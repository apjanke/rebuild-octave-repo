# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1310936368 -7200
#      Sun Jul 17 22:59:28 2011 +0200
# Node ID c70511cf64ee408e2f231ccbe4d0d7a5c884b194
# Parent  3a26a0ad2df95e1d17a63509f81187981ace32a5
Reformatted to GNU Style.

diff --git a/gui/src/BrowserWidget.cpp b/gui/src/BrowserWidget.cpp
--- a/gui/src/BrowserWidget.cpp
+++ b/gui/src/BrowserWidget.cpp
@@ -17,61 +17,75 @@
  */
 
 #include "BrowserWidget.h"
 #include <QVBoxLayout>
 #include <QAction>
 #include <QStyle>
 #include <QApplication>
 
-BrowserWidget::BrowserWidget(QWidget *parent)
-    : QWidget(parent) {
-    construct();
+BrowserWidget::BrowserWidget (QWidget * parent):QWidget (parent)
+{
+  construct ();
 }
 
-void BrowserWidget::construct() {
-    QStyle *style = QApplication::style();
-    m_navigationToolBar = new QToolBar(this);
-    m_webView = new QWebView(this);
-    m_urlLineEdit = new QLineEdit(this);
-    m_statusBar = new QStatusBar(this);
+void
+BrowserWidget::construct ()
+{
+  QStyle *style = QApplication::style ();
+  m_navigationToolBar = new QToolBar (this);
+  m_webView = new QWebView (this);
+  m_urlLineEdit = new QLineEdit (this);
+  m_statusBar = new QStatusBar (this);
 
-    m_webView->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-    QAction *backAction = new QAction(style->standardIcon(QStyle::SP_ArrowLeft),
-        "", m_navigationToolBar);
-    QAction *forwardAction = new QAction(style->standardIcon(QStyle::SP_ArrowRight),
-        "", m_navigationToolBar);
+  m_webView->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);
+  QAction *backAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowLeft),
+		 "", m_navigationToolBar);
+  QAction *forwardAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowRight),
+		 "", m_navigationToolBar);
 
-    m_navigationToolBar->addAction(backAction);
-    m_navigationToolBar->addAction(forwardAction);
-    m_navigationToolBar->addWidget(m_urlLineEdit);
+  m_navigationToolBar->addAction (backAction);
+  m_navigationToolBar->addAction (forwardAction);
+  m_navigationToolBar->addWidget (m_urlLineEdit);
 
-    QVBoxLayout *layout = new QVBoxLayout();
-    layout->addWidget(m_navigationToolBar);
-    layout->addWidget(m_webView);
-    layout->addWidget(m_statusBar);
-    layout->setMargin(2);
-    setLayout(layout);
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_navigationToolBar);
+  layout->addWidget (m_webView);
+  layout->addWidget (m_statusBar);
+  layout->setMargin (2);
+  setLayout (layout);
 
-    connect(backAction, SIGNAL(triggered()), m_webView, SLOT(back()));
-    connect(forwardAction, SIGNAL(triggered()), m_webView, SLOT(forward()));
-    connect(m_webView, SIGNAL(urlChanged(QUrl)), this, SLOT(setUrl(QUrl)));
-    connect(m_urlLineEdit, SIGNAL(returnPressed()), this, SLOT(jumpToWebsite()));
+  connect (backAction, SIGNAL (triggered ()), m_webView, SLOT (back ()));
+  connect (forwardAction, SIGNAL (triggered ()), m_webView,
+	   SLOT (forward ()));
+  connect (m_webView, SIGNAL (urlChanged (QUrl)), this, SLOT (setUrl (QUrl)));
+  connect (m_urlLineEdit, SIGNAL (returnPressed ()), this,
+	   SLOT (jumpToWebsite ()));
 }
 
-void BrowserWidget::setUrl(QUrl url) {
-    m_urlLineEdit->setText(url.toString());
+void
+BrowserWidget::setUrl (QUrl url)
+{
+  m_urlLineEdit->setText (url.toString ());
 }
 
-void BrowserWidget::jumpToWebsite() {
-    QString url = m_urlLineEdit->text();
-    if(!url.startsWith("http://"))
-        url = "http://" + url;
-    load(url);
+void
+BrowserWidget::jumpToWebsite ()
+{
+  QString url = m_urlLineEdit->text ();
+  if (!url.startsWith ("http://"))
+    url = "http://" + url;
+  load (url);
 }
 
-void BrowserWidget::showStatusMessage(QString message) {
-    m_statusBar->showMessage(message, 1000);
+void
+BrowserWidget::showStatusMessage (QString message)
+{
+  m_statusBar->showMessage (message, 1000);
 }
 
-void BrowserWidget::load(QUrl url) {
-    m_webView->load(url);
+void
+BrowserWidget::load (QUrl url)
+{
+  m_webView->load (url);
 }
diff --git a/gui/src/BrowserWidget.h b/gui/src/BrowserWidget.h
--- a/gui/src/BrowserWidget.h
+++ b/gui/src/BrowserWidget.h
@@ -20,29 +20,28 @@
 #define BROWSERMDISUBWINDOW_H
 
 #include <QWidget>
 #include <QToolBar>
 #include <QLineEdit>
 #include <QtWebKit/QWebView>
 #include <QStatusBar>
 
-class BrowserWidget : public QWidget {
-    Q_OBJECT
-public:
-    BrowserWidget(QWidget *parent = 0);
-    void load(QUrl url);
+class BrowserWidget:public QWidget
+{
+Q_OBJECT public:
+  BrowserWidget (QWidget * parent = 0);
+  void load (QUrl url);
 
-public slots:
-    void setUrl(QUrl url);
-    void jumpToWebsite();
-    void showStatusMessage(QString message);
+  public slots:void setUrl (QUrl url);
+  void jumpToWebsite ();
+  void showStatusMessage (QString message);
 
 private:
-    void construct();
+  void construct ();
 
-    QLineEdit *m_urlLineEdit;
-    QToolBar *m_navigationToolBar;
-    QWebView *m_webView;
-    QStatusBar *m_statusBar;
+  QLineEdit *m_urlLineEdit;
+  QToolBar *m_navigationToolBar;
+  QWebView *m_webView;
+  QStatusBar *m_statusBar;
 };
 
 #endif // BROWSERMDISUBWINDOW_H
diff --git a/gui/src/FileEditorMdiSubWindow.cpp b/gui/src/FileEditorMdiSubWindow.cpp
--- a/gui/src/FileEditorMdiSubWindow.cpp
+++ b/gui/src/FileEditorMdiSubWindow.cpp
@@ -21,205 +21,244 @@
 #include <QApplication>
 #include <QFile>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QAction>
 #include <QStyle>
 #include <QTextStream>
 
-FileEditorMdiSubWindow::FileEditorMdiSubWindow(QWidget *parent)
-    : QMdiSubWindow(parent) {
-    construct();
+FileEditorMdiSubWindow::FileEditorMdiSubWindow (QWidget * parent):QMdiSubWindow
+  (parent)
+{
+  construct ();
 }
 
-FileEditorMdiSubWindow::~FileEditorMdiSubWindow() {
-    while(checkFileModified("Close File")) {
-    } // don't close if something went wrong while saving the file
+FileEditorMdiSubWindow::~FileEditorMdiSubWindow ()
+{
+  while (checkFileModified ("Close File"))
+    {
+    }				// don't close if something went wrong while saving the file
 }
 
-void FileEditorMdiSubWindow::loadFile(QString fileName) {    
-    QFile file(fileName);
-    if (!file.open(QFile::ReadOnly)) {
-        QMessageBox::warning(this, tr("File Editor"),
-                             tr("Cannot read file %1:\n%2.")
-                             .arg(fileName)
-                             .arg(file.errorString()));
-        return;
+void
+FileEditorMdiSubWindow::loadFile (QString fileName)
+{
+  QFile file (fileName);
+  if (!file.open (QFile::ReadOnly))
+    {
+      QMessageBox::warning (this, tr ("File Editor"),
+			    tr ("Cannot read file %1:\n%2.").arg (fileName).
+			    arg (file.errorString ()));
+      return;
     }
 
-    QTextStream in(&file);
-    QApplication::setOverrideCursor(Qt::WaitCursor);
-    m_editor->setText(in.readAll());
-    QApplication::restoreOverrideCursor();
+  QTextStream in (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  m_editor->setText (in.readAll ());
+  QApplication::restoreOverrideCursor ();
+
+  m_fileName = fileName;
+  setWindowTitle (fileName);
+  m_statusBar->showMessage (tr ("File loaded."), 2000);
+  m_editor->setModified (false);
+}
 
-    m_fileName = fileName;
-    setWindowTitle(fileName);
-    m_statusBar->showMessage(tr("File loaded."), 2000);
-    m_editor->setModified(false);
+void
+FileEditorMdiSubWindow::newFile ()
+{
+  if (checkFileModified ("Open New File"))
+    {
+      return;			// something went wrong while saving the old file
+    }
+  m_fileName = "<unnamed>";
+  setWindowTitle (m_fileName);
+  m_editor->setText ("");
+  m_editor->setModified (false);
 }
 
-void FileEditorMdiSubWindow::newFile() {
-    if(checkFileModified("Open New File")) {
-        return;  // something went wrong while saving the old file
-    }
-    m_fileName = "<unnamed>";
-    setWindowTitle(m_fileName);
-    m_editor->setText("");
-    m_editor->setModified(false);
-}
+int
+FileEditorMdiSubWindow::checkFileModified (QString msg)
+{
+  if (m_editor->isModified ())
+    {
+      int decision = QMessageBox::question (this,
+					    msg,
+					    "Do you want to save the current file?",
+					    QMessageBox::Yes,
+					    QMessageBox::No);
 
-int FileEditorMdiSubWindow::checkFileModified(QString msg) {
-    if(m_editor->isModified()) {
-        int decision
-                = QMessageBox::question(this,
-                                        msg,
-                                        "Do you want to save the current file?",
-                                        QMessageBox::Yes, QMessageBox::No);
-
-        if(decision == QMessageBox::Yes) {
-            saveFile();
-            if(m_editor->isModified()) {
-                // If the user attempted to save the file, but it's still
-                // modified, then probably something went wrong, so return error
-                return(1);
-            }
-        }
+      if (decision == QMessageBox::Yes)
+	{
+	  saveFile ();
+	  if (m_editor->isModified ())
+	    {
+	      // If the user attempted to save the file, but it's still
+	      // modified, then probably something went wrong, so return error
+	      return (1);
+	    }
+	}
     }
-    return(0);
+  return (0);
 }
 
-void FileEditorMdiSubWindow::saveFile() {
-    if(m_fileName.isEmpty()) {
-        m_fileName = QFileDialog::getSaveFileName(this, "Save File", m_fileName);
-        if(m_fileName.isEmpty())
-            return;
+void
+FileEditorMdiSubWindow::saveFile ()
+{
+  if (m_fileName.isEmpty ())
+    {
+      m_fileName =
+	QFileDialog::getSaveFileName (this, "Save File", m_fileName);
+      if (m_fileName.isEmpty ())
+	return;
     }
 
-    QFile file(m_fileName);
-    if (!file.open(QFile::WriteOnly)) {
-        QMessageBox::warning(this, tr("File Editor"),
-                             tr("Cannot write file %1:\n%2.")
-                             .arg(m_fileName)
-                             .arg(file.errorString()));
-        return;
+  QFile file (m_fileName);
+  if (!file.open (QFile::WriteOnly))
+    {
+      QMessageBox::warning (this, tr ("File Editor"),
+			    tr ("Cannot write file %1:\n%2.").
+			    arg (m_fileName).arg (file.errorString ()));
+      return;
     }
 
-    QTextStream out(&file);
-    QApplication::setOverrideCursor(Qt::WaitCursor);
-    out << m_editor->text();
-    QApplication::restoreOverrideCursor();
-    m_statusBar->showMessage(tr("File saved"), 2000);
+  QTextStream out (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  out << m_editor->text ();
+  QApplication::restoreOverrideCursor ();
+  m_statusBar->showMessage (tr ("File saved"), 2000);
 }
 
-void FileEditorMdiSubWindow::saveFileAs() {/*
-    QString saveFileName = QFileDialog::getSaveFileName(this, "Save File", m_fileName);
-    if(saveFileName.isEmpty())
-        return;
+void
+FileEditorMdiSubWindow::saveFileAs ()
+{				/*
+				   QString saveFileName = QFileDialog::getSaveFileName(this, "Save File", m_fileName);
+				   if(saveFileName.isEmpty())
+				   return;
 
-    QFile file(saveFileName);
-    file.open(QFile::WriteOnly);
+				   QFile file(saveFileName);
+				   file.open(QFile::WriteOnly);
 
-    if(file.write(m_simpleEditor->toPlainText().toLocal8Bit()) == -1) {
-        QMessageBox::warning(this,
-                             "Error Saving File",
-                             QString("The file could not be saved: %1.").arg(file.errorString()));
-    } else {
-        m_simpleEditor->document()->setModified(false);
-        m_fileName = saveFileName;
-        setWindowTitle(m_fileName);
-    }
+				   if(file.write(m_simpleEditor->toPlainText().toLocal8Bit()) == -1) {
+				   QMessageBox::warning(this,
+				   "Error Saving File",
+				   QString("The file could not be saved: %1.").arg(file.errorString()));
+				   } else {
+				   m_simpleEditor->document()->setModified(false);
+				   m_fileName = saveFileName;
+				   setWindowTitle(m_fileName);
+				   }
 
-    file.close();*/
+				   file.close(); */
 }
 
-void FileEditorMdiSubWindow::showToolTipNew() {
-    m_statusBar->showMessage("Create a new file.", 2000);
+void
+FileEditorMdiSubWindow::showToolTipNew ()
+{
+  m_statusBar->showMessage ("Create a new file.", 2000);
 }
 
-void FileEditorMdiSubWindow::showToolTipSave() {
-    m_statusBar->showMessage("Save the file.", 2000);
+void
+FileEditorMdiSubWindow::showToolTipSave ()
+{
+  m_statusBar->showMessage ("Save the file.", 2000);
 }
 
-void FileEditorMdiSubWindow::showToolTipSaveAs() {
-    m_statusBar->showMessage("Save the file as.", 2000);
+void
+FileEditorMdiSubWindow::showToolTipSaveAs ()
+{
+  m_statusBar->showMessage ("Save the file as.", 2000);
 }
-void FileEditorMdiSubWindow::showToolTipUndo() {
-    m_statusBar->showMessage("Revert previous changes.", 2000);
+
+void
+FileEditorMdiSubWindow::showToolTipUndo ()
+{
+  m_statusBar->showMessage ("Revert previous changes.", 2000);
 }
 
-void FileEditorMdiSubWindow::showToolTipRedo() {
-    m_statusBar->showMessage("Append previous changes.", 2000);
+void
+FileEditorMdiSubWindow::showToolTipRedo ()
+{
+  m_statusBar->showMessage ("Append previous changes.", 2000);
 }
 
-void FileEditorMdiSubWindow::registerModified(bool modified) {
-    m_modified = modified;
+void
+FileEditorMdiSubWindow::registerModified (bool modified)
+{
+  m_modified = modified;
 }
 
-void FileEditorMdiSubWindow::construct() {
-    QStyle *style = QApplication::style();
-    setWidget(new QWidget());
-    m_toolBar = new QToolBar(this);
-    m_statusBar = new QStatusBar(this);
-    m_editor = new QsciScintilla(this);
+void
+FileEditorMdiSubWindow::construct ()
+{
+  QStyle *style = QApplication::style ();
+  setWidget (new QWidget ());
+  m_toolBar = new QToolBar (this);
+  m_statusBar = new QStatusBar (this);
+  m_editor = new QsciScintilla (this);
 
 // Not available in the Debian repos yet!
 /*
     m_lexer = new QsciLexerOctave(m_editor);
     m_lexer->setDefaultFont(QFont("Monospace",9));
     m_lexer->setAutoIndentStyle(QsciScintilla::AiMaintain ||
                                 QsciScintilla::AiOpening  ||
                                 QsciScintilla::AiClosing);
     m_editor->setLexer(m_lexer);
 */
 
-    m_editor->setMarginType(1,QsciScintilla::TextMargin);
-    m_editor->setMarginType(2,QsciScintilla::SymbolMargin);
-    m_editor->setFolding(QsciScintilla::BoxedTreeFoldStyle,2);
-    m_editor->setMarginLineNumbers(1, true);
-    m_editor->setMarginWidth(1, "99999");
+  m_editor->setMarginType (1, QsciScintilla::TextMargin);
+  m_editor->setMarginType (2, QsciScintilla::SymbolMargin);
+  m_editor->setFolding (QsciScintilla::BoxedTreeFoldStyle, 2);
+  m_editor->setMarginLineNumbers (1, true);
+  m_editor->setMarginWidth (1, "99999");
+
+  m_editor->setBraceMatching (QsciScintilla::SloppyBraceMatch);
+  m_editor->setAutoIndent (true);
+  m_editor->setIndentationWidth (2);
+  m_editor->setIndentationsUseTabs (false);
+  m_editor->setAutoCompletionThreshold (2);
 
-    m_editor->setBraceMatching(QsciScintilla::SloppyBraceMatch);
-    m_editor->setAutoIndent(true);
-    m_editor->setIndentationWidth(2);
-    m_editor->setIndentationsUseTabs(false);
-    m_editor->setAutoCompletionThreshold(2);
-
-    QAction *newAction = new QAction(style->standardIcon(QStyle::SP_FileIcon),
-        "", m_toolBar);
-    QAction *saveAction = new QAction(style->standardIcon(QStyle::SP_DriveHDIcon),
-        "", m_toolBar);
-    QAction *saveActionAs = new QAction(style->standardIcon(QStyle::SP_DriveFDIcon),
-        "", m_toolBar);
-    QAction *undoAction = new QAction(style->standardIcon(QStyle::SP_ArrowLeft),
-        "", m_toolBar);
-    QAction *redoAction = new QAction(style->standardIcon(QStyle::SP_ArrowRight),
-        "", m_toolBar);
+  QAction *newAction = new QAction (style->standardIcon (QStyle::SP_FileIcon),
+				    "", m_toolBar);
+  QAction *saveAction =
+    new QAction (style->standardIcon (QStyle::SP_DriveHDIcon),
+		 "", m_toolBar);
+  QAction *saveActionAs =
+    new QAction (style->standardIcon (QStyle::SP_DriveFDIcon),
+		 "", m_toolBar);
+  QAction *undoAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowLeft),
+		 "", m_toolBar);
+  QAction *redoAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowRight),
+		 "", m_toolBar);
 
-    m_toolBar->addAction(newAction);
-    m_toolBar->addAction(saveAction);
-    m_toolBar->addAction(saveActionAs);
-    m_toolBar->addAction(undoAction);
-    m_toolBar->addAction(redoAction);
+  m_toolBar->addAction (newAction);
+  m_toolBar->addAction (saveAction);
+  m_toolBar->addAction (saveActionAs);
+  m_toolBar->addAction (undoAction);
+  m_toolBar->addAction (redoAction);
 
-    QVBoxLayout *layout = new QVBoxLayout();
-    layout->addWidget(m_toolBar);
-    layout->addWidget(m_editor);
-    layout->addWidget(m_statusBar);
-    layout->setMargin(2);
-    widget()->setLayout(layout);
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_toolBar);
+  layout->addWidget (m_editor);
+  layout->addWidget (m_statusBar);
+  layout->setMargin (2);
+  widget ()->setLayout (layout);
 
-    connect(newAction, SIGNAL(triggered()), this, SLOT(newFile()));
-    connect(undoAction, SIGNAL(triggered()), m_editor, SLOT(undo()));
-    connect(redoAction, SIGNAL(triggered()), m_editor, SLOT(redo()));
-    connect(saveAction, SIGNAL(triggered()), this, SLOT(saveFile()));
-    connect(saveActionAs, SIGNAL(triggered()), this, SLOT(saveFileAs()));
+  connect (newAction, SIGNAL (triggered ()), this, SLOT (newFile ()));
+  connect (undoAction, SIGNAL (triggered ()), m_editor, SLOT (undo ()));
+  connect (redoAction, SIGNAL (triggered ()), m_editor, SLOT (redo ()));
+  connect (saveAction, SIGNAL (triggered ()), this, SLOT (saveFile ()));
+  connect (saveActionAs, SIGNAL (triggered ()), this, SLOT (saveFileAs ()));
 
-    connect(newAction, SIGNAL(hovered()), this, SLOT(showToolTipNew()));
-    connect(undoAction, SIGNAL(hovered()), this, SLOT(showToolTipUndo()));
-    connect(redoAction, SIGNAL(hovered()), this, SLOT(showToolTipRedo()));
-    connect(saveAction, SIGNAL(hovered()), this, SLOT(showToolTipSave()));
-    connect(saveActionAs, SIGNAL(hovered()), this, SLOT(showToolTipSaveAs()));
+  connect (newAction, SIGNAL (hovered ()), this, SLOT (showToolTipNew ()));
+  connect (undoAction, SIGNAL (hovered ()), this, SLOT (showToolTipUndo ()));
+  connect (redoAction, SIGNAL (hovered ()), this, SLOT (showToolTipRedo ()));
+  connect (saveAction, SIGNAL (hovered ()), this, SLOT (showToolTipSave ()));
+  connect (saveActionAs, SIGNAL (hovered ()), this,
+	   SLOT (showToolTipSaveAs ()));
 
-    m_fileName = "";
-    setWindowTitle(m_fileName);
-    show();
+  m_fileName = "";
+  setWindowTitle (m_fileName);
+  show ();
 }
diff --git a/gui/src/FileEditorMdiSubWindow.h b/gui/src/FileEditorMdiSubWindow.h
--- a/gui/src/FileEditorMdiSubWindow.h
+++ b/gui/src/FileEditorMdiSubWindow.h
@@ -22,38 +22,37 @@
 #include <QMdiSubWindow>
 #include <QToolBar>
 #include <QStatusBar>
 #include <Qsci/qsciscintilla.h>
 // Not available in the Debian repos yet!
 // #include <Qsci/qscilexeroctave.h>
 #include <Qsci/qsciapis.h>
 
-class FileEditorMdiSubWindow : public QMdiSubWindow {
-    Q_OBJECT
-public:
-    FileEditorMdiSubWindow(QWidget *parent = 0);
-    ~FileEditorMdiSubWindow();
-    void loadFile(QString fileName);
+class FileEditorMdiSubWindow:public QMdiSubWindow
+{
+Q_OBJECT public:
+  FileEditorMdiSubWindow (QWidget * parent = 0);
+  ~FileEditorMdiSubWindow ();
+  void loadFile (QString fileName);
 
-public slots:
-    void newFile();
-    void saveFile();
-    void saveFileAs();
+  public slots:void newFile ();
+  void saveFile ();
+  void saveFileAs ();
 
-    void showToolTipNew();
-    void showToolTipSave();
-    void showToolTipSaveAs();
-    void showToolTipUndo();
-    void showToolTipRedo();
+  void showToolTipNew ();
+  void showToolTipSave ();
+  void showToolTipSaveAs ();
+  void showToolTipUndo ();
+  void showToolTipRedo ();
 
-    void registerModified(bool modified);
+  void registerModified (bool modified);
 private:
-    int checkFileModified(QString msg);
-    void construct();
-    QToolBar *m_toolBar;
-    QsciScintilla *m_editor;
-    QStatusBar *m_statusBar;
-    QString m_fileName;
-    bool m_modified;
+  int checkFileModified (QString msg);
+  void construct ();
+  QToolBar *m_toolBar;
+  QsciScintilla *m_editor;
+  QStatusBar *m_statusBar;
+  QString m_fileName;
+  bool m_modified;
 };
 
 #endif // FILEEDITORMDISUBWINDOW_H
diff --git a/gui/src/FilesDockWidget.cpp b/gui/src/FilesDockWidget.cpp
--- a/gui/src/FilesDockWidget.cpp
+++ b/gui/src/FilesDockWidget.cpp
@@ -17,101 +17,128 @@
  */
 
 #include "FilesDockWidget.h"
 
 #include <QApplication>
 #include <QFileInfo>
 #include <QCompleter>
 
-FilesDockWidget::FilesDockWidget(QWidget *parent)
-  : QDockWidget(parent) {
-    setObjectName("FilesDockWidget");
-    setWindowTitle(tr("Current Folder"));
-    setWidget(new QWidget(this));
+FilesDockWidget::FilesDockWidget (QWidget * parent):QDockWidget (parent)
+{
+  setObjectName ("FilesDockWidget");
+  setWindowTitle (tr ("Current Folder"));
+  setWidget (new QWidget (this));
 
-    // Create a toolbar
-    m_navigationToolBar = new QToolBar("", widget());
-    m_navigationToolBar->setAllowedAreas(Qt::TopToolBarArea);
-    m_navigationToolBar->setMovable(false);
-    m_navigationToolBar->setIconSize(QSize (20,20));
+  // Create a toolbar
+  m_navigationToolBar = new QToolBar ("", widget ());
+  m_navigationToolBar->setAllowedAreas (Qt::TopToolBarArea);
+  m_navigationToolBar->setMovable (false);
+  m_navigationToolBar->setIconSize (QSize (20, 20));
 
-    // Add a button to the toolbar with the QT standard icon for up-directory
-    // TODO: Maybe change this to be an up-directory icon that is OS specific???
-    QStyle *style = QApplication::style();
-    m_directoryIcon = style->standardIcon(QStyle::SP_FileDialogToParent);
-    m_directoryUpAction = new QAction(m_directoryIcon, "", m_navigationToolBar);
-    m_currentDirectory = new QLineEdit(m_navigationToolBar);
+  // Add a button to the toolbar with the QT standard icon for up-directory
+  // TODO: Maybe change this to be an up-directory icon that is OS specific???
+  QStyle *
+    style = QApplication::style ();
+  m_directoryIcon = style->standardIcon (QStyle::SP_FileDialogToParent);
+  m_directoryUpAction =
+    new QAction (m_directoryIcon, "", m_navigationToolBar);
+  m_currentDirectory = new QLineEdit (m_navigationToolBar);
 
-    m_navigationToolBar->addAction(m_directoryUpAction);
-    m_navigationToolBar->addWidget(m_currentDirectory);
-    connect(m_directoryUpAction, SIGNAL(triggered()), this, SLOT(onUpDirectory()));
+  m_navigationToolBar->addAction (m_directoryUpAction);
+  m_navigationToolBar->addWidget (m_currentDirectory);
+  connect (m_directoryUpAction, SIGNAL (triggered ()), this,
+	   SLOT (onUpDirectory ()));
 
-    // TODO: Add other buttons for creating directories
+  // TODO: Add other buttons for creating directories
+
+  // Create the QFileSystemModel starting in the home directory
+  QString
+    homePath = QDir::homePath ();
+  // TODO: This should occur after Octave has been initialized and the startup directory of Octave is established
 
-    // Create the QFileSystemModel starting in the home directory
-    QString homePath = QDir::homePath();
-    // TODO: This should occur after Octave has been initialized and the startup directory of Octave is established
+  m_fileSystemModel = new QFileSystemModel (this);
+  m_fileSystemModel->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
+  QModelIndex
+    rootPathIndex = m_fileSystemModel->setRootPath (homePath);
 
-    m_fileSystemModel = new QFileSystemModel(this);
-    m_fileSystemModel->setFilter(QDir::NoDotAndDotDot | QDir::AllEntries);
-    QModelIndex rootPathIndex = m_fileSystemModel->setRootPath(homePath);
+  // Attach the model to the QTreeView and set the root index
+  m_fileTreeView = new QTreeView (widget ());
+  m_fileTreeView->setModel (m_fileSystemModel);
+  m_fileTreeView->setRootIndex (rootPathIndex);
+  m_fileTreeView->setSortingEnabled (true);
+  m_fileTreeView->setAlternatingRowColors (true);
+  m_fileTreeView->setAnimated (true);
+  setCurrentDirectory (m_fileSystemModel->fileInfo (rootPathIndex).
+		       absoluteFilePath ());
 
-    // Attach the model to the QTreeView and set the root index
-    m_fileTreeView = new QTreeView(widget());
-    m_fileTreeView->setModel(m_fileSystemModel);
-    m_fileTreeView->setRootIndex(rootPathIndex);
-    m_fileTreeView->setSortingEnabled(true);
-    m_fileTreeView->setAlternatingRowColors(true);
-    m_fileTreeView->setAnimated(true);
-    setCurrentDirectory(m_fileSystemModel->fileInfo(rootPathIndex).absoluteFilePath());
-
-    connect(m_fileTreeView, SIGNAL(doubleClicked(const QModelIndex &)), this, SLOT(itemDoubleClicked(const QModelIndex &)));
+  connect (m_fileTreeView, SIGNAL (doubleClicked (const QModelIndex &)), this,
+	   SLOT (itemDoubleClicked (const QModelIndex &)));
 
-    // Layout the widgets vertically with the toolbar on top
-    QVBoxLayout *layout = new QVBoxLayout();
-    layout->setSpacing(0);
-    layout->addWidget(m_navigationToolBar);
-    layout->addWidget(m_fileTreeView);
-    widget()->setLayout(layout);
-    // TODO: Add right-click contextual menus for copying, pasting, deleting files (and others)
+  // Layout the widgets vertically with the toolbar on top
+  QVBoxLayout *
+    layout = new QVBoxLayout ();
+  layout->setSpacing (0);
+  layout->addWidget (m_navigationToolBar);
+  layout->addWidget (m_fileTreeView);
+  widget ()->setLayout (layout);
+  // TODO: Add right-click contextual menus for copying, pasting, deleting files (and others)
 
-    connect(m_currentDirectory, SIGNAL(returnPressed()), this, SLOT(currentDirectoryEntered()));
-    QCompleter *completer = new QCompleter(m_fileSystemModel, this);
-    m_currentDirectory->setCompleter(completer);
+  connect (m_currentDirectory, SIGNAL (returnPressed ()), this,
+	   SLOT (currentDirectoryEntered ()));
+  QCompleter *
+    completer = new QCompleter (m_fileSystemModel, this);
+  m_currentDirectory->setCompleter (completer);
 }
 
-void FilesDockWidget::itemDoubleClicked(const QModelIndex &index)
+void
+FilesDockWidget::itemDoubleClicked (const QModelIndex & index)
 {
-    QFileInfo fileInfo = m_fileSystemModel->fileInfo(index);
-    if (fileInfo.isDir()) {
-        m_fileSystemModel->setRootPath(fileInfo.absolutePath());
-        m_fileTreeView->setRootIndex(index);
-        setCurrentDirectory(m_fileSystemModel->fileInfo(index).absoluteFilePath());
-    } else {
-        QFileInfo fileInfo = m_fileSystemModel->fileInfo(index);
-        emit openFile(fileInfo.filePath());
+  QFileInfo fileInfo = m_fileSystemModel->fileInfo (index);
+  if (fileInfo.isDir ())
+    {
+      m_fileSystemModel->setRootPath (fileInfo.absolutePath ());
+      m_fileTreeView->setRootIndex (index);
+      setCurrentDirectory (m_fileSystemModel->fileInfo (index).
+			   absoluteFilePath ());
+    }
+  else
+    {
+      QFileInfo fileInfo = m_fileSystemModel->fileInfo (index);
+      emit openFile (fileInfo.filePath ());
     }
 }
 
-void FilesDockWidget::setCurrentDirectory(QString currentDirectory) {
-    m_currentDirectory->setText(currentDirectory);
+void
+FilesDockWidget::setCurrentDirectory (QString currentDirectory)
+{
+  m_currentDirectory->setText (currentDirectory);
 }
 
-void FilesDockWidget::onUpDirectory(void) {
-    QDir dir = QDir(m_fileSystemModel->filePath(m_fileTreeView->rootIndex()));
-    dir.cdUp();
-    m_fileSystemModel->setRootPath(dir.absolutePath());
-    m_fileTreeView->setRootIndex(m_fileSystemModel->index(dir.absolutePath()));
-    setCurrentDirectory(dir.absolutePath());
+void
+FilesDockWidget::onUpDirectory (void)
+{
+  QDir dir =
+    QDir (m_fileSystemModel->filePath (m_fileTreeView->rootIndex ()));
+  dir.cdUp ();
+  m_fileSystemModel->setRootPath (dir.absolutePath ());
+  m_fileTreeView->setRootIndex (m_fileSystemModel->
+				index (dir.absolutePath ()));
+  setCurrentDirectory (dir.absolutePath ());
 }
 
-void FilesDockWidget::currentDirectoryEntered() {
-    QFileInfo fileInfo(m_currentDirectory->text());
-    if (fileInfo.isDir()) {
-        m_fileTreeView->setRootIndex(m_fileSystemModel->index(fileInfo.absolutePath()));
-        m_fileSystemModel->setRootPath(fileInfo.absolutePath());
-        setCurrentDirectory(fileInfo.absoluteFilePath());
-    } else {
-        if(QFile::exists(fileInfo.absoluteFilePath()))
-            emit openFile(fileInfo.absoluteFilePath());
+void
+FilesDockWidget::currentDirectoryEntered ()
+{
+  QFileInfo fileInfo (m_currentDirectory->text ());
+  if (fileInfo.isDir ())
+    {
+      m_fileTreeView->setRootIndex (m_fileSystemModel->
+				    index (fileInfo.absolutePath ()));
+      m_fileSystemModel->setRootPath (fileInfo.absolutePath ());
+      setCurrentDirectory (fileInfo.absoluteFilePath ());
+    }
+  else
+    {
+      if (QFile::exists (fileInfo.absoluteFilePath ()))
+	emit openFile (fileInfo.absoluteFilePath ());
     }
 }
diff --git a/gui/src/FilesDockWidget.h b/gui/src/FilesDockWidget.h
--- a/gui/src/FilesDockWidget.h
+++ b/gui/src/FilesDockWidget.h
@@ -41,46 +41,44 @@
 #undef PACKAGE_VERSION
 #include "octave/config.h"
 #include "octave/octave.h"
 #include "octave/str-vec.h"
 #include "octave/cmd-hist.h"
 #include <QDockWidget>
 #include <QLineEdit>
 
-class FilesDockWidget : public QDockWidget {
-    Q_OBJECT
-public :
-    FilesDockWidget(QWidget *parent = 0);
-public slots:
+class FilesDockWidget:public QDockWidget
+{
+  Q_OBJECT public:FilesDockWidget (QWidget * parent = 0);
+  public slots:
     /** Slot for handling a change in directory via double click. */
-    void itemDoubleClicked(const QModelIndex &index);
+  void itemDoubleClicked (const QModelIndex & index);
 
     /** Slot for handling the up-directory button in the toolbar. */
-    void onUpDirectory();
+  void onUpDirectory ();
 
-    void setCurrentDirectory(QString currentDirectory);
+  void setCurrentDirectory (QString currentDirectory);
 
-    void currentDirectoryEntered();
+  void currentDirectoryEntered ();
 
-signals:
-    void openFile(QString fileName);
+    signals:void openFile (QString fileName);
 
 private:
-    // TODO: Add toolbar with buttons for navigating the path, creating dirs, etc
+  // TODO: Add toolbar with buttons for navigating the path, creating dirs, etc
 
     /** Toolbar for file and directory manipulation. */
-    QToolBar *m_navigationToolBar;
+    QToolBar * m_navigationToolBar;
 
     /** Variables for the up-directory action. */
-    QIcon m_directoryIcon;
-    QAction *m_directoryUpAction;
-    QToolButton *upDirectoryButton;
+  QIcon m_directoryIcon;
+  QAction *m_directoryUpAction;
+  QToolButton *upDirectoryButton;
 
     /** The file system model. */
-    QFileSystemModel *m_fileSystemModel;
+  QFileSystemModel *m_fileSystemModel;
 
     /** The file system view. */
-    QTreeView *m_fileTreeView;
-    QLineEdit *m_currentDirectory;
+  QTreeView *m_fileTreeView;
+  QLineEdit *m_currentDirectory;
 };
 
 #endif // FILESDOCKWIDGET_H
diff --git a/gui/src/HistoryDockWidget.cpp b/gui/src/HistoryDockWidget.cpp
--- a/gui/src/HistoryDockWidget.cpp
+++ b/gui/src/HistoryDockWidget.cpp
@@ -14,48 +14,57 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "HistoryDockWidget.h"
 #include <QHBoxLayout>
 
-HistoryDockWidget::HistoryDockWidget(QWidget *parent)
-    : QDockWidget(parent) {
-    setObjectName("HistoryDockWidget");
-    construct();
+HistoryDockWidget::HistoryDockWidget (QWidget * parent):QDockWidget (parent)
+{
+  setObjectName ("HistoryDockWidget");
+  construct ();
 }
 
-void HistoryDockWidget::handleListViewItemDoubleClicked(QModelIndex modelIndex) {
-    QString command = m_historyListModel->data(modelIndex, 0).toString();
-    emit commandDoubleClicked(command);
+void
+HistoryDockWidget::handleListViewItemDoubleClicked (QModelIndex modelIndex)
+{
+  QString command = m_historyListModel->data (modelIndex, 0).toString ();
+  emit commandDoubleClicked (command);
 }
 
-void HistoryDockWidget::construct() {
-    m_historyListModel = new QStringListModel();
-    m_historyListView = new QListView(this);
-    m_historyListView->setModel(m_historyListModel);
-    m_historyListView->setAlternatingRowColors(true);
-    m_historyListView->setEditTriggers(QAbstractItemView::NoEditTriggers);
-    QHBoxLayout *layout = new QHBoxLayout();
+void
+HistoryDockWidget::construct ()
+{
+  m_historyListModel = new QStringListModel ();
+  m_historyListView = new QListView (this);
+  m_historyListView->setModel (m_historyListModel);
+  m_historyListView->setAlternatingRowColors (true);
+  m_historyListView->setEditTriggers (QAbstractItemView::NoEditTriggers);
+  QHBoxLayout *layout = new QHBoxLayout ();
 
-    setWindowTitle(tr("Command History"));
-    setWidget(new QWidget());
+  setWindowTitle (tr ("Command History"));
+  setWidget (new QWidget ());
 
-    layout->addWidget(m_historyListView);
-    layout->setMargin(2);
+  layout->addWidget (m_historyListView);
+  layout->setMargin (2);
 
-    widget()->setLayout(layout);
-    connect(m_historyListView, SIGNAL(doubleClicked(QModelIndex)), this, SLOT(handleListViewItemDoubleClicked(QModelIndex)));
+  widget ()->setLayout (layout);
+  connect (m_historyListView, SIGNAL (doubleClicked (QModelIndex)), this,
+	   SLOT (handleListViewItemDoubleClicked (QModelIndex)));
 }
 
-void HistoryDockWidget::updateHistory(string_vector historyEntries) {
-    QStringList stringList = m_historyListModel->stringList();
-    for(int i = 0; i < historyEntries.length(); i++) {
-        QString command(historyEntries[i].c_str());
-        if(!command.startsWith("#")) {
-            stringList.push_front(command);
-        }
+void
+HistoryDockWidget::updateHistory (string_vector historyEntries)
+{
+  QStringList stringList = m_historyListModel->stringList ();
+  for (int i = 0; i < historyEntries.length (); i++)
+    {
+      QString command (historyEntries[i].c_str ());
+      if (!command.startsWith ("#"))
+	{
+	  stringList.push_front (command);
+	}
     }
-    m_historyListModel->setStringList(stringList);
-    emit information(tr("History updated."));
+  m_historyListModel->setStringList (stringList);
+  emit information (tr ("History updated."));
 }
diff --git a/gui/src/HistoryDockWidget.h b/gui/src/HistoryDockWidget.h
--- a/gui/src/HistoryDockWidget.h
+++ b/gui/src/HistoryDockWidget.h
@@ -46,28 +46,26 @@
 #include "octave/sysdep.h"
 #include "octave/str-vec.h"
 #include "octave/cmd-hist.h"
 #include "octave/cmd-edit.h"
 #include "octave/oct-env.h"
 #include "octave/symtab.h"
 #include "cmd-edit.h"
 
-class HistoryDockWidget : public QDockWidget {
-    Q_OBJECT
-public:
-    HistoryDockWidget(QWidget *parent = 0);
-    void updateHistory(string_vector historyEntries);
+class HistoryDockWidget:public QDockWidget
+{
+Q_OBJECT public:
+  HistoryDockWidget (QWidget * parent = 0);
+  void updateHistory (string_vector historyEntries);
 
-signals:
-    void information(QString message);
-    void commandDoubleClicked(QString command);
+    signals:void information (QString message);
+  void commandDoubleClicked (QString command);
 
-private slots:
-    void handleListViewItemDoubleClicked(QModelIndex modelIndex);
+  private slots:void handleListViewItemDoubleClicked (QModelIndex modelIndex);
 
 private:
-    void construct();
-    QListView *m_historyListView;
-    QStringListModel *m_historyListModel;
+  void construct ();
+  QListView *m_historyListView;
+  QStringListModel *m_historyListModel;
 };
 
 #endif // HISTORYDOCKWIDGET_H
diff --git a/gui/src/IRCWidget.cpp b/gui/src/IRCWidget.cpp
--- a/gui/src/IRCWidget.cpp
+++ b/gui/src/IRCWidget.cpp
@@ -19,230 +19,324 @@
 #include "IRCWidget.h"
 #include <QMessageBox>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QLabel>
 #include <QSettings>
 #include <QInputDialog>
 
-IRCWidget::IRCWidget(QWidget *parent, QString settingsFile) :
-    QWidget(parent)
+IRCWidget::IRCWidget (QWidget * parent, QString settingsFile):
+QWidget (parent)
 {
-    m_settingsFile = settingsFile;
-    m_alternatingColor = false;
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    bool connectOnStartup = settings.value("connectOnStartup").toBool();
-    m_autoIdentification = settings.value("autoIdentification").toBool();
-    m_nickServPassword = settings.value("nickServPassword").toString();
+  m_settingsFile = settingsFile;
+  m_alternatingColor = false;
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  bool connectOnStartup = settings.value ("connectOnStartup").toBool ();
+  m_autoIdentification = settings.value ("autoIdentification").toBool ();
+  m_nickServPassword = settings.value ("nickServPassword").toString ();
 
-    m_initialNick = settings.value("IRCNick").toString();
+  m_initialNick = settings.value ("IRCNick").toString ();
+
+  if (m_initialNick.isEmpty ())
+    m_initialNick = "OctaveGUI-User";
+
+  QVBoxLayout *layout = new QVBoxLayout ();
 
-    if(m_initialNick.isEmpty())
-        m_initialNick = "OctaveGUI-User";
+  m_chatWindow = new QTextEdit (this);
+  m_chatWindow->setReadOnly (true);
+  m_chatWindow->setEnabled (false);
+  QWidget *bottomWidget = new QWidget (this);
 
-    QVBoxLayout *layout = new QVBoxLayout();
+  layout->addWidget (m_chatWindow);
+  layout->addWidget (bottomWidget);
+  setLayout (layout);
 
-    m_chatWindow = new QTextEdit(this);
-    m_chatWindow->setReadOnly(true);
-    m_chatWindow->setEnabled(false);
-    QWidget* bottomWidget = new QWidget(this);
-
-    layout->addWidget(m_chatWindow);
-    layout->addWidget(bottomWidget);
-    setLayout(layout);
+  QHBoxLayout *bottomLayout = new QHBoxLayout ();
+  m_nickButton = new QPushButton (bottomWidget);
+  m_nickButton->
+    setStatusTip (tr ((char *) "Click here to change your nick."));
+  m_nickButton->setText (m_initialNick);
+  m_inputLine = new QLineEdit (bottomWidget);
+  m_inputLine->setStatusTip (tr ((char *) "Enter your message here."));
+  bottomLayout->addWidget (m_nickButton);
+  bottomLayout->addWidget (new QLabel (":", this));
+  bottomLayout->addWidget (m_inputLine);
+  bottomLayout->setMargin (0);
+  bottomWidget->setLayout (bottomLayout);
+  m_nickButton->setEnabled (false);
+  m_inputLine->setEnabled (false);
 
-    QHBoxLayout *bottomLayout = new QHBoxLayout();
-    m_nickButton = new QPushButton(bottomWidget);
-    m_nickButton->setStatusTip(tr((char*)"Click here to change your nick."));
-    m_nickButton->setText(m_initialNick);
-    m_inputLine = new QLineEdit(bottomWidget);
-    m_inputLine->setStatusTip(tr((char*)"Enter your message here."));
-    bottomLayout->addWidget(m_nickButton);
-    bottomLayout->addWidget(new QLabel(":", this));
-    bottomLayout->addWidget(m_inputLine);
-    bottomLayout->setMargin(0);
-    bottomWidget->setLayout(bottomLayout);
-    m_nickButton->setEnabled(false);
-    m_inputLine->setEnabled(false);
+  m_chatWindow->setFocusProxy (m_inputLine);
+  m_nickButton->setFocusProxy (m_inputLine);
 
-    m_chatWindow->setFocusProxy(m_inputLine);
-    m_nickButton->setFocusProxy(m_inputLine);
+  QFont font;
+  font.setFamily ("Courier");
+  font.setPointSize (11);
+  m_chatWindow->setFont (font);
+  m_ircClient = new IRCClient ();
+
+  connect (m_nickButton, SIGNAL (clicked ()), this, SLOT (nickPopup ()));
+  connect (m_inputLine, SIGNAL (returnPressed ()), this,
+	   SLOT (sendInputLine ()));
 
-    QFont font;
-    font.setFamily("Courier");
-    font.setPointSize(11);
-    m_chatWindow->setFont(font);
-    m_ircClient = new IRCClient();
-
-    connect(m_nickButton, SIGNAL(clicked()), this, SLOT(nickPopup()));
-    connect(m_inputLine, SIGNAL(returnPressed()), this, SLOT(sendInputLine()));
+  connect (m_ircClient, SIGNAL (nickInUseChanged ()), this,
+	   SLOT (handleNickInUseChanged ()));
+  connect (m_ircClient, SIGNAL (connectionStatus (const char *)), this,
+	   SLOT (showStatusMessage (const char *)));
+  connect (m_ircClient, SIGNAL (error (const char *)), this,
+	   SLOT (showStatusMessage (const char *)));
+  connect (m_ircClient, SIGNAL (completedLogin (const char *)), this,
+	   SLOT (loginSuccessful (const char *)));
+  connect (m_ircClient, SIGNAL (completedLogin (const char *)), this,
+	   SLOT (joinOctaveChannel (const char *)));
+  connect (m_ircClient,
+	   SIGNAL (topic (const char *, const char *, const char *)), this,
+	   SLOT (showTopic (const char *, const char *, const char *)));
+  connect (m_ircClient, SIGNAL (join (const char *, const char *)), this,
+	   SLOT (showJoin (const char *, const char *)));
+  connect (m_ircClient, SIGNAL (quit (const char *, const char *)), this,
+	   SLOT (showQuit (const char *, const char *)));
+  connect (m_ircClient,
+	   SIGNAL (privateMessage (const char *, const char *, const char *)),
+	   this,
+	   SLOT (showPrivateMessage
+		 (const char *, const char *, const char *)));
+  connect (m_ircClient,
+	   SIGNAL (notice (const char *, const char *, const char *)), this,
+	   SLOT (showNotice (const char *, const char *, const char *)));
+  connect (m_ircClient, SIGNAL (nick (const char *, const char *)), this,
+	   SLOT (showNickChange (const char *, const char *)));
+  connect (m_ircClient, SIGNAL (replyCode (IRCEvent *)), this,
+	   SLOT (handleReplyCode (IRCEvent *)));
 
-    connect(m_ircClient, SIGNAL(nickInUseChanged()), this, SLOT(handleNickInUseChanged()));
-    connect(m_ircClient, SIGNAL(connectionStatus(const char*)), this, SLOT(showStatusMessage(const char*)));
-    connect(m_ircClient, SIGNAL(error(const char*)), this, SLOT(showStatusMessage(const char*)));
-    connect(m_ircClient, SIGNAL(completedLogin(const char*)), this, SLOT(loginSuccessful(const char*)));
-    connect(m_ircClient, SIGNAL(completedLogin(const char*)), this, SLOT(joinOctaveChannel(const char*)));
-    connect(m_ircClient, SIGNAL(topic(const char*,const char*,const char*)), this, SLOT(showTopic(const char*,const char*,const char*)));
-    connect(m_ircClient, SIGNAL(join(const char*,const char*)), this, SLOT(showJoin(const char*, const char*)));
-    connect(m_ircClient, SIGNAL(quit(const char*,const char*)), this, SLOT(showQuit(const char*,const char*)));
-    connect(m_ircClient, SIGNAL(privateMessage(const char*,const char*,const char*)), this, SLOT(showPrivateMessage(const char*,const char*,const char*)));
-    connect(m_ircClient, SIGNAL(notice(const char*,const char*,const char*)), this, SLOT(showNotice(const char*,const char*,const char*)));
-    connect(m_ircClient, SIGNAL(nick(const char*,const char*)), this, SLOT(showNickChange(const char*, const char*)));
-    connect(m_ircClient, SIGNAL(replyCode(IRCEvent*)), this, SLOT(handleReplyCode(IRCEvent*)));
-
-    if(connectOnStartup)
-        connectToServer();
+  if (connectOnStartup)
+    connectToServer ();
 }
 
-void IRCWidget::connectToServer() {
-    m_ircClient->connectToServer("irc.freenode.net", 6667,
-                                 m_initialNick.toStdString().c_str(),
-                                 m_initialNick.toStdString().c_str(),
-                                 "Unknown", "Unknown", 0, 0);
+void
+IRCWidget::connectToServer ()
+{
+  m_ircClient->connectToServer ("irc.freenode.net", 6667,
+				m_initialNick.toStdString ().c_str (),
+				m_initialNick.toStdString ().c_str (),
+				"Unknown", "Unknown", 0, 0);
 }
 
-void IRCWidget::showStatusMessage(const char *message) {
-    m_chatWindow->append(QString("<i>%1</i>").arg(message));
+void
+IRCWidget::showStatusMessage (const char *message)
+{
+  m_chatWindow->append (QString ("<i>%1</i>").arg (message));
 }
 
-void IRCWidget::joinOctaveChannel(const char*) {
-    m_ircClient->joinChannel("#octave");
+void
+IRCWidget::joinOctaveChannel (const char *)
+{
+  m_ircClient->joinChannel ("#octave");
 }
 
-void IRCWidget::loginSuccessful(const char *nick) {
-    m_chatWindow->append(QString("<i><font color=\"#00AA00\"><b>Successfully logged in as %1.</b></font></i>").arg(nick));
-    m_nickButton->setEnabled(true);
-    m_inputLine->setEnabled(true);
-    m_chatWindow->setEnabled(true);
-    m_inputLine->setFocus();
+void
+IRCWidget::loginSuccessful (const char *nick)
+{
+  m_chatWindow->
+    append (QString
+	    ("<i><font color=\"#00AA00\"><b>Successfully logged in as %1.</b></font></i>").
+	    arg (nick));
+  m_nickButton->setEnabled (true);
+  m_inputLine->setEnabled (true);
+  m_chatWindow->setEnabled (true);
+  m_inputLine->setFocus ();
 
-    if(m_autoIdentification)
-    m_ircClient->sendCommand(2, COMMAND_PRIVMSG,
-                             "NickServ",
-                             QString("identify %1").arg(m_nickServPassword).toStdString().c_str());
+  if (m_autoIdentification)
+    m_ircClient->sendCommand (2, COMMAND_PRIVMSG,
+			      "NickServ",
+			      QString ("identify %1").
+			      arg (m_nickServPassword).toStdString ().
+			      c_str ());
 }
 
-void IRCWidget::showPrivateMessage(const char *nick, const char *destination, const char *message) {
-    Q_UNUSED(destination);
-    QString msg(message);
-    if(msg.contains(m_ircClient->nickInUse())) {
-        msg = QString("<font color=\"#990000\"><b>%1:</b> %2</font>").arg(nick).arg(msg);
-    } else {
-        msg = QString("<font color=\"%3\"><b>%1:</b> %2</font>").arg(nick).arg(msg).arg(getAlternatingColor());
+void
+IRCWidget::showPrivateMessage (const char *nick, const char *destination,
+			       const char *message)
+{
+  Q_UNUSED (destination);
+  QString msg (message);
+  if (msg.contains (m_ircClient->nickInUse ()))
+    {
+      msg =
+	QString ("<font color=\"#990000\"><b>%1:</b> %2</font>").arg (nick).
+	arg (msg);
     }
-    m_chatWindow->append(msg);
-}
-
-void IRCWidget::showNotice(const char *nick, const char *destination, const char *message) {
-    Q_UNUSED(nick);
-    Q_UNUSED(destination);
-    m_chatWindow->append(QString("<font color=\"#007700\">%1</font>").arg(message));
+  else
+    {
+      msg =
+	QString ("<font color=\"%3\"><b>%1:</b> %2</font>").arg (nick).
+	arg (msg).arg (getAlternatingColor ());
+    }
+  m_chatWindow->append (msg);
 }
 
-void IRCWidget::showTopic(const char *nick, const char *channel, const char *message) {
-    m_chatWindow->append(QString("Topic for %2 was set by %1: %3").arg(nick).arg(channel).arg(message));
+void
+IRCWidget::showNotice (const char *nick, const char *destination,
+		       const char *message)
+{
+  Q_UNUSED (nick);
+  Q_UNUSED (destination);
+  m_chatWindow->append (QString ("<font color=\"#007700\">%1</font>").
+			arg (message));
+}
+
+void
+IRCWidget::showTopic (const char *nick, const char *channel,
+		      const char *message)
+{
+  m_chatWindow->append (QString ("Topic for %2 was set by %1: %3").arg (nick).
+			arg (channel).arg (message));
 }
 
-void IRCWidget::showNickChange(const char *oldNick, const char *newNick) {
-    m_chatWindow->append(QString("%1 is now known as %2.").arg(oldNick).arg(newNick));
-    m_nickList.removeAll(QString(oldNick));
-    m_nickList.append(QString(newNick));
-    updateNickCompleter();
+void
+IRCWidget::showNickChange (const char *oldNick, const char *newNick)
+{
+  m_chatWindow->append (QString ("%1 is now known as %2.").arg (oldNick).
+			arg (newNick));
+  m_nickList.removeAll (QString (oldNick));
+  m_nickList.append (QString (newNick));
+  updateNickCompleter ();
 }
 
-void IRCWidget::nickPopup() {
-    bool ok;
-    QString newNick = QInputDialog::getText(this, QString("Nickname"), QString("Type in your nickname:"),
-                           QLineEdit::Normal, m_ircClient->nickInUse(), &ok);
-    if(ok) {
-        m_ircClient->sendNickChange(newNick);
+void
+IRCWidget::nickPopup ()
+{
+  bool ok;
+  QString newNick =
+    QInputDialog::getText (this, QString ("Nickname"),
+			   QString ("Type in your nickname:"),
+			   QLineEdit::Normal, m_ircClient->nickInUse (), &ok);
+  if (ok)
+    {
+      m_ircClient->sendNickChange (newNick);
     }
 }
 
-void IRCWidget::showJoin(const char *nick, const char *channel) {
-    m_chatWindow->append(QString("<i>%1 has joined %2.</i>").arg(nick).arg(channel));
-    m_nickList.append(QString(nick));
-    updateNickCompleter();
+void
+IRCWidget::showJoin (const char *nick, const char *channel)
+{
+  m_chatWindow->append (QString ("<i>%1 has joined %2.</i>").arg (nick).
+			arg (channel));
+  m_nickList.append (QString (nick));
+  updateNickCompleter ();
 }
 
-void IRCWidget::showQuit(const char *nick, const char *reason) {
-    m_chatWindow->append(QString("<i>%1 has quit.(%2).</i>").arg(nick).arg(reason));
-    m_nickList.removeAll(QString(nick));
-    updateNickCompleter();
+void
+IRCWidget::showQuit (const char *nick, const char *reason)
+{
+  m_chatWindow->append (QString ("<i>%1 has quit.(%2).</i>").arg (nick).
+			arg (reason));
+  m_nickList.removeAll (QString (nick));
+  updateNickCompleter ();
 }
 
-void IRCWidget::sendMessage(QString message) {
-    // Do not send empty messages.
-    if(message.isEmpty())
-        return;
+void
+IRCWidget::sendMessage (QString message)
+{
+  // Do not send empty messages.
+  if (message.isEmpty ())
+    return;
 
-    // Remove trailing spaces.
-    while(message.at(0).isSpace()) message.remove(0, 1);
-    if(message.startsWith("/")) {
-        QStringList line = message.split(QRegExp("\\s+"), QString::SkipEmptyParts);
-        if(line.at(0) == "/join") {
-            m_ircClient->joinChannel(line.at(1));
-        } else if(line.at(0) == "/nick") {
-            m_ircClient->sendNickChange(line.at(1));
-        } else if(line.at(0) == "/msg") {
-            QString recipient = line.at(1);
-            // Since we splitted the message before, we have to glue it together again.
-            QString pmsg = "";
-            for(int i=2; i < line.length(); i++) {
-                pmsg += line.at(i);
-                pmsg += " ";
-            }
-            m_ircClient->sendCommand(2, COMMAND_PRIVMSG,
-                                     recipient.toStdString().c_str(),
-                                     pmsg.toStdString().c_str());
-        }
-    } else {
-        m_ircClient->sendPublicMessage(message);
-        m_chatWindow->append(QString("<b>%1:</b> %2").arg(m_ircClient->nickInUse()).arg(message));
+  // Remove trailing spaces.
+  while (message.at (0).isSpace ())
+    message.remove (0, 1);
+  if (message.startsWith ("/"))
+    {
+      QStringList line =
+	message.split (QRegExp ("\\s+"), QString::SkipEmptyParts);
+      if (line.at (0) == "/join")
+	{
+	  m_ircClient->joinChannel (line.at (1));
+	}
+      else if (line.at (0) == "/nick")
+	{
+	  m_ircClient->sendNickChange (line.at (1));
+	}
+      else if (line.at (0) == "/msg")
+	{
+	  QString recipient = line.at (1);
+	  // Since we splitted the message before, we have to glue it together again.
+	  QString pmsg = "";
+	  for (int i = 2; i < line.length (); i++)
+	    {
+	      pmsg += line.at (i);
+	      pmsg += " ";
+	    }
+	  m_ircClient->sendCommand (2, COMMAND_PRIVMSG,
+				    recipient.toStdString ().c_str (),
+				    pmsg.toStdString ().c_str ());
+	}
+    }
+  else
+    {
+      m_ircClient->sendPublicMessage (message);
+      m_chatWindow->append (QString ("<b>%1:</b> %2").
+			    arg (m_ircClient->nickInUse ()).arg (message));
     }
 }
 
-void IRCWidget::sendInputLine() {
-    sendMessage(m_inputLine->text());
-    m_inputLine->setText("");
+void
+IRCWidget::sendInputLine ()
+{
+  sendMessage (m_inputLine->text ());
+  m_inputLine->setText ("");
 }
 
-void IRCWidget::handleNickInUseChanged() {
-    m_nickButton->setText(m_ircClient->nickInUse());
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    settings.setValue("IRCNick", m_ircClient->nickInUse());
+void
+IRCWidget::handleNickInUseChanged ()
+{
+  m_nickButton->setText (m_ircClient->nickInUse ());
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  settings.setValue ("IRCNick", m_ircClient->nickInUse ());
 }
 
-void IRCWidget::handleReplyCode(IRCEvent *event) {
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
+void
+IRCWidget::handleReplyCode (IRCEvent * event)
+{
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
 
-    switch(event->getNumeric()) {
+  switch (event->getNumeric ())
+    {
     case RPL_MOTDSTART:
     case RPL_MOTD:
     case ERR_NOMOTD:
     case RPL_ENDOFMOTD:
-        if(settings.value("showMessageOfTheDay").toBool())
-            m_chatWindow->append(QString("<font color=\"#777777\">%1</font>").arg(event->getParam(1)));
-        break;
+      if (settings.value ("showMessageOfTheDay").toBool ())
+	m_chatWindow->append (QString ("<font color=\"#777777\">%1</font>").
+			      arg (event->getParam (1)));
+      break;
     case RPL_NOTOPIC:
     case RPL_TOPIC:
-        if(settings.value("showTopic").toBool())
-            m_chatWindow->append(QString("<font color=\"#000088\"><b>%1</b></font>").arg(event->getParam(2)));
-        break;
+      if (settings.value ("showTopic").toBool ())
+	m_chatWindow->
+	  append (QString ("<font color=\"#000088\"><b>%1</b></font>").
+		  arg (event->getParam (2)));
+      break;
     case RPL_NAMREPLY:
-        m_chatWindow->append(QString("<font color=\"#000088\">Users online: %1</font>").arg(event->getParam(3)));
-        m_nickList = event->getParam(3).split(QRegExp("\\s+"), QString::SkipEmptyParts);
-        updateNickCompleter();
-        break;
+      m_chatWindow->
+	append (QString ("<font color=\"#000088\">Users online: %1</font>").
+		arg (event->getParam (3)));
+      m_nickList =
+	event->getParam (3).split (QRegExp ("\\s+"), QString::SkipEmptyParts);
+      updateNickCompleter ();
+      break;
     case ERR_NICKNAMEINUSE:
     case ERR_NICKCOLLISION:
-        m_chatWindow->append(QString("<font color=\"#AA0000\">Nickname in use.</font>"));
-        break;
+      m_chatWindow->
+	append (QString ("<font color=\"#AA0000\">Nickname in use.</font>"));
+      break;
     };
 }
 
 
-void IRCWidget::updateNickCompleter() {
-    QCompleter *completer = new QCompleter(m_nickList, this);
-    completer->setCompletionMode(QCompleter::InlineCompletion);
-    m_inputLine->setCompleter(completer);
+void
+IRCWidget::updateNickCompleter ()
+{
+  QCompleter *completer = new QCompleter (m_nickList, this);
+  completer->setCompletionMode (QCompleter::InlineCompletion);
+  m_inputLine->setCompleter (completer);
 }
diff --git a/gui/src/IRCWidget.h b/gui/src/IRCWidget.h
--- a/gui/src/IRCWidget.h
+++ b/gui/src/IRCWidget.h
@@ -21,57 +21,54 @@
 
 #include <QWidget>
 #include <QTextEdit>
 #include <QPushButton>
 #include <QLineEdit>
 #include <QCompleter>
 #include "IRCClient.h"
 
-class IRCWidget : public QWidget
+class IRCWidget:public QWidget
 {
-    Q_OBJECT
-public:
-    explicit IRCWidget(QWidget *parent, QString settingsFile);
-    void connectToServer();
-
-signals:
+Q_OBJECT public:
+  explicit IRCWidget (QWidget * parent, QString settingsFile);
+  void connectToServer ();
 
-public slots:
-    void showStatusMessage(const char*);
-    void joinOctaveChannel(const char*);
-    void loginSuccessful(const char*);
-    void showPrivateMessage(const char*, const char*, const char*);
-    void showNotice(const char*, const char*, const char*);
-    void showTopic(const char*, const char*, const char*);
-    void showJoin(const char*, const char*);
-    void showQuit(const char*, const char*);
-    void showNickChange(const char*, const char*);
-    void nickPopup();
-    void sendMessage(QString);
-    void sendInputLine();
+    signals:public slots:void showStatusMessage (const char *);
+  void joinOctaveChannel (const char *);
+  void loginSuccessful (const char *);
+  void showPrivateMessage (const char *, const char *, const char *);
+  void showNotice (const char *, const char *, const char *);
+  void showTopic (const char *, const char *, const char *);
+  void showJoin (const char *, const char *);
+  void showQuit (const char *, const char *);
+  void showNickChange (const char *, const char *);
+  void nickPopup ();
+  void sendMessage (QString);
+  void sendInputLine ();
+
+  void handleNickInUseChanged ();
+  void handleReplyCode (IRCEvent * event);
 
-    void handleNickInUseChanged();
-    void handleReplyCode(IRCEvent *event);
-
-    void updateNickCompleter();
+  void updateNickCompleter ();
 private:
-    IRCClient *m_ircClient;
-    QTextEdit *m_chatWindow;
-    QPushButton *m_nickButton;
-    QLineEdit *m_inputLine;
-    bool m_alternatingColor;
+    IRCClient * m_ircClient;
+  QTextEdit *m_chatWindow;
+  QPushButton *m_nickButton;
+  QLineEdit *m_inputLine;
+  bool m_alternatingColor;
 
-    QString getAlternatingColor() {
-        m_alternatingColor = !m_alternatingColor;
-        if(m_alternatingColor)
-            return "#000077";
-        return "#005533";
-    }
+  QString getAlternatingColor ()
+  {
+    m_alternatingColor = !m_alternatingColor;
+    if (m_alternatingColor)
+      return "#000077";
+    return "#005533";
+  }
 
-    QString m_initialNick;
-    bool m_autoIdentification;
-    QString m_nickServPassword;
-    QString m_settingsFile;
-    QStringList m_nickList;
+  QString m_initialNick;
+  bool m_autoIdentification;
+  QString m_nickServPassword;
+  QString m_settingsFile;
+  QStringList m_nickList;
 };
 
 #endif // IRCWIDGET_H
diff --git a/gui/src/ImageViewerMdiSubWindow.cpp b/gui/src/ImageViewerMdiSubWindow.cpp
--- a/gui/src/ImageViewerMdiSubWindow.cpp
+++ b/gui/src/ImageViewerMdiSubWindow.cpp
@@ -16,26 +16,29 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ImageViewerMdiSubWindow.h"
 #include <QLabel>
 #include <QPixmap>
 #include <QScrollArea>
 
-ImageViewerMdiSubWindow::ImageViewerMdiSubWindow(QPixmap pixmap, QWidget *parent)
-    : QMdiSubWindow(parent),
-      m_pixmap(pixmap) {
-    construct();
+ImageViewerMdiSubWindow::ImageViewerMdiSubWindow (QPixmap pixmap, QWidget * parent):QMdiSubWindow (parent),
+m_pixmap
+(pixmap)
+{
+  construct ();
 }
 
-void ImageViewerMdiSubWindow::construct() {
-    QLabel *label = new QLabel();
-    label->setBackgroundRole(QPalette::Base);
-    label->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
-    label->setScaledContents(true);
-    label->setPixmap(m_pixmap);
+void
+ImageViewerMdiSubWindow::construct ()
+{
+  QLabel *label = new QLabel ();
+  label->setBackgroundRole (QPalette::Base);
+  label->setSizePolicy (QSizePolicy::Ignored, QSizePolicy::Ignored);
+  label->setScaledContents (true);
+  label->setPixmap (m_pixmap);
 
-    QScrollArea *scrollArea = new QScrollArea(this);
-    scrollArea->setBackgroundRole(QPalette::Dark);
-    scrollArea->setWidget(label);
-    setWidget(scrollArea);
+  QScrollArea *scrollArea = new QScrollArea (this);
+  scrollArea->setBackgroundRole (QPalette::Dark);
+  scrollArea->setWidget (label);
+  setWidget (scrollArea);
 }
diff --git a/gui/src/ImageViewerMdiSubWindow.h b/gui/src/ImageViewerMdiSubWindow.h
--- a/gui/src/ImageViewerMdiSubWindow.h
+++ b/gui/src/ImageViewerMdiSubWindow.h
@@ -16,19 +16,19 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef IMAGEVIEWERMDISUBWINDOW_H
 #define IMAGEVIEWERMDISUBWINDOW_H
 
 #include <QMdiSubWindow>
 
-class ImageViewerMdiSubWindow : public QMdiSubWindow
+class ImageViewerMdiSubWindow:public QMdiSubWindow
 {
 public:
-    ImageViewerMdiSubWindow(QPixmap pixmap, QWidget *parent = 0);
+  ImageViewerMdiSubWindow (QPixmap pixmap, QWidget * parent = 0);
 
 private:
-    void construct();
-    QPixmap m_pixmap;
+  void construct ();
+  QPixmap m_pixmap;
 };
 
 #endif // IMAGEVIEWERMDISUBWINDOW_H
diff --git a/gui/src/MainWindow.cpp b/gui/src/MainWindow.cpp
--- a/gui/src/MainWindow.cpp
+++ b/gui/src/MainWindow.cpp
@@ -22,203 +22,270 @@
 #include <QSettings>
 #include <QDesktopServices>
 #include <QFileDialog>
 #include "MainWindow.h"
 #include "FileEditorMdiSubWindow.h"
 #include "ImageViewerMdiSubWindow.h"
 #include "SettingsDialog.h"
 
-MainWindow::MainWindow(QWidget *parent)
-    : QMainWindow(parent),
-      m_isRunning(true) {
-    QDesktopServices desktopServices;
-    m_settingsFile = desktopServices.storageLocation(QDesktopServices::HomeLocation) + "/.quint/settings.ini";
-    construct();
-    establishOctaveLink();
+MainWindow::MainWindow (QWidget * parent):QMainWindow (parent),
+m_isRunning (true)
+{
+  QDesktopServices
+    desktopServices;
+  m_settingsFile =
+    desktopServices.storageLocation (QDesktopServices::HomeLocation) +
+    "/.quint/settings.ini";
+  construct ();
+  establishOctaveLink ();
 }
 
-MainWindow::~MainWindow() {
+MainWindow::~MainWindow ()
+{
 }
 
-void MainWindow::handleOpenFileRequest(QString fileName) {
-    reportStatusMessage(tr("Opening file."));
-    QPixmap pixmap;
-    if(pixmap.load(fileName)) {
+void
+MainWindow::handleOpenFileRequest (QString fileName)
+{
+  reportStatusMessage (tr ("Opening file."));
+  QPixmap pixmap;
+  if (pixmap.load (fileName))
+    {
 //        ImageViewerMdiSubWindow *subWindow = new ImageViewerMdiSubWindow(pixmap, this);
 //        subWindow->setAttribute(Qt::WA_DeleteOnClose);
 //        m_centralMdiArea->addSubWindow(subWindow);
 //        subWindow->setWindowTitle(fileName);
-    } else {
-        FileEditorMdiSubWindow *subWindow = new FileEditorMdiSubWindow(m_centralMdiArea);
-        subWindow->setAttribute(Qt::WA_DeleteOnClose);
+    }
+  else
+    {
+      FileEditorMdiSubWindow *subWindow =
+	new FileEditorMdiSubWindow (m_centralMdiArea);
+      subWindow->setAttribute (Qt::WA_DeleteOnClose);
 // addSubWindow uncommented to avoid "QMdiArea::addSubWindow: window is already added"
 //        m_centralMdiArea->addSubWindow(subWindow);
-        subWindow->loadFile(fileName);
+      subWindow->loadFile (fileName);
     }
 }
 
-void MainWindow::reportStatusMessage(QString statusMessage) {
-    m_statusBar->showMessage(statusMessage, 1000);
+void
+MainWindow::reportStatusMessage (QString statusMessage)
+{
+  m_statusBar->showMessage (statusMessage, 1000);
 }
 
-void MainWindow::openWebPage(QString url) {
-    m_documentationWidget->load(QUrl(url));
-}
-
-void MainWindow::handleSaveWorkspaceRequest() {
-    QDesktopServices desktopServices;
-    QString selectedFile = QFileDialog::getSaveFileName(this, tr("Save Workspace"),
-        desktopServices.storageLocation(QDesktopServices::HomeLocation) + "/.quint/workspace");
-    m_octaveTerminal->sendText(QString("save \'%1\'\n").arg(selectedFile));
-    m_octaveTerminal->setFocus();
+void
+MainWindow::openWebPage (QString url)
+{
+  m_documentationWidget->load (QUrl (url));
 }
 
-void MainWindow::handleLoadWorkspaceRequest() {
-    QDesktopServices desktopServices;
-    QString selectedFile = QFileDialog::getOpenFileName(this, tr("Load Workspace"),
-        desktopServices.storageLocation(QDesktopServices::HomeLocation) + "/.quint/workspace");
-    m_octaveTerminal->sendText(QString("load \'%1\'\n").arg(selectedFile));
-    m_octaveTerminal->setFocus();
+void
+MainWindow::handleSaveWorkspaceRequest ()
+{
+  QDesktopServices desktopServices;
+  QString selectedFile =
+    QFileDialog::getSaveFileName (this, tr ("Save Workspace"),
+				  desktopServices.
+				  storageLocation (QDesktopServices::
+						   HomeLocation) +
+				  "/.quint/workspace");
+  m_octaveTerminal->sendText (QString ("save \'%1\'\n").arg (selectedFile));
+  m_octaveTerminal->setFocus ();
 }
 
-void MainWindow::handleClearWorkspaceRequest() {
-    m_octaveTerminal->sendText("clear\n");
-    m_octaveTerminal->setFocus();
+void
+MainWindow::handleLoadWorkspaceRequest ()
+{
+  QDesktopServices desktopServices;
+  QString selectedFile =
+    QFileDialog::getOpenFileName (this, tr ("Load Workspace"),
+				  desktopServices.
+				  storageLocation (QDesktopServices::
+						   HomeLocation) +
+				  "/.quint/workspace");
+  m_octaveTerminal->sendText (QString ("load \'%1\'\n").arg (selectedFile));
+  m_octaveTerminal->setFocus ();
 }
 
-void MainWindow::handleCommandDoubleClicked(QString command) {
-    m_octaveTerminal->sendText(command);
-    m_octaveTerminal->setFocus();
+void
+MainWindow::handleClearWorkspaceRequest ()
+{
+  m_octaveTerminal->sendText ("clear\n");
+  m_octaveTerminal->setFocus ();
 }
 
-void MainWindow::alignMdiWindows() {
-    m_centralMdiArea->tileSubWindows();
+void
+MainWindow::handleCommandDoubleClicked (QString command)
+{
+  m_octaveTerminal->sendText (command);
+  m_octaveTerminal->setFocus ();
+}
+
+void
+MainWindow::alignMdiWindows ()
+{
+  m_centralMdiArea->tileSubWindows ();
 }
 
-void MainWindow::openBugTrackerPage() {
-    QDesktopServices::openUrl(QUrl("http://savannah.gnu.org/bugs/?group=octave"));
+void
+MainWindow::openBugTrackerPage ()
+{
+  QDesktopServices::
+    openUrl (QUrl ("http://savannah.gnu.org/bugs/?group=octave"));
 }
 
-void MainWindow::processSettingsDialogRequest() {
-    SettingsDialog settingsDialog(this, m_settingsFile);
-    settingsDialog.exec();
+void
+MainWindow::processSettingsDialogRequest ()
+{
+  SettingsDialog settingsDialog (this, m_settingsFile);
+  settingsDialog.exec ();
 }
 
-void MainWindow::closeEvent(QCloseEvent *closeEvent) {
-    m_isRunning = false;
-    reportStatusMessage(tr("Saving data and shutting down."));
-    writeSettings();
+void
+MainWindow::closeEvent (QCloseEvent * closeEvent)
+{
+  m_isRunning = false;
+  reportStatusMessage (tr ("Saving data and shutting down."));
+  writeSettings ();
 
-    m_octaveCallbackThread->terminate();
-    m_octaveCallbackThread->wait();
+  m_octaveCallbackThread->terminate ();
+  m_octaveCallbackThread->wait ();
 
-    m_octaveMainThread->terminate();
-    QMainWindow::closeEvent(closeEvent);
+  m_octaveMainThread->terminate ();
+  QMainWindow::closeEvent (closeEvent);
 }
 
-void MainWindow::readSettings() {
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    restoreGeometry(settings.value("MainWindow/geometry").toByteArray());
-    restoreState(settings.value("MainWindow/windowState").toByteArray());
+void
+MainWindow::readSettings ()
+{
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  restoreGeometry (settings.value ("MainWindow/geometry").toByteArray ());
+  restoreState (settings.value ("MainWindow/windowState").toByteArray ());
 }
 
-void MainWindow::writeSettings() {
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    settings.setValue("MainWindow/geometry", saveGeometry());
-    settings.setValue("MainWindow/windowState", saveState());
+void
+MainWindow::writeSettings ()
+{
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  settings.setValue ("MainWindow/geometry", saveGeometry ());
+  settings.setValue ("MainWindow/windowState", saveState ());
 }
 
-void MainWindow::construct() {
+void
+MainWindow::construct ()
+{
+
+  if (QFile::exists ("../media/logo.png"))
+    setWindowIcon (QIcon ("../media/logo.png"));
+  else
+    setWindowIcon (QIcon ("/usr/share/octave/quint/media/logo.png"));
 
-    if(QFile::exists("../media/logo.png"))
-        setWindowIcon(QIcon("../media/logo.png"));
-    else
-        setWindowIcon(QIcon("/usr/share/octave/quint/media/logo.png"));
+  // Initialize MDI area.
+  m_centralMdiArea = new QMdiArea (this);
+  m_centralMdiArea->setObjectName ("CentralMdiArea");
+  m_centralMdiArea->setViewMode (QMdiArea::TabbedView);
 
-    // Initialize MDI area.
-    m_centralMdiArea = new QMdiArea(this);
-    m_centralMdiArea->setObjectName("CentralMdiArea");
-    m_centralMdiArea->setViewMode(QMdiArea::TabbedView);
+  // Setup dockable widgets and the status bar.
+  m_variablesDockWidget = new VariablesDockWidget (this);
+  m_historyDockWidget = new HistoryDockWidget (this);
+  m_filesDockWidget = new FilesDockWidget (this);
+  m_statusBar = new QStatusBar (this);
 
-    // Setup dockable widgets and the status bar.
-    m_variablesDockWidget = new VariablesDockWidget(this);
-    m_historyDockWidget = new HistoryDockWidget(this);
-    m_filesDockWidget = new FilesDockWidget(this);
-    m_statusBar = new QStatusBar(this);
-
-    // Setup essential MDI Windows.
-    m_octaveTerminal = new OctaveTerminal(this);
-    m_documentationWidget = new BrowserWidget(this);
-    m_ircWidget = new IRCWidget(this, m_settingsFile);
+  // Setup essential MDI Windows.
+  m_octaveTerminal = new OctaveTerminal (this);
+  m_documentationWidget = new BrowserWidget (this);
+  m_ircWidget = new IRCWidget (this, m_settingsFile);
 
-    m_documentationWidgetSubWindow = m_centralMdiArea->addSubWindow(m_documentationWidget,
-        Qt::WindowTitleHint | Qt::WindowMinMaxButtonsHint);
-    m_documentationWidgetSubWindow->setObjectName("DocumentationWidgetSubWindow");
-    m_documentationWidgetSubWindow->setWindowTitle(tr("Documentation"));
-    m_documentationWidgetSubWindow->setWindowIcon(QIcon("../media/help_index.png"));
+  m_documentationWidgetSubWindow =
+    m_centralMdiArea->addSubWindow (m_documentationWidget,
+				    Qt::WindowTitleHint | Qt::
+				    WindowMinMaxButtonsHint);
+  m_documentationWidgetSubWindow->
+    setObjectName ("DocumentationWidgetSubWindow");
+  m_documentationWidgetSubWindow->setWindowTitle (tr ("Documentation"));
+  m_documentationWidgetSubWindow->
+    setWindowIcon (QIcon ("../media/help_index.png"));
 
-    m_octaveTerminalSubWindow = m_centralMdiArea->addSubWindow(m_octaveTerminal,
-        Qt::WindowTitleHint | Qt::WindowMinMaxButtonsHint);
-    m_octaveTerminalSubWindow->setObjectName("OctaveTerminalSubWindow");
-    m_octaveTerminalSubWindow->setWindowTitle(tr("Terminal"));
-    m_octaveTerminalSubWindow->setWindowIcon(QIcon("../media/terminal.png"));
+  m_octaveTerminalSubWindow =
+    m_centralMdiArea->addSubWindow (m_octaveTerminal,
+				    Qt::WindowTitleHint | Qt::
+				    WindowMinMaxButtonsHint);
+  m_octaveTerminalSubWindow->setObjectName ("OctaveTerminalSubWindow");
+  m_octaveTerminalSubWindow->setWindowTitle (tr ("Terminal"));
+  m_octaveTerminalSubWindow->setWindowIcon (QIcon ("../media/terminal.png"));
 
-    m_ircWidgetSubWindow = m_centralMdiArea->addSubWindow(m_ircWidget,
-        Qt::WindowTitleHint | Qt::WindowMinMaxButtonsHint);
-    m_ircWidgetSubWindow->setObjectName("ChatWidgetSubWindow");
-    m_ircWidgetSubWindow->setWindowTitle(tr("Chat"));
-    m_ircWidgetSubWindow->setWindowIcon(QIcon("../media/chat.png"));
+  m_ircWidgetSubWindow = m_centralMdiArea->addSubWindow (m_ircWidget,
+							 Qt::
+							 WindowTitleHint |
+							 Qt::
+							 WindowMinMaxButtonsHint);
+  m_ircWidgetSubWindow->setObjectName ("ChatWidgetSubWindow");
+  m_ircWidgetSubWindow->setWindowTitle (tr ("Chat"));
+  m_ircWidgetSubWindow->setWindowIcon (QIcon ("../media/chat.png"));
 
-    QMenu *controlMenu = menuBar()->addMenu(tr("Octave"));
-    QAction *settingsAction = controlMenu->addAction(tr("Settings"));
-    controlMenu->addSeparator();
-    QAction *exitAction = controlMenu->addAction(tr("Exit"));
+  QMenu *controlMenu = menuBar ()->addMenu (tr ("Octave"));
+  QAction *settingsAction = controlMenu->addAction (tr ("Settings"));
+  controlMenu->addSeparator ();
+  QAction *exitAction = controlMenu->addAction (tr ("Exit"));
 
-    QMenu *interfaceMenu = menuBar()->addMenu(tr("Interface"));
-    QAction *alignWindowsAction = interfaceMenu->addAction(tr("Align Windows"));
+  QMenu *interfaceMenu = menuBar ()->addMenu (tr ("Interface"));
+  QAction *alignWindowsAction =
+    interfaceMenu->addAction (tr ("Align Windows"));
 
-    QMenu *communityMenu = menuBar()->addMenu(tr("Community"));
-    QAction *reportBugAction = communityMenu->addAction(tr("Report Bug"));
+  QMenu *communityMenu = menuBar ()->addMenu (tr ("Community"));
+  QAction *reportBugAction = communityMenu->addAction (tr ("Report Bug"));
 
-    connect(settingsAction, SIGNAL(triggered()), this, SLOT(processSettingsDialogRequest()));
-    connect(exitAction, SIGNAL(triggered()), this, SLOT(close()));
-    connect(alignWindowsAction, SIGNAL(triggered()), this, SLOT(alignMdiWindows()));
-    connect(reportBugAction, SIGNAL(triggered()), this, SLOT(openBugTrackerPage()));
+  connect (settingsAction, SIGNAL (triggered ()), this,
+	   SLOT (processSettingsDialogRequest ()));
+  connect (exitAction, SIGNAL (triggered ()), this, SLOT (close ()));
+  connect (alignWindowsAction, SIGNAL (triggered ()), this,
+	   SLOT (alignMdiWindows ()));
+  connect (reportBugAction, SIGNAL (triggered ()), this,
+	   SLOT (openBugTrackerPage ()));
+
+  setWindowTitle ("Octave");
+  setCentralWidget (m_centralMdiArea);
+  addDockWidget (Qt::LeftDockWidgetArea, m_variablesDockWidget);
+  addDockWidget (Qt::LeftDockWidgetArea, m_historyDockWidget);
+  addDockWidget (Qt::RightDockWidgetArea, m_filesDockWidget);
+  setStatusBar (m_statusBar);
 
-    setWindowTitle("Octave");
-    setCentralWidget(m_centralMdiArea);
-    addDockWidget(Qt::LeftDockWidgetArea, m_variablesDockWidget);
-    addDockWidget(Qt::LeftDockWidgetArea, m_historyDockWidget);
-    addDockWidget(Qt::RightDockWidgetArea, m_filesDockWidget);
-    setStatusBar(m_statusBar);
-
-    readSettings();
+  readSettings ();
 
-    connect(m_filesDockWidget, SIGNAL(openFile(QString)), this, SLOT(handleOpenFileRequest(QString)));
-    connect(m_historyDockWidget, SIGNAL(information(QString)), this, SLOT(reportStatusMessage(QString)));
-    connect(m_historyDockWidget, SIGNAL(commandDoubleClicked(QString)), this, SLOT(handleCommandDoubleClicked(QString)));
-    connect(m_variablesDockWidget, SIGNAL(saveWorkspace()), this, SLOT(handleSaveWorkspaceRequest()));
-    connect(m_variablesDockWidget, SIGNAL(loadWorkspace()), this, SLOT(handleLoadWorkspaceRequest()));
-    connect(m_variablesDockWidget, SIGNAL(clearWorkspace()), this, SLOT(handleClearWorkspaceRequest()));
+  connect (m_filesDockWidget, SIGNAL (openFile (QString)), this,
+	   SLOT (handleOpenFileRequest (QString)));
+  connect (m_historyDockWidget, SIGNAL (information (QString)), this,
+	   SLOT (reportStatusMessage (QString)));
+  connect (m_historyDockWidget, SIGNAL (commandDoubleClicked (QString)), this,
+	   SLOT (handleCommandDoubleClicked (QString)));
+  connect (m_variablesDockWidget, SIGNAL (saveWorkspace ()), this,
+	   SLOT (handleSaveWorkspaceRequest ()));
+  connect (m_variablesDockWidget, SIGNAL (loadWorkspace ()), this,
+	   SLOT (handleLoadWorkspaceRequest ()));
+  connect (m_variablesDockWidget, SIGNAL (clearWorkspace ()), this,
+	   SLOT (handleClearWorkspaceRequest ()));
 
-    openWebPage("http://www.gnu.org/software/octave/doc/interpreter/");
+  openWebPage ("http://www.gnu.org/software/octave/doc/interpreter/");
 }
 
-void MainWindow::establishOctaveLink() {
-    m_octaveMainThread = new OctaveMainThread(this);
-    m_octaveMainThread->start();
+void
+MainWindow::establishOctaveLink ()
+{
+  m_octaveMainThread = new OctaveMainThread (this);
+  m_octaveMainThread->start ();
 
-    m_octaveCallbackThread = new OctaveCallbackThread(this, this);
-    m_octaveCallbackThread->start();
+  m_octaveCallbackThread = new OctaveCallbackThread (this, this);
+  m_octaveCallbackThread->start ();
 
-    command_editor::add_event_hook(OctaveLink::readlineEventHook);
+  command_editor::add_event_hook (OctaveLink::readlineEventHook);
 
-    int fdm, fds;
-    if(openpty(&fdm, &fds, 0, 0, 0) < 0) {
-        assert(0);
+  int fdm, fds;
+  if (openpty (&fdm, &fds, 0, 0, 0) < 0)
+    {
+      assert (0);
     }
-    dup2 (fds, 0);
-    dup2 (fds, 1);
-    dup2 (fds, 2);
-    m_octaveTerminal->openTeletype(fdm);
-    reportStatusMessage(tr("Established link to Octave."));
+  dup2 (fds, 0);
+  dup2 (fds, 1);
+  dup2 (fds, 2);
+  m_octaveTerminal->openTeletype (fdm);
+  reportStatusMessage (tr ("Established link to Octave."));
 }
diff --git a/gui/src/MainWindow.h b/gui/src/MainWindow.h
--- a/gui/src/MainWindow.h
+++ b/gui/src/MainWindow.h
@@ -58,17 +58,17 @@
 #include "octave/str-vec.h"
 #include "octave/cmd-hist.h"
 #include "octave/cmd-edit.h"
 #include "octave/oct-env.h"
 #include "octave/symtab.h"
 #include "cmd-edit.h"
 
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
-extern OCTINTERP_API YY_BUFFER_STATE create_buffer (FILE *f);
+extern OCTINTERP_API YY_BUFFER_STATE create_buffer (FILE * f);
 extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
 extern OCTINTERP_API FILE *get_input_from_stdin (void);
 
 // System
 #include <termios.h>
 #include <sys/types.h>
 #include <signal.h>
 #include <sys/types.h>
@@ -80,115 +80,138 @@ extern OCTINTERP_API FILE *get_input_fro
 class OctaveMainThread;
 class OctaveCallbackThread;
 
 /**
   * \class MainWindow
   *
   * Represents the main window.
   */
-class MainWindow : public QMainWindow {
-    Q_OBJECT
-public:
-    MainWindow(QWidget *parent = 0);
-    ~MainWindow();
-
-    bool isRunning() { return m_isRunning; }
-    OctaveTerminal *octaveTerminal() { return m_octaveTerminal; }
-    VariablesDockWidget *variablesDockWidget() { return m_variablesDockWidget; }
-    HistoryDockWidget *historyDockWidget() { return m_historyDockWidget; }
-    FilesDockWidget *filesDockWidget() { return m_filesDockWidget; }
+class MainWindow:public QMainWindow
+{
+Q_OBJECT public:
+  MainWindow (QWidget * parent = 0);
+  ~MainWindow ();
 
-public slots:
-    void handleOpenFileRequest(QString fileName);
-    void reportStatusMessage(QString statusMessage);
-    void openWebPage(QString url);
-    void handleSaveWorkspaceRequest();
-    void handleLoadWorkspaceRequest();
-    void handleClearWorkspaceRequest();
-    void handleCommandDoubleClicked(QString command);
-    void alignMdiWindows();
-    void openBugTrackerPage();
-    void processSettingsDialogRequest();
+  bool isRunning ()
+  {
+    return m_isRunning;
+  }
+  OctaveTerminal *octaveTerminal ()
+  {
+    return m_octaveTerminal;
+  }
+  VariablesDockWidget *variablesDockWidget ()
+  {
+    return m_variablesDockWidget;
+  }
+  HistoryDockWidget *historyDockWidget ()
+  {
+    return m_historyDockWidget;
+  }
+  FilesDockWidget *filesDockWidget ()
+  {
+    return m_filesDockWidget;
+  }
+
+  public slots:void handleOpenFileRequest (QString fileName);
+  void reportStatusMessage (QString statusMessage);
+  void openWebPage (QString url);
+  void handleSaveWorkspaceRequest ();
+  void handleLoadWorkspaceRequest ();
+  void handleClearWorkspaceRequest ();
+  void handleCommandDoubleClicked (QString command);
+  void alignMdiWindows ();
+  void openBugTrackerPage ();
+  void processSettingsDialogRequest ();
 
 protected:
-    void closeEvent(QCloseEvent *closeEvent);
-    void readSettings();
-    void writeSettings();
+  void closeEvent (QCloseEvent * closeEvent);
+  void readSettings ();
+  void writeSettings ();
 
 private:
-    void construct();
-    void establishOctaveLink();
-    QMdiArea *m_centralMdiArea;
+  void construct ();
+  void establishOctaveLink ();
+  QMdiArea *m_centralMdiArea;
 
-    // Mdi sub windows.
-    OctaveTerminal *m_octaveTerminal;
-    BrowserWidget *m_documentationWidget;
-    IRCWidget *m_ircWidget;
+  // Mdi sub windows.
+  OctaveTerminal *m_octaveTerminal;
+  BrowserWidget *m_documentationWidget;
+  IRCWidget *m_ircWidget;
 
-    QMdiSubWindow *m_octaveTerminalSubWindow;
-    QMdiSubWindow *m_documentationWidgetSubWindow;
-    QMdiSubWindow *m_ircWidgetSubWindow;
+  QMdiSubWindow *m_octaveTerminalSubWindow;
+  QMdiSubWindow *m_documentationWidgetSubWindow;
+  QMdiSubWindow *m_ircWidgetSubWindow;
 
-    // Dock widgets.
-    VariablesDockWidget *m_variablesDockWidget;
-    HistoryDockWidget *m_historyDockWidget;
-    FilesDockWidget *m_filesDockWidget;
+  // Dock widgets.
+  VariablesDockWidget *m_variablesDockWidget;
+  HistoryDockWidget *m_historyDockWidget;
+  FilesDockWidget *m_filesDockWidget;
 
-    // Toolbars.
-    QStatusBar *m_statusBar;
+  // Toolbars.
+  QStatusBar *m_statusBar;
 
-    QString m_settingsFile;
+  QString m_settingsFile;
 
-    // Threads for running octave and managing the data interaction.
-    OctaveMainThread *m_octaveMainThread;
-    OctaveCallbackThread *m_octaveCallbackThread;
-    bool m_isRunning;
+  // Threads for running octave and managing the data interaction.
+  OctaveMainThread *m_octaveMainThread;
+  OctaveCallbackThread *m_octaveCallbackThread;
+  bool m_isRunning;
 };
 
-class OctaveMainThread : public QThread {
-    Q_OBJECT
-public:
-    OctaveMainThread(QObject *parent)
-        : QThread(parent) {
-    }
+class OctaveMainThread:public QThread
+{
+Q_OBJECT public:
+  OctaveMainThread (QObject * parent):QThread (parent)
+  {
+  }
 protected:
-    void run() {
-        int argc = 3;
-        const char* argv[] = {"octave", "--interactive", "--line-editing"};
-        octave_main(argc, (char**)argv, 1);
-        main_loop();
-        clean_up_and_exit(0);
-    }
+  void run ()
+  {
+    int argc = 3;
+    const char *argv[] = { "octave", "--interactive", "--line-editing" };
+    octave_main (argc, (char **) argv, 1);
+    main_loop ();
+    clean_up_and_exit (0);
+  }
 };
 
-class OctaveCallbackThread : public QThread {
-    Q_OBJECT
-public:
-    OctaveCallbackThread(QObject *parent, MainWindow *mainWindow)
-        : QThread(parent),
-          m_mainWindow(mainWindow) {
-    }
+class OctaveCallbackThread:public QThread
+{
+Q_OBJECT public:
+  OctaveCallbackThread (QObject * parent,
+			MainWindow * mainWindow):QThread (parent),
+    m_mainWindow (mainWindow)
+  {
+  }
 
 protected:
-    void run() {
-        while(m_mainWindow->isRunning()) {
+  void run ()
+  {
+    while (m_mainWindow->isRunning ())
+      {
 
-        // Get a full variable list.
-        QList<SymbolRecord> symbolTable = OctaveLink::instance()->currentSymbolTable();
-        if(symbolTable.size()) {
-            m_mainWindow->variablesDockWidget()->setVariablesList(symbolTable);
-        }
+	// Get a full variable list.
+	QList < SymbolRecord > symbolTable =
+	  OctaveLink::instance ()->currentSymbolTable ();
+	if (symbolTable.size ())
+	  {
+	    m_mainWindow->variablesDockWidget ()->
+	      setVariablesList (symbolTable);
+	  }
 
-        // Collect history list.
-        string_vector historyList = OctaveLink::instance()->currentHistory();
-        if(historyList.length()) {
-            m_mainWindow->historyDockWidget()->updateHistory(historyList);
-        }
+	// Collect history list.
+	string_vector historyList =
+	  OctaveLink::instance ()->currentHistory ();
+	if (historyList.length ())
+	  {
+	    m_mainWindow->historyDockWidget ()->updateHistory (historyList);
+	  }
 
-            usleep(100000);
-        }
-    }
+	usleep (100000);
+      }
+  }
 private:
-    MainWindow *m_mainWindow;
+  MainWindow * m_mainWindow;
 };
 
 #endif // MAINWINDOW_H
diff --git a/gui/src/OctaveGUI.cpp b/gui/src/OctaveGUI.cpp
--- a/gui/src/OctaveGUI.cpp
+++ b/gui/src/OctaveGUI.cpp
@@ -16,29 +16,37 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <QtGui/QApplication>
 #include <QTranslator>
 #include <QSettings>
 #include "MainWindow.h"
 
-int main(int argc, char *argv[])
+int
+main (int argc, char *argv[])
 {
-    QApplication application(argc, argv);
-    QDesktopServices desktopServices;
-    QSettings settings(
-                desktopServices.storageLocation(QDesktopServices::HomeLocation)
-                + "/.quint/settings.ini", QSettings::IniFormat);
+  QApplication application (argc, argv);
+  QDesktopServices desktopServices;
+  QSettings settings (desktopServices.
+		      storageLocation (QDesktopServices::HomeLocation) +
+		      "/.quint/settings.ini", QSettings::IniFormat);
 
-    QTranslator translator;
-    QString translatorFile = QString("../languages/%1.qm").arg(settings.value("application/language").toString());
-    if(!QFile::exists(translatorFile))
-        translatorFile =  QString("/usr/share/octave/quint/languages/%1.qm").arg(settings.value("application/language").toString());
+  QTranslator translator;
+  QString translatorFile =
+    QString ("../languages/%1.qm").arg (settings.
+					value ("application/language").
+					toString ());
+  if (!QFile::exists (translatorFile))
+    translatorFile =
+      QString ("/usr/share/octave/quint/languages/%1.qm").arg (settings.
+							       value
+							       ("application/language").
+							       toString ());
 
-    translator.load(translatorFile);
-    application.installTranslator(&translator);
+  translator.load (translatorFile);
+  application.installTranslator (&translator);
 
-    MainWindow w;
-    w.show();
+  MainWindow w;
+  w.show ();
 
-    return application.exec();
+  return application.exec ();
 }
diff --git a/gui/src/OctaveLink.cpp b/gui/src/OctaveLink.cpp
--- a/gui/src/OctaveLink.cpp
+++ b/gui/src/OctaveLink.cpp
@@ -19,115 +19,149 @@ Software Foundation, Inc., 51 Franklin S
 02110-1301, USA.
 
 */
 
 // Born July 13, 2007.
 
 #include "OctaveLink.h"
 
-OctaveLink OctaveLink::m_singleton;
+OctaveLink
+  OctaveLink::m_singleton;
 
 
-OctaveLink::OctaveLink()
-    : QObject(),
-      m_previousHistoryLength(0) {
-    m_symbolTableSemaphore = new QSemaphore(1);
-    m_historySemaphore = new QSemaphore(1);
+OctaveLink::OctaveLink ():QObject (), m_previousHistoryLength (0)
+{
+  m_symbolTableSemaphore = new QSemaphore (1);
+  m_historySemaphore = new QSemaphore (1);
 }
 
-OctaveLink::~OctaveLink() {
+OctaveLink::~OctaveLink ()
+{
 }
 
-int OctaveLink::readlineEventHook() {
-  OctaveLink::instance()->processOctaveServerData();
+int
+OctaveLink::readlineEventHook ()
+{
+  OctaveLink::instance ()->processOctaveServerData ();
   return 0;
 }
 
-QString OctaveLink::octaveValueAsQString(OctaveValue octaveValue) {
-    // Convert single qouted string.
-    if(octaveValue.is_sq_string()) {
-        return QString("\'%1\'").arg(octaveValue.string_value().c_str());
+QString
+OctaveLink::octaveValueAsQString (OctaveValue octaveValue)
+{
+  // Convert single qouted string.
+  if (octaveValue.is_sq_string ())
+    {
+      return QString ("\'%1\'").arg (octaveValue.string_value ().c_str ());
 
-    // Convert double qouted string.
-    } else if(octaveValue.is_dq_string()) {
-        return QString("\"%1\"").arg(octaveValue.string_value().c_str());
+      // Convert double qouted string.
+    }
+  else if (octaveValue.is_dq_string ())
+    {
+      return QString ("\"%1\"").arg (octaveValue.string_value ().c_str ());
 
-    // Convert real scalar.
-    } else if(octaveValue.is_real_scalar()) {
-        return QString("%1").arg(octaveValue.scalar_value());
+      // Convert real scalar.
+    }
+  else if (octaveValue.is_real_scalar ())
+    {
+      return QString ("%1").arg (octaveValue.scalar_value ());
 
-    // Convert complex scalar.
-    } else if(octaveValue.is_complex_scalar()) {
-        return QString("%1 + %2i").arg(octaveValue.scalar_value()).arg(octaveValue.complex_value().imag());
+      // Convert complex scalar.
+    }
+  else if (octaveValue.is_complex_scalar ())
+    {
+      return QString ("%1 + %2i").arg (octaveValue.scalar_value ()).
+	arg (octaveValue.complex_value ().imag ());
 
-    // Convert range.
-    } else if(octaveValue.is_range()) {
-        return QString("%1 : %2 : %3").arg(octaveValue.range_value().base())
-                                      .arg(octaveValue.range_value().inc())
-                                      .arg(octaveValue.range_value().limit());
+      // Convert range.
+    }
+  else if (octaveValue.is_range ())
+    {
+      return QString ("%1 : %2 : %3").arg (octaveValue.range_value ().
+					   base ()).arg (octaveValue.
+							 range_value ().
+							 inc ()).
+	arg (octaveValue.range_value ().limit ());
 
-    // Convert real matrix.
-    } else if(octaveValue.is_real_matrix()) {
-        // TODO: Convert real matrix into a string.
-        return QString("{matrix}");
+      // Convert real matrix.
+    }
+  else if (octaveValue.is_real_matrix ())
+    {
+      // TODO: Convert real matrix into a string.
+      return QString ("{matrix}");
 
-    // Convert complex matrix.
-    } else if(octaveValue.is_complex_matrix()) {
-        // TODO: Convert complex matrix into a string.
-        return QString("{complex matrix}");
+      // Convert complex matrix.
+    }
+  else if (octaveValue.is_complex_matrix ())
+    {
+      // TODO: Convert complex matrix into a string.
+      return QString ("{complex matrix}");
 
-    // If everything else does not fit, we could not recognize the type.
-    } else {
-        return QString("<Type not recognized>");
+      // If everything else does not fit, we could not recognize the type.
+    }
+  else
+    {
+      return QString ("<Type not recognized>");
     }
 }
 
-void OctaveLink::fetchSymbolTable() {
-    m_symbolTableSemaphore->acquire();
-    m_symbolTableBuffer.clear();
-    std::list<SymbolRecord> allVariables = symbol_table::all_variables();
-    std::list<SymbolRecord>::iterator iterator;
-    for(iterator = allVariables.begin(); iterator != allVariables.end(); iterator++)
-        m_symbolTableBuffer.append(iterator->dup());
-    m_symbolTableSemaphore->release();
-    emit symbolTableChanged();
+void
+OctaveLink::fetchSymbolTable ()
+{
+  m_symbolTableSemaphore->acquire ();
+  m_symbolTableBuffer.clear ();
+  std::list < SymbolRecord > allVariables = symbol_table::all_variables ();
+  std::list < SymbolRecord >::iterator iterator;
+  for (iterator = allVariables.begin (); iterator != allVariables.end ();
+       iterator++)
+    m_symbolTableBuffer.append (iterator->dup ());
+  m_symbolTableSemaphore->release ();
+  emit symbolTableChanged ();
 }
 
 
-void OctaveLink::fetchHistory() {
-    int currentLen = command_history::length();
-    if(currentLen != m_previousHistoryLength) {
-        m_historySemaphore->acquire();
-        for(int i = m_previousHistoryLength; i < currentLen; i++) {
-            m_historyBuffer.append(command_history::get_entry(i));
-        }
-        m_historySemaphore->release();
-        m_previousHistoryLength = currentLen;
-        emit historyChanged();
+void
+OctaveLink::fetchHistory ()
+{
+  int currentLen = command_history::length ();
+  if (currentLen != m_previousHistoryLength)
+    {
+      m_historySemaphore->acquire ();
+      for (int i = m_previousHistoryLength; i < currentLen; i++)
+	{
+	  m_historyBuffer.append (command_history::get_entry (i));
+	}
+      m_historySemaphore->release ();
+      m_previousHistoryLength = currentLen;
+      emit historyChanged ();
     }
 }
 
-QList<SymbolRecord> OctaveLink::currentSymbolTable() {
-    QList<SymbolRecord> m_symbolTableCopy;
+QList < SymbolRecord > OctaveLink::currentSymbolTable ()
+{
+  QList < SymbolRecord > m_symbolTableCopy;
 
-    // Generate a deep copy of the current symbol table.
-    m_symbolTableSemaphore->acquire();
-    foreach(SymbolRecord symbolRecord, m_symbolTableBuffer)
-        m_symbolTableCopy.append(symbolRecord.dup());
-    m_symbolTableSemaphore->release();
+  // Generate a deep copy of the current symbol table.
+  m_symbolTableSemaphore->acquire ();
+  foreach (SymbolRecord symbolRecord, m_symbolTableBuffer)
+    m_symbolTableCopy.append (symbolRecord.dup ());
+  m_symbolTableSemaphore->release ();
 
-    return m_symbolTableCopy;
+  return m_symbolTableCopy;
 }
 
-string_vector OctaveLink::currentHistory() {
-    m_historySemaphore->acquire();
-    string_vector retval(m_historyBuffer);
-    m_historyBuffer = string_vector();
-    m_historySemaphore->release();
-    return retval;
+string_vector
+OctaveLink::currentHistory ()
+{
+  m_historySemaphore->acquire ();
+  string_vector retval (m_historyBuffer);
+  m_historyBuffer = string_vector ();
+  m_historySemaphore->release ();
+  return retval;
 }
 
-void OctaveLink::processOctaveServerData() {
-    fetchSymbolTable();
-    fetchHistory();
+void
+OctaveLink::processOctaveServerData ()
+{
+  fetchSymbolTable ();
+  fetchHistory ();
 }
-
diff --git a/gui/src/OctaveLink.h b/gui/src/OctaveLink.h
--- a/gui/src/OctaveLink.h
+++ b/gui/src/OctaveLink.h
@@ -74,70 +74,91 @@
 #include <QMutex>
 #include <QFileInfo>
 #include <QList>
 #include <QString>
 #include <QVector>
 #include <QSemaphore>
 #include <QObject>
 
-typedef symbol_table::symbol_record SymbolRecord;
-typedef octave_value OctaveValue;
+typedef
+  symbol_table::symbol_record
+  SymbolRecord;
+typedef octave_value
+  OctaveValue;
 
 /**
   * \class OctaveLink
   * Manages a link to an octave instance.
   */
-class OctaveLink : QObject
+class
+  OctaveLink:
+  QObject
 {
-    Q_OBJECT
+  Q_OBJECT
 public:
-    static OctaveLink *instance() { return &m_singleton; }
-    static int readlineEventHook(void);
-    static QString octaveValueAsQString(OctaveValue octaveValue);
+  static OctaveLink *
+  instance ()
+  {
+    return &m_singleton;
+  }
+  static int
+  readlineEventHook (void);
+  static QString
+  octaveValueAsQString (OctaveValue octaveValue);
 
     /**
       * Returns a copy of the current symbol table buffer.
       * \return Copy of the current symbol table buffer.
       */
-    QList<SymbolRecord> currentSymbolTable();
+  QList < SymbolRecord > currentSymbolTable ();
 
     /**
       * Returns a copy of the current history buffer.
       * \return Copy of the current history buffer.
       */
-    string_vector currentHistory();
+  string_vector
+  currentHistory ();
 
-    void processOctaveServerData();
+  void
+  processOctaveServerData ();
 
     /**
       * Updates the current symbol table with new data
       * from octave.
       */
-    void fetchSymbolTable();
+  void
+  fetchSymbolTable ();
 
     /**
       * Updates the current history buffer with new data
       * from octave.
       */
-    void fetchHistory();
+  void
+  fetchHistory ();
 
 signals:
-    void symbolTableChanged();
-    void historyChanged();
+  void
+  symbolTableChanged ();
+  void
+  historyChanged ();
 
 private:
-    OctaveLink();
-    ~OctaveLink();
+  OctaveLink ();
+  ~OctaveLink ();
 
     /** Variable related member variables. */
-    QSemaphore *m_symbolTableSemaphore;
-    QList<SymbolRecord> m_symbolTableBuffer;
+  QSemaphore *
+    m_symbolTableSemaphore;
+  QList < SymbolRecord > m_symbolTableBuffer;
 
     /** History related member variables. */
-    QSemaphore *m_historySemaphore;
-    string_vector m_historyBuffer;
-    int m_previousHistoryLength;
+  QSemaphore *
+    m_historySemaphore;
+  string_vector
+    m_historyBuffer;
+  int
+    m_previousHistoryLength;
 
-    static OctaveLink m_singleton;
+  static OctaveLink
+    m_singleton;
 };
 #endif // OCTAVELINK_H
-
diff --git a/gui/src/OctaveTerminal.cpp b/gui/src/OctaveTerminal.cpp
--- a/gui/src/OctaveTerminal.cpp
+++ b/gui/src/OctaveTerminal.cpp
@@ -17,21 +17,23 @@
  */
 
 #include "OctaveTerminal.h"
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QStringListModel>
 #include <QStringList>
 
-OctaveTerminal::OctaveTerminal(QWidget *parent)
-    : QTerminalWidget(0, parent) {
-    construct();
+OctaveTerminal::OctaveTerminal (QWidget * parent):QTerminalWidget (0, parent)
+{
+  construct ();
 }
 
-OctaveTerminal::~OctaveTerminal() {
+OctaveTerminal::~OctaveTerminal ()
+{
 }
 
-void OctaveTerminal::construct() {
-    setScrollBarPosition(QTerminalWidget::ScrollBarRight);
-    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+void
+OctaveTerminal::construct ()
+{
+  setScrollBarPosition (QTerminalWidget::ScrollBarRight);
+  setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);
 }
-
diff --git a/gui/src/OctaveTerminal.h b/gui/src/OctaveTerminal.h
--- a/gui/src/OctaveTerminal.h
+++ b/gui/src/OctaveTerminal.h
@@ -15,18 +15,18 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef OCTAVETERMINAL_H
 #define OCTAVETERMINAL_H
 #include "QTerminalWidget.h"
 
-class OctaveTerminal : public QTerminalWidget {
-    Q_OBJECT
-public:
-    OctaveTerminal(QWidget *parent = 0);
-    ~OctaveTerminal();
+class OctaveTerminal:public QTerminalWidget
+{
+Q_OBJECT public:
+  OctaveTerminal (QWidget * parent = 0);
+  ~OctaveTerminal ();
 
 private:
-    void construct();
+  void construct ();
 };
 #endif // OCTAVETERMINAL_H
diff --git a/gui/src/SettingsDialog.cpp b/gui/src/SettingsDialog.cpp
--- a/gui/src/SettingsDialog.cpp
+++ b/gui/src/SettingsDialog.cpp
@@ -1,29 +1,34 @@
 #include "SettingsDialog.h"
 #include "ui_SettingsDialog.h"
 #include <QSettings>
 
-SettingsDialog::SettingsDialog(QWidget *parent, QString settingsFile) :
-    QDialog(parent),
-    ui(new Ui::SettingsDialog)
+SettingsDialog::SettingsDialog (QWidget * parent, QString settingsFile):
+QDialog (parent), ui (new Ui::SettingsDialog)
 {
-    m_settingsFile = settingsFile;
-    ui->setupUi(this);
+  m_settingsFile = settingsFile;
+  ui->setupUi (this);
 
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    ui->connectOnStartup->setChecked(settings.value("connectOnStartup").toBool());
-    ui->showMessageOfTheDay->setChecked(settings.value("showMessageOfTheDay").toBool());
-    ui->showTopic->setChecked(settings.value("showTopic").toBool());
-    ui->autoIdentification->setChecked(settings.value("autoIdentification").toBool());
-    ui->nickServPassword->setText(settings.value("nickServPassword").toString());
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  ui->connectOnStartup->setChecked (settings.value ("connectOnStartup").
+				    toBool ());
+  ui->showMessageOfTheDay->setChecked (settings.value ("showMessageOfTheDay").
+				       toBool ());
+  ui->showTopic->setChecked (settings.value ("showTopic").toBool ());
+  ui->autoIdentification->setChecked (settings.value ("autoIdentification").
+				      toBool ());
+  ui->nickServPassword->setText (settings.value ("nickServPassword").
+				 toString ());
 }
 
-SettingsDialog::~SettingsDialog()
+SettingsDialog::~SettingsDialog ()
 {
-    QSettings settings(m_settingsFile, QSettings::IniFormat);
-    settings.setValue("connectOnStartup", ui->connectOnStartup->isChecked());
-    settings.setValue("showMessageOfTheDay", ui->showMessageOfTheDay->isChecked());
-    settings.setValue("showTopic", ui->showTopic->isChecked());
-    settings.setValue("autoIdentification", ui->autoIdentification->isChecked());
-    settings.setValue("nickServPassword", ui->nickServPassword->text());
-    delete ui;
+  QSettings settings (m_settingsFile, QSettings::IniFormat);
+  settings.setValue ("connectOnStartup", ui->connectOnStartup->isChecked ());
+  settings.setValue ("showMessageOfTheDay",
+		     ui->showMessageOfTheDay->isChecked ());
+  settings.setValue ("showTopic", ui->showTopic->isChecked ());
+  settings.setValue ("autoIdentification",
+		     ui->autoIdentification->isChecked ());
+  settings.setValue ("nickServPassword", ui->nickServPassword->text ());
+  delete ui;
 }
diff --git a/gui/src/SettingsDialog.h b/gui/src/SettingsDialog.h
--- a/gui/src/SettingsDialog.h
+++ b/gui/src/SettingsDialog.h
@@ -1,23 +1,22 @@
 #ifndef SETTINGSDIALOG_H
 #define SETTINGSDIALOG_H
 
 #include <QDialog>
 
-namespace Ui {
-    class SettingsDialog;
+namespace Ui
+{
+  class SettingsDialog;
 }
 
-class SettingsDialog : public QDialog
+class SettingsDialog:public QDialog
 {
-    Q_OBJECT
-
-public:
-    explicit SettingsDialog(QWidget *parent, QString settingsFile);
-    ~SettingsDialog();
+Q_OBJECT public:
+  explicit SettingsDialog (QWidget * parent, QString settingsFile);
+  ~SettingsDialog ();
 
 private:
-    Ui::SettingsDialog *ui;
-    QString m_settingsFile;
+  Ui::SettingsDialog * ui;
+  QString m_settingsFile;
 };
 
 #endif // SETTINGSDIALOG_H
diff --git a/gui/src/VariablesDockWidget.cpp b/gui/src/VariablesDockWidget.cpp
--- a/gui/src/VariablesDockWidget.cpp
+++ b/gui/src/VariablesDockWidget.cpp
@@ -16,171 +16,214 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "VariablesDockWidget.h"
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QPushButton>
 
-VariablesDockWidget::VariablesDockWidget(QWidget *parent)
-    : QDockWidget(parent) {
-    setObjectName("VariablesDockWidget");
-    construct();
+VariablesDockWidget::VariablesDockWidget (QWidget * parent):QDockWidget
+  (parent)
+{
+  setObjectName ("VariablesDockWidget");
+  construct ();
 }
 
-void VariablesDockWidget::construct() {
-    m_updateSemaphore = new QSemaphore(1);
-    QStringList headerLabels;
-    headerLabels << tr("Name") << tr("Type") << tr("Value");
-    m_variablesTreeWidget = new QTreeWidget(this);
-    m_variablesTreeWidget->setHeaderHidden(false);
-    m_variablesTreeWidget->setHeaderLabels(headerLabels);
-    QVBoxLayout *layout = new QVBoxLayout();
+void
+VariablesDockWidget::construct ()
+{
+  m_updateSemaphore = new QSemaphore (1);
+  QStringList headerLabels;
+  headerLabels << tr ("Name") << tr ("Type") << tr ("Value");
+  m_variablesTreeWidget = new QTreeWidget (this);
+  m_variablesTreeWidget->setHeaderHidden (false);
+  m_variablesTreeWidget->setHeaderLabels (headerLabels);
+  QVBoxLayout *layout = new QVBoxLayout ();
 
-    setWindowTitle(tr("Workspace"));
-    setWidget(new QWidget());
+  setWindowTitle (tr ("Workspace"));
+  setWidget (new QWidget ());
 
-    layout->addWidget(m_variablesTreeWidget);
-    QWidget *buttonBar = new QWidget(this);
-    layout->addWidget(buttonBar);
+  layout->addWidget (m_variablesTreeWidget);
+  QWidget *buttonBar = new QWidget (this);
+  layout->addWidget (buttonBar);
 
-        QHBoxLayout *buttonBarLayout = new QHBoxLayout();
-        QPushButton *saveWorkspaceButton = new QPushButton(tr("Save"), buttonBar);
-        QPushButton *loadWorkspaceButton = new QPushButton(tr("Load"), buttonBar);
-        QPushButton *clearWorkspaceButton = new QPushButton(tr("Clear"), buttonBar);
-        buttonBarLayout->addWidget(saveWorkspaceButton);
-        buttonBarLayout->addWidget(loadWorkspaceButton);
-        buttonBarLayout->addWidget(clearWorkspaceButton);
-        buttonBarLayout->setMargin(2);
-        buttonBar->setLayout(buttonBarLayout);
+  QHBoxLayout *buttonBarLayout = new QHBoxLayout ();
+  QPushButton *saveWorkspaceButton = new QPushButton (tr ("Save"), buttonBar);
+  QPushButton *loadWorkspaceButton = new QPushButton (tr ("Load"), buttonBar);
+  QPushButton *clearWorkspaceButton =
+    new QPushButton (tr ("Clear"), buttonBar);
+  buttonBarLayout->addWidget (saveWorkspaceButton);
+  buttonBarLayout->addWidget (loadWorkspaceButton);
+  buttonBarLayout->addWidget (clearWorkspaceButton);
+  buttonBarLayout->setMargin (2);
+  buttonBar->setLayout (buttonBarLayout);
 
-    layout->setMargin(2);
-    widget()->setLayout(layout);
+  layout->setMargin (2);
+  widget ()->setLayout (layout);
 
-    connect(saveWorkspaceButton, SIGNAL(clicked()), this, SLOT(emitSaveWorkspace()));
-    connect(loadWorkspaceButton, SIGNAL(clicked()), this, SLOT(emitLoadWorkspace()));
-    connect(clearWorkspaceButton, SIGNAL(clicked()), this, SLOT(emitClearWorkspace()));
+  connect (saveWorkspaceButton, SIGNAL (clicked ()), this,
+	   SLOT (emitSaveWorkspace ()));
+  connect (loadWorkspaceButton, SIGNAL (clicked ()), this,
+	   SLOT (emitLoadWorkspace ()));
+  connect (clearWorkspaceButton, SIGNAL (clicked ()), this,
+	   SLOT (emitClearWorkspace ()));
 
-    QTreeWidgetItem *treeWidgetItem = new QTreeWidgetItem();
-    treeWidgetItem->setData(0, 0, QString(tr("Local")));
-    m_variablesTreeWidget->insertTopLevelItem(0, treeWidgetItem);
+  QTreeWidgetItem *treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Local")));
+  m_variablesTreeWidget->insertTopLevelItem (0, treeWidgetItem);
 
-    treeWidgetItem = new QTreeWidgetItem();
-    treeWidgetItem->setData(0, 0, QString(tr("Global")));
-    m_variablesTreeWidget->insertTopLevelItem(1, treeWidgetItem);
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Global")));
+  m_variablesTreeWidget->insertTopLevelItem (1, treeWidgetItem);
 
-    treeWidgetItem = new QTreeWidgetItem();
-    treeWidgetItem->setData(0, 0, QString(tr("Persistent")));
-    m_variablesTreeWidget->insertTopLevelItem(2, treeWidgetItem);
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Persistent")));
+  m_variablesTreeWidget->insertTopLevelItem (2, treeWidgetItem);
 
-    treeWidgetItem = new QTreeWidgetItem();
-    treeWidgetItem->setData(0, 0, QString(tr("Hidden")));
-    m_variablesTreeWidget->insertTopLevelItem(3, treeWidgetItem);
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Hidden")));
+  m_variablesTreeWidget->insertTopLevelItem (3, treeWidgetItem);
 
-    m_variablesTreeWidget->expandAll();
-    m_variablesTreeWidget->setAlternatingRowColors(true);
-    m_variablesTreeWidget->setAnimated(true);    
+  m_variablesTreeWidget->expandAll ();
+  m_variablesTreeWidget->setAlternatingRowColors (true);
+  m_variablesTreeWidget->setAnimated (true);
 }
 
-void VariablesDockWidget::updateTreeEntry(QTreeWidgetItem *treeItem, SymbolRecord symbolRecord) {
-    treeItem->setData(0, 0, QString(symbolRecord.name().c_str()));
-    treeItem->setData(1, 0, QString(symbolRecord.varval().type_name().c_str()));
-    treeItem->setData(2, 0, OctaveLink::octaveValueAsQString(symbolRecord.varval()));
+void
+VariablesDockWidget::updateTreeEntry (QTreeWidgetItem * treeItem,
+				      SymbolRecord symbolRecord)
+{
+  treeItem->setData (0, 0, QString (symbolRecord.name ().c_str ()));
+  treeItem->setData (1, 0,
+		     QString (symbolRecord.varval ().type_name ().c_str ()));
+  treeItem->setData (2, 0,
+		     OctaveLink::octaveValueAsQString (symbolRecord.
+						       varval ()));
 }
 
-void VariablesDockWidget::setVariablesList(QList<SymbolRecord> symbolTable) {
-    m_updateSemaphore->acquire();
-    // Split the symbol table into its different scopes.
-    QList<SymbolRecord> localSymbolTable;
-    QList<SymbolRecord> globalSymbolTable;
-    QList<SymbolRecord> persistentSymbolTable;
-    QList<SymbolRecord> hiddenSymbolTable;
+void
+VariablesDockWidget::setVariablesList (QList < SymbolRecord > symbolTable)
+{
+  m_updateSemaphore->acquire ();
+  // Split the symbol table into its different scopes.
+  QList < SymbolRecord > localSymbolTable;
+  QList < SymbolRecord > globalSymbolTable;
+  QList < SymbolRecord > persistentSymbolTable;
+  QList < SymbolRecord > hiddenSymbolTable;
 
-    foreach(SymbolRecord symbolRecord, symbolTable) {
-        // It's true that being global or hidden includes it's can mean it's also locally visible,
-        // but we want to distinguish that here.
-        if(symbolRecord.is_local() && !symbolRecord.is_global() && !symbolRecord.is_hidden()) {
-            localSymbolTable.append(symbolRecord);
-        }
+  foreach (SymbolRecord symbolRecord, symbolTable)
+  {
+    // It's true that being global or hidden includes it's can mean it's also locally visible,
+    // but we want to distinguish that here.
+    if (symbolRecord.is_local () && !symbolRecord.is_global ()
+	&& !symbolRecord.is_hidden ())
+      {
+	localSymbolTable.append (symbolRecord);
+      }
 
-        if(symbolRecord.is_global()) {
-            globalSymbolTable.append(symbolRecord);
-        }
+    if (symbolRecord.is_global ())
+      {
+	globalSymbolTable.append (symbolRecord);
+      }
 
-        if(symbolRecord.is_persistent()) {
-            persistentSymbolTable.append(symbolRecord);
-        }
+    if (symbolRecord.is_persistent ())
+      {
+	persistentSymbolTable.append (symbolRecord);
+      }
 
-        if(symbolRecord.is_hidden()) {
-            hiddenSymbolTable.append(symbolRecord);
-        }
-    }
+    if (symbolRecord.is_hidden ())
+      {
+	hiddenSymbolTable.append (symbolRecord);
+      }
+  }
 
-    updateScope(0, localSymbolTable);
-    updateScope(1, globalSymbolTable);
-    updateScope(2, persistentSymbolTable);
-    updateScope(3, hiddenSymbolTable);
-    m_updateSemaphore->release();
+  updateScope (0, localSymbolTable);
+  updateScope (1, globalSymbolTable);
+  updateScope (2, persistentSymbolTable);
+  updateScope (3, hiddenSymbolTable);
+  m_updateSemaphore->release ();
 }
 
-void VariablesDockWidget::updateScope(int topLevelItemIndex, QList<SymbolRecord> symbolTable) {
-    // This method may be a little bit confusing; variablesList is a complete list of all
-    // variables that are in the workspace currently.
-    QTreeWidgetItem *topLevelItem = m_variablesTreeWidget->topLevelItem(topLevelItemIndex);
+void
+VariablesDockWidget::updateScope (int topLevelItemIndex,
+				  QList < SymbolRecord > symbolTable)
+{
+  // This method may be a little bit confusing; variablesList is a complete list of all
+  // variables that are in the workspace currently.
+  QTreeWidgetItem *topLevelItem =
+    m_variablesTreeWidget->topLevelItem (topLevelItemIndex);
 
-    // First we check, if any variables that exist in the model tree have to be updated
-    // or created. So we walk the variablesList check against the tree.
-    foreach(SymbolRecord symbolRecord, symbolTable) {
-        int childCount = topLevelItem->childCount();
-        bool alreadyExists = false;
-        QTreeWidgetItem *child;
+  // First we check, if any variables that exist in the model tree have to be updated
+  // or created. So we walk the variablesList check against the tree.
+  foreach (SymbolRecord symbolRecord, symbolTable)
+  {
+    int childCount = topLevelItem->childCount ();
+    bool alreadyExists = false;
+    QTreeWidgetItem *child;
 
-        // Search for the corresponding item in the tree. If it has been found, child
-        // will contain the appropriate QTreeWidgetItem* pointing at it.
-        for(int i = 0; i < childCount; i++) {
-            child = topLevelItem->child(i);
-            if(child->data(0, 0).toString() == QString(symbolRecord.name().c_str())) {
-                alreadyExists = true;
-                break;
-            }
-        }
+    // Search for the corresponding item in the tree. If it has been found, child
+    // will contain the appropriate QTreeWidgetItem* pointing at it.
+    for (int i = 0; i < childCount; i++)
+      {
+	child = topLevelItem->child (i);
+	if (child->data (0, 0).toString () ==
+	    QString (symbolRecord.name ().c_str ()))
+	  {
+	    alreadyExists = true;
+	    break;
+	  }
+      }
 
-        // If it already exists, just update it.
-        if(alreadyExists) {
-            updateTreeEntry(child, symbolRecord);
-        } else {
-            // It does not exist, so create a new one and set the right values.
-            child = new QTreeWidgetItem();
-            updateTreeEntry(child, symbolRecord);
-            topLevelItem->addChild(child);
-        }
-    }
+    // If it already exists, just update it.
+    if (alreadyExists)
+      {
+	updateTreeEntry (child, symbolRecord);
+      }
+    else
+      {
+	// It does not exist, so create a new one and set the right values.
+	child = new QTreeWidgetItem ();
+	updateTreeEntry (child, symbolRecord);
+	topLevelItem->addChild (child);
+      }
+  }
 
-    // Check the tree against the list for deleted variables.
-    for(int i = 0; i < topLevelItem->childCount(); i++) {
-        bool existsInVariableList = false;
-        QTreeWidgetItem *child = topLevelItem->child(i);
-        foreach(SymbolRecord symbolRecord, symbolTable) {
-            if(QString(symbolRecord.name().c_str()) == child->data(0, 0).toString()) {
-                existsInVariableList = true;
-            }
-        }
+  // Check the tree against the list for deleted variables.
+  for (int i = 0; i < topLevelItem->childCount (); i++)
+    {
+      bool existsInVariableList = false;
+      QTreeWidgetItem *child = topLevelItem->child (i);
+      foreach (SymbolRecord symbolRecord, symbolTable)
+      {
+	if (QString (symbolRecord.name ().c_str ()) ==
+	    child->data (0, 0).toString ())
+	  {
+	    existsInVariableList = true;
+	  }
+      }
 
-        if(!existsInVariableList) {
-            topLevelItem->removeChild(child);
-            delete child;
-            i--;
-        }
+      if (!existsInVariableList)
+	{
+	  topLevelItem->removeChild (child);
+	  delete child;
+	  i--;
+	}
     }
 }
 
-void VariablesDockWidget::emitSaveWorkspace() {
-    emit saveWorkspace();
+void
+VariablesDockWidget::emitSaveWorkspace ()
+{
+  emit saveWorkspace ();
 }
 
-void VariablesDockWidget::emitLoadWorkspace() {
-    emit loadWorkspace();
+void
+VariablesDockWidget::emitLoadWorkspace ()
+{
+  emit loadWorkspace ();
 }
 
-void VariablesDockWidget::emitClearWorkspace() {
-    emit clearWorkspace();
+void
+VariablesDockWidget::emitClearWorkspace ()
+{
+  emit clearWorkspace ();
 }
diff --git a/gui/src/VariablesDockWidget.h b/gui/src/VariablesDockWidget.h
--- a/gui/src/VariablesDockWidget.h
+++ b/gui/src/VariablesDockWidget.h
@@ -19,34 +19,33 @@
 #ifndef VARIABLESDOCKWIDGET_H
 #define VARIABLESDOCKWIDGET_H
 
 #include <QDockWidget>
 #include <QTreeWidget>
 #include <QSemaphore>
 #include "OctaveLink.h"
 
-class VariablesDockWidget : public QDockWidget
+class VariablesDockWidget:public QDockWidget
 {
-    Q_OBJECT
-public:
-    VariablesDockWidget(QWidget *parent = 0);
-    void setVariablesList(QList<SymbolRecord> symbolTable);
+Q_OBJECT public:
+  VariablesDockWidget (QWidget * parent = 0);
+  void setVariablesList (QList < SymbolRecord > symbolTable);
 
-signals:
-    void saveWorkspace();
-    void loadWorkspace();
-    void clearWorkspace();
+    signals:void saveWorkspace ();
+  void loadWorkspace ();
+  void clearWorkspace ();
 
-private slots:
-    void emitSaveWorkspace();
-    void emitLoadWorkspace();
-    void emitClearWorkspace();
+  private slots:void emitSaveWorkspace ();
+  void emitLoadWorkspace ();
+  void emitClearWorkspace ();
 
 private:
-    void construct();
-    void updateTreeEntry(QTreeWidgetItem *treeItem, SymbolRecord symbolRecord);
-    void updateScope(int topLevelItemIndex, QList<SymbolRecord> symbolTable);
-    QTreeWidget *m_variablesTreeWidget;
-    QSemaphore *m_updateSemaphore;
+  void construct ();
+  void updateTreeEntry (QTreeWidgetItem * treeItem,
+			SymbolRecord symbolRecord);
+  void updateScope (int topLevelItemIndex,
+		    QList < SymbolRecord > symbolTable);
+  QTreeWidget *m_variablesTreeWidget;
+  QSemaphore *m_updateSemaphore;
 };
 
 #endif // VARIABLESDOCKWIDGET_H
diff --git a/gui/src/qirc/IClientSocket.cpp b/gui/src/qirc/IClientSocket.cpp
--- a/gui/src/qirc/IClientSocket.cpp
+++ b/gui/src/qirc/IClientSocket.cpp
@@ -21,211 +21,269 @@
 #define ERROR_ICLIENTSOCKET_NOERROR		0
 #define ERROR_ICLIENTSOCKET_NOSOCKET            1
 #define ERROR_ICLIENTSOCKET_NOCONNECT           2
 #define ERROR_ICLIENTSOCKET_NORESOLV            3
 #define ERROR_ICLIENTSOCKET_NOREAD		4
 #define ERROR_ICLIENTSOCKET_NOWRITE		5
 #define ERROR_ICLIENTSOCKET_NOFCNTL		6
 
-const char *ICLIENTSOCKET_MENSAJES[] = {"Nothing has happened, boss",
-                                        "Can't create the socket to initiate the connection",
-                                        "Can't connect to the destination",
-                                        "Can't resolv the server name",
-                                        "Problems during read operation",
-                                        "Problems during write operation",
-                                        "Can't make the socket non-blocking"};
+const char *ICLIENTSOCKET_MENSAJES[] = { "Nothing has happened, boss",
+  "Can't create the socket to initiate the connection",
+  "Can't connect to the destination",
+  "Can't resolv the server name",
+  "Problems during read operation",
+  "Problems during write operation",
+  "Can't make the socket non-blocking"
+};
 
 #define ICLIENT_MAX_MENSAJE_ERROR 300
 
-char ICLIENTSOCKETmensajeError[ICLIENT_MAX_MENSAJE_ERROR+1];
+char ICLIENTSOCKETmensajeError[ICLIENT_MAX_MENSAJE_ERROR + 1];
 
-void IClientSocket::inicializar() {
-    handler = 0;
-    puerto = 0;
-    bzero((void *)&ip, sizeof(in_addr));
+void
+IClientSocket::inicializar ()
+{
+  handler = 0;
+  puerto = 0;
+  bzero ((void *) &ip, sizeof (in_addr));
 
-    conectado = false;
-    socketCreado = false;
-    blocking = true;
-    lastError = ERROR_ICLIENTSOCKET_NOERROR;
+  conectado = false;
+  socketCreado = false;
+  blocking = true;
+  lastError = ERROR_ICLIENTSOCKET_NOERROR;
 }
 
-IClientSocket::IClientSocket() {
-    inicializar();
+IClientSocket::IClientSocket ()
+{
+  inicializar ();
 }
 
 
-IClientSocket::~IClientSocket() {
-    if (conectado == true) {
-        close();
+IClientSocket::~IClientSocket ()
+{
+  if (conectado == true)
+    {
+      close ();
     }
 }
 
-int IClientSocket::getSocket() {
-    return handler;
+int
+IClientSocket::getSocket ()
+{
+  return handler;
 }
 
-const char *IClientSocket::strError() {
-    switch (lastError) {
-    case ERROR_ICLIENTSOCKET_NORESOLV : snprintf(ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR, "%s", ICLIENTSOCKET_MENSAJES[lastError]);
-        break;
-    default						 : snprintf(ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR, "%s - %s", ICLIENTSOCKET_MENSAJES[lastError], ::strerror(lastErrnoValue));
-        break;
+const char *
+IClientSocket::strError ()
+{
+  switch (lastError)
+    {
+    case ERROR_ICLIENTSOCKET_NORESOLV:
+      snprintf (ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR, "%s",
+		ICLIENTSOCKET_MENSAJES[lastError]);
+      break;
+    default:
+      snprintf (ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR,
+		"%s - %s",
+		ICLIENTSOCKET_MENSAJES[lastError],::
+		strerror (lastErrnoValue));
+      break;
     }
-    return ICLIENTSOCKETmensajeError;
+  return ICLIENTSOCKETmensajeError;
 }
 
-int IClientSocket::connect() {
-    if(conectado == true) {
-        close();
+int
+IClientSocket::connect ()
+{
+  if (conectado == true)
+    {
+      close ();
     }
 
-    if((handler = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-        lastError = ERROR_ICLIENTSOCKET_NOSOCKET;
-        lastErrnoValue = errno;
-        return -1;
+  if ((handler = socket (AF_INET, SOCK_STREAM, 0)) < 0)
+    {
+      lastError = ERROR_ICLIENTSOCKET_NOSOCKET;
+      lastErrnoValue = errno;
+      return -1;
     }
-    socketCreado = true;
+  socketCreado = true;
 
-    if (blocking == false) {
-        if (fcntl(handler, F_SETFL, O_NONBLOCK) < 0) {
-            lastError = ERROR_ICLIENTSOCKET_NOFCNTL;
-            lastErrnoValue = errno;
-        }
+  if (blocking == false)
+    {
+      if (fcntl (handler, F_SETFL, O_NONBLOCK) < 0)
+	{
+	  lastError = ERROR_ICLIENTSOCKET_NOFCNTL;
+	  lastErrnoValue = errno;
+	}
     }
 
-    sockaddr_in addr;
-    addr.sin_family = AF_INET;
-    addr.sin_port   = htons(puerto);
-    addr.sin_addr   = ip;
-    bzero(&(addr.sin_zero), 8);
-    int respuesta = ::connect(handler, (sockaddr *)&addr, sizeof(sockaddr_in));
+  sockaddr_in addr;
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons (puerto);
+  addr.sin_addr = ip;
+  bzero (&(addr.sin_zero), 8);
+  int respuesta =::connect (handler, (sockaddr *) & addr,
+			    sizeof (sockaddr_in));
 
-    if ((respuesta == 0) || ((respuesta < 0) && (errno == EINPROGRESS) && (blocking == false))) {
-        conectado = true;
-    } else {
-        lastError = ERROR_ICLIENTSOCKET_NOCONNECT;
-        lastErrnoValue = errno;
-        return -1;
+  if ((respuesta == 0)
+      || ((respuesta < 0) && (errno == EINPROGRESS) && (blocking == false)))
+    {
+      conectado = true;
+    }
+  else
+    {
+      lastError = ERROR_ICLIENTSOCKET_NOCONNECT;
+      lastErrnoValue = errno;
+      return -1;
     }
 
-    return 0;
+  return 0;
 }
 
 
-int IClientSocket::connect(int socket, bool block) {
-    if(socketCreado) {
-        close();
+int
+IClientSocket::connect (int socket, bool block)
+{
+  if (socketCreado)
+    {
+      close ();
     }
 
-    handler = socket;
-    bzero((void *)&ip, sizeof(in_addr));
+  handler = socket;
+  bzero ((void *) &ip, sizeof (in_addr));
 
-    conectado = true;
-    socketCreado = true;
-    blocking = block;
-    lastError = 0;
+  conectado = true;
+  socketCreado = true;
+  blocking = block;
+  lastError = 0;
 
-    if (block == false) {
-        fcntl(handler, F_SETFL, O_NONBLOCK);
+  if (block == false)
+    {
+      fcntl (handler, F_SETFL, O_NONBLOCK);
     }
 
-    return 0;
+  return 0;
 }
 
-int IClientSocket::connect(in_addr addr, unsigned int p, bool block) {
-    if(socketCreado == true) {
-        close();
+int
+IClientSocket::connect (in_addr addr, unsigned int p, bool block)
+{
+  if (socketCreado == true)
+    {
+      close ();
     }
 
-    ip = addr;
-    puerto = p;
-    blocking = block;
+  ip = addr;
+  puerto = p;
+  blocking = block;
 
-    return connect();
+  return connect ();
 }
 
-int IClientSocket::connect(const char * server, unsigned int p, bool block) {
-    if(socketCreado == true) {
-        close();
+int
+IClientSocket::connect (const char *server, unsigned int p, bool block)
+{
+  if (socketCreado == true)
+    {
+      close ();
     }
 
-    puerto = p;
-    blocking = block;
+  puerto = p;
+  blocking = block;
 
-    if (resolv(server, &ip) < 0) {
-        lastError = ERROR_ICLIENTSOCKET_NORESOLV;
-        return -1;
+  if (resolv (server, &ip) < 0)
+    {
+      lastError = ERROR_ICLIENTSOCKET_NORESOLV;
+      return -1;
     }
-    return connect();
+  return connect ();
 }
 
-long int IClientSocket::read(char *data, long count) {
-    long done = 0;
-    long res = 0;
+long int
+IClientSocket::read (char *data, long count)
+{
+  long done = 0;
+  long res = 0;
 
-    do {
-        res = recv(handler, data + done, count - done, 0);
-
-        if (res > 0)
-        {
-            done += res;
-        }
-    } while ((((done < count) && (res > 0)) && (blocking == true)) || ((res < 0) && (errno == EINTR)));
+  do
+    {
+      res = recv (handler, data + done, count - done, 0);
 
-    if (res < 0)
+      if (res > 0)
+	{
+	  done += res;
+	}
+    }
+  while ((((done < count) && (res > 0)) && (blocking == true))
+	 || ((res < 0) && (errno == EINTR)));
+
+  if (res < 0)
     {
-        if (errno == EWOULDBLOCK)
-        {
-            return 0;
-        } else {
-            lastError = ERROR_ICLIENTSOCKET_NOREAD;
-            lastErrnoValue = errno;
-            return -1;
-        }
-    } else {
-        return done;
+      if (errno == EWOULDBLOCK)
+	{
+	  return 0;
+	}
+      else
+	{
+	  lastError = ERROR_ICLIENTSOCKET_NOREAD;
+	  lastErrnoValue = errno;
+	  return -1;
+	}
+    }
+  else
+    {
+      return done;
     }
 }
 
-long IClientSocket::write(const char *data, long count) {
-    long sent = 0;
-    long response = 0;
+long
+IClientSocket::write (const char *data, long count)
+{
+  long sent = 0;
+  long response = 0;
 
-    do {
-        response = send(handler, data + sent, count - sent, 0);
+  do
+    {
+      response = send (handler, data + sent, count - sent, 0);
 
-        if (response > 0)
-        {
-            sent += response;
-        }
-    } while (((sent < count) && (response >= 0)) || ((response < 0) && (errno == EWOULDBLOCK)));
+      if (response > 0)
+	{
+	  sent += response;
+	}
+    }
+  while (((sent < count) && (response >= 0))
+	 || ((response < 0) && (errno == EWOULDBLOCK)));
 
-    if (response < 0)
+  if (response < 0)
     {
-        lastError = ERROR_ICLIENTSOCKET_NOWRITE;
-        lastErrnoValue = errno;
-        return -1;
+      lastError = ERROR_ICLIENTSOCKET_NOWRITE;
+      lastErrnoValue = errno;
+      return -1;
     }
-    return sent;
+  return sent;
 }
 
-void IClientSocket::close() {
-    if (socketCreado == true)
+void
+IClientSocket::close ()
+{
+  if (socketCreado == true)
     {
-        ::close(handler);
-        conectado = false;
-        socketCreado = false;
-        blocking = true;
+      ::close (handler);
+      conectado = false;
+      socketCreado = false;
+      blocking = true;
     }
 }
 
-int IClientSocket::resolv(const char * fqdn, in_addr * ip) {
-    hostent *host;
-    host = gethostbyname(fqdn);
-    if (host == NULL) {
-        return -1;
+int
+IClientSocket::resolv (const char *fqdn, in_addr * ip)
+{
+  hostent *host;
+  host = gethostbyname (fqdn);
+  if (host == NULL)
+    {
+      return -1;
     }
 
-    bcopy((void *)host->h_addr, (void *)ip, sizeof(in_addr));
-    return 0;
+  bcopy ((void *) host->h_addr, (void *) ip, sizeof (in_addr));
+  return 0;
 }
diff --git a/gui/src/qirc/IClientSocket.h b/gui/src/qirc/IClientSocket.h
--- a/gui/src/qirc/IClientSocket.h
+++ b/gui/src/qirc/IClientSocket.h
@@ -28,41 +28,41 @@
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
 #include <stdio.h>
 
 class IClientSocket
 {
 private:
-    int handler;
-    in_addr ip;
-    unsigned int puerto;
+  int handler;
+  in_addr ip;
+  unsigned int puerto;
 
-    int lastError, lastErrnoValue;
+  int lastError, lastErrnoValue;
 
-    bool conectado;
-    bool socketCreado;
-    bool blocking;
+  bool conectado;
+  bool socketCreado;
+  bool blocking;
 
-    void inicializar();
-    int connect();
+  void inicializar ();
+  int connect ();
 
 public:
-    IClientSocket();
-    ~IClientSocket();
+    IClientSocket ();
+   ~IClientSocket ();
 
-    int getSocket();
-    const char *strError();
+  int getSocket ();
+  const char *strError ();
 
-    int connect(int socket, bool block = true);
-    int connect(in_addr addr, unsigned int puerto, bool blocking = true);
-    int connect(const char * server, unsigned int puerto, bool blocking = true);
+  int connect (int socket, bool block = true);
+  int connect (in_addr addr, unsigned int puerto, bool blocking = true);
+  int connect (const char *server, unsigned int puerto, bool blocking = true);
 
-    long int read(char *, long count);
-    long int write(const char *, long count);
+  long int read (char *, long count);
+  long int write (const char *, long count);
 
-    void close();
+  void close ();
 
-    int resolv(const char * fqdn, in_addr * ip);
+  int resolv (const char *fqdn, in_addr * ip);
 };
 
 #endif
diff --git a/gui/src/qirc/IRCClient.cpp b/gui/src/qirc/IRCClient.cpp
--- a/gui/src/qirc/IRCClient.cpp
+++ b/gui/src/qirc/IRCClient.cpp
@@ -15,424 +15,562 @@
  *                                                                         *
  ***************************************************************************/
 
 #include "IRCClient.h"
 
 #include <string.h>
 #include <stdlib.h>
 
-void IRCClient::handleIncomingLine()
+void
+IRCClient::handleIncomingLine ()
 {
-    IRCEvent evento(lines);
-    emit event(&evento);
-    if (evento.isNumeric() == true) {
-        if (evento.getNumeric() == RPL_WELCOME) {
-            m_loggedIn = true;
-            emit completedLogin(m_nickInUse.toStdString().c_str());
-        } else if ((evento.getNumeric() == ERR_NICKNAMEINUSE) && (m_loggedIn == false)) {
-            if (testedNicks == 50) {
-                emit connectionStatus("Nicknames in use, aborting connection.");
-                disconnectFromServer();
-            } else {
-                emit connectionStatus(QString("Nickname %1 is in use.").arg(m_nickInUse).toStdString().c_str());
-                setNickInUse(QString("%1%2").arg(m_nick1).arg(testedNicks));
-                sendCommand(1, COMMAND_NICK, m_nickInUse.toStdString().c_str());
-                testedNicks++;
-            }
-        } else if (evento.getNumeric() == ERR_PASSWDMISMATCH) {
-            emit connectionStatus("The password you provided seems to be wrong.");
-        } else {
-            emit replyCode(&evento);
-        }
-        return;
+  IRCEvent evento (lines);
+  emit event (&evento);
+  if (evento.isNumeric () == true)
+    {
+      if (evento.getNumeric () == RPL_WELCOME)
+	{
+	  m_loggedIn = true;
+	  emit completedLogin (m_nickInUse.toStdString ().c_str ());
+	}
+      else if ((evento.getNumeric () == ERR_NICKNAMEINUSE)
+	       && (m_loggedIn == false))
+	{
+	  if (testedNicks == 50)
+	    {
+	      emit
+		connectionStatus ("Nicknames in use, aborting connection.");
+	      disconnectFromServer ();
+	    }
+	  else
+	    {
+	      emit connectionStatus (QString ("Nickname %1 is in use.").
+				     arg (m_nickInUse).toStdString ().
+				     c_str ());
+	      setNickInUse (QString ("%1%2").arg (m_nick1).arg (testedNicks));
+	      sendCommand (1, COMMAND_NICK,
+			   m_nickInUse.toStdString ().c_str ());
+	      testedNicks++;
+	    }
+	}
+      else if (evento.getNumeric () == ERR_PASSWDMISMATCH)
+	{
+	  emit
+	    connectionStatus ("The password you provided seems to be wrong.");
+	}
+      else
+	{
+	  emit replyCode (&evento);
+	}
+      return;
     }
 
-    QString command = evento.getCommand();
+  QString command = evento.getCommand ();
 
-    if (command == COMMAND_NICK) {
-        emit nick(evento.getNick().toStdString().c_str(),
-                  evento.getParam(0).toStdString().c_str());
+  if (command == COMMAND_NICK)
+    {
+      emit nick (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
 
-        if(evento.getNick() == nickInUse())
-            setNickInUse(evento.getParam(0));
+      if (evento.getNick () == nickInUse ())
+	setNickInUse (evento.getParam (0));
 
-        return;
-    } else if (command == COMMAND_QUIT) {
-        emit quit(evento.getNick().toStdString().c_str(),
-                  evento.getParam(0).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_JOIN) {
-        emit join(evento.getNick().toStdString().c_str(),
-                  evento.getParam(0).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_PART) {
-        emit part(evento.getNick().toStdString().c_str(),
-                  evento.getParam(0).toStdString().c_str(),
-                  evento.getParam(1).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_MODE) {
-        emit mode(&evento);
-        return;
-    } else if (command == COMMAND_TOPIC) {
-        emit topic(evento.getNick().toStdString().c_str(),
-                   evento.getParam(0).toStdString().c_str(),
-                   evento.getParam(1).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_KICK) {
-        emit kick(evento.getNick().toStdString().c_str(),
-                  evento.getParam(0).toStdString().c_str(),
-                  evento.getParam(1).toStdString().c_str(),
-                  evento.getParam(2).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_INVITE) {
-        emit invite(evento.getNick().toStdString().c_str(),
-                    evento.getParam(1).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_PRIVMSG) {
-        emit privateMessage(evento.getNick().toStdString().c_str(),
-                            evento.getParam(0).toStdString().c_str(),
-                            evento.getParam(1).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_NOTICE) {
-        emit notice(evento.getNick().toStdString().c_str(),
-                    evento.getParam(0).toStdString().c_str(),
-                    evento.getParam(1).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_PING) {
-        if (m_automaticPong == true) {
-            sendCommand(1, COMMAND_PONG, m_nickInUse.toStdString().c_str());
-        }
-        emit ping(evento.getParam(0).toStdString().c_str());
-        return;
-    } else if (command == COMMAND_ERROR) {
-        emit error(evento.getParam(0).toStdString().c_str());
-        terminateConnection();
-        return;
-    } else {
-        emit notRecognized(&evento);
+      return;
+    }
+  else if (command == COMMAND_QUIT)
+    {
+      emit quit (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_JOIN)
+    {
+      emit join (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PART)
+    {
+      emit part (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str (),
+		 evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_MODE)
+    {
+      emit mode (&evento);
+      return;
+    }
+  else if (command == COMMAND_TOPIC)
+    {
+      emit topic (evento.getNick ().toStdString ().c_str (),
+		  evento.getParam (0).toStdString ().c_str (),
+		  evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_KICK)
+    {
+      emit kick (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str (),
+		 evento.getParam (1).toStdString ().c_str (),
+		 evento.getParam (2).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_INVITE)
+    {
+      emit invite (evento.getNick ().toStdString ().c_str (),
+		   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PRIVMSG)
+    {
+      emit privateMessage (evento.getNick ().toStdString ().c_str (),
+			   evento.getParam (0).toStdString ().c_str (),
+			   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_NOTICE)
+    {
+      emit notice (evento.getNick ().toStdString ().c_str (),
+		   evento.getParam (0).toStdString ().c_str (),
+		   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PING)
+    {
+      if (m_automaticPong == true)
+	{
+	  sendCommand (1, COMMAND_PONG, m_nickInUse.toStdString ().c_str ());
+	}
+      emit ping (evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_ERROR)
+    {
+      emit error (evento.getParam (0).toStdString ().c_str ());
+      terminateConnection ();
+      return;
+    }
+  else
+    {
+      emit notRecognized (&evento);
     }
 }
 
-IRCClient::IRCClient(bool autoPong)
+IRCClient::IRCClient (bool autoPong)
 {
-    m_clientSocket = new IClientSocket();
-    m_connected = false;
-    m_loggedIn = false;
-    lines[0] = 0;
-    longitud = 0;
+  m_clientSocket = new IClientSocket ();
+  m_connected = false;
+  m_loggedIn = false;
+  lines[0] = 0;
+  longitud = 0;
 
-    m_readSocketNotifier = m_writeSocketNotifier = NULL;
-    m_automaticPong = autoPong;
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_automaticPong = autoPong;
 }
 
-IRCClient::~IRCClient() {
-    disconnectFromServer();
-    delete m_clientSocket;
+IRCClient::~IRCClient ()
+{
+  disconnectFromServer ();
+  delete m_clientSocket;
 }
 
-int IRCClient::getSocket() {
-    return m_clientSocket->getSocket();
+int
+IRCClient::getSocket ()
+{
+  return m_clientSocket->getSocket ();
 }
 
-bool IRCClient::setAutoPong(bool aP) {
-    return (m_automaticPong = aP);
+bool
+IRCClient::setAutoPong (bool aP)
+{
+  return (m_automaticPong = aP);
 }
 
-void IRCClient::initializeReadingSocket(int socketHandler) {
-    Q_UNUSED(socketHandler);
-    int error = 0;
-    bool moreThanOne = false;
-    char c;
+void
+IRCClient::initializeReadingSocket (int socketHandler)
+{
+  Q_UNUSED (socketHandler);
+  int error = 0;
+  bool moreThanOne = false;
+  char c;
 
-    while((m_connected == true) && ((error = m_clientSocket->read(&c, 1)) > 0)) {
-        if ((longitud < 510) && (c != 10) && (c != 13)) {
-            lines[longitud] = c;
-            lines[longitud+1] = 0;
-            longitud++;
-        }
+  while ((m_connected == true)
+	 && ((error = m_clientSocket->read (&c, 1)) > 0))
+    {
+      if ((longitud < 510) && (c != 10) && (c != 13))
+	{
+	  lines[longitud] = c;
+	  lines[longitud + 1] = 0;
+	  longitud++;
+	}
 
-        if (((c == 10) || (c == 13)) && (longitud > 0)) {
-            handleIncomingLine();
-            lines[0] = 0;
-            longitud = 0;
-        }
-        moreThanOne = true;
+      if (((c == 10) || (c == 13)) && (longitud > 0))
+	{
+	  handleIncomingLine ();
+	  lines[0] = 0;
+	  longitud = 0;
+	}
+      moreThanOne = true;
     }
 
-    if ((error == 0) && (moreThanOne == false)) {
-        terminateConnection();
+  if ((error == 0) && (moreThanOne == false))
+    {
+      terminateConnection ();
     }
 
-    if ((error < 0) && (m_connected == true)) {
-        terminateConnection();
+  if ((error < 0) && (m_connected == true))
+    {
+      terminateConnection ();
     }
 }
 
-void IRCClient::initializeWritingSocket(int socketHandler) {
-    Q_UNUSED(socketHandler);
-    m_writeSocketNotifier->setEnabled(false);
-    int resultado = 0;
-    socklen_t l = sizeof(resultado);
-    getsockopt(m_clientSocket->getSocket(), SOL_SOCKET, SO_ERROR, &resultado, &l);
-    if(resultado != 0) {
-        emit connectionStatus("<font color=\"#990000\"><b>Connection failed.</b></font>");
-        terminateConnection();
-    } else {
-        emit connectionStatus("<font color=\"#00AA00\"><b>Connection to server established.</b></font>");
-        m_connected = true;
-        m_readSocketNotifier->setEnabled(true);
-        emit establishedConnection();
-        setNickInUse(m_nick1);
-        m_loggedIn = false;
+void
+IRCClient::initializeWritingSocket (int socketHandler)
+{
+  Q_UNUSED (socketHandler);
+  m_writeSocketNotifier->setEnabled (false);
+  int resultado = 0;
+  socklen_t l = sizeof (resultado);
+  getsockopt (m_clientSocket->getSocket (), SOL_SOCKET, SO_ERROR, &resultado,
+	      &l);
+  if (resultado != 0)
+    {
+      emit
+	connectionStatus
+	("<font color=\"#990000\"><b>Connection failed.</b></font>");
+      terminateConnection ();
+    }
+  else
+    {
+      emit
+	connectionStatus
+	("<font color=\"#00AA00\"><b>Connection to server established.</b></font>");
+      m_connected = true;
+      m_readSocketNotifier->setEnabled (true);
+      emit establishedConnection ();
+      setNickInUse (m_nick1);
+      m_loggedIn = false;
 
-        emit connectionStatus(QString("Attempting to login as %1.")
-                              .arg(m_nickInUse).toStdString().c_str());
-        if (m_password.isNull() == false) {
-            sendCommand(1, COMMAND_PASS, m_password.toStdString().c_str());
-        }
-        sendCommand(4, COMMAND_USER, m_userName.toStdString().c_str(),
-                    "0", "0", m_realName.toStdString().c_str());
-        sendCommand(1, COMMAND_NICK, m_nickInUse.toStdString().c_str());
+      emit connectionStatus (QString ("Attempting to login as %1.").
+			     arg (m_nickInUse).toStdString ().c_str ());
+      if (m_password.isNull () == false)
+	{
+	  sendCommand (1, COMMAND_PASS, m_password.toStdString ().c_str ());
+	}
+      sendCommand (4, COMMAND_USER, m_userName.toStdString ().c_str (),
+		   "0", "0", m_realName.toStdString ().c_str ());
+      sendCommand (1, COMMAND_NICK, m_nickInUse.toStdString ().c_str ());
 
-        testedNicks = 1;
+      testedNicks = 1;
     }
 }
 
-void IRCClient::sendNickChange(QString nick) {
-    sendCommand(1, COMMAND_NICK, nick.toStdString().c_str());
+void
+IRCClient::sendNickChange (QString nick)
+{
+  sendCommand (1, COMMAND_NICK, nick.toStdString ().c_str ());
 }
 
-void IRCClient::joinChannel(QString channel) {
-    emit connectionStatus(QString("Joining channel %1.").arg(channel).toStdString().c_str());
-    sendCommand(1, COMMAND_JOIN, channel.toStdString().c_str());
-    m_recentChannel = channel;
+void
+IRCClient::joinChannel (QString channel)
+{
+  emit connectionStatus (QString ("Joining channel %1.").arg (channel).
+			 toStdString ().c_str ());
+  sendCommand (1, COMMAND_JOIN, channel.toStdString ().c_str ());
+  m_recentChannel = channel;
 }
 
-void IRCClient::sendPublicMessage(QString message) {
-    sendCommand(2, COMMAND_PRIVMSG, m_recentChannel.toStdString().c_str(),
-                message.toStdString().c_str());
+void
+IRCClient::sendPublicMessage (QString message)
+{
+  sendCommand (2, COMMAND_PRIVMSG, m_recentChannel.toStdString ().c_str (),
+	       message.toStdString ().c_str ());
 }
 
-void IRCClient::connectToServer(const char *server,
-                                int puerto,
-                                const char *nick1,
-                                const char *nick2,
-                                const char *user,
-                                const char *realName,
-                                const char *pass,
-                                int flags) {
-    Q_UNUSED(flags);
-    if (m_readSocketNotifier != NULL)
+void
+IRCClient::connectToServer (const char *server,
+			    int puerto,
+			    const char *nick1,
+			    const char *nick2,
+			    const char *user,
+			    const char *realName, const char *pass, int flags)
+{
+  Q_UNUSED (flags);
+  if (m_readSocketNotifier != NULL)
     {
-        if (m_connected == true) {
-            disconnectFromServer();
-        } else {
-            terminateConnection();
-        }
+      if (m_connected == true)
+	{
+	  disconnectFromServer ();
+	}
+      else
+	{
+	  terminateConnection ();
+	}
     }
 
-    m_connected = false;
-    IRCClient::m_nick1 = nick1;
-    IRCClient::m_nick2 = nick2;
-    IRCClient::m_userName = user;
-    IRCClient::m_password = pass;
-    IRCClient::m_realName = realName;
+  m_connected = false;
+  IRCClient::m_nick1 = nick1;
+  IRCClient::m_nick2 = nick2;
+  IRCClient::m_userName = user;
+  IRCClient::m_password = pass;
+  IRCClient::m_realName = realName;
 
-    if (m_clientSocket->connect(server, puerto, false) < 0)
+  if (m_clientSocket->connect (server, puerto, false) < 0)
     {
-        emit connectionStatus("Can't resolve the server name. Connection aborted.");
-        return;
+      emit
+	connectionStatus
+	("Can't resolve the server name. Connection aborted.");
+      return;
     }
 
-    m_writeSocketNotifier = new QSocketNotifier(m_clientSocket->getSocket(), QSocketNotifier::Write, this);
-    m_writeSocketNotifier->setEnabled(true);
-    connect(m_writeSocketNotifier, SIGNAL(activated(int)), this, SLOT(initializeWritingSocket(int)));
+  m_writeSocketNotifier =
+    new QSocketNotifier (m_clientSocket->getSocket (), QSocketNotifier::Write,
+			 this);
+  m_writeSocketNotifier->setEnabled (true);
+  connect (m_writeSocketNotifier, SIGNAL (activated (int)), this,
+	   SLOT (initializeWritingSocket (int)));
 
-    m_readSocketNotifier = new QSocketNotifier(m_clientSocket->getSocket(), QSocketNotifier::Read, this);
-    m_readSocketNotifier->setEnabled(false);
-    connect(m_readSocketNotifier, SIGNAL(activated(int)), this, SLOT(initializeReadingSocket(int)));
-    emit connectionStatus("Trying to connect to IRC server, please wait..");
+  m_readSocketNotifier =
+    new QSocketNotifier (m_clientSocket->getSocket (), QSocketNotifier::Read,
+			 this);
+  m_readSocketNotifier->setEnabled (false);
+  connect (m_readSocketNotifier, SIGNAL (activated (int)), this,
+	   SLOT (initializeReadingSocket (int)));
+  emit connectionStatus ("Trying to connect to IRC server, please wait..");
 }
 
-void IRCClient::disconnectFromServer(const char *razon)
+void
+IRCClient::disconnectFromServer (const char *razon)
 {
-    lines[0] = 0;
-    longitud = 0;
+  lines[0] = 0;
+  longitud = 0;
+
+  if (m_readSocketNotifier == NULL)
+    return;
 
-    if (m_readSocketNotifier == NULL)
-        return;
-
-    if (m_connected) {
-        if (razon == 0) {
-            sendCommand(0, COMMAND_QUIT);
-        } else {
-            sendCommand(1, COMMAND_QUIT, razon);
-        }
+  if (m_connected)
+    {
+      if (razon == 0)
+	{
+	  sendCommand (0, COMMAND_QUIT);
+	}
+      else
+	{
+	  sendCommand (1, COMMAND_QUIT, razon);
+	}
     }
 
-    delete m_readSocketNotifier;
-    delete m_writeSocketNotifier;
+  delete m_readSocketNotifier;
+  delete m_writeSocketNotifier;
 
-    m_readSocketNotifier = m_writeSocketNotifier = NULL;
-    m_clientSocket->close();
-    m_connected = m_loggedIn = false;
-    emit disconnected();
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_clientSocket->close ();
+  m_connected = m_loggedIn = false;
+  emit disconnected ();
 }
 
-void IRCClient::terminateConnection()
+void
+IRCClient::terminateConnection ()
 {
-    if (m_readSocketNotifier == NULL)
-        return;
+  if (m_readSocketNotifier == NULL)
+    return;
 
-    delete m_readSocketNotifier;
-    delete m_writeSocketNotifier;
-    m_readSocketNotifier = m_writeSocketNotifier = NULL;
-    m_clientSocket->close();
-    m_connected = m_loggedIn = false;
-    emit disconnected();
+  delete m_readSocketNotifier;
+  delete m_writeSocketNotifier;
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_clientSocket->close ();
+  m_connected = m_loggedIn = false;
+  emit disconnected ();
 }
 
 
-void IRCClient::sendLine(const char *line) {
-    QString msg = QString("%1%2").arg(line).arg(CRLF);
-    m_clientSocket->write(msg.toStdString().c_str(), msg.length());
+void
+IRCClient::sendLine (const char *line)
+{
+  QString msg = QString ("%1%2").arg (line).arg (CRLF);
+  m_clientSocket->write (msg.toStdString ().c_str (), msg.length ());
 }
 
-void IRCClient::sendCommand(int numberOfCommands, const char *command, ...) {
-    char linea[513];
-    char *parametro;
-    va_list lp;
+void
+IRCClient::sendCommand (int numberOfCommands, const char *command, ...)
+{
+  char linea[513];
+  char *parametro;
+  va_list lp;
 
-    strncpy(linea, command, 512);
-    linea[512] = 0;
-    va_start(lp, command);
-    for (int i = 0; i < numberOfCommands; i++)
+  strncpy (linea, command, 512);
+  linea[512] = 0;
+  va_start (lp, command);
+  for (int i = 0; i < numberOfCommands; i++)
     {
-        if (i == 15) break;
-        parametro = va_arg(lp, char *);
-        if (i == numberOfCommands - 1)
-        {
-            if (strlen(linea) + strlen(parametro) + 2 > 512) break;
-            if (strchr(parametro, ' ') != NULL)
-            { strcat(linea, " :");
-            } else {
-                strcat(linea, " ");
-            }
-            strcat(linea, parametro);
-        } else {
-            if (strlen(linea) + strlen(parametro) + 1 > 512) break;
-            strcat(linea, " ");
-            strcat(linea, parametro);
-        }
+      if (i == 15)
+	break;
+      parametro = va_arg (lp, char *);
+      if (i == numberOfCommands - 1)
+	{
+	  if (strlen (linea) + strlen (parametro) + 2 > 512)
+	    break;
+	  if (strchr (parametro, ' ') != NULL)
+	    {
+	      strcat (linea, " :");
+	    }
+	  else
+	    {
+	      strcat (linea, " ");
+	    }
+	  strcat (linea, parametro);
+	}
+      else
+	{
+	  if (strlen (linea) + strlen (parametro) + 1 > 512)
+	    break;
+	  strcat (linea, " ");
+	  strcat (linea, parametro);
+	}
     }
-    va_end(lp);
-    sendLine(linea);
+  va_end (lp);
+  sendLine (linea);
 }
 
 
 // ************************** IRCEvent **********************
 
-IRCEvent::IRCEvent(const char *serverMessage) {
-    char prefix[MAX_LINE_LEN];
-    int index = 0;
+IRCEvent::IRCEvent (const char *serverMessage)
+{
+  char prefix[MAX_LINE_LEN];
+  int index = 0;
 
-    nick = "";
-    user = "";
-    host = "";
-    for (int i = 0; i < 15; i++)
+  nick = "";
+  user = "";
+  host = "";
+  for (int i = 0; i < 15; i++)
     {
-        param[i] = "";
+      param[i] = "";
     }
 
-    if (serverMessage[0] == CHR_COLON)
+  if (serverMessage[0] == CHR_COLON)
     {
-        index++;
-        strcpy(prefix, getStringToken(serverMessage, index).toStdString().c_str());
+      index++;
+      strcpy (prefix,
+	      getStringToken (serverMessage, index).toStdString ().c_str ());
 
-        int etapa = 0;
-        for (unsigned int i = 0; i < strlen(prefix); i++)
-        {
-            switch (prefix[i]) {
-            case '!' : etapa = 1; break;
-            case '@' : etapa = 2; break;
-            default:
-                switch (etapa) {
-                case 0  : nick += prefix[i]; break;
-                case 1  : user += prefix[i]; break;
-                default : host += prefix[i]; break;
-                }
-            }
-        }
+      int etapa = 0;
+      for (unsigned int i = 0; i < strlen (prefix); i++)
+	{
+	  switch (prefix[i])
+	    {
+	    case '!':
+	      etapa = 1;
+	      break;
+	    case '@':
+	      etapa = 2;
+	      break;
+	    default:
+	      switch (etapa)
+		{
+		case 0:
+		  nick += prefix[i];
+		  break;
+		case 1:
+		  user += prefix[i];
+		  break;
+		default:
+		  host += prefix[i];
+		  break;
+		}
+	    }
+	}
     }
 
-    command = getStringToken(serverMessage, index);
-    command = command.toUpper();
+  command = getStringToken (serverMessage, index);
+  command = command.toUpper ();
 
-    paramCount = 0;
-    while (serverMessage[index] != 0)
+  paramCount = 0;
+  while (serverMessage[index] != 0)
     {
-        if ((serverMessage[index] == CHR_COLON) || (paramCount == 14))
-        {
+      if ((serverMessage[index] == CHR_COLON) || (paramCount == 14))
+	{
 
-            if (serverMessage[index] == CHR_COLON)
-            {
-                index++;
-            }
+	  if (serverMessage[index] == CHR_COLON)
+	    {
+	      index++;
+	    }
 
-            param[paramCount] = (const char *)(serverMessage+index);
-            index += strlen(serverMessage+index);
-        } else {
-            param[paramCount] = getStringToken(serverMessage, index);
-        }
-        paramCount++;
+	  param[paramCount] = (const char *) (serverMessage + index);
+	  index += strlen (serverMessage + index);
+	}
+      else
+	{
+	  param[paramCount] = getStringToken (serverMessage, index);
+	}
+      paramCount++;
     }
 
-    if (strlen(command.toStdString().c_str()) == strspn(command.toStdString().c_str(), DIGITS))
+  if (strlen (command.toStdString ().c_str ()) ==
+      strspn (command.toStdString ().c_str (), DIGITS))
     {
-        numeric = true;
-        codeNumber = atoi(command.toStdString().c_str());
-    } else {
-        numeric = false;
+      numeric = true;
+      codeNumber = atoi (command.toStdString ().c_str ());
+    }
+  else
+    {
+      numeric = false;
     }
 }
 
-int IRCEvent::getNumeric() {
-    if (!numeric)
+int
+IRCEvent::getNumeric ()
+{
+  if (!numeric)
     {
-        return -1;
-    } else {
-        return codeNumber;
+      return -1;
+    }
+  else
+    {
+      return codeNumber;
     }
 }
 
-QString IRCEvent::getParam(int index) {
-    if ((index < 0) || (index > 14)) {
-        return QString();
-    } else {
-        return param[index];
+QString
+IRCEvent::getParam (int index)
+{
+  if ((index < 0) || (index > 14))
+    {
+      return QString ();
+    }
+  else
+    {
+      return param[index];
     }
 }
 
-int IRCEvent::skipSpaces(const char *line, int &index) {
-    while (line[index] == CHR_SPACE)
+int
+IRCEvent::skipSpaces (const char *line, int &index)
+{
+  while (line[index] == CHR_SPACE)
     {
-        index++;
+      index++;
     }
-    return index;
+  return index;
 }
 
-QString IRCEvent::getStringToken(const char *line, int &index)
+QString
+IRCEvent::getStringToken (const char *line, int &index)
 {
-    QString token("");
-    skipSpaces(line, index);
-    while ((line[index] != CHR_SPACE) && (line[index] != CHR_ZERO)) {
-        token += line[index];
-        index++;
+  QString token ("");
+  skipSpaces (line, index);
+  while ((line[index] != CHR_SPACE) && (line[index] != CHR_ZERO))
+    {
+      token += line[index];
+      index++;
     }
 
-    skipSpaces(line, index);
-    return token;
+  skipSpaces (line, index);
+  return token;
 }
 
-QString IRCEvent::getStringToken(QString line, int &index) {
-    return getStringToken(line.toStdString().c_str(), index);
+QString
+IRCEvent::getStringToken (QString line, int &index)
+{
+  return getStringToken (line.toStdString ().c_str (), index);
 }
diff --git a/gui/src/qirc/IRCClient.h b/gui/src/qirc/IRCClient.h
--- a/gui/src/qirc/IRCClient.h
+++ b/gui/src/qirc/IRCClient.h
@@ -25,119 +25,147 @@
 #include <stdarg.h>
 
 #define MAX_LINE_LEN 512
 #define PARAM_MAX_COUNT 15
 #define CHR_COLON ':'
 #define CHR_SPACE ' '
 #define CHR_ZERO '\0'
 #ifdef Q_OS_LINUX
- #define CRLF "\n"
+#define CRLF "\n"
 #else
- #define CRLF "\r\n"
+#define CRLF "\r\n"
 #endif
 #define DIGITS	"0123456789"
 
 class IRCEvent
 {
 private:
-    int codeNumber;
-    bool numeric;
+  int codeNumber;
+  bool numeric;
 
-    QString nick, user, host;
-    QString command;
-    int  paramCount;
-    QString param[PARAM_MAX_COUNT];
+  QString nick, user, host;
+  QString command;
+  int paramCount;
+  QString param[PARAM_MAX_COUNT];
 
 protected:
-    int skipSpaces(const char *linea, int &index);
-    QString getStringToken(const char *linea, int &index);
-    QString getStringToken(QString linea, int &index);
+  int skipSpaces (const char *linea, int &index);
+  QString getStringToken (const char *linea, int &index);
+  QString getStringToken (QString linea, int &index);
 
 public:
-    IRCEvent(const char * serverMessage);
+    IRCEvent (const char *serverMessage);
 
-    bool isNumeric() { return numeric; }
+  bool isNumeric ()
+  {
+    return numeric;
+  }
 
-    QString getNick() { return nick; }
-    QString getUser() { return user; }
-    QString getHost() { return host; }
-    QString getCommand() { return command; }
-    int getNumeric();
+  QString getNick ()
+  {
+    return nick;
+  }
+  QString getUser ()
+  {
+    return user;
+  }
+  QString getHost ()
+  {
+    return host;
+  }
+  QString getCommand ()
+  {
+    return command;
+  }
+  int getNumeric ();
 
-    int getParamCount() { return paramCount; }
-    QString getParam(int index);
+  int getParamCount ()
+  {
+    return paramCount;
+  }
+  QString getParam (int index);
 };
 
-class IRCClient : public QObject
+class IRCClient:public QObject
 {
-    Q_OBJECT
-public:
-    IRCClient(bool autoPong = true);
-    ~IRCClient();
+Q_OBJECT public:
+  IRCClient (bool autoPong = true);
+  ~IRCClient ();
 
-    int getSocket();
-    bool setAutoPong(bool aP);
+  int getSocket ();
+  bool setAutoPong (bool aP);
 
-    void connectToServer(const char *server, int puerto, const char *m_nick1, const char * m_nick2, const char * m_userName, const char * m_realName, const char *m_password, int flags);
-    void disconnectFromServer(const char *razon = 0);
-    void terminateConnection();
+  void connectToServer (const char *server, int puerto, const char *m_nick1,
+			const char *m_nick2, const char *m_userName,
+			const char *m_realName, const char *m_password,
+			int flags);
+  void disconnectFromServer (const char *razon = 0);
+  void terminateConnection ();
 
-    void sendLine(const char *lines);
-    void sendCommand(int numberOfCommands, const char *command, ...);
+  void sendLine (const char *lines);
+  void sendCommand (int numberOfCommands, const char *command, ...);
 
-    QString nickInUse() { return m_nickInUse; }
-    void sendNickChange(QString nick);
-    void joinChannel(QString channel);
-    void sendPublicMessage(QString message);
+  QString nickInUse ()
+  {
+    return m_nickInUse;
+  }
+  void sendNickChange (QString nick);
+  void joinChannel (QString channel);
+  void sendPublicMessage (QString message);
 
-protected slots:
-    void initializeReadingSocket(int);
-    void initializeWritingSocket(int);
+  protected slots:void initializeReadingSocket (int);
+  void initializeWritingSocket (int);
 
 signals:
-    void establishedConnection();
-    void connectionStatus(const char *mensaje);
-    void completedLogin(const char * nick);
-    void disconnected();
+  void establishedConnection ();
+  void connectionStatus (const char *mensaje);
+  void completedLogin (const char *nick);
+  void disconnected ();
 
-    void event(IRCEvent *ircEvent);
-    void notRecognized(IRCEvent *e);
-    void replyCode(IRCEvent *);
+  void event (IRCEvent * ircEvent);
+  void notRecognized (IRCEvent * e);
+  void replyCode (IRCEvent *);
 
-    void nick(const char *nick, const char *newNick) ;
-    void quit(const char *nick, const char *razon);
-    void join(const char *nick, const char *canal);
-    void part(const char *nick, const char *canal, const char *mensaje);
-    void mode(IRCEvent *evento);
-    void topic(const char *nick, const char *canal, const char *topic);
-    void invite(const char *nick, const char *canal);
-    void kick(const char *nick, const char *canal, const char *echado, const char *razon);
+  void nick (const char *nick, const char *newNick);
+  void quit (const char *nick, const char *razon);
+  void join (const char *nick, const char *canal);
+  void part (const char *nick, const char *canal, const char *mensaje);
+  void mode (IRCEvent * evento);
+  void topic (const char *nick, const char *canal, const char *topic);
+  void invite (const char *nick, const char *canal);
+  void kick (const char *nick, const char *canal, const char *echado,
+	     const char *razon);
 
-    void privateMessage(const char *nick, const char *destino, const char *mensaje);
-    void notice(const char *nick, const char *destino, const char *mensaje);
+  void privateMessage (const char *nick, const char *destino,
+		       const char *mensaje);
+  void notice (const char *nick, const char *destino, const char *mensaje);
 
-    void ping(const char *server);
-    void error(const char *mensaje);
+  void ping (const char *server);
+  void error (const char *mensaje);
 
-    void nickInUseChanged();
+  void nickInUseChanged ();
 
 private:
-    void setNickInUse(QString nick) { m_nickInUse = nick; emit nickInUseChanged(); }
-    void handleIncomingLine();
+  void setNickInUse (QString nick)
+  {
+    m_nickInUse = nick;
+    emit nickInUseChanged ();
+  }
+  void handleIncomingLine ();
 
-    bool m_connected;
-    bool m_loggedIn;
-    int testedNicks;
+  bool m_connected;
+  bool m_loggedIn;
+  int testedNicks;
 
-    char lines[MAX_LINE_LEN+1]; // 513 ( para darle espacio al 0 )
-    int longitud;
-    IClientSocket *m_clientSocket;
+  char lines[MAX_LINE_LEN + 1];	// 513 ( para darle espacio al 0 )
+  int longitud;
+  IClientSocket *m_clientSocket;
 
-    QSocketNotifier *m_readSocketNotifier, *m_writeSocketNotifier;
+  QSocketNotifier *m_readSocketNotifier, *m_writeSocketNotifier;
 
-    QString m_nick1, m_nick2, m_password;
-    QString m_nickInUse, m_userName, m_realName;
-    QString m_recentChannel;
-    bool m_automaticPong;
+  QString m_nick1, m_nick2, m_password;
+  QString m_nickInUse, m_userName, m_realName;
+  QString m_recentChannel;
+  bool m_automaticPong;
 };
 
 #endif
diff --git a/gui/src/qirc/Makefile.am b/gui/src/qirc/Makefile.am
--- a/gui/src/qirc/Makefile.am
+++ b/gui/src/qirc/Makefile.am
@@ -1,29 +1,34 @@
 ####### kdevelop will overwrite this part!!! (begin)##########
 bin_PROGRAMS = qirc
-qirc_SOURCES = programcommand.cpp newtab.cpp MainTab.cpp notifyshowcase.cpp channellist.cpp dccget.cpp dccsend.cpp IServerSocket.cpp general.cpp listanicks.cpp qirc.cpp ventanas.cpp inputBox.cpp cuadroListaNicks.cpp cuadroConfiguracion.cpp cuadroConectarCon.cpp colamensajes.cpp IRCClient.cpp IClientSocket.cpp Config.cpp ChatView.cpp main.cpp 
-qirc_LDADD   = -lqt -lXext -lX11 $(LIBSOCKET)
-
-SUBDIRS = docs 
-
-EXTRA_DIST = main.cpp qirc.h ChatView.cpp ChatView.h Config.cpp Config.h IClientSocket.cpp IClientSocket.h IRCClient.cpp IRCClient.h IRCCodes.h colamensajes.cpp colamensajes.h cuadroConectarCon.cpp cuadroConectarCon.h cuadroConfiguracion.cpp cuadroConfiguracion.h cuadroListaNicks.cpp cuadroListaNicks.h inputBox.cpp inputBox.h ventanas.cpp ventanas.h qirc.cpp resource.h qirc16x16.xpm qirc32x32.xpm qirc64x64.xpm listanicks.cpp listanicks.h general.h general.cpp IServerSocket.cpp IServerSocket.h dccsend.cpp dccsend.h dccget.cpp dccget.h connect.xpm dccsend.xpm help.xpm connectto.xpm disconnect.xpm join.xpm part.xpm list.xpm channellist.cpp channellist.h notifyshowcase.cpp notifyshowcase.h offline.xpm online.xpm operator.xpm justconn.xpm MainTab.cpp MainTab.h newtab.cpp newtab.h leftArrowDisabled.xpm leftArrowEnabled.xpm rightArrowDisabled.xpm rightArrowEnabled.xpm tabLeft.xpm tabMiddle.xpm tabRight.xpm tabClose.xpm programcommand.cpp programcommand.h 
-
+  qirc_SOURCES =
+  programcommand.cpp newtab.cpp MainTab.cpp notifyshowcase.cpp channellist.
+  cpp dccget.cpp dccsend.cpp IServerSocket.cpp general.cpp listanicks.
+  cpp qirc.cpp ventanas.cpp inputBox.cpp cuadroListaNicks.
+  cpp cuadroConfiguracion.cpp cuadroConectarCon.cpp colamensajes.
+  cpp IRCClient.cpp IClientSocket.cpp Config.cpp ChatView.cpp main.
+  cpp qirc_LDADD = -lqt - lXext - lX11 $ (LIBSOCKET) SUBDIRS =
+  docs EXTRA_DIST =
+  main.cpp qirc.h ChatView.cpp ChatView.h Config.cpp Config.h IClientSocket.
+  cpp IClientSocket.h IRCClient.cpp IRCClient.h IRCCodes.h colamensajes.
+  cpp colamensajes.h cuadroConectarCon.cpp cuadroConectarCon.
+  h cuadroConfiguracion.cpp cuadroConfiguracion.h cuadroListaNicks.
+  cpp cuadroListaNicks.h inputBox.cpp inputBox.h ventanas.cpp ventanas.h qirc.
+  cpp resource.h qirc16x16.xpm qirc32x32.xpm qirc64x64.xpm listanicks.
+  cpp listanicks.h general.h general.cpp IServerSocket.cpp IServerSocket.
+  h dccsend.cpp dccsend.h dccget.cpp dccget.h connect.xpm dccsend.xpm help.
+  xpm connectto.xpm disconnect.xpm join.xpm part.xpm list.xpm channellist.
+  cpp channellist.h notifyshowcase.cpp notifyshowcase.h offline.xpm online.
+  xpm operator.xpm justconn.xpm MainTab.cpp MainTab.h newtab.cpp newtab.
+  h leftArrowDisabled.xpm leftArrowEnabled.xpm rightArrowDisabled.
+  xpm rightArrowEnabled.xpm tabLeft.xpm tabMiddle.xpm tabRight.xpm tabClose.
+  xpm programcommand.cpp programcommand.h
 ####### kdevelop will overwrite this part!!! (end)############
-
-
-# set the include path for X, qt and KDE
-INCLUDES= $(all_includes)
-# claim, which subdirectories you want to install
-# you can add here more. This one gets installed 
-bin_PROGRAMS = qirc 
-
-qirc_METASOURCES = USE_AUTOMOC
-
-# the library search path. 
-qirc_LDFLAGS = $(all_libraries) 
-
-# them while "make clean", use CLEANFILES
-DISTCLEANFILES = $(qirc_METASOURCES)
-
-
-
-
+#set the include path for X, qt and KDE
+  INCLUDES = $ (all_includes)
+#claim, which subdirectories you want to install
+#you can add here more. This one gets installed
+  bin_PROGRAMS = qirc qirc_METASOURCES = USE_AUTOMOC
+#the library search path.
+  qirc_LDFLAGS = $ (all_libraries)
+#them while "make clean", use CLEANFILES
+  DISTCLEANFILES = $ (qirc_METASOURCES)
diff --git a/gui/src/terminal/BlockArray.cpp b/gui/src/terminal/BlockArray.cpp
--- a/gui/src/terminal/BlockArray.cpp
+++ b/gui/src/terminal/BlockArray.cpp
@@ -28,305 +28,352 @@
 #include <unistd.h>
 #include <stdio.h>
 
 #define KDE_fseek ::fseek
 #define KDE_lseek ::lseek
 
 static int blocksize = 0;
 
-BlockArray::BlockArray()
-    : size(0),
-      current(size_t(-1)),
-      index(size_t(-1)),
-      lastmap(0),
-      lastmap_index(size_t(-1)),
-      lastblock(0), ion(-1),
-      length(0)
+BlockArray::BlockArray ():size (0),
+current (size_t (-1)),
+index (size_t (-1)),
+lastmap (0), lastmap_index (size_t (-1)), lastblock (0), ion (-1), length (0)
 {
-    // lastmap_index = index = current = size_t(-1);
-    if (blocksize == 0)
-        blocksize = ((sizeof(Block) / getpagesize()) + 1) * getpagesize();
+  // lastmap_index = index = current = size_t(-1);
+  if (blocksize == 0)
+    blocksize = ((sizeof (Block) / getpagesize ()) + 1) * getpagesize ();
 
 }
 
-BlockArray::~BlockArray()
+BlockArray::~BlockArray ()
 {
-    setHistorySize(0);
-    assert(!lastblock);
+  setHistorySize (0);
+  assert (!lastblock);
 }
 
-size_t BlockArray::append(Block *block)
+size_t
+BlockArray::append (Block * block)
 {
-    if (!size)
-        return size_t(-1);
+  if (!size)
+    return size_t (-1);
 
-    ++current;
-    if (current >= size) current = 0;
+  ++current;
+  if (current >= size)
+    current = 0;
 
-    int rc;
-    rc = KDE_lseek(ion, current * blocksize, SEEK_SET); if (rc < 0) { perror("HistoryBuffer::add.seek"); setHistorySize(0); return size_t(-1); }
-    rc = write(ion, block, blocksize); if (rc < 0) { perror("HistoryBuffer::add.write"); setHistorySize(0); return size_t(-1); }
+  int rc;
+  rc = KDE_lseek (ion, current * blocksize, SEEK_SET);
+  if (rc < 0)
+    {
+      perror ("HistoryBuffer::add.seek");
+      setHistorySize (0);
+      return size_t (-1);
+    }
+  rc = write (ion, block, blocksize);
+  if (rc < 0)
+    {
+      perror ("HistoryBuffer::add.write");
+      setHistorySize (0);
+      return size_t (-1);
+    }
 
-    length++;
-    if (length > size) length = size;
+  length++;
+  if (length > size)
+    length = size;
 
-    ++index;
+  ++index;
 
-    delete block;
-    return current;
+  delete block;
+  return current;
 }
 
-size_t BlockArray::newBlock()
+size_t
+BlockArray::newBlock ()
 {
-    if (!size)
-        return size_t(-1);
-    append(lastblock);
+  if (!size)
+    return size_t (-1);
+  append (lastblock);
 
-    lastblock = new Block();
-    return index + 1;
+  lastblock = new Block ();
+  return index + 1;
 }
 
-Block *BlockArray::lastBlock() const
+Block *
+BlockArray::lastBlock () const
 {
-    return lastblock;
+  return lastblock;
 }
 
-bool BlockArray::has(size_t i) const
+bool
+BlockArray::has (size_t i) const
 {
-    if (i == index + 1)
-        return true;
+  if (i == index + 1)
+    return true;
 
-    if (i > index)
-        return false;
-    if (index - i >= length)
-        return false;
-    return true;
+  if (i > index)
+    return false;
+  if (index - i >= length)
+    return false;
+  return true;
 }
 
-const Block* BlockArray::at(size_t i)
+const Block *
+BlockArray::at (size_t i)
 {
-    if (i == index + 1)
-        return lastblock;
+  if (i == index + 1)
+    return lastblock;
 
-    if (i == lastmap_index)
-        return lastmap;
+  if (i == lastmap_index)
+    return lastmap;
 
-    if (i > index) {
-        //kDebug(1211) << "BlockArray::at() i > index\n";
-        return 0;
+  if (i > index)
+    {
+      //kDebug(1211) << "BlockArray::at() i > index\n";
+      return 0;
     }
-    
+
 //     if (index - i >= length) {
 //         kDebug(1211) << "BlockArray::at() index - i >= length\n";
 //         return 0;
 //     }
 
-    size_t j = i; // (current - (index - i) + (index/size+1)*size) % size ;
+  size_t j = i;			// (current - (index - i) + (index/size+1)*size) % size ;
 
-    assert(j < size);
-    unmap();
+  assert (j < size);
+  unmap ();
 
-    Block *block = (Block*)mmap(0, blocksize, PROT_READ, MAP_PRIVATE, ion, j * blocksize);
+  Block *block =
+    (Block *) mmap (0, blocksize, PROT_READ, MAP_PRIVATE, ion, j * blocksize);
 
-    if (block == (Block*)-1) { perror("mmap"); return 0; }
+  if (block == (Block *) - 1)
+    {
+      perror ("mmap");
+      return 0;
+    }
 
-    lastmap = block;
-    lastmap_index = i;
+  lastmap = block;
+  lastmap_index = i;
 
-    return block;
+  return block;
 }
 
-void BlockArray::unmap()
+void
+BlockArray::unmap ()
 {
-    if (lastmap) {
-        int res = munmap((char*)lastmap, blocksize);
-        if (res < 0) perror("munmap");
+  if (lastmap)
+    {
+      int res = munmap ((char *) lastmap, blocksize);
+      if (res < 0)
+	perror ("munmap");
     }
-    lastmap = 0;
-    lastmap_index = size_t(-1);
+  lastmap = 0;
+  lastmap_index = size_t (-1);
 }
 
-bool BlockArray::setSize(size_t newsize)
+bool
+BlockArray::setSize (size_t newsize)
 {
-    return setHistorySize(newsize * 1024 / blocksize);
+  return setHistorySize (newsize * 1024 / blocksize);
 }
 
-bool BlockArray::setHistorySize(size_t newsize)
+bool
+BlockArray::setHistorySize (size_t newsize)
 {
 //    kDebug(1211) << "setHistorySize " << size << " " << newsize;
 
-    if (size == newsize)
-        return false;
+  if (size == newsize)
+    return false;
 
-    unmap();
+  unmap ();
 
-    if (!newsize) {
-        delete lastblock;
-        lastblock = 0;
-        if (ion >= 0) close(ion);
-        ion = -1;
-        current = size_t(-1);
-        return true;
+  if (!newsize)
+    {
+      delete lastblock;
+      lastblock = 0;
+      if (ion >= 0)
+	close (ion);
+      ion = -1;
+      current = size_t (-1);
+      return true;
     }
 
-    if (!size) {
-        FILE* tmp = tmpfile();
-        if (!tmp) {
-            perror("konsole: cannot open temp file.\n");
-        } else {
-            ion = dup(fileno(tmp));
-            if (ion<0) {
-                perror("konsole: cannot dup temp file.\n");
-                fclose(tmp);
-            }
-        }
-        if (ion < 0)
-            return false;
+  if (!size)
+    {
+      FILE *tmp = tmpfile ();
+      if (!tmp)
+	{
+	  perror ("konsole: cannot open temp file.\n");
+	}
+      else
+	{
+	  ion = dup (fileno (tmp));
+	  if (ion < 0)
+	    {
+	      perror ("konsole: cannot dup temp file.\n");
+	      fclose (tmp);
+	    }
+	}
+      if (ion < 0)
+	return false;
 
-        assert(!lastblock);
+      assert (!lastblock);
 
-        lastblock = new Block();
-        size = newsize;
-        return false;
+      lastblock = new Block ();
+      size = newsize;
+      return false;
     }
 
-    if (newsize > size) {
-        increaseBuffer();
-        size = newsize;
-        return false;
-    } else {
-        decreaseBuffer(newsize);
-        if (ftruncate(ion, length*blocksize) == -1)
-            perror("ftruncate");
-        size = newsize;
+  if (newsize > size)
+    {
+      increaseBuffer ();
+      size = newsize;
+      return false;
+    }
+  else
+    {
+      decreaseBuffer (newsize);
+      if (ftruncate (ion, length * blocksize) == -1)
+	perror ("ftruncate");
+      size = newsize;
 
-        return true;
+      return true;
     }
 }
 
-void moveBlock(FILE *fion, int cursor, int newpos, char *buffer2)
+void
+moveBlock (FILE * fion, int cursor, int newpos, char *buffer2)
 {
-    int res = KDE_fseek(fion, cursor * blocksize, SEEK_SET);
-    if (res)
-        perror("fseek");
-    res = fread(buffer2, blocksize, 1, fion);
-    if (res != 1)
-        perror("fread");
+  int res = KDE_fseek (fion, cursor * blocksize, SEEK_SET);
+  if (res)
+    perror ("fseek");
+  res = fread (buffer2, blocksize, 1, fion);
+  if (res != 1)
+    perror ("fread");
 
-    res = KDE_fseek(fion, newpos * blocksize, SEEK_SET);
-    if (res)
-        perror("fseek");
-    res = fwrite(buffer2, blocksize, 1, fion);
-    if (res != 1)
-        perror("fwrite");
+  res = KDE_fseek (fion, newpos * blocksize, SEEK_SET);
+  if (res)
+    perror ("fseek");
+  res = fwrite (buffer2, blocksize, 1, fion);
+  if (res != 1)
+    perror ("fwrite");
 }
 
-void BlockArray::decreaseBuffer(size_t newsize)
+void
+BlockArray::decreaseBuffer (size_t newsize)
 {
-    if (index < newsize) // still fits in whole
-        return;
+  if (index < newsize)		// still fits in whole
+    return;
 
-    int offset = (current - (newsize - 1) + size) % size;
+  int offset = (current - (newsize - 1) + size) % size;
 
-    if (!offset)
-        return;
+  if (!offset)
+    return;
 
-    // The Block constructor could do somthing in future...
-    char *buffer1 = new char[blocksize];
+  // The Block constructor could do somthing in future...
+  char *buffer1 = new char[blocksize];
 
-    FILE *fion = fdopen(dup(ion), "w+b");
-    if (!fion) {
-        delete [] buffer1;
-        perror("fdopen/dup");
-        return;
+  FILE *fion = fdopen (dup (ion), "w+b");
+  if (!fion)
+    {
+      delete[]buffer1;
+      perror ("fdopen/dup");
+      return;
     }
 
-    int firstblock;
-    if (current <= newsize) {
-        firstblock = current + 1;
-    } else {
-        firstblock = 0;
+  int firstblock;
+  if (current <= newsize)
+    {
+      firstblock = current + 1;
+    }
+  else
+    {
+      firstblock = 0;
     }
 
-    size_t oldpos;
-    for (size_t i = 0, cursor=firstblock; i < newsize; i++) {
-        oldpos = (size + cursor + offset) % size;
-        moveBlock(fion, oldpos, cursor, buffer1);
-        if (oldpos < newsize) {
-            cursor = oldpos;
-        } else
-            cursor++;
+  size_t oldpos;
+  for (size_t i = 0, cursor = firstblock; i < newsize; i++)
+    {
+      oldpos = (size + cursor + offset) % size;
+      moveBlock (fion, oldpos, cursor, buffer1);
+      if (oldpos < newsize)
+	{
+	  cursor = oldpos;
+	}
+      else
+	cursor++;
     }
 
-    current = newsize - 1;
-    length = newsize;
+  current = newsize - 1;
+  length = newsize;
 
-    delete [] buffer1;
+  delete[]buffer1;
 
-    fclose(fion);
+  fclose (fion);
 
 }
 
-void BlockArray::increaseBuffer()
+void
+BlockArray::increaseBuffer ()
 {
-    if (index < size) // not even wrapped once
-        return;
+  if (index < size)		// not even wrapped once
+    return;
 
-    int offset = (current + size + 1) % size;
-    if (!offset) // no moving needed
-        return;
+  int offset = (current + size + 1) % size;
+  if (!offset)			// no moving needed
+    return;
 
-    // The Block constructor could do somthing in future...
-    char *buffer1 = new char[blocksize];
-    char *buffer2 = new char[blocksize];
+  // The Block constructor could do somthing in future...
+  char *buffer1 = new char[blocksize];
+  char *buffer2 = new char[blocksize];
 
-    int runs = 1;
-    int bpr = size; // blocks per run
+  int runs = 1;
+  int bpr = size;		// blocks per run
 
-    if (size % offset == 0) {
-        bpr = size / offset;
-        runs = offset;
+  if (size % offset == 0)
+    {
+      bpr = size / offset;
+      runs = offset;
     }
 
-    FILE *fion = fdopen(dup(ion), "w+b");
-    if (!fion) {
-        perror("fdopen/dup");
-    delete [] buffer1;
-    delete [] buffer2;
-        return;
+  FILE *fion = fdopen (dup (ion), "w+b");
+  if (!fion)
+    {
+      perror ("fdopen/dup");
+      delete[]buffer1;
+      delete[]buffer2;
+      return;
     }
 
-    int res;
-    for (int i = 0; i < runs; i++)
+  int res;
+  for (int i = 0; i < runs; i++)
     {
-        // free one block in chain
-        int firstblock = (offset + i) % size;
-        res = KDE_fseek(fion, firstblock * blocksize, SEEK_SET);
-        if (res)
-            perror("fseek");
-        res = fread(buffer1, blocksize, 1, fion);
-        if (res != 1)
-            perror("fread");
-        int newpos = 0;
-        for (int j = 1, cursor=firstblock; j < bpr; j++)
-        {
-            cursor = (cursor + offset) % size;
-            newpos = (cursor - offset + size) % size;
-            moveBlock(fion, cursor, newpos, buffer2);
-        }
-        res = KDE_fseek(fion, i * blocksize, SEEK_SET);
-        if (res)
-            perror("fseek");
-        res = fwrite(buffer1, blocksize, 1, fion);
-        if (res != 1)
-            perror("fwrite");
+      // free one block in chain
+      int firstblock = (offset + i) % size;
+      res = KDE_fseek (fion, firstblock * blocksize, SEEK_SET);
+      if (res)
+	perror ("fseek");
+      res = fread (buffer1, blocksize, 1, fion);
+      if (res != 1)
+	perror ("fread");
+      int newpos = 0;
+      for (int j = 1, cursor = firstblock; j < bpr; j++)
+	{
+	  cursor = (cursor + offset) % size;
+	  newpos = (cursor - offset + size) % size;
+	  moveBlock (fion, cursor, newpos, buffer2);
+	}
+      res = KDE_fseek (fion, i * blocksize, SEEK_SET);
+      if (res)
+	perror ("fseek");
+      res = fwrite (buffer1, blocksize, 1, fion);
+      if (res != 1)
+	perror ("fwrite");
     }
-    current = size - 1;
-    length = size;
+  current = size - 1;
+  length = size;
 
-    delete [] buffer1;
-    delete [] buffer2;
+  delete[]buffer1;
+  delete[]buffer2;
 
-    fclose(fion);
+  fclose (fion);
 
 }
-
diff --git a/gui/src/terminal/BlockArray.h b/gui/src/terminal/BlockArray.h
--- a/gui/src/terminal/BlockArray.h
+++ b/gui/src/terminal/BlockArray.h
@@ -21,95 +21,106 @@
 #ifndef BLOCKARRAY_H
 #define BLOCKARRAY_H
 
 #include <unistd.h>
 
 #define BlockSize (1 << 12)
 #define ENTRIES   ((BlockSize - sizeof(size_t) ) / sizeof(unsigned char))
 
-struct Block {
-    Block() { size = 0; }
-    unsigned char data[ENTRIES];
-    size_t size;
+struct Block
+{
+  Block ()
+  {
+    size = 0;
+  }
+  unsigned char data[ENTRIES];
+  size_t size;
 };
 
 // ///////////////////////////////////////////////////////
 
-class BlockArray {
+class BlockArray
+{
 public:
     /**
     * Creates a history file for holding
     * maximal size blocks. If more blocks
     * are requested, then it drops earlier
     * added ones.
     */
-    BlockArray();
+  BlockArray ();
 
-    /// destructor
-    ~BlockArray();
+  /// destructor
+  ~BlockArray ();
 
     /**
     * adds the Block at the end of history.
     * This may drop other blocks.
     *
     * The ownership on the block is transferred.
     * An unique index number is returned for accessing
     * it later (if not yet dropped then)
     *
     * Note, that the block may be dropped completely
     * if history is turned off.
     */
-    size_t append(Block *block);
+  size_t append (Block * block);
 
     /**
     * gets the block at the index. Function may return
     * 0 if the block isn't available any more.
     *
     * The returned block is strictly readonly as only
     * maped in memory - and will be invalid on the next
     * operation on this class.
     */
-    const Block *at(size_t index);
+  const Block *at (size_t index);
 
     /**
     * reorders blocks as needed. If newsize is null,
     * the history is emptied completely. The indices
     * returned on append won't change their semantic,
     * but they may not be valid after this call.
     */
-    bool setHistorySize(size_t newsize);
+  bool setHistorySize (size_t newsize);
 
-    size_t newBlock();
+  size_t newBlock ();
 
-    Block *lastBlock() const;
+  Block *lastBlock () const;
 
     /**
     * Convenient function to set the size in KBytes
     * instead of blocks
     */
-    bool setSize(size_t newsize);
+  bool setSize (size_t newsize);
 
-    size_t len() const { return length; }
+  size_t len () const
+  {
+    return length;
+  }
 
-    bool has(size_t index) const;
+  bool has (size_t index) const;
 
-    size_t getCurrent() const { return current; }
+  size_t getCurrent () const
+  {
+    return current;
+  }
 
 private:
-    void unmap();
-    void increaseBuffer();
-    void decreaseBuffer(size_t newsize);
+  void unmap ();
+  void increaseBuffer ();
+  void decreaseBuffer (size_t newsize);
 
-    size_t size;
-    // current always shows to the last inserted block
-    size_t current;
-    size_t index;
+  size_t size;
+  // current always shows to the last inserted block
+  size_t current;
+  size_t index;
 
-    Block *lastmap;
-    size_t lastmap_index;
-    Block *lastblock;
+  Block *lastmap;
+  size_t lastmap_index;
+  Block *lastblock;
 
-    int ion;
-    size_t length;
+  int ion;
+  size_t length;
 
 };
 #endif
diff --git a/gui/src/terminal/Character.h b/gui/src/terminal/Character.h
--- a/gui/src/terminal/Character.h
+++ b/gui/src/terminal/Character.h
@@ -26,27 +26,27 @@
 // Qt
 #include <QtCore/QHash>
 
 // Local
 #include "CharacterColor.h"
 
 typedef unsigned char LineProperty;
 
-static const int LINE_DEFAULT        = 0;
-static const int LINE_WRAPPED          = (1 << 0);
-static const int LINE_DOUBLEWIDTH      = (1 << 1);
-static const int LINE_DOUBLEHEIGHT    = (1 << 2);
+static const int LINE_DEFAULT = 0;
+static const int LINE_WRAPPED = (1 << 0);
+static const int LINE_DOUBLEWIDTH = (1 << 1);
+static const int LINE_DOUBLEHEIGHT = (1 << 2);
 
 #define DEFAULT_RENDITION  0
 #define RE_BOLD            (1 << 0)
 #define RE_BLINK           (1 << 1)
 #define RE_UNDERLINE       (1 << 2)
-#define RE_REVERSE         (1 << 3) // Screen only
-#define RE_INTENSIVE       (1 << 3) // Widget only
+#define RE_REVERSE         (1 << 3)	// Screen only
+#define RE_INTENSIVE       (1 << 3)	// Widget only
 #define RE_CURSOR          (1 << 4)
 #define RE_EXTENDED_CHAR   (1 << 5)
 
 /**
  * A single character in the terminal which consists of a unicode character
  * value, foreground and background colors and a set of rendition attributes
  * which specify how it should be drawn.
  */
@@ -56,165 +56,173 @@ public:
   /** 
    * Constructs a new character.
    *
    * @param _c The unicode character value of this character.
    * @param _f The foreground color used to draw the character.
    * @param _b The color used to draw the character's background.
    * @param _r A set of rendition flags which specify how this character is to be drawn.
    */
-  inline Character(quint16 _c = ' ',
-            CharacterColor  _f = CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
-            CharacterColor  _b = CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
-            quint8  _r = DEFAULT_RENDITION)
-       : character(_c), rendition(_r), foregroundColor(_f), backgroundColor(_b) {}
+inline Character (quint16 _c = ' ', CharacterColor _f = CharacterColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR), CharacterColor _b = CharacterColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR), quint8 _r = DEFAULT_RENDITION):character (_c), rendition (_r), foregroundColor (_f),
+    backgroundColor
+    (_b)
+  {
+  }
 
   union
   {
     /** The unicode character value for this character. */
     quint16 character;
     /** 
      * Experimental addition which allows a single Character instance to contain more than
      * one unicode character.
      *
      * charSequence is a hash code which can be used to look up the unicode
      * character sequence in the ExtendedCharTable used to create the sequence.
      */
-    quint16 charSequence; 
+    quint16 charSequence;
   };
 
   /** A combination of RENDITION flags which specify options for drawing the character. */
-  quint8  rendition;
+  quint8 rendition;
 
   /** The foreground color used to draw this character. */
-  CharacterColor  foregroundColor; 
+  CharacterColor foregroundColor;
   /** The color used to draw this character's background. */
-  CharacterColor  backgroundColor;
+  CharacterColor backgroundColor;
 
   /** 
    * Returns true if this character has a transparent background when
    * it is drawn with the specified @p palette.
    */
-  bool   isTransparent(const ColorEntry* palette) const;
+  bool isTransparent (const ColorEntry * palette) const;
   /**
    * Returns true if this character should always be drawn in bold when
    * it is drawn with the specified @p palette, independent of whether
    * or not the character has the RE_BOLD rendition flag. 
    */
-  ColorEntry::FontWeight fontWeight(const ColorEntry* base) const;
-  
+  ColorEntry::FontWeight fontWeight (const ColorEntry * base) const;
+
   /** 
    * returns true if the format (color, rendition flag) of the compared characters is equal
    */
-  bool equalsFormat(const Character &other) const;
+  bool equalsFormat (const Character & other) const;
 
   /** 
    * Compares two characters and returns true if they have the same unicode character value,
    * rendition and colors.
    */
-  friend bool operator == (const Character& a, const Character& b);
+  friend bool operator == (const Character & a, const Character & b);
   /**
    * Compares two characters and returns true if they have different unicode character values,
    * renditions or colors.
    */
-  friend bool operator != (const Character& a, const Character& b);
+  friend bool operator != (const Character & a, const Character & b);
 };
 
-inline bool operator == (const Character& a, const Character& b)
-{ 
-  return a.character == b.character && 
-         a.rendition == b.rendition && 
-         a.foregroundColor == b.foregroundColor && 
-         a.backgroundColor == b.backgroundColor;
+inline bool
+operator == (const Character & a, const Character & b)
+{
+  return a.character == b.character &&
+    a.rendition == b.rendition &&
+    a.foregroundColor == b.foregroundColor &&
+    a.backgroundColor == b.backgroundColor;
 }
 
-inline bool operator != (const Character& a, const Character& b)
+inline bool
+operator != (const Character & a, const Character & b)
 {
-  return    a.character != b.character || 
-            a.rendition != b.rendition || 
-            a.foregroundColor != b.foregroundColor || 
-            a.backgroundColor != b.backgroundColor;
+  return a.character != b.character ||
+    a.rendition != b.rendition ||
+    a.foregroundColor != b.foregroundColor ||
+    a.backgroundColor != b.backgroundColor;
 }
 
-inline bool Character::isTransparent(const ColorEntry* base) const
+inline bool
+Character::isTransparent (const ColorEntry * base) const
 {
-  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) && 
-          base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].transparent)
-      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) && 
-          base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].transparent);
+  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
+	  base[backgroundColor._u + 0 +
+	       (backgroundColor._v ? BASE_COLORS : 0)].transparent)
+    || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
+	&& base[backgroundColor._u + 2 +
+		(backgroundColor._v ? BASE_COLORS : 0)].transparent);
 }
 
-inline bool Character::equalsFormat(const Character& other) const
+inline bool
+Character::equalsFormat (const Character & other) const
 {
-  return 
-    backgroundColor==other.backgroundColor &&
-    foregroundColor==other.foregroundColor &&
-    rendition==other.rendition;
-}	
+  return
+    backgroundColor == other.backgroundColor &&
+    foregroundColor == other.foregroundColor && rendition == other.rendition;
+}
 
-inline ColorEntry::FontWeight Character::fontWeight(const ColorEntry* base) const
+inline ColorEntry::FontWeight
+Character::fontWeight (const ColorEntry * base) const
 {
-    if (backgroundColor._colorSpace == COLOR_SPACE_DEFAULT)
-        return base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].fontWeight;
-    else if (backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
-        return base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].fontWeight;
-    else
-        return ColorEntry::UseCurrentFormat;
+  if (backgroundColor._colorSpace == COLOR_SPACE_DEFAULT)
+    return base[backgroundColor._u + 0 +
+		(backgroundColor._v ? BASE_COLORS : 0)].fontWeight;
+  else if (backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
+    return base[backgroundColor._u + 2 +
+		(backgroundColor._v ? BASE_COLORS : 0)].fontWeight;
+  else
+    return ColorEntry::UseCurrentFormat;
 }
 
 extern unsigned short vt100_graphics[32];
 
 
 /**
  * A table which stores sequences of unicode characters, referenced
  * by hash keys.  The hash key itself is the same size as a unicode
  * character ( ushort ) so that it can occupy the same space in
  * a structure.
  */
 class ExtendedCharTable
 {
 public:
     /** Constructs a new character table. */
-    ExtendedCharTable();
-    ~ExtendedCharTable();
+  ExtendedCharTable ();
+  ~ExtendedCharTable ();
 
     /**
      * Adds a sequences of unicode characters to the table and returns
      * a hash code which can be used later to look up the sequence
      * using lookupExtendedChar()
      *
      * If the same sequence already exists in the table, the hash
      * of the existing sequence will be returned.
      *
      * @param unicodePoints An array of unicode character points
      * @param length Length of @p unicodePoints
      */
-    ushort createExtendedChar(ushort* unicodePoints , ushort length);
+  ushort createExtendedChar (ushort * unicodePoints, ushort length);
     /**
      * Looks up and returns a pointer to a sequence of unicode characters
      * which was added to the table using createExtendedChar().
      *
      * @param hash The hash key returned by createExtendedChar()
      * @param length This variable is set to the length of the 
      * character sequence.
      *
      * @return A unicode character sequence of size @p length.
      */
-    ushort* lookupExtendedChar(ushort hash , ushort& length) const;
+  ushort *lookupExtendedChar (ushort hash, ushort & length) const;
 
     /** The global ExtendedCharTable instance. */
-    static ExtendedCharTable instance;
+  static ExtendedCharTable instance;
 private:
-    // calculates the hash key of a sequence of unicode points of size 'length'
-    ushort extendedCharHash(ushort* unicodePoints , ushort length) const;
-    // tests whether the entry in the table specified by 'hash' matches the 
-    // character sequence 'unicodePoints' of size 'length'
-    bool extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const;
-    // internal, maps hash keys to character sequence buffers.  The first ushort
-    // in each value is the length of the buffer, followed by the ushorts in the buffer
-    // themselves.
-    QHash<ushort,ushort*> extendedCharTable;
+  // calculates the hash key of a sequence of unicode points of size 'length'
+    ushort extendedCharHash (ushort * unicodePoints, ushort length) const;
+  // tests whether the entry in the table specified by 'hash' matches the 
+  // character sequence 'unicodePoints' of size 'length'
+  bool extendedCharMatch (ushort hash, ushort * unicodePoints,
+			  ushort length) const;
+  // internal, maps hash keys to character sequence buffers.  The first ushort
+  // in each value is the length of the buffer, followed by the ushorts in the buffer
+  // themselves.
+    QHash < ushort, ushort * >extendedCharTable;
 };
 
-Q_DECLARE_TYPEINFO(Character, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO (Character, Q_MOVABLE_TYPE);
 
 #endif // CHARACTER_H
-
diff --git a/gui/src/terminal/CharacterColor.h b/gui/src/terminal/CharacterColor.h
--- a/gui/src/terminal/CharacterColor.h
+++ b/gui/src/terminal/CharacterColor.h
@@ -38,17 +38,17 @@
  * Each entry can also be transparent, in which case the terminal
  * display should avoid drawing the background for any characters
  * using the entry as a background.
  */
 class ColorEntry
 {
 public:
   /** Specifies the weight to use when drawing text with this color. */
-  enum FontWeight 
+  enum FontWeight
   {
     /** Always draw text in this color with a bold weight. */
     Bold,
     /** Always draw text in this color with a normal weight. */
     Normal,
     /** 
      * Use the current font weight set by the terminal application.  
      * This is the default behavior.
@@ -58,48 +58,53 @@ public:
 
   /** 
    * Constructs a new color palette entry.
    *
    * @param c The color value for this entry.
    * @param tr Specifies that the color should be transparent when used as a background color.
    * @param weight Specifies the font weight to use when drawing text with this color. 
    */
-  ColorEntry(QColor c, bool tr, FontWeight weight = UseCurrentFormat) 
-          : color(c), transparent(tr), fontWeight(weight) {}
+  ColorEntry (QColor c, bool tr, FontWeight weight = UseCurrentFormat):color (c), transparent (tr),
+    fontWeight
+    (weight)
+  {
+  }
 
   /**
    * Constructs a new color palette entry with an undefined color, and
    * with the transparent and bold flags set to false.
-   */ 
-  ColorEntry() : transparent(false), fontWeight(UseCurrentFormat) {} 
- 
+   */
+  ColorEntry ():transparent (false), fontWeight (UseCurrentFormat)
+  {
+  }
+
   /**
    * Sets the color, transparency and boldness of this color to those of @p rhs.
-   */ 
-  void operator=(const ColorEntry& rhs) 
-  { 
-       color = rhs.color; 
-       transparent = rhs.transparent; 
-       fontWeight = rhs.fontWeight; 
+   */
+  void operator= (const ColorEntry & rhs)
+  {
+    color = rhs.color;
+    transparent = rhs.transparent;
+    fontWeight = rhs.fontWeight;
   }
 
   /** The color value of this entry for display. */
   QColor color;
 
   /** 
    * If true character backgrounds using this color should be transparent. 
    * This is not applicable when the color is used to render text.
    */
-  bool   transparent;
+  bool transparent;
   /**
    * Specifies the font weight to use when drawing text with this color. 
    * This is not applicable when the color is used to draw a character's background.
    */
-  FontWeight fontWeight;        
+  FontWeight fontWeight;
 };
 
 
 // Attributed Character Representations ///////////////////////////////
 
 // Colors
 
 #define BASE_COLORS   (2+8)
@@ -136,155 +141,167 @@ extern const ColorEntry base_color_table
 #define COLOR_SPACE_256         3
 #define COLOR_SPACE_RGB         4
 
 /**
  * Describes the color of a single character in the terminal.
  */
 class CharacterColor
 {
-    friend class Character;
+  friend class Character;
 
 public:
   /** Constructs a new CharacterColor whoose color and color space are undefined. */
-  CharacterColor() 
-      : _colorSpace(COLOR_SPACE_UNDEFINED), 
-        _u(0), 
-        _v(0), 
-        _w(0) 
-  {}
+    CharacterColor ():_colorSpace (COLOR_SPACE_UNDEFINED),
+    _u (0), _v (0), _w (0)
+  {
+  }
 
   /** 
    * Constructs a new CharacterColor using the specified @p colorSpace and with 
    * color value @p co
    *
    * The meaning of @p co depends on the @p colorSpace used.
    *
    * TODO : Document how @p co relates to @p colorSpace
    *
    * TODO : Add documentation about available color spaces.
    */
-  CharacterColor(quint8 colorSpace, int co) 
-      : _colorSpace(colorSpace), 
-        _u(0), 
-        _v(0), 
-        _w(0)
+  CharacterColor (quint8 colorSpace, int co):_colorSpace (colorSpace),
+    _u (0), _v (0), _w (0)
   {
     switch (colorSpace)
-    {
-        case COLOR_SPACE_DEFAULT:
-            _u = co & 1;
-            break;
-        case COLOR_SPACE_SYSTEM:
-            _u = co & 7;
-            _v = (co >> 3) & 1;
-            break;
-        case COLOR_SPACE_256:  
-            _u = co & 255;
-            break;
-        case COLOR_SPACE_RGB:
-            _u = co >> 16;
-            _v = co >> 8;
-            _w = co;
-            break;
-        default:
-            _colorSpace = COLOR_SPACE_UNDEFINED;
-    }
+      {
+      case COLOR_SPACE_DEFAULT:
+	_u = co & 1;
+	break;
+      case COLOR_SPACE_SYSTEM:
+	_u = co & 7;
+	_v = (co >> 3) & 1;
+	break;
+      case COLOR_SPACE_256:
+	_u = co & 255;
+	break;
+      case COLOR_SPACE_RGB:
+	_u = co >> 16;
+	_v = co >> 8;
+	_w = co;
+	break;
+      default:
+	_colorSpace = COLOR_SPACE_UNDEFINED;
+      }
   }
 
   /** 
    * Returns true if this character color entry is valid.
    */
-  bool isValid() 
+  bool isValid ()
   {
-        return _colorSpace != COLOR_SPACE_UNDEFINED;
+    return _colorSpace != COLOR_SPACE_UNDEFINED;
   }
-    
+
   /** 
    * Toggles the value of this color between a normal system color and the corresponding intensive
    * system color.
    * 
    * This is only applicable if the color is using the COLOR_SPACE_DEFAULT or COLOR_SPACE_SYSTEM
    * color spaces.
    */
-  void toggleIntensive();
+  void toggleIntensive ();
 
   /** 
    * Returns the color within the specified color @p palette
    *
    * The @p palette is only used if this color is one of the 16 system colors, otherwise
    * it is ignored.
    */
-  QColor color(const ColorEntry* palette) const;
- 
+  QColor color (const ColorEntry * palette) const;
+
   /** 
    * Compares two colors and returns true if they represent the same color value and
    * use the same color space.
    */
-  friend bool operator == (const CharacterColor& a, const CharacterColor& b);
+  friend bool operator == (const CharacterColor & a,
+			   const CharacterColor & b);
   /**
    * Compares two colors and returns true if they represent different color values
    * or use different color spaces.
    */
-  friend bool operator != (const CharacterColor& a, const CharacterColor& b);
+  friend bool operator != (const CharacterColor & a,
+			   const CharacterColor & b);
 
 private:
   quint8 _colorSpace;
 
   // bytes storing the character color 
-  quint8 _u; 
-  quint8 _v; 
-  quint8 _w; 
+  quint8 _u;
+  quint8 _v;
+  quint8 _w;
 };
 
-inline bool operator == (const CharacterColor& a, const CharacterColor& b)
-{ 
-    return     a._colorSpace == b._colorSpace &&
-            a._u == b._u &&
-            a._v == b._v &&
-            a._w == b._w;
-}
-inline bool operator != (const CharacterColor& a, const CharacterColor& b)
+inline bool
+operator == (const CharacterColor & a, const CharacterColor & b)
 {
-    return !operator==(a,b);
+  return a._colorSpace == b._colorSpace &&
+    a._u == b._u && a._v == b._v && a._w == b._w;
 }
 
-inline const QColor color256(quint8 u, const ColorEntry* base)
+inline bool
+operator != (const CharacterColor & a, const CharacterColor & b)
+{
+  return !operator== (a, b);
+}
+
+inline const QColor
+color256 (quint8 u, const ColorEntry * base)
 {
   //   0.. 16: system colors
-  if (u <   8) return base[u+2            ].color; u -= 8;
-  if (u <   8) return base[u+2+BASE_COLORS].color; u -= 8;
+  if (u < 8)
+    return base[u + 2].color;
+  u -= 8;
+  if (u < 8)
+    return base[u + 2 + BASE_COLORS].color;
+  u -= 8;
 
   //  16..231: 6x6x6 rgb color cube
-  if (u < 216) return QColor(((u/36)%6) ? (40*((u/36)%6)+55) : 0,
-                             ((u/ 6)%6) ? (40*((u/ 6)%6)+55) : 0,
-                             ((u/ 1)%6) ? (40*((u/ 1)%6)+55) : 0); u -= 216;
-  
+  if (u < 216)
+    return QColor (((u / 36) % 6) ? (40 * ((u / 36) % 6) + 55) : 0,
+		   ((u / 6) % 6) ? (40 * ((u / 6) % 6) + 55) : 0,
+		   ((u / 1) % 6) ? (40 * ((u / 1) % 6) + 55) : 0);
+  u -= 216;
+
   // 232..255: gray, leaving out black and white
-  int gray = u*10+8; return QColor(gray,gray,gray);
+  int gray = u * 10 + 8;
+  return QColor (gray, gray, gray);
 }
 
-inline QColor CharacterColor::color(const ColorEntry* base) const
+inline QColor
+CharacterColor::color (const ColorEntry * base) const
 {
   switch (_colorSpace)
-  {
-    case COLOR_SPACE_DEFAULT: return base[_u+0+(_v?BASE_COLORS:0)].color;
-    case COLOR_SPACE_SYSTEM: return base[_u+2+(_v?BASE_COLORS:0)].color;
-    case COLOR_SPACE_256: return color256(_u,base);
-    case COLOR_SPACE_RGB: return QColor(_u,_v,_w);
-    case COLOR_SPACE_UNDEFINED: return QColor();
-  }
+    {
+    case COLOR_SPACE_DEFAULT:
+      return base[_u + 0 + (_v ? BASE_COLORS : 0)].color;
+    case COLOR_SPACE_SYSTEM:
+      return base[_u + 2 + (_v ? BASE_COLORS : 0)].color;
+    case COLOR_SPACE_256:
+      return color256 (_u, base);
+    case COLOR_SPACE_RGB:
+      return QColor (_u, _v, _w);
+    case COLOR_SPACE_UNDEFINED:
+      return QColor ();
+    }
 
-  Q_ASSERT(false); // invalid color space
+  Q_ASSERT (false);		// invalid color space
 
-  return QColor();
+  return QColor ();
 }
 
-inline void CharacterColor::toggleIntensive()
+inline void
+CharacterColor::toggleIntensive ()
 {
   if (_colorSpace == COLOR_SPACE_SYSTEM || _colorSpace == COLOR_SPACE_DEFAULT)
-  {
-    _v = !_v;
-  }
+    {
+      _v = !_v;
+    }
 }
 
 #endif // CHARACTERCOLOR_H
-
diff --git a/gui/src/terminal/ColorTables.h b/gui/src/terminal/ColorTables.h
--- a/gui/src/terminal/ColorTables.h
+++ b/gui/src/terminal/ColorTables.h
@@ -18,59 +18,80 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef _COLOR_TABLE_H
 #define _COLOR_TABLE_H
 
 #include "CharacterColor.h"
 
-static const ColorEntry whiteonblack_color_table[TABLE_COLORS] =
-{
-    // normal
-    ColorEntry(QColor(0xFF,0xFF,0xFF), 0, 0 ), ColorEntry( QColor(0x00,0x00,0x00), 1, 0 ), // Dfore, Dback
-    ColorEntry(QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0x18), 0, 0 ), // Black, Red
-    ColorEntry(QColor(0x18,0xB2,0x18), 0, 0 ), ColorEntry( QColor(0xB2,0x68,0x18), 0, 0 ), // Green, Yellow
-    ColorEntry(QColor(0x18,0x18,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0xB2), 0, 0 ), // Blue, Magenta
-    ColorEntry(QColor(0x18,0xB2,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0xB2,0xB2), 0, 0 ), // Cyan, White
-    // intensiv
-    ColorEntry(QColor(0x00,0x00,0x00), 0, 1 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 1, 0 ),
-    ColorEntry(QColor(0x68,0x68,0x68), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0x54), 0, 0 ),
-    ColorEntry(QColor(0x54,0xFF,0x54), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0x54), 0, 0 ),
-    ColorEntry(QColor(0x54,0x54,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0xFF), 0, 0 ),
-    ColorEntry(QColor(0x54,0xFF,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 0, 0 )
+static const ColorEntry whiteonblack_color_table[TABLE_COLORS] = {
+  // normal
+  ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0, 0), ColorEntry (QColor (0x00, 0x00, 0x00), 1, 0),	// Dfore, Dback
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0, 0), ColorEntry (QColor (0xB2, 0x18, 0x18), 0, 0),	// Black, Red
+  ColorEntry (QColor (0x18, 0xB2, 0x18), 0, 0), ColorEntry (QColor (0xB2, 0x68, 0x18), 0, 0),	// Green, Yellow
+  ColorEntry (QColor (0x18, 0x18, 0xB2), 0, 0), ColorEntry (QColor (0xB2, 0x18, 0xB2), 0, 0),	// Blue, Magenta
+  ColorEntry (QColor (0x18, 0xB2, 0xB2), 0, 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 0, 0),	// Cyan, White
+  // intensiv
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0, 1),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 1, 0),
+  ColorEntry (QColor (0x68, 0x68, 0x68), 0, 0),
+    ColorEntry (QColor (0xFF, 0x54, 0x54), 0, 0),
+  ColorEntry (QColor (0x54, 0xFF, 0x54), 0, 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0x54), 0, 0),
+  ColorEntry (QColor (0x54, 0x54, 0xFF), 0, 0),
+    ColorEntry (QColor (0xFF, 0x54, 0xFF), 0, 0),
+  ColorEntry (QColor (0x54, 0xFF, 0xFF), 0, 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0, 0)
 };
 
-static const ColorEntry greenonblack_color_table[TABLE_COLORS] =
-{
-    ColorEntry(QColor(    24, 240,  24),  0, 0), ColorEntry(QColor(     0,   0,   0),  1, 0),  
-    ColorEntry(QColor(     0,   0,   0),  0, 0), ColorEntry(QColor(   178,  24,  24),  0, 0), 
-    ColorEntry(QColor(    24, 178,  24),  0, 0), ColorEntry(QColor(   178, 104,  24),  0, 0), 
-    ColorEntry(QColor(    24,  24, 178),  0, 0), ColorEntry(QColor(   178,  24, 178),  0, 0), 
-    ColorEntry(QColor(    24, 178, 178),  0, 0), ColorEntry(QColor(   178, 178, 178),  0, 0), 
-    // intensive colors
-    ColorEntry(QColor(   24, 240,  24),  0, 1 ), ColorEntry(QColor(    0,   0,   0),  1, 0 ),
-    ColorEntry(QColor(  104, 104, 104),  0, 0 ), ColorEntry(QColor(  255,  84,  84),  0, 0 ),
-    ColorEntry(QColor(   84, 255,  84),  0, 0 ), ColorEntry(QColor(  255, 255,  84),  0, 0 ),
-    ColorEntry(QColor(   84,  84, 255),  0, 0 ), ColorEntry(QColor(  255,  84, 255),  0, 0 ),
-    ColorEntry(QColor(   84, 255, 255),  0, 0 ), ColorEntry(QColor(  255, 255, 255),  0, 0 )
+static const ColorEntry greenonblack_color_table[TABLE_COLORS] = {
+  ColorEntry (QColor (24, 240, 24), 0, 0), ColorEntry (QColor (0, 0, 0), 1,
+						       0),
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (178, 24, 24), 0,
+						   0),
+  ColorEntry (QColor (24, 178, 24), 0, 0), ColorEntry (QColor (178, 104, 24),
+						       0, 0),
+  ColorEntry (QColor (24, 24, 178), 0, 0), ColorEntry (QColor (178, 24, 178),
+						       0, 0),
+  ColorEntry (QColor (24, 178, 178), 0, 0),
+    ColorEntry (QColor (178, 178, 178), 0, 0),
+  // intensive colors
+  ColorEntry (QColor (24, 240, 24), 0, 1), ColorEntry (QColor (0, 0, 0), 1,
+						       0),
+  ColorEntry (QColor (104, 104, 104), 0, 0), ColorEntry (QColor (255, 84, 84),
+							 0, 0),
+  ColorEntry (QColor (84, 255, 84), 0, 0), ColorEntry (QColor (255, 255, 84),
+						       0, 0),
+  ColorEntry (QColor (84, 84, 255), 0, 0), ColorEntry (QColor (255, 84, 255),
+						       0, 0),
+  ColorEntry (QColor (84, 255, 255), 0, 0),
+    ColorEntry (QColor (255, 255, 255), 0, 0)
 };
 
-static const ColorEntry blackonlightyellow_color_table[TABLE_COLORS] = 
-{
-    ColorEntry(QColor(  0,   0,   0),  0, 0),  ColorEntry(QColor( 255, 255, 221),  1, 0),  
-    ColorEntry(QColor(  0,   0,   0),  0, 0),  ColorEntry(QColor( 178,  24,  24),  0, 0),  
-    ColorEntry(QColor( 24, 178,  24),  0, 0),  ColorEntry(QColor( 178, 104,  24),  0, 0),  
-    ColorEntry(QColor( 24,  24, 178),  0, 0),  ColorEntry(QColor( 178,  24, 178),  0, 0),  
-    ColorEntry(QColor( 24, 178, 178),  0, 0),  ColorEntry(QColor( 178, 178, 178),  0, 0),  
-    ColorEntry(QColor(  0,   0,   0),  0, 1),  ColorEntry(QColor( 255, 255, 221),  1, 0),  
-    ColorEntry(QColor(104, 104, 104),  0, 0),  ColorEntry(QColor( 255,  84,  84),  0, 0),  
-    ColorEntry(QColor( 84, 255,  84),  0, 0),  ColorEntry(QColor( 255, 255,  84),  0, 0),  
-    ColorEntry(QColor( 84,  84, 255),  0, 0),  ColorEntry(QColor( 255,  84, 255),  0, 0),  
-    ColorEntry(QColor( 84, 255, 255),  0, 0),  ColorEntry(QColor( 255, 255, 255),  0, 0)
+static const ColorEntry blackonlightyellow_color_table[TABLE_COLORS] = {
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (255, 255, 221), 1,
+						   0),
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (178, 24, 24), 0,
+						   0),
+  ColorEntry (QColor (24, 178, 24), 0, 0), ColorEntry (QColor (178, 104, 24),
+						       0, 0),
+  ColorEntry (QColor (24, 24, 178), 0, 0), ColorEntry (QColor (178, 24, 178),
+						       0, 0),
+  ColorEntry (QColor (24, 178, 178), 0, 0),
+    ColorEntry (QColor (178, 178, 178), 0, 0),
+  ColorEntry (QColor (0, 0, 0), 0, 1), ColorEntry (QColor (255, 255, 221), 1,
+						   0),
+  ColorEntry (QColor (104, 104, 104), 0, 0), ColorEntry (QColor (255, 84, 84),
+							 0, 0),
+  ColorEntry (QColor (84, 255, 84), 0, 0), ColorEntry (QColor (255, 255, 84),
+						       0, 0),
+  ColorEntry (QColor (84, 84, 255), 0, 0), ColorEntry (QColor (255, 84, 255),
+						       0, 0),
+  ColorEntry (QColor (84, 255, 255), 0, 0),
+    ColorEntry (QColor (255, 255, 255), 0, 0)
 };
- 			  
-			  
-			  
+
+
+
 
 
 #endif
-
diff --git a/gui/src/terminal/Emulation.cpp b/gui/src/terminal/Emulation.cpp
--- a/gui/src/terminal/Emulation.cpp
+++ b/gui/src/terminal/Emulation.cpp
@@ -40,353 +40,397 @@
 #include <QtCore/QTime>
 
 // Konsole
 #include "KeyboardTranslator.h"
 #include "Screen.h"
 #include "TerminalCharacterDecoder.h"
 #include "ScreenWindow.h"
 
-Emulation::Emulation() :
-  _currentScreen(0),
-  _codec(0),
-  _decoder(0),
-  _keyTranslator(0),
-  _usesMouse(false)
+Emulation::Emulation ():
+_currentScreen (0),
+_codec (0), _decoder (0), _keyTranslator (0), _usesMouse (false)
 {
   // create screens with a default size
-  _screen[0] = new Screen(40,80);
-  _screen[1] = new Screen(40,80);
+  _screen[0] = new Screen (40, 80);
+  _screen[1] = new Screen (40, 80);
   _currentScreen = _screen[0];
 
-  QObject::connect(&_bulkTimer1, SIGNAL(timeout()), this, SLOT(showBulk()) );
-  QObject::connect(&_bulkTimer2, SIGNAL(timeout()), this, SLOT(showBulk()) );
-   
+  QObject::connect (&_bulkTimer1, SIGNAL (timeout ()), this,
+		    SLOT (showBulk ()));
+  QObject::connect (&_bulkTimer2, SIGNAL (timeout ()), this,
+		    SLOT (showBulk ()));
+
   // listen for mouse status changes
-  connect( this , SIGNAL(programUsesMouseChanged(bool)) , 
-           SLOT(usesMouseChanged(bool)) );
+  connect (this, SIGNAL (programUsesMouseChanged (bool)),
+	   SLOT (usesMouseChanged (bool)));
 }
 
-bool Emulation::programUsesMouse() const
+bool
+Emulation::programUsesMouse () const
 {
-    return _usesMouse;
+  return _usesMouse;
 }
 
-void Emulation::usesMouseChanged(bool usesMouse)
+void
+Emulation::usesMouseChanged (bool usesMouse)
 {
-    _usesMouse = usesMouse;
+  _usesMouse = usesMouse;
 }
 
-ScreenWindow* Emulation::createWindow()
+ScreenWindow *
+Emulation::createWindow ()
 {
-    ScreenWindow* window = new ScreenWindow();
-    window->setScreen(_currentScreen);
-    _windows << window;
+  ScreenWindow *window = new ScreenWindow ();
+  window->setScreen (_currentScreen);
+  _windows << window;
 
-    connect(window , SIGNAL(selectionChanged()),
-            this , SLOT(bufferedUpdate()));
+  connect (window, SIGNAL (selectionChanged ()),
+	   this, SLOT (bufferedUpdate ()));
 
-    connect(this , SIGNAL(outputChanged()),
-            window , SLOT(notifyOutputChanged()) );
-    return window;
+  connect (this, SIGNAL (outputChanged ()),
+	   window, SLOT (notifyOutputChanged ()));
+  return window;
 }
 
-Emulation::~Emulation()
+Emulation::~Emulation ()
 {
-  QListIterator<ScreenWindow*> windowIter(_windows);
+  QListIterator < ScreenWindow * >windowIter (_windows);
 
-  while (windowIter.hasNext())
-  {
-    delete windowIter.next();
-  }
+  while (windowIter.hasNext ())
+    {
+      delete windowIter.next ();
+    }
 
   delete _screen[0];
   delete _screen[1];
   delete _decoder;
 }
 
-void Emulation::setScreen(int n)
+void
+Emulation::setScreen (int n)
 {
   Screen *old = _currentScreen;
   _currentScreen = _screen[n & 1];
-  if (_currentScreen != old) 
-  {
-     // tell all windows onto this emulation to switch to the newly active screen
-     foreach(ScreenWindow* window,_windows)
-         window->setScreen(_currentScreen);
-  }
+  if (_currentScreen != old)
+    {
+      // tell all windows onto this emulation to switch to the newly active screen
+      foreach (ScreenWindow * window, _windows)
+	window->setScreen (_currentScreen);
+    }
+}
+
+void
+Emulation::clearHistory ()
+{
+  _screen[0]->setScroll (_screen[0]->getScroll (), false);
 }
 
-void Emulation::clearHistory()
+void
+Emulation::setHistory (const HistoryType & t)
 {
-    _screen[0]->setScroll( _screen[0]->getScroll() , false );
-}
-void Emulation::setHistory(const HistoryType& t)
-{
-  _screen[0]->setScroll(t);
+  _screen[0]->setScroll (t);
 
-  showBulk();
+  showBulk ();
 }
 
-const HistoryType& Emulation::history() const
+const HistoryType &
+Emulation::history () const
 {
-  return _screen[0]->getScroll();
+  return _screen[0]->getScroll ();
 }
 
-void Emulation::setCodec(const QTextCodec * qtc)
+void
+Emulation::setCodec (const QTextCodec * qtc)
 {
   if (qtc)
-      _codec = qtc;
+    _codec = qtc;
   else
-     setCodec(LocaleCodec);
+    setCodec (LocaleCodec);
 
   delete _decoder;
-  _decoder = _codec->makeDecoder();
+  _decoder = _codec->makeDecoder ();
+
+  emit useUtf8Request (utf8 ());
+}
 
-  emit useUtf8Request(utf8());
+void
+Emulation::setCodec (EmulationCodec codec)
+{
+  if (codec == Utf8Codec)
+    setCodec (QTextCodec::codecForName ("utf8"));
+  else if (codec == LocaleCodec)
+    setCodec (QTextCodec::codecForLocale ());
 }
 
-void Emulation::setCodec(EmulationCodec codec)
+void
+Emulation::setKeyBindings (const QString & name)
 {
-    if ( codec == Utf8Codec )
-        setCodec( QTextCodec::codecForName("utf8") );
-    else if ( codec == LocaleCodec )
-        setCodec( QTextCodec::codecForLocale() );
+  _keyTranslator =
+    KeyboardTranslatorManager::instance ()->findTranslator (name);
+  if (!_keyTranslator)
+    {
+      _keyTranslator =
+	KeyboardTranslatorManager::instance ()->defaultTranslator ();
+    }
 }
 
-void Emulation::setKeyBindings(const QString& name)
+QString
+Emulation::keyBindings () const
 {
-  _keyTranslator = KeyboardTranslatorManager::instance()->findTranslator(name);
-  if (!_keyTranslator)
-  {
-      _keyTranslator = KeyboardTranslatorManager::instance()->defaultTranslator();
-  }
+  return _keyTranslator->name ();
 }
 
-QString Emulation::keyBindings() const
-{
-  return _keyTranslator->name();
-}
-
-void Emulation::receiveChar(int c)
+void
+Emulation::receiveChar (int c)
 // process application unicode input to terminal
 // this is a trivial scanner
 {
   c &= 0xff;
   switch (c)
-  {
-    case '\b'      : _currentScreen->backspace();                 break;
-    case '\t'      : _currentScreen->tab();                       break;
-    case '\n'      : _currentScreen->newLine();                   break;
-    case '\r'      : _currentScreen->toStartOfLine();             break;
-    case 0x07      : emit stateSet(NOTIFYBELL);
-                     break;
-    default        : _currentScreen->displayCharacter(c);         break;
-  };
+    {
+    case '\b':
+      _currentScreen->backspace ();
+      break;
+    case '\t':
+      _currentScreen->tab ();
+      break;
+    case '\n':
+      _currentScreen->newLine ();
+      break;
+    case '\r':
+      _currentScreen->toStartOfLine ();
+      break;
+    case 0x07:
+      emit stateSet (NOTIFYBELL);
+      break;
+    default:
+      _currentScreen->displayCharacter (c);
+      break;
+    };
 }
 
-void Emulation::sendKeyEvent( QKeyEvent* ev )
+void
+Emulation::sendKeyEvent (QKeyEvent * ev)
 {
-  emit stateSet(NOTIFYNORMAL);
-  
-  if (!ev->text().isEmpty())
-  { // A block of text
-    // Note that the text is proper unicode.
-    // We should do a conversion here
-    emit sendData(ev->text().toUtf8(), ev->text().length());
-  }
+  emit stateSet (NOTIFYNORMAL);
+
+  if (!ev->text ().isEmpty ())
+    {				// A block of text
+      // Note that the text is proper unicode.
+      // We should do a conversion here
+      emit sendData (ev->text ().toUtf8 (), ev->text ().length ());
+    }
 }
 
-void Emulation::sendString(const char*,int)
+void
+Emulation::sendString (const char *, int)
 {
-    // default implementation does nothing
+  // default implementation does nothing
 }
 
-void Emulation::sendMouseEvent(int /*buttons*/, int /*column*/, int /*row*/, int /*eventType*/)
+void
+Emulation::sendMouseEvent (int /*buttons */ , int /*column */ , int /*row */ ,
+			   int /*eventType */ )
 {
-    // default implementation does nothing
+  // default implementation does nothing
 }
 
 /*
    We are doing code conversion from locale to unicode first.
 TODO: Character composition from the old code.  See #96536
 */
 
-void Emulation::receiveData(const char* text, int length)
+void
+Emulation::receiveData (const char *text, int length)
 {
-    emit stateSet(NOTIFYACTIVITY);
+  emit stateSet (NOTIFYACTIVITY);
 
-    bufferedUpdate();
-        
-    QString unicodeText = _decoder->toUnicode(text,length);
+  bufferedUpdate ();
+
+  QString unicodeText = _decoder->toUnicode (text, length);
 
-    //send characters to terminal emulator
-    for (int i=0;i<unicodeText.length();i++)
-        receiveChar(unicodeText[i].unicode());
+  //send characters to terminal emulator
+  for (int i = 0; i < unicodeText.length (); i++)
+    receiveChar (unicodeText[i].unicode ());
 }
 
-void Emulation::writeToStream( TerminalCharacterDecoder* _decoder , 
-                               int startLine ,
-                               int endLine) 
+void
+Emulation::writeToStream (TerminalCharacterDecoder * _decoder,
+			  int startLine, int endLine)
 {
-  _currentScreen->writeLinesToStream(_decoder,startLine,endLine);
+  _currentScreen->writeLinesToStream (_decoder, startLine, endLine);
 }
 
-int Emulation::lineCount() const
+int
+Emulation::lineCount () const
 {
-    // sum number of lines currently on _screen plus number of lines in history
-    return _currentScreen->getLines() + _currentScreen->getHistLines();
+  // sum number of lines currently on _screen plus number of lines in history
+  return _currentScreen->getLines () + _currentScreen->getHistLines ();
 }
 
 #define BULK_TIMEOUT1 10
 #define BULK_TIMEOUT2 40
 
-void Emulation::showBulk()
+void
+Emulation::showBulk ()
 {
-    _bulkTimer1.stop();
-    _bulkTimer2.stop();
+  _bulkTimer1.stop ();
+  _bulkTimer2.stop ();
 
-    emit outputChanged();
+  emit outputChanged ();
 
-    _currentScreen->resetScrolledLines();
-    _currentScreen->resetDroppedLines();
+  _currentScreen->resetScrolledLines ();
+  _currentScreen->resetDroppedLines ();
 }
 
-void Emulation::bufferedUpdate()
+void
+Emulation::bufferedUpdate ()
 {
-   _bulkTimer1.setSingleShot(true);
-   _bulkTimer1.start(BULK_TIMEOUT1);
-   if (!_bulkTimer2.isActive())
-   {
-      _bulkTimer2.setSingleShot(true);
-      _bulkTimer2.start(BULK_TIMEOUT2);
-   }
+  _bulkTimer1.setSingleShot (true);
+  _bulkTimer1.start (BULK_TIMEOUT1);
+  if (!_bulkTimer2.isActive ())
+    {
+      _bulkTimer2.setSingleShot (true);
+      _bulkTimer2.start (BULK_TIMEOUT2);
+    }
 }
 
-char Emulation::eraseChar() const
+char
+Emulation::eraseChar () const
 {
   return '\b';
 }
 
-void Emulation::setImageSize(int lines, int columns)
+void
+Emulation::setImageSize (int lines, int columns)
 {
-  if ((lines < 1) || (columns < 1)) 
+  if ((lines < 1) || (columns < 1))
     return;
 
-  QSize screenSize[2] = { QSize(_screen[0]->getColumns(),
-                                _screen[0]->getLines()),
-                          QSize(_screen[1]->getColumns(),
-                                _screen[1]->getLines()) };
-  QSize newSize(columns,lines);
+  QSize screenSize[2] = { QSize (_screen[0]->getColumns (),
+				 _screen[0]->getLines ()),
+    QSize (_screen[1]->getColumns (),
+	   _screen[1]->getLines ())
+  };
+  QSize newSize (columns, lines);
 
   if (newSize == screenSize[0] && newSize == screenSize[1])
-    return;    
+    return;
 
-  _screen[0]->resizeImage(lines,columns);
-  _screen[1]->resizeImage(lines,columns);
+  _screen[0]->resizeImage (lines, columns);
+  _screen[1]->resizeImage (lines, columns);
 
-  emit imageSizeChanged(lines,columns);
+  emit imageSizeChanged (lines, columns);
 
-  bufferedUpdate();
+  bufferedUpdate ();
 }
 
-QSize Emulation::imageSize() const
+QSize
+Emulation::imageSize () const
 {
-  return QSize(_currentScreen->getColumns(), _currentScreen->getLines());
+  return QSize (_currentScreen->getColumns (), _currentScreen->getLines ());
+}
+
+ushort
+ExtendedCharTable::extendedCharHash (ushort * unicodePoints, ushort length) const
+{
+  ushort hash = 0;
+  for (ushort i = 0; i < length; i++)
+    {
+      hash = 31 * hash + unicodePoints[i];
+    }
+  return hash;
 }
 
-ushort ExtendedCharTable::extendedCharHash(ushort* unicodePoints , ushort length) const
-{
-    ushort hash = 0;
-    for ( ushort i = 0 ; i < length ; i++ )
-    {
-        hash = 31*hash + unicodePoints[i];
-    }
-    return hash;
-}
-bool ExtendedCharTable::extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const
-{
-    ushort* entry = extendedCharTable[hash];
-
-    // compare given length with stored sequence length ( given as the first ushort in the 
-    // stored buffer ) 
-    if ( entry == 0 || entry[0] != length ) 
-       return false;
-    // if the lengths match, each character must be checked.  the stored buffer starts at
-    // entry[1]
-    for ( int i = 0 ; i < length ; i++ )
-    {
-        if ( entry[i+1] != unicodePoints[i] )
-           return false; 
-    } 
-    return true;
-}
-ushort ExtendedCharTable::createExtendedChar(ushort* unicodePoints , ushort length)
+bool
+ExtendedCharTable::extendedCharMatch (ushort hash, ushort * unicodePoints,
+				      ushort length) const
 {
-    // look for this sequence of points in the table
-    ushort hash = extendedCharHash(unicodePoints,length);
+  ushort *entry = extendedCharTable[hash];
 
-    // check existing entry for match
-    while ( extendedCharTable.contains(hash) )
+  // compare given length with stored sequence length ( given as the first ushort in the 
+  // stored buffer ) 
+  if (entry == 0 || entry[0] != length)
+    return false;
+  // if the lengths match, each character must be checked.  the stored buffer starts at
+  // entry[1]
+  for (int i = 0; i < length; i++)
     {
-        if ( extendedCharMatch(hash,unicodePoints,length) )
-        {
-            // this sequence already has an entry in the table, 
-            // return its hash
-            return hash;
-        }
-        else
-        {
-            // if hash is already used by another, different sequence of unicode character
-            // points then try next hash
-            hash++;
-        }
-    }    
-
-    
-     // add the new sequence to the table and
-     // return that index
-    ushort* buffer = new ushort[length+1];
-    buffer[0] = length;
-    for ( int i = 0 ; i < length ; i++ )
-       buffer[i+1] = unicodePoints[i]; 
-    
-    extendedCharTable.insert(hash,buffer);
-
-    return hash;
+      if (entry[i + 1] != unicodePoints[i])
+	return false;
+    }
+  return true;
 }
 
-ushort* ExtendedCharTable::lookupExtendedChar(ushort hash , ushort& length) const
+ushort
+ExtendedCharTable::createExtendedChar (ushort * unicodePoints, ushort length)
 {
-    // lookup index in table and if found, set the length
-    // argument and return a pointer to the character sequence
+  // look for this sequence of points in the table
+  ushort hash = extendedCharHash (unicodePoints, length);
 
-    ushort* buffer = extendedCharTable[hash];
-    if ( buffer )
+  // check existing entry for match
+  while (extendedCharTable.contains (hash))
     {
-        length = buffer[0];
-        return buffer+1;
+      if (extendedCharMatch (hash, unicodePoints, length))
+	{
+	  // this sequence already has an entry in the table, 
+	  // return its hash
+	  return hash;
+	}
+      else
+	{
+	  // if hash is already used by another, different sequence of unicode character
+	  // points then try next hash
+	  hash++;
+	}
     }
-    else
+
+
+  // add the new sequence to the table and
+  // return that index
+  ushort *buffer = new ushort[length + 1];
+  buffer[0] = length;
+  for (int i = 0; i < length; i++)
+    buffer[i + 1] = unicodePoints[i];
+
+  extendedCharTable.insert (hash, buffer);
+
+  return hash;
+}
+
+ushort *
+ExtendedCharTable::lookupExtendedChar (ushort hash, ushort & length) const
+{
+  // lookup index in table and if found, set the length
+  // argument and return a pointer to the character sequence
+
+  ushort *buffer = extendedCharTable[hash];
+  if (buffer)
     {
-        length = 0;
-        return 0;
+      length = buffer[0];
+      return buffer + 1;
+    }
+  else
+    {
+      length = 0;
+      return 0;
     }
 }
 
-ExtendedCharTable::ExtendedCharTable()
+ExtendedCharTable::ExtendedCharTable ()
 {
 }
-ExtendedCharTable::~ExtendedCharTable()
+
+ExtendedCharTable::~ExtendedCharTable ()
 {
-    // free all allocated character buffers
-    QHashIterator<ushort,ushort*> iter(extendedCharTable);
-    while ( iter.hasNext() )
+  // free all allocated character buffers
+  QHashIterator < ushort, ushort * >iter (extendedCharTable);
+  while (iter.hasNext ())
     {
-        iter.next();
-        delete[] iter.value();
+      iter.next ();
+      delete[]iter.value ();
     }
 }
 
 // global instance
-ExtendedCharTable ExtendedCharTable::instance;
-
-
+ExtendedCharTable
+  ExtendedCharTable::instance;
diff --git a/gui/src/terminal/Emulation.h b/gui/src/terminal/Emulation.h
--- a/gui/src/terminal/Emulation.h
+++ b/gui/src/terminal/Emulation.h
@@ -40,33 +40,33 @@ class ScreenWindow;
 class TerminalCharacterDecoder;
 
 /** 
  * This enum describes the available states which 
  * the terminal emulation may be set to.
  *
  * These are the values used by Emulation::stateChanged() 
  */
-enum 
-{ 
+enum
+{
     /** The emulation is currently receiving user input. */
-    NOTIFYNORMAL=0, 
+  NOTIFYNORMAL = 0,
     /** 
      * The terminal program has triggered a bell event
      * to get the user's attention.
      */
-    NOTIFYBELL=1, 
+  NOTIFYBELL = 1,
     /** 
      * The emulation is currently receiving data from its 
      * terminal input.
      */
-    NOTIFYACTIVITY=2,
+  NOTIFYACTIVITY = 2,
 
-    // unused here? 
-    NOTIFYSILENCE=3 
+  // unused here? 
+  NOTIFYSILENCE = 3
 };
 
 /**
  * Base class for terminal emulation back-ends.
  *
  * The back-end is responsible for decoding an incoming character stream and 
  * producing an output image of characters.
  *
@@ -108,230 +108,234 @@ enum
  * The emulation also maintains an activity state, which specifies whether
  * terminal is currently active ( when data is received ), normal
  * ( when the terminal is idle or receiving user input ) or trying
  * to alert the user ( also known as a "Bell" event ).  The stateSet() signal
  * is emitted whenever the activity state is set.  This can be used to determine
  * how long the emulation has been active/idle for and also respond to
  * a 'bell' event in different ways.
  */
-class Emulation : public QObject
-{ 
-Q_OBJECT
+class Emulation:public QObject
+{
+Q_OBJECT public:
 
-public:
- 
-   /** Constructs a new terminal emulation */ 
-   Emulation();
-  ~Emulation();
+   /** Constructs a new terminal emulation */
+  Emulation ();
+  ~Emulation ();
 
   /**
    * Creates a new window onto the output from this emulation.  The contents
    * of the window are then rendered by views which are set to use this window using the
    * TerminalDisplay::setScreenWindow() method.
    */
-  ScreenWindow* createWindow();
+  ScreenWindow *createWindow ();
 
   /** Returns the size of the screen image which the emulation produces */
-  QSize imageSize() const;
+  QSize imageSize () const;
 
   /**
    * Returns the total number of lines, including those stored in the history.
-   */ 
-  int lineCount() const;
+   */
+  int lineCount () const;
 
   /** 
    * Sets the history store used by this emulation.  When new lines
    * are added to the output, older lines at the top of the screen are transferred to a history
    * store.   
    *
    * The number of lines which are kept and the storage location depend on the 
    * type of store.
    */
-  void setHistory(const HistoryType&);
+  void setHistory (const HistoryType &);
   /** Returns the history store used by this emulation.  See setHistory() */
-  const HistoryType& history() const;
+  const HistoryType & history () const;
   /** Clears the history scroll. */
-  void clearHistory();
+  void clearHistory ();
 
   /** 
    * Copies the output history from @p startLine to @p endLine 
    * into @p stream, using @p decoder to convert the terminal
    * characters into text. 
    *
    * @param decoder A decoder which converts lines of terminal characters with 
    * appearance attributes into output text.  PlainTextDecoder is the most commonly
    * used decoder.
    * @param startLine Index of first line to copy
    * @param endLine Index of last line to copy
    */
-  virtual void writeToStream(TerminalCharacterDecoder* decoder,int startLine,int endLine);
-  
+  virtual void writeToStream (TerminalCharacterDecoder * decoder,
+			      int startLine, int endLine);
+
   /** Returns the codec used to decode incoming characters.  See setCodec() */
-  const QTextCodec* codec() const { return _codec; }
+  const QTextCodec *codec () const
+  {
+    return _codec;
+  }
   /** Sets the codec used to decode incoming characters.  */
-  void setCodec(const QTextCodec*);
+  void setCodec (const QTextCodec *);
 
   /** 
    * Convenience method.  
    * Returns true if the current codec used to decode incoming
    * characters is UTF-8
    */
-  bool utf8() const
-  { Q_ASSERT(_codec); return _codec->mibEnum() == 106; }
-  
+  bool utf8 () const
+  {
+    Q_ASSERT (_codec);
+    return _codec->mibEnum () == 106;
+  }
+
 
   /** TODO Document me */
-  virtual char eraseChar() const;
+  virtual char eraseChar () const;
 
   /** 
    * Sets the key bindings used to key events
    * ( received through sendKeyEvent() ) into character
    * streams to send to the terminal.
    */
-  void setKeyBindings(const QString& name);
+  void setKeyBindings (const QString & name);
   /** 
    * Returns the name of the emulation's current key bindings.
    * See setKeyBindings()
    */
-  QString keyBindings() const;
+  QString keyBindings () const;
 
   /** 
    * Copies the current image into the history and clears the screen.
    */
-  virtual void clearEntireScreen() =0;
+  virtual void clearEntireScreen () = 0;
 
   /** Resets the state of the terminal. */
-  virtual void reset() =0;
+  virtual void reset () = 0;
 
   /** 
    * Returns true if the active terminal program wants
    * mouse input events.
    *
    * The programUsesMouseChanged() signal is emitted when this
    * changes.
    */
-  bool programUsesMouse() const;
-
-public slots: 
+  bool programUsesMouse () const;
 
+  public slots:
   /** Change the size of the emulation's image */
-  virtual void setImageSize(int lines, int columns);
-  
+    virtual void setImageSize (int lines, int columns);
+
   /** 
    * Interprets a sequence of characters and sends the result to the terminal.
    * This is equivalent to calling sendKeyEvent() for each character in @p text in succession.
    */
-  virtual void sendText(const QString& text) = 0;
+  virtual void sendText (const QString & text) = 0;
 
   /** 
    * Interprets a key press event and emits the sendData() signal with
    * the resulting character stream. 
    */
-  virtual void sendKeyEvent(QKeyEvent*);
- 
+  virtual void sendKeyEvent (QKeyEvent *);
+
   /** 
    * Converts information about a mouse event into an xterm-compatible escape
    * sequence and emits the character sequence via sendData()
    */
-  virtual void sendMouseEvent(int buttons, int column, int line, int eventType);
-  
+  virtual void sendMouseEvent (int buttons, int column, int line,
+			       int eventType);
+
   /**
    * Sends a string of characters to the foreground terminal process. 
    *
    * @param string The characters to send.  
    * @param length Length of @p string or if set to a negative value, @p string will
    * be treated as a null-terminated string and its length will be determined automatically.
    */
-  virtual void sendString(const char* string, int length = -1) = 0;
+  virtual void sendString (const char *string, int length = -1) = 0;
 
   /** 
    * Processes an incoming stream of characters.  receiveData() decodes the incoming
    * character buffer using the current codec(), and then calls receiveChar() for
    * each unicode character in the resulting buffer.  
    *
    * receiveData() also starts a timer which causes the outputChanged() signal
    * to be emitted when it expires.  The timer allows multiple updates in quick
    * succession to be buffered into a single outputChanged() signal emission.
    *
    * @param buffer A string of characters received from the terminal program.
    * @param len The length of @p buffer
    */
-  void receiveData(const char* buffer,int len);
+  void receiveData (const char *buffer, int len);
 
-signals:
-
+    signals:
   /** 
    * Emitted when a buffer of data is ready to send to the 
    * standard input of the terminal.
    *
    * @param data The buffer of data ready to be sent
    * @param len The length of @p data in bytes
    */
-  void sendData(const char* data,int len);
+  void sendData (const char *data, int len);
 
   /** 
    * Requests that sending of input to the emulation
    * from the terminal process be suspended or resumed.
    *
    * @param suspend If true, requests that sending of 
    * input from the terminal process' stdout be 
    * suspended.  Otherwise requests that sending of
    * input be resumed. 
    */
-  void lockPtyRequest(bool suspend);
+  void lockPtyRequest (bool suspend);
 
   /**
    * Requests that the pty used by the terminal process
    * be set to UTF 8 mode.  
    *
    * TODO: More documentation
    */
-  void useUtf8Request(bool);
+  void useUtf8Request (bool);
 
   /**
    * Emitted when the activity state of the emulation is set.
    *
    * @param state The new activity state, one of NOTIFYNORMAL, NOTIFYACTIVITY
    * or NOTIFYBELL
    */
-  void stateSet(int state);
+  void stateSet (int state);
 
   /**
    * Requests that the color of the text used
    * to represent the tabs associated with this
    * emulation be changed.  This is a Konsole-specific
    * extension from pre-KDE 4 times.
    *
    * TODO: Document how the parameter works.
    */
-  void changeTabTextColorRequest(int color);
+  void changeTabTextColorRequest (int color);
 
   /** 
    * This is emitted when the program running in the shell indicates whether or
    * not it is interested in mouse events.
    *
    * @param usesMouse This will be true if the program wants to be informed about
    * mouse events or false otherwise.
    */
-  void programUsesMouseChanged(bool usesMouse);
+  void programUsesMouseChanged (bool usesMouse);
 
   /** 
    * Emitted when the contents of the screen image change.
    * The emulation buffers the updates from successive image changes,
    * and only emits outputChanged() at sensible intervals when
    * there is a lot of terminal activity.
    *
    * Normally there is no need for objects other than the screen windows
    * created with createWindow() to listen for this signal.
    *
    * ScreenWindow objects created using createWindow() will emit their
    * own outputChanged() signal in response to this signal. 
    */
-  void outputChanged();
+  void outputChanged ();
 
   /**
    * Emitted when the program running in the terminal wishes to update the 
    * session's title.  This also allows terminal programs to customize other
    * aspects of the terminal emulation display. 
    *
    * This signal is emitted when the escape sequence "\033]ARG;VALUE\007"
    * is received in the input string, where ARG is a number specifying what
@@ -355,104 +359,103 @@ signals:
    * <li>31 - Supposedly treats @p newTitle as a URL and opens it (NOT IMPLEMENTED)</li>
    * <li>32 - Sets the icon associated with the session.  @p newTitle is the name 
    *    of the icon to use, which can be the name of any icon in the current KDE icon
    *    theme (eg: 'konsole', 'kate', 'folder_home')</li>
    * </ul>
    * @param newTitle Specifies the new title 
    */
 
-  void titleChanged(int title,const QString& newTitle);
+  void titleChanged (int title, const QString & newTitle);
 
   /**
    * Emitted when the program running in the terminal changes the
    * screen size.
    */
-  void imageSizeChanged(int lineCount , int columnCount);
+  void imageSizeChanged (int lineCount, int columnCount);
 
   /** 
    * Emitted when the terminal program requests to change various properties
    * of the terminal display.  
    *
    * A profile change command occurs when a special escape sequence, followed
    * by a string containing a series of name and value pairs is received.
    * This string can be parsed using a ProfileCommandParser instance.
    *
    * @param text A string expected to contain a series of key and value pairs in
    * the form:  name=value;name2=value2 ...
    */
-  void profileChangeCommandReceived(const QString& text);
+  void profileChangeCommandReceived (const QString & text);
 
   /** 
    * Emitted when a flow control key combination ( Ctrl+S or Ctrl+Q ) is pressed.
    * @param suspendKeyPressed True if Ctrl+S was pressed to suspend output or Ctrl+Q to
    * resume output.
    */
-  void flowControlKeyPressed(bool suspendKeyPressed);
+  void flowControlKeyPressed (bool suspendKeyPressed);
 
 protected:
-  virtual void setMode(int mode) = 0;
-  virtual void resetMode(int mode) = 0;
-   
+    virtual void setMode (int mode) = 0;
+  virtual void resetMode (int mode) = 0;
+
   /** 
    * Processes an incoming character.  See receiveData()
    * @p ch A unicode character code. 
    */
-  virtual void receiveChar(int ch);
+  virtual void receiveChar (int ch);
 
   /** 
    * Sets the active screen.  The terminal has two screens, primary and alternate.
    * The primary screen is used by default.  When certain interactive programs such
    * as Vim are run, they trigger a switch to the alternate screen.
    *
    * @param index 0 to switch to the primary screen, or 1 to switch to the alternate screen
    */
-  void setScreen(int index); 
+  void setScreen (int index);
 
   enum EmulationCodec
   {
-      LocaleCodec = 0,
-      Utf8Codec   = 1
+    LocaleCodec = 0,
+    Utf8Codec = 1
   };
-  void setCodec(EmulationCodec codec); // codec number, 0 = locale, 1=utf8
+  void setCodec (EmulationCodec codec);	// codec number, 0 = locale, 1=utf8
 
 
-  QList<ScreenWindow*> _windows;
-  
-  Screen* _currentScreen;  // pointer to the screen which is currently active, 
-                            // this is one of the elements in the screen[] array
+    QList < ScreenWindow * >_windows;
+
+  Screen *_currentScreen;	// pointer to the screen which is currently active, 
+  // this is one of the elements in the screen[] array
 
-  Screen* _screen[2];      // 0 = primary screen ( used by most programs, including the shell
-                            //                      scrollbars are enabled in this mode )
-                            // 1 = alternate      ( used by vi , emacs etc.
-                            //                      scrollbars are not enabled in this mode )
-                            
-  
+  Screen *_screen[2];		// 0 = primary screen ( used by most programs, including the shell
+  //                      scrollbars are enabled in this mode )
+  // 1 = alternate      ( used by vi , emacs etc.
+  //                      scrollbars are not enabled in this mode )
+
+
   //decodes an incoming C-style character stream into a unicode QString using 
   //the current text codec.  (this allows for rendering of non-ASCII characters in text files etc.)
-  const QTextCodec* _codec;
-  QTextDecoder* _decoder;
-  const KeyboardTranslator* _keyTranslator; // the keyboard layout
+  const QTextCodec *_codec;
+  QTextDecoder *_decoder;
+  const KeyboardTranslator *_keyTranslator;	// the keyboard layout
 
-protected slots:
+  protected slots:
   /** 
    * Schedules an update of attached views.
    * Repeated calls to bufferedUpdate() in close succession will result in only a single update,
    * much like the Qt buffered update of widgets. 
    */
-  void bufferedUpdate();
-
-private slots: 
+  void bufferedUpdate ();
 
-  // triggered by timer, causes the emulation to send an updated screen image to each
-  // view
-  void showBulk(); 
+  private slots:
+    // triggered by timer, causes the emulation to send an updated screen image to each
+    // view
+  void showBulk ();
 
-  void usesMouseChanged(bool usesMouse);
+  void usesMouseChanged (bool usesMouse);
 
 private:
-  bool _usesMouse;
+    bool _usesMouse;
   QTimer _bulkTimer1;
   QTimer _bulkTimer2;
-  
+
 };
 
 #endif // ifndef EMULATION_H
diff --git a/gui/src/terminal/Filter.cpp b/gui/src/terminal/Filter.cpp
--- a/gui/src/terminal/Filter.cpp
+++ b/gui/src/terminal/Filter.cpp
@@ -32,503 +32,587 @@
 #include <QtCore/QSharedData>
 #include <QtCore/QFile>
 
 // Konsole
 #include "TerminalCharacterDecoder.h"
 #include "konsole_wcwidth.h"
 #include "konsole_export.h"
 
-FilterChain::~FilterChain()
+FilterChain::~FilterChain ()
 {
-    QMutableListIterator<Filter*> iter(*this);
-    
-    while ( iter.hasNext() )
+  QMutableListIterator < Filter * >iter (*this);
+
+  while (iter.hasNext ())
     {
-        Filter* filter = iter.next();
-        iter.remove();
-        delete filter;
+      Filter *filter = iter.next ();
+      iter.remove ();
+      delete filter;
     }
 }
 
-void FilterChain::addFilter(Filter* filter)
+void
+FilterChain::addFilter (Filter * filter)
 {
-    append(filter);
+  append (filter);
 }
-void FilterChain::removeFilter(Filter* filter)
+
+void
+FilterChain::removeFilter (Filter * filter)
 {
-    removeAll(filter);
+  removeAll (filter);
 }
-bool FilterChain::containsFilter(Filter* filter)
+
+bool
+FilterChain::containsFilter (Filter * filter)
 {
-    return contains(filter);
+  return contains (filter);
 }
-void FilterChain::reset()
+
+void
+FilterChain::reset ()
 {
-    QListIterator<Filter*> iter(*this);
-    while (iter.hasNext())
-        iter.next()->reset();
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->reset ();
 }
-void FilterChain::setBuffer(const QString* buffer , const QList<int>* linePositions)
+
+void
+FilterChain::setBuffer (const QString * buffer,
+			const QList < int >*linePositions)
 {
-    QListIterator<Filter*> iter(*this);
-    while (iter.hasNext())
-        iter.next()->setBuffer(buffer,linePositions);
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->setBuffer (buffer, linePositions);
 }
-void FilterChain::process()
+
+void
+FilterChain::process ()
 {
-    QListIterator<Filter*> iter(*this);
-    while (iter.hasNext())
-        iter.next()->process();
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->process ();
 }
-void FilterChain::clear()
+
+void
+FilterChain::clear ()
 {
-    QList<Filter*>::clear();
+  QList < Filter * >::clear ();
 }
-Filter::HotSpot* FilterChain::hotSpotAt(int line , int column) const
+
+Filter::HotSpot * FilterChain::hotSpotAt (int line, int column) const
 {
-    QListIterator<Filter*> iter(*this);
-    while (iter.hasNext())
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
     {
-        Filter* filter = iter.next();
-        Filter::HotSpot* spot = filter->hotSpotAt(line,column);
-        if ( spot != 0 )
-        {
-            return spot;
-        }
+      Filter *
+	filter = iter.next ();
+      Filter::HotSpot * spot = filter->hotSpotAt (line, column);
+      if (spot != 0)
+	{
+	  return spot;
+	}
     }
 
-    return 0;
+  return 0;
 }
 
-QList<Filter::HotSpot*> FilterChain::hotSpots() const
+QList < Filter::HotSpot * >FilterChain::hotSpots () const
 {
-    QList<Filter::HotSpot*> list;
-    QListIterator<Filter*> iter(*this);
-    while (iter.hasNext())
+  QList < Filter::HotSpot * >list;
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
     {
-        Filter* filter = iter.next();
-        list << filter->hotSpots();
+      Filter *
+	filter = iter.next ();
+      list << filter->hotSpots ();
     }
-    return list;
+  return list;
 }
+
 //QList<Filter::HotSpot*> FilterChain::hotSpotsAtLine(int line) const;
 
-TerminalImageFilterChain::TerminalImageFilterChain()
-: _buffer(0)
-, _linePositions(0)
+TerminalImageFilterChain::TerminalImageFilterChain ():_buffer (0),
+_linePositions (0)
 {
 }
 
-TerminalImageFilterChain::~TerminalImageFilterChain()
+TerminalImageFilterChain::~TerminalImageFilterChain ()
 {
-    delete _buffer;
-    delete _linePositions;
+  delete _buffer;
+  delete _linePositions;
 }
 
-void TerminalImageFilterChain::setImage(const Character* const image , int lines , int columns, const QVector<LineProperty>& lineProperties)
+void
+TerminalImageFilterChain::setImage (const Character * const image, int lines,
+				    int columns,
+				    const QVector < LineProperty >
+				    &lineProperties)
 {
-    if (empty())
-        return;
+  if (empty ())
+    return;
 
-    // reset all filters and hotspots
-    reset();
+  // reset all filters and hotspots
+  reset ();
 
-    PlainTextDecoder decoder;
-    decoder.setTrailingWhitespace(false);
-    
-    // setup new shared buffers for the filters to process on
-    QString* newBuffer = new QString();
-    QList<int>* newLinePositions = new QList<int>();
-    setBuffer( newBuffer , newLinePositions );
+  PlainTextDecoder decoder;
+  decoder.setTrailingWhitespace (false);
 
-    // free the old buffers
-    delete _buffer;
-    delete _linePositions;
+  // setup new shared buffers for the filters to process on
+  QString *newBuffer = new QString ();
+  QList < int >*newLinePositions = new QList < int >();
+  setBuffer (newBuffer, newLinePositions);
 
-    _buffer = newBuffer;
-    _linePositions = newLinePositions;
+  // free the old buffers
+  delete _buffer;
+  delete _linePositions;
 
-    QTextStream lineStream(_buffer);
-    decoder.begin(&lineStream);
+  _buffer = newBuffer;
+  _linePositions = newLinePositions;
 
-    for (int i=0 ; i < lines ; i++)
+  QTextStream lineStream (_buffer);
+  decoder.begin (&lineStream);
+
+  for (int i = 0; i < lines; i++)
     {
-        _linePositions->append(_buffer->length());
-        decoder.decodeLine(image + i*columns,columns,LINE_DEFAULT);
+      _linePositions->append (_buffer->length ());
+      decoder.decodeLine (image + i * columns, columns, LINE_DEFAULT);
 
-        // pretend that each line ends with a newline character.
-        // this prevents a link that occurs at the end of one line
-        // being treated as part of a link that occurs at the start of the next line
-        //
-        // the downside is that links which are spread over more than one line are not
-        // highlighted.  
-        //
-        // TODO - Use the "line wrapped" attribute associated with lines in a
-        // terminal image to avoid adding this imaginary character for wrapped
-        // lines
-        if ( !(lineProperties.value(i,LINE_DEFAULT) & LINE_WRAPPED) )
-            lineStream << QChar('\n');
+      // pretend that each line ends with a newline character.
+      // this prevents a link that occurs at the end of one line
+      // being treated as part of a link that occurs at the start of the next line
+      //
+      // the downside is that links which are spread over more than one line are not
+      // highlighted.  
+      //
+      // TODO - Use the "line wrapped" attribute associated with lines in a
+      // terminal image to avoid adding this imaginary character for wrapped
+      // lines
+      if (!(lineProperties.value (i, LINE_DEFAULT) & LINE_WRAPPED))
+	lineStream << QChar ('\n');
     }
-    decoder.end();
+  decoder.end ();
 }
 
-Filter::Filter() :
-_linePositions(0),
-_buffer(0)
+Filter::Filter ():
+_linePositions (0), _buffer (0)
 {
 }
 
-Filter::~Filter()
+Filter::~Filter ()
 {
-    QListIterator<HotSpot*> iter(_hotspotList);
-    while (iter.hasNext())
+  QListIterator < HotSpot * >iter (_hotspotList);
+  while (iter.hasNext ())
     {
-        delete iter.next();
+      delete iter.next ();
     }
 }
-void Filter::reset()
+
+void
+Filter::reset ()
 {
-    _hotspots.clear();
-    _hotspotList.clear();
+  _hotspots.clear ();
+  _hotspotList.clear ();
 }
 
-void Filter::setBuffer(const QString* buffer , const QList<int>* linePositions)
+void
+Filter::setBuffer (const QString * buffer, const QList < int >*linePositions)
 {
-    _buffer = buffer;
-    _linePositions = linePositions;
+  _buffer = buffer;
+  _linePositions = linePositions;
 }
 
-void Filter::getLineColumn(int position , int& startLine , int& startColumn)
+void
+Filter::getLineColumn (int position, int &startLine, int &startColumn)
 {
-    Q_ASSERT( _linePositions );
-    Q_ASSERT( _buffer );
+  Q_ASSERT (_linePositions);
+  Q_ASSERT (_buffer);
 
 
-    for (int i = 0 ; i < _linePositions->count() ; i++)
+  for (int i = 0; i < _linePositions->count (); i++)
     {
-        int nextLine = 0;
+      int nextLine = 0;
+
+      if (i == _linePositions->count () - 1)
+	nextLine = _buffer->length () + 1;
+      else
+	nextLine = _linePositions->value (i + 1);
 
-        if ( i == _linePositions->count()-1 )
-            nextLine = _buffer->length() + 1;
-        else
-            nextLine = _linePositions->value(i+1);
-
-        if ( _linePositions->value(i) <= position && position < nextLine ) 
-        {
-            startLine = i;
-            startColumn = string_width(buffer()->mid(_linePositions->value(i),position - _linePositions->value(i)));
-            return;
-        }
+      if (_linePositions->value (i) <= position && position < nextLine)
+	{
+	  startLine = i;
+	  startColumn =
+	    string_width (buffer ()->
+			  mid (_linePositions->value (i),
+			       position - _linePositions->value (i)));
+	  return;
+	}
     }
 }
-    
+
 
 /*void Filter::addLine(const QString& text)
 {
     _linePositions << _buffer.length();
     _buffer.append(text);
 }*/
 
-const QString* Filter::buffer()
+const QString *
+Filter::buffer ()
 {
-    return _buffer;
+  return _buffer;
 }
-Filter::HotSpot::~HotSpot()
+
+Filter::HotSpot::~HotSpot ()
 {
 }
-void Filter::addHotSpot(HotSpot* spot)
+
+void
+Filter::addHotSpot (HotSpot * spot)
 {
-    _hotspotList << spot;
+  _hotspotList << spot;
 
-    for (int line = spot->startLine() ; line <= spot->endLine() ; line++)
+  for (int line = spot->startLine (); line <= spot->endLine (); line++)
     {
-        _hotspots.insert(line,spot);
-    }    
+      _hotspots.insert (line, spot);
+    }
 }
-QList<Filter::HotSpot*> Filter::hotSpots() const
+
+QList < Filter::HotSpot * >Filter::hotSpots () const
 {
-    return _hotspotList;
-}
-QList<Filter::HotSpot*> Filter::hotSpotsAtLine(int line) const
-{
-    return _hotspots.values(line);
+  return _hotspotList;
 }
 
-Filter::HotSpot* Filter::hotSpotAt(int line , int column) const
+QList < Filter::HotSpot * >Filter::hotSpotsAtLine (int line) const
 {
-    QListIterator<HotSpot*> spotIter(_hotspots.values(line));
+  return _hotspots.values (line);
+}
 
-    while (spotIter.hasNext())
+Filter::HotSpot * Filter::hotSpotAt (int line, int column) const
+{
+  QListIterator < HotSpot * >spotIter (_hotspots.values (line));
+
+  while (spotIter.hasNext ())
     {
-        HotSpot* spot = spotIter.next();
-        
-        if ( spot->startLine() == line && spot->startColumn() > column )
-            continue;
-        if ( spot->endLine() == line && spot->endColumn() < column )
-            continue;
-       
-        return spot;
+      HotSpot *
+	spot = spotIter.next ();
+
+      if (spot->startLine () == line && spot->startColumn () > column)
+	continue;
+      if (spot->endLine () == line && spot->endColumn () < column)
+	continue;
+
+      return spot;
     }
 
-    return 0;
+  return 0;
 }
 
-Filter::HotSpot::HotSpot(int startLine , int startColumn , int endLine , int endColumn)
-    : _startLine(startLine)
-    , _startColumn(startColumn)
-    , _endLine(endLine)
-    , _endColumn(endColumn)
-    , _type(NotSpecified)
-{
-}
-QString Filter::HotSpot::tooltip() const
-{
-    return QString();
-}
-QList<QAction*> Filter::HotSpot::actions()
-{
-    return QList<QAction*>();
-}
-int Filter::HotSpot::startLine() const
-{
-    return _startLine;
-}
-int Filter::HotSpot::endLine() const
-{
-    return _endLine;
-}
-int Filter::HotSpot::startColumn() const
-{
-    return _startColumn;
-}
-int Filter::HotSpot::endColumn() const
-{
-    return _endColumn;
-}
-Filter::HotSpot::Type Filter::HotSpot::type() const
-{
-    return _type;
-}
-void Filter::HotSpot::setType(Type type)
-{
-    _type = type;
-}
-
-RegExpFilter::RegExpFilter()
+Filter::HotSpot::HotSpot (int startLine, int startColumn, int endLine, int endColumn):_startLine (startLine), _startColumn (startColumn), _endLine (endLine),
+_endColumn (endColumn),
+_type (NotSpecified)
 {
 }
 
-RegExpFilter::HotSpot::HotSpot(int startLine,int startColumn,int endLine,int endColumn)
-    : Filter::HotSpot(startLine,startColumn,endLine,endColumn)
+QString
+Filter::HotSpot::tooltip () const
+{
+  return QString ();
+}
+
+QList < QAction * >Filter::HotSpot::actions ()
 {
-    setType(Marker);
+  return QList < QAction * >();
+}
+
+int
+Filter::HotSpot::startLine () const
+{
+  return _startLine;
+}
+
+int
+Filter::HotSpot::endLine () const
+{
+  return _endLine;
 }
 
-void RegExpFilter::HotSpot::activate(QObject*)
+int
+Filter::HotSpot::startColumn () const
+{
+  return _startColumn;
+}
+
+int
+Filter::HotSpot::endColumn () const
+{
+  return _endColumn;
+}
+
+Filter::HotSpot::Type Filter::HotSpot::type () const
+{
+  return _type;
+}
+
+void
+Filter::HotSpot::setType (Type type)
+{
+  _type = type;
+}
+
+RegExpFilter::RegExpFilter ()
 {
 }
 
-void RegExpFilter::HotSpot::setCapturedTexts(const QStringList& texts)
+RegExpFilter::HotSpot::HotSpot (int startLine, int startColumn, int endLine,
+				int endColumn):
+Filter::HotSpot (startLine, startColumn, endLine, endColumn)
 {
-    _capturedTexts = texts;
+  setType (Marker);
 }
-QStringList RegExpFilter::HotSpot::capturedTexts() const
+
+void
+RegExpFilter::HotSpot::activate (QObject *)
 {
-    return _capturedTexts;
+}
+
+void
+RegExpFilter::HotSpot::setCapturedTexts (const QStringList & texts)
+{
+  _capturedTexts = texts;
 }
 
-void RegExpFilter::setRegExp(const QRegExp& regExp) 
+QStringList
+RegExpFilter::HotSpot::capturedTexts () const
 {
-    _searchText = regExp;
+  return _capturedTexts;
 }
-QRegExp RegExpFilter::regExp() const
+
+void
+RegExpFilter::setRegExp (const QRegExp & regExp)
 {
-    return _searchText;
+  _searchText = regExp;
 }
+
+QRegExp
+RegExpFilter::regExp () const
+{
+  return _searchText;
+}
+
 /*void RegExpFilter::reset(int)
 {
     _buffer = QString();
 }*/
-void RegExpFilter::process()
+void
+RegExpFilter::process ()
 {
-    int pos = 0;
-    const QString* text = buffer();
+  int pos = 0;
+  const QString *text = buffer ();
+
+  Q_ASSERT (text);
 
-    Q_ASSERT( text );
+  // ignore any regular expressions which match an empty string.
+  // otherwise the while loop below will run indefinitely
+  static const QString emptyString ("");
+  if (_searchText.exactMatch (emptyString))
+    return;
 
-    // ignore any regular expressions which match an empty string.
-    // otherwise the while loop below will run indefinitely
-    static const QString emptyString("");
-    if ( _searchText.exactMatch(emptyString) )
-        return;
+  while (pos >= 0)
+    {
+      pos = _searchText.indexIn (*text, pos);
 
-    while(pos >= 0)
-    {
-        pos = _searchText.indexIn(*text,pos);
+      if (pos >= 0)
+	{
+	  int startLine = 0;
+	  int endLine = 0;
+	  int startColumn = 0;
+	  int endColumn = 0;
+
+	  getLineColumn (pos, startLine, startColumn);
+	  getLineColumn (pos + _searchText.matchedLength (), endLine,
+			 endColumn);
 
-        if ( pos >= 0 )
-        {
-            int startLine = 0;
-            int endLine = 0;
-            int startColumn = 0;
-            int endColumn = 0;
+	  RegExpFilter::HotSpot * spot = newHotSpot (startLine, startColumn,
+						     endLine, endColumn);
+	  spot->setCapturedTexts (_searchText.capturedTexts ());
+
+	  addHotSpot (spot);
+	  pos += _searchText.matchedLength ();
 
-            getLineColumn(pos,startLine,startColumn);
-            getLineColumn(pos + _searchText.matchedLength(),endLine,endColumn);
+	  // if matchedLength == 0, the program will get stuck in an infinite loop
+	  if (_searchText.matchedLength () == 0)
+	    pos = -1;
+	}
+    }
+}
 
-            RegExpFilter::HotSpot* spot = newHotSpot(startLine,startColumn,
-                                           endLine,endColumn);
-            spot->setCapturedTexts(_searchText.capturedTexts());
+RegExpFilter::HotSpot * RegExpFilter::newHotSpot (int startLine,
+						  int startColumn,
+						  int endLine, int endColumn)
+{
+  return new RegExpFilter::HotSpot (startLine, startColumn,
+				    endLine, endColumn);
+}
 
-            addHotSpot( spot );  
-            pos += _searchText.matchedLength();
+RegExpFilter::HotSpot * UrlFilter::newHotSpot (int startLine, int startColumn,
+					       int endLine, int endColumn)
+{
+  return new UrlFilter::HotSpot (startLine, startColumn, endLine, endColumn);
+}
 
-            // if matchedLength == 0, the program will get stuck in an infinite loop
-            if ( _searchText.matchedLength() == 0 )
-                pos = -1;
-        }
-    }    
+UrlFilter::HotSpot::HotSpot (int startLine, int startColumn, int endLine, int endColumn):RegExpFilter::HotSpot (startLine, startColumn, endLine, endColumn),
+_urlObject (new
+	    FilterObject (this))
+{
+  setType (Link);
 }
 
-RegExpFilter::HotSpot* RegExpFilter::newHotSpot(int startLine,int startColumn,
-                                                int endLine,int endColumn)
-{
-    return new RegExpFilter::HotSpot(startLine,startColumn,
-                                                  endLine,endColumn);
-}
-RegExpFilter::HotSpot* UrlFilter::newHotSpot(int startLine,int startColumn,int endLine,
-                                                    int endColumn)
-{
-    return new UrlFilter::HotSpot(startLine,startColumn,
-                                               endLine,endColumn);
-}
-UrlFilter::HotSpot::HotSpot(int startLine,int startColumn,int endLine,int endColumn)
-: RegExpFilter::HotSpot(startLine,startColumn,endLine,endColumn)
-, _urlObject(new FilterObject(this))
-{
-    setType(Link);
-}
-QString UrlFilter::HotSpot::tooltip() const
+QString
+UrlFilter::HotSpot::tooltip () const
 {
-    QString url = capturedTexts().first();
+  QString
+    url = capturedTexts ().first ();
 
-    const UrlType kind = urlType();
+  const UrlType
+    kind = urlType ();
 
-    if ( kind == StandardUrl )
-        return QString(); 
-    else if ( kind == Email )
-        return QString(); 
-    else
-        return QString();
+  if (kind == StandardUrl)
+    return QString ();
+  else if (kind == Email)
+    return QString ();
+  else
+    return QString ();
 }
-UrlFilter::HotSpot::UrlType UrlFilter::HotSpot::urlType() const
+
+UrlFilter::HotSpot::UrlType UrlFilter::HotSpot::urlType () const
 {
-    QString url = capturedTexts().first();
-    
-    if ( FullUrlRegExp.exactMatch(url) )
-        return StandardUrl;
-    else if ( EmailAddressRegExp.exactMatch(url) )
-        return Email;
-    else
-        return Unknown;
+  QString
+    url = capturedTexts ().first ();
+
+  if (FullUrlRegExp.exactMatch (url))
+    return StandardUrl;
+  else if (EmailAddressRegExp.exactMatch (url))
+    return Email;
+  else
+    return Unknown;
 }
 
-void UrlFilter::HotSpot::activate(QObject* object)
+void
+UrlFilter::HotSpot::activate (QObject * object)
 {
-    QString url = capturedTexts().first();
+  QString
+    url = capturedTexts ().first ();
 
-    const UrlType kind = urlType();
+  const UrlType
+    kind = urlType ();
 
-    const QString& actionName = object ? object->objectName() : QString();
+  const
+    QString &
+    actionName = object ? object->objectName () : QString ();
 
-    if ( actionName == "copy-action" )
+  if (actionName == "copy-action")
     {
-        QApplication::clipboard()->setText(url);
-        return;
+      QApplication::clipboard ()->setText (url);
+      return;
     }
 
-    if ( !object || actionName == "open-action" )
+  if (!object || actionName == "open-action")
     {
-        if ( kind == StandardUrl )
-        {
-            // if the URL path does not include the protocol ( eg. "www.kde.org" ) then
-            // prepend http:// ( eg. "www.kde.org" --> "http://www.kde.org" )
-            if (!url.contains("://"))
-            {
-                url.prepend("http://");
-            }
-        } 
-        else if ( kind == Email )
-        {
-            url.prepend("mailto:");
-        }
-    
-        //new KRun(url,QApplication::activeWindow());
+      if (kind == StandardUrl)
+	{
+	  // if the URL path does not include the protocol ( eg. "www.kde.org" ) then
+	  // prepend http:// ( eg. "www.kde.org" --> "http://www.kde.org" )
+	  if (!url.contains ("://"))
+	    {
+	      url.prepend ("http://");
+	    }
+	}
+      else if (kind == Email)
+	{
+	  url.prepend ("mailto:");
+	}
+
+      //new KRun(url,QApplication::activeWindow());
     }
 }
 
 // Note:  Altering these regular expressions can have a major effect on the performance of the filters 
 // used for finding URLs in the text, especially if they are very general and could match very long
 // pieces of text.
 // Please be careful when altering them.
 
 //regexp matches:
 // full url:  
 // protocolname:// or www. followed by anything other than whitespaces, <, >, ' or ", and ends before whitespaces, <, >, ', ", ], !, comma and dot
-const QRegExp UrlFilter::FullUrlRegExp("(www\\.(?!\\.)|[a-z][a-z0-9+.-]*://)[^\\s<>'\"]+[^!,\\.\\s<>'\"\\]]");
+const QRegExp
+UrlFilter::
+
+FullUrlRegExp
+("(www\\.(?!\\.)|[a-z][a-z0-9+.-]*://)[^\\s<>'\"]+[^!,\\.\\s<>'\"\\]]");
 // email address:
 // [word chars, dots or dashes]@[word chars, dots or dashes].[word chars]
-const QRegExp UrlFilter::EmailAddressRegExp("\\b(\\w|\\.|-)+@(\\w|\\.|-)+\\.\\w+\\b");
+const QRegExp
+UrlFilter::EmailAddressRegExp ("\\b(\\w|\\.|-)+@(\\w|\\.|-)+\\.\\w+\\b");
 
 // matches full url or email address
-const QRegExp UrlFilter::CompleteUrlRegExp('('+FullUrlRegExp.pattern()+'|'+
-                                            EmailAddressRegExp.pattern()+')');
+const QRegExp
+UrlFilter::CompleteUrlRegExp ('(' + FullUrlRegExp.pattern () + '|' +
+			      EmailAddressRegExp.pattern () + ')');
 
-UrlFilter::UrlFilter()
+UrlFilter::UrlFilter ()
 {
-    setRegExp( CompleteUrlRegExp );
+  setRegExp (CompleteUrlRegExp);
 }
-UrlFilter::HotSpot::~HotSpot()
+
+UrlFilter::HotSpot::~HotSpot ()
 {
-    delete _urlObject;
+  delete
+    _urlObject;
 }
-void FilterObject::activated()
-{
-    _filter->activate(sender());
-}
-QList<QAction*> UrlFilter::HotSpot::actions()
+
+void
+FilterObject::activated ()
 {
-    QList<QAction*> list;
-
-    const UrlType kind = urlType();
+  _filter->activate (sender ());
+}
 
-    QAction* openAction = new QAction(_urlObject);
-    QAction* copyAction = new QAction(_urlObject);;
+QList < QAction * >UrlFilter::HotSpot::actions ()
+{
+  QList < QAction * >list;
 
-    Q_ASSERT( kind == StandardUrl || kind == Email );
+  const UrlType
+    kind = urlType ();
 
-    if ( kind == StandardUrl )
+  QAction *
+    openAction = new QAction (_urlObject);
+  QAction *
+    copyAction = new QAction (_urlObject);;
+
+  Q_ASSERT (kind == StandardUrl || kind == Email);
+
+  if (kind == StandardUrl)
     {
-        openAction->setText(tr((char*)"Open Link"));
-        copyAction->setText(tr((char*)"Copy Link Address"));
+      openAction->setText (tr ((char *) "Open Link"));
+      copyAction->setText (tr ((char *) "Copy Link Address"));
     }
-    else if ( kind == Email )
+  else if (kind == Email)
     {
-        openAction->setText(tr((char*)"Send Email To..."));
-        copyAction->setText(tr((char*)"Copy Email Address"));
+      openAction->setText (tr ((char *) "Send Email To..."));
+      copyAction->setText (tr ((char *) "Copy Email Address"));
     }
 
-    // object names are set here so that the hotspot performs the
-    // correct action when activated() is called with the triggered
-    // action passed as a parameter.
-    openAction->setObjectName( QLatin1String("open-action" ));
-    copyAction->setObjectName( QLatin1String("copy-action" ));
+  // object names are set here so that the hotspot performs the
+  // correct action when activated() is called with the triggered
+  // action passed as a parameter.
+  openAction->setObjectName (QLatin1String ("open-action"));
+  copyAction->setObjectName (QLatin1String ("copy-action"));
 
-    QObject::connect( openAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
-    QObject::connect( copyAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
+  QObject::connect (openAction, SIGNAL (triggered ()), _urlObject,
+		    SLOT (activated ()));
+  QObject::connect (copyAction, SIGNAL (triggered ()), _urlObject,
+		    SLOT (activated ()));
 
-    list << openAction;
-    list << copyAction;
+  list << openAction;
+  list << copyAction;
 
-    return list; 
+  return list;
 }
-
diff --git a/gui/src/terminal/Filter.h b/gui/src/terminal/Filter.h
--- a/gui/src/terminal/Filter.h
+++ b/gui/src/terminal/Filter.h
@@ -60,252 +60,252 @@ public:
     * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
     * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
     * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
     *
     * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
     * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
     * actions() method.  These actions may then be displayed in a popup menu or toolbar for example. 
     */
-    class HotSpot
-    {
-    public:
+  class HotSpot
+  {
+  public:
        /** 
         * Constructs a new hotspot which covers the area from (@p startLine,@p startColumn) to (@p endLine,@p endColumn)
         * in a block of text.
         */
-       HotSpot(int startLine , int startColumn , int endLine , int endColumn);
-       virtual ~HotSpot();
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+    virtual ~ HotSpot ();
 
-       enum Type
-       {
-            // the type of the hotspot is not specified
-            NotSpecified,
-            // this hotspot represents a clickable link
-            Link,
-            // this hotspot represents a marker
-            Marker
-       }; 
+    enum Type
+    {
+      // the type of the hotspot is not specified
+      NotSpecified,
+      // this hotspot represents a clickable link
+      Link,
+      // this hotspot represents a marker
+      Marker
+    };
 
        /** Returns the line when the hotspot area starts */
-       int startLine() const;
+    int startLine () const;
        /** Returns the line where the hotspot area ends */
-       int endLine() const;
+    int endLine () const;
        /** Returns the column on startLine() where the hotspot area starts */
-       int startColumn() const;
+    int startColumn () const;
        /** Returns the column on endLine() where the hotspot area ends */
-       int endColumn() const;
+    int endColumn () const;
        /** 
         * Returns the type of the hotspot.  This is usually used as a hint for views on how to represent
         * the hotspot graphically.  eg.  Link hotspots are typically underlined when the user mouses over them
         */
-       Type type() const;
+    Type type () const;
        /** 
         * Causes the an action associated with a hotspot to be triggered. 
         *
         * @param object The object which caused the hotspot to be triggered.  This is
         * typically null ( in which case the default action should be performed ) or
         * one of the objects from the actions() list.  In which case the associated
         * action should be performed. 
         */
-       virtual void activate(QObject* object = 0) = 0; 
+    virtual void activate (QObject * object = 0) = 0;
        /** 
         * Returns a list of actions associated with the hotspot which can be used in a 
         * menu or toolbar 
         */
-       virtual QList<QAction*> actions();
+    virtual QList < QAction * >actions ();
 
        /** 
         * Returns the text of a tooltip to be shown when the mouse moves over the hotspot, or
         * an empty string if there is no tooltip associated with this hotspot.
         *
         * The default implementation returns an empty string. 
         */
-       virtual QString tooltip() const;
+    virtual QString tooltip () const;
 
-    protected:
+  protected:
        /** Sets the type of a hotspot.  This should only be set once */
-       void setType(Type type);
+    void setType (Type type);
 
-    private:
-       int    _startLine;
-       int    _startColumn;
-       int    _endLine;
-       int    _endColumn;
-       Type _type;
-    
-    };
+  private:
+    int _startLine;
+    int _startColumn;
+    int _endLine;
+    int _endColumn;
+    Type _type;
+
+  };
 
     /** Constructs a new filter. */
-    Filter();
-    virtual ~Filter();
+  Filter ();
+  virtual ~ Filter ();
 
     /** Causes the filter to process the block of text currently in its internal buffer */
-    virtual void process() = 0;
+  virtual void process () = 0;
 
     /** 
      * Empties the filters internal buffer and resets the line count back to 0.
      * All hotspots are deleted. 
      */
-    void reset();
+  void reset ();
 
     /** Adds a new line of text to the filter and increments the line count */
-    //void addLine(const QString& string);
+  //void addLine(const QString& string);
 
     /** Returns the hotspot which covers the given @p line and @p column, or 0 if no hotspot covers that area */
-    HotSpot* hotSpotAt(int line , int column) const;
+  HotSpot *hotSpotAt (int line, int column) const;
 
     /** Returns the list of hotspots identified by the filter */
-    QList<HotSpot*> hotSpots() const;
+  QList < HotSpot * >hotSpots ()const;
 
     /** Returns the list of hotspots identified by the filter which occur on a given line */
-    QList<HotSpot*> hotSpotsAtLine(int line) const;
+  QList < HotSpot * >hotSpotsAtLine (int line) const;
 
     /** 
      * TODO: Document me
      */
-    void setBuffer(const QString* buffer , const QList<int>* linePositions);
+  void setBuffer (const QString * buffer, const QList < int >*linePositions);
 
 protected:
     /** Adds a new hotspot to the list */
-    void addHotSpot(HotSpot*);
+  void addHotSpot (HotSpot *);
     /** Returns the internal buffer */
-    const QString* buffer();
+  const QString *buffer ();
     /** Converts a character position within buffer() to a line and column */
-    void getLineColumn(int position , int& startLine , int& startColumn);
+  void getLineColumn (int position, int &startLine, int &startColumn);
 
 private:
-    QMultiHash<int,HotSpot*> _hotspots;
-    QList<HotSpot*> _hotspotList;
-    
-    const QList<int>* _linePositions;
-    const QString* _buffer;
+  QMultiHash < int, HotSpot * >_hotspots;
+  QList < HotSpot * >_hotspotList;
+
+  const QList < int >*_linePositions;
+  const QString *_buffer;
 };
 
 /** 
  * A filter which searches for sections of text matching a regular expression and creates a new RegExpFilter::HotSpot 
  * instance for them.
  *
  * Subclasses can reimplement newHotSpot() to return custom hotspot types when matches for the regular expression
  * are found. 
  */
-class RegExpFilter : public Filter
+class RegExpFilter:public Filter
 {
 public:
     /** 
      * Type of hotspot created by RegExpFilter.  The capturedTexts() method can be used to find the text
      * matched by the filter's regular expression.
      */
-    class HotSpot : public Filter::HotSpot
-    {
-    public:
-        HotSpot(int startLine, int startColumn, int endLine , int endColumn);
-        virtual void activate(QObject* object = 0);
+  class HotSpot:public Filter::HotSpot
+  {
+  public:
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+    virtual void activate (QObject * object = 0);
 
-        /** Sets the captured texts associated with this hotspot */
-        void setCapturedTexts(const QStringList& texts);
-        /** Returns the texts found by the filter when matching the filter's regular expression */
-        QStringList capturedTexts() const;
-    private:
-        QStringList _capturedTexts;
-    };
+	/** Sets the captured texts associated with this hotspot */
+    void setCapturedTexts (const QStringList & texts);
+	/** Returns the texts found by the filter when matching the filter's regular expression */
+    QStringList capturedTexts () const;
+  private:
+      QStringList _capturedTexts;
+  };
 
     /** Constructs a new regular expression filter */
-    RegExpFilter();
+  RegExpFilter ();
 
     /** 
      * Sets the regular expression which the filter searches for in blocks of text. 
      *
      * Regular expressions which match the empty string are treated as not matching
      * anything. 
      */
-    void setRegExp(const QRegExp& text);
+  void setRegExp (const QRegExp & text);
     /** Returns the regular expression which the filter searches for in blocks of text */
-    QRegExp regExp() const;
+  QRegExp regExp () const;
 
     /** 
      * Reimplemented to search the filter's text buffer for text matching regExp() 
      *
      * If regexp matches the empty string, then process() will return immediately
      * without finding results. 
      */
-    virtual void process();
+  virtual void process ();
 
 protected:
     /** 
      * Called when a match for the regular expression is encountered.  Subclasses should reimplement this
      * to return custom hotspot types
      */
-    virtual RegExpFilter::HotSpot* newHotSpot(int startLine,int startColumn,
-                                    int endLine,int endColumn);
+  virtual RegExpFilter::HotSpot * newHotSpot (int startLine, int startColumn,
+					      int endLine, int endColumn);
 
 private:
-    QRegExp _searchText;
+  QRegExp _searchText;
 };
 
 class FilterObject;
 
 /** A filter which matches URLs in blocks of text */
-class UrlFilter : public RegExpFilter 
+class UrlFilter:public RegExpFilter
 {
 public:
     /** 
      * Hotspot type created by UrlFilter instances.  The activate() method opens a web browser 
      * at the given URL when called.
      */
-    class HotSpot : public RegExpFilter::HotSpot 
-    {
-    public:
-        HotSpot(int startLine,int startColumn,int endLine,int endColumn);
-        virtual ~HotSpot();
+  class HotSpot:public RegExpFilter::HotSpot
+  {
+  public:
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+      virtual ~ HotSpot ();
 
-        virtual QList<QAction*> actions();
+    virtual QList < QAction * >actions ();
 
-        /** 
+	/** 
          * Open a web browser at the current URL.  The url itself can be determined using
          * the capturedTexts() method.
          */
-        virtual void activate(QObject* object = 0);
+    virtual void activate (QObject * object = 0);
 
-        virtual QString tooltip() const;
-    private:
-        enum UrlType
-        {
-            StandardUrl,
-            Email,
-            Unknown
-        };
-        UrlType urlType() const;
+    virtual QString tooltip () const;
+  private:
+    enum UrlType
+    {
+      StandardUrl,
+      Email,
+      Unknown
+    };
+    UrlType urlType () const;
 
-        FilterObject* _urlObject;
-    };
+    FilterObject *_urlObject;
+  };
 
-    UrlFilter();
+  UrlFilter ();
 
 protected:
-    virtual RegExpFilter::HotSpot* newHotSpot(int,int,int,int);
+  virtual RegExpFilter::HotSpot * newHotSpot (int, int, int, int);
 
 private:
-    
-    static const QRegExp FullUrlRegExp;
-    static const QRegExp EmailAddressRegExp;
 
-    // combined OR of FullUrlRegExp and EmailAddressRegExp
-    static const QRegExp CompleteUrlRegExp; 
+  static const QRegExp FullUrlRegExp;
+  static const QRegExp EmailAddressRegExp;
+
+  // combined OR of FullUrlRegExp and EmailAddressRegExp
+  static const QRegExp CompleteUrlRegExp;
 };
 
-class FilterObject : public QObject
+class FilterObject:public QObject
 {
-Q_OBJECT
-public:
-    FilterObject(Filter::HotSpot* filter) : _filter(filter) {}
-private slots:
-    void activated();
+Q_OBJECT public:
+  FilterObject (Filter::HotSpot * filter):_filter (filter)
+  {
+  }
+  private slots:void activated ();
 private:
-    Filter::HotSpot* _filter;
+  Filter::HotSpot * _filter;
 };
 
 /** 
  * A chain which allows a group of filters to be processed as one. 
  * The chain owns the filters added to it and deletes them when the chain itself is destroyed.
  *
  * Use addFilter() to add a new filter to the chain.  
  * When new text to be filtered arrives, use addLine() to add each additional
@@ -315,65 +315,65 @@ private:
  * After processing a block of text, the reset() method can be used to set the filter chain's
  * internal cursor back to the first line.
  *
  * The hotSpotAt() method will return the first hotspot which covers a given position.
  *
  * The hotSpots() and hotSpotsAtLine() method return all of the hotspots in the text and on
  * a given line respectively.
  */
-class FilterChain : protected QList<Filter*>
+class FilterChain:protected QList < Filter * >
 {
 public:
-    virtual ~FilterChain();
+  virtual ~ FilterChain ();
 
     /** Adds a new filter to the chain.  The chain will delete this filter when it is destroyed */
-    void addFilter(Filter* filter);
+  void addFilter (Filter * filter);
     /** Removes a filter from the chain.  The chain will no longer delete the filter when destroyed */
-    void removeFilter(Filter* filter);
+  void removeFilter (Filter * filter);
     /** Returns true if the chain contains @p filter */
-    bool containsFilter(Filter* filter);
+  bool containsFilter (Filter * filter);
     /** Removes all filters from the chain */
-    void clear();
+  void clear ();
 
     /** Resets each filter in the chain */
-    void reset();
+  void reset ();
     /**
      * Processes each filter in the chain 
      */
-    void process();
+  void process ();
 
     /** Sets the buffer for each filter in the chain to process. */
-    void setBuffer(const QString* buffer , const QList<int>* linePositions); 
+  void setBuffer (const QString * buffer, const QList < int >*linePositions);
 
     /** Returns the first hotspot which occurs at @p line, @p column or 0 if no hotspot was found */
-    Filter::HotSpot* hotSpotAt(int line , int column) const;
+    Filter::HotSpot * hotSpotAt (int line, int column) const;
     /** Returns a list of all the hotspots in all the chain's filters */
-    QList<Filter::HotSpot*> hotSpots() const;
+    QList < Filter::HotSpot * >hotSpots () const;
     /** Returns a list of all hotspots at the given line in all the chain's filters */
-    QList<Filter::HotSpot> hotSpotsAtLine(int line) const;
+    QList < Filter::HotSpot > hotSpotsAtLine (int line) const;
 
 };
 
 /** A filter chain which processes character images from terminal displays */
-class TerminalImageFilterChain : public FilterChain
+class TerminalImageFilterChain:public FilterChain
 {
 public:
-    TerminalImageFilterChain();
-    virtual ~TerminalImageFilterChain();
+  TerminalImageFilterChain ();
+  virtual ~ TerminalImageFilterChain ();
 
     /**
      * Set the current terminal image to @p image.
      *
      * @param image The terminal image
      * @param lines The number of lines in the terminal image
      * @param columns The number of columns in the terminal image
      * @param lineProperties The line properties to set for image
      */
-    void setImage(const Character* const image , int lines , int columns,
-                  const QVector<LineProperty>& lineProperties);  
+  void setImage (const Character * const image, int lines, int columns,
+		 const QVector < LineProperty > &lineProperties);
 
 private:
-    QString* _buffer;
-    QList<int>* _linePositions;
+    QString * _buffer;
+    QList < int >*_linePositions;
 };
 
 #endif //FILTER_H
diff --git a/gui/src/terminal/History.cpp b/gui/src/terminal/History.cpp
--- a/gui/src/terminal/History.cpp
+++ b/gui/src/terminal/History.cpp
@@ -76,125 +76,148 @@ FIXME: There is noticeable decrease in s
 //#define tmpfile xTmpFile
 
 // History File ///////////////////////////////////////////
 
 /*
   A Row(X) data type which allows adding elements to the end.
 */
 
-HistoryFile::HistoryFile()
-  : ion(-1),
-    length(0),
-	fileMap(0)
+HistoryFile::HistoryFile ():ion (-1), length (0), fileMap (0)
 {
-  if (tmpFile.open())
-  { 
-    tmpFile.setAutoRemove(true);
-    ion = tmpFile.handle();
-  }
+  if (tmpFile.open ())
+    {
+      tmpFile.setAutoRemove (true);
+      ion = tmpFile.handle ();
+    }
 }
 
-HistoryFile::~HistoryFile()
+HistoryFile::~HistoryFile ()
 {
-	if (fileMap)
-		unmap();
+  if (fileMap)
+    unmap ();
 }
 
 //TODO:  Mapping the entire file in will cause problems if the history file becomes exceedingly large,
 //(ie. larger than available memory).  HistoryFile::map() should only map in sections of the file at a time,
 //to avoid this.
-void HistoryFile::map()
+void
+HistoryFile::map ()
 {
-	assert( fileMap == 0 );
+  assert (fileMap == 0);
 
-	fileMap = (char*)mmap( 0 , length , PROT_READ , MAP_PRIVATE , ion , 0 );
+  fileMap = (char *) mmap (0, length, PROT_READ, MAP_PRIVATE, ion, 0);
 
-    //if mmap'ing fails, fall back to the read-lseek combination
-    if ( fileMap == MAP_FAILED )
+  //if mmap'ing fails, fall back to the read-lseek combination
+  if (fileMap == MAP_FAILED)
     {
-            readWriteBalance = 0; 
-            fileMap = 0;
-            qDebug() << ": mmap'ing history failed.  errno = " << errno;
+      readWriteBalance = 0;
+      fileMap = 0;
+      qDebug () << ": mmap'ing history failed.  errno = " << errno;
     }
 }
 
-void HistoryFile::unmap()
+void
+HistoryFile::unmap ()
 {
-	int result = munmap( fileMap , length );
-	assert( result == 0 );
+  int result = munmap (fileMap, length);
+  assert (result == 0);
 
-	fileMap = 0;
+  fileMap = 0;
 }
 
-bool HistoryFile::isMapped()
+bool
+HistoryFile::isMapped ()
 {
-	return (fileMap != 0);
+  return (fileMap != 0);
 }
 
-void HistoryFile::add(const unsigned char* bytes, int len)
+void
+HistoryFile::add (const unsigned char *bytes, int len)
 {
-  if ( fileMap )
-		  unmap();
-		
+  if (fileMap)
+    unmap ();
+
   readWriteBalance++;
 
   int rc = 0;
 
-  rc = lseek(ion,length,SEEK_SET); if (rc < 0) { perror("HistoryFile::add.seek"); return; }
-  rc = write(ion,bytes,len);       if (rc < 0) { perror("HistoryFile::add.write"); return; }
+  rc = lseek (ion, length, SEEK_SET);
+  if (rc < 0)
+    {
+      perror ("HistoryFile::add.seek");
+      return;
+    }
+  rc = write (ion, bytes, len);
+  if (rc < 0)
+    {
+      perror ("HistoryFile::add.write");
+      return;
+    }
   length += rc;
 }
 
-void HistoryFile::get(unsigned char* bytes, int len, int loc)
+void
+HistoryFile::get (unsigned char *bytes, int len, int loc)
 {
   //count number of get() calls vs. number of add() calls.  
   //If there are many more get() calls compared with add() 
   //calls (decided by using MAP_THRESHOLD) then mmap the log
   //file to improve performance.
   readWriteBalance--;
-  if ( !fileMap && readWriteBalance < MAP_THRESHOLD )
-		  map();
+  if (!fileMap && readWriteBalance < MAP_THRESHOLD)
+    map ();
 
-  if ( fileMap )
-  {
-	for (int i=0;i<len;i++)
-			bytes[i]=fileMap[loc+i];
-  }
+  if (fileMap)
+    {
+      for (int i = 0; i < len; i++)
+	bytes[i] = fileMap[loc + i];
+    }
   else
-  {	
-  	int rc = 0;
+    {
+      int rc = 0;
 
-  	if (loc < 0 || len < 0 || loc + len > length)
-    	fprintf(stderr,"getHist(...,%d,%d): invalid args.\n",len,loc);
-  	rc = lseek(ion,loc,SEEK_SET); if (rc < 0) { perror("HistoryFile::get.seek"); return; }
-  	rc = read(ion,bytes,len);     if (rc < 0) { perror("HistoryFile::get.read"); return; }
-  }
+      if (loc < 0 || len < 0 || loc + len > length)
+	fprintf (stderr, "getHist(...,%d,%d): invalid args.\n", len, loc);
+      rc = lseek (ion, loc, SEEK_SET);
+      if (rc < 0)
+	{
+	  perror ("HistoryFile::get.seek");
+	  return;
+	}
+      rc = read (ion, bytes, len);
+      if (rc < 0)
+	{
+	  perror ("HistoryFile::get.read");
+	  return;
+	}
+    }
 }
 
-int HistoryFile::len()
+int
+HistoryFile::len ()
 {
   return length;
 }
 
 
 // History Scroll abstract base class //////////////////////////////////////
 
 
-HistoryScroll::HistoryScroll(HistoryType* t)
-  : m_histType(t)
+HistoryScroll::HistoryScroll (HistoryType * t):m_histType (t)
 {
 }
 
-HistoryScroll::~HistoryScroll()
+HistoryScroll::~HistoryScroll ()
 {
   delete m_histType;
 }
 
-bool HistoryScroll::hasScroll()
+bool
+HistoryScroll::hasScroll ()
 {
   return true;
 }
 
 // History Scroll File //////////////////////////////////////
 
 /* 
    The history scroll makes a Row(Row(Cell)) from
@@ -202,495 +225,551 @@ bool HistoryScroll::hasScroll()
    start of line positions which refere to the cells
    buffer.
 
    Note that index[0] addresses the second line
    (line #1), while the first line (line #0) starts
    at 0 in cells.
 */
 
-HistoryScrollFile::HistoryScrollFile(const QString &logFileName)
-  : HistoryScroll(new HistoryTypeFile(logFileName)),
-  m_logFileName(logFileName)
+HistoryScrollFile::HistoryScrollFile (const QString & logFileName):HistoryScroll (new HistoryTypeFile (logFileName)),
+m_logFileName
+(logFileName)
+{
+}
+
+HistoryScrollFile::~HistoryScrollFile ()
 {
 }
 
-HistoryScrollFile::~HistoryScrollFile()
+int
+HistoryScrollFile::getLines ()
 {
-}
- 
-int HistoryScrollFile::getLines()
-{
-  return index.len() / sizeof(int);
+  return index.len () / sizeof (int);
 }
 
-int HistoryScrollFile::getLineLen(int lineno)
+int
+HistoryScrollFile::getLineLen (int lineno)
 {
-  return (startOfLine(lineno+1) - startOfLine(lineno)) / sizeof(Character);
+  return (startOfLine (lineno + 1) -
+	  startOfLine (lineno)) / sizeof (Character);
 }
 
-bool HistoryScrollFile::isWrappedLine(int lineno)
+bool
+HistoryScrollFile::isWrappedLine (int lineno)
 {
-  if (lineno>=0 && lineno <= getLines()) {
-    unsigned char flag;
-    lineflags.get((unsigned char*)&flag,sizeof(unsigned char),(lineno)*sizeof(unsigned char));
-    return flag;
-  }
+  if (lineno >= 0 && lineno <= getLines ())
+    {
+      unsigned char flag;
+      lineflags.get ((unsigned char *) &flag, sizeof (unsigned char),
+		     (lineno) * sizeof (unsigned char));
+      return flag;
+    }
   return false;
 }
 
-int HistoryScrollFile::startOfLine(int lineno)
+int
+HistoryScrollFile::startOfLine (int lineno)
 {
-  if (lineno <= 0) return 0;
-  if (lineno <= getLines())
-    { 
-	
-	if (!index.isMapped())
-			index.map();
-	
-	int res;
-    index.get((unsigned char*)&res,sizeof(int),(lineno-1)*sizeof(int));
-    return res;
+  if (lineno <= 0)
+    return 0;
+  if (lineno <= getLines ())
+    {
+
+      if (!index.isMapped ())
+	index.map ();
+
+      int res;
+      index.get ((unsigned char *) &res, sizeof (int),
+		 (lineno - 1) * sizeof (int));
+      return res;
     }
-  return cells.len();
+  return cells.len ();
 }
 
-void HistoryScrollFile::getCells(int lineno, int colno, int count, Character res[])
+void
+HistoryScrollFile::getCells (int lineno, int colno, int count,
+			     Character res[])
 {
-  cells.get((unsigned char*)res,count*sizeof(Character),startOfLine(lineno)+colno*sizeof(Character));
-}
-
-void HistoryScrollFile::addCells(const Character text[], int count)
-{
-  cells.add((unsigned char*)text,count*sizeof(Character));
+  cells.get ((unsigned char *) res, count * sizeof (Character),
+	     startOfLine (lineno) + colno * sizeof (Character));
 }
 
-void HistoryScrollFile::addLine(bool previousWrapped)
+void
+HistoryScrollFile::addCells (const Character text[], int count)
 {
-  if (index.isMapped())
-		  index.unmap();
+  cells.add ((unsigned char *) text, count * sizeof (Character));
+}
 
-  int locn = cells.len();
-  index.add((unsigned char*)&locn,sizeof(int));
+void
+HistoryScrollFile::addLine (bool previousWrapped)
+{
+  if (index.isMapped ())
+    index.unmap ();
+
+  int locn = cells.len ();
+  index.add ((unsigned char *) &locn, sizeof (int));
   unsigned char flags = previousWrapped ? 0x01 : 0x00;
-  lineflags.add((unsigned char*)&flags,sizeof(unsigned char));
+  lineflags.add ((unsigned char *) &flags, sizeof (unsigned char));
 }
 
 
 // History Scroll Buffer //////////////////////////////////////
-HistoryScrollBuffer::HistoryScrollBuffer(unsigned int maxLineCount)
-  : HistoryScroll(new HistoryTypeBuffer(maxLineCount))
-   ,_historyBuffer()
-   ,_maxLineCount(0)
-   ,_usedLines(0)
-   ,_head(0)
+HistoryScrollBuffer::HistoryScrollBuffer (unsigned int maxLineCount):
+HistoryScroll (new HistoryTypeBuffer (maxLineCount)),
+_historyBuffer (),
+_maxLineCount (0),
+_usedLines (0),
+_head (0)
 {
-  setMaxNbLines(maxLineCount);
+  setMaxNbLines (maxLineCount);
 }
 
-HistoryScrollBuffer::~HistoryScrollBuffer()
+HistoryScrollBuffer::~HistoryScrollBuffer ()
 {
-    delete[] _historyBuffer;
+  delete[]_historyBuffer;
 }
 
-void HistoryScrollBuffer::addCellsVector(const QVector<Character>& cells)
+void
+HistoryScrollBuffer::addCellsVector (const QVector < Character > &cells)
 {
-    _head++;
-    if ( _usedLines < _maxLineCount )
-        _usedLines++;
+  _head++;
+  if (_usedLines < _maxLineCount)
+    _usedLines++;
 
-    if ( _head >= _maxLineCount )
+  if (_head >= _maxLineCount)
     {
-        _head = 0;
+      _head = 0;
     }
 
-    _historyBuffer[bufferIndex(_usedLines-1)] = cells;
-    _wrappedLine[bufferIndex(_usedLines-1)] = false;
-}
-void HistoryScrollBuffer::addCells(const Character a[], int count)
-{
-  HistoryLine newLine(count);
-  qCopy(a,a+count,newLine.begin());
-
-  addCellsVector(newLine);
+  _historyBuffer[bufferIndex (_usedLines - 1)] = cells;
+  _wrappedLine[bufferIndex (_usedLines - 1)] = false;
 }
 
-void HistoryScrollBuffer::addLine(bool previousWrapped)
+void
+HistoryScrollBuffer::addCells (const Character a[], int count)
 {
-    _wrappedLine[bufferIndex(_usedLines-1)] = previousWrapped;
+  HistoryLine newLine (count);
+  qCopy (a, a + count, newLine.begin ());
+
+  addCellsVector (newLine);
 }
 
-int HistoryScrollBuffer::getLines()
+void
+HistoryScrollBuffer::addLine (bool previousWrapped)
 {
-    return _usedLines;
+  _wrappedLine[bufferIndex (_usedLines - 1)] = previousWrapped;
+}
+
+int
+HistoryScrollBuffer::getLines ()
+{
+  return _usedLines;
 }
 
-int HistoryScrollBuffer::getLineLen(int lineNumber)
+int
+HistoryScrollBuffer::getLineLen (int lineNumber)
 {
-  Q_ASSERT( lineNumber >= 0 && lineNumber < _maxLineCount );
+  Q_ASSERT (lineNumber >= 0 && lineNumber < _maxLineCount);
 
-  if ( lineNumber < _usedLines )
-  {
-    return _historyBuffer[bufferIndex(lineNumber)].size();
-  }
+  if (lineNumber < _usedLines)
+    {
+      return _historyBuffer[bufferIndex (lineNumber)].size ();
+    }
   else
-  {
-    return 0;
-  }
+    {
+      return 0;
+    }
 }
 
-bool HistoryScrollBuffer::isWrappedLine(int lineNumber)
+bool
+HistoryScrollBuffer::isWrappedLine (int lineNumber)
 {
-  Q_ASSERT( lineNumber >= 0 && lineNumber < _maxLineCount );
-    
+  Q_ASSERT (lineNumber >= 0 && lineNumber < _maxLineCount);
+
   if (lineNumber < _usedLines)
-  {
-    //kDebug() << "Line" << lineNumber << "wrapped is" << _wrappedLine[bufferIndex(lineNumber)];
-    return _wrappedLine[bufferIndex(lineNumber)];
-  }
+    {
+      //kDebug() << "Line" << lineNumber << "wrapped is" << _wrappedLine[bufferIndex(lineNumber)];
+      return _wrappedLine[bufferIndex (lineNumber)];
+    }
   else
     return false;
 }
 
-void HistoryScrollBuffer::getCells(int lineNumber, int startColumn, int count, Character* buffer)
+void
+HistoryScrollBuffer::getCells (int lineNumber, int startColumn, int count,
+			       Character * buffer)
 {
-  if ( count == 0 ) return;
-
-  Q_ASSERT( lineNumber < _maxLineCount );
+  if (count == 0)
+    return;
 
-  if (lineNumber >= _usedLines) 
-  {
-    memset(buffer, 0, count * sizeof(Character));
-    return;
-  }
-  
-  const HistoryLine& line = _historyBuffer[bufferIndex(lineNumber)];
+  Q_ASSERT (lineNumber < _maxLineCount);
+
+  if (lineNumber >= _usedLines)
+    {
+      memset (buffer, 0, count * sizeof (Character));
+      return;
+    }
+
+  const HistoryLine & line = _historyBuffer[bufferIndex (lineNumber)];
 
   //kDebug() << "startCol " << startColumn;
   //kDebug() << "line.size() " << line.size();
   //kDebug() << "count " << count;
 
-  Q_ASSERT( startColumn <= line.size() - count );
-    
-  memcpy(buffer, line.constData() + startColumn , count * sizeof(Character));
+  Q_ASSERT (startColumn <= line.size () - count);
+
+  memcpy (buffer, line.constData () + startColumn,
+	  count * sizeof (Character));
 }
 
-void HistoryScrollBuffer::setMaxNbLines(unsigned int lineCount)
+void
+HistoryScrollBuffer::setMaxNbLines (unsigned int lineCount)
 {
-    HistoryLine* oldBuffer = _historyBuffer;
-    HistoryLine* newBuffer = new HistoryLine[lineCount];
-    
-    for ( int i = 0 ; i < qMin(_usedLines,(int)lineCount) ; i++ )
+  HistoryLine *oldBuffer = _historyBuffer;
+  HistoryLine *newBuffer = new HistoryLine[lineCount];
+
+  for (int i = 0; i < qMin (_usedLines, (int) lineCount); i++)
     {
-        newBuffer[i] = oldBuffer[bufferIndex(i)];
+      newBuffer[i] = oldBuffer[bufferIndex (i)];
     }
-    
-    _usedLines = qMin(_usedLines,(int)lineCount);
-    _maxLineCount = lineCount;
-    _head = ( _usedLines == _maxLineCount ) ? 0 : _usedLines-1;
+
+  _usedLines = qMin (_usedLines, (int) lineCount);
+  _maxLineCount = lineCount;
+  _head = (_usedLines == _maxLineCount) ? 0 : _usedLines - 1;
 
-    _historyBuffer = newBuffer;
-    delete[] oldBuffer;
+  _historyBuffer = newBuffer;
+  delete[]oldBuffer;
 
-    _wrappedLine.resize(lineCount);
+  _wrappedLine.resize (lineCount);
 }
 
-int HistoryScrollBuffer::bufferIndex(int lineNumber)
+int
+HistoryScrollBuffer::bufferIndex (int lineNumber)
 {
-    Q_ASSERT( lineNumber >= 0 );
-    Q_ASSERT( lineNumber < _maxLineCount );
-    Q_ASSERT( (_usedLines == _maxLineCount) || lineNumber <= _head );
+  Q_ASSERT (lineNumber >= 0);
+  Q_ASSERT (lineNumber < _maxLineCount);
+  Q_ASSERT ((_usedLines == _maxLineCount) || lineNumber <= _head);
 
-    if ( _usedLines == _maxLineCount )
+  if (_usedLines == _maxLineCount)
     {
-        return (_head+lineNumber+1) % _maxLineCount;
+      return (_head + lineNumber + 1) % _maxLineCount;
     }
-    else
-    {   
-        return lineNumber;
+  else
+    {
+      return lineNumber;
     }
 }
 
 
 // History Scroll None //////////////////////////////////////
 
-HistoryScrollNone::HistoryScrollNone()
-  : HistoryScroll(new HistoryTypeNone())
+HistoryScrollNone::HistoryScrollNone ():HistoryScroll (new HistoryTypeNone ())
 {
 }
 
-HistoryScrollNone::~HistoryScrollNone()
+HistoryScrollNone::~HistoryScrollNone ()
 {
 }
 
-bool HistoryScrollNone::hasScroll()
+bool
+HistoryScrollNone::hasScroll ()
 {
   return false;
 }
 
-int  HistoryScrollNone::getLines()
+int
+HistoryScrollNone::getLines ()
 {
   return 0;
 }
 
-int  HistoryScrollNone::getLineLen(int)
+int
+HistoryScrollNone::getLineLen (int)
 {
   return 0;
 }
 
-bool HistoryScrollNone::isWrappedLine(int /*lineno*/)
+bool
+HistoryScrollNone::isWrappedLine (int /*lineno */ )
 {
   return false;
 }
 
-void HistoryScrollNone::getCells(int, int, int, Character [])
+void
+HistoryScrollNone::getCells (int, int, int, Character[])
 {
 }
 
-void HistoryScrollNone::addCells(const Character [], int)
+void
+HistoryScrollNone::addCells (const Character[], int)
 {
 }
 
-void HistoryScrollNone::addLine(bool)
+void
+HistoryScrollNone::addLine (bool)
 {
 }
 
 // History Scroll BlockArray //////////////////////////////////////
 
-HistoryScrollBlockArray::HistoryScrollBlockArray(size_t size)
-  : HistoryScroll(new HistoryTypeBlockArray(size))
+HistoryScrollBlockArray::HistoryScrollBlockArray (size_t size):HistoryScroll (new
+	       HistoryTypeBlockArray
+	       (size))
 {
-  m_blockArray.setHistorySize(size); // nb. of lines.
+  m_blockArray.setHistorySize (size);	// nb. of lines.
 }
 
-HistoryScrollBlockArray::~HistoryScrollBlockArray()
+HistoryScrollBlockArray::~HistoryScrollBlockArray ()
 {
 }
 
-int  HistoryScrollBlockArray::getLines()
+int
+HistoryScrollBlockArray::getLines ()
 {
-  return m_lineLengths.count();
+  return m_lineLengths.count ();
 }
 
-int  HistoryScrollBlockArray::getLineLen(int lineno)
+int
+HistoryScrollBlockArray::getLineLen (int lineno)
 {
-    if ( m_lineLengths.contains(lineno) )
-        return m_lineLengths[lineno];
-    else
-        return 0;
+  if (m_lineLengths.contains (lineno))
+    return m_lineLengths[lineno];
+  else
+    return 0;
 }
 
-bool HistoryScrollBlockArray::isWrappedLine(int /*lineno*/)
+bool
+HistoryScrollBlockArray::isWrappedLine (int /*lineno */ )
 {
   return false;
 }
 
-void HistoryScrollBlockArray::getCells(int lineno, int colno,
-                                       int count, Character res[])
+void
+HistoryScrollBlockArray::getCells (int lineno, int colno,
+				   int count, Character res[])
 {
-  if (!count) return;
+  if (!count)
+    return;
 
-  const Block *b = m_blockArray.at(lineno);
+  const Block *b = m_blockArray.at (lineno);
 
-  if (!b) {
-    memset(res, 0, count * sizeof(Character)); // still better than random data
-    return;
-  }
+  if (!b)
+    {
+      memset (res, 0, count * sizeof (Character));	// still better than random data
+      return;
+    }
 
-  assert(((colno + count) * sizeof(Character)) < ENTRIES);
-  memcpy(res, b->data + (colno * sizeof(Character)), count * sizeof(Character));
+  assert (((colno + count) * sizeof (Character)) < ENTRIES);
+  memcpy (res, b->data + (colno * sizeof (Character)),
+	  count * sizeof (Character));
 }
 
-void HistoryScrollBlockArray::addCells(const Character a[], int count)
+void
+HistoryScrollBlockArray::addCells (const Character a[], int count)
 {
-  Block *b = m_blockArray.lastBlock();
-  
-  if (!b) return;
+  Block *b = m_blockArray.lastBlock ();
+
+  if (!b)
+    return;
 
   // put cells in block's data
-  assert((count * sizeof(Character)) < ENTRIES);
+  assert ((count * sizeof (Character)) < ENTRIES);
 
-  memset(b->data, 0, ENTRIES);
+  memset (b->data, 0, ENTRIES);
 
-  memcpy(b->data, a, count * sizeof(Character));
-  b->size = count * sizeof(Character);
+  memcpy (b->data, a, count * sizeof (Character));
+  b->size = count * sizeof (Character);
 
-  size_t res = m_blockArray.newBlock();
+  size_t res = m_blockArray.newBlock ();
   assert (res > 0);
-  Q_UNUSED( res );
+  Q_UNUSED (res);
 
-  m_lineLengths.insert(m_blockArray.getCurrent(), count);
+  m_lineLengths.insert (m_blockArray.getCurrent (), count);
 }
 
-void HistoryScrollBlockArray::addLine(bool)
+void
+HistoryScrollBlockArray::addLine (bool)
 {
 }
 
 //////////////////////////////////////////////////////////////////////
 // History Types
 //////////////////////////////////////////////////////////////////////
 
-HistoryType::HistoryType()
+HistoryType::HistoryType ()
 {
 }
 
-HistoryType::~HistoryType()
+HistoryType::~HistoryType ()
 {
 }
 
 //////////////////////////////
 
-HistoryTypeNone::HistoryTypeNone()
+HistoryTypeNone::HistoryTypeNone ()
 {
 }
 
-bool HistoryTypeNone::isEnabled() const
+bool
+HistoryTypeNone::isEnabled () const
 {
   return false;
 }
 
-HistoryScroll* HistoryTypeNone::scroll(HistoryScroll *old) const
+HistoryScroll *
+HistoryTypeNone::scroll (HistoryScroll * old) const
 {
   delete old;
-  return new HistoryScrollNone();
+  return new HistoryScrollNone ();
 }
 
-int HistoryTypeNone::maximumLineCount() const
+int
+HistoryTypeNone::maximumLineCount () const
 {
   return 0;
 }
 
 //////////////////////////////
 
-HistoryTypeBlockArray::HistoryTypeBlockArray(size_t size)
-  : m_size(size)
+HistoryTypeBlockArray::HistoryTypeBlockArray (size_t size):m_size (size)
 {
 }
 
-bool HistoryTypeBlockArray::isEnabled() const
+bool
+HistoryTypeBlockArray::isEnabled () const
 {
   return true;
 }
 
-int HistoryTypeBlockArray::maximumLineCount() const
+int
+HistoryTypeBlockArray::maximumLineCount () const
 {
   return m_size;
 }
 
-HistoryScroll* HistoryTypeBlockArray::scroll(HistoryScroll *old) const
+HistoryScroll *
+HistoryTypeBlockArray::scroll (HistoryScroll * old) const
 {
   delete old;
-  return new HistoryScrollBlockArray(m_size);
+  return new HistoryScrollBlockArray (m_size);
 }
 
 
 //////////////////////////////
 
-HistoryTypeBuffer::HistoryTypeBuffer(unsigned int nbLines)
-  : m_nbLines(nbLines)
+HistoryTypeBuffer::HistoryTypeBuffer (unsigned int nbLines):m_nbLines (nbLines)
 {
 }
 
-bool HistoryTypeBuffer::isEnabled() const
+bool
+HistoryTypeBuffer::isEnabled () const
 {
   return true;
 }
 
-int HistoryTypeBuffer::maximumLineCount() const
+int
+HistoryTypeBuffer::maximumLineCount () const
 {
   return m_nbLines;
 }
 
-HistoryScroll* HistoryTypeBuffer::scroll(HistoryScroll *old) const
+HistoryScroll *
+HistoryTypeBuffer::scroll (HistoryScroll * old) const
 {
   if (old)
-  {
-    HistoryScrollBuffer *oldBuffer = dynamic_cast<HistoryScrollBuffer*>(old);
-    if (oldBuffer)
     {
-       oldBuffer->setMaxNbLines(m_nbLines);
-       return oldBuffer;
-    }
+      HistoryScrollBuffer *oldBuffer =
+	dynamic_cast < HistoryScrollBuffer * >(old);
+      if (oldBuffer)
+	{
+	  oldBuffer->setMaxNbLines (m_nbLines);
+	  return oldBuffer;
+	}
 
-    HistoryScroll *newScroll = new HistoryScrollBuffer(m_nbLines);
-    int lines = old->getLines();
-    int startLine = 0;
-    if (lines > (int) m_nbLines)
-       startLine = lines - m_nbLines;
+      HistoryScroll *newScroll = new HistoryScrollBuffer (m_nbLines);
+      int lines = old->getLines ();
+      int startLine = 0;
+      if (lines > (int) m_nbLines)
+	startLine = lines - m_nbLines;
 
-    Character line[LINE_SIZE];
-    for(int i = startLine; i < lines; i++)
-    {
-       int size = old->getLineLen(i);
-       if (size > LINE_SIZE)
-       {
-          Character *tmp_line = new Character[size];
-          old->getCells(i, 0, size, tmp_line);
-          newScroll->addCells(tmp_line, size);
-          newScroll->addLine(old->isWrappedLine(i));
-          delete [] tmp_line;
-       }
-       else
-       {
-          old->getCells(i, 0, size, line);
-          newScroll->addCells(line, size);
-          newScroll->addLine(old->isWrappedLine(i));
-       }
+      Character line[LINE_SIZE];
+      for (int i = startLine; i < lines; i++)
+	{
+	  int size = old->getLineLen (i);
+	  if (size > LINE_SIZE)
+	    {
+	      Character *tmp_line = new Character[size];
+	      old->getCells (i, 0, size, tmp_line);
+	      newScroll->addCells (tmp_line, size);
+	      newScroll->addLine (old->isWrappedLine (i));
+	      delete[]tmp_line;
+	    }
+	  else
+	    {
+	      old->getCells (i, 0, size, line);
+	      newScroll->addCells (line, size);
+	      newScroll->addLine (old->isWrappedLine (i));
+	    }
+	}
+      delete old;
+      return newScroll;
     }
-    delete old;
-    return newScroll;
-  }
-  return new HistoryScrollBuffer(m_nbLines);
+  return new HistoryScrollBuffer (m_nbLines);
 }
 
 //////////////////////////////
 
-HistoryTypeFile::HistoryTypeFile(const QString& fileName)
-  : m_fileName(fileName)
+HistoryTypeFile::HistoryTypeFile (const QString & fileName):m_fileName
+  (fileName)
 {
 }
 
-bool HistoryTypeFile::isEnabled() const
+bool
+HistoryTypeFile::isEnabled () const
 {
   return true;
 }
 
-const QString& HistoryTypeFile::getFileName() const
+const QString &
+HistoryTypeFile::getFileName () const
 {
   return m_fileName;
 }
 
-HistoryScroll* HistoryTypeFile::scroll(HistoryScroll *old) const
+HistoryScroll *
+HistoryTypeFile::scroll (HistoryScroll * old) const
 {
-  if (dynamic_cast<HistoryFile *>(old)) 
-     return old; // Unchanged.
+  if (dynamic_cast < HistoryFile * >(old))
+    return old;			// Unchanged.
 
-  HistoryScroll *newScroll = new HistoryScrollFile(m_fileName);
+  HistoryScroll *newScroll = new HistoryScrollFile (m_fileName);
 
   Character line[LINE_SIZE];
-  int lines = (old != 0) ? old->getLines() : 0;
-  for(int i = 0; i < lines; i++)
-  {
-     int size = old->getLineLen(i);
-     if (size > LINE_SIZE)
-     {
-        Character *tmp_line = new Character[size];
-        old->getCells(i, 0, size, tmp_line);
-        newScroll->addCells(tmp_line, size);
-        newScroll->addLine(old->isWrappedLine(i));
-        delete [] tmp_line;
-     }
-     else
-     {
-        old->getCells(i, 0, size, line);
-        newScroll->addCells(line, size);
-        newScroll->addLine(old->isWrappedLine(i));
-     }
-  }
+  int lines = (old != 0) ? old->getLines () : 0;
+  for (int i = 0; i < lines; i++)
+    {
+      int size = old->getLineLen (i);
+      if (size > LINE_SIZE)
+	{
+	  Character *tmp_line = new Character[size];
+	  old->getCells (i, 0, size, tmp_line);
+	  newScroll->addCells (tmp_line, size);
+	  newScroll->addLine (old->isWrappedLine (i));
+	  delete[]tmp_line;
+	}
+      else
+	{
+	  old->getCells (i, 0, size, line);
+	  newScroll->addCells (line, size);
+	  newScroll->addLine (old->isWrappedLine (i));
+	}
+    }
 
   delete old;
-  return newScroll; 
+  return newScroll;
 }
 
-int HistoryTypeFile::maximumLineCount() const
+int
+HistoryTypeFile::maximumLineCount () const
 {
   return 0;
 }
diff --git a/gui/src/terminal/History.h b/gui/src/terminal/History.h
--- a/gui/src/terminal/History.h
+++ b/gui/src/terminal/History.h
@@ -30,39 +30,39 @@
 
 // Konsole
 #include "BlockArray.h"
 #include "Character.h"
 
 class HistoryFile
 {
 public:
-  HistoryFile();
-  virtual ~HistoryFile();
+  HistoryFile ();
+  virtual ~ HistoryFile ();
 
-  virtual void add(const unsigned char* bytes, int len);
-  virtual void get(unsigned char* bytes, int len, int loc);
-  virtual int  len();
+  virtual void add (const unsigned char *bytes, int len);
+  virtual void get (unsigned char *bytes, int len, int loc);
+  virtual int len ();
 
   //mmaps the file in read-only mode
-  void map();
+  void map ();
   //un-mmaps the file
-  void unmap();
+  void unmap ();
   //returns true if the file is mmap'ed
-  bool isMapped();
+  bool isMapped ();
 
 
 private:
-  int  ion;
-  int  length;
+  int ion;
+  int length;
   QTemporaryFile tmpFile;
 
   //pointer to start of mmap'ed file data, or 0 if the file is not mmap'ed
-  char* fileMap;
- 
+  char *fileMap;
+
   //incremented whenver 'add' is called and decremented whenever
   //'get' is called.
   //this is used to detect when a large number of lines are being read and processed from the history
   //and automatically mmap the file for better performance (saves the overhead of many lseek-read calls).
   int readWriteBalance;
 
   //when readWriteBalance goes below this threshold, the file will be mmap'ed automatically
   static const int MAP_THRESHOLD = -1000;
@@ -73,235 +73,250 @@ private:
 //////////////////////////////////////////////////////////////////////
 // Abstract base class for file and buffer versions
 //////////////////////////////////////////////////////////////////////
 class HistoryType;
 
 class HistoryScroll
 {
 public:
-  HistoryScroll(HistoryType*);
- virtual ~HistoryScroll();
+  HistoryScroll (HistoryType *);
+  virtual ~ HistoryScroll ();
 
-  virtual bool hasScroll();
+  virtual bool hasScroll ();
 
   // access to history
-  virtual int  getLines() = 0;
-  virtual int  getLineLen(int lineno) = 0;
-  virtual void getCells(int lineno, int colno, int count, Character res[]) = 0;
-  virtual bool isWrappedLine(int lineno) = 0;
+  virtual int getLines () = 0;
+  virtual int getLineLen (int lineno) = 0;
+  virtual void getCells (int lineno, int colno, int count, Character res[]) =
+    0;
+  virtual bool isWrappedLine (int lineno) = 0;
 
   // backward compatibility (obsolete)
-  Character   getCell(int lineno, int colno) { Character res; getCells(lineno,colno,1,&res); return res; }
+  Character getCell (int lineno, int colno)
+  {
+    Character res;
+      getCells (lineno, colno, 1, &res);
+      return res;
+  }
 
   // adding lines.
-  virtual void addCells(const Character a[], int count) = 0;
+  virtual void addCells (const Character a[], int count) = 0;
   // convenience method - this is virtual so that subclasses can take advantage
   // of QVector's implicit copying
-  virtual void addCellsVector(const QVector<Character>& cells)
+  virtual void addCellsVector (const QVector < Character > &cells)
   {
-    addCells(cells.data(),cells.size());
+    addCells (cells.data (), cells.size ());
   }
 
-  virtual void addLine(bool previousWrapped=false) = 0;
+  virtual void addLine (bool previousWrapped = false) = 0;
 
   //
   // FIXME:  Passing around constant references to HistoryType instances
   // is very unsafe, because those references will no longer
   // be valid if the history scroll is deleted.
   //
-  const HistoryType& getType() { return *m_histType; }
+  const HistoryType & getType ()
+  {
+    return *m_histType;
+  }
 
 protected:
-  HistoryType* m_histType;
+  HistoryType * m_histType;
 
 };
 
 
 
 //////////////////////////////////////////////////////////////////////
 // File-based history (e.g. file log, no limitation in length)
 //////////////////////////////////////////////////////////////////////
 
-class HistoryScrollFile : public HistoryScroll
+class HistoryScrollFile:public HistoryScroll
 {
 public:
-  HistoryScrollFile(const QString &logFileName);
-  virtual ~HistoryScrollFile();
+  HistoryScrollFile (const QString & logFileName);
+  virtual ~ HistoryScrollFile ();
 
-  virtual int  getLines();
-  virtual int  getLineLen(int lineno);
-  virtual void getCells(int lineno, int colno, int count, Character res[]);
-  virtual bool isWrappedLine(int lineno);
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
 
-  virtual void addCells(const Character a[], int count);
-  virtual void addLine(bool previousWrapped=false);
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
 
 private:
-  int startOfLine(int lineno);
+  int startOfLine (int lineno);
 
   QString m_logFileName;
-  HistoryFile index; // lines Row(int)
-  HistoryFile cells; // text  Row(Character)
-  HistoryFile lineflags; // flags Row(unsigned char)
+  HistoryFile index;		// lines Row(int)
+  HistoryFile cells;		// text  Row(Character)
+  HistoryFile lineflags;	// flags Row(unsigned char)
 };
 
 
 //////////////////////////////////////////////////////////////////////
 // Buffer-based history (limited to a fixed nb of lines)
 //////////////////////////////////////////////////////////////////////
-class HistoryScrollBuffer : public HistoryScroll
+class HistoryScrollBuffer:public HistoryScroll
 {
 public:
-  typedef QVector<Character> HistoryLine;
+  typedef QVector < Character > HistoryLine;
+
+    HistoryScrollBuffer (unsigned int maxNbLines = 1000);
+    virtual ~ HistoryScrollBuffer ();
 
-  HistoryScrollBuffer(unsigned int maxNbLines = 1000);
-  virtual ~HistoryScrollBuffer();
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
 
-  virtual int  getLines();
-  virtual int  getLineLen(int lineno);
-  virtual void getCells(int lineno, int colno, int count, Character res[]);
-  virtual bool isWrappedLine(int lineno);
+  virtual void addCells (const Character a[], int count);
+  virtual void addCellsVector (const QVector < Character > &cells);
+  virtual void addLine (bool previousWrapped = false);
 
-  virtual void addCells(const Character a[], int count);
-  virtual void addCellsVector(const QVector<Character>& cells);
-  virtual void addLine(bool previousWrapped=false);
+  void setMaxNbLines (unsigned int nbLines);
+  unsigned int maxNbLines ()
+  {
+    return _maxLineCount;
+  }
 
-  void setMaxNbLines(unsigned int nbLines);
-  unsigned int maxNbLines() { return _maxLineCount; }
-  
 
 private:
-  int bufferIndex(int lineNumber);
+  int bufferIndex (int lineNumber);
 
-  HistoryLine* _historyBuffer;
+  HistoryLine *_historyBuffer;
   QBitArray _wrappedLine;
   int _maxLineCount;
-  int _usedLines;  
+  int _usedLines;
   int _head;
 };
 
 //////////////////////////////////////////////////////////////////////
 // Nothing-based history (no history :-)
 //////////////////////////////////////////////////////////////////////
-class HistoryScrollNone : public HistoryScroll
+class HistoryScrollNone:public HistoryScroll
 {
 public:
-  HistoryScrollNone();
-  virtual ~HistoryScrollNone();
+  HistoryScrollNone ();
+  virtual ~ HistoryScrollNone ();
 
-  virtual bool hasScroll();
+  virtual bool hasScroll ();
 
-  virtual int  getLines();
-  virtual int  getLineLen(int lineno);
-  virtual void getCells(int lineno, int colno, int count, Character res[]);
-  virtual bool isWrappedLine(int lineno);
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
 
-  virtual void addCells(const Character a[], int count);
-  virtual void addLine(bool previousWrapped=false);
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
 };
 
 //////////////////////////////////////////////////////////////////////
 // BlockArray-based history
 //////////////////////////////////////////////////////////////////////
-class HistoryScrollBlockArray : public HistoryScroll
+class HistoryScrollBlockArray:public HistoryScroll
 {
 public:
-  HistoryScrollBlockArray(size_t size);
-  virtual ~HistoryScrollBlockArray();
+  HistoryScrollBlockArray (size_t size);
+  virtual ~ HistoryScrollBlockArray ();
 
-  virtual int  getLines();
-  virtual int  getLineLen(int lineno);
-  virtual void getCells(int lineno, int colno, int count, Character res[]);
-  virtual bool isWrappedLine(int lineno);
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
 
-  virtual void addCells(const Character a[], int count);
-  virtual void addLine(bool previousWrapped=false);
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
 
 protected:
-  BlockArray m_blockArray;
-  QHash<int,size_t> m_lineLengths;
+    BlockArray m_blockArray;
+    QHash < int, size_t > m_lineLengths;
 };
 
 //////////////////////////////////////////////////////////////////////
 // History type
 //////////////////////////////////////////////////////////////////////
 
 class HistoryType
 {
 public:
-  HistoryType();
-  virtual ~HistoryType();
+  HistoryType ();
+  virtual ~ HistoryType ();
 
   /**
    * Returns true if the history is enabled ( can store lines of output )
    * or false otherwise. 
    */
-  virtual bool isEnabled()           const = 0;
+  virtual bool isEnabled () const = 0;
   /**
    * Returns true if the history size is unlimited.
    */
-  bool isUnlimited() const { return maximumLineCount() == 0; }
+  bool isUnlimited () const
+  {
+    return maximumLineCount () == 0;
+  }
   /**
    * Returns the maximum number of lines which this history type
    * can store or 0 if the history can store an unlimited number of lines.
    */
-  virtual int maximumLineCount()    const = 0;
+  virtual int maximumLineCount () const = 0;
 
-  virtual HistoryScroll* scroll(HistoryScroll *) const = 0;
+  virtual HistoryScroll *scroll (HistoryScroll *) const = 0;
 };
 
-class HistoryTypeNone : public HistoryType
+class HistoryTypeNone:public HistoryType
 {
 public:
-  HistoryTypeNone();
+  HistoryTypeNone ();
 
-  virtual bool isEnabled() const;
-  virtual int maximumLineCount() const;
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
 
-  virtual HistoryScroll* scroll(HistoryScroll *) const;
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
 };
 
-class HistoryTypeBlockArray : public HistoryType
+class HistoryTypeBlockArray:public HistoryType
 {
 public:
-  HistoryTypeBlockArray(size_t size);
-  
-  virtual bool isEnabled() const;
-  virtual int maximumLineCount() const;
+  HistoryTypeBlockArray (size_t size);
 
-  virtual HistoryScroll* scroll(HistoryScroll *) const;
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
 
 protected:
-  size_t m_size;
+    size_t m_size;
 };
 
-class HistoryTypeFile : public HistoryType
+class HistoryTypeFile:public HistoryType
 {
 public:
-  HistoryTypeFile(const QString& fileName=QString());
+  HistoryTypeFile (const QString & fileName = QString ());
 
-  virtual bool isEnabled() const;
-  virtual const QString& getFileName() const;
-  virtual int maximumLineCount() const;
+  virtual bool isEnabled () const;
+  virtual const QString & getFileName () const;
+  virtual int maximumLineCount () const;
 
-  virtual HistoryScroll* scroll(HistoryScroll *) const;
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
 
 protected:
-  QString m_fileName;
+    QString m_fileName;
 };
 
 
-class HistoryTypeBuffer : public HistoryType
+class HistoryTypeBuffer:public HistoryType
 {
 public:
-  HistoryTypeBuffer(unsigned int nbLines);
-  
-  virtual bool isEnabled() const;
-  virtual int maximumLineCount() const;
+  HistoryTypeBuffer (unsigned int nbLines);
 
-  virtual HistoryScroll* scroll(HistoryScroll *) const;
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
 
 protected:
   unsigned int m_nbLines;
 };
 
 #endif // HISTORY_H
diff --git a/gui/src/terminal/KeyboardTranslator.cpp b/gui/src/terminal/KeyboardTranslator.cpp
--- a/gui/src/terminal/KeyboardTranslator.cpp
+++ b/gui/src/terminal/KeyboardTranslator.cpp
@@ -32,186 +32,201 @@
 #include <QtCore/QFileInfo>
 #include <QtCore/QTextStream>
 #include <QtGui/QKeySequence>
 #include <QtCore/QDir>
 #include <QtCore/QStringList>
 #include <QtCore/QDebug>
 #include <QtCore/QDataStream>
 
-const QByteArray KeyboardTranslatorManager::defaultTranslatorText(
-"keyboard \"Fallback Key Translator\"\n"
-"key Tab : \"\\t\""
-);
+const QByteArray
+KeyboardTranslatorManager::
 
-KeyboardTranslatorManager::KeyboardTranslatorManager()
-    : _haveLoadedAll(false)
+defaultTranslatorText ("keyboard \"Fallback Key Translator\"\n"
+		       "key Tab : \"\\t\"");
+
+KeyboardTranslatorManager::KeyboardTranslatorManager ():_haveLoadedAll (false)
 {
 }
-KeyboardTranslatorManager::~KeyboardTranslatorManager()
+
+KeyboardTranslatorManager::~KeyboardTranslatorManager ()
 {
-    qDeleteAll(_translators);
+  qDeleteAll (_translators);
 }
 
-QString KeyboardTranslatorManager::findTranslatorPath(const QString& name)
+QString
+KeyboardTranslatorManager::findTranslatorPath (const QString & name)
 {
-    QString translatorFile = QString("../kb-layouts/" + name + ".keytab");
-    if(QFile::exists(translatorFile))
-        return translatorFile;
-    return QString("/usr/share/octave/quint/kb-layouts/" + name + ".keytab");
+  QString translatorFile = QString ("../kb-layouts/" + name + ".keytab");
+  if (QFile::exists (translatorFile))
+    return translatorFile;
+  return QString ("/usr/share/octave/quint/kb-layouts/" + name + ".keytab");
 }
 
-void KeyboardTranslatorManager::findTranslators()
+void
+KeyboardTranslatorManager::findTranslators ()
 {
   //QStringList list = KGlobal::dirs()->findAllResources("data",
   //                                                     "konsole/*.keytab",
   //                                                     KStandardDirs::NoDuplicates);
 
-    QDir dir("../kb-layouts/");
-    QStringList filters;
-    filters << "*.keytab";
-    dir.setNameFilters(filters);
-    QStringList list = dir.entryList(filters);
+  QDir dir ("../kb-layouts/");
+  QStringList filters;
+  filters << "*.keytab";
+  dir.setNameFilters (filters);
+  QStringList list = dir.entryList (filters);
 
-    // add the name of each translator to the list and associated
-    // the name with a null pointer to indicate that the translator
-    // has not yet been loaded from disk
-    QStringListIterator listIter(list);
-    while (listIter.hasNext())
+  // add the name of each translator to the list and associated
+  // the name with a null pointer to indicate that the translator
+  // has not yet been loaded from disk
+  QStringListIterator listIter (list);
+  while (listIter.hasNext ())
     {
-        QString translatorPath = listIter.next();
+      QString translatorPath = listIter.next ();
 
-        QString name = QFileInfo(translatorPath).baseName();
-       
-        if ( !_translators.contains(name) ) 
-            _translators.insert(name,0);
+      QString name = QFileInfo (translatorPath).baseName ();
+
+      if (!_translators.contains (name))
+	_translators.insert (name, 0);
     }
 
-    _haveLoadedAll = true;
+  _haveLoadedAll = true;
 }
 
-const KeyboardTranslator* KeyboardTranslatorManager::findTranslator(const QString& name)
+const KeyboardTranslator *
+KeyboardTranslatorManager::findTranslator (const QString & name)
 {
-    if ( name.isEmpty() )
-        return defaultTranslator();
+  if (name.isEmpty ())
+    return defaultTranslator ();
 
-    if ( _translators.contains(name) && _translators[name] != 0 )
-        return _translators[name];
+  if (_translators.contains (name) && _translators[name] != 0)
+    return _translators[name];
 
-    KeyboardTranslator* translator = loadTranslator(name);
+  KeyboardTranslator *translator = loadTranslator (name);
 
-    if ( translator != 0 )
-        _translators[name] = translator;
-    //else if ( !name.isEmpty() )
-    //  kWarning() << "Unable to load translator" << name;
+  if (translator != 0)
+    _translators[name] = translator;
+  //else if ( !name.isEmpty() )
+  //  kWarning() << "Unable to load translator" << name;
 
-    return translator;
+  return translator;
 }
 
-bool KeyboardTranslatorManager::saveTranslator(const KeyboardTranslator* translator)
+bool
+KeyboardTranslatorManager::saveTranslator (const KeyboardTranslator *
+					   translator)
 {
   //const QString path = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
   //         +".keytab";
   const QString path = ".keytab";
 
-    //kDebug() << "Saving translator to" << path;
+  //kDebug() << "Saving translator to" << path;
 
-    QFile destination(path);
-    if (!destination.open(QIODevice::WriteOnly | QIODevice::Text))
+  QFile destination (path);
+  if (!destination.open (QIODevice::WriteOnly | QIODevice::Text))
     {
-        //kWarning() << "Unable to save keyboard translation:"
-         //          << destination.errorString();
-        return false;
+      //kWarning() << "Unable to save keyboard translation:"
+      //          << destination.errorString();
+      return false;
     }
 
-    {
-        KeyboardTranslatorWriter writer(&destination);
-        writer.writeHeader(translator->description());
-    
-        QListIterator<KeyboardTranslator::Entry> iter(translator->entries());
-        while ( iter.hasNext() )
-            writer.writeEntry(iter.next());
-    }
+  {
+    KeyboardTranslatorWriter writer (&destination);
+    writer.writeHeader (translator->description ());
+
+    QListIterator < KeyboardTranslator::Entry > iter (translator->entries ());
+    while (iter.hasNext ())
+      writer.writeEntry (iter.next ());
+  }
+
+  destination.close ();
 
-    destination.close();
+  return true;
+}
 
-    return true;
+KeyboardTranslator *
+KeyboardTranslatorManager::loadTranslator (const QString & name)
+{
+  const QString & path = findTranslatorPath (name);
+
+  QFile source (path);
+  if (name.isEmpty () || !source.open (QIODevice::ReadOnly | QIODevice::Text))
+    return 0;
+
+  return loadTranslator (&source, name);
 }
 
-KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(const QString& name)
+const KeyboardTranslator *
+KeyboardTranslatorManager::defaultTranslator ()
 {
-    const QString& path = findTranslatorPath(name);
-
-    QFile source(path); 
-    if (name.isEmpty() || !source.open(QIODevice::ReadOnly | QIODevice::Text))
-        return 0;
-
-    return loadTranslator(&source,name);
+  // Try to find the default.keytab file if it exists, otherwise
+  // fall back to the hard-coded one
+  const KeyboardTranslator *translator = findTranslator ("default");
+  if (!translator)
+    {
+      QBuffer textBuffer;
+      textBuffer.setData (defaultTranslatorText);
+      textBuffer.open (QIODevice::ReadOnly);
+      translator = loadTranslator (&textBuffer, "fallback");
+    }
+  return translator;
 }
 
-const KeyboardTranslator* KeyboardTranslatorManager::defaultTranslator()
-{
-    // Try to find the default.keytab file if it exists, otherwise
-    // fall back to the hard-coded one
-    const KeyboardTranslator* translator = findTranslator("default");
-    if (!translator)
-    {
-        QBuffer textBuffer;
-        textBuffer.setData(defaultTranslatorText);
-        textBuffer.open(QIODevice::ReadOnly);
-        translator = loadTranslator(&textBuffer,"fallback");
-    }
-    return translator;
-}
-
-KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(QIODevice* source,const QString& name)
+KeyboardTranslator *
+KeyboardTranslatorManager::loadTranslator (QIODevice * source,
+					   const QString & name)
 {
-    KeyboardTranslator* translator = new KeyboardTranslator(name);
-    KeyboardTranslatorReader reader(source);
-    translator->setDescription( reader.description() );
-    while ( reader.hasNextEntry() )
-        translator->addEntry(reader.nextEntry());
+  KeyboardTranslator *translator = new KeyboardTranslator (name);
+  KeyboardTranslatorReader reader (source);
+  translator->setDescription (reader.description ());
+  while (reader.hasNextEntry ())
+    translator->addEntry (reader.nextEntry ());
 
-    source->close();
+  source->close ();
 
-    if ( !reader.parseError() )
+  if (!reader.parseError ())
     {
-        return translator;
+      return translator;
     }
-    else
+  else
     {
-        delete translator;
-        return 0;
+      delete translator;
+      return 0;
     }
 }
 
-KeyboardTranslatorWriter::KeyboardTranslatorWriter(QIODevice* destination)
-: _destination(destination)
+KeyboardTranslatorWriter::KeyboardTranslatorWriter (QIODevice * destination):_destination
+  (destination)
 {
-    Q_ASSERT( destination && destination->isWritable() );
+  Q_ASSERT (destination && destination->isWritable ());
 
-    _writer = new QTextStream(_destination);
+  _writer = new QTextStream (_destination);
 }
-KeyboardTranslatorWriter::~KeyboardTranslatorWriter()
+
+KeyboardTranslatorWriter::~KeyboardTranslatorWriter ()
 {
-    delete _writer;
+  delete _writer;
 }
-void KeyboardTranslatorWriter::writeHeader( const QString& description )
-{
-    *_writer << "keyboard \"" << description << '\"' << '\n';
-}
-void KeyboardTranslatorWriter::writeEntry( const KeyboardTranslator::Entry& entry )
+
+void
+KeyboardTranslatorWriter::writeHeader (const QString & description)
 {
-    QString result;
-    if ( entry.command() != KeyboardTranslator::NoCommand )
-        result = entry.resultToString();
-    else
-        result = '\"' + entry.resultToString() + '\"';
+  *_writer << "keyboard \"" << description << '\"' << '\n';
+}
 
-    *_writer << "key " << entry.conditionToString() << " : " << result << '\n';
+void
+KeyboardTranslatorWriter::writeEntry (const KeyboardTranslator::Entry & entry)
+{
+  QString result;
+  if (entry.command () != KeyboardTranslator::NoCommand)
+    result = entry.resultToString ();
+  else
+    result = '\"' + entry.resultToString () + '\"';
+
+  *_writer << "key " << entry.conditionToString () << " : " << result << '\n';
 }
 
 
 // each line of the keyboard translation file is one of:
 //
 // - keyboard "name"
 // - key KeySequence : "characters"
 // - key KeySequence : CommandName
@@ -224,701 +239,803 @@ void KeyboardTranslatorWriter::writeEntr
 //
 // eg:  "key Up+Shift : scrollLineUp"
 //      "key Next-Shift : "\E[6~"
 //
 // (lines containing only whitespace are ignored, parseLine assumes that comments have
 // already been removed)
 //
 
-KeyboardTranslatorReader::KeyboardTranslatorReader( QIODevice* source )
-    : _source(source)
-    , _hasNext(false)
+KeyboardTranslatorReader::KeyboardTranslatorReader (QIODevice * source):_source (source),
+_hasNext
+(false)
 {
-   // read input until we find the description
-   while ( _description.isEmpty() && !source->atEnd() )
-   {
-        QList<Token> tokens = tokenize( QString(source->readLine()) );
-        if ( !tokens.isEmpty() && tokens.first().type == Token::TitleKeyword )
-            _description = QString(tokens[1].text.toLatin1().data());
-   }
-   // read first entry (if any)
-   readNext();
+  // read input until we find the description
+  while (_description.isEmpty () && !source->atEnd ())
+    {
+      QList < Token > tokens = tokenize (QString (source->readLine ()));
+      if (!tokens.isEmpty () && tokens.first ().type == Token::TitleKeyword)
+	_description = QString (tokens[1].text.toLatin1 ().data ());
+    }
+  // read first entry (if any)
+  readNext ();
 }
-void KeyboardTranslatorReader::readNext() 
+
+void
+KeyboardTranslatorReader::readNext ()
 {
-    // find next entry
-    while ( !_source->atEnd() )
+  // find next entry
+  while (!_source->atEnd ())
     {
-        const QList<Token>& tokens = tokenize( QString(_source->readLine()) );
-        if ( !tokens.isEmpty() && tokens.first().type == Token::KeyKeyword )
-        {
-            KeyboardTranslator::States flags = KeyboardTranslator::NoState;
-            KeyboardTranslator::States flagMask = KeyboardTranslator::NoState;
-            Qt::KeyboardModifiers modifiers = Qt::NoModifier;
-            Qt::KeyboardModifiers modifierMask = Qt::NoModifier;
+      const QList < Token > &tokens =
+	tokenize (QString (_source->readLine ()));
+      if (!tokens.isEmpty () && tokens.first ().type == Token::KeyKeyword)
+	{
+	  KeyboardTranslator::States flags = KeyboardTranslator::NoState;
+	  KeyboardTranslator::States flagMask = KeyboardTranslator::NoState;
+	  Qt::KeyboardModifiers modifiers = Qt::NoModifier;
+	  Qt::KeyboardModifiers modifierMask = Qt::NoModifier;
 
-            int keyCode = Qt::Key_unknown;
+	  int keyCode = Qt::Key_unknown;
 
-            decodeSequence(tokens[1].text.toLower(),
-                           keyCode,
-                           modifiers,
-                           modifierMask,
-                           flags,
-                           flagMask); 
+	  decodeSequence (tokens[1].text.toLower (),
+			  keyCode, modifiers, modifierMask, flags, flagMask);
+
+	  KeyboardTranslator::Command command = KeyboardTranslator::NoCommand;
+	  QByteArray text;
 
-            KeyboardTranslator::Command command = KeyboardTranslator::NoCommand;
-            QByteArray text;
+	  // get text or command
+	  if (tokens[2].type == Token::OutputText)
+	    {
+	      text = tokens[2].text.toLocal8Bit ();
+	    }
+	  else if (tokens[2].type == Token::Command)
+	    {
+	      // identify command
+	      // if (!parseAsCommand(tokens[2].text,command))
+	      //  kWarning() << "Command" << tokens[2].text << "not understood.";
+	    }
 
-            // get text or command
-            if ( tokens[2].type == Token::OutputText )
-            {
-                text = tokens[2].text.toLocal8Bit();
-            }
-            else if ( tokens[2].type == Token::Command )
-            {
-                // identify command
-               // if (!parseAsCommand(tokens[2].text,command))
-                //  kWarning() << "Command" << tokens[2].text << "not understood.";
-            }
+	  KeyboardTranslator::Entry newEntry;
+	  newEntry.setKeyCode (keyCode);
+	  newEntry.setState (flags);
+	  newEntry.setStateMask (flagMask);
+	  newEntry.setModifiers (modifiers);
+	  newEntry.setModifierMask (modifierMask);
+	  newEntry.setText (text);
+	  newEntry.setCommand (command);
 
-            KeyboardTranslator::Entry newEntry;
-            newEntry.setKeyCode( keyCode );
-            newEntry.setState( flags );
-            newEntry.setStateMask( flagMask );
-            newEntry.setModifiers( modifiers );
-            newEntry.setModifierMask( modifierMask );
-            newEntry.setText( text );
-            newEntry.setCommand( command );
+	  _nextEntry = newEntry;
+
+	  _hasNext = true;
 
-            _nextEntry = newEntry;
-
-            _hasNext = true;
+	  return;
+	}
+    }
 
-            return;
-        }
-    } 
-
-    _hasNext = false;
+  _hasNext = false;
 }
 
-bool KeyboardTranslatorReader::parseAsCommand(const QString& text,KeyboardTranslator::Command& command) 
+bool
+KeyboardTranslatorReader::parseAsCommand (const QString & text,
+					  KeyboardTranslator::
+					  Command & command)
 {
-    if ( text.compare("erase",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::EraseCommand;
-    else if ( text.compare("scrollpageup",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::ScrollPageUpCommand;
-    else if ( text.compare("scrollpagedown",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::ScrollPageDownCommand;
-    else if ( text.compare("scrolllineup",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::ScrollLineUpCommand;
-    else if ( text.compare("scrolllinedown",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::ScrollLineDownCommand;
-    else if ( text.compare("scrolllock",Qt::CaseInsensitive) == 0 )
-        command = KeyboardTranslator::ScrollLockCommand;
-    else
-        return false;
+  if (text.compare ("erase", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::EraseCommand;
+  else if (text.compare ("scrollpageup", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollPageUpCommand;
+  else if (text.compare ("scrollpagedown", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollPageDownCommand;
+  else if (text.compare ("scrolllineup", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLineUpCommand;
+  else if (text.compare ("scrolllinedown", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLineDownCommand;
+  else if (text.compare ("scrolllock", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLockCommand;
+  else
+    return false;
 
-    return true;
+  return true;
 }
 
-bool KeyboardTranslatorReader::decodeSequence(const QString& text,
-                                              int& keyCode,
-                                              Qt::KeyboardModifiers& modifiers,
-                                              Qt::KeyboardModifiers& modifierMask,
-                                              KeyboardTranslator::States& flags,
-                                              KeyboardTranslator::States& flagMask)
+bool
+KeyboardTranslatorReader::decodeSequence (const QString & text,
+					  int &keyCode,
+					  Qt::KeyboardModifiers & modifiers,
+					  Qt::
+					  KeyboardModifiers & modifierMask,
+					  KeyboardTranslator::States & flags,
+					  KeyboardTranslator::
+					  States & flagMask)
 {
-    bool isWanted = true; 
-    bool endOfItem = false;
-    QString buffer;
+  bool isWanted = true;
+  bool endOfItem = false;
+  QString buffer;
 
-    Qt::KeyboardModifiers tempModifiers = modifiers;
-    Qt::KeyboardModifiers tempModifierMask = modifierMask;
-    KeyboardTranslator::States tempFlags = flags;
-    KeyboardTranslator::States tempFlagMask = flagMask;
+  Qt::KeyboardModifiers tempModifiers = modifiers;
+  Qt::KeyboardModifiers tempModifierMask = modifierMask;
+  KeyboardTranslator::States tempFlags = flags;
+  KeyboardTranslator::States tempFlagMask = flagMask;
 
-    for ( int i = 0 ; i < text.count() ; i++ )
+  for (int i = 0; i < text.count (); i++)
     {
-        const QChar& ch = text[i];
-        bool isFirstLetter = i == 0;
-        bool isLastLetter = ( i == text.count()-1 );
-        endOfItem = true;
-        if ( ch.isLetterOrNumber() )
-        {
-            endOfItem = false;
-            buffer.append(ch);
-        } else if ( isFirstLetter )
-        {
-            buffer.append(ch);
-        }
-
-        if ( (endOfItem || isLastLetter) && !buffer.isEmpty() )
-        {
-            Qt::KeyboardModifier itemModifier = Qt::NoModifier;
-            int itemKeyCode = 0;
-            KeyboardTranslator::State itemFlag = KeyboardTranslator::NoState;
+      const QChar & ch = text[i];
+      bool isFirstLetter = i == 0;
+      bool isLastLetter = (i == text.count () - 1);
+      endOfItem = true;
+      if (ch.isLetterOrNumber ())
+	{
+	  endOfItem = false;
+	  buffer.append (ch);
+	}
+      else if (isFirstLetter)
+	{
+	  buffer.append (ch);
+	}
 
-            if ( parseAsModifier(buffer,itemModifier) )
-            {
-                tempModifierMask |= itemModifier;
+      if ((endOfItem || isLastLetter) && !buffer.isEmpty ())
+	{
+	  Qt::KeyboardModifier itemModifier = Qt::NoModifier;
+	  int itemKeyCode = 0;
+	  KeyboardTranslator::State itemFlag = KeyboardTranslator::NoState;
 
-                if ( isWanted )
-                    tempModifiers |= itemModifier;
-            }
-            else if ( parseAsStateFlag(buffer,itemFlag) )
-            {
-                tempFlagMask |= itemFlag;
+	  if (parseAsModifier (buffer, itemModifier))
+	    {
+	      tempModifierMask |= itemModifier;
+
+	      if (isWanted)
+		tempModifiers |= itemModifier;
+	    }
+	  else if (parseAsStateFlag (buffer, itemFlag))
+	    {
+	      tempFlagMask |= itemFlag;
 
-                if ( isWanted )
-                    tempFlags |= itemFlag;
-            }
-            else if ( parseAsKeyCode(buffer,itemKeyCode) )
-                keyCode = itemKeyCode;
-            //else
-          //      kWarning() << "Unable to parse key binding item:" << buffer;
+	      if (isWanted)
+		tempFlags |= itemFlag;
+	    }
+	  else if (parseAsKeyCode (buffer, itemKeyCode))
+	    keyCode = itemKeyCode;
+	  //else
+	  //      kWarning() << "Unable to parse key binding item:" << buffer;
 
-            buffer.clear();
-        }
+	  buffer.clear ();
+	}
 
-        // check if this is a wanted / not-wanted flag and update the 
-        // state ready for the next item
-        if ( ch == '+' )
-           isWanted = true;
-        else if ( ch == '-' )
-           isWanted = false; 
-    } 
+      // check if this is a wanted / not-wanted flag and update the 
+      // state ready for the next item
+      if (ch == '+')
+	isWanted = true;
+      else if (ch == '-')
+	isWanted = false;
+    }
 
-    modifiers = tempModifiers;
-    modifierMask = tempModifierMask;
-    flags = tempFlags;
-    flagMask = tempFlagMask;
+  modifiers = tempModifiers;
+  modifierMask = tempModifierMask;
+  flags = tempFlags;
+  flagMask = tempFlagMask;
 
-    return true;
+  return true;
 }
 
-bool KeyboardTranslatorReader::parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier)
-{
-    if ( item == "shift" )
-        modifier = Qt::ShiftModifier;
-    else if ( item == "ctrl" || item == "control" )
-        modifier = Qt::ControlModifier;
-    else if ( item == "alt" )
-        modifier = Qt::AltModifier;
-    else if ( item == "meta" )
-        modifier = Qt::MetaModifier;
-    else if ( item == "keypad" )
-        modifier = Qt::KeypadModifier;
-    else
-        return false;
-
-    return true;
-}
-bool KeyboardTranslatorReader::parseAsStateFlag(const QString& item , KeyboardTranslator::State& flag)
+bool
+KeyboardTranslatorReader::parseAsModifier (const QString & item,
+					   Qt::KeyboardModifier & modifier)
 {
-    if ( item == "appcukeys" || item == "appcursorkeys" )
-        flag = KeyboardTranslator::CursorKeysState;
-    else if ( item == "ansi" )
-        flag = KeyboardTranslator::AnsiState;
-    else if ( item == "newline" )
-        flag = KeyboardTranslator::NewLineState;
-    else if ( item == "appscreen" )
-        flag = KeyboardTranslator::AlternateScreenState;
-    else if ( item == "anymod" || item == "anymodifier" )
-        flag = KeyboardTranslator::AnyModifierState;
-    else if ( item == "appkeypad" )
-        flag = KeyboardTranslator::ApplicationKeypadState;
-    else
-        return false;
+  if (item == "shift")
+    modifier = Qt::ShiftModifier;
+  else if (item == "ctrl" || item == "control")
+    modifier = Qt::ControlModifier;
+  else if (item == "alt")
+    modifier = Qt::AltModifier;
+  else if (item == "meta")
+    modifier = Qt::MetaModifier;
+  else if (item == "keypad")
+    modifier = Qt::KeypadModifier;
+  else
+    return false;
 
-    return true;
-}
-bool KeyboardTranslatorReader::parseAsKeyCode(const QString& item , int& keyCode)
-{
-    QKeySequence sequence = QKeySequence::fromString(item);
-    if ( !sequence.isEmpty() )
-    {
-        keyCode = sequence[0];
-
-        if ( sequence.count() > 1 )
-        {
-            //kWarning() << "Unhandled key codes in sequence: " << item;
-        }
-    }
-    // additional cases implemented for backwards compatibility with KDE 3
-    else if ( item == "prior" )
-        keyCode = Qt::Key_PageUp;
-    else if ( item == "next" )
-        keyCode = Qt::Key_PageDown;
-    else
-        return false;
-
-    return true;
+  return true;
 }
 
-QString KeyboardTranslatorReader::description() const
-{
-    return _description;
-}
-bool KeyboardTranslatorReader::hasNextEntry()
+bool
+KeyboardTranslatorReader::parseAsStateFlag (const QString & item,
+					    KeyboardTranslator::State & flag)
 {
-    return _hasNext;
+  if (item == "appcukeys" || item == "appcursorkeys")
+    flag = KeyboardTranslator::CursorKeysState;
+  else if (item == "ansi")
+    flag = KeyboardTranslator::AnsiState;
+  else if (item == "newline")
+    flag = KeyboardTranslator::NewLineState;
+  else if (item == "appscreen")
+    flag = KeyboardTranslator::AlternateScreenState;
+  else if (item == "anymod" || item == "anymodifier")
+    flag = KeyboardTranslator::AnyModifierState;
+  else if (item == "appkeypad")
+    flag = KeyboardTranslator::ApplicationKeypadState;
+  else
+    return false;
+
+  return true;
 }
-KeyboardTranslator::Entry KeyboardTranslatorReader::createEntry( const QString& condition , 
-                                                                 const QString& result )
-{
-    QString entryString("keyboard \"temporary\"\nkey ");
-    entryString.append(condition);
-    entryString.append(" : ");
 
-    // if 'result' is the name of a command then the entry result will be that command,
-    // otherwise the result will be treated as a string to echo when the key sequence
-    // specified by 'condition' is pressed
-    KeyboardTranslator::Command command;
-    if (parseAsCommand(result,command))
-        entryString.append(result);
-    else
-        entryString.append('\"' + result + '\"');
+bool
+KeyboardTranslatorReader::parseAsKeyCode (const QString & item, int &keyCode)
+{
+  QKeySequence sequence = QKeySequence::fromString (item);
+  if (!sequence.isEmpty ())
+    {
+      keyCode = sequence[0];
 
-    QByteArray array = entryString.toUtf8();
-    QBuffer buffer(&array);
-    buffer.open(QIODevice::ReadOnly);
-    KeyboardTranslatorReader reader(&buffer);
+      if (sequence.count () > 1)
+	{
+	  //kWarning() << "Unhandled key codes in sequence: " << item;
+	}
+    }
+  // additional cases implemented for backwards compatibility with KDE 3
+  else if (item == "prior")
+    keyCode = Qt::Key_PageUp;
+  else if (item == "next")
+    keyCode = Qt::Key_PageDown;
+  else
+    return false;
 
-    KeyboardTranslator::Entry entry;
-    if ( reader.hasNextEntry() )
-        entry = reader.nextEntry();
+  return true;
+}
 
-    return entry;
+QString
+KeyboardTranslatorReader::description () const
+{
+  return _description;
+}
+
+bool
+KeyboardTranslatorReader::hasNextEntry ()
+{
+  return _hasNext;
 }
 
-KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry() 
-{
-    Q_ASSERT( _hasNext );
-    KeyboardTranslator::Entry entry = _nextEntry;
-    readNext();
-    return entry;
-}
-bool KeyboardTranslatorReader::parseError()
+KeyboardTranslator::Entry KeyboardTranslatorReader::
+createEntry (const QString & condition, const QString & result)
 {
-    return false;
+  QString
+  entryString ("keyboard \"temporary\"\nkey ");
+  entryString.append (condition);
+  entryString.append (" : ");
+
+  // if 'result' is the name of a command then the entry result will be that command,
+  // otherwise the result will be treated as a string to echo when the key sequence
+  // specified by 'condition' is pressed
+  KeyboardTranslator::Command command;
+  if (parseAsCommand (result, command))
+    entryString.append (result);
+  else
+    entryString.append ('\"' + result + '\"');
+
+  QByteArray
+    array = entryString.toUtf8 ();
+  QBuffer
+  buffer (&array);
+  buffer.open (QIODevice::ReadOnly);
+  KeyboardTranslatorReader
+  reader (&buffer);
+
+  KeyboardTranslator::Entry entry;
+  if (reader.hasNextEntry ())
+    entry = reader.nextEntry ();
+
+  return entry;
 }
-QList<KeyboardTranslatorReader::Token> KeyboardTranslatorReader::tokenize(const QString& line)
+
+KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry ()
 {
-    QString text = line;
+  Q_ASSERT (_hasNext);
+  KeyboardTranslator::Entry entry = _nextEntry;
+  readNext ();
+  return entry;
+}
 
-    // remove comments 
-    bool inQuotes = false;
-    int commentPos = -1;
-    for (int i=text.length()-1;i>=0;i--)
+bool
+KeyboardTranslatorReader::parseError ()
+{
+  return false;
+}
+
+QList < KeyboardTranslatorReader::Token >
+  KeyboardTranslatorReader::tokenize (const QString & line)
+{
+  QString text = line;
+
+  // remove comments 
+  bool inQuotes = false;
+  int commentPos = -1;
+  for (int i = text.length () - 1; i >= 0; i--)
     {
-        QChar ch = text[i];
-        if (ch == '\"')
-            inQuotes = !inQuotes;
-        else if (ch == '#' && !inQuotes)
-            commentPos = i;
+      QChar ch = text[i];
+      if (ch == '\"')
+	inQuotes = !inQuotes;
+      else if (ch == '#' && !inQuotes)
+	commentPos = i;
     }
-    if (commentPos != -1)
-        text.remove(commentPos,text.length());
+  if (commentPos != -1)
+    text.remove (commentPos, text.length ());
+
+  text = text.simplified ();
 
-    text = text.simplified();
-   
-    // title line: keyboard "title"
-    static QRegExp title("keyboard\\s+\"(.*)\"");
-    // key line: key KeySequence : "output"
-    // key line: key KeySequence : command
-    static QRegExp key("key\\s+([\\w\\+\\s\\-\\*\\.]+)\\s*:\\s*(\"(.*)\"|\\w+)");
+  // title line: keyboard "title"
+  static QRegExp title ("keyboard\\s+\"(.*)\"");
+  // key line: key KeySequence : "output"
+  // key line: key KeySequence : command
+  static QRegExp
+    key ("key\\s+([\\w\\+\\s\\-\\*\\.]+)\\s*:\\s*(\"(.*)\"|\\w+)");
 
-    QList<Token> list;
-    if ( text.isEmpty() ) 
+  QList < Token > list;
+  if (text.isEmpty ())
     {
-        return list;
+      return list;
     }
 
-    if ( title.exactMatch(text) )
+  if (title.exactMatch (text))
     {
-        Token titleToken = { Token::TitleKeyword , QString() };
-        Token textToken = { Token::TitleText , title.capturedTexts()[1] };
-    
-        list << titleToken << textToken;
+      Token titleToken = { Token::TitleKeyword, QString () };
+      Token textToken = { Token::TitleText, title.capturedTexts ()[1] };
+
+      list << titleToken << textToken;
     }
-    else if  ( key.exactMatch(text) )
+  else if (key.exactMatch (text))
     {
-        Token keyToken = { Token::KeyKeyword , QString() };
-        Token sequenceToken = { Token::KeySequence , key.capturedTexts()[1].remove(' ') };
+      Token keyToken = { Token::KeyKeyword, QString () };
+      Token sequenceToken =
+	{ Token::KeySequence, key.capturedTexts ()[1].remove (' ') };
 
-        list << keyToken << sequenceToken;
+      list << keyToken << sequenceToken;
 
-        if ( key.capturedTexts()[3].isEmpty() )
-        {
-            // capturedTexts()[2] is a command
-            Token commandToken = { Token::Command , key.capturedTexts()[2] };
-            list << commandToken;    
-        }   
-        else
-        {
-            // capturedTexts()[3] is the output string
-           Token outputToken = { Token::OutputText , key.capturedTexts()[3] };
-           list << outputToken;
-        }    
+      if (key.capturedTexts ()[3].isEmpty ())
+	{
+	  // capturedTexts()[2] is a command
+	  Token commandToken = { Token::Command, key.capturedTexts ()[2] };
+	  list << commandToken;
+	}
+      else
+	{
+	  // capturedTexts()[3] is the output string
+	  Token outputToken = { Token::OutputText, key.capturedTexts ()[3] };
+	  list << outputToken;
+	}
     }
-    else
+  else
     {
-        //kWarning() << "Line in keyboard translator file could not be understood:" << text;
+      //kWarning() << "Line in keyboard translator file could not be understood:" << text;
     }
 
-    return list;
+  return list;
 }
 
-QList<QString> KeyboardTranslatorManager::allTranslators() 
+QList < QString > KeyboardTranslatorManager::allTranslators ()
 {
-    if ( !_haveLoadedAll )
+  if (!_haveLoadedAll)
     {
-        findTranslators();
+      findTranslators ();
     }
 
-    return _translators.keys();
+  return _translators.keys ();
 }
 
-KeyboardTranslator::Entry::Entry()
-: _keyCode(0)
-, _modifiers(Qt::NoModifier)
-, _modifierMask(Qt::NoModifier)
-, _state(NoState)
-, _stateMask(NoState)
-, _command(NoCommand)
+KeyboardTranslator::Entry::Entry ():_keyCode (0), _modifiers (Qt::NoModifier), _modifierMask (Qt::NoModifier),
+_state (NoState), _stateMask (NoState),
+_command (NoCommand)
 {
 }
 
-bool KeyboardTranslator::Entry::operator==(const Entry& rhs) const
+bool
+KeyboardTranslator::Entry::operator== (const Entry & rhs) const
+{
+  return _keyCode == rhs._keyCode &&
+    _modifiers == rhs._modifiers &&
+    _modifierMask == rhs._modifierMask &&
+    _state == rhs._state &&
+    _stateMask == rhs._stateMask &&
+    _command == rhs._command && _text == rhs._text;
+}
+
+bool
+KeyboardTranslator::Entry::matches (int keyCode,
+				    Qt::KeyboardModifiers modifiers,
+                                    States testState) const
 {
-    return _keyCode == rhs._keyCode &&
-           _modifiers == rhs._modifiers &&
-           _modifierMask == rhs._modifierMask &&
-           _state == rhs._state &&
-           _stateMask == rhs._stateMask &&
-           _command == rhs._command &&
-           _text == rhs._text;
+  if (_keyCode != keyCode)
+    return false;
+
+  if ((modifiers & _modifierMask) != (_modifiers & _modifierMask))
+    return false;
+
+  // if modifiers is non-zero, the 'any modifier' state is implicit
+  if (modifiers != 0)
+    testState |= AnyModifierState;
+
+  if ((testState & _stateMask) != (_state & _stateMask))
+    return false;
+
+  // special handling for the 'Any Modifier' state, which checks for the presence of 
+  // any or no modifiers.  In this context, the 'keypad' modifier does not count.
+  bool
+    anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
+  bool
+    wantAnyModifier = _state & KeyboardTranslator::AnyModifierState;
+  if (_stateMask & KeyboardTranslator::AnyModifierState)
+    {
+      if (wantAnyModifier != anyModifiersSet)
+	return false;
+    }
+
+  return true;
 }
 
-bool KeyboardTranslator::Entry::matches(int keyCode , 
-                                        Qt::KeyboardModifiers modifiers,
-                                        States testState) const
-{
-    if ( _keyCode != keyCode )
-        return false;
-
-    if ( (modifiers & _modifierMask) != (_modifiers & _modifierMask) ) 
-        return false;
-
-    // if modifiers is non-zero, the 'any modifier' state is implicit
-    if ( modifiers != 0 )
-        testState |= AnyModifierState;
-
-    if ( (testState & _stateMask) != (_state & _stateMask) )
-        return false;
-
-    // special handling for the 'Any Modifier' state, which checks for the presence of 
-    // any or no modifiers.  In this context, the 'keypad' modifier does not count.
-    bool anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
-    bool wantAnyModifier = _state & KeyboardTranslator::AnyModifierState;
-    if ( _stateMask & KeyboardTranslator::AnyModifierState )
-    {
-        if ( wantAnyModifier != anyModifiersSet )
-           return false;
-    }
-    
-    return true;
-}
-QByteArray KeyboardTranslator::Entry::escapedText(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
+QByteArray
+KeyboardTranslator::Entry::escapedText (bool expandWildCards,
+					Qt::
+					KeyboardModifiers modifiers) const
 {
-    QByteArray result(text(expandWildCards,modifiers));
+  QByteArray
+  result (text (expandWildCards, modifiers));
 
-    for ( int i = 0 ; i < result.count() ; i++ )
+  for (int i = 0; i < result.count (); i++)
     {
-        char ch = result[i];
-        char replacement = 0;
+      char
+	ch = result[i];
+      char
+	replacement = 0;
 
-        switch ( ch )
-        {
-            case 27 : replacement = 'E'; break;
-            case 8  : replacement = 'b'; break;
-            case 12 : replacement = 'f'; break;
-            case 9  : replacement = 't'; break;
-            case 13 : replacement = 'r'; break;
-            case 10 : replacement = 'n'; break;
-            default:
-                // any character which is not printable is replaced by an equivalent
-                // \xhh escape sequence (where 'hh' are the corresponding hex digits)
-                if ( !QChar(ch).isPrint() )
-                    replacement = 'x';
-        }
+      switch (ch)
+	{
+	case 27:
+	  replacement = 'E';
+	  break;
+	case 8:
+	  replacement = 'b';
+	  break;
+	case 12:
+	  replacement = 'f';
+	  break;
+	case 9:
+	  replacement = 't';
+	  break;
+	case 13:
+	  replacement = 'r';
+	  break;
+	case 10:
+	  replacement = 'n';
+	  break;
+	default:
+	  // any character which is not printable is replaced by an equivalent
+	  // \xhh escape sequence (where 'hh' are the corresponding hex digits)
+	  if (!QChar (ch).isPrint ())
+	    replacement = 'x';
+	}
 
-        if ( replacement == 'x' )
-        {
-            result.replace(i,1,"\\x"+QByteArray(1,ch).toHex()); 
-        } else if ( replacement != 0 )
-        {
-            result.remove(i,1);
-            result.insert(i,'\\');
-            result.insert(i+1,replacement);
-        }
+      if (replacement == 'x')
+	{
+	  result.replace (i, 1, "\\x" + QByteArray (1, ch).toHex ());
+	}
+      else if (replacement != 0)
+	{
+	  result.remove (i, 1);
+	  result.insert (i, '\\');
+	  result.insert (i + 1, replacement);
+	}
     }
 
-    return result;
+  return result;
 }
-QByteArray KeyboardTranslator::Entry::unescape(const QByteArray& input) const
+
+QByteArray
+KeyboardTranslator::Entry::unescape (const QByteArray & input) const
 {
-    QByteArray result(input);
+  QByteArray
+  result (input);
 
-    for ( int i = 0 ; i < result.count()-1 ; i++ )
+  for (int i = 0; i < result.count () - 1; i++)
     {
 
-        QByteRef ch = result[i];
-        if ( ch == '\\' )
-        {
-           char replacement[2] = {0,0};
-           int charsToRemove = 2;
-           bool escapedChar = true;
+      QByteRef
+	ch = result[i];
+      if (ch == '\\')
+	{
+	  char
+	  replacement[2] = { 0, 0 };
+	  int
+	    charsToRemove = 2;
+	  bool
+	    escapedChar = true;
 
-           switch ( result[i+1] )
-           {
-              case 'E' : replacement[0] = 27; break;
-              case 'b' : replacement[0] = 8 ; break;
-              case 'f' : replacement[0] = 12; break;
-              case 't' : replacement[0] = 9 ; break;
-              case 'r' : replacement[0] = 13; break;
-              case 'n' : replacement[0] = 10; break;
-              case 'x' :
-                 {
-                    // format is \xh or \xhh where 'h' is a hexadecimal
-                    // digit from 0-9 or A-F which should be replaced
-                    // with the corresponding character value
-                    char hexDigits[3] = {0};
+	  switch (result[i + 1])
+	    {
+	    case 'E':
+	      replacement[0] = 27;
+	      break;
+	    case 'b':
+	      replacement[0] = 8;
+	      break;
+	    case 'f':
+	      replacement[0] = 12;
+	      break;
+	    case 't':
+	      replacement[0] = 9;
+	      break;
+	    case 'r':
+	      replacement[0] = 13;
+	      break;
+	    case 'n':
+	      replacement[0] = 10;
+	      break;
+	    case 'x':
+	      {
+		// format is \xh or \xhh where 'h' is a hexadecimal
+		// digit from 0-9 or A-F which should be replaced
+		// with the corresponding character value
+		char
+		hexDigits[3] = { 0 };
 
-                    if ( (i < result.count()-2) && isxdigit(result[i+2]) )
-                            hexDigits[0] = result[i+2];
-                    if ( (i < result.count()-3) && isxdigit(result[i+3]) )
-                            hexDigits[1] = result[i+3];
+		if ((i < result.count () - 2) && isxdigit (result[i + 2]))
+		  hexDigits[0] = result[i + 2];
+		if ((i < result.count () - 3) && isxdigit (result[i + 3]))
+		  hexDigits[1] = result[i + 3];
 
-                    unsigned charValue = 0;
-                    sscanf(hexDigits,"%x",&charValue);
+		unsigned
+		  charValue = 0;
+		sscanf (hexDigits, "%x", &charValue);
 
-                    replacement[0] = (char)charValue; 
-                    charsToRemove = 2 + strlen(hexDigits);
-                  }
-              break;
-              default:
-                  escapedChar = false;
-           }
+		replacement[0] = (char) charValue;
+		charsToRemove = 2 + strlen (hexDigits);
+	      }
+	      break;
+	    default:
+	      escapedChar = false;
+	    }
 
-           if ( escapedChar )
-               result.replace(i,charsToRemove,replacement);
-        }
+	  if (escapedChar)
+	    result.replace (i, charsToRemove, replacement);
+	}
     }
 
-    return result;
+  return result;
 }
 
-void KeyboardTranslator::Entry::insertModifier( QString& item , int modifier ) const
+void
+KeyboardTranslator::Entry::insertModifier (QString & item, int modifier) const
 {
-    if ( !(modifier & _modifierMask) )
-        return;
-
-    if ( modifier & _modifiers )
-        item += '+';
-    else
-        item += '-';
+  if (!(modifier & _modifierMask))
+    return;
 
-    if ( modifier == Qt::ShiftModifier )
-        item += "Shift";
-    else if ( modifier == Qt::ControlModifier )
-        item += "Ctrl";
-    else if ( modifier == Qt::AltModifier )
-        item += "Alt";
-    else if ( modifier == Qt::MetaModifier )
-        item += "Meta";
-    else if ( modifier == Qt::KeypadModifier )
-        item += "KeyPad";
-}
-void KeyboardTranslator::Entry::insertState( QString& item , int state ) const
-{
-    if ( !(state & _stateMask) )
-        return;
-
-    if ( state & _state )
-        item += '+' ;
-    else
-        item += '-' ;
+  if (modifier & _modifiers)
+    item += '+';
+  else
+    item += '-';
 
-    if ( state == KeyboardTranslator::AlternateScreenState )
-        item += "AppScreen";
-    else if ( state == KeyboardTranslator::NewLineState )
-        item += "NewLine";
-    else if ( state == KeyboardTranslator::AnsiState )
-        item += "Ansi";
-    else if ( state == KeyboardTranslator::CursorKeysState )
-        item += "AppCursorKeys";
-    else if ( state == KeyboardTranslator::AnyModifierState )
-        item += "AnyModifier";
-    else if ( state == KeyboardTranslator::ApplicationKeypadState )
-        item += "AppKeypad";
-}
-QString KeyboardTranslator::Entry::resultToString(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
-{
-    if ( !_text.isEmpty() )
-        return escapedText(expandWildCards,modifiers);
-    else if ( _command == EraseCommand )
-        return "Erase";
-    else if ( _command == ScrollPageUpCommand )
-        return "ScrollPageUp";
-    else if ( _command == ScrollPageDownCommand )
-        return "ScrollPageDown";
-    else if ( _command == ScrollLineUpCommand )
-        return "ScrollLineUp";
-    else if ( _command == ScrollLineDownCommand )
-        return "ScrollLineDown";
-    else if ( _command == ScrollLockCommand )
-        return "ScrollLock";
-
-    return QString();
-}
-QString KeyboardTranslator::Entry::conditionToString() const
-{
-    QString result = QKeySequence(_keyCode).toString();
-
-    insertModifier( result , Qt::ShiftModifier );
-    insertModifier( result , Qt::ControlModifier );
-    insertModifier( result , Qt::AltModifier );
-    insertModifier( result , Qt::MetaModifier );
-    insertModifier( result , Qt::KeypadModifier );
-
-    insertState( result , KeyboardTranslator::AlternateScreenState );
-    insertState( result , KeyboardTranslator::NewLineState );
-    insertState( result , KeyboardTranslator::AnsiState );
-    insertState( result , KeyboardTranslator::CursorKeysState );
-    insertState( result , KeyboardTranslator::AnyModifierState );
-    insertState( result , KeyboardTranslator::ApplicationKeypadState );
-
-    return result;
+  if (modifier == Qt::ShiftModifier)
+    item += "Shift";
+  else if (modifier == Qt::ControlModifier)
+    item += "Ctrl";
+  else if (modifier == Qt::AltModifier)
+    item += "Alt";
+  else if (modifier == Qt::MetaModifier)
+    item += "Meta";
+  else if (modifier == Qt::KeypadModifier)
+    item += "KeyPad";
 }
 
-KeyboardTranslator::KeyboardTranslator(const QString& name)
-: _name(name)
+void
+KeyboardTranslator::Entry::insertState (QString & item, int state) const
+{
+  if (!(state & _stateMask))
+    return;
+
+  if (state & _state)
+    item += '+';
+  else
+    item += '-';
+
+  if (state == KeyboardTranslator::AlternateScreenState)
+    item += "AppScreen";
+  else if (state == KeyboardTranslator::NewLineState)
+    item += "NewLine";
+  else if (state == KeyboardTranslator::AnsiState)
+    item += "Ansi";
+  else if (state == KeyboardTranslator::CursorKeysState)
+    item += "AppCursorKeys";
+  else if (state == KeyboardTranslator::AnyModifierState)
+    item += "AnyModifier";
+  else if (state == KeyboardTranslator::ApplicationKeypadState)
+    item += "AppKeypad";
+}
+
+QString
+KeyboardTranslator::Entry::resultToString (bool expandWildCards,
+					   Qt::
+					   KeyboardModifiers modifiers) const
+{
+  if (!_text.isEmpty ())
+    return escapedText (expandWildCards, modifiers);
+  else if (_command == EraseCommand)
+    return "Erase";
+  else if (_command == ScrollPageUpCommand)
+    return "ScrollPageUp";
+  else if (_command == ScrollPageDownCommand)
+    return "ScrollPageDown";
+  else if (_command == ScrollLineUpCommand)
+    return "ScrollLineUp";
+  else if (_command == ScrollLineDownCommand)
+    return "ScrollLineDown";
+  else if (_command == ScrollLockCommand)
+    return "ScrollLock";
+
+  return QString ();
+}
+
+QString
+KeyboardTranslator::Entry::conditionToString () const
+{
+  QString
+    result = QKeySequence (_keyCode).toString ();
+
+  insertModifier (result, Qt::ShiftModifier);
+  insertModifier (result, Qt::ControlModifier);
+  insertModifier (result, Qt::AltModifier);
+  insertModifier (result, Qt::MetaModifier);
+  insertModifier (result, Qt::KeypadModifier);
+
+  insertState (result, KeyboardTranslator::AlternateScreenState);
+  insertState (result, KeyboardTranslator::NewLineState);
+  insertState (result, KeyboardTranslator::AnsiState);
+  insertState (result, KeyboardTranslator::CursorKeysState);
+  insertState (result, KeyboardTranslator::AnyModifierState);
+  insertState (result, KeyboardTranslator::ApplicationKeypadState);
+
+  return result;
+}
+
+KeyboardTranslator::KeyboardTranslator (const QString & name):_name (name)
 {
 }
 
-void KeyboardTranslator::setDescription(const QString& description) 
+void
+KeyboardTranslator::setDescription (const QString & description)
 {
-    _description = description;
-}
-QString KeyboardTranslator::description() const
-{
-    return _description;
+  _description = description;
 }
-void KeyboardTranslator::setName(const QString& name)
+
+QString
+KeyboardTranslator::description () const
 {
-    _name = name;
-}
-QString KeyboardTranslator::name() const
-{
-    return _name;
+  return _description;
 }
 
-QList<KeyboardTranslator::Entry> KeyboardTranslator::entries() const
+void
+KeyboardTranslator::setName (const QString & name)
 {
-    return _entries.values();
+  _name = name;
+}
+
+QString
+KeyboardTranslator::name () const
+{
+  return _name;
+}
+
+QList < KeyboardTranslator::Entry >
+KeyboardTranslator::entries () const
+{
+  return _entries.values ();
 }
 
-void KeyboardTranslator::addEntry(const Entry& entry)
+void
+KeyboardTranslator::addEntry (const Entry & entry)
 {
-    const int keyCode = entry.keyCode();
-    _entries.insert(keyCode,entry);
+  const int keyCode = entry.keyCode ();
+  _entries.insert (keyCode, entry);
 }
-void KeyboardTranslator::replaceEntry(const Entry& existing , const Entry& replacement)
+
+void
+KeyboardTranslator::replaceEntry (const Entry & existing,
+				  const Entry & replacement)
 {
-    if ( !existing.isNull() )
-        _entries.remove(existing.keyCode(),existing);
-    _entries.insert(replacement.keyCode(),replacement);
+  if (!existing.isNull ())
+    _entries.remove (existing.keyCode (), existing);
+  _entries.insert (replacement.keyCode (), replacement);
 }
-void KeyboardTranslator::removeEntry(const Entry& entry)
+
+void
+KeyboardTranslator::removeEntry (const Entry & entry)
 {
-    _entries.remove(entry.keyCode(),entry);
+  _entries.remove (entry.keyCode (), entry);
 }
-KeyboardTranslator::Entry KeyboardTranslator::findEntry(int keyCode, Qt::KeyboardModifiers modifiers, States state) const
+
+KeyboardTranslator::Entry KeyboardTranslator::findEntry (int keyCode,
+							 Qt::
+							 KeyboardModifiers
+							 modifiers,
+							 States state) const
 {
-    foreach(const Entry& entry, _entries.values(keyCode))
-    {
-        if ( entry.matches(keyCode,modifiers,state) )
-            return entry;
-    }
-    return Entry(); // entry not found
+  foreach (const Entry & entry, _entries.values (keyCode))
+  {
+    if (entry.matches (keyCode, modifiers, state))
+      return entry;
+  }
+  return Entry ();		// entry not found
 }
-void KeyboardTranslatorManager::addTranslator(KeyboardTranslator* translator)
+
+void
+KeyboardTranslatorManager::addTranslator (KeyboardTranslator * translator)
 {
-    _translators.insert(translator->name(),translator);
+  _translators.insert (translator->name (), translator);
 
   //  if ( !saveTranslator(translator) )
   //      kWarning() << "Unable to save translator" << translator->name()
-    //               << "to disk.";
+  //               << "to disk.";
 }
-bool KeyboardTranslatorManager::deleteTranslator(const QString& name)
+
+bool
+KeyboardTranslatorManager::deleteTranslator (const QString & name)
 {
-    Q_ASSERT( _translators.contains(name) );
+  Q_ASSERT (_translators.contains (name));
 
-    // locate and delete
-    QString path = findTranslatorPath(name);
-    if ( QFile::remove(path) )
+  // locate and delete
+  QString path = findTranslatorPath (name);
+  if (QFile::remove (path))
     {
-        _translators.remove(name);
-        return true; 
+      _translators.remove (name);
+      return true;
     }
-    else
+  else
     {
-        //kWarning() << "Failed to remove translator - " << path;
-        return false;
+      //kWarning() << "Failed to remove translator - " << path;
+      return false;
     }
 }
 
 /**
  * @internal
  */
-typedef void (*KdeCleanUpFunction)();
+typedef void (*KdeCleanUpFunction) ();
 
 /**
  * @internal
  *
  * Helper class for K_GLOBAL_STATIC to clean up the object on library unload or application
  * shutdown.
  */
 class KCleanUpGlobalStatic
 {
-    public:
-        KdeCleanUpFunction func;
+public:
+  KdeCleanUpFunction func;
 
-        inline ~KCleanUpGlobalStatic() { func(); }
+  inline ~ KCleanUpGlobalStatic ()
+  {
+    func ();
+  }
 };
 
 
 
 #ifdef Q_CC_MSVC
 /**
  * @internal
  *
  * MSVC seems to give anonymous structs the same name which fails at link time. So instead we name
  * the struct and hope that by adding the line number to the name it's unique enough to never clash.
  */
-# define K_GLOBAL_STATIC_STRUCT_NAME(NAME) _k_##NAME##__LINE__
+#define K_GLOBAL_STATIC_STRUCT_NAME(NAME) _k_##NAME##__LINE__
 #else
 /**
  * @internal
  *
  * Make the struct of the K_GLOBAL_STATIC anonymous.
  */
-# define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
+#define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
 #endif
 
 
 
 #define K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                            \
 static QBasicAtomicPointer<TYPE > _k_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0); \
 static bool _k_static_##NAME##_destroyed;                                      \
 static struct K_GLOBAL_STATIC_STRUCT_NAME(NAME)                                \
@@ -962,13 +1079,13 @@ static struct K_GLOBAL_STATIC_STRUCT_NAM
         TYPE *x = _k_static_##NAME;                                            \
         _k_static_##NAME = 0;                                                  \
         delete x;                                                              \
     }                                                                          \
 } NAME;
 
 #define K_GLOBAL_STATIC(TYPE, NAME) K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())
 
-K_GLOBAL_STATIC( KeyboardTranslatorManager , theKeyboardTranslatorManager )
-KeyboardTranslatorManager* KeyboardTranslatorManager::instance()
+K_GLOBAL_STATIC (KeyboardTranslatorManager, theKeyboardTranslatorManager)
+     KeyboardTranslatorManager *KeyboardTranslatorManager::instance ()
 {
-    return theKeyboardTranslatorManager;
+  return theKeyboardTranslatorManager;
 }
diff --git a/gui/src/terminal/KeyboardTranslator.h b/gui/src/terminal/KeyboardTranslator.h
--- a/gui/src/terminal/KeyboardTranslator.h
+++ b/gui/src/terminal/KeyboardTranslator.h
@@ -51,274 +51,272 @@ public:
     /** 
      * The meaning of a particular key sequence may depend upon the state which
      * the terminal emulation is in.  Therefore findEntry() may return a different
      * Entry depending upon the state flags supplied.
      *
      * This enum describes the states which may be associated with with a particular
      * entry in the keyboard translation entry.
      */
-    enum State
-    {
-        /** Indicates that no special state is active */
-        NoState = 0,
-        /**
+  enum State
+  {
+	/** Indicates that no special state is active */
+    NoState = 0,
+	/**
          * TODO More documentation
          */
-        NewLineState = 1,
-        /** 
+    NewLineState = 1,
+	/** 
          * Indicates that the terminal is in 'Ansi' mode.
          * TODO: More documentation
          */
-        AnsiState = 2,
-        /**
+    AnsiState = 2,
+	/**
          * TODO More documentation
          */
-        CursorKeysState = 4,
-        /**
+    CursorKeysState = 4,
+	/**
          * Indicates that the alternate screen ( typically used by interactive programs
          * such as screen or vim ) is active 
          */
-        AlternateScreenState = 8,
-        /** Indicates that any of the modifier keys is active. */ 
-        AnyModifierState = 16,
-        /** Indicates that the numpad is in application mode. */
-        ApplicationKeypadState = 32
-    };
-    Q_DECLARE_FLAGS(States,State)
-
+    AlternateScreenState = 8,
+	/** Indicates that any of the modifier keys is active. */
+    AnyModifierState = 16,
+	/** Indicates that the numpad is in application mode. */
+    ApplicationKeypadState = 32
+  };
+    Q_DECLARE_FLAGS (States, State)
     /**
      * This enum describes commands which are associated with particular key sequences.
      */
     enum Command
-    {
-        /** Indicates that no command is associated with this command sequence */
-        NoCommand = 0,
-        /** TODO Document me */
-        SendCommand = 1,
-        /** Scroll the terminal display up one page */
-        ScrollPageUpCommand = 2,
-        /** Scroll the terminal display down one page */
-        ScrollPageDownCommand = 4,
-        /** Scroll the terminal display up one line */
-        ScrollLineUpCommand = 8,
-        /** Scroll the terminal display down one line */
-        ScrollLineDownCommand = 16,
-        /** Toggles scroll lock mode */
-        ScrollLockCommand = 32,
-        /** Echos the operating system specific erase character. */
-        EraseCommand = 64
-    };
-    Q_DECLARE_FLAGS(Commands,Command)
-
+  {
+	/** Indicates that no command is associated with this command sequence */
+    NoCommand = 0,
+	/** TODO Document me */
+    SendCommand = 1,
+	/** Scroll the terminal display up one page */
+    ScrollPageUpCommand = 2,
+	/** Scroll the terminal display down one page */
+    ScrollPageDownCommand = 4,
+	/** Scroll the terminal display up one line */
+    ScrollLineUpCommand = 8,
+	/** Scroll the terminal display down one line */
+    ScrollLineDownCommand = 16,
+	/** Toggles scroll lock mode */
+    ScrollLockCommand = 32,
+	/** Echos the operating system specific erase character. */
+    EraseCommand = 64
+  };
+    Q_DECLARE_FLAGS (Commands, Command)
     /**
      * Represents an association between a key sequence pressed by the user
      * and the character sequence and commands associated with it for a particular
      * KeyboardTranslator.
      */
-    class Entry
-    {
-    public:
-        /** 
+  class Entry
+  {
+  public:
+	/** 
          * Constructs a new entry for a keyboard translator.
          */
-        Entry();
+    Entry ();
 
-        /** 
+	/** 
          * Returns true if this entry is null.
          * This is true for newly constructed entries which have no properties set. 
          */
-        bool isNull() const;
+    bool isNull () const;
 
-        /** Returns the commands associated with this entry */
-        Command command() const;
-        /** Sets the command associated with this entry. */
-        void setCommand(Command command);
+	/** Returns the commands associated with this entry */
+    Command command () const;
+	/** Sets the command associated with this entry. */
+    void setCommand (Command command);
 
-        /** 
+	/** 
          * Returns the character sequence associated with this entry, optionally replacing 
          * wildcard '*' characters with numbers to indicate the keyboard modifiers being pressed.
          *
          * TODO: The numbers used to replace '*' characters are taken from the Konsole/KDE 3 code.
          * Document them. 
          *
          * @param expandWildCards Specifies whether wild cards (occurrences of the '*' character) in
          * the entry should be replaced with a number to indicate the modifier keys being pressed. 
          *
          * @param modifiers The keyboard modifiers being pressed.
          */
-        QByteArray text(bool expandWildCards = false,
-                        Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+    QByteArray text (bool expandWildCards = false,
+		     Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
 
-        /** Sets the character sequence associated with this entry */
-        void setText(const QByteArray& text);
+	/** Sets the character sequence associated with this entry */
+    void setText (const QByteArray & text);
 
-        /** 
+	/** 
          * Returns the character sequence associated with this entry,
          * with any non-printable characters replaced with escape sequences.
          *
          * eg. \\E for Escape, \\t for tab, \\n for new line.
          *
          * @param expandWildCards See text()
          * @param modifiers See text()
          */
-        QByteArray escapedText(bool expandWildCards = false,
-                               Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+    QByteArray escapedText (bool expandWildCards = false,
+			    Qt::KeyboardModifiers modifiers =
+			    Qt::NoModifier) const;
 
-        /** Returns the character code ( from the Qt::Key enum ) associated with this entry */
-        int keyCode() const;
-        /** Sets the character code associated with this entry */
-        void setKeyCode(int keyCode);
+	/** Returns the character code ( from the Qt::Key enum ) associated with this entry */
+    int keyCode () const;
+	/** Sets the character code associated with this entry */
+    void setKeyCode (int keyCode);
 
-        /** 
+	/** 
          * Returns a bitwise-OR of the enabled keyboard modifiers associated with this entry. 
          * If a modifier is set in modifierMask() but not in modifiers(), this means that the entry
          * only matches when that modifier is NOT pressed.
          *
          * If a modifier is not set in modifierMask() then the entry matches whether the modifier
          * is pressed or not. 
          */
-        Qt::KeyboardModifiers modifiers() const;
+      Qt::KeyboardModifiers modifiers () const;
 
-        /** Returns the keyboard modifiers which are valid in this entry.  See modifiers() */
-        Qt::KeyboardModifiers modifierMask() const;
+	/** Returns the keyboard modifiers which are valid in this entry.  See modifiers() */
+      Qt::KeyboardModifiers modifierMask () const;
 
-        /** See modifiers() */
-        void setModifiers( Qt::KeyboardModifiers modifiers );
-        /** See modifierMask() and modifiers() */
-        void setModifierMask( Qt::KeyboardModifiers modifiers );
+	/** See modifiers() */
+    void setModifiers (Qt::KeyboardModifiers modifiers);
+	/** See modifierMask() and modifiers() */
+    void setModifierMask (Qt::KeyboardModifiers modifiers);
 
-        /** 
+	/** 
          * Returns a bitwise-OR of the enabled state flags associated with this entry. 
          * If flag is set in stateMask() but not in state(), this means that the entry only 
          * matches when the terminal is NOT in that state.
          *
          * If a state is not set in stateMask() then the entry matches whether the terminal
          * is in that state or not. 
          */
-        States state() const;
+    States state () const;
 
-        /** Returns the state flags which are valid in this entry.  See state() */
-        States stateMask() const;
+	/** Returns the state flags which are valid in this entry.  See state() */
+    States stateMask () const;
 
-        /** See state() */
-        void setState( States state );
-        /** See stateMask() */
-        void setStateMask( States mask );
+	/** See state() */
+    void setState (States state);
+	/** See stateMask() */
+    void setStateMask (States mask);
 
-        /** 
+	/** 
          * Returns the key code and modifiers associated with this entry 
          * as a QKeySequence
          */
-        //QKeySequence keySequence() const;
+    //QKeySequence keySequence() const;
 
-        /** 
+	/** 
          * Returns this entry's conditions ( ie. its key code, modifier and state criteria )
          * as a string.
          */
-        QString conditionToString() const;
+    QString conditionToString () const;
 
-        /**
+	/**
          * Returns this entry's result ( ie. its command or character sequence )
          * as a string.
          *
          * @param expandWildCards See text()
          * @param modifiers See text()
          */
-        QString resultToString(bool expandWildCards = false,
-                               Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+    QString resultToString (bool expandWildCards = false,
+			    Qt::KeyboardModifiers modifiers =
+			    Qt::NoModifier) const;
 
-        /** 
+	/** 
          * Returns true if this entry matches the given key sequence, specified
          * as a combination of @p keyCode , @p modifiers and @p state.
          */
-        bool matches( int keyCode , 
-                      Qt::KeyboardModifiers modifiers , 
-                      States flags ) const;
+    bool matches (int keyCode,
+		  Qt::KeyboardModifiers modifiers, States flags) const;
+
+    bool operator== (const Entry & rhs) const;
+
+  private:
+    void insertModifier (QString & item, int modifier) const;
+    void insertState (QString & item, int state) const;
+    QByteArray unescape (const QByteArray & text) const;
 
-        bool operator==(const Entry& rhs) const;
-       
-    private:
-        void insertModifier( QString& item , int modifier ) const;
-        void insertState( QString& item , int state ) const;
-        QByteArray unescape(const QByteArray& text) const;
+    int _keyCode;
+      Qt::KeyboardModifiers _modifiers;
+      Qt::KeyboardModifiers _modifierMask;
+    States _state;
+    States _stateMask;
 
-        int _keyCode;
-        Qt::KeyboardModifiers _modifiers;
-        Qt::KeyboardModifiers _modifierMask;
-        States _state;
-        States _stateMask;
-
-        Command _command;
-        QByteArray _text;
-    };
+    Command _command;
+    QByteArray _text;
+  };
 
     /** Constructs a new keyboard translator with the given @p name */
-    KeyboardTranslator(const QString& name);
-   
-    //KeyboardTranslator(const KeyboardTranslator& other);
+    KeyboardTranslator (const QString & name);
+
+  //KeyboardTranslator(const KeyboardTranslator& other);
 
     /** Returns the name of this keyboard translator */
-    QString name() const;
+  QString name () const;
 
     /** Sets the name of this keyboard translator */
-    void setName(const QString& name);
+  void setName (const QString & name);
 
     /** Returns the descriptive name of this keyboard translator */
-    QString description() const;
+  QString description () const;
 
     /** Sets the descriptive name of this keyboard translator */
-    void setDescription(const QString& description);
+  void setDescription (const QString & description);
 
     /**
      * Looks for an entry in this keyboard translator which matches the given
      * key code, keyboard modifiers and state flags.
      * 
      * Returns the matching entry if found or a null Entry otherwise ( ie.
      * entry.isNull() will return true )
      *
      * @param keyCode A key code from the Qt::Key enum
      * @param modifiers A combination of modifiers
      * @param state Optional flags which specify the current state of the terminal
      */
-    Entry findEntry(int keyCode , 
-                    Qt::KeyboardModifiers modifiers , 
-                    States state = NoState) const;
+  Entry findEntry (int keyCode,
+		   Qt::KeyboardModifiers modifiers,
+		   States state = NoState) const;
 
     /** 
      * Adds an entry to this keyboard translator's table.  Entries can be looked up according
      * to their key sequence using findEntry()
      */
-    void addEntry(const Entry& entry);
+  void addEntry (const Entry & entry);
 
     /**
      * Replaces an entry in the translator.  If the @p existing entry is null,
      * then this is equivalent to calling addEntry(@p replacement)
      */
-    void replaceEntry(const Entry& existing , const Entry& replacement);
+  void replaceEntry (const Entry & existing, const Entry & replacement);
 
     /**
      * Removes an entry from the table.
      */
-    void removeEntry(const Entry& entry);
+  void removeEntry (const Entry & entry);
 
     /** Returns a list of all entries in the translator. */
-    QList<Entry> entries() const;
+    QList < Entry > entries () const;
 
 private:
 
-    QMultiHash<int,Entry> _entries; // entries in this keyboard translation,
-                                                 // entries are indexed according to
-                                                 // their keycode
-    QString _name;
-    QString _description;
+    QMultiHash < int, Entry > _entries;	// entries in this keyboard translation,
+  // entries are indexed according to
+  // their keycode
+  QString _name;
+  QString _description;
 };
-Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::States)
-Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::Commands)
-
+Q_DECLARE_OPERATORS_FOR_FLAGS (KeyboardTranslator::States)
+Q_DECLARE_OPERATORS_FOR_FLAGS (KeyboardTranslator::Commands)
 /** 
  * Parses the contents of a Keyboard Translator (.keytab) file and 
  * returns the entries found in it.
  *
  * Usage example:
  *
  * @code
  *  QFile source( "/path/to/keytab" );
@@ -337,241 +335,292 @@ Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTr
  *      // parsing succeeded, do something with the translator
  *  } 
  *  else
  *  {
  *      // parsing failed
  *  }
  * @endcode
  */
-class KeyboardTranslatorReader
-{
-public:
+     class KeyboardTranslatorReader
+     {
+     public:
     /** Constructs a new reader which parses the given @p source */
-    KeyboardTranslatorReader( QIODevice* source );
+       KeyboardTranslatorReader (QIODevice * source);
 
     /** 
      * Returns the description text. 
      * TODO: More documentation 
      */
-    QString description() const;
+       QString description () const;
 
     /** Returns true if there is another entry in the source stream */
-    bool hasNextEntry();
+       bool hasNextEntry ();
     /** Returns the next entry found in the source stream */
-    KeyboardTranslator::Entry nextEntry(); 
+         KeyboardTranslator::Entry nextEntry ();
 
     /** 
      * Returns true if an error occurred whilst parsing the input or
      * false if no error occurred.
      */
-    bool parseError();
+       bool parseError ();
 
     /**
      * Parses a condition and result string for a translator entry
      * and produces a keyboard translator entry.
      *
      * The condition and result strings are in the same format as in  
      */
-    static KeyboardTranslator::Entry createEntry( const QString& condition ,
-                                                  const QString& result );
-private:
-    struct Token
-    {
-        enum Type
-        {
-            TitleKeyword,
-            TitleText,
-            KeyKeyword,
-            KeySequence,
-            Command,
-            OutputText
-        };
-        Type type;
-        QString text;
-    };
-    QList<Token> tokenize(const QString&);
-    void readNext();
-    bool decodeSequence(const QString& , 
-                                int& keyCode,
-                                Qt::KeyboardModifiers& modifiers,
-                                Qt::KeyboardModifiers& modifierMask,
-                                KeyboardTranslator::States& state,
-                                KeyboardTranslator::States& stateFlags);
+       static KeyboardTranslator::
+	 Entry createEntry (const QString & condition,
+			    const QString & result);
+     private:
+       struct Token
+       {
+	 enum Type
+	 {
+	   TitleKeyword,
+	   TitleText,
+	   KeyKeyword,
+	   KeySequence,
+	   Command,
+	   OutputText
+	 };
+	 Type type;
+	 QString text;
+       };
+         QList < Token > tokenize (const QString &);
+       void readNext ();
+       bool decodeSequence (const QString &,
+			    int &keyCode,
+			    Qt::KeyboardModifiers & modifiers,
+			    Qt::KeyboardModifiers & modifierMask,
+			    KeyboardTranslator::States & state,
+			    KeyboardTranslator::States & stateFlags);
 
-    static bool parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier);
-    static bool parseAsStateFlag(const QString& item , KeyboardTranslator::State& state);
-    static bool parseAsKeyCode(const QString& item , int& keyCode);
-       static bool parseAsCommand(const QString& text , KeyboardTranslator::Command& command);
+       static bool parseAsModifier (const QString & item,
+				    Qt::KeyboardModifier & modifier);
+       static bool parseAsStateFlag (const QString & item,
+				     KeyboardTranslator::State & state);
+       static bool parseAsKeyCode (const QString & item, int &keyCode);
+       static bool parseAsCommand (const QString & text,
+				   KeyboardTranslator::Command & command);
 
-    QIODevice* _source;
-    QString _description;
-    KeyboardTranslator::Entry _nextEntry;
-    bool _hasNext;
-};
+       QIODevice *_source;
+       QString _description;
+         KeyboardTranslator::Entry _nextEntry;
+       bool _hasNext;
+     };
 
 /** Writes a keyboard translation to disk. */
-class KeyboardTranslatorWriter
-{
-public:
+     class KeyboardTranslatorWriter
+     {
+     public:
     /** 
      * Constructs a new writer which saves data into @p destination.
      * The caller is responsible for closing the device when writing is complete.
      */
-    KeyboardTranslatorWriter(QIODevice* destination);
-    ~KeyboardTranslatorWriter();
+       KeyboardTranslatorWriter (QIODevice * destination);
+       ~KeyboardTranslatorWriter ();
 
     /** 
      * Writes the header for the keyboard translator. 
      * @param description Description of the keyboard translator. 
      */
-    void writeHeader( const QString& description );
+       void writeHeader (const QString & description);
     /** Writes a translator entry. */
-    void writeEntry( const KeyboardTranslator::Entry& entry ); 
+       void writeEntry (const KeyboardTranslator::Entry & entry);
 
-private:
-    QIODevice* _destination;  
-    QTextStream* _writer;
-};
+     private:
+         QIODevice * _destination;
+       QTextStream *_writer;
+     };
 
 /**
  * Manages the keyboard translations available for use by terminal sessions,
  * see KeyboardTranslator.
  */
-class KeyboardTranslatorManager
-{
-public:
+     class KeyboardTranslatorManager
+     {
+     public:
     /** 
      * Constructs a new KeyboardTranslatorManager and loads the list of
      * available keyboard translations.
      *
      * The keyboard translations themselves are not loaded until they are
      * first requested via a call to findTranslator()
      */
-    KeyboardTranslatorManager();
-    ~KeyboardTranslatorManager();
+       KeyboardTranslatorManager ();
+       ~KeyboardTranslatorManager ();
 
     /**
      * Adds a new translator.  If a translator with the same name 
      * already exists, it will be replaced by the new translator.
      *
      * TODO: More documentation.
      */
-    void addTranslator(KeyboardTranslator* translator);
+       void addTranslator (KeyboardTranslator * translator);
 
     /**
      * Deletes a translator.  Returns true on successful deletion or false otherwise.
      *
      * TODO: More documentation
      */
-    bool deleteTranslator(const QString& name);
+       bool deleteTranslator (const QString & name);
 
     /** Returns the default translator for Konsole. */
-    const KeyboardTranslator* defaultTranslator();
+       const KeyboardTranslator *defaultTranslator ();
 
     /** 
      * Returns the keyboard translator with the given name or 0 if no translator
      * with that name exists.
      *
      * The first time that a translator with a particular name is requested,
      * the on-disk .keyboard file is loaded and parsed.  
      */
-    const KeyboardTranslator* findTranslator(const QString& name);
+       const KeyboardTranslator *findTranslator (const QString & name);
     /**
      * Returns a list of the names of available keyboard translators.
      *
      * The first time this is called, a search for available 
      * translators is started.
      */
-    QList<QString> allTranslators();
+         QList < QString > allTranslators ();
 
     /** Returns the global KeyboardTranslatorManager instance. */
-   static KeyboardTranslatorManager* instance();
+       static KeyboardTranslatorManager *instance ();
+
+     private:
+       static const QByteArray defaultTranslatorText;
+
+       void findTranslators ();	// locate the available translators
+       KeyboardTranslator *loadTranslator (const QString & name);	// loads the translator 
+       // with the given name
+       KeyboardTranslator *loadTranslator (QIODevice * device,
+					   const QString & name);
+
+       bool saveTranslator (const KeyboardTranslator * translator);
+       QString findTranslatorPath (const QString & name);
 
-private:
-    static const QByteArray defaultTranslatorText;
-    
-    void findTranslators(); // locate the available translators
-    KeyboardTranslator* loadTranslator(const QString& name); // loads the translator 
-                                                             // with the given name
-    KeyboardTranslator* loadTranslator(QIODevice* device,const QString& name);
+         QHash < QString, KeyboardTranslator * >_translators;	// maps translator-name -> KeyboardTranslator
+       // instance
+       bool _haveLoadedAll;
+     };
 
-    bool saveTranslator(const KeyboardTranslator* translator);
-    QString findTranslatorPath(const QString& name);
-    
-    QHash<QString,KeyboardTranslator*> _translators; // maps translator-name -> KeyboardTranslator
-                                                     // instance
-    bool _haveLoadedAll;
-};
+inline int
+KeyboardTranslator::Entry::keyCode () const
+{
+  return _keyCode;
+}
+
+inline void
+KeyboardTranslator::Entry::setKeyCode (int keyCode)
+{
+  _keyCode = keyCode;
+}
 
-inline int KeyboardTranslator::Entry::keyCode() const { return _keyCode; }
-inline void KeyboardTranslator::Entry::setKeyCode(int keyCode) { _keyCode = keyCode; }
+inline void
+KeyboardTranslator::Entry::setModifiers (Qt::KeyboardModifiers modifier)
+{
+  _modifiers = modifier;
+}
 
-inline void KeyboardTranslator::Entry::setModifiers( Qt::KeyboardModifiers modifier ) 
-{ 
-    _modifiers = modifier;
+inline Qt::KeyboardModifiers
+KeyboardTranslator::Entry::modifiers () const
+{
+  return _modifiers;
 }
-inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifiers() const { return _modifiers; }
 
-inline void  KeyboardTranslator::Entry::setModifierMask( Qt::KeyboardModifiers mask ) 
-{ 
-   _modifierMask = mask; 
+inline void
+KeyboardTranslator::Entry::setModifierMask (Qt::KeyboardModifiers mask)
+{
+  _modifierMask = mask;
+}
+
+inline Qt::KeyboardModifiers
+KeyboardTranslator::Entry::modifierMask () const
+{
+  return _modifierMask;
 }
-inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifierMask() const { return _modifierMask; }
 
-inline bool KeyboardTranslator::Entry::isNull() const
+inline bool
+KeyboardTranslator::Entry::isNull () const
 {
-    return ( *this == Entry() );
+  return (*this == Entry ());
+}
+
+inline void
+KeyboardTranslator::Entry::setCommand (Command command)
+{
+  _command = command;
 }
 
-inline void KeyboardTranslator::Entry::setCommand( Command command )
-{ 
-    _command = command; 
+inline KeyboardTranslator::Command
+KeyboardTranslator::Entry::command () const
+{
+  return _command;
 }
-inline KeyboardTranslator::Command KeyboardTranslator::Entry::command() const { return _command; }
 
-inline void KeyboardTranslator::Entry::setText( const QByteArray& text )
-{ 
-    _text = unescape(text);
+inline void
+KeyboardTranslator::Entry::setText (const QByteArray & text)
+{
+  _text = unescape (text);
 }
-inline int oneOrZero(int value)
+
+inline int
+oneOrZero (int value)
 {
-    return value ? 1 : 0;
+  return value ? 1 : 0;
 }
-inline QByteArray KeyboardTranslator::Entry::text(bool expandWildCards,Qt::KeyboardModifiers modifiers) const 
+
+inline QByteArray
+KeyboardTranslator::Entry::text (bool expandWildCards,
+                                 Qt::KeyboardModifiers modifiers) const
 {
-    QByteArray expandedText = _text;
-    
-    if (expandWildCards)
+  QByteArray
+    expandedText = _text;
+
+  if (expandWildCards)
     {
-        int modifierValue = 1;
-        modifierValue += oneOrZero(modifiers & Qt::ShiftModifier);
-        modifierValue += oneOrZero(modifiers & Qt::AltModifier)     << 1;
-        modifierValue += oneOrZero(modifiers & Qt::ControlModifier) << 2;
+      int
+	modifierValue = 1;
+      modifierValue += oneOrZero (modifiers & Qt::ShiftModifier);
+      modifierValue += oneOrZero (modifiers & Qt::AltModifier) << 1;
+      modifierValue += oneOrZero (modifiers & Qt::ControlModifier) << 2;
 
-        for (int i=0;i<_text.length();i++) 
-        {
-            if (expandedText[i] == '*')
-                expandedText[i] = '0' + modifierValue;
-        }
+      for (int i = 0; i < _text.length (); i++)
+	{
+	  if (expandedText[i] == '*')
+	    expandedText[i] = '0' + modifierValue;
+	}
     }
 
-    return expandedText; 
+  return expandedText;
+}
+
+inline void
+KeyboardTranslator::Entry::setState (States state)
+{
+  _state = state;
+}
+
+inline KeyboardTranslator::States
+KeyboardTranslator::Entry::state () const
+{
+  return _state;
 }
 
-inline void KeyboardTranslator::Entry::setState( States state )
-{ 
-    _state = state; 
+inline void
+KeyboardTranslator::Entry::setStateMask (States stateMask)
+{
+  _stateMask = stateMask;
 }
-inline KeyboardTranslator::States KeyboardTranslator::Entry::state() const { return _state; }
 
-inline void KeyboardTranslator::Entry::setStateMask( States stateMask )
-{ 
-    _stateMask = stateMask; 
+inline KeyboardTranslator::States
+KeyboardTranslator::Entry::stateMask () const
+{
+  return _stateMask;
 }
-inline KeyboardTranslator::States KeyboardTranslator::Entry::stateMask() const { return _stateMask; }
 
 
-Q_DECLARE_METATYPE(KeyboardTranslator::Entry)
-Q_DECLARE_METATYPE(const KeyboardTranslator*)
-
+Q_DECLARE_METATYPE (KeyboardTranslator::Entry)
+Q_DECLARE_METATYPE (const KeyboardTranslator *)
 #endif // KEYBOARDTRANSLATOR_H
-
diff --git a/gui/src/terminal/LineFont.h b/gui/src/terminal/LineFont.h
--- a/gui/src/terminal/LineFont.h
+++ b/gui/src/terminal/LineFont.h
@@ -14,25 +14,41 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 static const quint32 LineChars[] = {
-	0x00007c00, 0x000fffe0, 0x00421084, 0x00e739ce, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00427000, 0x004e7380, 0x00e77800, 0x00ef7bc0, 
-	0x00421c00, 0x00439ce0, 0x00e73c00, 0x00e7bde0, 0x00007084, 0x000e7384, 0x000079ce, 0x000f7bce, 
-	0x00001c84, 0x00039ce4, 0x00003dce, 0x0007bdee, 0x00427084, 0x004e7384, 0x004279ce, 0x00e77884, 
-	0x00e779ce, 0x004f7bce, 0x00ef7bc4, 0x00ef7bce, 0x00421c84, 0x00439ce4, 0x00423dce, 0x00e73c84, 
-	0x00e73dce, 0x0047bdee, 0x00e7bde4, 0x00e7bdee, 0x00427c00, 0x0043fce0, 0x004e7f80, 0x004fffe0, 
-	0x004fffe0, 0x00e7fde0, 0x006f7fc0, 0x00efffe0, 0x00007c84, 0x0003fce4, 0x000e7f84, 0x000fffe4, 
-	0x00007dce, 0x0007fdee, 0x000f7fce, 0x000fffee, 0x00427c84, 0x0043fce4, 0x004e7f84, 0x004fffe4, 
-	0x00427dce, 0x00e77c84, 0x00e77dce, 0x0047fdee, 0x004e7fce, 0x00e7fde4, 0x00ef7f84, 0x004fffee, 
-	0x00efffe4, 0x00e7fdee, 0x00ef7fce, 0x00efffee, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
-	0x000f83e0, 0x00a5294a, 0x004e1380, 0x00a57800, 0x00ad0bc0, 0x004390e0, 0x00a53c00, 0x00a5a1e0, 
-	0x000e1384, 0x0000794a, 0x000f0b4a, 0x000390e4, 0x00003d4a, 0x0007a16a, 0x004e1384, 0x00a5694a, 
-	0x00ad2b4a, 0x004390e4, 0x00a52d4a, 0x00a5a16a, 0x004f83e0, 0x00a57c00, 0x00ad83e0, 0x000f83e4, 
-	0x00007d4a, 0x000f836a, 0x004f93e4, 0x00a57d4a, 0x00ad836a, 0x00000000, 0x00000000, 0x00000000, 
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001c00, 0x00001084, 0x00007000, 0x00421000, 
-	0x00039ce0, 0x000039ce, 0x000e7380, 0x00e73800, 0x000e7f80, 0x00e73884, 0x0003fce0, 0x004239ce
+  0x00007c00, 0x000fffe0, 0x00421084, 0x00e739ce, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00427000, 0x004e7380,
+    0x00e77800, 0x00ef7bc0,
+  0x00421c00, 0x00439ce0, 0x00e73c00, 0x00e7bde0, 0x00007084, 0x000e7384,
+    0x000079ce, 0x000f7bce,
+  0x00001c84, 0x00039ce4, 0x00003dce, 0x0007bdee, 0x00427084, 0x004e7384,
+    0x004279ce, 0x00e77884,
+  0x00e779ce, 0x004f7bce, 0x00ef7bc4, 0x00ef7bce, 0x00421c84, 0x00439ce4,
+    0x00423dce, 0x00e73c84,
+  0x00e73dce, 0x0047bdee, 0x00e7bde4, 0x00e7bdee, 0x00427c00, 0x0043fce0,
+    0x004e7f80, 0x004fffe0,
+  0x004fffe0, 0x00e7fde0, 0x006f7fc0, 0x00efffe0, 0x00007c84, 0x0003fce4,
+    0x000e7f84, 0x000fffe4,
+  0x00007dce, 0x0007fdee, 0x000f7fce, 0x000fffee, 0x00427c84, 0x0043fce4,
+    0x004e7f84, 0x004fffe4,
+  0x00427dce, 0x00e77c84, 0x00e77dce, 0x0047fdee, 0x004e7fce, 0x00e7fde4,
+    0x00ef7f84, 0x004fffee,
+  0x00efffe4, 0x00e7fdee, 0x00ef7fce, 0x00efffee, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000,
+  0x000f83e0, 0x00a5294a, 0x004e1380, 0x00a57800, 0x00ad0bc0, 0x004390e0,
+    0x00a53c00, 0x00a5a1e0,
+  0x000e1384, 0x0000794a, 0x000f0b4a, 0x000390e4, 0x00003d4a, 0x0007a16a,
+    0x004e1384, 0x00a5694a,
+  0x00ad2b4a, 0x004390e4, 0x00a52d4a, 0x00a5a16a, 0x004f83e0, 0x00a57c00,
+    0x00ad83e0, 0x000f83e4,
+  0x00007d4a, 0x000f836a, 0x004f93e4, 0x00a57d4a, 0x00ad836a, 0x00000000,
+    0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001c00, 0x00001084,
+    0x00007000, 0x00421000,
+  0x00039ce0, 0x000039ce, 0x000e7380, 0x00e73800, 0x000e7f80, 0x00e73884,
+    0x0003fce0, 0x004239ce
 };
diff --git a/gui/src/terminal/ProcessInfo.cpp b/gui/src/terminal/ProcessInfo.cpp
--- a/gui/src/terminal/ProcessInfo.cpp
+++ b/gui/src/terminal/ProcessInfo.cpp
@@ -48,1007 +48,1083 @@
 #include <sys/proc.h>
 #endif
 //#include <kde_file.h>
 #define KDE_struct_stat struct stat
 #define KDE_stat ::stat
 #endif
 
 #if defined(Q_OS_FREEBSD)
-#include <sys/sysctl.h> //krazy:exclude=includes
+#include <sys/sysctl.h>		//krazy:exclude=includes
 #include <sys/types.h>
 #include <sys/user.h>
 #include <sys/syslimits.h>
 #include <libutil.h>
 #endif
 
-ProcessInfo::ProcessInfo(int pid , bool enableEnvironmentRead)
-    : _fields( ARGUMENTS | ENVIRONMENT ) // arguments and environments
-                                         // are currently always valid,
-                                         // they just return an empty
-                                         // vector / map respectively
-                                         // if no arguments
-                                         // or environment bindings
-                                         // have been explicitly set
-    , _enableEnvironmentRead(enableEnvironmentRead)
-    , _pid(pid)
-    , _parentPid(0)
-    , _foregroundPid(0)
-    , _userId(0)
-    , _lastError(NoError)
-    , _userName(QString())
-    , _userHomeDir(QString())
+ProcessInfo::ProcessInfo (int pid, bool enableEnvironmentRead):
+_fields (ARGUMENTS | ENVIRONMENT)	// arguments and environments
+					 // are currently always valid,
+					 // they just return an empty
+					 // vector / map respectively
+					 // if no arguments
+					 // or environment bindings
+					 // have been explicitly set
+,
+_enableEnvironmentRead (enableEnvironmentRead),
+_pid (pid),
+_parentPid (0),
+_foregroundPid (0),
+_userId (0),
+_lastError (NoError),
+_userName (QString ()),
+_userHomeDir (QString ())
 {
 }
 
-ProcessInfo::Error ProcessInfo::error() const { return _lastError; }
-void ProcessInfo::setError(Error error) { _lastError = error; }
+ProcessInfo::Error ProcessInfo::error () const
+{
+  return _lastError;
+}
 
-void ProcessInfo::update() 
+void
+ProcessInfo::setError (Error error)
 {
-    readProcessInfo(_pid,_enableEnvironmentRead);
+  _lastError = error;
+}
+
+void
+ProcessInfo::update ()
+{
+  readProcessInfo (_pid, _enableEnvironmentRead);
 }
 
-QString ProcessInfo::validCurrentDir() const
+QString
+ProcessInfo::validCurrentDir () const
 {
-   bool ok = false;
+  bool ok = false;
 
-   // read current dir, if an error occurs try the parent as the next
-   // best option
-   int currentPid = parentPid(&ok);
-   QString dir = currentDir(&ok);
-   while ( !ok && currentPid != 0 )
-   {
-       ProcessInfo* current = ProcessInfo::newInstance(currentPid);
-       current->update();
-       currentPid = current->parentPid(&ok); 
-       dir = current->currentDir(&ok);
-       delete current;
-   }
+  // read current dir, if an error occurs try the parent as the next
+  // best option
+  int currentPid = parentPid (&ok);
+  QString dir = currentDir (&ok);
+  while (!ok && currentPid != 0)
+    {
+      ProcessInfo *current = ProcessInfo::newInstance (currentPid);
+      current->update ();
+      currentPid = current->parentPid (&ok);
+      dir = current->currentDir (&ok);
+      delete current;
+    }
 
-   return dir;
+  return dir;
 }
 
-QString ProcessInfo::format(const QString& input) const
+QString
+ProcessInfo::format (const QString & input) const
 {
-   bool ok = false;
+  bool ok = false;
 
-   QString output(input);
+  QString output (input);
 
-   // search for and replace known marker
-   output.replace("%u",userName());
-   output.replace("%n",name(&ok));
-   output.replace("%c",formatCommand(name(&ok),arguments(&ok),ShortCommandFormat));
-   output.replace("%C",formatCommand(name(&ok),arguments(&ok),LongCommandFormat));
-   
-   QString dir = validCurrentDir();
-   if (output.contains("%D"))
-   {
-      QString homeDir = userHomeDir();
+  // search for and replace known marker
+  output.replace ("%u", userName ());
+  output.replace ("%n", name (&ok));
+  output.replace ("%c",
+		  formatCommand (name (&ok), arguments (&ok),
+				 ShortCommandFormat));
+  output.replace ("%C",
+		  formatCommand (name (&ok), arguments (&ok),
+				 LongCommandFormat));
+
+  QString dir = validCurrentDir ();
+  if (output.contains ("%D"))
+    {
+      QString homeDir = userHomeDir ();
       QString tempDir = dir;
       // Change User's Home Dir w/ ~ only at the beginning
-      if (tempDir.startsWith(homeDir))
-      {
-         tempDir.remove(0, homeDir.length());
-         tempDir.prepend('~');
-      }
-      output.replace("%D", tempDir);
-   }
-   output.replace("%d", dir);
-   
-   // remove any remaining %[LETTER] sequences
-   // output.replace(QRegExp("%\\w"), QString());
+      if (tempDir.startsWith (homeDir))
+	{
+	  tempDir.remove (0, homeDir.length ());
+	  tempDir.prepend ('~');
+	}
+      output.replace ("%D", tempDir);
+    }
+  output.replace ("%d", dir);
 
-   return output;
+  // remove any remaining %[LETTER] sequences
+  // output.replace(QRegExp("%\\w"), QString());
+
+  return output;
 }
 
-QString ProcessInfo::formatCommand(const QString& name, 
-                                   const QVector<QString>& arguments,
-                                   CommandFormat format) const
+QString
+ProcessInfo::formatCommand (const QString & name,
+			    const QVector < QString > &arguments,
+			    CommandFormat format) const
 {
-    Q_UNUSED(name);
-    Q_UNUSED(format);
+  Q_UNUSED (name);
+  Q_UNUSED (format);
 
-    // TODO Implement me
-    return QStringList(QList<QString>::fromVector(arguments)).join(" ");
+  // TODO Implement me
+  return QStringList (QList < QString >::fromVector (arguments)).join (" ");
 }
 
-QVector<QString> ProcessInfo::arguments(bool* ok) const
+QVector < QString > ProcessInfo::arguments (bool * ok) const
 {
-    *ok = _fields & ARGUMENTS;
+  *ok = _fields & ARGUMENTS;
 
-    return _arguments;
+  return _arguments;
 }
 
-QMap<QString,QString> ProcessInfo::environment(bool* ok) const
+QMap < QString, QString > ProcessInfo::environment (bool * ok) const
 {
-    *ok = _fields & ENVIRONMENT;
+  *ok = _fields & ENVIRONMENT;
 
-    return _environment;
+  return _environment;
 }
 
-bool ProcessInfo::isValid() const
+bool
+ProcessInfo::isValid () const
 {
-    return _fields & PROCESS_ID;
+  return _fields & PROCESS_ID;
 }
 
-int ProcessInfo::pid(bool* ok) const
+int
+ProcessInfo::pid (bool * ok) const
 {
-    *ok = _fields & PROCESS_ID;
+  *ok = _fields & PROCESS_ID;
 
-    return _pid;
+  return _pid;
 }
 
-int ProcessInfo::parentPid(bool* ok) const
+int
+ProcessInfo::parentPid (bool * ok) const
 {
-    *ok = _fields & PARENT_PID;
+  *ok = _fields & PARENT_PID;
 
-    return _parentPid;
+  return _parentPid;
 }
 
-int ProcessInfo::foregroundPid(bool* ok) const
+int
+ProcessInfo::foregroundPid (bool * ok) const
 {
-    *ok = _fields & FOREGROUND_PID;
+  *ok = _fields & FOREGROUND_PID;
 
-    return _foregroundPid;
+  return _foregroundPid;
 }
 
-QString ProcessInfo::name(bool* ok) const
+QString
+ProcessInfo::name (bool * ok) const
 {
-    *ok = _fields & NAME;
+  *ok = _fields & NAME;
 
-    return _name;
+  return _name;
 }
 
-int ProcessInfo::userId(bool* ok) const
+int
+ProcessInfo::userId (bool * ok) const
 {
-    *ok = _fields & UID;
+  *ok = _fields & UID;
 
-    return _userId;
+  return _userId;
 }
 
-QString ProcessInfo::userName() const
+QString
+ProcessInfo::userName () const
 {
-    return _userName;
+  return _userName;
 }
 
-QString ProcessInfo::userHomeDir() const
+QString
+ProcessInfo::userHomeDir () const
 {
-    return _userHomeDir;
+  return _userHomeDir;
 }
 
-void ProcessInfo::setPid(int pid)
+void
+ProcessInfo::setPid (int pid)
 {
-    _pid = pid;
-    _fields |= PROCESS_ID;
+  _pid = pid;
+  _fields |= PROCESS_ID;
 }
 
-void ProcessInfo::setUserId(int uid)
+void
+ProcessInfo::setUserId (int uid)
 {
-    _userId = uid;
-    _fields |= UID;
+  _userId = uid;
+  _fields |= UID;
 }
 
-void ProcessInfo::setUserName(const QString& name)
+void
+ProcessInfo::setUserName (const QString & name)
 {
-    _userName = name;
-    setUserHomeDir();
+  _userName = name;
+  setUserHomeDir ();
 }
 
-void ProcessInfo::setUserHomeDir()
+void
+ProcessInfo::setUserHomeDir ()
 {
-    QString usersName = userName();
-    // JPS: I don't know a good QT replacement
-    //if (!usersName.isEmpty())
-    //    _userHomeDir = KUser(usersName).homeDir();
-    //else
-        _userHomeDir = QDir::homePath();
+  QString usersName = userName ();
+  // JPS: I don't know a good QT replacement
+  //if (!usersName.isEmpty())
+  //    _userHomeDir = KUser(usersName).homeDir();
+  //else
+  _userHomeDir = QDir::homePath ();
 }
 
-void ProcessInfo::setParentPid(int pid)
+void
+ProcessInfo::setParentPid (int pid)
 {
-    _parentPid = pid;
-    _fields |= PARENT_PID;
+  _parentPid = pid;
+  _fields |= PARENT_PID;
 }
-void ProcessInfo::setForegroundPid(int pid)
+
+void
+ProcessInfo::setForegroundPid (int pid)
 {
-    _foregroundPid = pid;
-    _fields |= FOREGROUND_PID;
+  _foregroundPid = pid;
+  _fields |= FOREGROUND_PID;
+}
+
+QString
+ProcessInfo::currentDir (bool * ok) const
+{
+  if (ok)
+    *ok = _fields & CURRENT_DIR;
+
+  return _currentDir;
 }
 
-QString ProcessInfo::currentDir(bool* ok) const
+void
+ProcessInfo::setCurrentDir (const QString & dir)
 {
-    if (ok)
-        *ok = _fields & CURRENT_DIR;
+  _fields |= CURRENT_DIR;
+  _currentDir = dir;
+}
 
-    return _currentDir;
+void
+ProcessInfo::setName (const QString & name)
+{
+  _name = name;
+  _fields |= NAME;
 }
-void ProcessInfo::setCurrentDir(const QString& dir)
+
+void
+ProcessInfo::addArgument (const QString & argument)
 {
-    _fields |= CURRENT_DIR;
-    _currentDir = dir;
+  _arguments << argument;
 }
 
-void ProcessInfo::setName(const QString& name)
+void
+ProcessInfo::addEnvironmentBinding (const QString & name,
+				    const QString & value)
 {
-    _name = name;
-    _fields |= NAME;
-}
-void ProcessInfo::addArgument(const QString& argument)
-{
-    _arguments << argument;    
+  _environment.insert (name, value);
 }
 
-void ProcessInfo::addEnvironmentBinding(const QString& name , const QString& value)
+void
+ProcessInfo::setFileError (QFile::FileError error)
 {
-    _environment.insert(name,value);
-}
-
-void ProcessInfo::setFileError( QFile::FileError error )
-{
-    switch ( error )
+  switch (error)
     {
-        case PermissionsError:
-            setError( PermissionsError );
-            break;
-        case NoError:
-            setError( NoError );
-            break;
-        default:
-            setError( UnknownError );
+    case PermissionsError:
+      setError (PermissionsError);
+      break;
+    case NoError:
+      setError (NoError);
+      break;
+    default:
+      setError (UnknownError);
     }
 }
 
 //
 // ProcessInfo::newInstance() is way at the bottom so it can see all of the
 // implementations of the UnixProcessInfo abstract class.
 //
 
-NullProcessInfo::NullProcessInfo(int pid,bool enableEnvironmentRead)
-    : ProcessInfo(pid,enableEnvironmentRead)
+NullProcessInfo::NullProcessInfo (int pid, bool enableEnvironmentRead):
+ProcessInfo (pid, enableEnvironmentRead)
 {
 }
 
-bool NullProcessInfo::readProcessInfo(int /*pid*/ , bool /*enableEnvironmentRead*/)
+bool
+NullProcessInfo::readProcessInfo (int /*pid */ ,
+				  bool /*enableEnvironmentRead */ )
 {
-    return false;
+  return false;
 }
 
-void NullProcessInfo::readUserName()
+void
+NullProcessInfo::readUserName ()
 {
 }
 
-UnixProcessInfo::UnixProcessInfo(int pid,bool enableEnvironmentRead)
-    : ProcessInfo(pid,enableEnvironmentRead)
+UnixProcessInfo::UnixProcessInfo (int pid, bool enableEnvironmentRead):
+ProcessInfo (pid, enableEnvironmentRead)
 {
 }
 
-bool UnixProcessInfo::readProcessInfo(int pid , bool enableEnvironmentRead)
+bool
+UnixProcessInfo::readProcessInfo (int pid, bool enableEnvironmentRead)
 {
-    bool ok = readProcInfo(pid);
-    if (ok)
+  bool ok = readProcInfo (pid);
+  if (ok)
     {
-        ok |= readArguments(pid);
-        ok |= readCurrentDir(pid);
-        if ( enableEnvironmentRead )
-        {
-            ok |= readEnvironment(pid);
-        }
+      ok |= readArguments (pid);
+      ok |= readCurrentDir (pid);
+      if (enableEnvironmentRead)
+	{
+	  ok |= readEnvironment (pid);
+	}
     }
-    return ok;
+  return ok;
 }
 
-void UnixProcessInfo::readUserName()
+void
+UnixProcessInfo::readUserName ()
 {
-    bool ok = false;
-    int uid = userId(&ok);
-    if (!ok) return;
+  bool ok = false;
+  int uid = userId (&ok);
+  if (!ok)
+    return;
 
-    struct passwd passwdStruct;
-    struct passwd *getpwResult;
-    char *getpwBuffer;
-    long getpwBufferSize;
-    int getpwStatus;
+  struct passwd passwdStruct;
+  struct passwd *getpwResult;
+  char *getpwBuffer;
+  long getpwBufferSize;
+  int getpwStatus;
 
-    getpwBufferSize = sysconf(_SC_GETPW_R_SIZE_MAX);
-    if (getpwBufferSize == -1)
-        getpwBufferSize = 16384;
+  getpwBufferSize = sysconf (_SC_GETPW_R_SIZE_MAX);
+  if (getpwBufferSize == -1)
+    getpwBufferSize = 16384;
 
-    getpwBuffer = new char[getpwBufferSize];
-    if (getpwBuffer == NULL)
-        return;
-    getpwStatus = getpwuid_r(uid, &passwdStruct, getpwBuffer, getpwBufferSize, &getpwResult);
-    if (getpwResult != NULL)
-        setUserName(QString(passwdStruct.pw_name));
-    else
-        setUserName(QString());
-    delete [] getpwBuffer;
+  getpwBuffer = new char[getpwBufferSize];
+  if (getpwBuffer == NULL)
+    return;
+  getpwStatus =
+    getpwuid_r (uid, &passwdStruct, getpwBuffer, getpwBufferSize,
+		&getpwResult);
+  if (getpwResult != NULL)
+    setUserName (QString (passwdStruct.pw_name));
+  else
+    setUserName (QString ());
+  delete[]getpwBuffer;
 }
 
 
-class LinuxProcessInfo : public UnixProcessInfo
+class LinuxProcessInfo:public UnixProcessInfo
 {
 public:
-    LinuxProcessInfo(int pid, bool env) :
-        UnixProcessInfo(pid,env)
-    {
-    }
+  LinuxProcessInfo (int pid, bool env):UnixProcessInfo (pid, env)
+  {
+  }
 
 private:
-    virtual bool readProcInfo(int pid)
-    {
-        // indicies of various fields within the process status file which
-        // contain various information about the process
-        const int PARENT_PID_FIELD = 3;
-        const int PROCESS_NAME_FIELD = 1;
-        const int GROUP_PROCESS_FIELD = 7;
+    virtual bool readProcInfo (int pid)
+  {
+    // indicies of various fields within the process status file which
+    // contain various information about the process
+    const int PARENT_PID_FIELD = 3;
+    const int PROCESS_NAME_FIELD = 1;
+    const int GROUP_PROCESS_FIELD = 7;
 
-        QString parentPidString;
-        QString processNameString;
-        QString foregroundPidString;
-        QString uidLine;
-        QString uidString;
-        QStringList uidStrings;
+    QString parentPidString;
+    QString processNameString;
+    QString foregroundPidString;
+    QString uidLine;
+    QString uidString;
+    QStringList uidStrings;
 
-        // For user id read process status file ( /proc/<pid>/status )
-        //  Can not use getuid() due to it does not work for 'su'
-        QFile statusInfo( QString("/proc/%1/status").arg(pid) );
-        if ( statusInfo.open(QIODevice::ReadOnly) )
-        {
-            QTextStream stream(&statusInfo);
-            QString statusLine;
-            do {
-                statusLine = stream.readLine(0);
-                if (statusLine.startsWith(QLatin1String("Uid:")))
-                    uidLine = statusLine;
-            } while (!statusLine.isNull() && uidLine.isNull());
+    // For user id read process status file ( /proc/<pid>/status )
+    //  Can not use getuid() due to it does not work for 'su'
+    QFile statusInfo (QString ("/proc/%1/status").arg (pid));
+    if (statusInfo.open (QIODevice::ReadOnly))
+      {
+	QTextStream stream (&statusInfo);
+	QString statusLine;
+	do
+	  {
+	    statusLine = stream.readLine (0);
+	    if (statusLine.startsWith (QLatin1String ("Uid:")))
+	      uidLine = statusLine;
+	  }
+	while (!statusLine.isNull () && uidLine.isNull ());
 
-            uidStrings << uidLine.split('\t', QString::SkipEmptyParts);
-            // Must be 5 entries: 'Uid: %d %d %d %d' and
-            // uid string must be less than 5 chars (uint)
-            if (uidStrings.size() == 5)
-                uidString = uidStrings[1];
-            if (uidString.size() > 5)
-                uidString.clear();
+	uidStrings << uidLine.split ('\t', QString::SkipEmptyParts);
+	// Must be 5 entries: 'Uid: %d %d %d %d' and
+	// uid string must be less than 5 chars (uint)
+	if (uidStrings.size () == 5)
+	  uidString = uidStrings[1];
+	if (uidString.size () > 5)
+	  uidString.clear ();
 
-            bool ok = false;
-            int uid = uidString.toInt(&ok);
-            if (ok)
-                setUserId(uid);
-            readUserName();
-        }
-        else
-        {
-            setFileError( statusInfo.error() );
-            return false;
-        }
+	bool ok = false;
+	int uid = uidString.toInt (&ok);
+	if (ok)
+	  setUserId (uid);
+	readUserName ();
+      }
+    else
+      {
+	setFileError (statusInfo.error ());
+	return false;
+      }
 
 
-        // read process status file ( /proc/<pid/stat )
-        //
-        // the expected file format is a list of fields separated by spaces, using
-        // parenthesies to escape fields such as the process name which may itself contain
-        // spaces:
-        //
-        // FIELD FIELD (FIELD WITH SPACES) FIELD FIELD
-        //
-        QFile processInfo( QString("/proc/%1/stat").arg(pid) );
-        if ( processInfo.open(QIODevice::ReadOnly) )
-        {
-            QTextStream stream(&processInfo);
-            QString data = stream.readAll();
+    // read process status file ( /proc/<pid/stat )
+    //
+    // the expected file format is a list of fields separated by spaces, using
+    // parenthesies to escape fields such as the process name which may itself contain
+    // spaces:
+    //
+    // FIELD FIELD (FIELD WITH SPACES) FIELD FIELD
+    //
+    QFile processInfo (QString ("/proc/%1/stat").arg (pid));
+    if (processInfo.open (QIODevice::ReadOnly))
+      {
+	QTextStream stream (&processInfo);
+	QString data = stream.readAll ();
 
-            int stack = 0;
-            int field = 0;
-            int pos = 0;
+	int stack = 0;
+	int field = 0;
+	int pos = 0;
 
-            while (pos < data.count())
-            {
-                QChar c = data[pos];
+	while (pos < data.count ())
+	  {
+	    QChar c = data[pos];
 
-                if ( c == '(' )
-                    stack++;
-                else if ( c == ')' )
-                    stack--;
-                else if ( stack == 0 && c == ' ' )
-                    field++;
-                else
-                {
-                    switch ( field )
-                    {
-                        case PARENT_PID_FIELD:
-                            parentPidString.append(c);
-                            break;
-                        case PROCESS_NAME_FIELD:
-                            processNameString.append(c);
-                            break;
-                        case GROUP_PROCESS_FIELD:
-                            foregroundPidString.append(c);
-                            break;
-                    }
-                }
+	    if (c == '(')
+	      stack++;
+	    else if (c == ')')
+	      stack--;
+	    else if (stack == 0 && c == ' ')
+	      field++;
+	    else
+	      {
+		switch (field)
+		  {
+		  case PARENT_PID_FIELD:
+		    parentPidString.append (c);
+		    break;
+		  case PROCESS_NAME_FIELD:
+		    processNameString.append (c);
+		    break;
+		  case GROUP_PROCESS_FIELD:
+		    foregroundPidString.append (c);
+		    break;
+		  }
+	      }
 
-                pos++;
-            }
-        }
-        else
-        {
-            setFileError( processInfo.error() );
-            return false;
-        }
+	    pos++;
+	  }
+      }
+    else
+      {
+	setFileError (processInfo.error ());
+	return false;
+      }
 
-        // check that data was read successfully
-        bool ok = false;
-        int foregroundPid = foregroundPidString.toInt(&ok);
-        if (ok)
-            setForegroundPid(foregroundPid);
+    // check that data was read successfully
+    bool ok = false;
+    int foregroundPid = foregroundPidString.toInt (&ok);
+    if (ok)
+      setForegroundPid (foregroundPid);
 
-        int parentPid = parentPidString.toInt(&ok);
-        if (ok)
-            setParentPid(parentPid);
+    int parentPid = parentPidString.toInt (&ok);
+    if (ok)
+      setParentPid (parentPid);
 
-        if (!processNameString.isEmpty())
-            setName(processNameString);
+    if (!processNameString.isEmpty ())
+      setName (processNameString);
 
-        // update object state
-        setPid(pid);
+    // update object state
+    setPid (pid);
 
-        return ok;
-    }
+    return ok;
+  }
 
-    virtual bool readArguments(int pid)
-    {
-        // read command-line arguments file found at /proc/<pid>/cmdline
-        // the expected format is a list of strings delimited by null characters,
-        // and ending in a double null character pair.
+  virtual bool readArguments (int pid)
+  {
+    // read command-line arguments file found at /proc/<pid>/cmdline
+    // the expected format is a list of strings delimited by null characters,
+    // and ending in a double null character pair.
 
-        QFile argumentsFile( QString("/proc/%1/cmdline").arg(pid) );
-        if ( argumentsFile.open(QIODevice::ReadOnly) )
-        {
-            QTextStream stream(&argumentsFile);
-            QString data = stream.readAll();
+    QFile argumentsFile (QString ("/proc/%1/cmdline").arg (pid));
+    if (argumentsFile.open (QIODevice::ReadOnly))
+      {
+	QTextStream stream (&argumentsFile);
+	QString data = stream.readAll ();
 
-            QStringList argList = data.split( QChar('\0') );
+	QStringList argList = data.split (QChar ('\0'));
 
-            foreach ( const QString &entry , argList )
-            {
-                if (!entry.isEmpty())
-                    addArgument(entry);
-            }
-        }
-        else
-        {
-            setFileError( argumentsFile.error() );
-        }
+	foreach (const QString & entry, argList)
+	{
+	  if (!entry.isEmpty ())
+	    addArgument (entry);
+	}
+      }
+    else
+      {
+	setFileError (argumentsFile.error ());
+      }
 
-        return true;
-    }
+    return true;
+  }
 
-    virtual bool readCurrentDir(int pid)
-    {
-        QFileInfo info( QString("/proc/%1/cwd").arg(pid) );
+  virtual bool readCurrentDir (int pid)
+  {
+    QFileInfo info (QString ("/proc/%1/cwd").arg (pid));
 
-        const bool readable = info.isReadable();
+    const bool readable = info.isReadable ();
 
-        if ( readable && info.isSymLink() )
-        {
-            setCurrentDir( info.symLinkTarget() );
-            return true;
-        }
-        else
-        {
-            if ( !readable )
-                setError( PermissionsError );
-            else
-                setError( UnknownError );
+    if (readable && info.isSymLink ())
+      {
+	setCurrentDir (info.symLinkTarget ());
+	return true;
+      }
+    else
+      {
+	if (!readable)
+	  setError (PermissionsError);
+	else
+	  setError (UnknownError);
 
-            return false;
-        }
-    }
+	return false;
+      }
+  }
 
-    virtual bool readEnvironment(int pid)
-    {
-        // read environment bindings file found at /proc/<pid>/environ
-        // the expected format is a list of KEY=VALUE strings delimited by null
-        // characters and ending in a double null character pair.
+  virtual bool readEnvironment (int pid)
+  {
+    // read environment bindings file found at /proc/<pid>/environ
+    // the expected format is a list of KEY=VALUE strings delimited by null
+    // characters and ending in a double null character pair.
 
-        QFile environmentFile( QString("/proc/%1/environ").arg(pid) );
-        if ( environmentFile.open(QIODevice::ReadOnly) )
-        {
-            QTextStream stream(&environmentFile);
-            QString data = stream.readAll();
+    QFile environmentFile (QString ("/proc/%1/environ").arg (pid));
+    if (environmentFile.open (QIODevice::ReadOnly))
+      {
+	QTextStream stream (&environmentFile);
+	QString data = stream.readAll ();
 
-            QStringList bindingList = data.split( QChar('\0') );
+	QStringList bindingList = data.split (QChar ('\0'));
 
-            foreach( const QString &entry , bindingList )
-            {
-                QString name;
-                QString value;
+	foreach (const QString & entry, bindingList)
+	{
+	  QString name;
+	  QString value;
 
-                int splitPos = entry.indexOf('=');
+	  int splitPos = entry.indexOf ('=');
 
-                if ( splitPos != -1 )
-                {
-                    name = entry.mid(0,splitPos);
-                    value = entry.mid(splitPos+1,-1);
+	  if (splitPos != -1)
+	    {
+	      name = entry.mid (0, splitPos);
+	      value = entry.mid (splitPos + 1, -1);
 
-                    addEnvironmentBinding(name,value);
-                }
-            }
-        }
-        else
-        {
-            setFileError( environmentFile.error() );
-        }
+	      addEnvironmentBinding (name, value);
+	    }
+	}
+      }
+    else
+      {
+	setFileError (environmentFile.error ());
+      }
 
-        return true;
-    }
-} ;
+    return true;
+  }
+};
 
 #if defined(Q_OS_FREEBSD)
-class FreeBSDProcessInfo : public UnixProcessInfo
+class FreeBSDProcessInfo:public UnixProcessInfo
 {
 public:
-    FreeBSDProcessInfo(int pid, bool readEnvironment) :
-        UnixProcessInfo(pid, readEnvironment)
-    {
-    }
+  FreeBSDProcessInfo (int pid, bool readEnvironment):UnixProcessInfo (pid,
+								      readEnvironment)
+  {
+  }
 
 private:
-    virtual bool readProcInfo(int pid)
-    {
-        int managementInfoBase[4];
-        size_t mibLength;
-        struct kinfo_proc* kInfoProc;
+    virtual bool readProcInfo (int pid)
+  {
+    int managementInfoBase[4];
+    size_t mibLength;
+    struct kinfo_proc *kInfoProc;
 
-        managementInfoBase[0] = CTL_KERN;
-        managementInfoBase[1] = KERN_PROC;
-        managementInfoBase[2] = KERN_PROC_PID;
-        managementInfoBase[3] = pid;
+    managementInfoBase[0] = CTL_KERN;
+    managementInfoBase[1] = KERN_PROC;
+    managementInfoBase[2] = KERN_PROC_PID;
+    managementInfoBase[3] = pid;
 
-        if (sysctl(managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
-            return false;
+    if (sysctl (managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
+      return false;
 
-        kInfoProc = new struct kinfo_proc [mibLength];
+    kInfoProc = new struct kinfo_proc[mibLength];
 
-        if (sysctl(managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
-        {
-            delete [] kInfoProc;
-            return false;
-        }
+    if (sysctl (managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
+      {
+	delete[]kInfoProc;
+	return false;
+      }
 
 #if defined(__DragonFly__)
-        setName(kInfoProc->kp_comm);
-        setPid(kInfoProc->kp_pid);
-        setParentPid(kInfoProc->kp_ppid);
-        setForegroundPid(kInfoProc->kp_pgid);
-        setUserId(kInfoProc->kp_uid);
+    setName (kInfoProc->kp_comm);
+    setPid (kInfoProc->kp_pid);
+    setParentPid (kInfoProc->kp_ppid);
+    setForegroundPid (kInfoProc->kp_pgid);
+    setUserId (kInfoProc->kp_uid);
 #else
-        setName(kInfoProc->ki_comm);
-        setPid(kInfoProc->ki_pid);
-        setParentPid(kInfoProc->ki_ppid);
-        setForegroundPid(kInfoProc->ki_pgid);
-        setUserId(kInfoProc->ki_uid);
+    setName (kInfoProc->ki_comm);
+    setPid (kInfoProc->ki_pid);
+    setParentPid (kInfoProc->ki_ppid);
+    setForegroundPid (kInfoProc->ki_pgid);
+    setUserId (kInfoProc->ki_uid);
 #endif
 
-        readUserName();
+    readUserName ();
 
-        delete [] kInfoProc;
-        return true;
-    }
+    delete[]kInfoProc;
+    return true;
+  }
 
-    virtual bool readArguments(int pid)
-    {
-        char args[ARG_MAX];
-        int managementInfoBase[4];
-        size_t len;
+  virtual bool readArguments (int pid)
+  {
+    char args[ARG_MAX];
+    int managementInfoBase[4];
+    size_t len;
 
-        managementInfoBase[0] = CTL_KERN;
-        managementInfoBase[1] = KERN_PROC;
-        managementInfoBase[2] = KERN_PROC_PID;
-        managementInfoBase[3] = pid;
+    managementInfoBase[0] = CTL_KERN;
+    managementInfoBase[1] = KERN_PROC;
+    managementInfoBase[2] = KERN_PROC_PID;
+    managementInfoBase[3] = pid;
 
-        len = sizeof(args);
-        if (sysctl(managementInfoBase, 4, args, &len, NULL, 0) == -1)
-            return false;
+    len = sizeof (args);
+    if (sysctl (managementInfoBase, 4, args, &len, NULL, 0) == -1)
+      return false;
+
+    const QStringList argumentList = QString (args).split (QChar ('\0'));
 
-        const QStringList argumentList = QString(args).split(QChar('\0'));
-
-        for (QStringList::const_iterator it = argumentList.begin(); it != argumentList.end(); ++it)
-        {
-            addArgument(*it);
-        }
+    for (QStringList::const_iterator it = argumentList.begin ();
+	 it != argumentList.end (); ++it)
+      {
+	addArgument (*it);
+      }
 
-        return true;
-    }
+    return true;
+  }
 
-    virtual bool readEnvironment(int pid)
-    {
-        // Not supported in FreeBSD?
-        return false;
-    }
+  virtual bool readEnvironment (int pid)
+  {
+    // Not supported in FreeBSD?
+    return false;
+  }
 
-    virtual bool readCurrentDir(int pid)
-    {
+  virtual bool readCurrentDir (int pid)
+  {
 #if defined(__DragonFly__)
-        char buf[PATH_MAX];
-        int managementInfoBase[4];
-        size_t len;
+    char buf[PATH_MAX];
+    int managementInfoBase[4];
+    size_t len;
 
-        managementInfoBase[0] = CTL_KERN;
-        managementInfoBase[1] = KERN_PROC;
-        managementInfoBase[2] = KERN_PROC_CWD;
-        managementInfoBase[3] = pid;
+    managementInfoBase[0] = CTL_KERN;
+    managementInfoBase[1] = KERN_PROC;
+    managementInfoBase[2] = KERN_PROC_CWD;
+    managementInfoBase[3] = pid;
 
-        len = sizeof(buf);
-        if (sysctl(managementInfoBase, 4, buf, &len, NULL, 0) == -1)
-            return false;
+    len = sizeof (buf);
+    if (sysctl (managementInfoBase, 4, buf, &len, NULL, 0) == -1)
+      return false;
 
-        setCurrentDir(buf);
+    setCurrentDir (buf);
 
-        return true;
+    return true;
 #else
-        int numrecords;
-        struct kinfo_file* info = 0;
+    int numrecords;
+    struct kinfo_file *info = 0;
 
-        info = kinfo_getfile(pid, &numrecords);
+    info = kinfo_getfile (pid, &numrecords);
 
-        if (!info)
-            return false;
+    if (!info)
+      return false;
 
-        for (int i = 0; i < numrecords; ++i)
-        {
-            if (info[i].kf_fd == KF_FD_TYPE_CWD)
-            {
-                setCurrentDir(info[i].kf_path);
+    for (int i = 0; i < numrecords; ++i)
+      {
+	if (info[i].kf_fd == KF_FD_TYPE_CWD)
+	  {
+	    setCurrentDir (info[i].kf_path);
 
-                free(info);
-                return true;
-            }
-        }
+	    free (info);
+	    return true;
+	  }
+      }
 
-        free(info);
-        return false;
+    free (info);
+    return false;
 #endif
-    }
-} ;
+  }
+};
 #endif
 
 #if defined(Q_OS_MAC)
-class MacProcessInfo : public UnixProcessInfo
+class MacProcessInfo:public UnixProcessInfo
 {
 public:
-    MacProcessInfo(int pid, bool env) :
-        UnixProcessInfo(pid, env)
-    {
-    }
+  MacProcessInfo (int pid, bool env):UnixProcessInfo (pid, env)
+  {
+  }
 
 private:
-    virtual bool readProcInfo(int pid)
-    {
-        int managementInfoBase[4];
-        size_t mibLength;
-        struct kinfo_proc* kInfoProc;
-        KDE_struct_stat statInfo;
+    virtual bool readProcInfo (int pid)
+  {
+    int managementInfoBase[4];
+    size_t mibLength;
+    struct kinfo_proc *kInfoProc;
+    KDE_struct_stat statInfo;
 
-        // Find the tty device of 'pid' (Example: /dev/ttys001)
-        managementInfoBase[0] = CTL_KERN;
-        managementInfoBase[1] = KERN_PROC;
-        managementInfoBase[2] = KERN_PROC_PID;
-        managementInfoBase[3] = pid;
+    // Find the tty device of 'pid' (Example: /dev/ttys001)
+    managementInfoBase[0] = CTL_KERN;
+    managementInfoBase[1] = KERN_PROC;
+    managementInfoBase[2] = KERN_PROC_PID;
+    managementInfoBase[3] = pid;
 
-        if (sysctl(managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
-        {
-            return false;
-        } 
-        else
-        {
-            kInfoProc = new struct kinfo_proc [mibLength];
-            if (sysctl(managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
-            {
-                delete [] kInfoProc;
-                return false;
-            }
-            else
-            { 
-                QString deviceNumber = QString(devname(((&kInfoProc->kp_eproc)->e_tdev), S_IFCHR));
-                QString fullDeviceName =  QString("/dev/") + deviceNumber.rightJustified(3, '0');
-                delete [] kInfoProc;
+    if (sysctl (managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
+      {
+	return false;
+      }
+    else
+      {
+	kInfoProc = new struct kinfo_proc[mibLength];
+	if (sysctl (managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) ==
+	    -1)
+	  {
+	    delete[]kInfoProc;
+	    return false;
+	  }
+	else
+	  {
+	    QString deviceNumber =
+	      QString (devname (((&kInfoProc->kp_eproc)->e_tdev), S_IFCHR));
+	    QString fullDeviceName =
+	      QString ("/dev/") + deviceNumber.rightJustified (3, '0');
+	    delete[]kInfoProc;
 
-                QByteArray deviceName = fullDeviceName.toLatin1();
-                const char* ttyName = deviceName.data();
+	    QByteArray deviceName = fullDeviceName.toLatin1 ();
+	    const char *ttyName = deviceName.data ();
+
+	    if (KDE_stat (ttyName, &statInfo) != 0)
+	      return false;
 
-                if (KDE_stat(ttyName, &statInfo) != 0)
-                    return false;
+	    // Find all processes attached to ttyName
+	    managementInfoBase[0] = CTL_KERN;
+	    managementInfoBase[1] = KERN_PROC;
+	    managementInfoBase[2] = KERN_PROC_TTY;
+	    managementInfoBase[3] = statInfo.st_rdev;
 
-                // Find all processes attached to ttyName
-                managementInfoBase[0] = CTL_KERN;
-                managementInfoBase[1] = KERN_PROC;
-                managementInfoBase[2] = KERN_PROC_TTY;
-                managementInfoBase[3] = statInfo.st_rdev;
-
-                mibLength = 0;
-                if (sysctl(managementInfoBase, sizeof(managementInfoBase)/sizeof(int), NULL, &mibLength, NULL, 0) == -1)
-                    return false;
+	    mibLength = 0;
+	    if (sysctl
+		(managementInfoBase,
+		 sizeof (managementInfoBase) / sizeof (int), NULL, &mibLength,
+		 NULL, 0) == -1)
+	      return false;
 
-                kInfoProc = new struct kinfo_proc [mibLength];
-                if (sysctl(managementInfoBase, sizeof(managementInfoBase)/sizeof(int), kInfoProc, &mibLength, NULL, 0) == -1)
-                    return false;
+	    kInfoProc = new struct kinfo_proc[mibLength];
+	    if (sysctl
+		(managementInfoBase,
+		 sizeof (managementInfoBase) / sizeof (int), kInfoProc,
+		 &mibLength, NULL, 0) == -1)
+	      return false;
 
-                // The foreground program is the first one
-                setName(QString(kInfoProc->kp_proc.p_comm));
+	    // The foreground program is the first one
+	    setName (QString (kInfoProc->kp_proc.p_comm));
 
-                delete [] kInfoProc;
-            }
-        }
-        return true;
-    }
+	    delete[]kInfoProc;
+	  }
+      }
+    return true;
+  }
 
-    virtual bool readArguments(int pid)
-    {
-        Q_UNUSED(pid);
-        return false;
-    }
-    virtual bool readCurrentDir(int pid)
-    {
-        struct proc_vnodepathinfo vpi;
-        int nb = proc_pidinfo(pid, PROC_PIDVNODEPATHINFO, 0, &vpi, sizeof(vpi));
-        if (nb == sizeof(vpi))
-        {
-            setCurrentDir(QString(vpi.pvi_cdir.vip_path));
-            return true;
-        }
-        return false;
-    }
-    virtual bool readEnvironment(int pid)
-    {
-        Q_UNUSED(pid);
-        return false;
-    }
-} ;
+  virtual bool readArguments (int pid)
+  {
+    Q_UNUSED (pid);
+    return false;
+  }
+  virtual bool readCurrentDir (int pid)
+  {
+    struct proc_vnodepathinfo vpi;
+    int nb = proc_pidinfo (pid, PROC_PIDVNODEPATHINFO, 0, &vpi, sizeof (vpi));
+    if (nb == sizeof (vpi))
+      {
+	setCurrentDir (QString (vpi.pvi_cdir.vip_path));
+	return true;
+      }
+    return false;
+  }
+  virtual bool readEnvironment (int pid)
+  {
+    Q_UNUSED (pid);
+    return false;
+  }
+};
 #endif
 
 #ifdef Q_OS_SOLARIS
     // The procfs structure definition requires off_t to be
     // 32 bits, which only applies if FILE_OFFSET_BITS=32.
     // Futz around here to get it to compile regardless,
     // although some of the structure sizes might be wrong.
     // Fortunately, the structures we actually use don't use
     // off_t, and we're safe.
-    #if defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS==64)
-        #undef _FILE_OFFSET_BITS
-    #endif
-    #include <procfs.h>
+#if defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS==64)
+#undef _FILE_OFFSET_BITS
+#endif
+#include <procfs.h>
 #else
     // On non-Solaris platforms, define a fake psinfo structure
     // so that the SolarisProcessInfo class can be compiled
     //
     // That avoids the trap where you change the API and
     // don't notice it in #ifdeffed platform-specific parts
     // of the code.
-    struct psinfo {
-        int pr_ppid;
-        int pr_pgid;
-        char* pr_fname;
-        char* pr_psargs;
-    } ;
-    static const int PRARGSZ=1;
+struct psinfo
+{
+  int pr_ppid;
+  int pr_pgid;
+  char *pr_fname;
+  char *pr_psargs;
+};
+static const int PRARGSZ = 1;
 #endif
 
-class SolarisProcessInfo : public UnixProcessInfo
+class SolarisProcessInfo:public UnixProcessInfo
 {
 public:
-    SolarisProcessInfo(int pid, bool readEnvironment) 
-    : UnixProcessInfo(pid,readEnvironment)
-    {
-    }
+  SolarisProcessInfo (int pid, bool readEnvironment):UnixProcessInfo (pid,
+								      readEnvironment)
+  {
+  }
 private:
-    virtual bool readProcInfo(int pid)
-    {
-        QFile psinfo( QString("/proc/%1/psinfo").arg(pid) );
-        if ( psinfo.open( QIODevice::ReadOnly ) )
-        {
-            struct psinfo info;
-            if (psinfo.read((char *)&info,sizeof(info)) != sizeof(info))
-            {
-                return false;
-            }
+    virtual bool readProcInfo (int pid)
+  {
+    QFile psinfo (QString ("/proc/%1/psinfo").arg (pid));
+    if (psinfo.open (QIODevice::ReadOnly))
+      {
+	struct psinfo info;
+	if (psinfo.read ((char *) &info, sizeof (info)) != sizeof (info))
+	  {
+	    return false;
+	  }
+
+	setParentPid (info.pr_ppid);
+	setForegroundPid (info.pr_pgid);
+	setName (info.pr_fname);
+	setPid (pid);
+
+	// Bogus, because we're treating the arguments as one single string
+	info.pr_psargs[PRARGSZ - 1] = 0;
+	addArgument (info.pr_psargs);
+      }
+    return true;
+  }
+
+  virtual bool readArguments (int /*pid */ )
+  {
+    // Handled in readProcInfo()
+    return false;
+  }
+
+  virtual bool readEnvironment (int /*pid */ )
+  {
+    // Not supported in Solaris
+    return false;
+  }
 
-            setParentPid(info.pr_ppid);
-            setForegroundPid(info.pr_pgid);
-            setName(info.pr_fname);
-            setPid(pid);
+  virtual bool readCurrentDir (int pid)
+  {
+    QFileInfo info (QString ("/proc/%1/path/cwd").arg (pid));
+    const bool readable = info.isReadable ();
+
+    if (readable && info.isSymLink ())
+      {
+	setCurrentDir (info.symLinkTarget ());
+	return true;
+      }
+    else
+      {
+	if (!readable)
+	  setError (PermissionsError);
+	else
+	  setError (UnknownError);
 
-            // Bogus, because we're treating the arguments as one single string
-            info.pr_psargs[PRARGSZ-1]=0;
-            addArgument(info.pr_psargs);
-        }
-        return true;
-    }
+	return false;
+      }
+  }
+};
 
-    virtual bool readArguments(int /*pid*/)
+SSHProcessInfo::SSHProcessInfo (const ProcessInfo & process):_process (process)
+{
+  bool
+    ok = false;
+
+  // check that this is a SSH process
+  const
+    QString &
+    name = _process.name (&ok);
+
+  if (!ok || name != "ssh")
     {
-        // Handled in readProcInfo()
-        return false;
-    }
+      //if ( !ok )
+      //    kWarning() << "Could not read process info";
+      //else
+      //    kWarning() << "Process is not a SSH process";
 
-    virtual bool readEnvironment(int /*pid*/)
-    {
-        // Not supported in Solaris
-        return false;
+      return;
     }
 
-    virtual bool readCurrentDir(int pid)
-    {
-        QFileInfo info( QString("/proc/%1/path/cwd").arg(pid) );
-        const bool readable = info.isReadable();
+  // read arguments
+  const
+    QVector <
+  QString > &
+    args = _process.arguments (&ok);
 
-        if ( readable && info.isSymLink() )
-        {
-            setCurrentDir( info.symLinkTarget() );
-            return true;
-        }
-        else
-        {
-            if ( !readable )
-                setError( PermissionsError );
-            else
-                setError( UnknownError );
-
-            return false;
-        }
-    }
-} ;
+  // SSH options
+  // these are taken from the SSH manual ( accessed via 'man ssh' )
 
-SSHProcessInfo::SSHProcessInfo(const ProcessInfo& process)
- : _process(process)
-{
-    bool ok = false;
-
-    // check that this is a SSH process
-    const QString& name = _process.name(&ok);
-
-    if ( !ok || name != "ssh" )
-    {
-        //if ( !ok )
-        //    kWarning() << "Could not read process info";
-        //else
-        //    kWarning() << "Process is not a SSH process";
+  // options which take no arguments
+  static const QString
+  noOptionsArguments ("1246AaCfgkMNnqsTtVvXxY");
+  // options which take one argument
+  static const QString
+  singleOptionArguments ("bcDeFiLlmOopRSw");
 
-        return;
-    }
-
-    // read arguments
-    const QVector<QString>& args = _process.arguments(&ok); 
-
-    // SSH options
-    // these are taken from the SSH manual ( accessed via 'man ssh' )
-    
-    // options which take no arguments
-    static const QString noOptionsArguments("1246AaCfgkMNnqsTtVvXxY"); 
-    // options which take one argument
-    static const QString singleOptionArguments("bcDeFiLlmOopRSw");
-
-    if ( ok )
+  if (ok)
     {
-         // find the username, host and command arguments
-         //
-         // the username/host is assumed to be the first argument 
-         // which is not an option
-         // ( ie. does not start with a dash '-' character )
-         // or an argument to a previous option.
-         //
-         // the command, if specified, is assumed to be the argument following
-         // the username and host
-         //
-         // note that we skip the argument at index 0 because that is the
-         // program name ( expected to be 'ssh' in this case )
-         for ( int i = 1 ; i < args.count() ; i++ )
-         {
-            // if this argument is an option then skip it, plus any 
-            // following arguments which refer to this option
-            if ( args[i].startsWith('-') )
-            {
-                QChar argChar = ( args[i].length() > 1 ) ? args[i][1] : '\0';
+      // find the username, host and command arguments
+      //
+      // the username/host is assumed to be the first argument 
+      // which is not an option
+      // ( ie. does not start with a dash '-' character )
+      // or an argument to a previous option.
+      //
+      // the command, if specified, is assumed to be the argument following
+      // the username and host
+      //
+      // note that we skip the argument at index 0 because that is the
+      // program name ( expected to be 'ssh' in this case )
+      for (int i = 1; i < args.count (); i++)
+	{
+	  // if this argument is an option then skip it, plus any 
+	  // following arguments which refer to this option
+	  if (args[i].startsWith ('-'))
+	    {
+	      QChar
+		argChar = (args[i].length () > 1) ? args[i][1] : '\0';
 
-                if ( noOptionsArguments.contains(argChar) )
-                    continue;
-                else if ( singleOptionArguments.contains(argChar) )
-                {
-                    i++;
-                    continue;
-                }
-            }
+	      if (noOptionsArguments.contains (argChar))
+		continue;
+	      else if (singleOptionArguments.contains (argChar))
+		{
+		  i++;
+		  continue;
+		}
+	    }
 
-            // check whether the host has been found yet
-            // if not, this must be the username/host argument 
-            if ( _host.isEmpty() )
-            {
-                // check to see if only a hostname is specified, or whether
-                // both a username and host are specified ( in which case they
-                // are separated by an '@' character:  username@host )
-            
-                int separatorPosition = args[i].indexOf('@');
-                if ( separatorPosition != -1 )
-                {
-                    // username and host specified
-                    _user = args[i].left(separatorPosition);
-                    _host = args[i].mid(separatorPosition+1);
-                }
-                else
-                {
-                    // just the host specified
-                    _host = args[i];
-                }
-            }
-            else
-            {
-                // host has already been found, this must be the command argument
-                _command = args[i];
-            }
+	  // check whether the host has been found yet
+	  // if not, this must be the username/host argument 
+	  if (_host.isEmpty ())
+	    {
+	      // check to see if only a hostname is specified, or whether
+	      // both a username and host are specified ( in which case they
+	      // are separated by an '@' character:  username@host )
 
-         }
+	      int
+		separatorPosition = args[i].indexOf ('@');
+	      if (separatorPosition != -1)
+		{
+		  // username and host specified
+		  _user = args[i].left (separatorPosition);
+		  _host = args[i].mid (separatorPosition + 1);
+		}
+	      else
+		{
+		  // just the host specified
+		  _host = args[i];
+		}
+	    }
+	  else
+	    {
+	      // host has already been found, this must be the command argument
+	      _command = args[i];
+	    }
+
+	}
     }
-    else
+  else
     {
-        //kWarning() << "Could not read arguments";
-        
-        return;
+      //kWarning() << "Could not read arguments";
+
+      return;
     }
 }
 
-QString SSHProcessInfo::userName() const
-{
-    return _user;
-}
-QString SSHProcessInfo::host() const
-{
-    return _host;
-}
-QString SSHProcessInfo::command() const
-{
-    return _command;
-}
-QString SSHProcessInfo::format(const QString& input) const
+QString
+SSHProcessInfo::userName () const
 {
-    QString output(input);
-   
-    // test whether host is an ip address
-    // in which case 'short host' and 'full host'
-    // markers in the input string are replaced with
-    // the full address
-    bool isIpAddress = false;
-   
-    struct in_addr address;
-    if ( inet_aton(_host.toLocal8Bit().constData(),&address) != 0 )
-        isIpAddress = true;
-    else
-        isIpAddress = false;
+  return _user;
+}
 
-    // search for and replace known markers
-    output.replace("%u",_user);
+QString
+SSHProcessInfo::host () const
+{
+  return _host;
+}
 
-    if ( isIpAddress )
-        output.replace("%h",_host);
-    else
-        output.replace("%h",_host.left(_host.indexOf('.')));
-    
-    output.replace("%H",_host);
-    output.replace("%c",_command);
-
-    return output;
+QString
+SSHProcessInfo::command () const
+{
+  return _command;
 }
 
-ProcessInfo* ProcessInfo::newInstance(int pid,bool enableEnvironmentRead)
+QString
+SSHProcessInfo::format (const QString & input) const
+{
+  QString output (input);
+
+  // test whether host is an ip address
+  // in which case 'short host' and 'full host'
+  // markers in the input string are replaced with
+  // the full address
+  bool isIpAddress = false;
+
+  struct in_addr address;
+  if (inet_aton (_host.toLocal8Bit ().constData (), &address) != 0)
+    isIpAddress = true;
+  else
+    isIpAddress = false;
+
+  // search for and replace known markers
+  output.replace ("%u", _user);
+
+  if (isIpAddress)
+    output.replace ("%h", _host);
+  else
+    output.replace ("%h", _host.left (_host.indexOf ('.')));
+
+  output.replace ("%H", _host);
+  output.replace ("%c", _command);
+
+  return output;
+}
+
+ProcessInfo *
+ProcessInfo::newInstance (int pid, bool enableEnvironmentRead)
 {
 #ifdef Q_OS_LINUX
-    return new LinuxProcessInfo(pid,enableEnvironmentRead);
+  return new LinuxProcessInfo (pid, enableEnvironmentRead);
 #elif defined(Q_OS_SOLARIS)
-    return new SolarisProcessInfo(pid,enableEnvironmentRead);
+  return new SolarisProcessInfo (pid, enableEnvironmentRead);
 #elif defined(Q_OS_MAC)
-    return new MacProcessInfo(pid,enableEnvironmentRead);
+  return new MacProcessInfo (pid, enableEnvironmentRead);
 #elif defined(Q_OS_FREEBSD)
-    return new FreeBSDProcessInfo(pid,enableEnvironmentRead);
+  return new FreeBSDProcessInfo (pid, enableEnvironmentRead);
 #else
-    return new NullProcessInfo(pid,enableEnvironmentRead);
+  return new NullProcessInfo (pid, enableEnvironmentRead);
 #endif
 }
-
diff --git a/gui/src/terminal/ProcessInfo.h b/gui/src/terminal/ProcessInfo.h
--- a/gui/src/terminal/ProcessInfo.h
+++ b/gui/src/terminal/ProcessInfo.h
@@ -78,97 +78,99 @@ public:
      *
      * @param pid The pid of the process to examine
      * @param readEnvironment Specifies whether environment bindings should
      * be read.  If this is false, then environment() calls will
      * always fail.  This is an optimization to avoid the overhead
      * of reading the (potentially large) environment data when it
      * is not required. 
      */
-    static ProcessInfo* newInstance(int pid,bool readEnvironment = false);
+  static ProcessInfo *newInstance (int pid, bool readEnvironment = false);
 
-    virtual ~ProcessInfo() {}
+    virtual ~ ProcessInfo ()
+  {
+  }
 
     /** 
      * Updates the information about the process.  This must
      * be called before attempting to use any of the accessor methods.
      */
-    void update();
+  void update ();
 
-    /** Returns true if the process state was read successfully. */ 
-    bool isValid() const;
+    /** Returns true if the process state was read successfully. */
+  bool isValid () const;
     /** 
      * Returns the process id.  
      *
      * @param ok Set to true if the process id was read successfully or false otherwise 
      */
-    int pid(bool* ok) const;
+  int pid (bool * ok) const;
     /** 
      * Returns the id of the parent process id was read successfully or false otherwise
      * 
      * @param ok Set to true if the parent process id
      */
-    int parentPid(bool* ok) const;
-    
+  int parentPid (bool * ok) const;
+
     /** 
      * Returns the id of the current foreground process 
      *
      * NOTE:  Using the foregroundProcessGroup() method of the Pty
      * instance associated with the terminal of interest is preferred
      * over using this method.
      *
      * @param ok Set to true if the foreground process id was read successfully or false otherwise
      */
-    int foregroundPid(bool* ok) const;
-    
-    /* Returns the user id of the process */
-    int userId(bool* ok) const;
+  int foregroundPid (bool * ok) const;
+
+  /* Returns the user id of the process */
+  int userId (bool * ok) const;
 
     /** Returns the user's name of the process */
-    QString userName() const;
-   
+  QString userName () const;
+
     /** Returns the user's home directory of the process */
-    QString userHomeDir() const;
+  QString userHomeDir () const;
 
     /** Returns the name of the current process */
-    QString name(bool* ok) const;
-   
+  QString name (bool * ok) const;
+
     /** 
      * Returns the command-line arguments which the process
      * was started with.
      *
      * The first argument is the name used to launch the process.
      *
      * @param ok Set to true if the arguments were read successfully or false otherwise.
      */
-    QVector<QString> arguments(bool* ok) const;
+  QVector < QString > arguments (bool * ok) const;
     /**
      * Returns the environment bindings which the process
      * was started with.
      * In the returned map, the key is the name of the environment variable,
      * and the value is the corresponding value.
      *
      * @param ok Set to true if the environment bindings were read successfully or false otherwise
      */
-    QMap<QString,QString> environment(bool* ok) const;
+  QMap < QString, QString > environment (bool * ok) const;
 
     /**
      * Returns the current working directory of the process
      *
      * @param ok Set to true if the current working directory was read successfully or false otherwise
      */
-    QString currentDir(bool* ok) const;
+  QString currentDir (bool * ok) const;
 
     /**
      * Returns the current working directory of the process (or its parent)
      */
-    QString validCurrentDir() const;
+  QString validCurrentDir () const;
 
     /** Forces the user home directory to be calculated */
-    void setUserHomeDir();
+  void setUserHomeDir ();
 
     /**
      * Parses an input string, looking for markers beginning with a '%' 
      * character and returns a string with the markers replaced
      * with information from this process description.
      * <br>
      * The markers recognised are:
      * <ul>
@@ -178,45 +180,45 @@ public:
      *      process' current working directory.
      *      
      *      (eg. if the current directory is '/home/bob' then
      *      'bob' would be returned)
      * </li>
      * <li> %D - Replaced with the current working directory of the process. </li>
      * </ul>
      */
-    QString format(const QString& text) const;
+  QString format (const QString & text) const;
 
     /** 
      * This enum describes the errors which can occur when trying to read 
      * a process's information.
      */
-    enum Error
-    {
-        /** No error occurred. */
-        NoError,
-        /** The nature of the error is unknown. */
-        UnknownError,
-        /** Konsole does not have permission to obtain the process information. */
-        PermissionsError
-    };
+  enum Error
+  {
+	/** No error occurred. */
+    NoError,
+	/** The nature of the error is unknown. */
+    UnknownError,
+	/** Konsole does not have permission to obtain the process information. */
+    PermissionsError
+  };
 
     /**
      * Returns the last error which occurred.
      */
-    Error error() const;
+  Error error () const;
 
 protected:
     /**
      * Constructs a new process instance.  You should not call the constructor
      * of ProcessInfo or its subclasses directly.  Instead use the 
      * static ProcessInfo::newInstance() method which will return
      * a suitable ProcessInfo instance for the current platform.
-     */ 
-    explicit ProcessInfo(int pid , bool readEnvironment = false);
+     */
+  explicit ProcessInfo (int pid, bool readEnvironment = false);
 
     /** 
      * This is called on construction to read the process state 
      * Subclasses should reimplement this function to provide
      * platform-specific process state reading functionality.
      *
      * When called, readProcessInfo() should attempt to read all
      * of the necessary state information.  If the attempt is successful,
@@ -226,225 +228,226 @@ protected:
      *
      * Calls to isValid() will return true only if the process id
      * has been set using setPid()
      *
      * @param pid The process id of the process to read
      * @param readEnvironment Specifies whether the environment bindings
      *                        for the process should be read
      */
-    virtual bool readProcessInfo(int pid , bool readEnvironment) = 0;
+  virtual bool readProcessInfo (int pid, bool readEnvironment) = 0;
 
-    /* Read the user name */
-    virtual void readUserName(void) = 0;
+  /* Read the user name */
+  virtual void readUserName (void) = 0;
 
     /** Sets the process id associated with this ProcessInfo instance */
-    void setPid(int pid);
+  void setPid (int pid);
     /** Sets the parent process id as returned by parentPid() */
-    void setParentPid(int pid);
+  void setParentPid (int pid);
     /** Sets the foreground process id as returend by foregroundPid() */
-    void setForegroundPid(int pid);
+  void setForegroundPid (int pid);
     /** Sets the user id associated with this ProcessInfo instance */
-    void setUserId(int uid);
+  void setUserId (int uid);
     /** Sets the user name of the process as set by readUserName() */
-    void setUserName(const QString& name);
+  void setUserName (const QString & name);
     /** Sets the name of the process as returned by name() */
-    void setName(const QString& name);
+  void setName (const QString & name);
     /** Sets the current working directory for the process */
-    void setCurrentDir(const QString& dir);
+  void setCurrentDir (const QString & dir);
 
     /** Sets the error */
-    void setError( Error error );
+  void setError (Error error);
 
-    /** Convenience method.  Sets the error based on a QFile error code. */ 
-    void setFileError( QFile::FileError error ); 
+    /** Convenience method.  Sets the error based on a QFile error code. */
+  void setFileError (QFile::FileError error);
 
     /** 
      * Adds a commandline argument for the process, as returned
      * by arguments()
      */
-    void addArgument(const QString& argument);
+  void addArgument (const QString & argument);
     /**
      * Adds an environment binding for the process, as returned by
      * environment()
      *
      * @param name The name of the environment variable, eg. "PATH"
      * @param value The value of the environment variable, eg. "/bin"
      */
-    void addEnvironmentBinding(const QString& name , const QString& value);
+  void addEnvironmentBinding (const QString & name, const QString & value);
 
 private:
-    enum CommandFormat
-    {
-        ShortCommandFormat,
-        LongCommandFormat
-    };
-    // takes a process name and its arguments and produces formatted output
-    QString formatCommand(const QString& name , const QVector<QString>& arguments , 
-                          CommandFormat format) const;
+  enum CommandFormat
+  {
+    ShortCommandFormat,
+    LongCommandFormat
+  };
+  // takes a process name and its arguments and produces formatted output
+  QString formatCommand (const QString & name,
+			 const QVector < QString > &arguments,
+			 CommandFormat format) const;
 
-    // valid bits for _fields variable, ensure that
-    // _fields is changed to an int if more than 8 fields are added
-    enum FIELD_BITS
-    {
-        PROCESS_ID          = 1,
-        PARENT_PID          = 2,
-        FOREGROUND_PID      = 4,
-        ARGUMENTS           = 8,
-        ENVIRONMENT         = 16,
-        NAME                = 32,
-        CURRENT_DIR         = 64,
-        UID                 =128 
-    };
+  // valid bits for _fields variable, ensure that
+  // _fields is changed to an int if more than 8 fields are added
+  enum FIELD_BITS
+  {
+    PROCESS_ID = 1,
+    PARENT_PID = 2,
+    FOREGROUND_PID = 4,
+    ARGUMENTS = 8,
+    ENVIRONMENT = 16,
+    NAME = 32,
+    CURRENT_DIR = 64,
+    UID = 128
+  };
 
-    char _fields; // a bitmap indicating which fields are valid
-                  // used to set the "ok" parameters for the public
-                  // accessor functions
+  char _fields;			// a bitmap indicating which fields are valid
+  // used to set the "ok" parameters for the public
+  // accessor functions
 
-    bool _enableEnvironmentRead; // specifies whether to read the environment
-                                 // bindings when update() is called
-    int _pid;  
-    int _parentPid;
-    int _foregroundPid;
-    int _userId;  
+  bool _enableEnvironmentRead;	// specifies whether to read the environment
+  // bindings when update() is called
+  int _pid;
+  int _parentPid;
+  int _foregroundPid;
+  int _userId;
 
-    Error _lastError;
+  Error _lastError;
 
-    QString _name;
-    QString _userName;
-    QString _userHomeDir;
-    QString _currentDir;
+  QString _name;
+  QString _userName;
+  QString _userHomeDir;
+  QString _currentDir;
 
-    QVector<QString> _arguments;
-    QMap<QString,QString> _environment;
+  QVector < QString > _arguments;
+  QMap < QString, QString > _environment;
 };
 
 /** 
  * Implementation of ProcessInfo which does nothing.
  * Used on platforms where a suitable ProcessInfo subclass is not 
  * available.
  *
  * isValid() will always return false for instances of NullProcessInfo
  */
-class NullProcessInfo : public ProcessInfo
+class NullProcessInfo:public ProcessInfo
 {
 public:
     /** 
      * Constructs a new NullProcessInfo instance.
      * See ProcessInfo::newInstance()
      */
-    explicit NullProcessInfo(int pid,bool readEnvironment = false);
+  explicit NullProcessInfo (int pid, bool readEnvironment = false);
 protected:
-    virtual bool readProcessInfo(int pid,bool readEnvironment);
-    virtual void readUserName(void);
+    virtual bool readProcessInfo (int pid, bool readEnvironment);
+  virtual void readUserName (void);
 };
 
 /**
  * Implementation of ProcessInfo for Unix platforms which uses
  * the /proc filesystem
  */
-class UnixProcessInfo : public ProcessInfo
+class UnixProcessInfo:public ProcessInfo
 {
 public:
     /** 
      * Constructs a new instance of UnixProcessInfo.
      * See ProcessInfo::newInstance()
      */
-    explicit UnixProcessInfo(int pid,bool readEnvironment = false);
+  explicit UnixProcessInfo (int pid, bool readEnvironment = false);
 
 protected:
     /** 
      * Implementation of ProcessInfo::readProcessInfo(); calls the
      * four private methods below in turn.
      */
-    virtual bool readProcessInfo(int pid , bool readEnvironment);
+    virtual bool readProcessInfo (int pid, bool readEnvironment);
 
-    virtual void readUserName(void);
+  virtual void readUserName (void);
 
 private:
     /**
      * Read the standard process information -- PID, parent PID, foreground PID.
      * @param pid process ID to use
      * @return true on success
      */
-    virtual bool readProcInfo(int pid)=0;
+    virtual bool readProcInfo (int pid) = 0;
 
     /**
      * Read the environment of the process. Sets _environment.
      * @param pid process ID to use
      * @return true on success
      */
-    virtual bool readEnvironment(int pid)=0;
+  virtual bool readEnvironment (int pid) = 0;
 
     /**
      * Determine what arguments were passed to the process. Sets _arguments.
      * @param pid process ID to use
      * @return true on success
      */
-    virtual bool readArguments(int pid)=0;
+  virtual bool readArguments (int pid) = 0;
 
     /**
      * Determine the current directory of the process.
      * @param pid process ID to use
      * @return true on success
      */
-    virtual bool readCurrentDir(int pid)=0;
+  virtual bool readCurrentDir (int pid) = 0;
 };
 
 /** 
  * Lightweight class which provides additional information about SSH processes.
  */
 class SSHProcessInfo
 {
 public:
     /** 
      * Constructs a new SSHProcessInfo instance which provides additional
      * information about the specified SSH process.
      *
      * @param process A ProcessInfo instance for a SSH process.
      */
-    SSHProcessInfo(const ProcessInfo& process);
+  SSHProcessInfo (const ProcessInfo & process);
 
     /** 
      * Returns the user name which the user initially logged into on
      * the remote computer.
      */
-    QString userName() const;
+  QString userName () const;
 
     /**
      * Returns the host which the user has connected to.
      */
-    QString host() const;
+  QString host () const;
 
     /** 
      * Returns the command which the user specified to execute on the 
      * remote computer when starting the SSH process.
      */
-    QString command() const;
+  QString command () const;
 
     /**
      * Operates in the same way as ProcessInfo::format(), except
      * that the set of markers understood is different:
      *
      * %u - Replaced with user name which the user initially logged
      *      into on the remote computer.
      * %h - Replaced with the first part of the host name which
      *      is connected to.
      * %H - Replaced with the full host name of the computer which
      *      is connected to.
      * %c - Replaced with the command which the user specified
      *      to execute when starting the SSH process.
      */
-    QString format(const QString& input) const;
+  QString format (const QString & input) const;
 
 private:
-    const ProcessInfo& _process;
-    QString _user;
-    QString _host;
-    QString _command;
+  const ProcessInfo & _process;
+  QString _user;
+  QString _host;
+  QString _command;
 };
 
 #endif //PROCESSINFO_H
 
 /*
   Local Variables:
   mode: c++
   c-file-style: "stroustrup"
diff --git a/gui/src/terminal/Pty.cpp b/gui/src/terminal/Pty.cpp
--- a/gui/src/terminal/Pty.cpp
+++ b/gui/src/terminal/Pty.cpp
@@ -33,278 +33,296 @@
 
 // Qt
 #include <QtCore/QStringList>
 
 #include "kpty.h"
 #include "kptydevice.h"
 
 
-void Pty::setWindowSize(int lines, int cols)
+void
+Pty::setWindowSize (int lines, int cols)
 {
   _windowColumns = cols;
   _windowLines = lines;
 
-  if (pty()->masterFd() >= 0)
-    pty()->setWinSize(lines, cols);
-}
-QSize Pty::windowSize() const
-{
-    return QSize(_windowColumns,_windowLines);
+  if (pty ()->masterFd () >= 0)
+    pty ()->setWinSize (lines, cols);
 }
 
-void Pty::setFlowControlEnabled(bool enable)
+QSize
+Pty::windowSize () const
+{
+  return QSize (_windowColumns, _windowLines);
+}
+
+void
+Pty::setFlowControlEnabled (bool enable)
 {
   _xonXoff = enable;
 
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-    pty()->tcGetAttr(&ttmode);
-    if (!enable)
-      ttmode.c_iflag &= ~(IXOFF | IXON);
-    else
-      ttmode.c_iflag |= (IXOFF | IXON);
-    //if (!pty()->tcSetAttr(&ttmode))
-    //  kWarning() << "Unable to set terminal attributes.";
-  }
-}
-bool Pty::flowControlEnabled() const
-{
-    if (pty()->masterFd() >= 0)
+  if (pty ()->masterFd () >= 0)
     {
-        struct ::termios ttmode;
-        pty()->tcGetAttr(&ttmode);
-        return ttmode.c_iflag & IXOFF &&
-               ttmode.c_iflag & IXON;
-    }  
-    //kWarning() << "Unable to get flow control status, terminal not connected.";
-    return false;
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      if (!enable)
+	ttmode.c_iflag &= ~(IXOFF | IXON);
+      else
+	ttmode.c_iflag |= (IXOFF | IXON);
+      //if (!pty()->tcSetAttr(&ttmode))
+      //  kWarning() << "Unable to set terminal attributes.";
+    }
 }
 
-void Pty::setUtf8Mode(bool enable)
+bool
+Pty::flowControlEnabled () const
 {
-#ifdef IUTF8 // XXX not a reasonable place to check it.
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      return ttmode.c_iflag & IXOFF && ttmode.c_iflag & IXON;
+    }
+  //kWarning() << "Unable to get flow control status, terminal not connected.";
+  return false;
+}
+
+void
+Pty::setUtf8Mode (bool enable)
+{
+#ifdef IUTF8			// XXX not a reasonable place to check it.
   _utf8 = enable;
 
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-    pty()->tcGetAttr(&ttmode);
-    if (!enable)
-      ttmode.c_iflag &= ~IUTF8;
-    else
-      ttmode.c_iflag |= IUTF8;
-   // if (!pty()->tcSetAttr(&ttmode))
-    //  kWarning() << "Unable to set terminal attributes.";
-  }
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      if (!enable)
+	ttmode.c_iflag &= ~IUTF8;
+      else
+	ttmode.c_iflag |= IUTF8;
+      // if (!pty()->tcSetAttr(&ttmode))
+      //  kWarning() << "Unable to set terminal attributes.";
+    }
 #endif
 }
 
-void Pty::setErase(char erase)
+void
+Pty::setErase (char erase)
 {
   _eraseChar = erase;
-  
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-    pty()->tcGetAttr(&ttmode);
-    ttmode.c_cc[VERASE] = erase;
-    //if (!pty()->tcSetAttr(&ttmode))
-    //  kWarning() << "Unable to set terminal attributes.";
-  }
-}
 
-char Pty::erase() const
-{
-    if (pty()->masterFd() >= 0)
+  if (pty ()->masterFd () >= 0)
     {
-        struct ::termios ttyAttributes;
-        pty()->tcGetAttr(&ttyAttributes);
-        return ttyAttributes.c_cc[VERASE];
-    }
-
-    return _eraseChar;
-}
-
-void Pty::addEnvironmentVariables(const QStringList& environment)
-{
-    QListIterator<QString> iter(environment);
-    while (iter.hasNext())
-    {
-        QString pair = iter.next();
-
-        // split on the first '=' character
-        int pos = pair.indexOf('=');
-        
-        if ( pos >= 0 )
-        {
-            QString variable = pair.left(pos);
-            QString value = pair.mid(pos+1);
-
-            setEnv(variable,value);
-        }
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      ttmode.c_cc[VERASE] = erase;
+      //if (!pty()->tcSetAttr(&ttmode))
+      //  kWarning() << "Unable to set terminal attributes.";
     }
 }
 
-int Pty::start(const QString& program, 
-               const QStringList& programArguments, 
-               const QStringList& environment, 
-               ulong winid, 
-               bool addToUtmp,
-               const QString& dbusService, 
-               const QString& dbusSession)
+char
+Pty::erase () const
+{
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttyAttributes;
+      pty ()->tcGetAttr (&ttyAttributes);
+      return ttyAttributes.c_cc[VERASE];
+    }
+
+  return _eraseChar;
+}
+
+void
+Pty::addEnvironmentVariables (const QStringList & environment)
 {
-  clearProgram();
+  QListIterator < QString > iter (environment);
+  while (iter.hasNext ())
+    {
+      QString pair = iter.next ();
+
+      // split on the first '=' character
+      int pos = pair.indexOf ('=');
+
+      if (pos >= 0)
+	{
+	  QString variable = pair.left (pos);
+	  QString value = pair.mid (pos + 1);
+
+	  setEnv (variable, value);
+	}
+    }
+}
+
+int
+Pty::start (const QString & program,
+	    const QStringList & programArguments,
+	    const QStringList & environment,
+	    ulong winid,
+	    bool addToUtmp,
+	    const QString & dbusService, const QString & dbusSession)
+{
+  clearProgram ();
 
   // For historical reasons, the first argument in programArguments is the 
   // name of the program to execute, so create a list consisting of all
   // but the first argument to pass to setProgram()
-  Q_ASSERT(programArguments.count() >= 1);
-  setProgram(program.toLatin1(),programArguments.mid(1));
+  Q_ASSERT (programArguments.count () >= 1);
+  setProgram (program.toLatin1 (), programArguments.mid (1));
 
-  addEnvironmentVariables(environment);
+  addEnvironmentVariables (environment);
 
-  if ( !dbusService.isEmpty() )
-     setEnv("KONSOLE_DBUS_SERVICE",dbusService);
-  if ( !dbusSession.isEmpty() )
-     setEnv("KONSOLE_DBUS_SESSION", dbusSession);
+  if (!dbusService.isEmpty ())
+    setEnv ("KONSOLE_DBUS_SERVICE", dbusService);
+  if (!dbusSession.isEmpty ())
+    setEnv ("KONSOLE_DBUS_SESSION", dbusSession);
 
-  setEnv("WINDOWID", QString::number(winid));
+  setEnv ("WINDOWID", QString::number (winid));
 
   // unless the LANGUAGE environment variable has been set explicitly
   // set it to a null string
   // this fixes the problem where KCatalog sets the LANGUAGE environment
   // variable during the application's startup to something which
   // differs from LANG,LC_* etc. and causes programs run from
   // the terminal to display messages in the wrong language
   //
   // this can happen if LANG contains a language which KDE
   // does not have a translation for
   //
   // BR:149300
-  setEnv("LANGUAGE",QString(),false /* do not overwrite existing value if any */);
+  setEnv ("LANGUAGE", QString (),
+	  false /* do not overwrite existing value if any */ );
 
-  setUseUtmp(addToUtmp);
+  setUseUtmp (addToUtmp);
 
-  struct ::termios ttmode;
-  pty()->tcGetAttr(&ttmode);
+  struct::termios ttmode;
+  pty ()->tcGetAttr (&ttmode);
   if (!_xonXoff)
     ttmode.c_iflag &= ~(IXOFF | IXON);
   else
     ttmode.c_iflag |= (IXOFF | IXON);
-#ifdef IUTF8 // XXX not a reasonable place to check it.
+#ifdef IUTF8			// XXX not a reasonable place to check it.
   if (!_utf8)
     ttmode.c_iflag &= ~IUTF8;
   else
     ttmode.c_iflag |= IUTF8;
 #endif
 
   if (_eraseChar != 0)
-      ttmode.c_cc[VERASE] = _eraseChar;
-  
+    ttmode.c_cc[VERASE] = _eraseChar;
+
   //if (!pty()->tcSetAttr(&ttmode))
   //  kWarning() << "Unable to set terminal attributes.";
-  
-  pty()->setWinSize(_windowLines, _windowColumns);
+
+  pty ()->setWinSize (_windowLines, _windowColumns);
 
-  KProcess::start();
+  KProcess::start ();
 
-  if (!waitForStarted())
-      return -1;
+  if (!waitForStarted ())
+    return -1;
 
   return 0;
 }
 
-void Pty::setWriteable(bool writeable)
+void
+Pty::setWriteable (bool writeable)
 {
   //KDE_struct_stat sbuf;
   struct stat sbuf;
   //KDE_stat(pty()->ttyName(), &sbuf);
-  ::stat(pty()->ttyName(), &sbuf);
+  ::stat (pty ()->ttyName (), &sbuf);
   if (writeable)
-    chmod(pty()->ttyName(), sbuf.st_mode | S_IWGRP);
+    chmod (pty ()->ttyName (), sbuf.st_mode | S_IWGRP);
   else
-    chmod(pty()->ttyName(), sbuf.st_mode & ~(S_IWGRP|S_IWOTH));
+    chmod (pty ()->ttyName (), sbuf.st_mode & ~(S_IWGRP | S_IWOTH));
 }
 
-Pty::Pty(int masterFd, QObject* parent)
-    : KPtyProcess(masterFd,parent)
+Pty::Pty (int masterFd, QObject * parent):
+KPtyProcess (masterFd, parent)
 {
-    init();
+  init ();
 }
-Pty::Pty(QObject* parent)
-    : KPtyProcess(parent)
+
+Pty::Pty (QObject * parent):KPtyProcess (parent)
 {
-    init();
+  init ();
 }
-void Pty::init()
+
+void
+Pty::init ()
 {
   _windowColumns = 0;
   _windowLines = 0;
   _eraseChar = 0;
   _xonXoff = true;
-  _utf8 =true;
+  _utf8 = true;
 
-  connect(pty(), SIGNAL(readyRead()) , this , SLOT(dataReceived()));
-  setPtyChannels(KPtyProcess::AllChannels);
+  connect (pty (), SIGNAL (readyRead ()), this, SLOT (dataReceived ()));
+  setPtyChannels (KPtyProcess::AllChannels);
 }
 
-Pty::~Pty()
+Pty::~Pty ()
 {
 }
 
-void Pty::sendData(const char* data, int length)
+void
+Pty::sendData (const char *data, int length)
 {
   if (!length)
+    return;
+
+  if (!pty ()->write (data, length))
+    {
+      //kWarning() << "Pty::doSendJobs - Could not send input data to terminal process.";
       return;
-  
-  if (!pty()->write(data,length)) 
-  {
-    //kWarning() << "Pty::doSendJobs - Could not send input data to terminal process.";
-    return;
-  }
+    }
 }
 
-void Pty::dataReceived() 
+void
+Pty::dataReceived ()
 {
-     QByteArray data = pty()->readAll();
-    emit receivedData(data.constData(),data.count());
+  QByteArray data = pty ()->readAll ();
+  emit receivedData (data.constData (), data.count ());
 }
 
-void Pty::lockPty(bool lock)
+void
+Pty::lockPty (bool lock)
 {
-    Q_UNUSED(lock);
+  Q_UNUSED (lock);
 
 // TODO: Support for locking the Pty
   //if (lock)
-    //suspend();
+  //suspend();
   //else
-    //resume();
+  //resume();
 }
 
-int Pty::foregroundProcessGroup() const
+int
+Pty::foregroundProcessGroup () const
 {
-    int pid = tcgetpgrp(pty()->masterFd());
+  int pid = tcgetpgrp (pty ()->masterFd ());
 
-    if ( pid != -1 )
+  if (pid != -1)
     {
-        return pid;
-    } 
+      return pid;
+    }
 
-    return 0;
+  return 0;
 }
 
-void Pty::setupChildProcess()
+void
+Pty::setupChildProcess ()
 {
-    KPtyProcess::setupChildProcess();
-    
-    // reset all signal handlers
-    // this ensures that terminal applications respond to 
-    // signals generated via key sequences such as Ctrl+C
-    // (which sends SIGINT)
-    struct sigaction action;
-    sigemptyset(&action.sa_mask);
-    action.sa_handler = SIG_DFL;
-    action.sa_flags = 0;
-    for (int signal=1;signal < NSIG; signal++)
-        sigaction(signal,&action,0L);
+  KPtyProcess::setupChildProcess ();
+
+  // reset all signal handlers
+  // this ensures that terminal applications respond to 
+  // signals generated via key sequences such as Ctrl+C
+  // (which sends SIGINT)
+  struct sigaction action;
+  sigemptyset (&action.sa_mask);
+  action.sa_handler = SIG_DFL;
+  action.sa_flags = 0;
+  for (int signal = 1; signal < NSIG; signal++)
+    sigaction (signal, &action, 0L);
 }
diff --git a/gui/src/terminal/Pty.h b/gui/src/terminal/Pty.h
--- a/gui/src/terminal/Pty.h
+++ b/gui/src/terminal/Pty.h
@@ -42,40 +42,38 @@
  * To use this class, construct an instance and connect
  * to the sendData slot and receivedData signal to
  * send data to or receive data from the process.
  *
  * To start the terminal process, call the start() method
  * with the program name and appropriate arguments. 
  */
 //class KONSOLEPRIVATE_EXPORT Pty: public KPtyProcess
-class Pty: public KPtyProcess
+class Pty:public KPtyProcess
 {
-Q_OBJECT
+Q_OBJECT public:
 
-  public:
-    
     /** 
      * Constructs a new Pty.
      * 
      * Connect to the sendData() slot and receivedData() signal to prepare
      * for sending and receiving data from the terminal process.
      *
      * To start the terminal process, call the run() method with the 
      * name of the program to start and appropriate arguments.
      */
-    explicit Pty(QObject* parent = 0);
+  explicit Pty (QObject * parent = 0);
 
     /** 
      * Construct a process using an open pty master.
      * See KPtyProcess::KPtyProcess()
      */
-    explicit Pty(int ptyMasterFd, QObject* parent = 0);
+  explicit Pty (int ptyMasterFd, QObject * parent = 0);
 
-    ~Pty();
+   ~Pty ();
 
     /**
      * Starts the terminal process.  
      *
      * Returns 0 if the process was started successfully or non-zero
      * otherwise.
      *
      * @param program Path to the program to start
@@ -87,115 +85,111 @@ Q_OBJECT
      * in the process's environment.
      * @param addToUtmp Specifies whether a utmp entry should be created for
      * the pty used.  See K3Process::setUsePty() 
      * @param dbusService Specifies the value of the KONSOLE_DBUS_SERVICE 
      * environment variable in the process's environment.
      * @param dbusSession Specifies the value of the KONSOLE_DBUS_SESSION
      * environment variable in the process's environment. 
      */
-    int start( const QString& program, 
-               const QStringList& arguments, 
-               const QStringList& environment, 
-               ulong winid, 
-               bool addToUtmp,
-               const QString& dbusService,
-               const QString& dbusSession
-             );
+  int start (const QString & program,
+	     const QStringList & arguments,
+	     const QStringList & environment,
+	     ulong winid,
+	     bool addToUtmp,
+	     const QString & dbusService, const QString & dbusSession);
 
     /** TODO: Document me */
-    void setWriteable(bool writeable);
+  void setWriteable (bool writeable);
 
     /** 
      * Enables or disables Xon/Xoff flow control.  The flow control setting
      * may be changed later by a terminal application, so flowControlEnabled()
      * may not equal the value of @p on in the previous call to setFlowControlEnabled()
      */
-    void setFlowControlEnabled(bool on);
+  void setFlowControlEnabled (bool on);
 
     /** Queries the terminal state and returns true if Xon/Xoff flow control is enabled. */
-    bool flowControlEnabled() const;
+  bool flowControlEnabled () const;
 
     /** 
      * Sets the size of the window (in lines and columns of characters) 
      * used by this teletype.
      */
-    void setWindowSize(int lines, int cols);
-    
+  void setWindowSize (int lines, int cols);
+
     /** Returns the size of the window used by this teletype.  See setWindowSize() */
-    QSize windowSize() const;
+  QSize windowSize () const;
 
     /** TODO Document me */
-    void setErase(char erase);
+  void setErase (char erase);
 
     /** */
-    char erase() const;
+  char erase () const;
 
     /**
      * Returns the process id of the teletype's current foreground
      * process.  This is the process which is currently reading
      * input sent to the terminal via. sendData()
      *
      * If there is a problem reading the foreground process group,
      * 0 will be returned.
      */
-    int foregroundProcessGroup() const;
-   
+  int foregroundProcessGroup () const;
+
   public slots:
-
     /**
      * Put the pty into UTF-8 mode on systems which support it.
      */
-    void setUtf8Mode(bool on);
+  void setUtf8Mode (bool on);
 
     /**
      * Suspend or resume processing of data from the standard 
      * output of the terminal process.
      *
      * See K3Process::suspend() and K3Process::resume()
      *
      * @param lock If true, processing of output is suspended,
      * otherwise processing is resumed.
      */
-    void lockPty(bool lock);
-    
+  void lockPty (bool lock);
+
     /** 
      * Sends data to the process currently controlling the 
      * teletype ( whose id is returned by foregroundProcessGroup() )
      *
      * @param buffer Pointer to the data to send.
      * @param length Length of @p buffer.
      */
-    void sendData(const char* buffer, int length);
+  void sendData (const char *buffer, int length);
 
-  signals:
-
+    signals:
     /**
      * Emitted when a new block of data is received from
      * the teletype.
      *
      * @param buffer Pointer to the data received.
      * @param length Length of @p buffer
      */
-    void receivedData(const char* buffer, int length);
-   
-  protected:
-      void setupChildProcess();
+  void receivedData (const char *buffer, int length);
+
+protected:
+  void setupChildProcess ();
 
   private slots:
     // called when data is received from the terminal process 
-    void dataReceived(); 
-    
-  private:
-      void init();
+  void dataReceived ();
+
+private:
+  void init ();
 
-    // takes a list of key=value pairs and adds them
-    // to the environment for the process
-    void addEnvironmentVariables(const QStringList& environment);
+  // takes a list of key=value pairs and adds them
+  // to the environment for the process
+  void addEnvironmentVariables (const QStringList & environment);
 
-    int  _windowColumns; 
-    int  _windowLines;
-    char _eraseChar;
-    bool _xonXoff;
-    bool _utf8;
+  int _windowColumns;
+  int _windowLines;
+  char _eraseChar;
+  bool _xonXoff;
+  bool _utf8;
 };
 
 #endif // PTY_H
diff --git a/gui/src/terminal/QTerminalWidget.cpp b/gui/src/terminal/QTerminalWidget.cpp
--- a/gui/src/terminal/QTerminalWidget.cpp
+++ b/gui/src/terminal/QTerminalWidget.cpp
@@ -10,182 +10,201 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Library General Public License for more details.
 				
     You should have received a copy of the GNU Library General Public License
     along with this library; see the file COPYING.LIB.  If not, write to
     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
     Boston, MA 02110-1301, USA.
 */
-						
+
 #include "QTerminalWidget.h"
 #include "Session.h"
 #include "TerminalDisplay.h"
 
 struct TermWidgetImpl
 {
-    TermWidgetImpl(QWidget* parent = 0);
+  TermWidgetImpl (QWidget * parent = 0);
 
-    TerminalDisplay *m_terminalDisplay;
-    Session *m_session;
-    Session* createSession();
-    TerminalDisplay* createTerminalDisplay(Session *session, QWidget* parent);
+  TerminalDisplay *m_terminalDisplay;
+  Session *m_session;
+  Session *createSession ();
+  TerminalDisplay *createTerminalDisplay (Session * session,
+					  QWidget * parent);
 };
 
-TermWidgetImpl::TermWidgetImpl(QWidget* parent)
+TermWidgetImpl::TermWidgetImpl (QWidget * parent)
 {
-    QPalette palette = QApplication::palette();
-    m_session = createSession();
-    m_terminalDisplay = createTerminalDisplay(this->m_session, parent);
-    m_terminalDisplay->setBackgroundColor(palette.color(QPalette::Base));
-    m_terminalDisplay->setForegroundColor(palette.color(QPalette::Text));
+  QPalette palette = QApplication::palette ();
+  m_session = createSession ();
+  m_terminalDisplay = createTerminalDisplay (this->m_session, parent);
+  m_terminalDisplay->setBackgroundColor (palette.color (QPalette::Base));
+  m_terminalDisplay->setForegroundColor (palette.color (QPalette::Text));
 }
 
-Session *TermWidgetImpl::createSession()
+Session *
+TermWidgetImpl::createSession ()
 {
-    Session *session = new Session();
-    session->setTitle(Session::NameRole, "QTerminalWidget");
-    session->setProgram("/bin/bash");
-    session->setArguments(QStringList());
-    session->setAutoClose(true);
-    session->setCodec(QTextCodec::codecForName("UTF-8"));
-    session->setFlowControlEnabled(true);
-    session->setHistoryType(HistoryTypeBuffer(1000));
-    session->setDarkBackground(true);
-    session->setKeyBindings("");
-    return session;
+  Session *session = new Session ();
+  session->setTitle (Session::NameRole, "QTerminalWidget");
+  session->setProgram ("/bin/bash");
+  session->setArguments (QStringList ());
+  session->setAutoClose (true);
+  session->setCodec (QTextCodec::codecForName ("UTF-8"));
+  session->setFlowControlEnabled (true);
+  session->setHistoryType (HistoryTypeBuffer (1000));
+  session->setDarkBackground (true);
+  session->setKeyBindings ("");
+  return session;
 }
 
-TerminalDisplay *TermWidgetImpl::createTerminalDisplay(Session *session, QWidget* parent)
+TerminalDisplay *
+TermWidgetImpl::createTerminalDisplay (Session * session, QWidget * parent)
 {
-    TerminalDisplay* display = new TerminalDisplay(parent);
-    display->setBellMode(TerminalDisplay::NotifyBell);
-    display->setTerminalSizeHint(true);
-    display->setTripleClickMode(TerminalDisplay::SelectWholeLine);
-    display->setTerminalSizeStartup(true);
-    display->setRandomSeed(session->sessionId() * 31);
-    return display;
+  TerminalDisplay *display = new TerminalDisplay (parent);
+  display->setBellMode (TerminalDisplay::NotifyBell);
+  display->setTerminalSizeHint (true);
+  display->setTripleClickMode (TerminalDisplay::SelectWholeLine);
+  display->setTerminalSizeStartup (true);
+  display->setRandomSeed (session->sessionId () * 31);
+  return display;
 }
 
-QTerminalWidget::QTerminalWidget(int startnow, QWidget *parent)
-    :QWidget(parent)
+QTerminalWidget::QTerminalWidget (int startnow, QWidget * parent):QWidget
+  (parent)
 {
-    m_impl = new TermWidgetImpl(this);
-    
-    initialize();
+  m_impl = new TermWidgetImpl (this);
+
+  initialize ();
 
-    if(startnow && m_impl->m_session) {
-	m_impl->m_session->run();
+  if (startnow && m_impl->m_session)
+    {
+      m_impl->m_session->run ();
     }
 
-    setFocus(Qt::OtherFocusReason);
-    m_impl->m_terminalDisplay->resize(this->size());
-    setFocusProxy(m_impl->m_terminalDisplay);
+  setFocus (Qt::OtherFocusReason);
+  m_impl->m_terminalDisplay->resize (this->size ());
+  setFocusProxy (m_impl->m_terminalDisplay);
 }
 
-void QTerminalWidget::startShellProgram()
+void
+QTerminalWidget::startShellProgram ()
 {
-    if(m_impl->m_session->isRunning())
-	return;
-	
-    m_impl->m_session->run();
+  if (m_impl->m_session->isRunning ())
+    return;
+
+  m_impl->m_session->run ();
 }
 
-void QTerminalWidget::initialize()
-{    
-    m_impl->m_terminalDisplay->setSize(80, 40);
-    
-    QFont font = QApplication::font(); 
-    font.setFamily("Monospace");
-    font.setPointSize(10);
-    font.setStyleHint(QFont::TypeWriter);
-    setTerminalFont(font);
-    setScrollBarPosition(NoScrollBar);
+void
+QTerminalWidget::initialize ()
+{
+  m_impl->m_terminalDisplay->setSize (80, 40);
 
-    m_impl->m_session->addView(m_impl->m_terminalDisplay);
-    
-    connect(m_impl->m_session, SIGNAL(finished()), this, SLOT(sessionFinished()));
+  QFont font = QApplication::font ();
+  font.setFamily ("Monospace");
+  font.setPointSize (10);
+  font.setStyleHint (QFont::TypeWriter);
+  setTerminalFont (font);
+  setScrollBarPosition (NoScrollBar);
+
+  m_impl->m_session->addView (m_impl->m_terminalDisplay);
+
+  connect (m_impl->m_session, SIGNAL (finished ()), this,
+	   SLOT (sessionFinished ()));
 }
 
-QTerminalWidget::~QTerminalWidget()
+QTerminalWidget::~QTerminalWidget ()
 {
-    emit destroyed();
+  emit destroyed ();
 }
 
-void QTerminalWidget::setTerminalFont(QFont &font)
+void
+QTerminalWidget::setTerminalFont (QFont & font)
 {
-    if (!m_impl->m_terminalDisplay)
-	return;
-    m_impl->m_terminalDisplay->setVTFont(font);
+  if (!m_impl->m_terminalDisplay)
+    return;
+  m_impl->m_terminalDisplay->setVTFont (font);
 }
 
-void QTerminalWidget::setShellProgram(QString progname)
+void
+QTerminalWidget::setShellProgram (QString progname)
 {
-    if (!m_impl->m_session)
-	return;
-    m_impl->m_session->setProgram(progname);	
+  if (!m_impl->m_session)
+    return;
+  m_impl->m_session->setProgram (progname);
 }
 
-void QTerminalWidget::openTeletype(int fd)
+void
+QTerminalWidget::openTeletype (int fd)
 {
-  if ( m_impl->m_session->isRunning() )
+  if (m_impl->m_session->isRunning ())
     return;
 
-  m_impl->m_session->openTeletype(fd);
+  m_impl->m_session->openTeletype (fd);
 }
 
-void QTerminalWidget::setArgs(QStringList &args)
+void
+QTerminalWidget::setArgs (QStringList & args)
 {
-    if (!m_impl->m_session)
-	return;
-    m_impl->m_session->setArguments(args);	
+  if (!m_impl->m_session)
+    return;
+  m_impl->m_session->setArguments (args);
 }
 
-void QTerminalWidget::setTextCodec(QTextCodec *codec)
+void
+QTerminalWidget::setTextCodec (QTextCodec * codec)
 {
-    if (!m_impl->m_session)
-	return;
-    m_impl->m_session->setCodec(codec);	
+  if (!m_impl->m_session)
+    return;
+  m_impl->m_session->setCodec (codec);
 }
 
-void QTerminalWidget::setSize(int h, int v)
+void
+QTerminalWidget::setSize (int h, int v)
 {
-    if (!m_impl->m_terminalDisplay)
-	return;
-    m_impl->m_terminalDisplay->setSize(h, v);
+  if (!m_impl->m_terminalDisplay)
+    return;
+  m_impl->m_terminalDisplay->setSize (h, v);
 }
 
-void QTerminalWidget::setHistorySize(int lines)
+void
+QTerminalWidget::setHistorySize (int lines)
 {
-    if (lines < 0)
-        m_impl->m_session->setHistoryType(HistoryTypeFile());
-    else
-	m_impl->m_session->setHistoryType(HistoryTypeBuffer(lines));
-}
-
-void QTerminalWidget::setScrollBarPosition(ScrollBarPosition pos)
-{
-    if (!m_impl->m_terminalDisplay)
-	return;
-    m_impl->m_terminalDisplay->setScrollBarPosition((TerminalDisplay::ScrollBarPosition)pos);
+  if (lines < 0)
+    m_impl->m_session->setHistoryType (HistoryTypeFile ());
+  else
+    m_impl->m_session->setHistoryType (HistoryTypeBuffer (lines));
 }
 
-void QTerminalWidget::sendText(const QString &text)
+void
+QTerminalWidget::setScrollBarPosition (ScrollBarPosition pos)
 {
-    m_impl->m_session->sendText(text); 
+  if (!m_impl->m_terminalDisplay)
+    return;
+  m_impl->m_terminalDisplay->
+    setScrollBarPosition ((TerminalDisplay::ScrollBarPosition) pos);
 }
 
-void QTerminalWidget::installEventFilterOnDisplay(QObject *object) {
-    m_impl->m_terminalDisplay->installEventFilter(object);
+void
+QTerminalWidget::sendText (const QString & text)
+{
+  m_impl->m_session->sendText (text);
 }
 
-void QTerminalWidget::resizeEvent(QResizeEvent*)
+void
+QTerminalWidget::installEventFilterOnDisplay (QObject * object)
 {
-    m_impl->m_terminalDisplay->resize(this->size());
-    m_impl->m_terminalDisplay->update();
+  m_impl->m_terminalDisplay->installEventFilter (object);
 }
 
-void QTerminalWidget::sessionFinished()
+void
+QTerminalWidget::resizeEvent (QResizeEvent *)
 {
-    emit finished();
+  m_impl->m_terminalDisplay->resize (this->size ());
+  m_impl->m_terminalDisplay->update ();
 }
 
-
+void
+QTerminalWidget::sessionFinished ()
+{
+  emit finished ();
+}
diff --git a/gui/src/terminal/QTerminalWidget.h b/gui/src/terminal/QTerminalWidget.h
--- a/gui/src/terminal/QTerminalWidget.h
+++ b/gui/src/terminal/QTerminalWidget.h
@@ -21,73 +21,71 @@
 
 #include <QtGui>
 
 struct TermWidgetImpl;
 /**
   * \class QTerminalWidget
   * This class forms a widget class that can be inserted into other widgets.
   */
-class QTerminalWidget : public QWidget
+class QTerminalWidget:public QWidget
 {
-    Q_OBJECT
-public:
+Q_OBJECT public:
     /**
       * \enum ScrollBarPosition
       * Defines the scrollbar position of the terminal.
       */
-    enum ScrollBarPosition
-    {
-        NoScrollBar,
-        ScrollBarLeft,
-        ScrollBarRight
-    };
+  enum ScrollBarPosition
+  {
+    NoScrollBar,
+    ScrollBarLeft,
+    ScrollBarRight
+  };
 
-    QTerminalWidget(int startnow = 1, QWidget *parent = 0);
-    ~QTerminalWidget();
+    QTerminalWidget (int startnow = 1, QWidget * parent = 0);
+   ~QTerminalWidget ();
 
-    void startShellProgram();
-    void openTeletype(int fd);
+  void startShellProgram ();
+  void openTeletype (int fd);
 
     /** Default is application font with family Monospace, size 10. */
-    void setTerminalFont(QFont &font); 
-    
+  void setTerminalFont (QFont & font);
+
     /**	Shell program, default is /bin/bash. */
-    void setShellProgram(QString progname);
-    
+  void setShellProgram (QString progname);
+
     /** Shell program args, default is none. */
-    void setArgs(QStringList &args);
-    
+  void setArgs (QStringList & args);
+
     /** Text codec, default is UTF-8. */
-    void setTextCodec(QTextCodec *codec);
-    
+  void setTextCodec (QTextCodec * codec);
+
     /** Resize terminal widget. */
-    void setSize(int h, int v);
-    
+  void setSize (int h, int v);
+
     /** History size for scrolling, values below zero mean infinite. */
-    void setHistorySize(int lines);
+  void setHistorySize (int lines);
 
     /** Presence of scrollbar. By default, there is no scrollbar present. */
-    void setScrollBarPosition(ScrollBarPosition);
-    
+  void setScrollBarPosition (ScrollBarPosition);
+
     /** Send some text to the terminal. */
-    void sendText(const QString &text);
+  void sendText (const QString & text);
 
     /** Installs an event filter onto the display. */
-    void installEventFilterOnDisplay(QObject *object);
-            
-signals:
+  void installEventFilterOnDisplay (QObject * object);
+
+    signals:
     /** Emitted, when the current program has finished. */
-    void finished();
-        
-protected: 
-    virtual void resizeEvent(QResizeEvent *);
-    
-protected slots:
-    void sessionFinished();        
-    
+  void finished ();
+
+protected:
+    virtual void resizeEvent (QResizeEvent *);
+
+  protected slots:void sessionFinished ();
+
 private:
     /** Performs initial operations on this widget. */
-    void initialize();
-    TermWidgetImpl *m_impl;
+  void initialize ();
+  TermWidgetImpl *m_impl;
 };
 
 #endif // QTERMINALWIDGET_H
diff --git a/gui/src/terminal/Screen.cpp b/gui/src/terminal/Screen.cpp
--- a/gui/src/terminal/Screen.cpp
+++ b/gui/src/terminal/Screen.cpp
@@ -53,291 +53,344 @@
 //Many internal parts of this class still use this representation for parameters and so on,
 //notably moveImage() and clearImage().
 //This macro converts from an X,Y position into an image offset.
 #ifndef loc
 #define loc(X,Y) ((Y)*columns+(X))
 #endif
 
 
-Character Screen::defaultChar = Character(' ',
-        CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
-        CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
-        DEFAULT_RENDITION);
+Character
+  Screen::defaultChar = Character (' ',
+				   CharacterColor (COLOR_SPACE_DEFAULT,
+						   DEFAULT_FORE_COLOR),
+				   CharacterColor (COLOR_SPACE_DEFAULT,
+						   DEFAULT_BACK_COLOR),
+				   DEFAULT_RENDITION);
 
 //#define REVERSE_WRAPPED_LINES  // for wrapped line debug
 
-    Screen::Screen(int l, int c)
-: lines(l),
-    columns(c),
-    screenLines(new ImageLine[lines+1] ),
-    _scrolledLines(0),
-    _droppedLines(0),
-    history(new HistoryScrollNone()),
-    cuX(0), cuY(0),
-    currentRendition(0),
-    _topMargin(0), _bottomMargin(0),
-    selBegin(0), selTopLeft(0), selBottomRight(0),
-    blockSelectionMode(false),
-    effectiveForeground(CharacterColor()), effectiveBackground(CharacterColor()), effectiveRendition(0),
-    lastPos(-1)
+Screen::Screen (int l, int c):
+lines (l),
+columns (c),
+screenLines (new ImageLine[lines + 1]),
+_scrolledLines (0),
+_droppedLines (0),
+history (new HistoryScrollNone ()),
+cuX (0),
+cuY (0),
+currentRendition (0),
+_topMargin (0),
+_bottomMargin (0),
+selBegin (0),
+selTopLeft (0),
+selBottomRight (0),
+blockSelectionMode (false),
+effectiveForeground (CharacterColor ()),
+effectiveBackground (CharacterColor ()),
+effectiveRendition (0),
+lastPos (-1)
 {
-    lineProperties.resize(lines+1);
-    for (int i=0;i<lines+1;i++)
-        lineProperties[i]=LINE_DEFAULT;
+  lineProperties.resize (lines + 1);
+  for (int i = 0; i < lines + 1; i++)
+    lineProperties[i] = LINE_DEFAULT;
 
-    initTabStops();
-    clearSelection();
-    reset();
+  initTabStops ();
+  clearSelection ();
+  reset ();
 }
 
 /*! Destructor
 */
 
-Screen::~Screen()
+Screen::~Screen ()
 {
-    delete[] screenLines;
-    delete history;
+  delete[]screenLines;
+  delete history;
 }
 
-void Screen::cursorUp(int n)
+void
+Screen::cursorUp (int n)
     //=CUU
 {
-    if (n == 0) n = 1; // Default
-    int stop = cuY < _topMargin ? 0 : _topMargin;
-    cuX = qMin(columns-1,cuX); // nowrap!
-    cuY = qMax(stop,cuY-n);
+  if (n == 0)
+    n = 1;			// Default
+  int stop = cuY < _topMargin ? 0 : _topMargin;
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuY = qMax (stop, cuY - n);
 }
 
-void Screen::cursorDown(int n)
+void
+Screen::cursorDown (int n)
     //=CUD
 {
-    if (n == 0) n = 1; // Default
-    int stop = cuY > _bottomMargin ? lines-1 : _bottomMargin;
-    cuX = qMin(columns-1,cuX); // nowrap!
-    cuY = qMin(stop,cuY+n);
+  if (n == 0)
+    n = 1;			// Default
+  int stop = cuY > _bottomMargin ? lines - 1 : _bottomMargin;
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuY = qMin (stop, cuY + n);
 }
 
-void Screen::cursorLeft(int n)
+void
+Screen::cursorLeft (int n)
     //=CUB
 {
-    if (n == 0) n = 1; // Default
-    cuX = qMin(columns-1,cuX); // nowrap!
-    cuX = qMax(0,cuX-n);
+  if (n == 0)
+    n = 1;			// Default
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuX = qMax (0, cuX - n);
 }
 
-void Screen::cursorRight(int n)
+void
+Screen::cursorRight (int n)
     //=CUF
 {
-    if (n == 0) n = 1; // Default
-    cuX = qMin(columns-1,cuX+n);
+  if (n == 0)
+    n = 1;			// Default
+  cuX = qMin (columns - 1, cuX + n);
 }
 
-void Screen::setMargins(int top, int bot)
+void
+Screen::setMargins (int top, int bot)
     //=STBM
 {
-    if (top == 0) top = 1;      // Default
-    if (bot == 0) bot = lines;  // Default
-    top = top - 1;              // Adjust to internal lineno
-    bot = bot - 1;              // Adjust to internal lineno
-    if ( !( 0 <= top && top < bot && bot < lines ) )
-    { //Debug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
-        return;                   // Default error action: ignore
+  if (top == 0)
+    top = 1;			// Default
+  if (bot == 0)
+    bot = lines;		// Default
+  top = top - 1;		// Adjust to internal lineno
+  bot = bot - 1;		// Adjust to internal lineno
+  if (!(0 <= top && top < bot && bot < lines))
+    {				//Debug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
+      return;			// Default error action: ignore
     }
-    _topMargin = top;
-    _bottomMargin = bot;
-    cuX = 0;
-    cuY = getMode(MODE_Origin) ? top : 0;
+  _topMargin = top;
+  _bottomMargin = bot;
+  cuX = 0;
+  cuY = getMode (MODE_Origin) ? top : 0;
 
 }
 
-int Screen::topMargin() const
+int
+Screen::topMargin () const
 {
-    return _topMargin;
-}
-int Screen::bottomMargin() const
-{
-    return _bottomMargin;
+  return _topMargin;
 }
 
-void Screen::index()
+int
+Screen::bottomMargin () const
+{
+  return _bottomMargin;
+}
+
+void
+Screen::index ()
     //=IND
 {
-    if (cuY == _bottomMargin)
-        scrollUp(1);
-    else if (cuY < lines-1)
-        cuY += 1;
+  if (cuY == _bottomMargin)
+    scrollUp (1);
+  else if (cuY < lines - 1)
+    cuY += 1;
 }
 
-void Screen::reverseIndex()
+void
+Screen::reverseIndex ()
     //=RI
 {
-    if (cuY == _topMargin)
-        scrollDown(_topMargin,1);
-    else if (cuY > 0)
-        cuY -= 1;
+  if (cuY == _topMargin)
+    scrollDown (_topMargin, 1);
+  else if (cuY > 0)
+    cuY -= 1;
 }
 
-void Screen::nextLine()
+void
+Screen::nextLine ()
     //=NEL
 {
-    toStartOfLine(); index();
+  toStartOfLine ();
+  index ();
 }
 
-void Screen::eraseChars(int n)
+void
+Screen::eraseChars (int n)
 {
-    if (n == 0) n = 1; // Default
-    int p = qMax(0,qMin(cuX+n-1,columns-1));
-    clearImage(loc(cuX,cuY),loc(p,cuY),' ');
+  if (n == 0)
+    n = 1;			// Default
+  int p = qMax (0, qMin (cuX + n - 1, columns - 1));
+  clearImage (loc (cuX, cuY), loc (p, cuY), ' ');
 }
 
-void Screen::deleteChars(int n)
+void
+Screen::deleteChars (int n)
 {
-    Q_ASSERT( n >= 0 );
+  Q_ASSERT (n >= 0);
 
-    // always delete at least one char
-    if (n == 0) 
-        n = 1; 
+  // always delete at least one char
+  if (n == 0)
+    n = 1;
 
-    // if cursor is beyond the end of the line there is nothing to do
-    if ( cuX >= screenLines[cuY].count() )
-        return;
+  // if cursor is beyond the end of the line there is nothing to do
+  if (cuX >= screenLines[cuY].count ())
+    return;
 
-    if ( cuX+n > screenLines[cuY].count() ) 
-        n = screenLines[cuY].count() - cuX;
+  if (cuX + n > screenLines[cuY].count ())
+    n = screenLines[cuY].count () - cuX;
 
-    Q_ASSERT( n >= 0 );
-    Q_ASSERT( cuX+n <= screenLines[cuY].count() );
+  Q_ASSERT (n >= 0);
+  Q_ASSERT (cuX + n <= screenLines[cuY].count ());
 
-    screenLines[cuY].remove(cuX,n);
+  screenLines[cuY].remove (cuX, n);
 }
 
-void Screen::insertChars(int n)
+void
+Screen::insertChars (int n)
 {
-    if (n == 0) n = 1; // Default
+  if (n == 0)
+    n = 1;			// Default
 
-    if ( screenLines[cuY].size() < cuX )
-        screenLines[cuY].resize(cuX);
+  if (screenLines[cuY].size () < cuX)
+    screenLines[cuY].resize (cuX);
 
-    screenLines[cuY].insert(cuX,n,' ');
+  screenLines[cuY].insert (cuX, n, ' ');
 
-    if ( screenLines[cuY].count() > columns )
-        screenLines[cuY].resize(columns);
+  if (screenLines[cuY].count () > columns)
+    screenLines[cuY].resize (columns);
 }
 
-void Screen::deleteLines(int n)
+void
+Screen::deleteLines (int n)
 {
-    if (n == 0) n = 1; // Default
-    scrollUp(cuY,n);
+  if (n == 0)
+    n = 1;			// Default
+  scrollUp (cuY, n);
 }
 
-void Screen::insertLines(int n)
+void
+Screen::insertLines (int n)
 {
-    if (n == 0) n = 1; // Default
-    scrollDown(cuY,n);
+  if (n == 0)
+    n = 1;			// Default
+  scrollDown (cuY, n);
 }
 
-void Screen::setMode(int m)
+void
+Screen::setMode (int m)
 {
-    currentModes[m] = true;
-    switch(m)
+  currentModes[m] = true;
+  switch (m)
     {
-        case MODE_Origin : cuX = 0; cuY = _topMargin; break; //FIXME: home
+    case MODE_Origin:
+      cuX = 0;
+      cuY = _topMargin;
+      break;			//FIXME: home
     }
 }
 
-void Screen::resetMode(int m)
+void
+Screen::resetMode (int m)
 {
-    currentModes[m] = false;
-    switch(m)
+  currentModes[m] = false;
+  switch (m)
     {
-        case MODE_Origin : cuX = 0; cuY = 0; break; //FIXME: home
+    case MODE_Origin:
+      cuX = 0;
+      cuY = 0;
+      break;			//FIXME: home
     }
 }
 
-void Screen::saveMode(int m)
+void
+Screen::saveMode (int m)
 {
-    savedModes[m] = currentModes[m];
+  savedModes[m] = currentModes[m];
 }
 
-void Screen::restoreMode(int m)
+void
+Screen::restoreMode (int m)
 {
-    currentModes[m] = savedModes[m];
+  currentModes[m] = savedModes[m];
 }
 
-bool Screen::getMode(int m) const
+bool
+Screen::getMode (int m) const
 {
-    return currentModes[m];
+  return currentModes[m];
 }
 
-void Screen::saveCursor()
+void
+Screen::saveCursor ()
 {
-    savedState.cursorColumn = cuX;
-    savedState.cursorLine  = cuY;
-    savedState.rendition = currentRendition;
-    savedState.foreground = currentForeground;
-    savedState.background = currentBackground;
+  savedState.cursorColumn = cuX;
+  savedState.cursorLine = cuY;
+  savedState.rendition = currentRendition;
+  savedState.foreground = currentForeground;
+  savedState.background = currentBackground;
 }
 
-void Screen::restoreCursor()
+void
+Screen::restoreCursor ()
 {
-    cuX     = qMin(savedState.cursorColumn,columns-1);
-    cuY     = qMin(savedState.cursorLine,lines-1);
-    currentRendition   = savedState.rendition; 
-    currentForeground   = savedState.foreground;
-    currentBackground   = savedState.background;
-    updateEffectiveRendition();
+  cuX = qMin (savedState.cursorColumn, columns - 1);
+  cuY = qMin (savedState.cursorLine, lines - 1);
+  currentRendition = savedState.rendition;
+  currentForeground = savedState.foreground;
+  currentBackground = savedState.background;
+  updateEffectiveRendition ();
 }
 
-void Screen::resizeImage(int new_lines, int new_columns)
+void
+Screen::resizeImage (int new_lines, int new_columns)
 {
-    if ((new_lines==lines) && (new_columns==columns)) return;
+  if ((new_lines == lines) && (new_columns == columns))
+    return;
 
-    if (cuY > new_lines-1)
-    { // attempt to preserve focus and lines
-        _bottomMargin = lines-1; //FIXME: margin lost
-        for (int i = 0; i < cuY-(new_lines-1); i++)
-        {
-            addHistLine(); scrollUp(0,1);
-        }
+  if (cuY > new_lines - 1)
+    {				// attempt to preserve focus and lines
+      _bottomMargin = lines - 1;	//FIXME: margin lost
+      for (int i = 0; i < cuY - (new_lines - 1); i++)
+	{
+	  addHistLine ();
+	  scrollUp (0, 1);
+	}
     }
 
-    // create new screen lines and copy from old to new
+  // create new screen lines and copy from old to new
 
-    ImageLine* newScreenLines = new ImageLine[new_lines+1];
-    for (int i=0; i < qMin(lines-1,new_lines+1) ;i++)
-        newScreenLines[i]=screenLines[i];
-    for (int i=lines;(i > 0) && (i<new_lines+1);i++)
-        newScreenLines[i].resize( new_columns );
+  ImageLine *newScreenLines = new ImageLine[new_lines + 1];
+  for (int i = 0; i < qMin (lines - 1, new_lines + 1); i++)
+    newScreenLines[i] = screenLines[i];
+  for (int i = lines; (i > 0) && (i < new_lines + 1); i++)
+    newScreenLines[i].resize (new_columns);
 
-    lineProperties.resize(new_lines+1);
-    for (int i=lines;(i > 0) && (i<new_lines+1);i++)
-        lineProperties[i] = LINE_DEFAULT;
+  lineProperties.resize (new_lines + 1);
+  for (int i = lines; (i > 0) && (i < new_lines + 1); i++)
+    lineProperties[i] = LINE_DEFAULT;
 
-    clearSelection();
+  clearSelection ();
 
-    delete[] screenLines; 
-    screenLines = newScreenLines;
+  delete[]screenLines;
+  screenLines = newScreenLines;
 
-    lines = new_lines;
-    columns = new_columns;
-    cuX = qMin(cuX,columns-1);
-    cuY = qMin(cuY,lines-1);
+  lines = new_lines;
+  columns = new_columns;
+  cuX = qMin (cuX, columns - 1);
+  cuY = qMin (cuY, lines - 1);
 
-    // FIXME: try to keep values, evtl.
-    _topMargin=0;
-    _bottomMargin=lines-1;
-    initTabStops();
-    clearSelection();
+  // FIXME: try to keep values, evtl.
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
+  initTabStops ();
+  clearSelection ();
 }
 
-void Screen::setDefaultMargins()
+void
+Screen::setDefaultMargins ()
 {
-    _topMargin = 0;
-    _bottomMargin = lines-1;
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
 }
 
 
 /*
    Clarifying rendition here and in the display.
 
    currently, the display's color table is
    0       1       2 .. 9    10 .. 17
@@ -365,992 +418,1111 @@ void Screen::setDefaultMargins()
    and screen rendition. Since xterm/vt102
    is to poor to distinguish between bold
    (which is a font attribute) and intensive
    (which is a color attribute), we translate
    this and RE_BOLD in falls eventually appart
    into RE_BOLD and RE_INTENSIVE.
    */
 
-void Screen::reverseRendition(Character& p) const
-{ 
-    CharacterColor f = p.foregroundColor; 
-    CharacterColor b = p.backgroundColor;
+void
+Screen::reverseRendition (Character & p) const
+{
+  CharacterColor f = p.foregroundColor;
+  CharacterColor b = p.backgroundColor;
 
-    p.foregroundColor = b; 
-    p.backgroundColor = f; //p->r &= ~RE_TRANSPARENT;
+  p.foregroundColor = b;
+  p.backgroundColor = f;	//p->r &= ~RE_TRANSPARENT;
 }
 
-void Screen::updateEffectiveRendition()
+void
+Screen::updateEffectiveRendition ()
 {
-    effectiveRendition = currentRendition;
-    if (currentRendition & RE_REVERSE)
+  effectiveRendition = currentRendition;
+  if (currentRendition & RE_REVERSE)
     {
-        effectiveForeground = currentBackground;
-        effectiveBackground = currentForeground;
+      effectiveForeground = currentBackground;
+      effectiveBackground = currentForeground;
     }
-    else
+  else
     {
-        effectiveForeground = currentForeground;
-        effectiveBackground = currentBackground;
+      effectiveForeground = currentForeground;
+      effectiveBackground = currentBackground;
     }
 
-    if (currentRendition & RE_BOLD)
-        effectiveForeground.toggleIntensive();
+  if (currentRendition & RE_BOLD)
+    effectiveForeground.toggleIntensive ();
 }
 
-void Screen::copyFromHistory(Character* dest, int startLine, int count) const
+void
+Screen::copyFromHistory (Character * dest, int startLine, int count) const
 {
-    Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= history->getLines() );
+  Q_ASSERT (startLine >= 0 && count > 0
+	    && startLine + count <= history->getLines ());
 
-    for (int line = startLine; line < startLine + count; line++) 
+  for (int line = startLine; line < startLine + count; line++)
     {
-        const int length = qMin(columns,history->getLineLen(line));
-        const int destLineOffset  = (line-startLine)*columns;
+      const int length = qMin (columns, history->getLineLen (line));
+      const int destLineOffset = (line - startLine) * columns;
 
-        history->getCells(line,0,length,dest + destLineOffset);
+      history->getCells (line, 0, length, dest + destLineOffset);
 
-        for (int column = length; column < columns; column++) 
-            dest[destLineOffset+column] = defaultChar;
+      for (int column = length; column < columns; column++)
+	dest[destLineOffset + column] = defaultChar;
 
-        // invert selected text
-        if (selBegin !=-1)
-        {
-            for (int column = 0; column < columns; column++)
-            {
-                if (isSelected(column,line)) 
-                {
-                    reverseRendition(dest[destLineOffset + column]); 
-                }
-            }
-        }
+      // invert selected text
+      if (selBegin != -1)
+	{
+	  for (int column = 0; column < columns; column++)
+	    {
+	      if (isSelected (column, line))
+		{
+		  reverseRendition (dest[destLineOffset + column]);
+		}
+	    }
+	}
     }
 }
 
-void Screen::copyFromScreen(Character* dest , int startLine , int count) const
+void
+Screen::copyFromScreen (Character * dest, int startLine, int count) const
 {
-    Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= lines );
+  Q_ASSERT (startLine >= 0 && count > 0 && startLine + count <= lines);
 
-    for (int line = startLine; line < (startLine+count) ; line++)
+  for (int line = startLine; line < (startLine + count); line++)
     {
-        int srcLineStartIndex  = line*columns;
-        int destLineStartIndex = (line-startLine)*columns;
+      int srcLineStartIndex = line * columns;
+      int destLineStartIndex = (line - startLine) * columns;
 
-        for (int column = 0; column < columns; column++)
-        { 
-            int srcIndex = srcLineStartIndex + column; 
-            int destIndex = destLineStartIndex + column;
+      for (int column = 0; column < columns; column++)
+	{
+	  int srcIndex = srcLineStartIndex + column;
+	  int destIndex = destLineStartIndex + column;
 
-            dest[destIndex] = screenLines[srcIndex/columns].value(srcIndex%columns,defaultChar);
+	  dest[destIndex] =
+	    screenLines[srcIndex / columns].value (srcIndex % columns,
+						   defaultChar);
 
-            // invert selected text
-            if (selBegin != -1 && isSelected(column,line + history->getLines()))
-                reverseRendition(dest[destIndex]); 
-        }
+	  // invert selected text
+	  if (selBegin != -1
+	      && isSelected (column, line + history->getLines ()))
+	    reverseRendition (dest[destIndex]);
+	}
 
     }
 }
 
-void Screen::getImage( Character* dest, int size, int startLine, int endLine ) const
+void
+Screen::getImage (Character * dest, int size, int startLine, int endLine) const
 {
-    Q_ASSERT( startLine >= 0 );
-    Q_ASSERT( endLine >= startLine && endLine < history->getLines() + lines );
+  Q_ASSERT (startLine >= 0);
+  Q_ASSERT (endLine >= startLine && endLine < history->getLines () + lines);
 
-    const int mergedLines = endLine - startLine + 1;
+  const int mergedLines = endLine - startLine + 1;
 
-    Q_ASSERT( size >= mergedLines * columns ); 
-    Q_UNUSED( size );
+  Q_ASSERT (size >= mergedLines * columns);
+  Q_UNUSED (size);
 
-    const int linesInHistoryBuffer = qBound(0,history->getLines()-startLine,mergedLines);
-    const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
+  const int linesInHistoryBuffer =
+    qBound (0, history->getLines () - startLine, mergedLines);
+  const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
 
-    // copy lines from history buffer
-    if (linesInHistoryBuffer > 0)
-        copyFromHistory(dest,startLine,linesInHistoryBuffer); 
+  // copy lines from history buffer
+  if (linesInHistoryBuffer > 0)
+    copyFromHistory (dest, startLine, linesInHistoryBuffer);
 
-    // copy lines from screen buffer
-    if (linesInScreenBuffer > 0)
-        copyFromScreen(dest + linesInHistoryBuffer*columns,
-                startLine + linesInHistoryBuffer - history->getLines(),
-                linesInScreenBuffer);
+  // copy lines from screen buffer
+  if (linesInScreenBuffer > 0)
+    copyFromScreen (dest + linesInHistoryBuffer * columns,
+		    startLine + linesInHistoryBuffer - history->getLines (),
+		    linesInScreenBuffer);
 
-    // invert display when in screen mode
-    if (getMode(MODE_Screen))
+  // invert display when in screen mode
+  if (getMode (MODE_Screen))
     {
-        for (int i = 0; i < mergedLines*columns; i++)
-            reverseRendition(dest[i]); // for reverse display
+      for (int i = 0; i < mergedLines * columns; i++)
+	reverseRendition (dest[i]);	// for reverse display
     }
 
-    // mark the character at the current cursor position
-    int cursorIndex = loc(cuX, cuY + linesInHistoryBuffer);
-    if(getMode(MODE_Cursor) && cursorIndex < columns*mergedLines)
-        dest[cursorIndex].rendition |= RE_CURSOR;
+  // mark the character at the current cursor position
+  int cursorIndex = loc (cuX, cuY + linesInHistoryBuffer);
+  if (getMode (MODE_Cursor) && cursorIndex < columns * mergedLines)
+    dest[cursorIndex].rendition |= RE_CURSOR;
 }
 
-QVector<LineProperty> Screen::getLineProperties( int startLine , int endLine ) const
+QVector < LineProperty > Screen::getLineProperties (int startLine,
+                                                    int endLine) const
 {
-    Q_ASSERT( startLine >= 0 ); 
-    Q_ASSERT( endLine >= startLine && endLine < history->getLines() + lines );
+  Q_ASSERT (startLine >= 0);
+  Q_ASSERT (endLine >= startLine && endLine < history->getLines () + lines);
 
-    const int mergedLines = endLine-startLine+1;
-    const int linesInHistory = qBound(0,history->getLines()-startLine,mergedLines);
-    const int linesInScreen = mergedLines - linesInHistory;
+  const int
+    mergedLines = endLine - startLine + 1;
+  const int
+    linesInHistory =
+    qBound (0, history->getLines () - startLine, mergedLines);
+  const int
+    linesInScreen = mergedLines - linesInHistory;
 
-    QVector<LineProperty> result(mergedLines);
-    int index = 0;
+  QVector < LineProperty > result (mergedLines);
+  int
+    index = 0;
 
-    // copy properties for lines in history
-    for (int line = startLine; line < startLine + linesInHistory; line++) 
+  // copy properties for lines in history
+  for (int line = startLine; line < startLine + linesInHistory; line++)
     {
-        //TODO Support for line properties other than wrapped lines
-        if (history->isWrappedLine(line))
-        {
-            result[index] = (LineProperty)(result[index] | LINE_WRAPPED);
-        }
-        index++;
+      //TODO Support for line properties other than wrapped lines
+      if (history->isWrappedLine (line))
+	{
+	  result[index] = (LineProperty) (result[index] | LINE_WRAPPED);
+	}
+      index++;
     }
 
-    // copy properties for lines in screen buffer
-    const int firstScreenLine = startLine + linesInHistory - history->getLines();
-    for (int line = firstScreenLine; line < firstScreenLine+linesInScreen; line++)
+  // copy properties for lines in screen buffer
+  const int
+    firstScreenLine = startLine + linesInHistory - history->getLines ();
+  for (int line = firstScreenLine; line < firstScreenLine + linesInScreen;
+       line++)
     {
-        result[index]=lineProperties[line];
-        index++;
+      result[index] = lineProperties[line];
+      index++;
     }
 
-    return result;
+  return result;
 }
 
-void Screen::reset(bool clearScreen)
+void
+Screen::reset (bool clearScreen)
 {
-    setMode(MODE_Wrap  ); saveMode(MODE_Wrap  );  // wrap at end of margin
-    resetMode(MODE_Origin); saveMode(MODE_Origin);  // position refere to [1,1]
-    resetMode(MODE_Insert); saveMode(MODE_Insert);  // overstroke
-    setMode(MODE_Cursor);                         // cursor visible
-    resetMode(MODE_Screen);                         // screen not inverse
-    resetMode(MODE_NewLine);
+  setMode (MODE_Wrap);
+  saveMode (MODE_Wrap);		// wrap at end of margin
+  resetMode (MODE_Origin);
+  saveMode (MODE_Origin);	// position refere to [1,1]
+  resetMode (MODE_Insert);
+  saveMode (MODE_Insert);	// overstroke
+  setMode (MODE_Cursor);	// cursor visible
+  resetMode (MODE_Screen);	// screen not inverse
+  resetMode (MODE_NewLine);
 
-    _topMargin=0;
-    _bottomMargin=lines-1;
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
 
-    setDefaultRendition();
-    saveCursor();
+  setDefaultRendition ();
+  saveCursor ();
 
-    if ( clearScreen )
-        clear();
+  if (clearScreen)
+    clear ();
 }
 
-void Screen::clear()
+void
+Screen::clear ()
 {
-    clearEntireScreen();
-    home();
+  clearEntireScreen ();
+  home ();
 }
 
-void Screen::backspace()
+void
+Screen::backspace ()
 {
-    cuX = qMin(columns-1,cuX); // nowrap!
-    cuX = qMax(0,cuX-1);
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuX = qMax (0, cuX - 1);
 
-    if (screenLines[cuY].size() < cuX+1)
-        screenLines[cuY].resize(cuX+1);
+  if (screenLines[cuY].size () < cuX + 1)
+    screenLines[cuY].resize (cuX + 1);
 
-    if (BS_CLEARS) 
-        screenLines[cuY][cuX].character = ' ';
+  if (BS_CLEARS)
+    screenLines[cuY][cuX].character = ' ';
 }
 
-void Screen::tab(int n)
+void
+Screen::tab (int n)
 {
-    // note that TAB is a format effector (does not write ' ');
-    if (n == 0) n = 1;
-    while((n > 0) && (cuX < columns-1))
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0)
+    n = 1;
+  while ((n > 0) && (cuX < columns - 1))
     {
-        cursorRight(1); 
-        while((cuX < columns-1) && !tabStops[cuX]) 
-            cursorRight(1);
-        n--;
+      cursorRight (1);
+      while ((cuX < columns - 1) && !tabStops[cuX])
+	cursorRight (1);
+      n--;
     }
 }
 
-void Screen::backtab(int n)
+void
+Screen::backtab (int n)
 {
-    // note that TAB is a format effector (does not write ' ');
-    if (n == 0) n = 1;
-    while((n > 0) && (cuX > 0))
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0)
+    n = 1;
+  while ((n > 0) && (cuX > 0))
     {
-        cursorLeft(1); while((cuX > 0) && !tabStops[cuX]) cursorLeft(1);
-        n--;
+      cursorLeft (1);
+      while ((cuX > 0) && !tabStops[cuX])
+	cursorLeft (1);
+      n--;
     }
 }
 
-void Screen::clearTabStops()
+void
+Screen::clearTabStops ()
 {
-    for (int i = 0; i < columns; i++) tabStops[i] = false;
+  for (int i = 0; i < columns; i++)
+    tabStops[i] = false;
 }
 
-void Screen::changeTabStop(bool set)
+void
+Screen::changeTabStop (bool set)
 {
-    if (cuX >= columns) return;
-    tabStops[cuX] = set;
+  if (cuX >= columns)
+    return;
+  tabStops[cuX] = set;
 }
 
-void Screen::initTabStops()
+void
+Screen::initTabStops ()
 {
-    tabStops.resize(columns);
+  tabStops.resize (columns);
 
-    // Arrg! The 1st tabstop has to be one longer than the other.
-    // i.e. the kids start counting from 0 instead of 1.
-    // Other programs might behave correctly. Be aware.
-    for (int i = 0; i < columns; i++) 
-        tabStops[i] = (i%8 == 0 && i != 0);
+  // Arrg! The 1st tabstop has to be one longer than the other.
+  // i.e. the kids start counting from 0 instead of 1.
+  // Other programs might behave correctly. Be aware.
+  for (int i = 0; i < columns; i++)
+    tabStops[i] = (i % 8 == 0 && i != 0);
 }
 
-void Screen::newLine()
+void
+Screen::newLine ()
 {
-    if (getMode(MODE_NewLine)) 
-        toStartOfLine();
-    index();
+  if (getMode (MODE_NewLine))
+    toStartOfLine ();
+  index ();
 }
 
-void Screen::checkSelection(int from, int to)
+void
+Screen::checkSelection (int from, int to)
 {
-    if (selBegin == -1) 
-        return;
-    int scr_TL = loc(0, history->getLines());
-    //Clear entire selection if it overlaps region [from, to]
-    if ( (selBottomRight >= (from+scr_TL)) && (selTopLeft <= (to+scr_TL)) )
-        clearSelection();
+  if (selBegin == -1)
+    return;
+  int scr_TL = loc (0, history->getLines ());
+  //Clear entire selection if it overlaps region [from, to]
+  if ((selBottomRight >= (from + scr_TL)) && (selTopLeft <= (to + scr_TL)))
+    clearSelection ();
 }
 
-void Screen::displayCharacter(unsigned short c)
+void
+Screen::displayCharacter (unsigned short c)
 {
-    // Note that VT100 does wrapping BEFORE putting the character.
-    // This has impact on the assumption of valid cursor positions.
-    // We indicate the fact that a newline has to be triggered by
-    // putting the cursor one right to the last column of the screen.
+  // Note that VT100 does wrapping BEFORE putting the character.
+  // This has impact on the assumption of valid cursor positions.
+  // We indicate the fact that a newline has to be triggered by
+  // putting the cursor one right to the last column of the screen.
 
-    int w = konsole_wcwidth(c);
-    if (w <= 0)
-        return;
+  int w = konsole_wcwidth (c);
+  if (w <= 0)
+    return;
 
-    if (cuX+w > columns) {
-        if (getMode(MODE_Wrap)) {
-            lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | LINE_WRAPPED);
-            nextLine();
-        }
-        else
-            cuX = columns-w;
+  if (cuX + w > columns)
+    {
+      if (getMode (MODE_Wrap))
+	{
+	  lineProperties[cuY] =
+	    (LineProperty) (lineProperties[cuY] | LINE_WRAPPED);
+	  nextLine ();
+	}
+      else
+	cuX = columns - w;
     }
 
-    // ensure current line vector has enough elements
-    int size = screenLines[cuY].size();
-    if (size < cuX+w)
+  // ensure current line vector has enough elements
+  int size = screenLines[cuY].size ();
+  if (size < cuX + w)
     {
-        screenLines[cuY].resize(cuX+w);
+      screenLines[cuY].resize (cuX + w);
     }
 
-    if (getMode(MODE_Insert)) insertChars(w);
+  if (getMode (MODE_Insert))
+    insertChars (w);
 
-    lastPos = loc(cuX,cuY);
-
-    // check if selection is still valid.
-    checkSelection(lastPos, lastPos);
+  lastPos = loc (cuX, cuY);
 
-    Character& currentChar = screenLines[cuY][cuX];
+  // check if selection is still valid.
+  checkSelection (lastPos, lastPos);
+
+  Character & currentChar = screenLines[cuY][cuX];
 
-    currentChar.character = c;
-    currentChar.foregroundColor = effectiveForeground;
-    currentChar.backgroundColor = effectiveBackground;
-    currentChar.rendition = effectiveRendition;
+  currentChar.character = c;
+  currentChar.foregroundColor = effectiveForeground;
+  currentChar.backgroundColor = effectiveBackground;
+  currentChar.rendition = effectiveRendition;
 
-    int i = 0;
-    int newCursorX = cuX + w--;
-    while(w)
+  int i = 0;
+  int newCursorX = cuX + w--;
+  while (w)
     {
-        i++;
+      i++;
 
-        if ( screenLines[cuY].size() < cuX + i + 1 )
-            screenLines[cuY].resize(cuX+i+1);
+      if (screenLines[cuY].size () < cuX + i + 1)
+	screenLines[cuY].resize (cuX + i + 1);
 
-        Character& ch = screenLines[cuY][cuX + i];
-        ch.character = 0;
-        ch.foregroundColor = effectiveForeground;
-        ch.backgroundColor = effectiveBackground;
-        ch.rendition = effectiveRendition;
+      Character & ch = screenLines[cuY][cuX + i];
+      ch.character = 0;
+      ch.foregroundColor = effectiveForeground;
+      ch.backgroundColor = effectiveBackground;
+      ch.rendition = effectiveRendition;
 
-        w--;
+      w--;
     }
-    cuX = newCursorX;
+  cuX = newCursorX;
 }
 
-void Screen::compose(const QString& /*compose*/)
+void
+Screen::compose (const QString & /*compose */ )
 {
-    Q_ASSERT( 0 /*Not implemented yet*/ );
+  Q_ASSERT (0 /*Not implemented yet */ );
+
+  /*  if (lastPos == -1)
+     return;
+
+     QChar c(image[lastPos].character);
+     compose.prepend(c);
+     //compose.compose(); ### FIXME!
+     image[lastPos].character = compose[0].unicode(); */
+}
 
-    /*  if (lastPos == -1)
-        return;
+int
+Screen::scrolledLines () const
+{
+  return _scrolledLines;
+}
 
-        QChar c(image[lastPos].character);
-        compose.prepend(c);
-    //compose.compose(); ### FIXME!
-    image[lastPos].character = compose[0].unicode();*/
+int
+Screen::droppedLines () const
+{
+  return _droppedLines;
+}
+
+void
+Screen::resetDroppedLines ()
+{
+  _droppedLines = 0;
+}
+
+void
+Screen::resetScrolledLines ()
+{
+  _scrolledLines = 0;
 }
 
-int Screen::scrolledLines() const
+void
+Screen::scrollUp (int n)
 {
-    return _scrolledLines;
-}
-int Screen::droppedLines() const
-{
-    return _droppedLines;
+  if (n == 0)
+    n = 1;			// Default
+  if (_topMargin == 0)
+    addHistLine ();		// history.history
+  scrollUp (_topMargin, n);
 }
-void Screen::resetDroppedLines()
+
+QRect
+Screen::lastScrolledRegion () const
 {
-    _droppedLines = 0;
-}
-void Screen::resetScrolledLines()
-{
-    _scrolledLines = 0;
+  return _lastScrolledRegion;
 }
 
-void Screen::scrollUp(int n)
+void
+Screen::scrollUp (int from, int n)
 {
-    if (n == 0) n = 1; // Default
-    if (_topMargin == 0) addHistLine(); // history.history
-    scrollUp(_topMargin, n);
-}
+  if (n <= 0 || from + n > _bottomMargin)
+    return;
 
-QRect Screen::lastScrolledRegion() const
-{
-    return _lastScrolledRegion;
+  _scrolledLines -= n;
+  _lastScrolledRegion =
+    QRect (0, _topMargin, columns - 1, (_bottomMargin - _topMargin));
+
+  //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+  moveImage (loc (0, from), loc (0, from + n),
+	     loc (columns - 1, _bottomMargin));
+  clearImage (loc (0, _bottomMargin - n + 1),
+	      loc (columns - 1, _bottomMargin), ' ');
 }
 
-void Screen::scrollUp(int from, int n)
+void
+Screen::scrollDown (int n)
 {
-    if (n <= 0 || from + n > _bottomMargin) return;
-
-    _scrolledLines -= n;
-    _lastScrolledRegion = QRect(0,_topMargin,columns-1,(_bottomMargin-_topMargin));
-
-    //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
-    moveImage(loc(0,from),loc(0,from+n),loc(columns-1,_bottomMargin));
-    clearImage(loc(0,_bottomMargin-n+1),loc(columns-1,_bottomMargin),' ');
-}
-
-void Screen::scrollDown(int n)
-{
-    if (n == 0) n = 1; // Default
-    scrollDown(_topMargin, n);
+  if (n == 0)
+    n = 1;			// Default
+  scrollDown (_topMargin, n);
 }
 
-void Screen::scrollDown(int from, int n)
+void
+Screen::scrollDown (int from, int n)
 {
-    _scrolledLines += n;
+  _scrolledLines += n;
 
-    //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
-    if (n <= 0) 
-        return;
-    if (from > _bottomMargin) 
-        return;
-    if (from + n > _bottomMargin) 
-        n = _bottomMargin - from;
-    moveImage(loc(0,from+n),loc(0,from),loc(columns-1,_bottomMargin-n));
-    clearImage(loc(0,from),loc(columns-1,from+n-1),' ');
+  //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+  if (n <= 0)
+    return;
+  if (from > _bottomMargin)
+    return;
+  if (from + n > _bottomMargin)
+    n = _bottomMargin - from;
+  moveImage (loc (0, from + n), loc (0, from),
+	     loc (columns - 1, _bottomMargin - n));
+  clearImage (loc (0, from), loc (columns - 1, from + n - 1), ' ');
 }
 
-void Screen::setCursorYX(int y, int x)
+void
+Screen::setCursorYX (int y, int x)
 {
-    setCursorY(y); setCursorX(x);
+  setCursorY (y);
+  setCursorX (x);
+}
+
+void
+Screen::setCursorX (int x)
+{
+  if (x == 0)
+    x = 1;			// Default
+  x -= 1;			// Adjust
+  cuX = qMax (0, qMin (columns - 1, x));
 }
 
-void Screen::setCursorX(int x)
+void
+Screen::setCursorY (int y)
 {
-    if (x == 0) x = 1; // Default
-    x -= 1; // Adjust
-    cuX = qMax(0,qMin(columns-1, x));
+  if (y == 0)
+    y = 1;			// Default
+  y -= 1;			// Adjust
+  cuY =
+    qMax (0, qMin (lines - 1, y + (getMode (MODE_Origin) ? _topMargin : 0)));
 }
 
-void Screen::setCursorY(int y)
+void
+Screen::home ()
 {
-    if (y == 0) y = 1; // Default
-    y -= 1; // Adjust
-    cuY = qMax(0,qMin(lines  -1, y + (getMode(MODE_Origin) ? _topMargin : 0) ));
+  cuX = 0;
+  cuY = 0;
 }
 
-void Screen::home()
+void
+Screen::toStartOfLine ()
 {
-    cuX = 0;
-    cuY = 0;
+  cuX = 0;
 }
 
-void Screen::toStartOfLine()
+int
+Screen::getCursorX () const
 {
-    cuX = 0;
+  return cuX;
 }
 
-int Screen::getCursorX() const
+int
+Screen::getCursorY () const
 {
-    return cuX;
-}
-
-int Screen::getCursorY() const
-{
-    return cuY;
+  return cuY;
 }
 
-void Screen::clearImage(int loca, int loce, char c)
-{ 
-    int scr_TL=loc(0,history->getLines());
-    //FIXME: check positions
+void
+Screen::clearImage (int loca, int loce, char c)
+{
+  int scr_TL = loc (0, history->getLines ());
+  //FIXME: check positions
 
-    //Clear entire selection if it overlaps region to be moved...
-    if ( (selBottomRight > (loca+scr_TL) )&&(selTopLeft < (loce+scr_TL)) )
+  //Clear entire selection if it overlaps region to be moved...
+  if ((selBottomRight > (loca + scr_TL)) && (selTopLeft < (loce + scr_TL)))
     {
-        clearSelection();
+      clearSelection ();
     }
 
-    int topLine = loca/columns;
-    int bottomLine = loce/columns;
+  int topLine = loca / columns;
+  int bottomLine = loce / columns;
 
-    Character clearCh(c,currentForeground,currentBackground,DEFAULT_RENDITION);
+  Character clearCh (c, currentForeground, currentBackground,
+		     DEFAULT_RENDITION);
 
-    //if the character being used to clear the area is the same as the
-    //default character, the affected lines can simply be shrunk.
-    bool isDefaultCh = (clearCh == Character());
+  //if the character being used to clear the area is the same as the
+  //default character, the affected lines can simply be shrunk.
+  bool isDefaultCh = (clearCh == Character ());
 
-    for (int y=topLine;y<=bottomLine;y++)
+  for (int y = topLine; y <= bottomLine; y++)
     {
-        lineProperties[y] = 0;
-
-        int endCol = ( y == bottomLine) ? loce%columns : columns-1;
-        int startCol = ( y == topLine ) ? loca%columns : 0;
+      lineProperties[y] = 0;
 
-        QVector<Character>& line = screenLines[y];
+      int endCol = (y == bottomLine) ? loce % columns : columns - 1;
+      int startCol = (y == topLine) ? loca % columns : 0;
+
+      QVector < Character > &line = screenLines[y];
 
-        if ( isDefaultCh && endCol == columns-1 )
-        {
-            line.resize(startCol);
-        }
-        else
-        {
-            if (line.size() < endCol + 1)
-                line.resize(endCol+1);
+      if (isDefaultCh && endCol == columns - 1)
+	{
+	  line.resize (startCol);
+	}
+      else
+	{
+	  if (line.size () < endCol + 1)
+	    line.resize (endCol + 1);
 
-            Character* data = line.data();
-            for (int i=startCol;i<=endCol;i++)
-                data[i]=clearCh;
-        }
+	  Character *data = line.data ();
+	  for (int i = startCol; i <= endCol; i++)
+	    data[i] = clearCh;
+	}
     }
 }
 
-void Screen::moveImage(int dest, int sourceBegin, int sourceEnd)
+void
+Screen::moveImage (int dest, int sourceBegin, int sourceEnd)
 {
-    Q_ASSERT( sourceBegin <= sourceEnd );
+  Q_ASSERT (sourceBegin <= sourceEnd);
 
-    int lines=(sourceEnd-sourceBegin)/columns;
+  int lines = (sourceEnd - sourceBegin) / columns;
 
-    //move screen image and line properties:
-    //the source and destination areas of the image may overlap, 
-    //so it matters that we do the copy in the right order - 
-    //forwards if dest < sourceBegin or backwards otherwise.
-    //(search the web for 'memmove implementation' for details)
-    if (dest < sourceBegin)
+  //move screen image and line properties:
+  //the source and destination areas of the image may overlap, 
+  //so it matters that we do the copy in the right order - 
+  //forwards if dest < sourceBegin or backwards otherwise.
+  //(search the web for 'memmove implementation' for details)
+  if (dest < sourceBegin)
     {
-        for (int i=0;i<=lines;i++)
-        {
-            screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
-            lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
-        }
+      for (int i = 0; i <= lines; i++)
+	{
+	  screenLines[(dest / columns) + i] =
+	    screenLines[(sourceBegin / columns) + i];
+	  lineProperties[(dest / columns) + i] =
+	    lineProperties[(sourceBegin / columns) + i];
+	}
     }
-    else
+  else
     {
-        for (int i=lines;i>=0;i--)
-        {
-            screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
-            lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
-        }
-    }
-
-    if (lastPos != -1)
-    {
-        int diff = dest - sourceBegin; // Scroll by this amount
-        lastPos += diff;
-        if ((lastPos < 0) || (lastPos >= (lines*columns)))
-            lastPos = -1;
+      for (int i = lines; i >= 0; i--)
+	{
+	  screenLines[(dest / columns) + i] =
+	    screenLines[(sourceBegin / columns) + i];
+	  lineProperties[(dest / columns) + i] =
+	    lineProperties[(sourceBegin / columns) + i];
+	}
     }
 
-    // Adjust selection to follow scroll.
-    if (selBegin != -1)
+  if (lastPos != -1)
     {
-        bool beginIsTL = (selBegin == selTopLeft);
-        int diff = dest - sourceBegin; // Scroll by this amount
-        int scr_TL=loc(0,history->getLines());
-        int srca = sourceBegin+scr_TL; // Translate index from screen to global
-        int srce = sourceEnd+scr_TL; // Translate index from screen to global
-        int desta = srca+diff;
-        int deste = srce+diff;
+      int diff = dest - sourceBegin;	// Scroll by this amount
+      lastPos += diff;
+      if ((lastPos < 0) || (lastPos >= (lines * columns)))
+	lastPos = -1;
+    }
 
-        if ((selTopLeft >= srca) && (selTopLeft <= srce))
-            selTopLeft += diff;
-        else if ((selTopLeft >= desta) && (selTopLeft <= deste))
-            selBottomRight = -1; // Clear selection (see below)
+  // Adjust selection to follow scroll.
+  if (selBegin != -1)
+    {
+      bool beginIsTL = (selBegin == selTopLeft);
+      int diff = dest - sourceBegin;	// Scroll by this amount
+      int scr_TL = loc (0, history->getLines ());
+      int srca = sourceBegin + scr_TL;	// Translate index from screen to global
+      int srce = sourceEnd + scr_TL;	// Translate index from screen to global
+      int desta = srca + diff;
+      int deste = srce + diff;
 
-        if ((selBottomRight >= srca) && (selBottomRight <= srce))
-            selBottomRight += diff;
-        else if ((selBottomRight >= desta) && (selBottomRight <= deste))
-            selBottomRight = -1; // Clear selection (see below)
+      if ((selTopLeft >= srca) && (selTopLeft <= srce))
+	selTopLeft += diff;
+      else if ((selTopLeft >= desta) && (selTopLeft <= deste))
+	selBottomRight = -1;	// Clear selection (see below)
+
+      if ((selBottomRight >= srca) && (selBottomRight <= srce))
+	selBottomRight += diff;
+      else if ((selBottomRight >= desta) && (selBottomRight <= deste))
+	selBottomRight = -1;	// Clear selection (see below)
 
-        if (selBottomRight < 0)
-        {
-            clearSelection();
-        }
-        else
-        {
-            if (selTopLeft < 0)
-                selTopLeft = 0;
-        }
+      if (selBottomRight < 0)
+	{
+	  clearSelection ();
+	}
+      else
+	{
+	  if (selTopLeft < 0)
+	    selTopLeft = 0;
+	}
 
-        if (beginIsTL)
-            selBegin = selTopLeft;
-        else
-            selBegin = selBottomRight;
+      if (beginIsTL)
+	selBegin = selTopLeft;
+      else
+	selBegin = selBottomRight;
     }
 }
 
-void Screen::clearToEndOfScreen()
+void
+Screen::clearToEndOfScreen ()
 {
-    clearImage(loc(cuX,cuY),loc(columns-1,lines-1),' ');
+  clearImage (loc (cuX, cuY), loc (columns - 1, lines - 1), ' ');
 }
 
-void Screen::clearToBeginOfScreen()
+void
+Screen::clearToBeginOfScreen ()
 {
-    clearImage(loc(0,0),loc(cuX,cuY),' ');
+  clearImage (loc (0, 0), loc (cuX, cuY), ' ');
 }
 
-void Screen::clearEntireScreen()
+void
+Screen::clearEntireScreen ()
 {
-    // Add entire screen to history
-    for (int i = 0; i < (lines-1); i++)
+  // Add entire screen to history
+  for (int i = 0; i < (lines - 1); i++)
     {
-        addHistLine(); scrollUp(0,1);
+      addHistLine ();
+      scrollUp (0, 1);
     }
 
-    clearImage(loc(0,0),loc(columns-1,lines-1),' ');
+  clearImage (loc (0, 0), loc (columns - 1, lines - 1), ' ');
 }
 
 /*! fill screen with 'E'
   This is to aid screen alignment
   */
 
-void Screen::helpAlign()
+void
+Screen::helpAlign ()
 {
-    clearImage(loc(0,0),loc(columns-1,lines-1),'E');
+  clearImage (loc (0, 0), loc (columns - 1, lines - 1), 'E');
 }
 
-void Screen::clearToEndOfLine()
+void
+Screen::clearToEndOfLine ()
 {
-    clearImage(loc(cuX,cuY),loc(columns-1,cuY),' ');
+  clearImage (loc (cuX, cuY), loc (columns - 1, cuY), ' ');
 }
 
-void Screen::clearToBeginOfLine()
+void
+Screen::clearToBeginOfLine ()
 {
-    clearImage(loc(0,cuY),loc(cuX,cuY),' ');
+  clearImage (loc (0, cuY), loc (cuX, cuY), ' ');
 }
 
-void Screen::clearEntireLine()
+void
+Screen::clearEntireLine ()
 {
-    clearImage(loc(0,cuY),loc(columns-1,cuY),' ');
+  clearImage (loc (0, cuY), loc (columns - 1, cuY), ' ');
 }
 
-void Screen::setRendition(int re)
+void
+Screen::setRendition (int re)
 {
-    currentRendition |= re;
-    updateEffectiveRendition();
+  currentRendition |= re;
+  updateEffectiveRendition ();
 }
 
-void Screen::resetRendition(int re)
+void
+Screen::resetRendition (int re)
 {
-    currentRendition &= ~re;
-    updateEffectiveRendition();
+  currentRendition &= ~re;
+  updateEffectiveRendition ();
 }
 
-void Screen::setDefaultRendition()
+void
+Screen::setDefaultRendition ()
 {
-    setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
-    setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
-    currentRendition   = DEFAULT_RENDITION;
-    updateEffectiveRendition();
+  setForeColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR);
+  setBackColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR);
+  currentRendition = DEFAULT_RENDITION;
+  updateEffectiveRendition ();
 }
 
-void Screen::setForeColor(int space, int color)
+void
+Screen::setForeColor (int space, int color)
 {
-    currentForeground = CharacterColor(space, color);
+  currentForeground = CharacterColor (space, color);
 
-    if ( currentForeground.isValid() ) 
-        updateEffectiveRendition();
-    else 
-        setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
+  if (currentForeground.isValid ())
+    updateEffectiveRendition ();
+  else
+    setForeColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR);
 }
 
-void Screen::setBackColor(int space, int color)
+void
+Screen::setBackColor (int space, int color)
 {
-    currentBackground = CharacterColor(space, color);
+  currentBackground = CharacterColor (space, color);
 
-    if ( currentBackground.isValid() ) 
-        updateEffectiveRendition();
-    else
-        setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
+  if (currentBackground.isValid ())
+    updateEffectiveRendition ();
+  else
+    setBackColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR);
 }
 
-void Screen::clearSelection() 
+void
+Screen::clearSelection ()
 {
-    selBottomRight = -1;
-    selTopLeft = -1;
-    selBegin = -1;
+  selBottomRight = -1;
+  selTopLeft = -1;
+  selBegin = -1;
 }
 
-void Screen::getSelectionStart(int& column , int& line) const
+void
+Screen::getSelectionStart (int &column, int &line) const
 {
-    if ( selTopLeft != -1 )
+  if (selTopLeft != -1)
+    {
+      column = selTopLeft % columns;
+      line = selTopLeft / columns;
+    }
+  else
     {
-        column = selTopLeft % columns;
-        line = selTopLeft / columns; 
+      column = cuX + getHistLines ();
+      line = cuY + getHistLines ();
     }
-    else
+}
+
+void
+Screen::getSelectionEnd (int &column, int &line) const
+{
+  if (selBottomRight != -1)
     {
-        column = cuX + getHistLines();
-        line = cuY + getHistLines();
+      column = selBottomRight % columns;
+      line = selBottomRight / columns;
+    }
+  else
+    {
+      column = cuX + getHistLines ();
+      line = cuY + getHistLines ();
     }
 }
-void Screen::getSelectionEnd(int& column , int& line) const
+
+void
+Screen::setSelectionStart (const int x, const int y, const bool mode)
 {
-    if ( selBottomRight != -1 )
-    {
-        column = selBottomRight % columns;
-        line = selBottomRight / columns;
-    }
-    else
-    {
-        column = cuX + getHistLines();
-        line = cuY + getHistLines();
-    } 
-}
-void Screen::setSelectionStart(const int x, const int y, const bool mode)
-{
-    selBegin = loc(x,y); 
-    /* FIXME, HACK to correct for x too far to the right... */
-    if (x == columns) selBegin--;
+  selBegin = loc (x, y);
+  /* FIXME, HACK to correct for x too far to the right... */
+  if (x == columns)
+    selBegin--;
 
-    selBottomRight = selBegin;
-    selTopLeft = selBegin;
-    blockSelectionMode = mode;
+  selBottomRight = selBegin;
+  selTopLeft = selBegin;
+  blockSelectionMode = mode;
 }
 
-void Screen::setSelectionEnd( const int x, const int y)
+void
+Screen::setSelectionEnd (const int x, const int y)
 {
-    if (selBegin == -1) 
-        return;
+  if (selBegin == -1)
+    return;
 
-    int endPos =  loc(x,y); 
+  int endPos = loc (x, y);
 
-    if (endPos < selBegin)
+  if (endPos < selBegin)
     {
-        selTopLeft = endPos;
-        selBottomRight = selBegin;
+      selTopLeft = endPos;
+      selBottomRight = selBegin;
     }
-    else
+  else
     {
-        /* FIXME, HACK to correct for x too far to the right... */
-        if (x == columns) 
-            endPos--;
+      /* FIXME, HACK to correct for x too far to the right... */
+      if (x == columns)
+	endPos--;
 
-        selTopLeft = selBegin;
-        selBottomRight = endPos;
+      selTopLeft = selBegin;
+      selBottomRight = endPos;
     }
 
-    // Normalize the selection in column mode
-    if (blockSelectionMode)
+  // Normalize the selection in column mode
+  if (blockSelectionMode)
     {
-        int topRow = selTopLeft / columns;
-        int topColumn = selTopLeft % columns;
-        int bottomRow = selBottomRight / columns;
-        int bottomColumn = selBottomRight % columns;
+      int topRow = selTopLeft / columns;
+      int topColumn = selTopLeft % columns;
+      int bottomRow = selBottomRight / columns;
+      int bottomColumn = selBottomRight % columns;
 
-        selTopLeft = loc(qMin(topColumn,bottomColumn),topRow);
-        selBottomRight = loc(qMax(topColumn,bottomColumn),bottomRow);
+      selTopLeft = loc (qMin (topColumn, bottomColumn), topRow);
+      selBottomRight = loc (qMax (topColumn, bottomColumn), bottomRow);
     }
 }
 
-bool Screen::isSelected( const int x,const int y) const
+bool
+Screen::isSelected (const int x, const int y) const
 {
-    bool columnInSelection = true;
-    if (blockSelectionMode)
+  bool columnInSelection = true;
+  if (blockSelectionMode)
     {
-        columnInSelection = x >= (selTopLeft % columns) &&
-            x <= (selBottomRight % columns);
+      columnInSelection = x >= (selTopLeft % columns) &&
+	x <= (selBottomRight % columns);
     }
 
-    int pos = loc(x,y);
-    return pos >= selTopLeft && pos <= selBottomRight && columnInSelection;
+  int pos = loc (x, y);
+  return pos >= selTopLeft && pos <= selBottomRight && columnInSelection;
 }
 
-QString Screen::selectedText(bool preserveLineBreaks) const
+QString
+Screen::selectedText (bool preserveLineBreaks) const
 {
-    QString result;
-    QTextStream stream(&result, QIODevice::ReadWrite);
+  QString result;
+  QTextStream stream (&result, QIODevice::ReadWrite);
 
-    PlainTextDecoder decoder;
-    decoder.begin(&stream);
-    writeSelectionToStream(&decoder , preserveLineBreaks);
-    decoder.end();
+  PlainTextDecoder decoder;
+  decoder.begin (&stream);
+  writeSelectionToStream (&decoder, preserveLineBreaks);
+  decoder.end ();
 
-    return result;
+  return result;
 }
 
-bool Screen::isSelectionValid() const
+bool
+Screen::isSelectionValid () const
 {
-    return selTopLeft >= 0 && selBottomRight >= 0;
+  return selTopLeft >= 0 && selBottomRight >= 0;
 }
 
-void Screen::writeSelectionToStream(TerminalCharacterDecoder* decoder , 
-        bool preserveLineBreaks) const
+void
+Screen::writeSelectionToStream (TerminalCharacterDecoder * decoder,
+                                bool preserveLineBreaks) const
 {
-    if (!isSelectionValid())
-        return;
-    writeToStream(decoder,selTopLeft,selBottomRight,preserveLineBreaks);
+  if (!isSelectionValid ())
+    return;
+  writeToStream (decoder, selTopLeft, selBottomRight, preserveLineBreaks);
 }
 
-void Screen::writeToStream(TerminalCharacterDecoder* decoder, 
-        int startIndex, int endIndex,
-        bool preserveLineBreaks) const
+void
+Screen::writeToStream (TerminalCharacterDecoder * decoder,
+		       int startIndex, int endIndex,
+                       bool preserveLineBreaks) const
 {
-    int top = startIndex / columns;    
-    int left = startIndex % columns;
-
-    int bottom = endIndex / columns;
-    int right = endIndex % columns;
+  int top = startIndex / columns;
+  int left = startIndex % columns;
 
-    Q_ASSERT( top >= 0 && left >= 0 && bottom >= 0 && right >= 0 );
+  int bottom = endIndex / columns;
+  int right = endIndex % columns;
 
-    for (int y=top;y<=bottom;y++)
+  Q_ASSERT (top >= 0 && left >= 0 && bottom >= 0 && right >= 0);
+
+  for (int y = top; y <= bottom; y++)
     {
-        int start = 0;
-        if ( y == top || blockSelectionMode ) start = left;
-
-        int count = -1;
-        if ( y == bottom || blockSelectionMode ) count = right - start + 1;
+      int start = 0;
+      if (y == top || blockSelectionMode)
+	start = left;
 
-        const bool appendNewLine = ( y != bottom );
-        int copied = copyLineToStream( y,
-                start,
-                count,
-                decoder, 
-                appendNewLine,
-                preserveLineBreaks );
+      int count = -1;
+      if (y == bottom || blockSelectionMode)
+	count = right - start + 1;
+
+      const bool appendNewLine = (y != bottom);
+      int copied = copyLineToStream (y,
+				     start,
+				     count,
+				     decoder,
+				     appendNewLine,
+				     preserveLineBreaks);
 
-        // if the selection goes beyond the end of the last line then
-        // append a new line character.
-        //
-        // this makes it possible to 'select' a trailing new line character after
-        // the text on a line.  
-        if ( y == bottom && 
-                copied < count    )
-        {
-            Character newLineChar('\n');
-            decoder->decodeLine(&newLineChar,1,0);
-        }
-    }    
+      // if the selection goes beyond the end of the last line then
+      // append a new line character.
+      //
+      // this makes it possible to 'select' a trailing new line character after
+      // the text on a line.  
+      if (y == bottom && copied < count)
+	{
+	  Character newLineChar ('\n');
+	  decoder->decodeLine (&newLineChar, 1, 0);
+	}
+    }
 }
 
-int Screen::copyLineToStream(int line , 
-        int start, 
-        int count,
-        TerminalCharacterDecoder* decoder,
-        bool appendNewLine,
-        bool preserveLineBreaks) const
+int
+Screen::copyLineToStream (int line,
+			  int start,
+			  int count,
+			  TerminalCharacterDecoder * decoder,
+			  bool appendNewLine,
+                          bool preserveLineBreaks) const
 {
-    //buffer to hold characters for decoding
-    //the buffer is static to avoid initialising every 
-    //element on each call to copyLineToStream
-    //(which is unnecessary since all elements will be overwritten anyway)
-    static const int MAX_CHARS = 1024;
-    static Character characterBuffer[MAX_CHARS];
+  //buffer to hold characters for decoding
+  //the buffer is static to avoid initialising every 
+  //element on each call to copyLineToStream
+  //(which is unnecessary since all elements will be overwritten anyway)
+  static const int MAX_CHARS = 1024;
+  static Character characterBuffer[MAX_CHARS];
 
-    assert( count < MAX_CHARS );
+  assert (count < MAX_CHARS);
 
-    LineProperty currentLineProperties = 0;
+  LineProperty currentLineProperties = 0;
 
-    //determine if the line is in the history buffer or the screen image
-    if (line < history->getLines())
+  //determine if the line is in the history buffer or the screen image
+  if (line < history->getLines ())
     {
-        const int lineLength = history->getLineLen(line);
+      const int lineLength = history->getLineLen (line);
 
-        // ensure that start position is before end of line
-        start = qMin(start,qMax(0,lineLength-1));
+      // ensure that start position is before end of line
+      start = qMin (start, qMax (0, lineLength - 1));
 
-        // retrieve line from history buffer.  It is assumed
-        // that the history buffer does not store trailing white space
-        // at the end of the line, so it does not need to be trimmed here 
-        if (count == -1)
-        {
-            count = lineLength-start;
-        }
-        else
-        {
-            count = qMin(start+count,lineLength)-start;
-        }
+      // retrieve line from history buffer.  It is assumed
+      // that the history buffer does not store trailing white space
+      // at the end of the line, so it does not need to be trimmed here 
+      if (count == -1)
+	{
+	  count = lineLength - start;
+	}
+      else
+	{
+	  count = qMin (start + count, lineLength) - start;
+	}
 
-        // safety checks
-        assert( start >= 0 );
-        assert( count >= 0 );    
-        assert( (start+count) <= history->getLineLen(line) );
+      // safety checks
+      assert (start >= 0);
+      assert (count >= 0);
+      assert ((start + count) <= history->getLineLen (line));
 
-        history->getCells(line,start,count,characterBuffer);
+      history->getCells (line, start, count, characterBuffer);
 
-        if ( history->isWrappedLine(line) )
-            currentLineProperties |= LINE_WRAPPED;
+      if (history->isWrappedLine (line))
+	currentLineProperties |= LINE_WRAPPED;
     }
-    else
+  else
     {
-        if ( count == -1 )
-            count = columns - start;
+      if (count == -1)
+	count = columns - start;
 
-        assert( count >= 0 );
+      assert (count >= 0);
 
-        const int screenLine = line-history->getLines();
+      const int screenLine = line - history->getLines ();
 
-        Character* data = screenLines[screenLine].data();
-        int length = screenLines[screenLine].count();
+      Character *data = screenLines[screenLine].data ();
+      int length = screenLines[screenLine].count ();
 
-        //retrieve line from screen image
-        for (int i=start;i < qMin(start+count,length);i++)
-        {
-            characterBuffer[i-start] = data[i];
-        }
+      //retrieve line from screen image
+      for (int i = start; i < qMin (start + count, length); i++)
+	{
+	  characterBuffer[i - start] = data[i];
+	}
 
-        // count cannot be any greater than length
-        count = qBound(0,count,length-start);
+      // count cannot be any greater than length
+      count = qBound (0, count, length - start);
 
-        Q_ASSERT( screenLine < lineProperties.count() );
-        currentLineProperties |= lineProperties[screenLine]; 
+      Q_ASSERT (screenLine < lineProperties.count ());
+      currentLineProperties |= lineProperties[screenLine];
     }
 
-    // add new line character at end
-    const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
-        !preserveLineBreaks;
+  // add new line character at end
+  const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
+    !preserveLineBreaks;
 
-    if ( !omitLineBreak && appendNewLine && (count+1 < MAX_CHARS) )
+  if (!omitLineBreak && appendNewLine && (count + 1 < MAX_CHARS))
     {
-        characterBuffer[count] = '\n';
-        count++;
+      characterBuffer[count] = '\n';
+      count++;
     }
 
-    //decode line and write to text stream    
-    decoder->decodeLine( (Character*) characterBuffer , 
-            count, currentLineProperties );
+  //decode line and write to text stream    
+  decoder->decodeLine ((Character *) characterBuffer,
+		       count, currentLineProperties);
 
-    return count;
+  return count;
 }
 
-void Screen::writeLinesToStream(TerminalCharacterDecoder* decoder, int fromLine, int toLine) const
+void
+Screen::writeLinesToStream (TerminalCharacterDecoder * decoder, int fromLine,
+                            int toLine) const
 {
-    writeToStream(decoder,loc(0,fromLine),loc(columns-1,toLine));
+  writeToStream (decoder, loc (0, fromLine), loc (columns - 1, toLine));
 }
 
-void Screen::addHistLine()
+void
+Screen::addHistLine ()
 {
-    // add line to history buffer
-    // we have to take care about scrolling, too...
+  // add line to history buffer
+  // we have to take care about scrolling, too...
 
-    if (hasScroll())
+  if (hasScroll ())
     {
-        int oldHistLines = history->getLines();
+      int oldHistLines = history->getLines ();
 
-        history->addCellsVector(screenLines[0]);
-        history->addLine( lineProperties[0] & LINE_WRAPPED );
+      history->addCellsVector (screenLines[0]);
+      history->addLine (lineProperties[0] & LINE_WRAPPED);
 
-        int newHistLines = history->getLines();
+      int newHistLines = history->getLines ();
 
-        bool beginIsTL = (selBegin == selTopLeft);
+      bool beginIsTL = (selBegin == selTopLeft);
 
-        // If the history is full, increment the count
-        // of dropped lines
-        if ( newHistLines == oldHistLines )
-            _droppedLines++;
+      // If the history is full, increment the count
+      // of dropped lines
+      if (newHistLines == oldHistLines)
+	_droppedLines++;
 
-        // Adjust selection for the new point of reference
-        if (newHistLines > oldHistLines)
-        {
-            if (selBegin != -1)
-            {
-                selTopLeft += columns;
-                selBottomRight += columns;
-            }
-        }
+      // Adjust selection for the new point of reference
+      if (newHistLines > oldHistLines)
+	{
+	  if (selBegin != -1)
+	    {
+	      selTopLeft += columns;
+	      selBottomRight += columns;
+	    }
+	}
 
-        if (selBegin != -1)
-        {
-            // Scroll selection in history up
-            int top_BR = loc(0, 1+newHistLines);
+      if (selBegin != -1)
+	{
+	  // Scroll selection in history up
+	  int top_BR = loc (0, 1 + newHistLines);
 
-            if (selTopLeft < top_BR)
-                selTopLeft -= columns;
+	  if (selTopLeft < top_BR)
+	    selTopLeft -= columns;
 
-            if (selBottomRight < top_BR)
-                selBottomRight -= columns;
+	  if (selBottomRight < top_BR)
+	    selBottomRight -= columns;
 
-            if (selBottomRight < 0)
-                clearSelection();
-            else
-            {
-                if (selTopLeft < 0)
-                    selTopLeft = 0;
-            }
+	  if (selBottomRight < 0)
+	    clearSelection ();
+	  else
+	    {
+	      if (selTopLeft < 0)
+		selTopLeft = 0;
+	    }
 
-            if (beginIsTL)
-                selBegin = selTopLeft;
-            else
-                selBegin = selBottomRight;
-        }
+	  if (beginIsTL)
+	    selBegin = selTopLeft;
+	  else
+	    selBegin = selBottomRight;
+	}
     }
 
 }
 
-int Screen::getHistLines() const
+int
+Screen::getHistLines () const
 {
-    return history->getLines();
+  return history->getLines ();
 }
 
-void Screen::setScroll(const HistoryType& t , bool copyPreviousScroll)
+void
+Screen::setScroll (const HistoryType & t, bool copyPreviousScroll)
 {
-    clearSelection();
+  clearSelection ();
 
-    if ( copyPreviousScroll )
-        history = t.scroll(history);
-    else
+  if (copyPreviousScroll)
+    history = t.scroll (history);
+  else
     {
-        HistoryScroll* oldScroll = history;
-        history = t.scroll(0);
-        delete oldScroll;
+      HistoryScroll *oldScroll = history;
+      history = t.scroll (0);
+      delete oldScroll;
     }
 }
 
-bool Screen::hasScroll() const
+bool
+Screen::hasScroll () const
 {
-    return history->hasScroll();
+  return history->hasScroll ();
 }
 
-const HistoryType& Screen::getScroll() const
+const HistoryType &
+Screen::getScroll () const
 {
-    return history->getType();
+  return history->getType ();
 }
 
-void Screen::setLineProperty(LineProperty property , bool enable)
+void
+Screen::setLineProperty (LineProperty property, bool enable)
 {
-    if ( enable )
-        lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | property);
-    else
-        lineProperties[cuY] = (LineProperty)(lineProperties[cuY] & ~property);
+  if (enable)
+    lineProperties[cuY] = (LineProperty) (lineProperties[cuY] | property);
+  else
+    lineProperties[cuY] = (LineProperty) (lineProperties[cuY] & ~property);
 }
-void Screen::fillWithDefaultChar(Character* dest, int count)
+
+void
+Screen::fillWithDefaultChar (Character * dest, int count)
 {
-    for (int i=0;i<count;i++)
-        dest[i] = defaultChar;
+  for (int i = 0; i < count; i++)
+    dest[i] = defaultChar;
 }
diff --git a/gui/src/terminal/Screen.h b/gui/src/terminal/Screen.h
--- a/gui/src/terminal/Screen.h
+++ b/gui/src/terminal/Screen.h
@@ -64,255 +64,255 @@ class TerminalCharacterDecoder;
     setSelectionStart() and setSelectionEnd().  The selected text can be retrieved
     using selectedText().  When getImage() is used to retrieve the visible image,
     characters which are part of the selection have their colours inverted.   
 */
 class Screen
 {
 public:
     /** Construct a new screen image of size @p lines by @p columns. */
-    Screen(int lines, int columns);
-    ~Screen();
+  Screen (int lines, int columns);
+   ~Screen ();
 
-    // VT100/2 Operations 
-    // Cursor Movement
-    
+  // VT100/2 Operations 
+  // Cursor Movement
+
     /** 
      * Move the cursor up by @p n lines.  The cursor will stop at the 
      * top margin.
      */
-    void cursorUp(int n);
+  void cursorUp (int n);
     /** 
      * Move the cursor down by @p n lines.  The cursor will stop at the
      * bottom margin.
      */
-    void cursorDown(int n);
+  void cursorDown (int n);
     /** 
      * Move the cursor to the left by @p n columns.
      * The cursor will stop at the first column.
      */
-    void cursorLeft(int n);
+  void cursorLeft (int n);
     /** 
      * Move the cursor to the right by @p n columns.
      * The cursor will stop at the right-most column.
      */
-    void cursorRight(int n);
+  void cursorRight (int n);
     /** Position the cursor on line @p y. */
-    void setCursorY(int y);
+  void setCursorY (int y);
     /** Position the cursor at column @p x. */
-    void setCursorX(int x);
+  void setCursorX (int x);
     /** Position the cursor at line @p y, column @p x. */
-    void setCursorYX(int y, int x);
+  void setCursorYX (int y, int x);
     /**
      * Sets the margins for scrolling the screen.
      *
      * @param topLine The top line of the new scrolling margin. 
      * @param bottomLine The bottom line of the new scrolling margin. 
      */
-    void setMargins(int topLine , int bottomLine);
-    /** Returns the top line of the scrolling region. */ 
-    int topMargin() const;
+  void setMargins (int topLine, int bottomLine);
+    /** Returns the top line of the scrolling region. */
+  int topMargin () const;
     /** Returns the bottom line of the scrolling region. */
-    int bottomMargin() const;
+  int bottomMargin () const;
 
     /** 
      * Resets the scrolling margins back to the top and bottom lines
      * of the screen.
      */
-    void setDefaultMargins();
-    
+  void setDefaultMargins ();
+
     /** 
      * Moves the cursor down one line, if the MODE_NewLine mode 
      * flag is enabled then the cursor is returned to the leftmost
      * column first.
      *
      * Equivalent to NextLine() if the MODE_NewLine flag is set
      * or index() otherwise. 
      */
-    void newLine();
+  void newLine ();
     /**
      * Moves the cursor down one line and positions it at the beginning
      * of the line.  Equivalent to calling Return() followed by index()
      */
-    void nextLine();
+  void nextLine ();
 
     /** 
      * Move the cursor down one line.  If the cursor is on the bottom
      * line of the scrolling region (as returned by bottomMargin()) the
      * scrolling region is scrolled up by one line instead.
      */
-    void index();
+  void index ();
     /**
      * Move the cursor up one line.  If the cursor is on the top line
      * of the scrolling region (as returned by topMargin()) the scrolling
      * region is scrolled down by one line instead.
      */
-    void reverseIndex();
-    
+  void reverseIndex ();
+
     /** 
      * Scroll the scrolling region of the screen up by @p n lines. 
      * The scrolling region is initially the whole screen, but can be changed 
      * using setMargins()
-     */ 
-    void scrollUp(int n);
+     */
+  void scrollUp (int n);
     /**
      * Scroll the scrolling region of the screen down by @p n lines.
      * The scrolling region is initially the whole screen, but can be changed
      * using setMargins()
      */
-    void scrollDown(int n);
+  void scrollDown (int n);
     /** 
      * Moves the cursor to the beginning of the current line. 
      * Equivalent to setCursorX(0)
      */
-    void toStartOfLine();
+  void toStartOfLine ();
     /** 
      * Moves the cursor one column to the left and erases the character
      * at the new cursor position.
      */
-    void backspace();
+  void backspace ();
     /** Moves the cursor @p n tab-stops to the right. */
-    void tab(int n = 1);
+  void tab (int n = 1);
     /** Moves the cursor @p n tab-stops to the left. */
-    void backtab(int n);
-    
-    // Editing
-    
+  void backtab (int n);
+
+  // Editing
+
     /** 
      * Erase @p n characters beginning from the current cursor position. 
      * This is equivalent to over-writing @p n characters starting with the current
      * cursor position with spaces.
      * If @p n is 0 then one character is erased. 
      */
-    void eraseChars(int n);
+  void eraseChars (int n);
     /** 
      * Delete @p n characters beginning from the current cursor position. 
      * If @p n is 0 then one character is deleted. 
      */
-    void deleteChars(int n);
+  void deleteChars (int n);
     /**
      * Insert @p n blank characters beginning from the current cursor position.
      * The position of the cursor is not altered.  
      * If @p n is 0 then one character is inserted.
      */
-    void insertChars(int n);
+  void insertChars (int n);
     /** 
      * Removes @p n lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is removed.
      */
-    void deleteLines(int n);
+  void deleteLines (int n);
     /**
      * Inserts @p lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is inserted.
      */
-    void insertLines(int n);
+  void insertLines (int n);
     /** Clears all the tab stops. */
-    void clearTabStops();
-    /**  Sets or removes a tab stop at the cursor's current column. */ 
-    void changeTabStop(bool set);
-   
+  void clearTabStops ();
+    /**  Sets or removes a tab stop at the cursor's current column. */
+  void changeTabStop (bool set);
+
     /** Resets (clears) the specified screen @p mode. */
-    void resetMode(int mode);
+  void resetMode (int mode);
     /** Sets (enables) the specified screen @p mode. */
-    void setMode(int mode);
+  void setMode (int mode);
     /** 
      * Saves the state of the specified screen @p mode.  It can be restored
      * using restoreMode()
      */
-    void saveMode(int mode);
+  void saveMode (int mode);
     /** Restores the state of a screen @p mode saved by calling saveMode() */
-    void restoreMode(int mode);
+  void restoreMode (int mode);
     /** Returns whether the specified screen @p mode is enabled or not .*/
-    bool getMode(int mode) const;
-   
+  bool getMode (int mode) const;
+
     /** 
      * Saves the current position and appearance (text color and style) of the cursor. 
      * It can be restored by calling restoreCursor() 
-     */ 
-    void saveCursor();
+     */
+  void saveCursor ();
     /** Restores the position and appearance of the cursor.  See saveCursor() */
-    void restoreCursor();
-   
-    /** Clear the whole screen, moving the current screen contents into the history first. */ 
-    void clearEntireScreen();
+  void restoreCursor ();
+
+    /** Clear the whole screen, moving the current screen contents into the history first. */
+  void clearEntireScreen ();
     /** 
      * Clear the area of the screen from the current cursor position to the end of 
      * the screen.
      */
-    void clearToEndOfScreen();
+  void clearToEndOfScreen ();
     /**
      * Clear the area of the screen from the current cursor position to the start
      * of the screen.
      */
-    void clearToBeginOfScreen();
+  void clearToBeginOfScreen ();
     /** Clears the whole of the line on which the cursor is currently positioned. */
-    void clearEntireLine();
+  void clearEntireLine ();
     /** Clears from the current cursor position to the end of the line. */
-    void clearToEndOfLine();
+  void clearToEndOfLine ();
     /** Clears from the current cursor position to the beginning of the line. */
-    void clearToBeginOfLine();
-    
+  void clearToBeginOfLine ();
+
     /** Fills the entire screen with the letter 'E' */
-    void helpAlign();
-       
+  void helpAlign ();
+
     /** 
      * Enables the given @p rendition flag.  Rendition flags control the appearance 
      * of characters on the screen.
      *
      * @see Character::rendition
-     */  
-    void setRendition(int rendition);
+     */
+  void setRendition (int rendition);
     /**
      * Disables the given @p rendition flag.  Rendition flags control the appearance
      * of characters on the screen.
      *
      * @see Character::rendition
      */
-    void resetRendition(int rendition);
-    
+  void resetRendition (int rendition);
+
     /** 
      * Sets the cursor's foreground color.
      * @param space The color space used by the @p color argument
      * @param color The new foreground color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
-    void setForeColor(int space, int color);
+  void setForeColor (int space, int color);
     /**
      * Sets the cursor's background color.
      * @param space The color space used by the @p color argumnet.
      * @param color The new background color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
-    void setBackColor(int space, int color);
+  void setBackColor (int space, int color);
     /** 
      * Resets the cursor's color back to the default and sets the 
      * character's rendition flags back to the default settings.
      */
-    void setDefaultRendition();
-    
+  void setDefaultRendition ();
+
     /** Returns the column which the cursor is positioned at. */
-    int  getCursorX() const;
+  int getCursorX () const;
     /** Returns the line which the cursor is positioned on. */
-    int  getCursorY() const;
-   
+  int getCursorY () const;
+
     /** Clear the entire screen and move the cursor to the home position.
      * Equivalent to calling clearEntireScreen() followed by home().
      */
-    void clear();
+  void clear ();
     /** 
      * Sets the position of the cursor to the 'home' position at the top-left
      * corner of the screen (0,0) 
      */
-    void home();
+  void home ();
     /**
      * Resets the state of the screen.  This resets the various screen modes
      * back to their default states.  The cursor style and colors are reset
      * (as if setDefaultRendition() had been called)
      *
      * <ul>
      * <li>Line wrapping is enabled.</li>
      * <li>Origin mode is disabled.</li>
@@ -320,167 +320,175 @@ public:
      * <li>Cursor mode is enabled.  TODO Document me</li>
      * <li>Screen mode is disabled. TODO Document me</li>
      * <li>New line mode is disabled.  TODO Document me</li>
      * </ul>
      *
      * If @p clearScreen is true then the screen contents are erased entirely, 
      * otherwise they are unaltered.
      */
-    void reset(bool clearScreen = true);
-   
+  void reset (bool clearScreen = true);
+
     /** 
      * Displays a new character at the current cursor position. 
      * 
      * If the cursor is currently positioned at the right-edge of the screen and
      * line wrapping is enabled then the character is added at the start of a new 
      * line below the current one.
      *
      * If the MODE_Insert screen mode is currently enabled then the character 
      * is inserted at the current cursor position, otherwise it will replace the 
      * character already at the current cursor position.  
-     */ 
-    void displayCharacter(unsigned short c);
-    
-    // Do composition with last shown character FIXME: Not implemented yet for KDE 4
-    void compose(const QString& compose);
-    
+     */
+  void displayCharacter (unsigned short c);
+
+  // Do composition with last shown character FIXME: Not implemented yet for KDE 4
+  void compose (const QString & compose);
+
     /** 
      * Resizes the image to a new fixed size of @p new_lines by @p new_columns.  
      * In the case that @p new_columns is smaller than the current number of columns,
      * existing lines are not truncated.  This prevents characters from being lost
      * if the terminal display is resized smaller and then larger again.
      *
      * The top and bottom margins are reset to the top and bottom of the new 
      * screen size.  Tab stops are also reset and the current selection is
      * cleared.
      */
-    void resizeImage(int new_lines, int new_columns);
-    
+  void resizeImage (int new_lines, int new_columns);
+
     /**
      * Returns the current screen image.  
      * The result is an array of Characters of size [getLines()][getColumns()] which
      * must be freed by the caller after use.
      *
      * @param dest Buffer to copy the characters into
      * @param size Size of @p dest in Characters
      * @param startLine Index of first line to copy
      * @param endLine Index of last line to copy
      */
-    void getImage( Character* dest , int size , int startLine , int endLine ) const;
+  void getImage (Character * dest, int size, int startLine,
+		 int endLine) const;
 
     /** 
      * Returns the additional attributes associated with lines in the image.
      * The most important attribute is LINE_WRAPPED which specifies that the 
      * line is wrapped,
      * other attributes control the size of characters in the line.
      */
-    QVector<LineProperty> getLineProperties( int startLine , int endLine ) const;
-    
+    QVector < LineProperty > getLineProperties (int startLine,
+						int endLine) const;
+
 
     /** Return the number of lines. */
-    int getLines() const   
-    { return lines; }
+  int getLines () const
+  {
+    return lines;
+  }
     /** Return the number of columns. */
-    int getColumns() const 
-    { return columns; }
+  int getColumns () const
+  {
+    return columns;
+  }
     /** Return the number of lines in the history buffer. */
-    int getHistLines() const;
+  int getHistLines () const;
     /** 
      * Sets the type of storage used to keep lines in the history. 
      * If @p copyPreviousScroll is true then the contents of the previous 
      * history buffer are copied into the new scroll.
      */
-    void setScroll(const HistoryType& , bool copyPreviousScroll = true);
+  void setScroll (const HistoryType &, bool copyPreviousScroll = true);
     /** Returns the type of storage used to keep lines in the history. */
-    const HistoryType& getScroll() const;
+  const HistoryType & getScroll () const;
     /** 
      * Returns true if this screen keeps lines that are scrolled off the screen
      * in a history buffer.
      */
-    bool hasScroll() const;
+  bool hasScroll () const;
 
     /** 
      * Sets the start of the selection.
      *
      * @param column The column index of the first character in the selection.
      * @param line The line index of the first character in the selection.
      * @param blockSelectionMode True if the selection is in column mode.
      */
-    void setSelectionStart(const int column, const int line, const bool blockSelectionMode);
-    
+  void setSelectionStart (const int column, const int line,
+			  const bool blockSelectionMode);
+
     /**
      * Sets the end of the current selection.
      *
      * @param column The column index of the last character in the selection.
      * @param line The line index of the last character in the selection. 
-     */ 
-    void setSelectionEnd(const int column, const int line);
-   
+     */
+  void setSelectionEnd (const int column, const int line);
+
     /**
      * Retrieves the start of the selection or the cursor position if there
      * is no selection.
      */
-    void getSelectionStart(int& column , int& line) const;
-    
+  void getSelectionStart (int &column, int &line) const;
+
     /**
      * Retrieves the end of the selection or the cursor position if there
      * is no selection.
      */
-    void getSelectionEnd(int& column , int& line) const;
+  void getSelectionEnd (int &column, int &line) const;
 
     /** Clears the current selection */
-    void clearSelection();
+  void clearSelection ();
 
     /** 
       *  Returns true if the character at (@p column, @p line) is part of the
       *  current selection. 
-      */ 
-    bool isSelected(const int column,const int line) const;
+      */
+  bool isSelected (const int column, const int line) const;
 
     /** 
      * Convenience method.  Returns the currently selected text. 
      * @param preserveLineBreaks Specifies whether new line characters should 
      * be inserted into the returned text at the end of each terminal line.
      */
-    QString selectedText(bool preserveLineBreaks) const;
-        
+  QString selectedText (bool preserveLineBreaks) const;
+
     /**
      * Copies part of the output to a stream.
      *
      * @param decoder A decoder which converts terminal characters into text
      * @param fromLine The first line in the history to retrieve
      * @param toLine The last line in the history to retrieve
      */
-    void writeLinesToStream(TerminalCharacterDecoder* decoder, int fromLine, int toLine) const;
+  void writeLinesToStream (TerminalCharacterDecoder * decoder, int fromLine,
+			   int toLine) const;
 
     /**
      * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
      * into a stream.
      *
      * @param decoder A decoder which converts terminal characters into text.  
      * PlainTextDecoder is the most commonly used decoder which converts characters 
      * into plain text with no formatting.
      * @param preserveLineBreaks Specifies whether new line characters should 
      * be inserted into the returned text at the end of each terminal line. 
      */
-    void writeSelectionToStream(TerminalCharacterDecoder* decoder , bool
-                                preserveLineBreaks = true) const;
+  void writeSelectionToStream (TerminalCharacterDecoder * decoder, bool
+			       preserveLineBreaks = true) const;
 
     /**
      * Checks if the text between from and to is inside the current
      * selection. If this is the case, the selection is cleared. The
      * from and to are coordinates in the current viewable window.
      * The loc(x,y) macro can be used to generate these values from a
      * column,line pair.
      *
      * @param from The start of the area to check.
      * @param to The end of the area to check
      */
-    void checkSelection(int from, int to);
+  void checkSelection (int from, int to);
 
     /** 
      * Sets or clears an attribute of the current line.
      * 
      * @param property The attribute to set or clear
      * Possible properties are:
      * LINE_WRAPPED:     Specifies that the line is wrapped.
      * LINE_DOUBLEWIDTH: Specifies that the characters in the current line
@@ -489,182 +497,182 @@ public:
      *                   should be double the normal height.
      *                   Double-height lines are formed of two lines containing the same characters,
      *                   with both having the LINE_DOUBLEHEIGHT attribute.
      *                   This allows other parts of the code to work on the
      *                   assumption that all lines are the same height.
      *
      * @param enable true to apply the attribute to the current line or false to remove it
      */
-    void setLineProperty(LineProperty property , bool enable);
+  void setLineProperty (LineProperty property, bool enable);
 
     /** 
      * Returns the number of lines that the image has been scrolled up or down by,
      * since the last call to resetScrolledLines().
      *
      * a positive return value indicates that the image has been scrolled up,
      * a negative return value indicates that the image has been scrolled down. 
      */
-    int scrolledLines() const;
+  int scrolledLines () const;
 
     /**
      * Returns the region of the image which was last scrolled.
      *
      * This is the area of the image from the top margin to the 
      * bottom margin when the last scroll occurred.
      */
-    QRect lastScrolledRegion() const;
+  QRect lastScrolledRegion () const;
 
     /** 
      * Resets the count of the number of lines that the image has been scrolled up or down by,
      * see scrolledLines()
      */
-    void resetScrolledLines();
+  void resetScrolledLines ();
 
     /**
      * Returns the number of lines of output which have been
      * dropped from the history since the last call
      * to resetDroppedLines()
      *
      * If the history is not unlimited then it will drop
      * the oldest lines of output if new lines are added when
      * it is full.  
      */
-    int droppedLines() const;
+  int droppedLines () const;
 
     /**
      * Resets the count of the number of lines dropped from
      * the history.
      */
-    void resetDroppedLines();
+  void resetDroppedLines ();
 
     /** 
       * Fills the buffer @p dest with @p count instances of the default (ie. blank)
       * Character style.
       */
-    static void fillWithDefaultChar(Character* dest, int count);
+  static void fillWithDefaultChar (Character * dest, int count);
 
-private: 
+private:
 
-    //copies a line of text from the screen or history into a stream using a 
-    //specified character decoder.  Returns the number of lines actually copied,
-    //which may be less than 'count' if (start+count) is more than the number of characters on
-    //the line 
-    //
-    //line - the line number to copy, from 0 (the earliest line in the history) up to 
-    //         history->getLines() + lines - 1
-    //start - the first column on the line to copy
-    //count - the number of characters on the line to copy
-    //decoder - a decoder which converts terminal characters (an Character array) into text
-    //appendNewLine - if true a new line character (\n) is appended to the end of the line
-    int  copyLineToStream(int line, 
-                          int start, 
-                          int count, 
-                          TerminalCharacterDecoder* decoder,
-                          bool appendNewLine,
-                          bool preserveLineBreaks) const;
-    
-    //fills a section of the screen image with the character 'c'
-    //the parameters are specified as offsets from the start of the screen image.
-    //the loc(x,y) macro can be used to generate these values from a column,line pair.
-    void clearImage(int loca, int loce, char c);
+  //copies a line of text from the screen or history into a stream using a 
+  //specified character decoder.  Returns the number of lines actually copied,
+  //which may be less than 'count' if (start+count) is more than the number of characters on
+  //the line 
+  //
+  //line - the line number to copy, from 0 (the earliest line in the history) up to 
+  //         history->getLines() + lines - 1
+  //start - the first column on the line to copy
+  //count - the number of characters on the line to copy
+  //decoder - a decoder which converts terminal characters (an Character array) into text
+  //appendNewLine - if true a new line character (\n) is appended to the end of the line
+  int copyLineToStream (int line,
+			int start,
+			int count,
+			TerminalCharacterDecoder * decoder,
+			bool appendNewLine, bool preserveLineBreaks) const;
+
+  //fills a section of the screen image with the character 'c'
+  //the parameters are specified as offsets from the start of the screen image.
+  //the loc(x,y) macro can be used to generate these values from a column,line pair.
+  void clearImage (int loca, int loce, char c);
 
-    //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
-    //the parameters are specified as offsets from the start of the screen image.
-    //the loc(x,y) macro can be used to generate these values from a column,line pair.
-    //
-    //NOTE: moveImage() can only move whole lines
-    void moveImage(int dest, int sourceBegin, int sourceEnd);
-    // scroll up 'i' lines in current region, clearing the bottom 'i' lines 
-    void scrollUp(int from, int i);
-    // scroll down 'i' lines in current region, clearing the top 'i' lines
-    void scrollDown(int from, int i);
+  //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
+  //the parameters are specified as offsets from the start of the screen image.
+  //the loc(x,y) macro can be used to generate these values from a column,line pair.
+  //
+  //NOTE: moveImage() can only move whole lines
+  void moveImage (int dest, int sourceBegin, int sourceEnd);
+  // scroll up 'i' lines in current region, clearing the bottom 'i' lines 
+  void scrollUp (int from, int i);
+  // scroll down 'i' lines in current region, clearing the top 'i' lines
+  void scrollDown (int from, int i);
 
-    void addHistLine();
+  void addHistLine ();
 
-    void initTabStops();
+  void initTabStops ();
 
-    void updateEffectiveRendition();
-    void reverseRendition(Character& p) const;
+  void updateEffectiveRendition ();
+  void reverseRendition (Character & p) const;
 
-    bool isSelectionValid() const;
-    // copies text from 'startIndex' to 'endIndex' to a stream
-    // startIndex and endIndex are positions generated using the loc(x,y) macro
-    void writeToStream(TerminalCharacterDecoder* decoder, int startIndex, 
-                       int endIndex, bool preserveLineBreaks = true) const;
-    // copies 'count' lines from the screen buffer into 'dest',
-    // starting from 'startLine', where 0 is the first line in the screen buffer
-    void copyFromScreen(Character* dest, int startLine, int count) const;
-    // copies 'count' lines from the history buffer into 'dest',
-    // starting from 'startLine', where 0 is the first line in the history
-    void copyFromHistory(Character* dest, int startLine, int count) const;
+  bool isSelectionValid () const;
+  // copies text from 'startIndex' to 'endIndex' to a stream
+  // startIndex and endIndex are positions generated using the loc(x,y) macro
+  void writeToStream (TerminalCharacterDecoder * decoder, int startIndex,
+		      int endIndex, bool preserveLineBreaks = true) const;
+  // copies 'count' lines from the screen buffer into 'dest',
+  // starting from 'startLine', where 0 is the first line in the screen buffer
+  void copyFromScreen (Character * dest, int startLine, int count) const;
+  // copies 'count' lines from the history buffer into 'dest',
+  // starting from 'startLine', where 0 is the first line in the history
+  void copyFromHistory (Character * dest, int startLine, int count) const;
 
 
-    // screen image ----------------
-    int lines;
-    int columns;
+  // screen image ----------------
+  int lines;
+  int columns;
+
+  typedef QVector < Character > ImageLine;	// [0..columns]
+  ImageLine *screenLines;	// [lines]
 
-    typedef QVector<Character> ImageLine;      // [0..columns]
-    ImageLine*          screenLines;    // [lines]
+  int _scrolledLines;
+  QRect _lastScrolledRegion;
+
+  int _droppedLines;
 
-    int _scrolledLines;
-    QRect _lastScrolledRegion;
+    QVarLengthArray < LineProperty, 64 > lineProperties;
 
-    int _droppedLines;
+  // history buffer ---------------
+  HistoryScroll *history;
 
-    QVarLengthArray<LineProperty,64> lineProperties;    
-    
-    // history buffer ---------------
-    HistoryScroll* history;
-    
-    // cursor location
-    int cuX;
-    int cuY;
+  // cursor location
+  int cuX;
+  int cuY;
 
-    // cursor color and rendition info
-    CharacterColor currentForeground;
-    CharacterColor currentBackground;
-    quint8 currentRendition; 
+  // cursor color and rendition info
+  CharacterColor currentForeground;
+  CharacterColor currentBackground;
+  quint8 currentRendition;
 
-    // margins ----------------
-    int _topMargin;
-    int _bottomMargin;
+  // margins ----------------
+  int _topMargin;
+  int _bottomMargin;
 
-    // states ----------------
-    int currentModes[MODES_SCREEN];
-    int savedModes[MODES_SCREEN];
+  // states ----------------
+  int currentModes[MODES_SCREEN];
+  int savedModes[MODES_SCREEN];
 
-    // ----------------------------
+  // ----------------------------
+
+  QBitArray tabStops;
 
-    QBitArray tabStops;
+  // selection -------------------
+  int selBegin;			// The first location selected.
+  int selTopLeft;		// TopLeft Location.
+  int selBottomRight;		// Bottom Right Location.
+  bool blockSelectionMode;	// Column selection mode
 
-    // selection -------------------
-    int selBegin; // The first location selected.
-    int selTopLeft;    // TopLeft Location.
-    int selBottomRight;    // Bottom Right Location.
-    bool blockSelectionMode;  // Column selection mode
+  // effective colors and rendition ------------
+  CharacterColor effectiveForeground;	// These are derived from
+  CharacterColor effectiveBackground;	// the cu_* variables above
+  quint8 effectiveRendition;	// to speed up operation
 
-    // effective colors and rendition ------------
-    CharacterColor effectiveForeground; // These are derived from
-    CharacterColor effectiveBackground; // the cu_* variables above
-    quint8 effectiveRendition;          // to speed up operation
-
-    class SavedState  
+  class SavedState
+  {
+  public:
+    SavedState ():cursorColumn (0), cursorLine (0), rendition (0)
     {
-    public:
-        SavedState()
-        : cursorColumn(0),cursorLine(0),rendition(0) {}
+    }
 
-        int cursorColumn;
-        int cursorLine;
-        quint8 rendition;
-        CharacterColor foreground;
-        CharacterColor background;
-    };
-    SavedState savedState;
-        
-    // last position where we added a character
-    int lastPos;
+    int cursorColumn;
+    int cursorLine;
+    quint8 rendition;
+    CharacterColor foreground;
+    CharacterColor background;
+  };
+  SavedState savedState;
 
-    static Character defaultChar;
+  // last position where we added a character
+  int lastPos;
+
+  static Character defaultChar;
 };
 
 #endif // SCREEN_H
diff --git a/gui/src/terminal/ScreenWindow.cpp b/gui/src/terminal/ScreenWindow.cpp
--- a/gui/src/terminal/ScreenWindow.cpp
+++ b/gui/src/terminal/ScreenWindow.cpp
@@ -23,270 +23,304 @@
 #include "ScreenWindow.h"
 
 // Qt
 #include <QtCore>
 
 // Konsole
 #include "Screen.h"
 
-ScreenWindow::ScreenWindow(QObject* parent)
-    : QObject(parent)
-	, _windowBuffer(0)
-	, _windowBufferSize(0)
-	, _bufferNeedsUpdate(true)
-	, _windowLines(1)
-    , _currentLine(0)
-    , _trackOutput(true)
-    , _scrollCount(0)
+ScreenWindow::ScreenWindow (QObject * parent):QObject (parent), _windowBuffer (0), _windowBufferSize (0),
+_bufferNeedsUpdate (true), _windowLines (1), _currentLine (0),
+_trackOutput (true), _scrollCount (0)
 {
 }
-ScreenWindow::~ScreenWindow()
+
+ScreenWindow::~ScreenWindow ()
 {
-	delete[] _windowBuffer;
-}
-void ScreenWindow::setScreen(Screen* screen)
-{
-    Q_ASSERT( screen );
-
-    _screen = screen;
+  delete[]_windowBuffer;
 }
 
-Screen* ScreenWindow::screen() const
+void
+ScreenWindow::setScreen (Screen * screen)
 {
-    return _screen;
+  Q_ASSERT (screen);
+
+  _screen = screen;
+}
+
+Screen *
+ScreenWindow::screen () const
+{
+  return _screen;
 }
 
-Character* ScreenWindow::getImage()
+Character *
+ScreenWindow::getImage ()
 {
-	// reallocate internal buffer if the window size has changed
-	int size = windowLines() * windowColumns();
-	if (_windowBuffer == 0 || _windowBufferSize != size) 
-	{
-		delete[] _windowBuffer;
-		_windowBufferSize = size;
-		_windowBuffer = new Character[size];
-		_bufferNeedsUpdate = true;
-	}
+  // reallocate internal buffer if the window size has changed
+  int size = windowLines () * windowColumns ();
+  if (_windowBuffer == 0 || _windowBufferSize != size)
+    {
+      delete[]_windowBuffer;
+      _windowBufferSize = size;
+      _windowBuffer = new Character[size];
+      _bufferNeedsUpdate = true;
+    }
 
-	 if (!_bufferNeedsUpdate)
-		return _windowBuffer;
- 
-	_screen->getImage(_windowBuffer,size,
-					  currentLine(),endWindowLine());
+  if (!_bufferNeedsUpdate)
+    return _windowBuffer;
+
+  _screen->getImage (_windowBuffer, size, currentLine (), endWindowLine ());
 
-	// this window may look beyond the end of the screen, in which 
-	// case there will be an unused area which needs to be filled
-	// with blank characters
-	fillUnusedArea();
+  // this window may look beyond the end of the screen, in which 
+  // case there will be an unused area which needs to be filled
+  // with blank characters
+  fillUnusedArea ();
 
-	_bufferNeedsUpdate = false;
-	return _windowBuffer;
+  _bufferNeedsUpdate = false;
+  return _windowBuffer;
 }
 
-void ScreenWindow::fillUnusedArea()
+void
+ScreenWindow::fillUnusedArea ()
 {
-	int screenEndLine = _screen->getHistLines() + _screen->getLines() - 1;
-	int windowEndLine = currentLine() + windowLines() - 1;
+  int screenEndLine = _screen->getHistLines () + _screen->getLines () - 1;
+  int windowEndLine = currentLine () + windowLines () - 1;
 
-	int unusedLines = windowEndLine - screenEndLine;
-	int charsToFill = unusedLines * windowColumns();
+  int unusedLines = windowEndLine - screenEndLine;
+  int charsToFill = unusedLines * windowColumns ();
 
-	Screen::fillWithDefaultChar(_windowBuffer + _windowBufferSize - charsToFill,charsToFill); 
+  Screen::fillWithDefaultChar (_windowBuffer + _windowBufferSize -
+			       charsToFill, charsToFill);
 }
 
 // return the index of the line at the end of this window, or if this window 
 // goes beyond the end of the screen, the index of the line at the end
 // of the screen.
 //
 // when passing a line number to a Screen method, the line number should
 // never be more than endWindowLine()
 //
-int ScreenWindow::endWindowLine() const
-{
-	return qMin(currentLine() + windowLines() - 1,
-				lineCount() - 1);
-}
-QVector<LineProperty> ScreenWindow::getLineProperties()
+int
+ScreenWindow::endWindowLine () const
 {
-    QVector<LineProperty> result = _screen->getLineProperties(currentLine(),endWindowLine());
-	
-	if (result.count() != windowLines())
-		result.resize(windowLines());
-
-	return result;
+  return qMin (currentLine () + windowLines () - 1, lineCount () - 1);
 }
 
-QString ScreenWindow::selectedText( bool preserveLineBreaks ) const
+QVector < LineProperty > ScreenWindow::getLineProperties ()
 {
-    return _screen->selectedText( preserveLineBreaks );
+  QVector < LineProperty > result =
+    _screen->getLineProperties (currentLine (), endWindowLine ());
+
+  if (result.count () != windowLines ())
+    result.resize (windowLines ());
+
+  return result;
+}
+
+QString
+ScreenWindow::selectedText (bool preserveLineBreaks) const
+{
+  return _screen->selectedText (preserveLineBreaks);
+}
+
+void
+ScreenWindow::getSelectionStart (int &column, int &line)
+{
+  _screen->getSelectionStart (column, line);
+  line -= currentLine ();
 }
 
-void ScreenWindow::getSelectionStart( int& column , int& line )
-{
-    _screen->getSelectionStart(column,line);
-    line -= currentLine();
-}
-void ScreenWindow::getSelectionEnd( int& column , int& line )
+void
+ScreenWindow::getSelectionEnd (int &column, int &line)
 {
-    _screen->getSelectionEnd(column,line);
-    line -= currentLine();
-}
-void ScreenWindow::setSelectionStart( int column , int line , bool columnMode )
-{
-    _screen->setSelectionStart( column , qMin(line + currentLine(),endWindowLine())  , columnMode);
-	
-	_bufferNeedsUpdate = true;
-    emit selectionChanged();
+  _screen->getSelectionEnd (column, line);
+  line -= currentLine ();
 }
 
-void ScreenWindow::setSelectionEnd( int column , int line )
+void
+ScreenWindow::setSelectionStart (int column, int line, bool columnMode)
 {
-    _screen->setSelectionEnd( column , qMin(line + currentLine(),endWindowLine()) );
+  _screen->setSelectionStart (column,
+			      qMin (line + currentLine (), endWindowLine ()),
+			      columnMode);
 
-	_bufferNeedsUpdate = true;
-    emit selectionChanged();
+  _bufferNeedsUpdate = true;
+  emit selectionChanged ();
 }
 
-bool ScreenWindow::isSelected( int column , int line )
+void
+ScreenWindow::setSelectionEnd (int column, int line)
 {
-    return _screen->isSelected( column , qMin(line + currentLine(),endWindowLine()) );
+  _screen->setSelectionEnd (column,
+			    qMin (line + currentLine (), endWindowLine ()));
+
+  _bufferNeedsUpdate = true;
+  emit selectionChanged ();
+}
+
+bool
+ScreenWindow::isSelected (int column, int line)
+{
+  return _screen->isSelected (column,
+			      qMin (line + currentLine (), endWindowLine ()));
 }
 
-void ScreenWindow::clearSelection()
+void
+ScreenWindow::clearSelection ()
 {
-    _screen->clearSelection();
+  _screen->clearSelection ();
+
+  emit selectionChanged ();
+}
 
-    emit selectionChanged();
+void
+ScreenWindow::setWindowLines (int lines)
+{
+  Q_ASSERT (lines > 0);
+  _windowLines = lines;
 }
 
-void ScreenWindow::setWindowLines(int lines)
+int
+ScreenWindow::windowLines () const
 {
-	Q_ASSERT(lines > 0);
-	_windowLines = lines;
-}
-int ScreenWindow::windowLines() const
-{
-	return _windowLines;		
+  return _windowLines;
 }
 
-int ScreenWindow::windowColumns() const
+int
+ScreenWindow::windowColumns () const
 {
-    return _screen->getColumns();
+  return _screen->getColumns ();
 }
 
-int ScreenWindow::lineCount() const
+int
+ScreenWindow::lineCount () const
 {
-    return _screen->getHistLines() + _screen->getLines();
+  return _screen->getHistLines () + _screen->getLines ();
 }
 
-int ScreenWindow::columnCount() const
+int
+ScreenWindow::columnCount () const
 {
-    return _screen->getColumns();
+  return _screen->getColumns ();
 }
 
-QPoint ScreenWindow::cursorPosition() const
+QPoint
+ScreenWindow::cursorPosition () const
 {
-    QPoint position;
-    
-    position.setX( _screen->getCursorX() );
-    position.setY( _screen->getCursorY() );
+  QPoint position;
 
-    return position; 
+  position.setX (_screen->getCursorX ());
+  position.setY (_screen->getCursorY ());
+
+  return position;
 }
 
-int ScreenWindow::currentLine() const
+int
+ScreenWindow::currentLine () const
 {
-    return qBound(0,_currentLine,lineCount()-windowLines());
+  return qBound (0, _currentLine, lineCount () - windowLines ());
 }
 
-void ScreenWindow::scrollBy( RelativeScrollMode mode , int amount )
+void
+ScreenWindow::scrollBy (RelativeScrollMode mode, int amount)
 {
-    if ( mode == ScrollLines )
+  if (mode == ScrollLines)
     {
-        scrollTo( currentLine() + amount );
+      scrollTo (currentLine () + amount);
     }
-    else if ( mode == ScrollPages )
+  else if (mode == ScrollPages)
     {
-        scrollTo( currentLine() + amount * ( windowLines() / 2 ) ); 
+      scrollTo (currentLine () + amount * (windowLines () / 2));
     }
 }
 
-bool ScreenWindow::atEndOfOutput() const
+bool
+ScreenWindow::atEndOfOutput () const
 {
-    return currentLine() == (lineCount()-windowLines());
+  return currentLine () == (lineCount () - windowLines ());
 }
 
-void ScreenWindow::scrollTo( int line )
+void
+ScreenWindow::scrollTo (int line)
 {
-	int maxCurrentLineNumber = lineCount() - windowLines();
-	line = qBound(0,line,maxCurrentLineNumber);
-
-    const int delta = line - _currentLine;
-    _currentLine = line;
+  int maxCurrentLineNumber = lineCount () - windowLines ();
+  line = qBound (0, line, maxCurrentLineNumber);
 
-    // keep track of number of lines scrolled by,
-    // this can be reset by calling resetScrollCount()
-    _scrollCount += delta;
+  const int delta = line - _currentLine;
+  _currentLine = line;
 
-    _bufferNeedsUpdate = true;
+  // keep track of number of lines scrolled by,
+  // this can be reset by calling resetScrollCount()
+  _scrollCount += delta;
 
-    emit scrolled(_currentLine);
+  _bufferNeedsUpdate = true;
+
+  emit scrolled (_currentLine);
 }
 
-void ScreenWindow::setTrackOutput(bool trackOutput)
+void
+ScreenWindow::setTrackOutput (bool trackOutput)
 {
-    _trackOutput = trackOutput;
+  _trackOutput = trackOutput;
 }
 
-bool ScreenWindow::trackOutput() const
+bool
+ScreenWindow::trackOutput () const
 {
-    return _trackOutput;
+  return _trackOutput;
 }
 
-int ScreenWindow::scrollCount() const
+int
+ScreenWindow::scrollCount () const
 {
-    return _scrollCount;
+  return _scrollCount;
 }
 
-void ScreenWindow::resetScrollCount() 
+void
+ScreenWindow::resetScrollCount ()
 {
-    _scrollCount = 0;
+  _scrollCount = 0;
 }
 
-QRect ScreenWindow::scrollRegion() const
+QRect
+ScreenWindow::scrollRegion () const
 {
-	bool equalToScreenSize = windowLines() == _screen->getLines();
+  bool equalToScreenSize = windowLines () == _screen->getLines ();
 
-	if ( atEndOfOutput() && equalToScreenSize )
-    	return _screen->lastScrolledRegion();
-	else
-		return QRect(0,0,windowColumns(),windowLines());
+  if (atEndOfOutput () && equalToScreenSize)
+    return _screen->lastScrolledRegion ();
+  else
+    return QRect (0, 0, windowColumns (), windowLines ());
 }
 
-void ScreenWindow::notifyOutputChanged()
+void
+ScreenWindow::notifyOutputChanged ()
 {
-    // move window to the bottom of the screen and update scroll count
-    // if this window is currently tracking the bottom of the screen
-    if ( _trackOutput )
-    { 
-        _scrollCount -= _screen->scrolledLines();
-        _currentLine = qMax(0,_screen->getHistLines() - (windowLines()-_screen->getLines()));
-    }
-    else
+  // move window to the bottom of the screen and update scroll count
+  // if this window is currently tracking the bottom of the screen
+  if (_trackOutput)
     {
-        // if the history is not unlimited then it may 
-        // have run out of space and dropped the oldest
-        // lines of output - in this case the screen
-        // window's current line number will need to 
-        // be adjusted - otherwise the output will scroll
-        _currentLine = qMax(0,_currentLine - 
-                              _screen->droppedLines());
+      _scrollCount -= _screen->scrolledLines ();
+      _currentLine =
+	qMax (0,
+	      _screen->getHistLines () - (windowLines () -
+					  _screen->getLines ()));
+    }
+  else
+    {
+      // if the history is not unlimited then it may 
+      // have run out of space and dropped the oldest
+      // lines of output - in this case the screen
+      // window's current line number will need to 
+      // be adjusted - otherwise the output will scroll
+      _currentLine = qMax (0, _currentLine - _screen->droppedLines ());
 
-        // ensure that the screen window's current position does
-        // not go beyond the bottom of the screen
-        _currentLine = qMin( _currentLine , _screen->getHistLines() );
+      // ensure that the screen window's current position does
+      // not go beyond the bottom of the screen
+      _currentLine = qMin (_currentLine, _screen->getHistLines ());
     }
 
-	_bufferNeedsUpdate = true;
+  _bufferNeedsUpdate = true;
 
-    emit outputChanged(); 
+  emit outputChanged ();
 }
diff --git a/gui/src/terminal/ScreenWindow.h b/gui/src/terminal/ScreenWindow.h
--- a/gui/src/terminal/ScreenWindow.h
+++ b/gui/src/terminal/ScreenWindow.h
@@ -43,209 +43,207 @@ class Screen;
  *
  * setTrackOutput() controls whether the window moves to the bottom of the associated screen when new
  * lines are added to it.
  *
  * Whenever the output from the underlying screen is changed, the notifyOutputChanged() slot should
  * be called.  This in turn will update the window's position and emit the outputChanged() signal
  * if necessary.
  */
-class ScreenWindow : public QObject
+class ScreenWindow:public QObject
 {
-Q_OBJECT
-
-public:
+Q_OBJECT public:
     /** 
      * Constructs a new screen window with the given parent.
      * A screen must be specified by calling setScreen() before calling getImage() or getLineProperties().
      *
      * You should not call this constructor directly, instead use the Emulation::createWindow() method
      * to create a window on the emulation which you wish to view.  This allows the emulation
      * to notify the window when the associated screen has changed and synchronize selection updates
      * between all views on a session.
      */
-    ScreenWindow(QObject* parent = 0);
-	virtual ~ScreenWindow();
+  ScreenWindow (QObject * parent = 0);
+  virtual ~ ScreenWindow ();
 
     /** Sets the screen which this window looks onto */
-    void setScreen(Screen* screen);
+  void setScreen (Screen * screen);
     /** Returns the screen which this window looks onto */
-    Screen* screen() const;
+  Screen *screen () const;
 
     /** 
      * Returns the image of characters which are currently visible through this window
      * onto the screen.
      *
      * The buffer is managed by the ScreenWindow instance and does not need to be
      * deleted by the caller.
      */
-    Character* getImage();
+  Character *getImage ();
 
     /**
      * Returns the line attributes associated with the lines of characters which
      * are currently visible through this window
      */
-    QVector<LineProperty> getLineProperties();
+    QVector < LineProperty > getLineProperties ();
 
     /**
      * Returns the number of lines which the region of the window
      * specified by scrollRegion() has been scrolled by since the last call 
      * to resetScrollCount().  scrollRegion() is in most cases the 
      * whole window, but will be a smaller area in, for example, applications
      * which provide split-screen facilities.
      *
      * This is not guaranteed to be accurate, but allows views to optimise
      * rendering by reducing the amount of costly text rendering that
      * needs to be done when the output is scrolled. 
      */
-    int scrollCount() const;
+  int scrollCount () const;
 
     /**
      * Resets the count of scrolled lines returned by scrollCount()
      */
-    void resetScrollCount();
+  void resetScrollCount ();
 
     /**
      * Returns the area of the window which was last scrolled, this is 
      * usually the whole window area.
      *
      * Like scrollCount(), this is not guaranteed to be accurate,
      * but allows views to optimise rendering.
      */
-    QRect scrollRegion() const;
+  QRect scrollRegion () const;
 
     /** 
      * Sets the start of the selection to the given @p line and @p column within 
      * the window.
      */
-    void setSelectionStart( int column , int line , bool columnMode );
+  void setSelectionStart (int column, int line, bool columnMode);
     /**
      * Sets the end of the selection to the given @p line and @p column within
      * the window.
      */
-    void setSelectionEnd( int column , int line ); 
+  void setSelectionEnd (int column, int line);
     /**
      * Retrieves the start of the selection within the window.
      */
-    void getSelectionStart( int& column , int& line );
+  void getSelectionStart (int &column, int &line);
     /**
      * Retrieves the end of the selection within the window.
      */
-    void getSelectionEnd( int& column , int& line );
+  void getSelectionEnd (int &column, int &line);
     /**
      * Returns true if the character at @p line , @p column is part of the selection.
      */
-    bool isSelected( int column , int line );
+  bool isSelected (int column, int line);
     /** 
      * Clears the current selection
      */
-    void clearSelection();
+  void clearSelection ();
 
 	/** Sets the number of lines in the window */
-	void setWindowLines(int lines);
+  void setWindowLines (int lines);
     /** Returns the number of lines in the window */
-    int windowLines() const;
+  int windowLines () const;
     /** Returns the number of columns in the window */
-    int windowColumns() const;
-    
+  int windowColumns () const;
+
     /** Returns the total number of lines in the screen */
-    int lineCount() const;
+  int lineCount () const;
     /** Returns the total number of columns in the screen */
-    int columnCount() const;
+  int columnCount () const;
 
     /** Returns the index of the line which is currently at the top of this window */
-    int currentLine() const;
+  int currentLine () const;
 
     /** 
      * Returns the position of the cursor 
      * within the window.
      */
-    QPoint cursorPosition() const;
+  QPoint cursorPosition () const;
 
     /** 
      * Convenience method. Returns true if the window is currently at the bottom
      * of the screen.
      */
-    bool atEndOfOutput() const;
+  bool atEndOfOutput () const;
 
     /** Scrolls the window so that @p line is at the top of the window */
-    void scrollTo( int line );
+  void scrollTo (int line);
 
-    enum RelativeScrollMode
-    {
-        ScrollLines,
-        ScrollPages
-    };
+  enum RelativeScrollMode
+  {
+    ScrollLines,
+    ScrollPages
+  };
 
     /** 
      * Scrolls the window relative to its current position on the screen.
      *
      * @param mode Specifies whether @p amount refers to the number of lines or the number
      * of pages to scroll.    
      * @param amount The number of lines or pages ( depending on @p mode ) to scroll by.  If
      * this number is positive, the view is scrolled down.  If this number is negative, the view
      * is scrolled up.
      */
-    void scrollBy( RelativeScrollMode mode , int amount );
+  void scrollBy (RelativeScrollMode mode, int amount);
 
     /** 
      * Specifies whether the window should automatically move to the bottom
      * of the screen when new output is added.
      *
      * If this is set to true, the window will be moved to the bottom of the associated screen ( see 
      * screen() ) when the notifyOutputChanged() method is called.
      */
-    void setTrackOutput(bool trackOutput);
+  void setTrackOutput (bool trackOutput);
     /** 
      * Returns whether the window automatically moves to the bottom of the screen as
      * new output is added.  See setTrackOutput()
      */
-    bool trackOutput() const;
+  bool trackOutput () const;
 
     /**
      * Returns the text which is currently selected.
      *
      * @param preserveLineBreaks See Screen::selectedText()
      */
-    QString selectedText( bool preserveLineBreaks ) const;
+  QString selectedText (bool preserveLineBreaks) const;
 
-public slots:
+  public slots:
     /** 
      * Notifies the window that the contents of the associated terminal screen have changed.
      * This moves the window to the bottom of the screen if trackOutput() is true and causes
      * the outputChanged() signal to be emitted.
      */
-    void notifyOutputChanged();
+  void notifyOutputChanged ();
 
-signals:
+    signals:
     /**
      * Emitted when the contents of the associated terminal screen ( see screen() ) changes. 
      */
-    void outputChanged();
+  void outputChanged ();
 
     /**
      * Emitted when the screen window is scrolled to a different position.
      * 
      * @param line The line which is now at the top of the window.
      */
-    void scrolled(int line);
+  void scrolled (int line);
 
     /**
      * Emitted when the selection is changed.
      */
-    void selectionChanged();
+  void selectionChanged ();
 
 private:
-	int endWindowLine() const;
-	void fillUnusedArea();
+  int endWindowLine () const;
+  void fillUnusedArea ();
 
-    Screen* _screen; // see setScreen() , screen()
-	Character* _windowBuffer;
-	int _windowBufferSize;
-	bool _bufferNeedsUpdate;
+  Screen *_screen;		// see setScreen() , screen()
+  Character *_windowBuffer;
+  int _windowBufferSize;
+  bool _bufferNeedsUpdate;
 
-	int  _windowLines;
-    int  _currentLine; // see scrollTo() , currentLine()
-    bool _trackOutput; // see setTrackOutput() , trackOutput() 
-    int  _scrollCount; // count of lines which the window has been scrolled by since
-                       // the last call to resetScrollCount()
+  int _windowLines;
+  int _currentLine;		// see scrollTo() , currentLine()
+  bool _trackOutput;		// see setTrackOutput() , trackOutput() 
+  int _scrollCount;		// count of lines which the window has been scrolled by since
+  // the last call to resetScrollCount()
 };
 #endif // SCREENWINDOW_H
diff --git a/gui/src/terminal/Session.cpp b/gui/src/terminal/Session.cpp
--- a/gui/src/terminal/Session.cpp
+++ b/gui/src/terminal/Session.cpp
@@ -42,1166 +42,1334 @@
 #include "kptydevice.h"
 
 #include "ProcessInfo.h"
 #include "Pty.h"
 #include "TerminalDisplay.h"
 #include "ShellCommand.h"
 #include "Vt102Emulation.h"
 
-int Session::lastSessionId = 0;
+int
+  Session::lastSessionId = 0;
 
 // HACK This is copied out of QUuid::createUuid with reseeding forced.
 // Required because color schemes repeatedly seed the RNG...
 // ...with a constant.
-QUuid createUuid()
+QUuid
+createUuid ()
 {
-    static const int intbits = sizeof(int)*8;
-    static int randbits = 0;
-    if (!randbits)
+  static const int
+    intbits = sizeof (int) * 8;
+  static int
+    randbits = 0;
+  if (!randbits)
     {
-        int max = RAND_MAX;
-        do { ++randbits; } while ((max=max>>1));
+      int
+	max = RAND_MAX;
+      do
+	{
+	  ++randbits;
+	}
+      while ((max = max >> 1));
     }
 
-    qsrand(uint(QDateTime::currentDateTime().toTime_t()));
-    qrand(); // Skip first
+  qsrand (uint (QDateTime::currentDateTime ().toTime_t ()));
+  qrand ();			// Skip first
 
-    QUuid result;
-    uint *data = &(result.data1);
-    int chunks = 16 / sizeof(uint);
-    while (chunks--) {
-        uint randNumber = 0;
-        for (int filled = 0; filled < intbits; filled += randbits)
-            randNumber |= qrand()<<filled;
-         *(data+chunks) = randNumber;
+  QUuid
+    result;
+  uint *
+    data = &(result.data1);
+  int
+    chunks = 16 / sizeof (uint);
+  while (chunks--)
+    {
+      uint
+	randNumber = 0;
+      for (int filled = 0; filled < intbits; filled += randbits)
+	randNumber |= qrand () << filled;
+      *(data + chunks) = randNumber;
     }
 
-    result.data4[0] = (result.data4[0] & 0x3F) | 0x80;        // UV_DCE
-    result.data3 = (result.data3 & 0x0FFF) | 0x4000;        // UV_Random
+  result.data4[0] = (result.data4[0] & 0x3F) | 0x80;	// UV_DCE
+  result.data3 = (result.data3 & 0x0FFF) | 0x4000;	// UV_Random
 
-    return result;
+  return result;
 }
 
-Session::Session(QObject* parent) :
-   QObject(parent)
-   , _shellProcess(0)
-   , _emulation(0)
-   , _monitorActivity(false)
-   , _monitorSilence(false)
-   , _notifiedActivity(false)
-   , _autoClose(true)
-   , _wantedClose(false)
-   , _silenceSeconds(10)
-   , _addToUtmp(true)  
-   , _flowControl(true)
-   , _fullScripting(false)
-   , _sessionId(0)
-   , _sessionProcessInfo(0)
-   , _foregroundProcessInfo(0)
-   , _foregroundPid(0)
-   //, _zmodemBusy(false)
-   //, _zmodemProc(0)
-   //, _zmodemProgress(0)
-   , _hasDarkBackground(false)
+Session::Session (QObject * parent):
+QObject (parent), _shellProcess (0), _emulation (0), _monitorActivity (false),
+_monitorSilence (false), _notifiedActivity (false), _autoClose (true),
+_wantedClose (false), _silenceSeconds (10), _addToUtmp (true),
+_flowControl (true), _fullScripting (false), _sessionId (0),
+_sessionProcessInfo (0), _foregroundProcessInfo (0), _foregroundPid (0)
+  //, _zmodemBusy(false)
+  //, _zmodemProc(0)
+  //, _zmodemProgress(0)
+  , _hasDarkBackground (false)
 {
-    _uniqueIdentifier = createUuid();
+  _uniqueIdentifier = createUuid ();
+
+  //prepare DBus communication
+  //new SessionAdaptor(this);
+  _sessionId = ++lastSessionId;
+
+  // JPS: commented out for lack of DBUS support by default on OSX
+  //QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
 
-    //prepare DBus communication
-    //new SessionAdaptor(this);
-    _sessionId = ++lastSessionId;
-    
-    // JPS: commented out for lack of DBUS support by default on OSX
-    //QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
-
-    //create emulation backend
-    _emulation = new Vt102Emulation();
+  //create emulation backend
+  _emulation = new Vt102Emulation ();
 
-    connect( _emulation, SIGNAL( titleChanged( int, const QString & ) ),
-           this, SLOT( setUserTitle( int, const QString & ) ) );
-    connect( _emulation, SIGNAL( stateSet(int) ),
-           this, SLOT( activityStateSet(int) ) );
-    connect( _emulation, SIGNAL( changeTabTextColorRequest( int ) ),
-           this, SIGNAL( changeTabTextColorRequest( int ) ) );
-    connect( _emulation, SIGNAL(profileChangeCommandReceived(const QString&)),
-           this, SIGNAL( profileChangeCommandReceived(const QString&)) );
-    connect( _emulation, SIGNAL(flowControlKeyPressed(bool)) , this, 
-             SLOT(updateFlowControlState(bool)) );
+  connect (_emulation, SIGNAL (titleChanged (int, const QString &)),
+	   this, SLOT (setUserTitle (int, const QString &)));
+  connect (_emulation, SIGNAL (stateSet (int)),
+	   this, SLOT (activityStateSet (int)));
+  connect (_emulation, SIGNAL (changeTabTextColorRequest (int)),
+	   this, SIGNAL (changeTabTextColorRequest (int)));
+  connect (_emulation,
+	   SIGNAL (profileChangeCommandReceived (const QString &)), this,
+	   SIGNAL (profileChangeCommandReceived (const QString &)));
+  connect (_emulation, SIGNAL (flowControlKeyPressed (bool)), this,
+	   SLOT (updateFlowControlState (bool)));
 
-    //create new teletype for I/O with shell process
-    openTeletype(-1);
+  //create new teletype for I/O with shell process
+  openTeletype (-1);
 
-    //setup timer for monitoring session activity
-    _monitorTimer = new QTimer(this);
-    _monitorTimer->setSingleShot(true);
-    connect(_monitorTimer, SIGNAL(timeout()), this, SLOT(monitorTimerDone()));
+  //setup timer for monitoring session activity
+  _monitorTimer = new QTimer (this);
+  _monitorTimer->setSingleShot (true);
+  connect (_monitorTimer, SIGNAL (timeout ()), this,
+	   SLOT (monitorTimerDone ()));
 }
 
-void Session::openTeletype(int fd)
+void
+Session::openTeletype (int fd)
 {
-    if (_shellProcess && isRunning())
+  if (_shellProcess && isRunning ())
     {
-        //kWarning() << "Attempted to open teletype in a running session.";
-        return;
+      //kWarning() << "Attempted to open teletype in a running session.";
+      return;
     }
 
-    delete _shellProcess;
+  delete _shellProcess;
 
-    if (fd < 0)
-        _shellProcess = new Pty();
-    else
-        _shellProcess = new Pty(fd);
+  if (fd < 0)
+    _shellProcess = new Pty ();
+  else
+    _shellProcess = new Pty (fd);
 
-    _shellProcess->setUtf8Mode(_emulation->utf8());
+  _shellProcess->setUtf8Mode (_emulation->utf8 ());
 
-    //connect teletype to emulation backend
-    connect( _shellProcess,SIGNAL(receivedData(const char*,int)),this,
-            SLOT(onReceiveBlock(const char*,int)) );
-    connect( _emulation,SIGNAL(sendData(const char*,int)),_shellProcess,
-            SLOT(sendData(const char*,int)) );
-    connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
-    connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
-    connect( _shellProcess,SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(done(int)) );
-    connect( _emulation,SIGNAL(imageSizeChanged(int,int)),this,SLOT(updateWindowSize(int,int)) );
+  //connect teletype to emulation backend
+  connect (_shellProcess, SIGNAL (receivedData (const char *, int)), this,
+	   SLOT (onReceiveBlock (const char *, int)));
+  connect (_emulation, SIGNAL (sendData (const char *, int)), _shellProcess,
+	   SLOT (sendData (const char *, int)));
+  connect (_emulation, SIGNAL (lockPtyRequest (bool)), _shellProcess,
+	   SLOT (lockPty (bool)));
+  connect (_emulation, SIGNAL (useUtf8Request (bool)), _shellProcess,
+	   SLOT (setUtf8Mode (bool)));
+  connect (_shellProcess, SIGNAL (finished (int, QProcess::ExitStatus)), this,
+	   SLOT (done (int)));
+  connect (_emulation, SIGNAL (imageSizeChanged (int, int)), this,
+	   SLOT (updateWindowSize (int, int)));
 }
 
-WId Session::windowId() const
+WId
+Session::windowId () const
 {
-    // Returns a window ID for this session which is used
-    // to set the WINDOWID environment variable in the shell
-    // process.
-    //
-    // Sessions can have multiple views or no views, which means
-    // that a single ID is not always going to be accurate.
-    //
-    // If there are no views, the window ID is just 0.  If
-    // there are multiple views, then the window ID for the
-    // top-level window which contains the first view is
-    // returned
+  // Returns a window ID for this session which is used
+  // to set the WINDOWID environment variable in the shell
+  // process.
+  //
+  // Sessions can have multiple views or no views, which means
+  // that a single ID is not always going to be accurate.
+  //
+  // If there are no views, the window ID is just 0.  If
+  // there are multiple views, then the window ID for the
+  // top-level window which contains the first view is
+  // returned
 
-    if ( _views.count() == 0 )
-       return 0;
-    else
+  if (_views.count () == 0)
+    return 0;
+  else
     {
-        QWidget* window = _views.first();
+      QWidget *window = _views.first ();
 
-        Q_ASSERT( window );
+      Q_ASSERT (window);
 
-        while ( window->parentWidget() != 0 )
-            window = window->parentWidget();
+      while (window->parentWidget () != 0)
+	window = window->parentWidget ();
 
-        return window->winId();
+      return window->winId ();
     }
 }
 
-void Session::setDarkBackground(bool darkBackground)
-{
-    _hasDarkBackground = darkBackground;
-}
-bool Session::hasDarkBackground() const
+void
+Session::setDarkBackground (bool darkBackground)
 {
-    return _hasDarkBackground;
-}
-bool Session::isRunning() const
-{
-    return _shellProcess->state() == QProcess::Running;
+  _hasDarkBackground = darkBackground;
 }
 
-void Session::setCodec(QTextCodec* codec)
+bool
+Session::hasDarkBackground () const
 {
-    emulation()->setCodec(codec);
+  return _hasDarkBackground;
 }
 
-bool Session::setCodec(QByteArray name)
+bool
+Session::isRunning () const
 {
-    QTextCodec *codec = QTextCodec::codecForName(name);
-    if (codec) {
-        setCodec(codec);
-        return true;
-    }
-    return false;
+  return _shellProcess->state () == QProcess::Running;
+}
+
+void
+Session::setCodec (QTextCodec * codec)
+{
+  emulation ()->setCodec (codec);
 }
 
-QByteArray Session::codec()
+bool
+Session::setCodec (QByteArray name)
 {
-    return _emulation->codec()->name();
+  QTextCodec *codec = QTextCodec::codecForName (name);
+  if (codec)
+    {
+      setCodec (codec);
+      return true;
+    }
+  return false;
 }
 
-void Session::setProgram(const QString& program)
+QByteArray
+Session::codec ()
 {
-    _program = ShellCommand::expand(program);
+  return _emulation->codec ()->name ();
 }
-void Session::setInitialWorkingDirectory(const QString& dir)
+
+void
+Session::setProgram (const QString & program)
+{
+  _program = ShellCommand::expand (program);
+}
+
+void
+Session::setInitialWorkingDirectory (const QString & dir)
 {
   //_initialWorkingDir = KShell::tildeExpand(ShellCommand::expand(dir));
-  _initialWorkingDir = ShellCommand::expand(dir);
-}
-void Session::setArguments(const QStringList& arguments)
-{
-    _arguments = ShellCommand::expand(arguments);
+  _initialWorkingDir = ShellCommand::expand (dir);
 }
 
-QString Session::currentWorkingDirectory()
+void
+Session::setArguments (const QStringList & arguments)
 {
-    // only returned cached value
-    if (_currentWorkingDir.isEmpty()) updateWorkingDirectory();
-    return _currentWorkingDir;
-}
-ProcessInfo* Session::updateWorkingDirectory()
-{
-    ProcessInfo *process = getProcessInfo();
-    _currentWorkingDir = process->validCurrentDir();
-    return process;
+  _arguments = ShellCommand::expand (arguments);
 }
 
-QList<TerminalDisplay*> Session::views() const
+QString
+Session::currentWorkingDirectory ()
 {
-    return _views;
+  // only returned cached value
+  if (_currentWorkingDir.isEmpty ())
+    updateWorkingDirectory ();
+  return _currentWorkingDir;
 }
 
-void Session::addView(TerminalDisplay* widget)
+ProcessInfo *
+Session::updateWorkingDirectory ()
 {
-     Q_ASSERT( !_views.contains(widget) );
-
-    _views.append(widget);
-
-    if ( _emulation != 0 )
-    {
-        // connect emulation - view signals and slots
-        connect( widget , SIGNAL(keyPressedSignal(QKeyEvent*)) , _emulation ,
-               SLOT(sendKeyEvent(QKeyEvent*)) );
-        connect( widget , SIGNAL(mouseSignal(int,int,int,int)) , _emulation ,
-               SLOT(sendMouseEvent(int,int,int,int)) );
-        connect( widget , SIGNAL(sendStringToEmu(const char*)) , _emulation ,
-               SLOT(sendString(const char*)) );
+  ProcessInfo *process = getProcessInfo ();
+  _currentWorkingDir = process->validCurrentDir ();
+  return process;
+}
 
-        // allow emulation to notify view when the foreground process
-        // indicates whether or not it is interested in mouse signals
-        connect( _emulation , SIGNAL(programUsesMouseChanged(bool)) , widget ,
-               SLOT(setUsesMouse(bool)) );
-
-        widget->setUsesMouse( _emulation->programUsesMouse() );
-
-        widget->setScreenWindow(_emulation->createWindow());
-    }
-
-    //connect view signals and slots
-    QObject::connect( widget ,SIGNAL(changedContentSizeSignal(int,int)),this,
-                    SLOT(onViewSizeChange(int,int)));
-
-    QObject::connect( widget ,SIGNAL(destroyed(QObject*)) , this ,
-                    SLOT(viewDestroyed(QObject*)) );
+QList < TerminalDisplay * >Session::views () const
+{
+  return _views;
 }
 
-void Session::viewDestroyed(QObject* view)
+void
+Session::addView (TerminalDisplay * widget)
 {
-    TerminalDisplay* display = (TerminalDisplay*)view;
+  Q_ASSERT (!_views.contains (widget));
+
+  _views.append (widget);
+
+  if (_emulation != 0)
+    {
+      // connect emulation - view signals and slots
+      connect (widget, SIGNAL (keyPressedSignal (QKeyEvent *)), _emulation,
+	       SLOT (sendKeyEvent (QKeyEvent *)));
+      connect (widget, SIGNAL (mouseSignal (int, int, int, int)), _emulation,
+	       SLOT (sendMouseEvent (int, int, int, int)));
+      connect (widget, SIGNAL (sendStringToEmu (const char *)), _emulation,
+	       SLOT (sendString (const char *)));
 
-    Q_ASSERT( _views.contains(display) );
+      // allow emulation to notify view when the foreground process
+      // indicates whether or not it is interested in mouse signals
+      connect (_emulation, SIGNAL (programUsesMouseChanged (bool)), widget,
+	       SLOT (setUsesMouse (bool)));
+
+      widget->setUsesMouse (_emulation->programUsesMouse ());
 
-    removeView(display);
+      widget->setScreenWindow (_emulation->createWindow ());
+    }
+
+  //connect view signals and slots
+  QObject::connect (widget, SIGNAL (changedContentSizeSignal (int, int)),
+		    this, SLOT (onViewSizeChange (int, int)));
+
+  QObject::connect (widget, SIGNAL (destroyed (QObject *)), this,
+		    SLOT (viewDestroyed (QObject *)));
 }
 
-void Session::removeView(TerminalDisplay* widget)
+void
+Session::viewDestroyed (QObject * view)
 {
-    _views.removeAll(widget);
+  TerminalDisplay *display = (TerminalDisplay *) view;
+
+  Q_ASSERT (_views.contains (display));
 
-    disconnect(widget,0,this,0);
+  removeView (display);
+}
 
-    if ( _emulation != 0 )
+void
+Session::removeView (TerminalDisplay * widget)
+{
+  _views.removeAll (widget);
+
+  disconnect (widget, 0, this, 0);
+
+  if (_emulation != 0)
     {
-        // disconnect
-        //  - key presses signals from widget
-        //  - mouse activity signals from widget
-        //  - string sending signals from widget
-        //
-        //  ... and any other signals connected in addView()
-        disconnect( widget, 0, _emulation, 0);
+      // disconnect
+      //  - key presses signals from widget
+      //  - mouse activity signals from widget
+      //  - string sending signals from widget
+      //
+      //  ... and any other signals connected in addView()
+      disconnect (widget, 0, _emulation, 0);
 
-        // disconnect state change signals emitted by emulation
-        disconnect( _emulation , 0 , widget , 0);
+      // disconnect state change signals emitted by emulation
+      disconnect (_emulation, 0, widget, 0);
     }
 
-    // close the session automatically when the last view is removed
-    if ( _views.count() == 0 )
+  // close the session automatically when the last view is removed
+  if (_views.count () == 0)
     {
-        close();
+      close ();
     }
 }
 
-QString Session::checkProgram(const QString& program) const
+QString
+Session::checkProgram (const QString & program) const
 {
   // Upon a KPty error, there is no description on what that error was...
   // Check to see if the given program is executable.
-  QString exec = QFile::encodeName(program);
+  QString exec = QFile::encodeName (program);
 
-  if (exec.isEmpty())
-      return QString();
+  if (exec.isEmpty ())
+    return QString ();
 
   // if 'exec' is not specified, fall back to default shell.  if that 
   // is not set then fall back to /bin/sh
-  if ( exec.isEmpty() )
-      exec = qgetenv("SHELL");
-  if ( exec.isEmpty() )
-        exec = "/bin/sh";
+  if (exec.isEmpty ())
+    exec = qgetenv ("SHELL");
+  if (exec.isEmpty ())
+    exec = "/bin/sh";
   return program;
 }
 
-void Session::terminalWarning(const QString& message)
+void
+Session::terminalWarning (const QString & message)
 {
-  static const QByteArray warningText = QByteArray("@info:shell Alert the user with red color text");
-    QByteArray messageText = message.toLocal8Bit();
+  static const QByteArray warningText =
+    QByteArray ("@info:shell Alert the user with red color text");
+  QByteArray messageText = message.toLocal8Bit ();
 
-    static const char redPenOn[] = "\033[1m\033[31m";
-    static const char redPenOff[] = "\033[0m";
+  static const char redPenOn[] = "\033[1m\033[31m";
+  static const char redPenOff[] = "\033[0m";
 
-    _emulation->receiveData(redPenOn,strlen(redPenOn));
-    _emulation->receiveData("\n\r\n\r",4);
-    _emulation->receiveData(warningText.constData(),strlen(warningText.constData()));
-    _emulation->receiveData(messageText.constData(),strlen(messageText.constData()));
-    _emulation->receiveData("\n\r\n\r",4);
-    _emulation->receiveData(redPenOff,strlen(redPenOff));
+  _emulation->receiveData (redPenOn, strlen (redPenOn));
+  _emulation->receiveData ("\n\r\n\r", 4);
+  _emulation->receiveData (warningText.constData (),
+			   strlen (warningText.constData ()));
+  _emulation->receiveData (messageText.constData (),
+			   strlen (messageText.constData ()));
+  _emulation->receiveData ("\n\r\n\r", 4);
+  _emulation->receiveData (redPenOff, strlen (redPenOff));
 }
 
-QString Session::shellSessionId() const
+QString
+Session::shellSessionId () const
 {
-    QString friendlyUuid(_uniqueIdentifier.toString());
-    friendlyUuid.remove('-').remove('{').remove('}');
+  QString friendlyUuid (_uniqueIdentifier.toString ());
+  friendlyUuid.remove ('-').remove ('{').remove ('}');
 
-    return friendlyUuid;
+  return friendlyUuid;
 }
 
-void Session::run()
+void
+Session::run ()
 {
   //check that everything is in place to run the session
-  if (_program.isEmpty())
-  {
+  if (_program.isEmpty ())
+    {
       //kWarning() << "Session::run() - program to run not set.";
-  }
-  if (_arguments.isEmpty())
-  {
+    }
+  if (_arguments.isEmpty ())
+    {
       //kWarning() << "Session::run() - no command line arguments specified.";
-  }
-  if (_uniqueIdentifier.isNull())
-  {
-      _uniqueIdentifier = createUuid();
-  }
+    }
+  if (_uniqueIdentifier.isNull ())
+    {
+      _uniqueIdentifier = createUuid ();
+    }
 
   const int CHOICE_COUNT = 3;
-  QString programs[CHOICE_COUNT] = {_program,qgetenv("SHELL"),"/bin/sh"};
+  QString programs[CHOICE_COUNT] = { _program, qgetenv ("SHELL"), "/bin/sh" };
   QString exec;
   int choice = 0;
   while (choice < CHOICE_COUNT)
-  {
-    exec = checkProgram(programs[choice]);
-    if (exec.isEmpty())
-        choice++;
-    else
-        break;
-  }
+    {
+      exec = checkProgram (programs[choice]);
+      if (exec.isEmpty ())
+	choice++;
+      else
+	break;
+    }
 
   // if a program was specified via setProgram(), but it couldn't be found, print a warning
-  if (choice != 0 && choice < CHOICE_COUNT && !_program.isEmpty())
-  {
-    QString msg;
-    QTextStream msgStream(&msg);
-    msgStream << "Could not find '" << _program << "', starting '" << exec << "' instead. Please check your profile settings.";
-    terminalWarning(msg);
-    //terminalWarning(i18n("Could not find '%1', starting '%2' instead.  Please check your profile settings.",_program.toLatin1().data(),exec.toLatin1().data())); 
-  }
+  if (choice != 0 && choice < CHOICE_COUNT && !_program.isEmpty ())
+    {
+      QString msg;
+      QTextStream msgStream (&msg);
+      msgStream << "Could not find '" << _program << "', starting '" << exec
+	<< "' instead. Please check your profile settings.";
+      terminalWarning (msg);
+      //terminalWarning(i18n("Could not find '%1', starting '%2' instead.  Please check your profile settings.",_program.toLatin1().data(),exec.toLatin1().data())); 
+    }
   // if none of the choices are available, print a warning
   else if (choice == CHOICE_COUNT)
-  {
-      terminalWarning(QString("Could not find an interactive shell to start."));
+    {
+      terminalWarning (QString
+		       ("Could not find an interactive shell to start."));
       return;
-  }
-  
+    }
+
   // if no arguments are specified, fall back to program name
-  QStringList arguments = _arguments.join(QChar(' ')).isEmpty() ?
-                                                   QStringList() << exec : _arguments;
+  QStringList arguments = _arguments.join (QChar (' ')).isEmpty ()?
+    QStringList () << exec : _arguments;
 
   // JPS: commented out for lack of DBUS support by default on OSX
-  QString dbusService = ""; //QDBusConnection::sessionBus().baseService();
-  if (!_initialWorkingDir.isEmpty())
-    _shellProcess->setWorkingDirectory(_initialWorkingDir);
+  QString dbusService = "";	//QDBusConnection::sessionBus().baseService();
+  if (!_initialWorkingDir.isEmpty ())
+    _shellProcess->setWorkingDirectory (_initialWorkingDir);
   else
-    _shellProcess->setWorkingDirectory(QDir::homePath());
+    _shellProcess->setWorkingDirectory (QDir::homePath ());
 
-  _shellProcess->setFlowControlEnabled(_flowControl);
-  _shellProcess->setErase(_emulation->eraseChar());
+  _shellProcess->setFlowControlEnabled (_flowControl);
+  _shellProcess->setErase (_emulation->eraseChar ());
 
   // this is not strictly accurate use of the COLORFGBG variable.  This does not
   // tell the terminal exactly which colors are being used, but instead approximates
   // the color scheme as "black on white" or "white on black" depending on whether
   // the background color is deemed dark or not
-  QString backgroundColorHint = _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
+  QString backgroundColorHint =
+    _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
   _environment << backgroundColorHint;
-  _environment << QString("SHELL_SESSION_ID=%1").arg(shellSessionId());
+  _environment << QString ("SHELL_SESSION_ID=%1").arg (shellSessionId ());
 
-  int result = _shellProcess->start(exec,
-                                  arguments,
-                                  _environment,
-                                  windowId(),
-                                  _addToUtmp,
-                                  dbusService,
-                                  (QLatin1String("/Sessions/") +
-                                   QString::number(_sessionId)));
+  int result = _shellProcess->start (exec,
+				     arguments,
+				     _environment,
+				     windowId (),
+				     _addToUtmp,
+				     dbusService,
+				     (QLatin1String ("/Sessions/") +
+				      QString::number (_sessionId)));
 
   if (result < 0)
-  {
-    QString msg;
-    QTextStream msgStream(&msg);
-    msgStream << QString("Could not start program '") << exec << QString("' with arguments '") << arguments.join(" ") << QString("'.");
-    terminalWarning (msg);
-    //      terminalWarning(i18n("Could not start program '%1' with arguments '%2'.", exec.toLatin1().data(), arguments.join(" ").toLatin1().data()));
-    return;
-  }
+    {
+      QString msg;
+      QTextStream msgStream (&msg);
+      msgStream << QString ("Could not start program '") << exec <<
+	QString ("' with arguments '") << arguments.
+	join (" ") << QString ("'.");
+      terminalWarning (msg);
+      //      terminalWarning(i18n("Could not start program '%1' with arguments '%2'.", exec.toLatin1().data(), arguments.join(" ").toLatin1().data()));
+      return;
+    }
 
-  _shellProcess->setWriteable(false);  // We are reachable via kwrited.
+  _shellProcess->setWriteable (false);	// We are reachable via kwrited.
 
-  emit started();
+  emit started ();
 }
 
-void Session::setUserTitle( int what, const QString &caption )
+void
+Session::setUserTitle (int what, const QString & caption)
 {
-    //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
-    bool modified = false;
+  //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
+  bool modified = false;
 
-    if ((what == IconNameAndWindowTitle) || (what == WindowTitle)) 
+  if ((what == IconNameAndWindowTitle) || (what == WindowTitle))
     {
-           if ( _userTitle != caption ) {
-            _userTitle = caption;
-            modified = true;
-        }
+      if (_userTitle != caption)
+	{
+	  _userTitle = caption;
+	  modified = true;
+	}
     }
 
-    if ((what == IconNameAndWindowTitle) || (what == IconName))
+  if ((what == IconNameAndWindowTitle) || (what == IconName))
     {
-        if ( _iconText != caption ) {
-               _iconText = caption;
-            modified = true;
-        }
+      if (_iconText != caption)
+	{
+	  _iconText = caption;
+	  modified = true;
+	}
     }
 
-    if (what == TextColor || what == BackgroundColor) 
+  if (what == TextColor || what == BackgroundColor)
     {
-      QString colorString = caption.section(';',0,0);
-      QColor color = QColor(colorString);
-      if (color.isValid())
-      {
-          if (what == TextColor)
-                  emit changeForegroundColorRequest(color);
-          else
-                  emit changeBackgroundColorRequest(color);
-      }
+      QString colorString = caption.section (';', 0, 0);
+      QColor color = QColor (colorString);
+      if (color.isValid ())
+	{
+	  if (what == TextColor)
+	    emit changeForegroundColorRequest (color);
+	  else
+	  emit changeBackgroundColorRequest (color);
+	}
     }
 
-    if (what == SessionName) 
+  if (what == SessionName)
     {
-        if ( _nameTitle != caption ) {
-               setTitle(Session::NameRole,caption);
-            return;
-        }
+      if (_nameTitle != caption)
+	{
+	  setTitle (Session::NameRole, caption);
+	  return;
+	}
     }
 
-    if (what == 31) 
+  if (what == 31)
     {
-       QString cwd=caption;
-       cwd=cwd.replace( QRegExp("^~"), QDir::homePath() );
-       emit openUrlRequest(cwd);
+      QString cwd = caption;
+      cwd = cwd.replace (QRegExp ("^~"), QDir::homePath ());
+      emit openUrlRequest (cwd);
     }
 
-    // change icon via \033]32;Icon\007
-    if (what == 32) 
-    { 
-        if ( _iconName != caption ) {
-               _iconName = caption;
+  // change icon via \033]32;Icon\007
+  if (what == 32)
+    {
+      if (_iconName != caption)
+	{
+	  _iconName = caption;
 
-            modified = true;
-        }
+	  modified = true;
+	}
     }
 
-    if (what == ProfileChange) 
+  if (what == ProfileChange)
     {
-        emit profileChangeCommandReceived(caption);
-        return;
+      emit profileChangeCommandReceived (caption);
+      return;
     }
 
-    if ( modified )
-        emit titleChanged();
+  if (modified)
+    emit titleChanged ();
 }
 
-QString Session::userTitle() const
-{
-    return _userTitle;
-}
-void Session::setTabTitleFormat(TabTitleContext context , const QString& format)
+QString
+Session::userTitle () const
 {
-    if ( context == LocalTabTitle )
-        _localTabTitleFormat = format;
-    else if ( context == RemoteTabTitle )
-        _remoteTabTitleFormat = format;
-}
-QString Session::tabTitleFormat(TabTitleContext context) const
-{
-    if ( context == LocalTabTitle )
-        return _localTabTitleFormat;
-    else if ( context == RemoteTabTitle )
-        return _remoteTabTitleFormat;
-
-    return QString();
+  return _userTitle;
 }
 
-void Session::monitorTimerDone()
+void
+Session::setTabTitleFormat (TabTitleContext context, const QString & format)
+{
+  if (context == LocalTabTitle)
+    _localTabTitleFormat = format;
+  else if (context == RemoteTabTitle)
+    _remoteTabTitleFormat = format;
+}
+
+QString
+Session::tabTitleFormat (TabTitleContext context) const
+{
+  if (context == LocalTabTitle)
+    return _localTabTitleFormat;
+  else if (context == RemoteTabTitle)
+    return _remoteTabTitleFormat;
+
+  return QString ();
+}
+
+void
+Session::monitorTimerDone ()
 {
   //FIXME: The idea here is that the notification popup will appear to tell the user than output from
   //the terminal has stopped and the popup will disappear when the user activates the session.
   //
   //This breaks with the addition of multiple views of a session.  The popup should disappear
   //when any of the views of the session becomes active
-  
+
 
   //FIXME: Make message text for this notification and the activity notification more descriptive.    
-  if (_monitorSilence) {
-    //KNotification::event("Silence", i18n("Silence in session '%1'", _nameTitle)propagateSize, QPixmap(),
-    //                QApplication::activeWindow(),
-    //                KNotification::CloseWhenWidgetActivated);
-    emit stateChanged(NOTIFYSILENCE);
-  }
-  else
-  {
-    emit stateChanged(NOTIFYNORMAL);
-  }
-
-  _notifiedActivity=false;
-}
-void Session::updateFlowControlState(bool suspended)
-{
-    if (suspended)
+  if (_monitorSilence)
     {
-        if (flowControlEnabled())
-        {
-            foreach(TerminalDisplay* display,_views)
-            {
-                if (display->flowControlWarningEnabled())
-                    display->outputSuspended(true);
-            }
-        }
-    } 
-    else
+      //KNotification::event("Silence", i18n("Silence in session '%1'", _nameTitle)propagateSize, QPixmap(),
+      //                QApplication::activeWindow(),
+      //                KNotification::CloseWhenWidgetActivated);
+      emit stateChanged (NOTIFYSILENCE);
+    }
+  else
     {
-        foreach(TerminalDisplay* display,_views)
-            display->outputSuspended(false);
-    }   
-}
-void Session::activityStateSet(int state)
-{
-  if (state==NOTIFYBELL)
-  {
-      emit bellRequest(QString("Bell in session '%1'").arg(_nameTitle.toLatin1().data()));
-  }
-  else if (state==NOTIFYACTIVITY)
-  {
-    if (_monitorSilence) {
-      _monitorTimer->start(_silenceSeconds*1000);
+      emit stateChanged (NOTIFYNORMAL);
     }
 
-    if ( _monitorActivity ) {
-      //FIXME:  See comments in Session::monitorTimerDone()
-      if (!_notifiedActivity) {
-        //KNotification::event("Activity", i18n("Activity in session '%1'", _nameTitle), QPixmap(),
-        //                QApplication::activeWindow(),
-        //KNotification::CloseWhenWidgetActivated);
-        _notifiedActivity=true;
-      }
+  _notifiedActivity = false;
+}
+
+void
+Session::updateFlowControlState (bool suspended)
+{
+  if (suspended)
+    {
+      if (flowControlEnabled ())
+	{
+	  foreach (TerminalDisplay * display, _views)
+	  {
+	    if (display->flowControlWarningEnabled ())
+	      display->outputSuspended (true);
+	  }
+	}
     }
-  }
-
-  if ( state==NOTIFYACTIVITY && !_monitorActivity )
-          state = NOTIFYNORMAL;
-  if ( state==NOTIFYSILENCE && !_monitorSilence )
-          state = NOTIFYNORMAL;
-
-  emit stateChanged(state);
+  else
+    {
+      foreach (TerminalDisplay * display, _views)
+	display->outputSuspended (false);
+    }
 }
 
-void Session::onViewSizeChange(int /*height*/, int /*width*/)
+void
+Session::activityStateSet (int state)
 {
-  updateTerminalSize();
+  if (state == NOTIFYBELL)
+    {
+      emit bellRequest (QString ("Bell in session '%1'").
+			arg (_nameTitle.toLatin1 ().data ()));
+    }
+  else if (state == NOTIFYACTIVITY)
+    {
+      if (_monitorSilence)
+	{
+	  _monitorTimer->start (_silenceSeconds * 1000);
+	}
+
+      if (_monitorActivity)
+	{
+	  //FIXME:  See comments in Session::monitorTimerDone()
+	  if (!_notifiedActivity)
+	    {
+	      //KNotification::event("Activity", i18n("Activity in session '%1'", _nameTitle), QPixmap(),
+	      //                QApplication::activeWindow(),
+	      //KNotification::CloseWhenWidgetActivated);
+	      _notifiedActivity = true;
+	    }
+	}
+    }
+
+  if (state == NOTIFYACTIVITY && !_monitorActivity)
+    state = NOTIFYNORMAL;
+  if (state == NOTIFYSILENCE && !_monitorSilence)
+    state = NOTIFYNORMAL;
+
+  emit stateChanged (state);
+}
+
+void
+Session::onViewSizeChange (int /*height */ , int /*width */ )
+{
+  updateTerminalSize ();
 }
 
-void Session::updateTerminalSize()
+void
+Session::updateTerminalSize ()
 {
-    QListIterator<TerminalDisplay*> viewIter(_views);
+  QListIterator < TerminalDisplay * >viewIter (_views);
 
-    int minLines = -1;
-    int minColumns = -1;
+  int minLines = -1;
+  int minColumns = -1;
 
-    // minimum number of lines and columns that views require for
-    // their size to be taken into consideration ( to avoid problems
-    // with new view widgets which haven't yet been set to their correct size )
-    const int VIEW_LINES_THRESHOLD = 2;
-    const int VIEW_COLUMNS_THRESHOLD = 2;
+  // minimum number of lines and columns that views require for
+  // their size to be taken into consideration ( to avoid problems
+  // with new view widgets which haven't yet been set to their correct size )
+  const int VIEW_LINES_THRESHOLD = 2;
+  const int VIEW_COLUMNS_THRESHOLD = 2;
 
-    //select largest number of lines and columns that will fit in all visible views
-    while ( viewIter.hasNext() )
+  //select largest number of lines and columns that will fit in all visible views
+  while (viewIter.hasNext ())
     {
-        TerminalDisplay* view = viewIter.next();
-        if ( view->isHidden() == false &&
-             view->lines() >= VIEW_LINES_THRESHOLD &&
-             view->columns() >= VIEW_COLUMNS_THRESHOLD )
-        {
-            minLines = (minLines == -1) ? view->lines() : qMin( minLines , view->lines() );
-            minColumns = (minColumns == -1) ? view->columns() : qMin( minColumns , view->columns() );
-            view->processFilters();
-        }
+      TerminalDisplay *view = viewIter.next ();
+      if (view->isHidden () == false &&
+	  view->lines () >= VIEW_LINES_THRESHOLD &&
+	  view->columns () >= VIEW_COLUMNS_THRESHOLD)
+	{
+	  minLines =
+	    (minLines == -1) ? view->lines () : qMin (minLines,
+						      view->lines ());
+	  minColumns =
+	    (minColumns == -1) ? view->columns () : qMin (minColumns,
+							  view->columns ());
+	  view->processFilters ();
+	}
     }
 
-    // backend emulation must have a _terminal of at least 1 column x 1 line in size
-    if ( minLines > 0 && minColumns > 0 )
+  // backend emulation must have a _terminal of at least 1 column x 1 line in size
+  if (minLines > 0 && minColumns > 0)
     {
-        _emulation->setImageSize( minLines , minColumns );
+      _emulation->setImageSize (minLines, minColumns);
     }
 }
-void Session::updateWindowSize(int lines, int columns)
-{
-    Q_ASSERT(lines > 0 && columns > 0);
-    _shellProcess->setWindowSize(lines,columns);
-}
-void Session::refresh()
+
+void
+Session::updateWindowSize (int lines, int columns)
 {
-    // attempt to get the shell process to redraw the display
-    //
-    // this requires the program running in the shell
-    // to cooperate by sending an update in response to
-    // a window size change
-    //
-    // the window size is changed twice, first made slightly larger and then
-    // resized back to its normal size so that there is actually a change
-    // in the window size (some shells do nothing if the
-    // new and old sizes are the same)
-    //
-    // if there is a more 'correct' way to do this, please
-    // send an email with method or patches to konsole-devel@kde.org
-
-    const QSize existingSize = _shellProcess->windowSize();
-    _shellProcess->setWindowSize(existingSize.height(),existingSize.width()+1);
-    _shellProcess->setWindowSize(existingSize.height(),existingSize.width());
+  Q_ASSERT (lines > 0 && columns > 0);
+  _shellProcess->setWindowSize (lines, columns);
 }
 
-bool Session::kill(int signal)
+void
+Session::refresh ()
 {
-    int result = ::kill(_shellProcess->pid(),signal);    
-    
-    if ( result == 0 )
-    {
-        _shellProcess->waitForFinished();
-        return true;
-    }
-    else
-        return false;
+  // attempt to get the shell process to redraw the display
+  //
+  // this requires the program running in the shell
+  // to cooperate by sending an update in response to
+  // a window size change
+  //
+  // the window size is changed twice, first made slightly larger and then
+  // resized back to its normal size so that there is actually a change
+  // in the window size (some shells do nothing if the
+  // new and old sizes are the same)
+  //
+  // if there is a more 'correct' way to do this, please
+  // send an email with method or patches to konsole-devel@kde.org
+
+  const QSize existingSize = _shellProcess->windowSize ();
+  _shellProcess->setWindowSize (existingSize.height (),
+				existingSize.width () + 1);
+  _shellProcess->setWindowSize (existingSize.height (),
+				existingSize.width ());
 }
 
-void Session::close()
+bool
+Session::kill (int signal)
+{
+  int result =::kill (_shellProcess->pid (), signal);
+
+  if (result == 0)
+    {
+      _shellProcess->waitForFinished ();
+      return true;
+    }
+  else
+    return false;
+}
+
+void
+Session::close ()
 {
   _autoClose = true;
   _wantedClose = true;
 
-  if (!isRunning() || !kill(SIGHUP))
-  {
-     if (isRunning())
-     {
-        //kWarning() << "Process" << _shellProcess->pid() << "did not respond to SIGHUP";
+  if (!isRunning () || !kill (SIGHUP))
+    {
+      if (isRunning ())
+	{
+	  //kWarning() << "Process" << _shellProcess->pid() << "did not respond to SIGHUP";
 
-        // close the pty and wait to see if the process finishes.  If it does,
-        // the done() slot will have been called so we can return.  Otherwise,
-        // emit the finished() signal regardless
-        _shellProcess->pty()->close();
-        if (_shellProcess->waitForFinished(3000))
-            return;
+	  // close the pty and wait to see if the process finishes.  If it does,
+	  // the done() slot will have been called so we can return.  Otherwise,
+	  // emit the finished() signal regardless
+	  _shellProcess->pty ()->close ();
+	  if (_shellProcess->waitForFinished (3000))
+	    return;
 
-        //kWarning() << "Unable to kill process" << _shellProcess->pid();
-     }
+	  //kWarning() << "Unable to kill process" << _shellProcess->pid();
+	}
 
-     // Forced close.
-     QTimer::singleShot(1, this, SIGNAL(finished()));
-  }
+      // Forced close.
+      QTimer::singleShot (1, this, SIGNAL (finished ()));
+    }
 }
 
-void Session::sendText(const QString &text) const
+void
+Session::sendText (const QString & text) const
 {
-  _emulation->sendText(text);
+  _emulation->sendText (text);
 }
 
-void Session::sendMouseEvent(int buttons, int column, int line, int eventType)
+void
+Session::sendMouseEvent (int buttons, int column, int line, int eventType)
 {
-    _emulation->sendMouseEvent(buttons, column, line, eventType);
+  _emulation->sendMouseEvent (buttons, column, line, eventType);
 }
 
-Session::~Session()
+Session::~Session ()
 {
   if (_foregroundProcessInfo)
-      delete _foregroundProcessInfo;
+    delete _foregroundProcessInfo;
   if (_sessionProcessInfo)
-      delete _sessionProcessInfo;
+    delete _sessionProcessInfo;
   delete _emulation;
   delete _shellProcess;
   //delete _zmodemProc;
 }
 
-void Session::done(int exitStatus)
+void
+Session::done (int exitStatus)
 {
   if (!_autoClose)
-  {
-    _userTitle = QString("@info:shell This session is done");
-    emit titleChanged();
-    return;
-  }
+    {
+      _userTitle = QString ("@info:shell This session is done");
+      emit titleChanged ();
+      return;
+    }
 
   QString message;
-  QTextStream msgStream(&message);
+  QTextStream msgStream (&message);
   if (!_wantedClose || exitStatus != 0)
-  {
-    if (_shellProcess->exitStatus() == QProcess::NormalExit)
     {
-      msgStream << "Program '" << _program << "' exited with statis " << exitStatus << ".";
-      //message = i18n("Program '%1' exited with status %2.", _program.toLatin1().data(), exitStatus);
+      if (_shellProcess->exitStatus () == QProcess::NormalExit)
+	{
+	  msgStream << "Program '" << _program << "' exited with statis " <<
+	    exitStatus << ".";
+	  //message = i18n("Program '%1' exited with status %2.", _program.toLatin1().data(), exitStatus);
 
-    }
-    else
-    {
-      msgStream << "Program '" << _program << "' crashed.";
-      //message = i18n("Program '%1' crashed.", _program.toLatin1().data());
-	
+	}
+      else
+	{
+	  msgStream << "Program '" << _program << "' crashed.";
+	  //message = i18n("Program '%1' crashed.", _program.toLatin1().data());
+
+	}
+
+      //FIXME: See comments in Session::monitorTimerDone()
+      //KNotification::event("Finished", message , QPixmap(),
+      //                     QApplication::activeWindow(),
+      //                     KNotification::CloseWhenWidgetActivated);
     }
 
-    //FIXME: See comments in Session::monitorTimerDone()
-    //KNotification::event("Finished", message , QPixmap(),
-    //                     QApplication::activeWindow(),
-    //                     KNotification::CloseWhenWidgetActivated);
-  }
-
-  if ( !_wantedClose && _shellProcess->exitStatus() != QProcess::NormalExit )
-      terminalWarning(message);
+  if (!_wantedClose && _shellProcess->exitStatus () != QProcess::NormalExit)
+    terminalWarning (message);
   else
-        emit finished();
+    emit finished ();
 }
 
-Emulation* Session::emulation() const
+Emulation *
+Session::emulation () const
 {
   return _emulation;
 }
 
-QString Session::keyBindings() const
+QString
+Session::keyBindings () const
 {
-  return _emulation->keyBindings();
+  return _emulation->keyBindings ();
 }
 
-QStringList Session::environment() const
+QStringList
+Session::environment () const
 {
   return _environment;
 }
 
-void Session::setEnvironment(const QStringList& environment)
+void
+Session::setEnvironment (const QStringList & environment)
 {
-    _environment = environment;
+  _environment = environment;
 }
 
-int Session::sessionId() const
+int
+Session::sessionId () const
 {
   return _sessionId;
 }
 
-void Session::setKeyBindings(const QString &id)
+void
+Session::setKeyBindings (const QString & id)
 {
-  _emulation->setKeyBindings(id);
+  _emulation->setKeyBindings (id);
 }
 
-void Session::setTitle(TitleRole role , const QString& newTitle)
+void
+Session::setTitle (TitleRole role, const QString & newTitle)
 {
-    if ( title(role) != newTitle )
+  if (title (role) != newTitle)
     {
-        if ( role == NameRole )
-            _nameTitle = newTitle;
-        else if ( role == DisplayedTitleRole )
-            _displayTitle = newTitle;
+      if (role == NameRole)
+	_nameTitle = newTitle;
+      else if (role == DisplayedTitleRole)
+	_displayTitle = newTitle;
 
-        emit titleChanged();
+      emit titleChanged ();
     }
 }
 
-QString Session::title(TitleRole role) const
+QString
+Session::title (TitleRole role) const
 {
-    if ( role == NameRole )
-        return _nameTitle;
-    else if ( role == DisplayedTitleRole )
-        return _displayTitle;
-    else
-        return QString();
+  if (role == NameRole)
+    return _nameTitle;
+  else if (role == DisplayedTitleRole)
+    return _displayTitle;
+  else
+    return QString ();
 }
 
-ProcessInfo* Session::getProcessInfo()
+ProcessInfo *
+Session::getProcessInfo ()
 {
-    ProcessInfo* process;
+  ProcessInfo *process;
 
-    if (isForegroundProcessActive())
-        process = _foregroundProcessInfo;
-    else
+  if (isForegroundProcessActive ())
+    process = _foregroundProcessInfo;
+  else
     {
-        updateSessionProcessInfo();
-        process = _sessionProcessInfo;
+      updateSessionProcessInfo ();
+      process = _sessionProcessInfo;
     }
 
-    return process;
+  return process;
 }
 
-void Session::updateSessionProcessInfo()
+void
+Session::updateSessionProcessInfo ()
 {
-    Q_ASSERT(_shellProcess);
-    if (!_sessionProcessInfo)
+  Q_ASSERT (_shellProcess);
+  if (!_sessionProcessInfo)
     {
-        _sessionProcessInfo = ProcessInfo::newInstance(processId());
-        _sessionProcessInfo->setUserHomeDir();
+      _sessionProcessInfo = ProcessInfo::newInstance (processId ());
+      _sessionProcessInfo->setUserHomeDir ();
     }
-    _sessionProcessInfo->update();
+  _sessionProcessInfo->update ();
 }
 
-bool Session::updateForegroundProcessInfo()
+bool
+Session::updateForegroundProcessInfo ()
 {
-    bool valid = (_foregroundProcessInfo != 0);
+  bool valid = (_foregroundProcessInfo != 0);
 
-    // has foreground process changed?
-    Q_ASSERT(_shellProcess);
-    int pid = _shellProcess->foregroundProcessGroup();
-    if (pid != _foregroundPid)
+  // has foreground process changed?
+  Q_ASSERT (_shellProcess);
+  int pid = _shellProcess->foregroundProcessGroup ();
+  if (pid != _foregroundPid)
     {
-        if (valid)
-            delete _foregroundProcessInfo;
-        _foregroundProcessInfo = ProcessInfo::newInstance(pid);
-        _foregroundPid = pid;
-        valid = true;
+      if (valid)
+	delete _foregroundProcessInfo;
+      _foregroundProcessInfo = ProcessInfo::newInstance (pid);
+      _foregroundPid = pid;
+      valid = true;
     }
 
-    if (valid)
+  if (valid)
     {
-        _foregroundProcessInfo->update();
-        valid = _foregroundProcessInfo->isValid();
+      _foregroundProcessInfo->update ();
+      valid = _foregroundProcessInfo->isValid ();
     }
 
-    return valid;
+  return valid;
 }
 
-bool Session::isRemote()
+bool
+Session::isRemote ()
 {
-    ProcessInfo* process = getProcessInfo();
+  ProcessInfo *process = getProcessInfo ();
 
-    bool ok = false;
-    return ( process->name(&ok) == "ssh" && ok );
+  bool ok = false;
+  return (process->name (&ok) == "ssh" && ok);
 }
 
-QString Session::getDynamicTitle()
+QString
+Session::getDynamicTitle ()
 {
-    // update current directory from process
-    ProcessInfo* process = updateWorkingDirectory();
+  // update current directory from process
+  ProcessInfo *process = updateWorkingDirectory ();
 
-    // format tab titles using process info
-    bool ok = false;
-    QString title;
-    if ( process->name(&ok) == "ssh" && ok )
+  // format tab titles using process info
+  bool ok = false;
+  QString title;
+  if (process->name (&ok) == "ssh" && ok)
     {
-        SSHProcessInfo sshInfo(*process);
-        title = sshInfo.format(tabTitleFormat(Session::RemoteTabTitle));
+      SSHProcessInfo sshInfo (*process);
+      title = sshInfo.format (tabTitleFormat (Session::RemoteTabTitle));
     }
-    else
-        title = process->format(tabTitleFormat(Session::LocalTabTitle));
+  else
+    title = process->format (tabTitleFormat (Session::LocalTabTitle));
 
-    return title;
+  return title;
 }
 
-void Session::setIconName(const QString& iconName)
+void
+Session::setIconName (const QString & iconName)
 {
-    if ( iconName != _iconName )
+  if (iconName != _iconName)
     {
-        _iconName = iconName;
-        emit titleChanged();
+      _iconName = iconName;
+      emit titleChanged ();
     }
 }
 
-void Session::setIconText(const QString& iconText)
+void
+Session::setIconText (const QString & iconText)
 {
   _iconText = iconText;
 }
 
-QString Session::iconName() const
+QString
+Session::iconName () const
 {
   return _iconName;
 }
 
-QString Session::iconText() const
+QString
+Session::iconText () const
 {
   return _iconText;
 }
 
-void Session::setHistoryType(const HistoryType &hType)
+void
+Session::setHistoryType (const HistoryType & hType)
 {
-  _emulation->setHistory(hType);
+  _emulation->setHistory (hType);
 }
 
-const HistoryType& Session::historyType() const
+const HistoryType &
+Session::historyType () const
 {
-  return _emulation->history();
+  return _emulation->history ();
 }
 
-void Session::clearHistory()
+void
+Session::clearHistory ()
 {
-    _emulation->clearHistory();
+  _emulation->clearHistory ();
 }
 
-QStringList Session::arguments() const
+QStringList
+Session::arguments () const
 {
   return _arguments;
 }
 
-QString Session::program() const
+QString
+Session::program () const
 {
   return _program;
 }
 
 // unused currently
-bool Session::isMonitorActivity() const { return _monitorActivity; }
-// unused currently
-bool Session::isMonitorSilence()  const { return _monitorSilence; }
+bool
+Session::isMonitorActivity () const
+{
+  return _monitorActivity;
+}
 
-void Session::setMonitorActivity(bool _monitor)
+// unused currently
+bool
+Session::isMonitorSilence () const
 {
-  _monitorActivity=_monitor;
-  _notifiedActivity=false;
-
-  activityStateSet(NOTIFYNORMAL);
+  return _monitorSilence;
 }
 
-void Session::setMonitorSilence(bool _monitor)
+void
+Session::setMonitorActivity (bool _monitor)
 {
-  if (_monitorSilence==_monitor)
+  _monitorActivity = _monitor;
+  _notifiedActivity = false;
+
+  activityStateSet (NOTIFYNORMAL);
+}
+
+void
+Session::setMonitorSilence (bool _monitor)
+{
+  if (_monitorSilence == _monitor)
     return;
 
-  _monitorSilence=_monitor;
+  _monitorSilence = _monitor;
   if (_monitorSilence)
-  {
-    _monitorTimer->start(_silenceSeconds*1000);
-  }
+    {
+      _monitorTimer->start (_silenceSeconds * 1000);
+    }
   else
-    _monitorTimer->stop();
+    _monitorTimer->stop ();
 
-  activityStateSet(NOTIFYNORMAL);
+  activityStateSet (NOTIFYNORMAL);
 }
 
-void Session::setMonitorSilenceSeconds(int seconds)
+void
+Session::setMonitorSilenceSeconds (int seconds)
 {
-  _silenceSeconds=seconds;
-  if (_monitorSilence) {
-    _monitorTimer->start(_silenceSeconds*1000);
-  }
+  _silenceSeconds = seconds;
+  if (_monitorSilence)
+    {
+      _monitorTimer->start (_silenceSeconds * 1000);
+    }
 }
 
-void Session::setAddToUtmp(bool set)
+void
+Session::setAddToUtmp (bool set)
 {
   _addToUtmp = set;
 }
 
-void Session::setFlowControlEnabled(bool enabled)
+void
+Session::setFlowControlEnabled (bool enabled)
 {
   _flowControl = enabled;
 
-  if (_shellProcess)  
-    _shellProcess->setFlowControlEnabled(_flowControl);
-  emit flowControlEnabledChanged(enabled);
-}
-bool Session::flowControlEnabled() const
-{
-    if (_shellProcess)
-            return _shellProcess->flowControlEnabled();
-    else
-            return _flowControl;
+  if (_shellProcess)
+    _shellProcess->setFlowControlEnabled (_flowControl);
+  emit flowControlEnabledChanged (enabled);
 }
 
-void Session::onReceiveBlock( const char* buf, int len )
+bool
+Session::flowControlEnabled () const
 {
-    _emulation->receiveData( buf, len );
-    emit receivedData( QString::fromLatin1( buf, len ) );
+  if (_shellProcess)
+    return _shellProcess->flowControlEnabled ();
+  else
+    return _flowControl;
+}
+
+void
+Session::onReceiveBlock (const char *buf, int len)
+{
+  _emulation->receiveData (buf, len);
+  emit receivedData (QString::fromLatin1 (buf, len));
+}
+
+QSize
+Session::size ()
+{
+  return _emulation->imageSize ();
 }
 
-QSize Session::size()
+void
+Session::setSize (const QSize & size)
 {
-  return _emulation->imageSize();
+  if ((size.width () <= 1) || (size.height () <= 1))
+    return;
+
+  emit resizeRequest (size);
 }
 
-void Session::setSize(const QSize& size)
+int
+Session::processId () const
 {
-  if ((size.width() <= 1) || (size.height() <= 1))
-     return;
-
-  emit resizeRequest(size);
-}
-int Session::processId() const
-{
-    return _shellProcess->pid();
+  return _shellProcess->pid ();
 }
 
-void Session::setTitle(int role , const QString& title)
+void
+Session::setTitle (int role, const QString & title)
 {
-    switch (role) {
+  switch (role)
+    {
     case (0):
-        this->setTitle(Session::NameRole, title);
-        break;
+      this->setTitle (Session::NameRole, title);
+      break;
     case (1):
-        this->setTitle(Session::DisplayedTitleRole, title);
-        break;
+      this->setTitle (Session::DisplayedTitleRole, title);
+      break;
     }
 }
 
-QString Session::title(int role) const
+QString
+Session::title (int role) const
 {
-    switch (role) {
+  switch (role)
+    {
     case (0):
-        return this->title(Session::NameRole);
+      return this->title (Session::NameRole);
     case (1):
-        return this->title(Session::DisplayedTitleRole);
+      return this->title (Session::DisplayedTitleRole);
     default:
-        return QString();
+      return QString ();
     }
 }
 
-void Session::setTabTitleFormat(int context , const QString& format)
+void
+Session::setTabTitleFormat (int context, const QString & format)
 {
-    switch (context) {
+  switch (context)
+    {
     case (0):
-        this->setTabTitleFormat(Session::LocalTabTitle, format);
-        break;
+      this->setTabTitleFormat (Session::LocalTabTitle, format);
+      break;
     case (1):
-        this->setTabTitleFormat(Session::RemoteTabTitle, format);
-        break;
+      this->setTabTitleFormat (Session::RemoteTabTitle, format);
+      break;
     }
 }
 
-QString Session::tabTitleFormat(int context) const
+QString
+Session::tabTitleFormat (int context) const
 {
-    switch (context) {
+  switch (context)
+    {
     case (0):
-        return this->tabTitleFormat(Session::LocalTabTitle);
+      return this->tabTitleFormat (Session::LocalTabTitle);
     case (1):
-        return this->tabTitleFormat(Session::RemoteTabTitle);
+      return this->tabTitleFormat (Session::RemoteTabTitle);
     default:
-        return QString();
+      return QString ();
     }
 }
 
-int Session::foregroundProcessId()
+int
+Session::foregroundProcessId ()
 {
-    int pid;
+  int pid;
 
-    bool ok = false;
-    pid = getProcessInfo()->pid(&ok);
-    if (!ok)
-        pid = -1;
+  bool ok = false;
+  pid = getProcessInfo ()->pid (&ok);
+  if (!ok)
+    pid = -1;
 
-    return pid;
+  return pid;
 }
 
-bool Session::isForegroundProcessActive()
+bool
+Session::isForegroundProcessActive ()
 {
-    // foreground process info is always updated after this
-    return updateForegroundProcessInfo() && (processId() != _foregroundPid);
+  // foreground process info is always updated after this
+  return updateForegroundProcessInfo () && (processId () != _foregroundPid);
 }
 
-QString Session::foregroundProcessName()
+QString
+Session::foregroundProcessName ()
 {
-    QString name;
+  QString name;
 
-    if (updateForegroundProcessInfo()) 
+  if (updateForegroundProcessInfo ())
     {
-        bool ok = false;
-        name = _foregroundProcessInfo->name(&ok);
-        if (!ok)
-            name.clear();
+      bool ok = false;
+      name = _foregroundProcessInfo->name (&ok);
+      if (!ok)
+	name.clear ();
     }
 
-    return name;
+  return name;
 }
 
-SessionGroup::SessionGroup(QObject* parent)
-    : QObject(parent), _masterMode(0)
+SessionGroup::SessionGroup (QObject * parent):QObject (parent), _masterMode (0)
 {
 }
-SessionGroup::~SessionGroup()
+
+SessionGroup::~SessionGroup ()
 {
 }
-int SessionGroup::masterMode() const { return _masterMode; }
-QList<Session*> SessionGroup::sessions() const { return _sessions.keys(); }
-bool SessionGroup::masterStatus(Session* session) const { return _sessions[session]; }
+
+int
+SessionGroup::masterMode () const
+{
+  return _masterMode;
+}
 
-void SessionGroup::addSession(Session* session)
+QList < Session * >SessionGroup::sessions () const
 {
-    connect(session,SIGNAL(finished()),this,SLOT(sessionFinished()));
-    _sessions.insert(session,false);
+  return _sessions.keys ();
 }
-void SessionGroup::removeSession(Session* session)
+
+bool
+SessionGroup::masterStatus (Session * session) const
 {
-    disconnect(session,SIGNAL(finished()),this,SLOT(sessionFinished()));
-    setMasterStatus(session,false);
-    _sessions.remove(session);
+  return _sessions[session];
 }
-void SessionGroup::sessionFinished()
+
+void
+SessionGroup::addSession (Session * session)
 {
-    Session* session = qobject_cast<Session*>(sender());
-    Q_ASSERT(session);
-    removeSession(session);
+  connect (session, SIGNAL (finished ()), this, SLOT (sessionFinished ()));
+  _sessions.insert (session, false);
 }
-void SessionGroup::setMasterMode(int mode)
+
+void
+SessionGroup::removeSession (Session * session)
+{
+  disconnect (session, SIGNAL (finished ()), this, SLOT (sessionFinished ()));
+  setMasterStatus (session, false);
+  _sessions.remove (session);
+}
+
+void
+SessionGroup::sessionFinished ()
 {
-   _masterMode = mode;
+  Session *session = qobject_cast < Session * >(sender ());
+  Q_ASSERT (session);
+  removeSession (session);
 }
-QList<Session*> SessionGroup::masters() const
+
+void
+SessionGroup::setMasterMode (int mode)
 {
-    return _sessions.keys(true);
+  _masterMode = mode;
 }
-void SessionGroup::setMasterStatus(Session* session , bool master)
+
+QList < Session * >SessionGroup::masters () const
 {
-    const bool wasMaster = _sessions[session];
+  return _sessions.keys (true);
+}
 
-    if (wasMaster == master) {
-        // No status change -> nothing to do.
-        return;
-    }
-    _sessions[session] = master;
+void
+SessionGroup::setMasterStatus (Session * session, bool master)
+{
+  const bool wasMaster = _sessions[session];
 
-    if(master) {
-        connect( session->emulation() , SIGNAL(sendData(const char*,int)) , this,
-                 SLOT(forwardData(const char*,int)) );
+  if (wasMaster == master)
+    {
+      // No status change -> nothing to do.
+      return;
     }
-    else {
-        disconnect( session->emulation() , SIGNAL(sendData(const char*,int)) , this,
-                    SLOT(forwardData(const char*,int)) );
+  _sessions[session] = master;
+
+  if (master)
+    {
+      connect (session->emulation (), SIGNAL (sendData (const char *, int)),
+	       this, SLOT (forwardData (const char *, int)));
+    }
+  else
+    {
+      disconnect (session->emulation (),
+		  SIGNAL (sendData (const char *, int)), this,
+		  SLOT (forwardData (const char *, int)));
     }
 }
-void SessionGroup::forwardData(const char* data, int size)
+
+void
+SessionGroup::forwardData (const char *data, int size)
 {
-    static bool _inForwardData = false;
-    if(_inForwardData) {   // Avoid recursive calls among session groups!
-       // A recursive call happens when a master in group A calls forwardData()
-       // in group B. If one of the destination sessions in group B is also a
-       // master of a group including the master session of group A, this would
-       // again call forwardData() in group A, and so on.
-       return;
+  static bool _inForwardData = false;
+  if (_inForwardData)
+    {				// Avoid recursive calls among session groups!
+      // A recursive call happens when a master in group A calls forwardData()
+      // in group B. If one of the destination sessions in group B is also a
+      // master of a group including the master session of group A, this would
+      // again call forwardData() in group A, and so on.
+      return;
     }
-    
-    _inForwardData = true;
-    QListIterator<Session*> iter(_sessions.keys());
-    while(iter.hasNext()) {
-        Session* other = iter.next();
-        if(!_sessions[other]) {
-           other->emulation()->sendString(data, size);
-        }
+
+  _inForwardData = true;
+  QListIterator < Session * >iter (_sessions.keys ());
+  while (iter.hasNext ())
+    {
+      Session *other = iter.next ();
+      if (!_sessions[other])
+	{
+	  other->emulation ()->sendString (data, size);
+	}
     }
-    _inForwardData = false;
+  _inForwardData = false;
 }
-
-
diff --git a/gui/src/terminal/Session.h b/gui/src/terminal/Session.h
--- a/gui/src/terminal/Session.h
+++ b/gui/src/terminal/Session.h
@@ -47,92 +47,88 @@ class TerminalDisplay;
  * The terminal emulation ( Emulation and subclasses ) processes the output stream from the
  * PTY and produces a character image which is then shown on views connected to the session.
  *
  * Each Session can be connected to one or more views by using the addView() method.
  * The attached views can then display output from the program running in the terminal
  * or send input to the program in the terminal in the form of keypresses and mouse
  * activity.
  */
-class Session : public QObject
+class Session:public QObject
 {
-Q_OBJECT
-Q_CLASSINFO("D-Bus Interface", "org.kde.konsole.Session")
-
-public:
-  Q_PROPERTY(QString name READ nameTitle)
-  Q_PROPERTY(int processId READ processId)
-  Q_PROPERTY(QString keyBindings READ keyBindings WRITE setKeyBindings)
-  Q_PROPERTY(QSize size READ size WRITE setSize)
-
+Q_OBJECT Q_CLASSINFO ("D-Bus Interface", "org.kde.konsole.Session") public:
+  Q_PROPERTY (QString name READ nameTitle)
+    Q_PROPERTY (int processId READ processId)
+    Q_PROPERTY (QString keyBindings READ keyBindings WRITE setKeyBindings)
+    Q_PROPERTY (QSize size READ size WRITE setSize)
   /**
    * Constructs a new session.
    *
    * To start the terminal process, call the run() method,
    * after specifying the program and arguments
    * using setProgram() and setArguments()
    *
    * If no program or arguments are specified explicitly, the Session
    * falls back to using the program specified in the SHELL environment
    * variable.
    */
-  explicit Session(QObject* parent = 0);
-  ~Session();
+  explicit Session (QObject * parent = 0);
+   ~Session ();
 
   /** 
    * Connect to an existing terminal.  When a new Session() is constructed it 
    * automatically searches for and opens a new teletype.  If you want to 
    * use an existing teletype (given its file descriptor) call this after
    * constructing the session.
    *
    * Calling openTeletype() while a session is running has no effect.
    *
    * @param masterFd The file descriptor of the pseudo-teletype master (See KPtyProcess::KPtyProcess())
    */
-  void openTeletype(int masterFd);
+  void openTeletype (int masterFd);
 
   /**
    * Returns true if the session is currently running.  This will be true
    * after run() has been called successfully.
    */
-  bool isRunning() const;
+  bool isRunning () const;
 
   /**
    * Adds a new view for this session.
    *
    * The viewing widget will display the output from the terminal and
    * input from the viewing widget (key presses, mouse activity etc.)
    * will be sent to the terminal.
    *
    * Views can be removed using removeView().  The session is automatically
    * closed when the last view is removed.
    */
-  void addView(TerminalDisplay* widget);
+  void addView (TerminalDisplay * widget);
   /**
    * Removes a view from this session.  When the last view is removed,
    * the session will be closed automatically.
    *
    * @p widget will no longer display output from or send input
    * to the terminal
    */
-  void removeView(TerminalDisplay* widget);
+  void removeView (TerminalDisplay * widget);
 
   /**
    * Returns the views connected to this session
    */
-  QList<TerminalDisplay*> views() const;
+    QList < TerminalDisplay * >views () const;
 
   /**
    * Returns the terminal emulation instance being used to encode / decode
    * characters to / from the process.
    */
-  Emulation*  emulation() const;
+  Emulation *emulation () const;
 
   /** Returns the unique ID for this session. */
-  int sessionId() const;
+  int sessionId () const;
 
   /**
    * This enum describes the contexts for which separate
    * tab title formats may be specified.
    */
   enum TabTitleContext
   {
     /** Default tab title format */
@@ -143,604 +139,609 @@ public:
      */
     RemoteTabTitle
   };
 
   /**
    * Returns true if the session currently contains a connection to a 
    * remote computer.  It currently supports ssh.
    */
-  bool isRemote();
+  bool isRemote ();
 
   /**
    * Sets the format used by this session for tab titles.
    *
    * @param context The context whoose format should be set.
    * @param format The tab title format.  This may be a mixture
    * of plain text and dynamic elements denoted by a '%' character
    * followed by a letter.  (eg. %d for directory).  The dynamic
    * elements available depend on the @p context
    */
-  void setTabTitleFormat(TabTitleContext context , const QString& format);
+  void setTabTitleFormat (TabTitleContext context, const QString & format);
   /** Returns the format used by this session for tab titles. */
-  QString tabTitleFormat(TabTitleContext context) const;
+  QString tabTitleFormat (TabTitleContext context) const;
 
 
   /** Returns the arguments passed to the shell process when run() is called. */
-  QStringList arguments() const;
+  QStringList arguments () const;
   /** Returns the program name of the shell process started when run() is called. */
-  QString program() const;
+  QString program () const;
 
   /**
    * Sets the command line arguments which the session's program will be passed when
    * run() is called.
    */
-  void setArguments(const QStringList& arguments);
+  void setArguments (const QStringList & arguments);
   /** Sets the program to be executed when run() is called. */
-  void setProgram(const QString& program);
+  void setProgram (const QString & program);
 
   /** Returns the session's current working directory. */
-  QString initialWorkingDirectory() { return _initialWorkingDir; }
+  QString initialWorkingDirectory ()
+  {
+    return _initialWorkingDir;
+  }
 
   /**
    * Sets the initial working directory for the session when it is run
    * This has no effect once the session has been started.
    */
-  void setInitialWorkingDirectory( const QString& dir );
+  void setInitialWorkingDirectory (const QString & dir);
 
   /**
    * Returns the current directory of the foreground process in the session
    */
-  QString currentWorkingDirectory();
+  QString currentWorkingDirectory ();
 
   /**
    * Sets the type of history store used by this session.
    * Lines of output produced by the terminal are added
    * to the history store.  The type of history store
    * used affects the number of lines which can be
    * remembered before they are lost and the storage
    * (in memory, on-disk etc.) used.
    */
-  void setHistoryType(const HistoryType& type);
+  void setHistoryType (const HistoryType & type);
   /**
    * Returns the type of history store used by this session.
    */
-  const HistoryType& historyType() const;
+  const HistoryType & historyType () const;
   /**
    * Clears the history store used by this session.
    */
-  void clearHistory();
+  void clearHistory ();
 
   /**
    * Sets the key bindings used by this session.  The bindings
    * specify how input key sequences are translated into
    * the character stream which is sent to the terminal.
    *
    * @param id The name of the key bindings to use.  The
    * names of available key bindings can be determined using the
    * KeyboardTranslatorManager class.
    */
-  void setKeyBindings(const QString& id);
+  void setKeyBindings (const QString & id);
   /** Returns the name of the key bindings used by this session. */
-  QString keyBindings() const;
+  QString keyBindings () const;
 
   /**
    * This enum describes the available title roles.
    */
   enum TitleRole
   {
       /** The name of the session. */
-      NameRole,
+    NameRole,
       /** The title of the session which is displayed in tabs etc. */
-      DisplayedTitleRole
+    DisplayedTitleRole
   };
 
   /**
    * Return the session title set by the user (ie. the program running
    * in the terminal), or an empty string if the user has not set a custom title
    */
-  QString userTitle() const;
+  QString userTitle () const;
 
   /** Convenience method used to read the name property.  Returns title(Session::NameRole). */
-  QString nameTitle() const { return title(Session::NameRole); }
+  QString nameTitle () const
+  {
+    return title (Session::NameRole);
+  }
   /** Returns a title generated from tab format and process information. */
-  QString getDynamicTitle();
+  QString getDynamicTitle ();
 
   /** Sets the name of the icon associated with this session. */
-  void setIconName(const QString& iconName);
+  void setIconName (const QString & iconName);
   /** Returns the name of the icon associated with this session. */
-  QString iconName() const;
+  QString iconName () const;
 
   /** Return URL for the session. */
   //KUrl getUrl();
 
   /** Sets the text of the icon associated with this session. */
-  void setIconText(const QString& iconText);
+  void setIconText (const QString & iconText);
   /** Returns the text of the icon associated with this session. */
-  QString iconText() const;
+  QString iconText () const;
 
   /** Sets the session's title for the specified @p role to @p title. */
-  void setTitle(TitleRole role , const QString& title);
+  void setTitle (TitleRole role, const QString & title);
 
   /** Returns the session's title for the specified @p role. */
-  QString title(TitleRole role) const;
+  QString title (TitleRole role) const;
 
   /** 
    * Specifies whether a utmp entry should be created for the pty used by this session.
    * If true, KPty::login() is called when the session is started.
    */
-  void setAddToUtmp(bool);
+  void setAddToUtmp (bool);
 
   /**
    * Specifies whether to close the session automatically when the terminal
    * process terminates.
    */
-  void setAutoClose(bool b) { _autoClose = b; }
+  void setAutoClose (bool b)
+  {
+    _autoClose = b;
+  }
 
   /** Returns true if the user has started a program in the session. */
-  bool isForegroundProcessActive();
+  bool isForegroundProcessActive ();
 
   /** Returns the name of the current foreground process. */
-  QString foregroundProcessName();
+  QString foregroundProcessName ();
 
   /** Returns the terminal session's window size in lines and columns. */
-  QSize size();
+  QSize size ();
   /**
    * Emits a request to resize the session to accommodate
    * the specified window size.
    *
    * @param size The size in lines and columns to request.
    */
-  void setSize(const QSize& size);
+  void setSize (const QSize & size);
 
   /**
    * Sets whether the session has a dark background or not.  The session
    * uses this information to set the COLORFGBG variable in the process's
    * environment, which allows the programs running in the terminal to determine
    * whether the background is light or dark and use appropriate colors by default.
    *
    * This has no effect once the session is running.
    */
-  void setDarkBackground(bool darkBackground);
+  void setDarkBackground (bool darkBackground);
   /**
    * Returns true if the session has a dark background.
    * See setDarkBackground()
    */
-  bool hasDarkBackground() const;
+  bool hasDarkBackground () const;
 
   /**
    * Attempts to get the shell program to redraw the current display area.
    * This can be used after clearing the screen, for example, to get the
    * shell to redraw the prompt line.
    */
-  void refresh();
+  void refresh ();
 
   //  void startZModem(const QString &rz, const QString &dir, const QStringList &list);
   //  void cancelZModem();
   //  bool isZModemBusy() { return _zmodemBusy; }
 
  /** 
    * Possible values of the @p what parameter for setUserTitle()
    * See "Operating System Controls" section on http://rtfm.etla.org/xterm/ctlseq.html 
    */
   enum UserTitleChange
   {
-      IconNameAndWindowTitle     = 0,
-    IconName                 = 1,
-    WindowTitle                = 2,
-    TextColor                = 10,
-    BackgroundColor            = 11,
-    SessionName                = 30,
-    ProfileChange            = 50     // this clashes with Xterm's font change command
+    IconNameAndWindowTitle = 0,
+    IconName = 1,
+    WindowTitle = 2,
+    TextColor = 10,
+    BackgroundColor = 11,
+    SessionName = 30,
+    ProfileChange = 50		// this clashes with Xterm's font change command
   };
 
   // Sets the text codec used by this sessions terminal emulation.
-  void setCodec(QTextCodec* codec);
+  void setCodec (QTextCodec * codec);
 
   // session management
   //void saveSession(KConfigGroup& group);
   //void restoreSession(KConfigGroup& group);
 
-public slots:
-
+  public slots:
   /**
    * Starts the terminal session.
    *
    * This creates the terminal process and connects the teletype to it.
    */
-  void run();
+  void run ();
 
   /**
    * Returns the environment of this session as a list of strings like
    * VARIABLE=VALUE
    */
-  Q_SCRIPTABLE QStringList environment() const;
+  Q_SCRIPTABLE QStringList environment () const;
 
   /**
    * Sets the environment for this session.
    * @p environment should be a list of strings like
    * VARIABLE=VALUE
    */
-  Q_SCRIPTABLE void setEnvironment(const QStringList& environment);
+  Q_SCRIPTABLE void setEnvironment (const QStringList & environment);
 
   /**
    * Closes the terminal session.  This sends a hangup signal
    * (SIGHUP) to the terminal process and causes the finished()  
    * signal to be emitted.  If the process does not respond to the SIGHUP signal
    * then the terminal connection (the pty) is closed and Konsole waits for the 
    * process to exit.
    */
-  Q_SCRIPTABLE void close();
+  Q_SCRIPTABLE void close ();
 
   /**
    * Changes the session title or other customizable aspects of the terminal
    * emulation display. For a list of what may be changed see the
    * Emulation::titleChanged() signal.
    *
    * @param what The feature being changed.  Value is one of UserTitleChange
    * @param caption The text part of the terminal command
    */
-  void setUserTitle( int what , const QString &caption );
+  void setUserTitle (int what, const QString & caption);
 
   /**
    * Enables monitoring for activity in the session.
    * This will cause notifySessionState() to be emitted
    * with the NOTIFYACTIVITY state flag when output is
    * received from the terminal.
    */
-  Q_SCRIPTABLE void setMonitorActivity(bool);
+  Q_SCRIPTABLE void setMonitorActivity (bool);
 
   /** Returns true if monitoring for activity is enabled. */
-  Q_SCRIPTABLE bool isMonitorActivity() const;
+  Q_SCRIPTABLE bool isMonitorActivity () const;
 
   /**
    * Enables monitoring for silence in the session.
    * This will cause notifySessionState() to be emitted
    * with the NOTIFYSILENCE state flag when output is not
    * received from the terminal for a certain period of
    * time, specified with setMonitorSilenceSeconds()
    */
-  Q_SCRIPTABLE void setMonitorSilence(bool);
+  Q_SCRIPTABLE void setMonitorSilence (bool);
 
   /**
    * Returns true if monitoring for inactivity (silence)
    * in the session is enabled.
    */
-  Q_SCRIPTABLE bool isMonitorSilence() const;
+  Q_SCRIPTABLE bool isMonitorSilence () const;
 
   /** See setMonitorSilence() */
-  Q_SCRIPTABLE void setMonitorSilenceSeconds(int seconds);
+  Q_SCRIPTABLE void setMonitorSilenceSeconds (int seconds);
 
   /**
    * Sets whether flow control is enabled for this terminal
    * session.
    */
-  Q_SCRIPTABLE void setFlowControlEnabled(bool enabled);
+  Q_SCRIPTABLE void setFlowControlEnabled (bool enabled);
 
   /** Returns whether flow control is enabled for this terminal session. */
-  Q_SCRIPTABLE bool flowControlEnabled() const;
+  Q_SCRIPTABLE bool flowControlEnabled () const;
 
   /**
    * Sends @p text to the current foreground terminal program.
    */
-  Q_SCRIPTABLE void sendText(const QString& text) const;
+  Q_SCRIPTABLE void sendText (const QString & text) const;
 
    /**
     * Sends a mouse event of type @p eventType emitted by button
     * @p buttons on @p column/@p line to the current foreground
     * terminal program
     */
-   Q_SCRIPTABLE void sendMouseEvent(int buttons, int column, int line, int eventType);
+  Q_SCRIPTABLE void sendMouseEvent (int buttons, int column, int line,
+				    int eventType);
 
    /**
    * Returns the process id of the terminal process.
    * This is the id used by the system API to refer to the process.
    */
-  Q_SCRIPTABLE int processId() const;
+  Q_SCRIPTABLE int processId () const;
 
   /**
    * Returns the process id of the terminal's foreground process.
    * This is initially the same as processId() but can change
    * as the user starts other programs inside the terminal.
    */
-  Q_SCRIPTABLE int foregroundProcessId();
+  Q_SCRIPTABLE int foregroundProcessId ();
 
   /** Sets the text codec used by this sessions terminal emulation.
     * Overloaded to accept a QByteArray for convenience since DBus
     * does not accept QTextCodec directky.
     */
-  Q_SCRIPTABLE bool setCodec(QByteArray codec);
+  Q_SCRIPTABLE bool setCodec (QByteArray codec);
 
   /** Returns the codec used to decode incoming characters in this
    * terminal emulation
    */
-  Q_SCRIPTABLE QByteArray codec();
+  Q_SCRIPTABLE QByteArray codec ();
 
   /** Sets the session's title for the specified @p role to @p title.
    *  This is an overloaded member function for setTitle(TitleRole, QString)
    *  provided for convenience since enum data types may not be
    *  exported directly through DBus
    */
-  Q_SCRIPTABLE void setTitle(int role, const QString& title);
+  Q_SCRIPTABLE void setTitle (int role, const QString & title);
 
   /** Returns the session's title for the specified @p role.
    * This is an overloaded member function for  setTitle(TitleRole)
    * provided for convenience since enum data types may not be
    * exported directly through DBus
    */
-  Q_SCRIPTABLE QString title(int role) const;
+  Q_SCRIPTABLE QString title (int role) const;
 
   /** Returns the "friendly" version of the QUuid of this session.
   * This is a QUuid with the braces and dashes removed, so it cannot be
   * used to construct a new QUuid. The same text appears in the
   * SHELL_SESSION_ID environment variable.
   */
-  Q_SCRIPTABLE QString shellSessionId() const;
+  Q_SCRIPTABLE QString shellSessionId () const;
 
   /** Sets the session's tab title format for the specified @p context to @p format.
    *  This is an overloaded member function for setTabTitleFormat(TabTitleContext, QString)
    *  provided for convenience since enum data types may not be
    *  exported directly through DBus
    */
-  Q_SCRIPTABLE void setTabTitleFormat(int context, const QString& format);
+  Q_SCRIPTABLE void setTabTitleFormat (int context, const QString & format);
 
   /** Returns the session's tab title format for the specified @p context.
    * This is an overloaded member function for tabTitleFormat(TitleRole)
    * provided for convenience since enum data types may not be
    * exported directly through DBus
    */
-  Q_SCRIPTABLE QString tabTitleFormat(int context) const;
+  Q_SCRIPTABLE QString tabTitleFormat (int context) const;
 
 signals:
 
   /** Emitted when the terminal process starts. */
-  void started();
+  void started ();
 
   /**
    * Emitted when the terminal process exits.
    */
-  void finished();
+  void finished ();
 
   /**
    * Emitted when output is received from the terminal process.
    */
-  void receivedData( const QString& text );
+  void receivedData (const QString & text);
 
   /** Emitted when the session's title has changed. */
-  void titleChanged();
+  void titleChanged ();
 
   /**
    * Emitted when the activity state of this session changes.
    *
    * @param state The new state of the session.  This may be one
    * of NOTIFYNORMAL, NOTIFYSILENCE or NOTIFYACTIVITY
    */
-  void stateChanged(int state);
+  void stateChanged (int state);
 
   /** Emitted when a bell event occurs in the session. */
-  void bellRequest( const QString& message );
+  void bellRequest (const QString & message);
 
   /**
    * Requests that the color the text for any tabs associated with
    * this session should be changed;
    *
    * TODO: Document what the parameter does
    */
-  void changeTabTextColorRequest(int);
+  void changeTabTextColorRequest (int);
 
   /**
    * Requests that the background color of views on this session
    * should be changed.
    */
-  void changeBackgroundColorRequest(const QColor&);
+  void changeBackgroundColorRequest (const QColor &);
   /** 
    * Requests that the text color of views on this session should
    * be changed to @p color.
    */
-  void changeForegroundColorRequest(const QColor&);
+  void changeForegroundColorRequest (const QColor &);
 
   /** TODO: Document me. */
-  void openUrlRequest(const QString& url);
+  void openUrlRequest (const QString & url);
 
 
   /**
    * Emitted when the terminal process requests a change
    * in the size of the terminal window.
    *
    * @param size The requested window size in terms of lines and columns.
    */
-  void resizeRequest(const QSize& size);
+  void resizeRequest (const QSize & size);
 
   /**
    * Emitted when a profile change command is received from the terminal.
    *
    * @param text The text of the command.  This is a string of the form
    * "PropertyName=Value;PropertyName=Value ..."
    */
-  void profileChangeCommandReceived(const QString& text);
+  void profileChangeCommandReceived (const QString & text);
 
  /**
   * Emitted when the flow control state changes.
   *
   * @param enabled True if flow control is enabled or false otherwise.
   */
-  void flowControlEnabledChanged(bool enabled);
+  void flowControlEnabledChanged (bool enabled);
 
-private slots:
-  void done(int);
+  private slots:void done (int);
 
   //  void fireZModemDetected();
 
-  void onReceiveBlock( const char* buffer, int len );
-  void monitorTimerDone();
+  void onReceiveBlock (const char *buffer, int len);
+  void monitorTimerDone ();
 
-  void onViewSizeChange(int height, int width);
+  void onViewSizeChange (int height, int width);
 
-  void activityStateSet(int);
+  void activityStateSet (int);
 
   //automatically detach views from sessions when view is destroyed
-  void viewDestroyed(QObject* view);
+  void viewDestroyed (QObject * view);
 
   //void zmodemReadStatus();
   //void zmodemReadAndSendBlock();
   //void zmodemRcvBlock(const char *data, int len);
   //void zmodemFinished();
 
-  void updateFlowControlState(bool suspended);
-  void updateWindowSize(int lines, int columns);
+  void updateFlowControlState (bool suspended);
+  void updateWindowSize (int lines, int columns);
 private:
 
-  void updateTerminalSize();
-  WId windowId() const;
-  bool kill(int signal);
+  void updateTerminalSize ();
+  WId windowId () const;
+  bool kill (int signal);
   // print a warning message in the terminal.  This is used
   // if the program fails to start, or if the shell exits in 
   // an unsuccessful manner
-  void terminalWarning(const QString& message);
+  void terminalWarning (const QString & message);
   // checks that the binary 'program' is available and can be executed
   // returns the binary name if available or an empty string otherwise
-  QString checkProgram(const QString& program) const;
-  ProcessInfo* getProcessInfo();
-  void updateSessionProcessInfo();
-  bool updateForegroundProcessInfo();
-  ProcessInfo* updateWorkingDirectory();
+  QString checkProgram (const QString & program) const;
+  ProcessInfo *getProcessInfo ();
+  void updateSessionProcessInfo ();
+  bool updateForegroundProcessInfo ();
+  ProcessInfo *updateWorkingDirectory ();
 
-  QUuid            _uniqueIdentifier; // SHELL_SESSION_ID
+  QUuid _uniqueIdentifier;	// SHELL_SESSION_ID
 
-  Pty*          _shellProcess;
-  Emulation*    _emulation;
+  Pty *_shellProcess;
+  Emulation *_emulation;
 
-  QList<TerminalDisplay*> _views;
+  QList < TerminalDisplay * >_views;
 
-  bool           _monitorActivity;
-  bool           _monitorSilence;
-  bool           _notifiedActivity;
-  bool           _masterMode;
-  bool           _autoClose;
-  bool           _wantedClose;
-  QTimer*        _monitorTimer;
+  bool _monitorActivity;
+  bool _monitorSilence;
+  bool _notifiedActivity;
+  bool _masterMode;
+  bool _autoClose;
+  bool _wantedClose;
+  QTimer *_monitorTimer;
 
-  int            _silenceSeconds;
+  int _silenceSeconds;
 
-  QString        _nameTitle;
-  QString        _displayTitle;
-  QString        _userTitle;
+  QString _nameTitle;
+  QString _displayTitle;
+  QString _userTitle;
 
-  QString        _localTabTitleFormat;
-  QString        _remoteTabTitleFormat;
+  QString _localTabTitleFormat;
+  QString _remoteTabTitleFormat;
 
-  QString        _iconName;
-  QString        _iconText; // as set by: echo -en '\033]1;IconText\007
-  bool           _addToUtmp;
-  bool           _flowControl;
-  bool           _fullScripting;
+  QString _iconName;
+  QString _iconText;		// as set by: echo -en '\033]1;IconText\007
+  bool _addToUtmp;
+  bool _flowControl;
+  bool _fullScripting;
 
-  QString        _program;
-  QStringList    _arguments;
+  QString _program;
+  QStringList _arguments;
 
-  QStringList    _environment;
-  int            _sessionId;
+  QStringList _environment;
+  int _sessionId;
 
-  QString        _initialWorkingDir;
-  QString        _currentWorkingDir;
+  QString _initialWorkingDir;
+  QString _currentWorkingDir;
 
-  ProcessInfo*   _sessionProcessInfo;
-  ProcessInfo*   _foregroundProcessInfo;
-  int            _foregroundPid;
+  ProcessInfo *_sessionProcessInfo;
+  ProcessInfo *_foregroundProcessInfo;
+  int _foregroundPid;
 
   // ZModem
   //  bool           _zmodemBusy;
   //  KProcess*      _zmodemProc;
   //  ZModemDialog*  _zmodemProgress;
 
   // Color/Font Changes by ESC Sequences
 
-  QColor         _modifiedBackground; // as set by: echo -en '\033]11;Color\007
+  QColor _modifiedBackground;	// as set by: echo -en '\033]11;Color\007
 
-  QString        _profileKey;
+  QString _profileKey;
 
   bool _hasDarkBackground;
 
   static int lastSessionId;
 
 };
 
 /**
  * Provides a group of sessions which is divided into master and slave sessions.
  * Activity in master sessions can be propagated to all sessions within the group.
  * The type of activity which is propagated and method of propagation is controlled
  * by the masterMode() flags.
  */
-class SessionGroup : public QObject
+class SessionGroup:public QObject
 {
-Q_OBJECT
-
-public:
+Q_OBJECT public:
     /** Constructs an empty session group. */
-    SessionGroup(QObject* parent);
+  SessionGroup (QObject * parent);
     /** Destroys the session group and removes all connections between master and slave sessions. */
-    ~SessionGroup();
+  ~SessionGroup ();
 
     /** Adds a session to the group. */
-    void addSession( Session* session );
+  void addSession (Session * session);
     /** Removes a session from the group. */
-    void removeSession( Session* session );
+  void removeSession (Session * session);
 
     /** Returns the list of sessions currently in the group. */
-    QList<Session*> sessions() const;
+    QList < Session * >sessions () const;
 
     /**
      * Sets whether a particular session is a master within the group.
      * Changes or activity in the group's master sessions may be propagated
      * to all the sessions in the group, depending on the current masterMode()
      *
      * @param session The session whoose master status should be changed.
      * @param master True to make this session a master or false otherwise
      */
-    void setMasterStatus( Session* session , bool master );
+  void setMasterStatus (Session * session, bool master);
     /** Returns the master status of a session.  See setMasterStatus() */
-    bool masterStatus( Session* session ) const;
+  bool masterStatus (Session * session) const;
 
     /**
      * This enum describes the options for propagating certain activity or
      * changes in the group's master sessions to all sessions in the group.
      */
-    enum MasterMode
-    {
-        /**
+  enum MasterMode
+  {
+	/**
          * Any input key presses in the master sessions are sent to all
          * sessions in the group.
          */
-        CopyInputToAll = 1
-    };
+    CopyInputToAll = 1
+  };
 
     /**
      * Specifies which activity in the group's master sessions is propagated
      * to all sessions in the group.
      *
      * @param mode A bitwise OR of MasterMode flags.
      */
-    void setMasterMode( int mode );
+  void setMasterMode (int mode);
     /**
      * Returns a bitwise OR of the active MasterMode flags for this group.
      * See setMasterMode()
      */
-    int masterMode() const;
+  int masterMode () const;
 
-private slots:
-    void sessionFinished();
-    void forwardData(const char* data, int size);
+  private slots:void sessionFinished ();
+  void forwardData (const char *data, int size);
 
 private:
-    QList<Session*> masters() const;
+    QList < Session * >masters () const;
 
-    // maps sessions to their master status
-    QHash<Session*,bool> _sessions;
+  // maps sessions to their master status
+    QHash < Session *, bool > _sessions;
 
-    int _masterMode;
+  int _masterMode;
 };
 
 #endif
 
 /*
   Local Variables:
   mode: c++
   c-file-style: "stroustrup"
diff --git a/gui/src/terminal/ShellCommand.cpp b/gui/src/terminal/ShellCommand.cpp
--- a/gui/src/terminal/ShellCommand.cpp
+++ b/gui/src/terminal/ShellCommand.cpp
@@ -22,144 +22,166 @@
 // Own
 #include "ShellCommand.h"
 
 //some versions of gcc(4.3) require explicit include
 #include <cstdlib>
 
 // expands environment variables in 'text'
 // function copied from kdelibs/kio/kio/kurlcompletion.cpp
-static bool expandEnv(QString& text);
+static bool expandEnv (QString & text);
 
-ShellCommand::ShellCommand(const QString& fullCommand)
+ShellCommand::ShellCommand (const QString & fullCommand)
 {
-    bool inQuotes = false;
+  bool inQuotes = false;
 
-    QString builder;
+  QString builder;
 
-    for ( int i = 0 ; i < fullCommand.count() ; i++ )
+  for (int i = 0; i < fullCommand.count (); i++)
     {
-        QChar ch = fullCommand[i];
+      QChar ch = fullCommand[i];
 
-        const bool isLastChar = ( i == fullCommand.count() - 1 );
-        const bool isQuote = ( ch == '\'' || ch == '\"' );
+      const bool isLastChar = (i == fullCommand.count () - 1);
+      const bool isQuote = (ch == '\'' || ch == '\"');
 
-        if ( !isLastChar && isQuote )
-            inQuotes = !inQuotes;
-        else
-        { 
-            if ( (!ch.isSpace() || inQuotes) && !isQuote )
-                builder.append(ch);
+      if (!isLastChar && isQuote)
+	inQuotes = !inQuotes;
+      else
+	{
+	  if ((!ch.isSpace () || inQuotes) && !isQuote)
+	    builder.append (ch);
 
-            if ( (ch.isSpace() && !inQuotes) || ( i == fullCommand.count()-1 ) )
-            {
-                _arguments << builder;      
-                builder.clear(); 
-            }
-        }
+	  if ((ch.isSpace () && !inQuotes) || (i == fullCommand.count () - 1))
+	    {
+	      _arguments << builder;
+	      builder.clear ();
+	    }
+	}
     }
 }
-ShellCommand::ShellCommand(const QString& command , const QStringList& arguments)
+
+ShellCommand::ShellCommand (const QString & command,
+			    const QStringList & arguments)
 {
-    _arguments = arguments;
-    
-    if ( !_arguments.isEmpty() )
-        _arguments[0] == command;
+  _arguments = arguments;
+
+  if (!_arguments.isEmpty ())
+    _arguments[0] == command;
 }
-QString ShellCommand::fullCommand() const
+
+QString
+ShellCommand::fullCommand () const
 {
-    return _arguments.join(QChar(' '));
+  return _arguments.join (QChar (' '));
 }
-QString ShellCommand::command() const
+
+QString
+ShellCommand::command () const
 {
-    if ( !_arguments.isEmpty() )
-        return _arguments[0];
-    else
-        return QString();
+  if (!_arguments.isEmpty ())
+    return _arguments[0];
+  else
+    return QString ();
 }
-QStringList ShellCommand::arguments() const
+
+QStringList
+ShellCommand::arguments () const
 {
-    return _arguments;
+  return _arguments;
 }
-bool ShellCommand::isRootCommand() const
+
+bool
+ShellCommand::isRootCommand () const
 {
-    Q_ASSERT(0); // not implemented yet
-    return false;
+  Q_ASSERT (0);			// not implemented yet
+  return false;
 }
-bool ShellCommand::isAvailable() const
-{
-    Q_ASSERT(0); // not implemented yet
-    return false; 
-}
-QStringList ShellCommand::expand(const QStringList& items)
+
+bool
+ShellCommand::isAvailable () const
 {
-    QStringList result;
+  Q_ASSERT (0);			// not implemented yet
+  return false;
+}
 
-    foreach( QString item , items )
-        result << expand(item);
+QStringList
+ShellCommand::expand (const QStringList & items)
+{
+  QStringList result;
 
-    return result;
+  foreach (QString item, items) result << expand (item);
+
+  return result;
 }
-QString ShellCommand::expand(const QString& text)
+
+QString
+ShellCommand::expand (const QString & text)
 {
-    QString result = text;
-    expandEnv(result);
-    return result;
+  QString result = text;
+  expandEnv (result);
+  return result;
 }
 
 /*
  * expandEnv
  *
  * Expand environment variables in text. Escaped '$' characters are ignored.
  * Return true if any variables were expanded
  */
-static bool expandEnv( QString &text )
+static bool
+expandEnv (QString & text)
 {
-	// Find all environment variables beginning with '$'
-	//
-	int pos = 0;
+  // Find all environment variables beginning with '$'
+  //
+  int pos = 0;
 
-	bool expanded = false;
+  bool expanded = false;
 
-	while ( (pos = text.indexOf(QLatin1Char('$'), pos)) != -1 ) {
+  while ((pos = text.indexOf (QLatin1Char ('$'), pos)) != -1)
+    {
 
-		// Skip escaped '$'
-		//
-		if ( pos > 0 && text.at(pos-1) == QLatin1Char('\\') ) {
-			pos++;
-		}
-		// Variable found => expand
-		//
-		else {
-			// Find the end of the variable = next '/' or ' '
-			//
-			int pos2 = text.indexOf( QLatin1Char(' '), pos+1 );
-			int pos_tmp = text.indexOf( QLatin1Char('/'), pos+1 );
+      // Skip escaped '$'
+      //
+      if (pos > 0 && text.at (pos - 1) == QLatin1Char ('\\'))
+	{
+	  pos++;
+	}
+      // Variable found => expand
+      //
+      else
+	{
+	  // Find the end of the variable = next '/' or ' '
+	  //
+	  int pos2 = text.indexOf (QLatin1Char (' '), pos + 1);
+	  int pos_tmp = text.indexOf (QLatin1Char ('/'), pos + 1);
 
-			if ( pos2 == -1 || (pos_tmp != -1 && pos_tmp < pos2) )
-				pos2 = pos_tmp;
+	  if (pos2 == -1 || (pos_tmp != -1 && pos_tmp < pos2))
+	    pos2 = pos_tmp;
 
-			if ( pos2 == -1 )
-				pos2 = text.length();
+	  if (pos2 == -1)
+	    pos2 = text.length ();
 
-			// Replace if the variable is terminated by '/' or ' '
-			// and defined
-			//
-			if ( pos2 >= 0 ) {
-				int len	= pos2 - pos;
-				QString key	= text.mid( pos+1, len-1);
-				QString value =
-					QString::fromLocal8Bit( ::getenv(key.toLocal8Bit()) );
+	  // Replace if the variable is terminated by '/' or ' '
+	  // and defined
+	  //
+	  if (pos2 >= 0)
+	    {
+	      int len = pos2 - pos;
+	      QString key = text.mid (pos + 1, len - 1);
+	      QString value =
+		QString::fromLocal8Bit (::getenv (key.toLocal8Bit ()));
 
-				if ( !value.isEmpty() ) {
-					expanded = true;
-					text.replace( pos, len, value );
-					pos = pos + value.length();
-				}
-				else {
-					pos = pos2;
-				}
-			}
+	      if (!value.isEmpty ())
+		{
+		  expanded = true;
+		  text.replace (pos, len, value);
+		  pos = pos + value.length ();
 		}
+	      else
+		{
+		  pos = pos2;
+		}
+	    }
 	}
+    }
 
-	return expanded;
+  return expanded;
 }
diff --git a/gui/src/terminal/ShellCommand.h b/gui/src/terminal/ShellCommand.h
--- a/gui/src/terminal/ShellCommand.h
+++ b/gui/src/terminal/ShellCommand.h
@@ -49,40 +49,39 @@
 class ShellCommand
 {
 public:
     /**
      * Constructs a ShellCommand from a command line.
      *
      * @param fullCommand The command line to parse.  
      */
-    ShellCommand(const QString& fullCommand);
+  ShellCommand (const QString & fullCommand);
     /**
      * Constructs a ShellCommand with the specified @p command and @p arguments.
      */
-    ShellCommand(const QString& command , const QStringList& arguments);
+  ShellCommand (const QString & command, const QStringList & arguments);
 
     /** Returns the command. */
-    QString command() const;
+  QString command () const;
     /** Returns the arguments. */
-    QStringList arguments() const;
+  QStringList arguments () const;
 
     /** 
      * Returns the full command line. 
      */
-    QString fullCommand() const;
+  QString fullCommand () const;
 
     /** Returns true if this is a root command. */
-    bool isRootCommand() const;
+  bool isRootCommand () const;
     /** Returns true if the program specified by @p command() exists. */
-    bool isAvailable() const;
+  bool isAvailable () const;
 
     /** Expands environment variables in @p text .*/
-    static QString expand(const QString& text);
+  static QString expand (const QString & text);
 
     /** Expands environment variables in each string in @p list. */
-    static QStringList expand(const QStringList& items);
+  static QStringList expand (const QStringList & items);
 
 private:
-    QStringList _arguments;    
+    QStringList _arguments;
 };
 #endif // SHELLCOMMAND_H
-
diff --git a/gui/src/terminal/TerminalCharacterDecoder.cpp b/gui/src/terminal/TerminalCharacterDecoder.cpp
--- a/gui/src/terminal/TerminalCharacterDecoder.cpp
+++ b/gui/src/terminal/TerminalCharacterDecoder.cpp
@@ -23,225 +23,245 @@
 #include "TerminalCharacterDecoder.h"
 
 // Qt
 #include <QtCore/QTextStream>
 
 // Konsole
 #include "konsole_wcwidth.h"
 
-PlainTextDecoder::PlainTextDecoder()
- : _output(0)
- , _includeTrailingWhitespace(true)
- , _recordLinePositions(false)
+PlainTextDecoder::PlainTextDecoder ():_output (0), _includeTrailingWhitespace (true),
+_recordLinePositions (false)
 {
 
 }
-void PlainTextDecoder::setTrailingWhitespace(bool enable)
+
+void
+PlainTextDecoder::setTrailingWhitespace (bool enable)
 {
-    _includeTrailingWhitespace = enable;
-}
-bool PlainTextDecoder::trailingWhitespace() const
-{
-    return _includeTrailingWhitespace;
+  _includeTrailingWhitespace = enable;
 }
-void PlainTextDecoder::begin(QTextStream* output)
+
+bool
+PlainTextDecoder::trailingWhitespace () const
 {
-   _output = output;
-   if (!_linePositions.isEmpty())
-       _linePositions.clear();
+  return _includeTrailingWhitespace;
 }
-void PlainTextDecoder::end()
+
+void
+PlainTextDecoder::begin (QTextStream * output)
 {
-    _output = 0;
+  _output = output;
+  if (!_linePositions.isEmpty ())
+    _linePositions.clear ();
 }
 
-void PlainTextDecoder::setRecordLinePositions(bool record)
+void
+PlainTextDecoder::end ()
 {
-    _recordLinePositions = record;
+  _output = 0;
 }
-QList<int> PlainTextDecoder::linePositions() const
+
+void
+PlainTextDecoder::setRecordLinePositions (bool record)
 {
-    return _linePositions;
+  _recordLinePositions = record;
 }
-void PlainTextDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
-                             )
+
+QList < int >
+PlainTextDecoder::linePositions () const
 {
-    Q_ASSERT( _output );
+  return _linePositions;
+}
 
-    if (_recordLinePositions && _output->string())
+void
+PlainTextDecoder::decodeLine (const Character * const characters, int count, LineProperty	/*properties */
+  )
+{
+  Q_ASSERT (_output);
+
+  if (_recordLinePositions && _output->string ())
     {
-        int pos = _output->string()->count();
-        _linePositions << pos;
+      int pos = _output->string ()->count ();
+      _linePositions << pos;
     }
 
-    //TODO should we ignore or respect the LINE_WRAPPED line property?
+  //TODO should we ignore or respect the LINE_WRAPPED line property?
 
-    //note:  we build up a QString and send it to the text stream rather writing into the text
-    //stream a character at a time because it is more efficient.
-    //(since QTextStream always deals with QStrings internally anyway)
-    QString plainText;
-    plainText.reserve(count);
-   
-    int outputCount = count;
+  //note:  we build up a QString and send it to the text stream rather writing into the text
+  //stream a character at a time because it is more efficient.
+  //(since QTextStream always deals with QStrings internally anyway)
+  QString plainText;
+  plainText.reserve (count);
 
-    // if inclusion of trailing whitespace is disabled then find the end of the
-    // line
-    if ( !_includeTrailingWhitespace )
+  int outputCount = count;
+
+  // if inclusion of trailing whitespace is disabled then find the end of the
+  // line
+  if (!_includeTrailingWhitespace)
     {
-        for (int i = count-1 ; i >= 0 ; i--)
-        {
-            if ( characters[i].character != ' '  )
-                break;
-            else
-                outputCount--;
-        }
+      for (int i = count - 1; i >= 0; i--)
+	{
+	  if (characters[i].character != ' ')
+	    break;
+	  else
+	    outputCount--;
+	}
     }
-    
-    for (int i=0;i<outputCount;)
+
+  for (int i = 0; i < outputCount;)
     {
-        plainText.append( QChar(characters[i].character) );
-        i += qMax(1,konsole_wcwidth(characters[i].character));
+      plainText.append (QChar (characters[i].character));
+      i += qMax (1, konsole_wcwidth (characters[i].character));
     }
-    *_output << plainText;
+  *_output << plainText;
 }
 
-HTMLDecoder::HTMLDecoder() :
-        _output(0)
-    ,_colorTable(base_color_table)
-       ,_innerSpanOpen(false)
-       ,_lastRendition(DEFAULT_RENDITION)
+HTMLDecoder::HTMLDecoder ():
+_output (0), _colorTable (base_color_table), _innerSpanOpen (false),
+_lastRendition (DEFAULT_RENDITION)
 {
-    
+
 }
 
-void HTMLDecoder::begin(QTextStream* output)
+void
+HTMLDecoder::begin (QTextStream * output)
 {
-    _output = output;
+  _output = output;
 
-    QString text;
+  QString text;
 
-    //open monospace span
-    openSpan(text,"font-family:monospace");
+  //open monospace span
+  openSpan (text, "font-family:monospace");
 
-    *output << text;
+  *output << text;
 }
 
-void HTMLDecoder::end()
+void
+HTMLDecoder::end ()
 {
-    Q_ASSERT( _output );
-
-    QString text;
+  Q_ASSERT (_output);
 
-    closeSpan(text);
+  QString text;
+
+  closeSpan (text);
 
-    *_output << text;
+  *_output << text;
 
-    _output = 0;
+  _output = 0;
 
 }
 
 //TODO: Support for LineProperty (mainly double width , double height)
-void HTMLDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
-                            )
+void
+HTMLDecoder::decodeLine (const Character * const characters, int count, LineProperty	/*properties */
+  )
 {
-    Q_ASSERT( _output );
+  Q_ASSERT (_output);
 
-    QString text;
+  QString text;
+
+  int spaceCount = 0;
 
-    int spaceCount = 0;
-        
-    for (int i=0;i<count;i++)
+  for (int i = 0; i < count; i++)
     {
-        QChar ch(characters[i].character);
+      QChar ch (characters[i].character);
 
-        //check if appearance of character is different from previous char
-        if ( characters[i].rendition != _lastRendition  ||
-             characters[i].foregroundColor != _lastForeColor  ||
-             characters[i].backgroundColor != _lastBackColor )
-        {
-            if ( _innerSpanOpen )
-                    closeSpan(text);
+      //check if appearance of character is different from previous char
+      if (characters[i].rendition != _lastRendition ||
+	  characters[i].foregroundColor != _lastForeColor ||
+	  characters[i].backgroundColor != _lastBackColor)
+	{
+	  if (_innerSpanOpen)
+	    closeSpan (text);
+
+	  _lastRendition = characters[i].rendition;
+	  _lastForeColor = characters[i].foregroundColor;
+	  _lastBackColor = characters[i].backgroundColor;
 
-            _lastRendition = characters[i].rendition;
-            _lastForeColor = characters[i].foregroundColor;
-            _lastBackColor = characters[i].backgroundColor;
-            
-            //build up style string
-            QString style;
+	  //build up style string
+	  QString style;
 
-            bool useBold;
-            ColorEntry::FontWeight weight = characters[i].fontWeight(_colorTable);
-            if (weight == ColorEntry::UseCurrentFormat)
-                useBold = _lastRendition & RE_BOLD;
-            else
-                useBold = weight == ColorEntry::Bold;
-            
-            if (useBold)
-                style.append("font-weight:bold;");
+	  bool useBold;
+	  ColorEntry::FontWeight weight =
+	    characters[i].fontWeight (_colorTable);
+	  if (weight == ColorEntry::UseCurrentFormat)
+	    useBold = _lastRendition & RE_BOLD;
+	  else
+	    useBold = weight == ColorEntry::Bold;
+
+	  if (useBold)
+	    style.append ("font-weight:bold;");
+
+	  if (_lastRendition & RE_UNDERLINE)
+	    style.append ("font-decoration:underline;");
 
-            if ( _lastRendition & RE_UNDERLINE )
-                    style.append("font-decoration:underline;");
-        
-            //colours - a colour table must have been defined first
-            if ( _colorTable )    
-            {
-                style.append( QString("color:%1;").arg(_lastForeColor.color(_colorTable).name() ) );
+	  //colours - a colour table must have been defined first
+	  if (_colorTable)
+	    {
+	      style.append (QString ("color:%1;").
+			    arg (_lastForeColor.color (_colorTable).name ()));
 
-                if (!characters[i].isTransparent(_colorTable))
-                {
-                    style.append( QString("background-color:%1;").arg(_lastBackColor.color(_colorTable).name() ) );
-                }
-            }
-        
-            //open the span with the current style    
-            openSpan(text,style);
-            _innerSpanOpen = true;
-        }
+	      if (!characters[i].isTransparent (_colorTable))
+		{
+		  style.append (QString ("background-color:%1;").
+				arg (_lastBackColor.color (_colorTable).
+				     name ()));
+		}
+	    }
+
+	  //open the span with the current style    
+	  openSpan (text, style);
+	  _innerSpanOpen = true;
+	}
 
-        //handle whitespace
-        if (ch.isSpace())
-            spaceCount++;
-        else
-            spaceCount = 0;
-        
+      //handle whitespace
+      if (ch.isSpace ())
+	spaceCount++;
+      else
+	spaceCount = 0;
+
 
-        //output current character
-        if (spaceCount < 2)
-        {
-            //escape HTML tag characters and just display others as they are
-            if ( ch == '<' )
-                text.append("&lt;");
-            else if (ch == '>')
-                    text.append("&gt;");
-            else    
-                    text.append(ch);
-        }
-        else
-        {
-            text.append("&nbsp;"); //HTML truncates multiple spaces, so use a space marker instead
-        }
-        
+      //output current character
+      if (spaceCount < 2)
+	{
+	  //escape HTML tag characters and just display others as they are
+	  if (ch == '<')
+	    text.append ("&lt;");
+	  else if (ch == '>')
+	    text.append ("&gt;");
+	  else
+	    text.append (ch);
+	}
+      else
+	{
+	  text.append ("&nbsp;");	//HTML truncates multiple spaces, so use a space marker instead
+	}
+
     }
 
-    //close any remaining open inner spans
-    if ( _innerSpanOpen )
-        closeSpan(text);
+  //close any remaining open inner spans
+  if (_innerSpanOpen)
+    closeSpan (text);
 
-    //start new line
-    text.append("<br>");
-    
-    *_output << text;
-}
-void HTMLDecoder::openSpan(QString& text , const QString& style)
-{
-    text.append( QString("<span style=\"%1\">").arg(style) );
+  //start new line
+  text.append ("<br>");
+
+  *_output << text;
 }
 
-void HTMLDecoder::closeSpan(QString& text)
+void
+HTMLDecoder::openSpan (QString & text, const QString & style)
 {
-    text.append("</span>");
+  text.append (QString ("<span style=\"%1\">").arg (style));
 }
 
-void HTMLDecoder::setColorTable(const ColorEntry* table)
+void
+HTMLDecoder::closeSpan (QString & text)
 {
-    _colorTable = table;
+  text.append ("</span>");
 }
+
+void
+HTMLDecoder::setColorTable (const ColorEntry * table)
+{
+  _colorTable = table;
+}
diff --git a/gui/src/terminal/TerminalCharacterDecoder.h b/gui/src/terminal/TerminalCharacterDecoder.h
--- a/gui/src/terminal/TerminalCharacterDecoder.h
+++ b/gui/src/terminal/TerminalCharacterDecoder.h
@@ -35,111 +35,110 @@ class QTextStream;
  * and background colours and other appearance-related properties into text strings.
  *
  * Derived classes may produce either plain text with no other colour or appearance information, or
  * they may produce text which incorporates these additional properties. 
  */
 class TerminalCharacterDecoder
 {
 public:
-    virtual ~TerminalCharacterDecoder() {}
+  virtual ~ TerminalCharacterDecoder ()
+  {
+  }
 
     /** Begin decoding characters.  The resulting text is appended to @p output. */
-    virtual void begin(QTextStream* output) = 0;
+  virtual void begin (QTextStream * output) = 0;
     /** End decoding. */
-    virtual void end() = 0;
+  virtual void end () = 0;
 
     /**
      * Converts a line of terminal characters with associated properties into a text string
      * and writes the string into an output QTextStream.
      *
      * @param characters An array of characters of length @p count.
      * @param count The number of characters
      * @param properties Additional properties which affect all characters in the line
      */
-    virtual void decodeLine(const Character* const characters, 
-                            int count,
-                            LineProperty properties) = 0; 
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties) = 0;
 };
 
 /**
  * A terminal character decoder which produces plain text, ignoring colours and other appearance-related
  * properties of the original characters.
  */
-class PlainTextDecoder : public TerminalCharacterDecoder
+class PlainTextDecoder:public TerminalCharacterDecoder
 {
 public:
-    PlainTextDecoder(); 
+  PlainTextDecoder ();
 
     /** 
      * Set whether trailing whitespace at the end of lines should be included 
      * in the output.
      * Defaults to true.
      */
-    void setTrailingWhitespace(bool enable);
+  void setTrailingWhitespace (bool enable);
     /**
      * Returns whether trailing whitespace at the end of lines is included
      * in the output.
      */
-    bool trailingWhitespace() const;
+  bool trailingWhitespace () const;
     /** 
      * Returns of character positions in the output stream
      * at which new lines where added.  Returns an empty if setTrackLinePositions() is false or if 
      * the output device is not a string.
      */
-    QList<int> linePositions() const;
+    QList < int >linePositions () const;
     /** Enables recording of character positions at which new lines are added.  See linePositions() */
-    void setRecordLinePositions(bool record);
+  void setRecordLinePositions (bool record);
 
-    virtual void begin(QTextStream* output);
-    virtual void end();
+  virtual void begin (QTextStream * output);
+  virtual void end ();
 
-    virtual void decodeLine(const Character* const characters,
-                            int count,
-                            LineProperty properties);    
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties);
 
-    
+
 private:
-    QTextStream* _output;
-    bool _includeTrailingWhitespace;
+    QTextStream * _output;
+  bool _includeTrailingWhitespace;
 
-    bool _recordLinePositions;
-    QList<int> _linePositions;
+  bool _recordLinePositions;
+    QList < int >_linePositions;
 };
 
 /**
  * A terminal character decoder which produces pretty HTML markup
  */
-class HTMLDecoder : public TerminalCharacterDecoder
+class HTMLDecoder:public TerminalCharacterDecoder
 {
 public:
     /** 
      * Constructs an HTML decoder using a default black-on-white color scheme.
      */
-    HTMLDecoder();
+  HTMLDecoder ();
 
     /**
      * Sets the colour table which the decoder uses to produce the HTML colour codes in its
      * output
      */
-    void setColorTable( const ColorEntry* table );
-        
-    virtual void decodeLine(const Character* const characters,
-                            int count,
-                            LineProperty properties);
+  void setColorTable (const ColorEntry * table);
 
-    virtual void begin(QTextStream* output);
-    virtual void end();
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties);
+
+  virtual void begin (QTextStream * output);
+  virtual void end ();
 
 private:
-    void openSpan(QString& text , const QString& style);
-    void closeSpan(QString& text);
+  void openSpan (QString & text, const QString & style);
+  void closeSpan (QString & text);
 
-    QTextStream* _output;
-    const ColorEntry* _colorTable;
-    bool _innerSpanOpen; 
-    quint8 _lastRendition;
-    CharacterColor _lastForeColor;
-    CharacterColor _lastBackColor;
+  QTextStream *_output;
+  const ColorEntry *_colorTable;
+  bool _innerSpanOpen;
+  quint8 _lastRendition;
+  CharacterColor _lastForeColor;
+  CharacterColor _lastBackColor;
 
 };
 
 #endif
diff --git a/gui/src/terminal/TerminalDisplay.cpp b/gui/src/terminal/TerminalDisplay.cpp
--- a/gui/src/terminal/TerminalDisplay.cpp
+++ b/gui/src/terminal/TerminalDisplay.cpp
@@ -57,108 +57,128 @@
     "abcdefgjijklmnopqrstuvwxyz" \
     "0123456789./+@"
 
 const ColorEntry base_color_table[TABLE_COLORS] =
 // The following are almost IBM standard color codes, with some slight
 // gamma correction for the dim colors to compensate for bright X screens.
 // It contains the 8 ansiterm/xterm colors in 2 intensities.
 {
-    // Fixme: could add faint colors here, also.
-    // normal
-    ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xB2,0xB2,0xB2), 1), // Dfore, Dback
-            ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xB2,0x18,0x18), 0), // Black, Red
-            ColorEntry(QColor(0x18,0xB2,0x18), 0), ColorEntry( QColor(0xB2,0x68,0x18), 0), // Green, Yellow
-            ColorEntry(QColor(0x18,0x18,0xB2), 0), ColorEntry( QColor(0xB2,0x18,0xB2), 0), // Blue, Magenta
-            ColorEntry(QColor(0x18,0xB2,0xB2), 0), ColorEntry( QColor(0xB2,0xB2,0xB2), 0), // Cyan, White
-            // intensiv
-            ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xFF,0xFF,0xFF), 1),
-            ColorEntry(QColor(0x68,0x68,0x68), 0), ColorEntry( QColor(0xFF,0x54,0x54), 0),
-            ColorEntry(QColor(0x54,0xFF,0x54), 0), ColorEntry( QColor(0xFF,0xFF,0x54), 0),
-            ColorEntry(QColor(0x54,0x54,0xFF), 0), ColorEntry( QColor(0xFF,0x54,0xFF), 0),
-            ColorEntry(QColor(0x54,0xFF,0xFF), 0), ColorEntry( QColor(0xFF,0xFF,0xFF), 0)
+  // Fixme: could add faint colors here, also.
+  // normal
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 1),	// Dfore, Dback
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0), ColorEntry (QColor (0xB2, 0x18, 0x18), 0),	// Black, Red
+  ColorEntry (QColor (0x18, 0xB2, 0x18), 0), ColorEntry (QColor (0xB2, 0x68, 0x18), 0),	// Green, Yellow
+  ColorEntry (QColor (0x18, 0x18, 0xB2), 0), ColorEntry (QColor (0xB2, 0x18, 0xB2), 0),	// Blue, Magenta
+  ColorEntry (QColor (0x18, 0xB2, 0xB2), 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 0),	// Cyan, White
+  // intensiv
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 1),
+  ColorEntry (QColor (0x68, 0x68, 0x68), 0),
+    ColorEntry (QColor (0xFF, 0x54, 0x54), 0),
+  ColorEntry (QColor (0x54, 0xFF, 0x54), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0x54), 0),
+  ColorEntry (QColor (0x54, 0x54, 0xFF), 0),
+    ColorEntry (QColor (0xFF, 0x54, 0xFF), 0),
+  ColorEntry (QColor (0x54, 0xFF, 0xFF), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0)
 };
 
 // scroll increment used when dragging selection at top/bottom of window.
 
 // static
-bool TerminalDisplay::_antialiasText = true;
-bool TerminalDisplay::HAVE_TRANSPARENCY = false;
+bool
+  TerminalDisplay::_antialiasText = true;
+bool
+  TerminalDisplay::HAVE_TRANSPARENCY = false;
 
 // we use this to force QPainter to display text in LTR mode
 // more information can be found in: http://unicode.org/reports/tr9/ 
-const QChar LTR_OVERRIDE_CHAR( 0x202D );
+const QChar
+LTR_OVERRIDE_CHAR (0x202D);
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Colors                                     */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 /* Note that we use ANSI color order (bgr), while IBMPC color order is (rgb)
 
    Code        0       1       2       3       4       5       6       7
    ----------- ------- ------- ------- ------- ------- ------- ------- -------
    ANSI  (bgr) Black   Red     Green   Yellow  Blue    Magenta Cyan    White
    IBMPC (rgb) Black   Blue    Green   Cyan    Red     Magenta Yellow  White
 */
 
-ScreenWindow* TerminalDisplay::screenWindow() const
+ScreenWindow *
+TerminalDisplay::screenWindow () const
 {
-    return _screenWindow;
+  return _screenWindow;
 }
-void TerminalDisplay::setScreenWindow(ScreenWindow* window)
+
+void
+TerminalDisplay::setScreenWindow (ScreenWindow * window)
 {
-    // disconnect existing screen window if any
-    if ( _screenWindow )
+  // disconnect existing screen window if any
+  if (_screenWindow)
     {
-        disconnect( _screenWindow , 0 , this , 0 );
+      disconnect (_screenWindow, 0, this, 0);
     }
 
-    _screenWindow = window;
-
-    if ( window )
+  _screenWindow = window;
+
+  if (window)
     {
 
-        // TODO: Determine if this is an issue.
-        //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
-        connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateLineProperties()) );
-        connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateImage()) );
-        window->setWindowLines(_lines);
+      // TODO: Determine if this is an issue.
+      //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
+      connect (_screenWindow, SIGNAL (outputChanged ()), this,
+	       SLOT (updateLineProperties ()));
+      connect (_screenWindow, SIGNAL (outputChanged ()), this,
+	       SLOT (updateImage ()));
+      window->setWindowLines (_lines);
     }
 }
 
-const ColorEntry* TerminalDisplay::colorTable() const
+const ColorEntry *
+TerminalDisplay::colorTable () const
 {
-    return _colorTable;
+  return _colorTable;
 }
-void TerminalDisplay::setBackgroundColor(const QColor& color)
+
+void
+TerminalDisplay::setBackgroundColor (const QColor & color)
 {
-    _colorTable[DEFAULT_BACK_COLOR].color = color;
-    QPalette p = palette();
-    p.setColor( backgroundRole(), color );
-    setPalette( p );
-
-    // Avoid propagating the palette change to the scroll bar
-    _scrollBar->setPalette( QApplication::palette() );
-
-    update();
+  _colorTable[DEFAULT_BACK_COLOR].color = color;
+  QPalette p = palette ();
+  p.setColor (backgroundRole (), color);
+  setPalette (p);
+
+  // Avoid propagating the palette change to the scroll bar
+  _scrollBar->setPalette (QApplication::palette ());
+
+  update ();
 }
-void TerminalDisplay::setForegroundColor(const QColor& color)
+
+void
+TerminalDisplay::setForegroundColor (const QColor & color)
 {
-    _colorTable[DEFAULT_FORE_COLOR].color = color;
-
-    update();
+  _colorTable[DEFAULT_FORE_COLOR].color = color;
+
+  update ();
 }
-void TerminalDisplay::setColorTable(const ColorEntry table[])
+
+void
+TerminalDisplay::setColorTable (const ColorEntry table[])
 {
-    for (int i = 0; i < TABLE_COLORS; i++)
-        _colorTable[i] = table[i];
-
-    setBackgroundColor(_colorTable[DEFAULT_BACK_COLOR].color);
+  for (int i = 0; i < TABLE_COLORS; i++)
+    _colorTable[i] = table[i];
+
+  setBackgroundColor (_colorTable[DEFAULT_BACK_COLOR].color);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                   Font                                    */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
@@ -169,215 +189,196 @@ void TerminalDisplay::setColorTable(cons
    QT's iso mapping leaves 0x00..0x7f without any changes. But the graphicals
    come in here as proper unicode characters.
 
    We treat non-iso10646 fonts as VT100 extended and do the requiered mapping
    from unicode to 0x00..0x1f. The remaining translation is then left to the
    QCodec.
 */
 
-static inline bool isLineChar(quint16 c) { return ((c & 0xFF80) == 0x2500);}
-static inline bool isLineCharString(const QString& string)
+static inline bool
+isLineChar (quint16 c)
 {
-    return (string.length() > 0) && (isLineChar(string.at(0).unicode()));
+  return ((c & 0xFF80) == 0x2500);
+}
+
+static inline bool
+isLineCharString (const QString & string)
+{
+  return (string.length () > 0) && (isLineChar (string.at (0).unicode ()));
 }
 
 
 // assert for i in [0..31] : vt100extended(vt100_graphics[i]) == i.
 
-unsigned short vt100_graphics[32] =
-{ // 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
+unsigned short vt100_graphics[32] = {	// 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
   0x0020, 0x25C6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0,
   0x00b1, 0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c,
   0xF800, 0xF801, 0x2500, 0xF803, 0xF804, 0x251c, 0x2524, 0x2534,
   0x252c, 0x2502, 0x2264, 0x2265, 0x03C0, 0x2260, 0x00A3, 0x00b7
 };
 
-void TerminalDisplay::fontChange(const QFont&)
+void
+TerminalDisplay::fontChange (const QFont &)
 {
-    QFontMetrics fm(font());
-    _fontHeight = fm.height() + _lineSpacing;
-
-    // waba TerminalDisplay 1.123:
-    // "Base character width on widest ASCII character. This prevents too wide
-    //  characters in the presence of double wide (e.g. Japanese) characters."
-    // Get the width from representative normal width characters
-    _fontWidth = qRound((double)fm.width(REPCHAR)/(double)strlen(REPCHAR));
-
-    _fixedFont = true;
-
-    int fw = fm.width(REPCHAR[0]);
-    for(unsigned int i=1; i< strlen(REPCHAR); i++)
+  QFontMetrics fm (font ());
+  _fontHeight = fm.height () + _lineSpacing;
+
+  // waba TerminalDisplay 1.123:
+  // "Base character width on widest ASCII character. This prevents too wide
+  //  characters in the presence of double wide (e.g. Japanese) characters."
+  // Get the width from representative normal width characters
+  _fontWidth =
+    qRound ((double) fm.width (REPCHAR) / (double) strlen (REPCHAR));
+
+  _fixedFont = true;
+
+  int fw = fm.width (REPCHAR[0]);
+  for (unsigned int i = 1; i < strlen (REPCHAR); i++)
     {
-        if (fw != fm.width(REPCHAR[i]))
-        {
-            _fixedFont = false;
-            break;
-        }
+      if (fw != fm.width (REPCHAR[i]))
+	{
+	  _fixedFont = false;
+	  break;
+	}
     }
 
-    if (_fontWidth < 1)
-        _fontWidth=1;
-
-    _fontAscent = fm.ascent();
-
-    emit changedFontMetricSignal( _fontHeight, _fontWidth );
-    propagateSize();
-    update();
+  if (_fontWidth < 1)
+    _fontWidth = 1;
+
+  _fontAscent = fm.ascent ();
+
+  emit changedFontMetricSignal (_fontHeight, _fontWidth);
+  propagateSize ();
+  update ();
 }
 
-void TerminalDisplay::setVTFont(const QFont& f)
+void
+TerminalDisplay::setVTFont (const QFont & f)
 {
-    QFont font = f;
-
-    QFontMetrics metrics(font);
-
-    if ( !QFontInfo(font).fixedPitch() )
+  QFont font = f;
+
+  QFontMetrics metrics (font);
+
+  if (!QFontInfo (font).fixedPitch ())
     {
-        //kWarning() << "Using an unsupported variable-width font in the terminal.  This may produce display errors.";
+      //kWarning() << "Using an unsupported variable-width font in the terminal.  This may produce display errors.";
     }
 
-    if ( metrics.height() < height() && metrics.maxWidth() < width() )
+  if (metrics.height () < height () && metrics.maxWidth () < width ())
     {
-        // hint that text should be drawn without anti-aliasing.
-        // depending on the user's font configuration, this may not be respected
-        if (!_antialiasText)
-            font.setStyleStrategy( QFont::NoAntialias );
-
-        // experimental optimization.  Konsole assumes that the terminal is using a
-        // mono-spaced font, in which case kerning information should have an effect.
-        // Disabling kerning saves some computation when rendering text.
-        font.setKerning(false);
-
-        QWidget::setFont(font);
-        fontChange(font);
+      // hint that text should be drawn without anti-aliasing.
+      // depending on the user's font configuration, this may not be respected
+      if (!_antialiasText)
+	font.setStyleStrategy (QFont::NoAntialias);
+
+      // experimental optimization.  Konsole assumes that the terminal is using a
+      // mono-spaced font, in which case kerning information should have an effect.
+      // Disabling kerning saves some computation when rendering text.
+      font.setKerning (false);
+
+      QWidget::setFont (font);
+      fontChange (font);
     }
 }
 
-void TerminalDisplay::setFont(const QFont &)
+void
+TerminalDisplay::setFont (const QFont &)
 {
-    // ignore font change request if not coming from konsole itself
+  // ignore font change request if not coming from konsole itself
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                         Constructor / Destructor                          */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
-TerminalDisplay::TerminalDisplay(QWidget *parent)
-    :QWidget(parent)
-    ,_screenWindow(0)
-    ,_allowBell(true)
-    ,_gridLayout(0)
-    ,_fontHeight(1)
-    ,_fontWidth(1)
-    ,_fontAscent(1)
-    ,_boldIntense(true)
-    ,_lines(1)
-    ,_columns(1)
-    ,_usedLines(1)
-    ,_usedColumns(1)
-    ,_contentHeight(1)
-    ,_contentWidth(1)
-    ,_image(0)
-    ,_randomSeed(0)
-    ,_resizing(false)
-    ,_terminalSizeHint(false)
-    ,_terminalSizeStartup(true)
-    ,_bidiEnabled(false)
-    ,_actSel(0)
-    ,_wordSelectionMode(false)
-    ,_lineSelectionMode(false)
-    ,_preserveLineBreaks(false)
-    ,_columnSelectionMode(false)
-    ,_scrollbarLocation(NoScrollBar)
-    ,_wordCharacters(":@-./_~")
-    ,_bellMode(SystemBeepBell)
-    ,_blinking(false)
-    ,_hasBlinker(false)
-    ,_cursorBlinking(false)
-    ,_hasBlinkingCursor(false)
-    ,_allowBlinkingText(true)
-    ,_ctrlDrag(true)
-    ,_tripleClickMode(SelectWholeLine)
-    ,_isFixedSize(false)
-    ,_possibleTripleClick(false)
-    ,_resizeWidget(0)
-    ,_resizeTimer(0)
-    ,_flowControlWarningEnabled(false)
-    ,_outputSuspendedLabel(0)
-    ,_lineSpacing(0)
-    ,_colorsInverted(false)
-    ,_blendColor(qRgba(0,0,0,0xff))
-    ,_filterChain(new TerminalImageFilterChain())
-    ,_cursorShape(BlockCursor)
+TerminalDisplay::TerminalDisplay (QWidget * parent):QWidget (parent), _screenWindow (0), _allowBell (true), _gridLayout (0),
+_fontHeight (1), _fontWidth (1), _fontAscent (1), _boldIntense (true),
+_lines (1), _columns (1), _usedLines (1), _usedColumns (1),
+_contentHeight (1), _contentWidth (1), _image (0), _randomSeed (0),
+_resizing (false), _terminalSizeHint (false), _terminalSizeStartup (true),
+_bidiEnabled (false), _actSel (0), _wordSelectionMode (false),
+_lineSelectionMode (false), _preserveLineBreaks (false),
+_columnSelectionMode (false), _scrollbarLocation (NoScrollBar),
+_wordCharacters (":@-./_~"), _bellMode (SystemBeepBell), _blinking (false),
+_hasBlinker (false), _cursorBlinking (false), _hasBlinkingCursor (false),
+_allowBlinkingText (true), _ctrlDrag (true),
+_tripleClickMode (SelectWholeLine), _isFixedSize (false),
+_possibleTripleClick (false), _resizeWidget (0), _resizeTimer (0),
+_flowControlWarningEnabled (false), _outputSuspendedLabel (0),
+_lineSpacing (0), _colorsInverted (false),
+_blendColor (qRgba (0, 0, 0, 0xff)),
+_filterChain (new TerminalImageFilterChain ()), _cursorShape (BlockCursor)
 {
-    // terminal applications are not designed with Right-To-Left in mind,
-    // so the layout is forced to Left-To-Right
-    setLayoutDirection(Qt::LeftToRight);
-
-    // The offsets are not yet calculated.
-    // Do not calculate these too often to be more smoothly when resizing
-    // konsole in opaque mode.
-    _topMargin = DEFAULT_TOP_MARGIN;
-    _leftMargin = DEFAULT_LEFT_MARGIN;
-
-    // create scroll bar for scrolling output up and down
-    // set the scroll bar's slider to occupy the whole area of the scroll bar initially
-    _scrollBar = new QScrollBar(this);
-    setScroll(0,0);
-    _scrollBar->setCursor( Qt::ArrowCursor );
-    connect(_scrollBar, SIGNAL(valueChanged(int)), this,
-            SLOT(scrollBarPositionChanged(int)));
-
-    // setup timers for blinking cursor and text
-    _blinkTimer   = new QTimer(this);
-    connect(_blinkTimer, SIGNAL(timeout()), this, SLOT(blinkEvent()));
-    _blinkCursorTimer   = new QTimer(this);
-    connect(_blinkCursorTimer, SIGNAL(timeout()), this, SLOT(blinkCursorEvent()));
-
-    //KCursor::setAutoHideCursor( this, true );
-
-    setUsesMouse(true);
-    setColorTable(base_color_table);
-    setMouseTracking(true);
-
-    // Enable drag and drop
-    setAcceptDrops(true); // attempt
-    dragInfo.state = diNone;
-
-    setFocusPolicy( Qt::WheelFocus );
-
-    // enable input method support
-    setAttribute(Qt::WA_InputMethodEnabled, true);
-
-    // this is an important optimization, it tells Qt
-    // that TerminalDisplay will handle repainting its entire area.
-    setAttribute(Qt::WA_OpaquePaintEvent);
-
-    _gridLayout = new QGridLayout(this);
-    _gridLayout->setContentsMargins(0, 0, 0, 0);
-
-    setLayout( _gridLayout );
-
-    new AutoScrollHandler(this);
+  // terminal applications are not designed with Right-To-Left in mind,
+  // so the layout is forced to Left-To-Right
+  setLayoutDirection (Qt::LeftToRight);
+
+  // The offsets are not yet calculated.
+  // Do not calculate these too often to be more smoothly when resizing
+  // konsole in opaque mode.
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _leftMargin = DEFAULT_LEFT_MARGIN;
+
+  // create scroll bar for scrolling output up and down
+  // set the scroll bar's slider to occupy the whole area of the scroll bar initially
+  _scrollBar = new QScrollBar (this);
+  setScroll (0, 0);
+  _scrollBar->setCursor (Qt::ArrowCursor);
+  connect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	   SLOT (scrollBarPositionChanged (int)));
+
+  // setup timers for blinking cursor and text
+  _blinkTimer = new QTimer (this);
+  connect (_blinkTimer, SIGNAL (timeout ()), this, SLOT (blinkEvent ()));
+  _blinkCursorTimer = new QTimer (this);
+  connect (_blinkCursorTimer, SIGNAL (timeout ()), this,
+	   SLOT (blinkCursorEvent ()));
+
+  //KCursor::setAutoHideCursor( this, true );
+
+  setUsesMouse (true);
+  setColorTable (base_color_table);
+  setMouseTracking (true);
+
+  // Enable drag and drop
+  setAcceptDrops (true);	// attempt
+  dragInfo.state = diNone;
+
+  setFocusPolicy (Qt::WheelFocus);
+
+  // enable input method support
+  setAttribute (Qt::WA_InputMethodEnabled, true);
+
+  // this is an important optimization, it tells Qt
+  // that TerminalDisplay will handle repainting its entire area.
+  setAttribute (Qt::WA_OpaquePaintEvent);
+
+  _gridLayout = new QGridLayout (this);
+  _gridLayout->setContentsMargins (0, 0, 0, 0);
+
+  setLayout (_gridLayout);
+
+  new
+  AutoScrollHandler (this);
 }
 
-TerminalDisplay::~TerminalDisplay()
+TerminalDisplay::~TerminalDisplay ()
 {
-    disconnect(_blinkTimer);
-    disconnect(_blinkCursorTimer);
-    qApp->removeEventFilter( this );
-
-    delete[] _image;
-
-    delete _gridLayout;
-    delete _outputSuspendedLabel;
-    delete _filterChain;
+  disconnect (_blinkTimer);
+  disconnect (_blinkCursorTimer);
+  qApp->removeEventFilter (this);
+
+  delete[]_image;
+
+  delete _gridLayout;
+  delete _outputSuspendedLabel;
+  delete _filterChain;
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                             Display Operations                            */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
@@ -397,2580 +398,2847 @@ TerminalDisplay::~TerminalDisplay()
 where _ = none
       | = vertical line.
       - = horizontal line.
  */
 
 
 enum LineEncode
 {
-    TopL  = (1<<1),
-    TopC  = (1<<2),
-    TopR  = (1<<3),
-
-    LeftT = (1<<5),
-    Int11 = (1<<6),
-    Int12 = (1<<7),
-    Int13 = (1<<8),
-    RightT = (1<<9),
-
-    LeftC = (1<<10),
-    Int21 = (1<<11),
-    Int22 = (1<<12),
-    Int23 = (1<<13),
-    RightC = (1<<14),
-
-    LeftB = (1<<15),
-    Int31 = (1<<16),
-    Int32 = (1<<17),
-    Int33 = (1<<18),
-    RightB = (1<<19),
-
-    BotL  = (1<<21),
-    BotC  = (1<<22),
-    BotR  = (1<<23)
+  TopL = (1 << 1),
+  TopC = (1 << 2),
+  TopR = (1 << 3),
+
+  LeftT = (1 << 5),
+  Int11 = (1 << 6),
+  Int12 = (1 << 7),
+  Int13 = (1 << 8),
+  RightT = (1 << 9),
+
+  LeftC = (1 << 10),
+  Int21 = (1 << 11),
+  Int22 = (1 << 12),
+  Int23 = (1 << 13),
+  RightC = (1 << 14),
+
+  LeftB = (1 << 15),
+  Int31 = (1 << 16),
+  Int32 = (1 << 17),
+  Int33 = (1 << 18),
+  RightB = (1 << 19),
+
+  BotL = (1 << 21),
+  BotC = (1 << 22),
+  BotR = (1 << 23)
 };
 
 #include "LineFont.h"
 
-static void drawLineChar(QPainter& paint, int x, int y, int w, int h, uchar code)
+static void
+drawLineChar (QPainter & paint, int x, int y, int w, int h, uchar code)
 {
-    //Calculate cell midpoints, end points.
-    int cx = x + w/2;
-    int cy = y + h/2;
-    int ex = x + w - 1;
-    int ey = y + h - 1;
-
-    quint32 toDraw = LineChars[code];
-
-    //Top _lines:
-    if (toDraw & TopL)
-        paint.drawLine(cx-1, y, cx-1, cy-2);
-    if (toDraw & TopC)
-        paint.drawLine(cx, y, cx, cy-2);
-    if (toDraw & TopR)
-        paint.drawLine(cx+1, y, cx+1, cy-2);
-
-    //Bot _lines:
-    if (toDraw & BotL)
-        paint.drawLine(cx-1, cy+2, cx-1, ey);
-    if (toDraw & BotC)
-        paint.drawLine(cx, cy+2, cx, ey);
-    if (toDraw & BotR)
-        paint.drawLine(cx+1, cy+2, cx+1, ey);
-
-    //Left _lines:
-    if (toDraw & LeftT)
-        paint.drawLine(x, cy-1, cx-2, cy-1);
-    if (toDraw & LeftC)
-        paint.drawLine(x, cy, cx-2, cy);
-    if (toDraw & LeftB)
-        paint.drawLine(x, cy+1, cx-2, cy+1);
-
-    //Right _lines:
-    if (toDraw & RightT)
-        paint.drawLine(cx+2, cy-1, ex, cy-1);
-    if (toDraw & RightC)
-        paint.drawLine(cx+2, cy, ex, cy);
-    if (toDraw & RightB)
-        paint.drawLine(cx+2, cy+1, ex, cy+1);
-
-    //Intersection points.
-    if (toDraw & Int11)
-        paint.drawPoint(cx-1, cy-1);
-    if (toDraw & Int12)
-        paint.drawPoint(cx, cy-1);
-    if (toDraw & Int13)
-        paint.drawPoint(cx+1, cy-1);
-
-    if (toDraw & Int21)
-        paint.drawPoint(cx-1, cy);
-    if (toDraw & Int22)
-        paint.drawPoint(cx, cy);
-    if (toDraw & Int23)
-        paint.drawPoint(cx+1, cy);
-
-    if (toDraw & Int31)
-        paint.drawPoint(cx-1, cy+1);
-    if (toDraw & Int32)
-        paint.drawPoint(cx, cy+1);
-    if (toDraw & Int33)
-        paint.drawPoint(cx+1, cy+1);
+  //Calculate cell midpoints, end points.
+  int cx = x + w / 2;
+  int cy = y + h / 2;
+  int ex = x + w - 1;
+  int ey = y + h - 1;
+
+  quint32 toDraw = LineChars[code];
+
+  //Top _lines:
+  if (toDraw & TopL)
+    paint.drawLine (cx - 1, y, cx - 1, cy - 2);
+  if (toDraw & TopC)
+    paint.drawLine (cx, y, cx, cy - 2);
+  if (toDraw & TopR)
+    paint.drawLine (cx + 1, y, cx + 1, cy - 2);
+
+  //Bot _lines:
+  if (toDraw & BotL)
+    paint.drawLine (cx - 1, cy + 2, cx - 1, ey);
+  if (toDraw & BotC)
+    paint.drawLine (cx, cy + 2, cx, ey);
+  if (toDraw & BotR)
+    paint.drawLine (cx + 1, cy + 2, cx + 1, ey);
+
+  //Left _lines:
+  if (toDraw & LeftT)
+    paint.drawLine (x, cy - 1, cx - 2, cy - 1);
+  if (toDraw & LeftC)
+    paint.drawLine (x, cy, cx - 2, cy);
+  if (toDraw & LeftB)
+    paint.drawLine (x, cy + 1, cx - 2, cy + 1);
+
+  //Right _lines:
+  if (toDraw & RightT)
+    paint.drawLine (cx + 2, cy - 1, ex, cy - 1);
+  if (toDraw & RightC)
+    paint.drawLine (cx + 2, cy, ex, cy);
+  if (toDraw & RightB)
+    paint.drawLine (cx + 2, cy + 1, ex, cy + 1);
+
+  //Intersection points.
+  if (toDraw & Int11)
+    paint.drawPoint (cx - 1, cy - 1);
+  if (toDraw & Int12)
+    paint.drawPoint (cx, cy - 1);
+  if (toDraw & Int13)
+    paint.drawPoint (cx + 1, cy - 1);
+
+  if (toDraw & Int21)
+    paint.drawPoint (cx - 1, cy);
+  if (toDraw & Int22)
+    paint.drawPoint (cx, cy);
+  if (toDraw & Int23)
+    paint.drawPoint (cx + 1, cy);
+
+  if (toDraw & Int31)
+    paint.drawPoint (cx - 1, cy + 1);
+  if (toDraw & Int32)
+    paint.drawPoint (cx, cy + 1);
+  if (toDraw & Int33)
+    paint.drawPoint (cx + 1, cy + 1);
 
 }
 
-void TerminalDisplay::drawLineCharString(    QPainter& painter, int x, int y, const QString& str, 
-                                         const Character* attributes)
+void
+TerminalDisplay::drawLineCharString (QPainter & painter, int x, int y,
+				     const QString & str,
+				     const Character * attributes)
 {
-    const QPen& currentPen = painter.pen();
-
-    if ( (attributes->rendition & RE_BOLD) && _boldIntense )
-    {
-        QPen boldPen(currentPen);
-        boldPen.setWidth(3);
-        painter.setPen( boldPen );
-    }
-
-    for (int i=0 ; i < str.length(); i++)
+  const QPen & currentPen = painter.pen ();
+
+  if ((attributes->rendition & RE_BOLD) && _boldIntense)
     {
-        uchar code = str[i].cell();
-        if (LineChars[code])
-            drawLineChar(painter, x + (_fontWidth*i), y, _fontWidth, _fontHeight, code);
+      QPen boldPen (currentPen);
+      boldPen.setWidth (3);
+      painter.setPen (boldPen);
     }
 
-    painter.setPen( currentPen );
+  for (int i = 0; i < str.length (); i++)
+    {
+      uchar code = str[i].cell ();
+      if (LineChars[code])
+	drawLineChar (painter, x + (_fontWidth * i), y, _fontWidth,
+		      _fontHeight, code);
+    }
+
+  painter.setPen (currentPen);
 }
 
-void TerminalDisplay::setKeyboardCursorShape(KeyboardCursorShape shape)
-{
-    _cursorShape = shape;
-}
-TerminalDisplay::KeyboardCursorShape TerminalDisplay::keyboardCursorShape() const
-{
-    return _cursorShape;
-}
-void TerminalDisplay::setKeyboardCursorColor(bool useForegroundColor, const QColor& color)
+void
+TerminalDisplay::setKeyboardCursorShape (KeyboardCursorShape shape)
 {
-    if (useForegroundColor)
-        _cursorColor = QColor(); // an invalid color means that
-    // the foreground color of the
-    // current character should
-    // be used
-
-    else
-        _cursorColor = color;
+  _cursorShape = shape;
 }
-QColor TerminalDisplay::keyboardCursorColor() const
+
+TerminalDisplay::KeyboardCursorShape TerminalDisplay::keyboardCursorShape () const
 {
-    return _cursorColor;
+  return _cursorShape;
 }
 
-void TerminalDisplay::setOpacity(qreal opacity)
+void
+TerminalDisplay::setKeyboardCursorColor (bool useForegroundColor,
+					 const QColor & color)
 {
-    QColor color(_blendColor);
-    color.setAlphaF(opacity);
-
-    // enable automatic background filling to prevent the display
-    // flickering if there is no transparency
-    /*if ( color.alpha() == 255 ) 
-    {
-        setAutoFillBackground(true);
-    }
-    else
-    {
-        setAutoFillBackground(false);
-    }*/
-
-    _blendColor = color.rgba();
+  if (useForegroundColor)
+    _cursorColor = QColor ();	// an invalid color means that
+  // the foreground color of the
+  // current character should
+  // be used
+
+  else
+    _cursorColor = color;
 }
 
-void TerminalDisplay::drawBackground(QPainter& painter, const QRect& rect, const QColor& backgroundColor, bool useOpacitySetting )
+QColor
+TerminalDisplay::keyboardCursorColor () const
+{
+  return _cursorColor;
+}
+
+void
+TerminalDisplay::setOpacity (qreal opacity)
 {
-    // the area of the widget showing the contents of the terminal display is drawn
-    // using the background color from the color scheme set with setColorTable()
-    //
-    // the area of the widget behind the scroll-bar is drawn using the background
-    // brush from the scroll-bar's palette, to give the effect of the scroll-bar
-    // being outside of the terminal display and visual consistency with other KDE
-    // applications.
-    //
-    QRect scrollBarArea = _scrollBar->isVisible() ?
-                rect.intersected(_scrollBar->geometry()) :
-                QRect();
-    QRegion contentsRegion = QRegion(rect).subtracted(scrollBarArea);
-    QRect contentsRect = contentsRegion.boundingRect();
-
-    if ( HAVE_TRANSPARENCY && qAlpha(_blendColor) < 0xff && useOpacitySetting )
-    {
-        QColor color(backgroundColor);
-        color.setAlpha(qAlpha(_blendColor));
-
-        painter.save();
-        painter.setCompositionMode(QPainter::CompositionMode_Source);
-        painter.fillRect(contentsRect, color);
-        painter.restore();
-    }
-    else
-        painter.fillRect(contentsRect, backgroundColor);
-
-    painter.fillRect(scrollBarArea,_scrollBar->palette().background());
+  QColor color (_blendColor);
+  color.setAlphaF (opacity);
+
+  // enable automatic background filling to prevent the display
+  // flickering if there is no transparency
+  /*if ( color.alpha() == 255 ) 
+     {
+     setAutoFillBackground(true);
+     }
+     else
+     {
+     setAutoFillBackground(false);
+     } */
+
+  _blendColor = color.rgba ();
 }
 
-void TerminalDisplay::drawCursor(QPainter& painter, 
-                                 const QRect& rect,
-                                 const QColor& foregroundColor,
-                                 const QColor& /*backgroundColor*/,
-                                 bool& invertCharacterColor)
+void
+TerminalDisplay::drawBackground (QPainter & painter, const QRect & rect,
+				 const QColor & backgroundColor,
+				 bool useOpacitySetting)
 {
-    QRect cursorRect = rect;
-    cursorRect.setHeight(_fontHeight - _lineSpacing - 1);
-    
-    if (!_cursorBlinking)
+  // the area of the widget showing the contents of the terminal display is drawn
+  // using the background color from the color scheme set with setColorTable()
+  //
+  // the area of the widget behind the scroll-bar is drawn using the background
+  // brush from the scroll-bar's palette, to give the effect of the scroll-bar
+  // being outside of the terminal display and visual consistency with other KDE
+  // applications.
+  //
+  QRect scrollBarArea = _scrollBar->isVisible ()?
+    rect.intersected (_scrollBar->geometry ()) : QRect ();
+  QRegion contentsRegion = QRegion (rect).subtracted (scrollBarArea);
+  QRect contentsRect = contentsRegion.boundingRect ();
+
+  if (HAVE_TRANSPARENCY && qAlpha (_blendColor) < 0xff && useOpacitySetting)
     {
-        if ( _cursorColor.isValid() )
-            painter.setPen(_cursorColor);
-        else
-            painter.setPen(foregroundColor);
-
-        if ( _cursorShape == BlockCursor )
-        {
-            // draw the cursor outline, adjusting the area so that
-            // it is draw entirely inside 'rect'
-            int penWidth = qMax(1,painter.pen().width());
-
-            painter.drawRect(cursorRect.adjusted(penWidth/2,
-                                                 penWidth/2,
-                                                 - penWidth/2 - penWidth%2,
-                                                 - penWidth/2 - penWidth%2));
-            if ( hasFocus() )
-            {
-                painter.fillRect(cursorRect, _cursorColor.isValid() ? _cursorColor : foregroundColor);
-
-                if ( !_cursorColor.isValid() )
-                {
-                    // invert the colour used to draw the text to ensure that the character at
-                    // the cursor position is readable
-                    invertCharacterColor = true;
-                }
-            }
-        }
-        else if ( _cursorShape == UnderlineCursor )
-            painter.drawLine(cursorRect.left(),
-                             cursorRect.bottom(),
-                             cursorRect.right(),
-                             cursorRect.bottom());
-        else if ( _cursorShape == IBeamCursor )
-            painter.drawLine(cursorRect.left(),
-                             cursorRect.top(),
-                             cursorRect.left(),
-                             cursorRect.bottom());
+      QColor color (backgroundColor);
+      color.setAlpha (qAlpha (_blendColor));
+
+      painter.save ();
+      painter.setCompositionMode (QPainter::CompositionMode_Source);
+      painter.fillRect (contentsRect, color);
+      painter.restore ();
+    }
+  else
+    painter.fillRect (contentsRect, backgroundColor);
+
+  painter.fillRect (scrollBarArea, _scrollBar->palette ().background ());
+}
+
+void
+TerminalDisplay::drawCursor (QPainter & painter,
+			     const QRect & rect,
+			     const QColor & foregroundColor,
+			     const QColor & /*backgroundColor */ ,
+			     bool & invertCharacterColor)
+{
+  QRect cursorRect = rect;
+  cursorRect.setHeight (_fontHeight - _lineSpacing - 1);
+
+  if (!_cursorBlinking)
+    {
+      if (_cursorColor.isValid ())
+	painter.setPen (_cursorColor);
+      else
+	painter.setPen (foregroundColor);
+
+      if (_cursorShape == BlockCursor)
+	{
+	  // draw the cursor outline, adjusting the area so that
+	  // it is draw entirely inside 'rect'
+	  int penWidth = qMax (1, painter.pen ().width ());
+
+	  painter.drawRect (cursorRect.adjusted (penWidth / 2,
+						 penWidth / 2,
+						 -penWidth / 2 - penWidth % 2,
+						 -penWidth / 2 -
+						 penWidth % 2));
+	  if (hasFocus ())
+	    {
+	      painter.fillRect (cursorRect,
+				_cursorColor.
+				isValid ()? _cursorColor : foregroundColor);
+
+	      if (!_cursorColor.isValid ())
+		{
+		  // invert the colour used to draw the text to ensure that the character at
+		  // the cursor position is readable
+		  invertCharacterColor = true;
+		}
+	    }
+	}
+      else if (_cursorShape == UnderlineCursor)
+	painter.drawLine (cursorRect.left (),
+			  cursorRect.bottom (),
+			  cursorRect.right (), cursorRect.bottom ());
+      else if (_cursorShape == IBeamCursor)
+	painter.drawLine (cursorRect.left (),
+			  cursorRect.top (),
+			  cursorRect.left (), cursorRect.bottom ());
 
     }
 }
 
-void TerminalDisplay::drawCharacters(QPainter& painter,
-                                     const QRect& rect,
-                                     const QString& text,
-                                     const Character* style,
-                                     bool invertCharacterColor)
+void
+TerminalDisplay::drawCharacters (QPainter & painter,
+				 const QRect & rect,
+				 const QString & text,
+				 const Character * style,
+				 bool invertCharacterColor)
 {
-    // don't draw text which is currently blinking
-    if ( _blinking && (style->rendition & RE_BLINK) )
-        return;
-
-    // setup bold and underline
-    bool useBold;
-    ColorEntry::FontWeight weight = style->fontWeight(_colorTable);    
-    if (weight == ColorEntry::UseCurrentFormat)
-        useBold = ((style->rendition & RE_BOLD) && _boldIntense) || font().bold();
-    else
-        useBold = (weight == ColorEntry::Bold) ? true : false;
-    bool useUnderline = style->rendition & RE_UNDERLINE || font().underline();
-
-    QFont font = painter.font();
-    if (    font.bold() != useBold 
-            || font.underline() != useUnderline )
+  // don't draw text which is currently blinking
+  if (_blinking && (style->rendition & RE_BLINK))
+    return;
+
+  // setup bold and underline
+  bool useBold;
+  ColorEntry::FontWeight weight = style->fontWeight (_colorTable);
+  if (weight == ColorEntry::UseCurrentFormat)
+    useBold = ((style->rendition & RE_BOLD) && _boldIntense)
+      || font ().bold ();
+  else
+    useBold = (weight == ColorEntry::Bold) ? true : false;
+  bool useUnderline = style->rendition & RE_UNDERLINE || font ().underline ();
+
+  QFont font = painter.font ();
+  if (font.bold () != useBold || font.underline () != useUnderline)
     {
-        font.setBold(useBold);
-        font.setUnderline(useUnderline);
-        painter.setFont(font);
+      font.setBold (useBold);
+      font.setUnderline (useUnderline);
+      painter.setFont (font);
     }
 
-    // setup pen
-    const CharacterColor& textColor = ( invertCharacterColor ? style->backgroundColor : style->foregroundColor );
-    const QColor color = textColor.color(_colorTable);
-    QPen pen = painter.pen();
-    if ( pen.color() != color )
+  // setup pen
+  const CharacterColor & textColor =
+    (invertCharacterColor ? style->backgroundColor : style->foregroundColor);
+  const QColor color = textColor.color (_colorTable);
+  QPen pen = painter.pen ();
+  if (pen.color () != color)
     {
-        pen.setColor(color);
-        painter.setPen(color);
+      pen.setColor (color);
+      painter.setPen (color);
     }
 
-    // draw text
-    if ( isLineCharString(text) )
-        drawLineCharString(painter,rect.x(),rect.y(),text,style);
-    else
+  // draw text
+  if (isLineCharString (text))
+    drawLineCharString (painter, rect.x (), rect.y (), text, style);
+  else
     {
-        // the drawText(rect,flags,string) overload is used here with null flags
-        // instead of drawText(rect,string) because the (rect,string) overload causes 
-        // the application's default layout direction to be used instead of 
-        // the widget-specific layout direction, which should always be
-        // Qt::LeftToRight for this widget
-        // This was discussed in: http://lists.kde.org/?t=120552223600002&r=1&w=2
-        if (_bidiEnabled)
-            painter.drawText(rect,0,text);
-        else
-            painter.drawText(rect,0,LTR_OVERRIDE_CHAR+text);
+      // the drawText(rect,flags,string) overload is used here with null flags
+      // instead of drawText(rect,string) because the (rect,string) overload causes 
+      // the application's default layout direction to be used instead of 
+      // the widget-specific layout direction, which should always be
+      // Qt::LeftToRight for this widget
+      // This was discussed in: http://lists.kde.org/?t=120552223600002&r=1&w=2
+      if (_bidiEnabled)
+	painter.drawText (rect, 0, text);
+      else
+	painter.drawText (rect, 0, LTR_OVERRIDE_CHAR + text);
     }
 }
 
-void TerminalDisplay::drawTextFragment(QPainter& painter , 
-                                       const QRect& rect,
-                                       const QString& text, 
-                                       const Character* style)
+void
+TerminalDisplay::drawTextFragment (QPainter & painter,
+				   const QRect & rect,
+				   const QString & text,
+				   const Character * style)
 {
-    painter.save();
-
-    // setup painter 
-    const QColor foregroundColor = style->foregroundColor.color(_colorTable);
-    const QColor backgroundColor = style->backgroundColor.color(_colorTable);
-    
-    // draw background if different from the display's background color
-    if ( backgroundColor != palette().background().color() )
-        drawBackground(painter,rect,backgroundColor,
-                       false /* do not use transparency */);
-
-    // draw cursor shape if the current character is the cursor
-    // this may alter the foreground and background colors
-    bool invertCharacterColor = false;
-    if ( style->rendition & RE_CURSOR )
-        drawCursor(painter,rect,foregroundColor,backgroundColor,invertCharacterColor);
-
-    // draw text
-    drawCharacters(painter,rect,text,style,invertCharacterColor);
-
-    painter.restore();
+  painter.save ();
+
+  // setup painter 
+  const QColor foregroundColor = style->foregroundColor.color (_colorTable);
+  const QColor backgroundColor = style->backgroundColor.color (_colorTable);
+
+  // draw background if different from the display's background color
+  if (backgroundColor != palette ().background ().color ())
+    drawBackground (painter, rect, backgroundColor,
+		    false /* do not use transparency */ );
+
+  // draw cursor shape if the current character is the cursor
+  // this may alter the foreground and background colors
+  bool invertCharacterColor = false;
+  if (style->rendition & RE_CURSOR)
+    drawCursor (painter, rect, foregroundColor, backgroundColor,
+		invertCharacterColor);
+
+  // draw text
+  drawCharacters (painter, rect, text, style, invertCharacterColor);
+
+  painter.restore ();
 }
 
-void TerminalDisplay::setRandomSeed(uint randomSeed) { _randomSeed = randomSeed; }
-uint TerminalDisplay::randomSeed() const { return _randomSeed; }
+void
+TerminalDisplay::setRandomSeed (uint randomSeed)
+{
+  _randomSeed = randomSeed;
+}
+
+uint
+TerminalDisplay::randomSeed () const
+{
+  return _randomSeed;
+}
 
 #if 0
 /*!
     Set XIM Position
 */
-void TerminalDisplay::setCursorPos(const int curx, const int cury)
+void
+TerminalDisplay::setCursorPos (const int curx, const int cury)
 {
-    QPoint tL  = contentsRect().topLeft();
-    int    tLx = tL.x();
-    int    tLy = tL.y();
-
-    int xpos, ypos;
-    ypos = _topMargin + tLy + _fontHeight*(cury-1) + _fontAscent;
-    xpos = _leftMargin + tLx + _fontWidth*curx;
-    _cursorLine = cury;
-    _cursorCol = curx;
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+
+  int xpos, ypos;
+  ypos = _topMargin + tLy + _fontHeight * (cury - 1) + _fontAscent;
+  xpos = _leftMargin + tLx + _fontWidth * curx;
+  _cursorLine = cury;
+  _cursorCol = curx;
 }
 #endif
 
 // scrolls the image by 'lines', down if lines > 0 or up otherwise.
 //
 // the terminal emulation keeps track of the scrolling of the character 
 // image as it receives input, and when the view is updated, it calls scrollImage() 
 // with the final scroll amount.  this improves performance because scrolling the 
 // display is much cheaper than re-rendering all the text for the 
 // part of the image which has moved up or down.  
 // Instead only new lines have to be drawn
-void TerminalDisplay::scrollImage(int lines , const QRect& screenWindowRegion)
+void
+TerminalDisplay::scrollImage (int lines, const QRect & screenWindowRegion)
 {
-    // if the flow control warning is enabled this will interfere with the 
-    // scrolling optimizations and cause artifacts.  the simple solution here
-    // is to just disable the optimization whilst it is visible
-    if ( _outputSuspendedLabel && _outputSuspendedLabel->isVisible() )
-        return;
-
-    // constrain the region to the display
-    // the bottom of the region is capped to the number of lines in the display's
-    // internal image - 2, so that the height of 'region' is strictly less
-    // than the height of the internal image.
-    QRect region = screenWindowRegion;
-    region.setBottom( qMin(region.bottom(),this->_lines-2) ); 
-
-    // return if there is nothing to do
-    if (    lines == 0 
-            || _image == 0
-            || !region.isValid()
-            || (region.top() + abs(lines)) >= region.bottom()
-            || this->_lines <= region.height() ) return;
-
-    // hide terminal size label to prevent it being scrolled
-    if (_resizeWidget && _resizeWidget->isVisible())
-        _resizeWidget->hide();
-
-    // Note:  With Qt 4.4 the left edge of the scrolled area must be at 0
-    // to get the correct (newly exposed) part of the widget repainted.
-    //
-    // The right edge must be before the left edge of the scroll bar to 
-    // avoid triggering a repaint of the entire widget, the distance is 
-    // given by SCROLLBAR_CONTENT_GAP
-    //
-    // Set the QT_FLUSH_PAINT environment variable to '1' before starting the
-    // application to monitor repainting.
-    //
-    int scrollBarWidth = _scrollBar->isHidden() ? 0 : _scrollBar->width();
-    const int SCROLLBAR_CONTENT_GAP = 1;
-    QRect scrollRect;
-    if ( _scrollbarLocation == ScrollBarLeft )
+  // if the flow control warning is enabled this will interfere with the 
+  // scrolling optimizations and cause artifacts.  the simple solution here
+  // is to just disable the optimization whilst it is visible
+  if (_outputSuspendedLabel && _outputSuspendedLabel->isVisible ())
+    return;
+
+  // constrain the region to the display
+  // the bottom of the region is capped to the number of lines in the display's
+  // internal image - 2, so that the height of 'region' is strictly less
+  // than the height of the internal image.
+  QRect region = screenWindowRegion;
+  region.setBottom (qMin (region.bottom (), this->_lines - 2));
+
+  // return if there is nothing to do
+  if (lines == 0
+      || _image == 0
+      || !region.isValid ()
+      || (region.top () + abs (lines)) >= region.bottom ()
+      || this->_lines <= region.height ())
+    return;
+
+  // hide terminal size label to prevent it being scrolled
+  if (_resizeWidget && _resizeWidget->isVisible ())
+    _resizeWidget->hide ();
+
+  // Note:  With Qt 4.4 the left edge of the scrolled area must be at 0
+  // to get the correct (newly exposed) part of the widget repainted.
+  //
+  // The right edge must be before the left edge of the scroll bar to 
+  // avoid triggering a repaint of the entire widget, the distance is 
+  // given by SCROLLBAR_CONTENT_GAP
+  //
+  // Set the QT_FLUSH_PAINT environment variable to '1' before starting the
+  // application to monitor repainting.
+  //
+  int scrollBarWidth = _scrollBar->isHidden ()? 0 : _scrollBar->width ();
+  const int SCROLLBAR_CONTENT_GAP = 1;
+  QRect scrollRect;
+  if (_scrollbarLocation == ScrollBarLeft)
     {
-        scrollRect.setLeft(scrollBarWidth+SCROLLBAR_CONTENT_GAP);
-        scrollRect.setRight(width());
+      scrollRect.setLeft (scrollBarWidth + SCROLLBAR_CONTENT_GAP);
+      scrollRect.setRight (width ());
     }
-    else
+  else
     {
-        scrollRect.setLeft(0);
-        scrollRect.setRight(width() - scrollBarWidth - SCROLLBAR_CONTENT_GAP);
+      scrollRect.setLeft (0);
+      scrollRect.setRight (width () - scrollBarWidth - SCROLLBAR_CONTENT_GAP);
     }
-    void* firstCharPos = &_image[ region.top() * this->_columns ];
-    void* lastCharPos = &_image[ (region.top() + abs(lines)) * this->_columns ];
-
-    int top = _topMargin + (region.top() * _fontHeight);
-    int linesToMove = region.height() - abs(lines);
-    int bytesToMove = linesToMove * 
-            this->_columns *
-            sizeof(Character);
-
-    Q_ASSERT( linesToMove > 0 );
-    Q_ASSERT( bytesToMove > 0 );
-
-    //scroll internal image
-    if ( lines > 0 )
+  void *firstCharPos = &_image[region.top () * this->_columns];
+  void *lastCharPos = &_image[(region.top () + abs (lines)) * this->_columns];
+
+  int top = _topMargin + (region.top () * _fontHeight);
+  int linesToMove = region.height () - abs (lines);
+  int bytesToMove = linesToMove * this->_columns * sizeof (Character);
+
+  Q_ASSERT (linesToMove > 0);
+  Q_ASSERT (bytesToMove > 0);
+
+  //scroll internal image
+  if (lines > 0)
     {
-        // check that the memory areas that we are going to move are valid
-        Q_ASSERT( (char*)lastCharPos + bytesToMove < 
-                 (char*)(_image + (this->_lines * this->_columns)) );
-        
-        Q_ASSERT( (lines*this->_columns) < _imageSize ); 
-
-        //scroll internal image down
-        memmove( firstCharPos , lastCharPos , bytesToMove ); 
-
-        //set region of display to scroll
-        scrollRect.setTop(top);
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT ((char *) lastCharPos + bytesToMove <
+		(char *) (_image + (this->_lines * this->_columns)));
+
+      Q_ASSERT ((lines * this->_columns) < _imageSize);
+
+      //scroll internal image down
+      memmove (firstCharPos, lastCharPos, bytesToMove);
+
+      //set region of display to scroll
+      scrollRect.setTop (top);
     }
-    else
+  else
     {
-        // check that the memory areas that we are going to move are valid
-        Q_ASSERT( (char*)firstCharPos + bytesToMove < 
-                 (char*)(_image + (this->_lines * this->_columns)) );
-
-        //scroll internal image up
-        memmove( lastCharPos , firstCharPos , bytesToMove ); 
-
-        //set region of the display to scroll
-        scrollRect.setTop(top + abs(lines) * _fontHeight); 
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT ((char *) firstCharPos + bytesToMove <
+		(char *) (_image + (this->_lines * this->_columns)));
+
+      //scroll internal image up
+      memmove (lastCharPos, firstCharPos, bytesToMove);
+
+      //set region of the display to scroll
+      scrollRect.setTop (top + abs (lines) * _fontHeight);
     }
-    scrollRect.setHeight(linesToMove * _fontHeight );
-
-    Q_ASSERT(scrollRect.isValid() && !scrollRect.isEmpty());
-
-    //scroll the display vertically to match internal _image
-    scroll( 0 , _fontHeight * (-lines) , scrollRect );
+  scrollRect.setHeight (linesToMove * _fontHeight);
+
+  Q_ASSERT (scrollRect.isValid () && !scrollRect.isEmpty ());
+
+  //scroll the display vertically to match internal _image
+  scroll (0, _fontHeight * (-lines), scrollRect);
 }
 
-QRegion TerminalDisplay::hotSpotRegion() const 
+QRegion
+TerminalDisplay::hotSpotRegion () const
 {
-    QRegion region;
-    foreach( Filter::HotSpot* hotSpot , _filterChain->hotSpots() )
-    {
-        QRect r;
-        if (hotSpot->startLine()==hotSpot->endLine()) {
-            r.setLeft(hotSpot->startColumn());
-            r.setTop(hotSpot->startLine());
-            r.setRight(hotSpot->endColumn());
-            r.setBottom(hotSpot->endLine());
-            region |= imageToWidget(r);;
-        } else {
-            r.setLeft(hotSpot->startColumn());
-            r.setTop(hotSpot->startLine());
-            r.setRight(_columns);
-            r.setBottom(hotSpot->startLine());
-            region |= imageToWidget(r);;
-            for ( int line = hotSpot->startLine()+1 ; line < hotSpot->endLine() ; line++ ) {
-                r.setLeft(0);
-                r.setTop(line);
-                r.setRight(_columns);
-                r.setBottom(line);
-                region |= imageToWidget(r);;
-            }
-            r.setLeft(0);
-            r.setTop(hotSpot->endLine());
-            r.setRight(hotSpot->endColumn());
-            r.setBottom(hotSpot->endLine());
-            region |= imageToWidget(r);;
-        }
-    }
-    return region;
+  QRegion region;
+  foreach (Filter::HotSpot * hotSpot, _filterChain->hotSpots ())
+  {
+    QRect r;
+    if (hotSpot->startLine () == hotSpot->endLine ())
+      {
+	r.setLeft (hotSpot->startColumn ());
+	r.setTop (hotSpot->startLine ());
+	r.setRight (hotSpot->endColumn ());
+	r.setBottom (hotSpot->endLine ());
+	region |= imageToWidget (r);;
+      }
+    else
+      {
+	r.setLeft (hotSpot->startColumn ());
+	r.setTop (hotSpot->startLine ());
+	r.setRight (_columns);
+	r.setBottom (hotSpot->startLine ());
+	region |= imageToWidget (r);;
+	for (int line = hotSpot->startLine () + 1; line < hotSpot->endLine ();
+	     line++)
+	  {
+	    r.setLeft (0);
+	    r.setTop (line);
+	    r.setRight (_columns);
+	    r.setBottom (line);
+	    region |= imageToWidget (r);;
+	  }
+	r.setLeft (0);
+	r.setTop (hotSpot->endLine ());
+	r.setRight (hotSpot->endColumn ());
+	r.setBottom (hotSpot->endLine ());
+	region |= imageToWidget (r);;
+      }
+  }
+  return region;
 }
 
-void TerminalDisplay::processFilters() 
+void
+TerminalDisplay::processFilters ()
 {
-    if (!_screenWindow)
-        return;
-
-    QRegion preUpdateHotSpots = hotSpotRegion();
-
-    // use _screenWindow->getImage() here rather than _image because
-    // other classes may call processFilters() when this display's
-    // ScreenWindow emits a scrolled() signal - which will happen before
-    // updateImage() is called on the display and therefore _image is 
-    // out of date at this point
-    _filterChain->setImage( _screenWindow->getImage(),
-                           _screenWindow->windowLines(),
-                           _screenWindow->windowColumns(),
-                           _screenWindow->getLineProperties() );
-    _filterChain->process();
-
-    QRegion postUpdateHotSpots = hotSpotRegion();
-
-    update( preUpdateHotSpots | postUpdateHotSpots );
+  if (!_screenWindow)
+    return;
+
+  QRegion preUpdateHotSpots = hotSpotRegion ();
+
+  // use _screenWindow->getImage() here rather than _image because
+  // other classes may call processFilters() when this display's
+  // ScreenWindow emits a scrolled() signal - which will happen before
+  // updateImage() is called on the display and therefore _image is 
+  // out of date at this point
+  _filterChain->setImage (_screenWindow->getImage (),
+			  _screenWindow->windowLines (),
+			  _screenWindow->windowColumns (),
+			  _screenWindow->getLineProperties ());
+  _filterChain->process ();
+
+  QRegion postUpdateHotSpots = hotSpotRegion ();
+
+  update (preUpdateHotSpots | postUpdateHotSpots);
 }
 
-void TerminalDisplay::updateImage() 
+void
+TerminalDisplay::updateImage ()
 {
-    if ( !_screenWindow )
-        return;
-
-    // optimization - scroll the existing image where possible and
-    // avoid expensive text drawing for parts of the image that
-    // can simply be moved up or down
-    scrollImage( _screenWindow->scrollCount() ,
-                _screenWindow->scrollRegion() );
-    _screenWindow->resetScrollCount();
-
-    if (!_image) {
-        // Create _image.
-        // The emitted changedContentSizeSignal also leads to getImage being recreated, so do this first.
-        updateImageSize();
+  if (!_screenWindow)
+    return;
+
+  // optimization - scroll the existing image where possible and
+  // avoid expensive text drawing for parts of the image that
+  // can simply be moved up or down
+  scrollImage (_screenWindow->scrollCount (), _screenWindow->scrollRegion ());
+  _screenWindow->resetScrollCount ();
+
+  if (!_image)
+    {
+      // Create _image.
+      // The emitted changedContentSizeSignal also leads to getImage being recreated, so do this first.
+      updateImageSize ();
     }
 
-    Character* const newimg = _screenWindow->getImage();
-    int lines = _screenWindow->windowLines();
-    int columns = _screenWindow->windowColumns();
-
-    setScroll( _screenWindow->currentLine() , _screenWindow->lineCount() );
-
-    Q_ASSERT( this->_usedLines <= this->_lines );
-    Q_ASSERT( this->_usedColumns <= this->_columns );
-
-    int y,x,len;
-
-    QPoint tL  = contentsRect().topLeft();
-    int    tLx = tL.x();
-    int    tLy = tL.y();
-    _hasBlinker = false;
-
-    CharacterColor cf;       // undefined
-    CharacterColor _clipboard;       // undefined
-    int cr  = -1;   // undefined
-
-    const int linesToUpdate = qMin(this->_lines, qMax(0,lines  ));
-    const int columnsToUpdate = qMin(this->_columns,qMax(0,columns));
-
-    QChar *disstrU = new QChar[columnsToUpdate];
-    char *dirtyMask = new char[columnsToUpdate+2];
-    QRegion dirtyRegion;
-
-    // debugging variable, this records the number of lines that are found to
-    // be 'dirty' ( ie. have changed from the old _image to the new _image ) and
-    // which therefore need to be repainted
-    int dirtyLineCount = 0;
-
-    for (y = 0; y < linesToUpdate; ++y)
+  Character *const newimg = _screenWindow->getImage ();
+  int lines = _screenWindow->windowLines ();
+  int columns = _screenWindow->windowColumns ();
+
+  setScroll (_screenWindow->currentLine (), _screenWindow->lineCount ());
+
+  Q_ASSERT (this->_usedLines <= this->_lines);
+  Q_ASSERT (this->_usedColumns <= this->_columns);
+
+  int y, x, len;
+
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+  _hasBlinker = false;
+
+  CharacterColor cf;		// undefined
+  CharacterColor _clipboard;	// undefined
+  int cr = -1;			// undefined
+
+  const int linesToUpdate = qMin (this->_lines, qMax (0, lines));
+  const int columnsToUpdate = qMin (this->_columns, qMax (0, columns));
+
+  QChar *disstrU = new QChar[columnsToUpdate];
+  char *dirtyMask = new char[columnsToUpdate + 2];
+  QRegion dirtyRegion;
+
+  // debugging variable, this records the number of lines that are found to
+  // be 'dirty' ( ie. have changed from the old _image to the new _image ) and
+  // which therefore need to be repainted
+  int dirtyLineCount = 0;
+
+  for (y = 0; y < linesToUpdate; ++y)
     {
-        const Character*       currentLine = &_image[y*this->_columns];
-        const Character* const newLine = &newimg[y*columns];
-
-        bool updateLine = false;
-
-        // The dirty mask indicates which characters need repainting. We also
-        // mark surrounding neighbours dirty, in case the character exceeds
-        // its cell boundaries
-        memset(dirtyMask, 0, columnsToUpdate+2);
-
-        for( x = 0 ; x < columnsToUpdate ; ++x)
-        {
-            if ( newLine[x] != currentLine[x] )
-            {
-                dirtyMask[x] = true;
-            }
-        }
-
-        if (!_resizing) // not while _resizing, we're expecting a paintEvent
-            for (x = 0; x < columnsToUpdate; ++x)
-            {
-                _hasBlinker |= (newLine[x].rendition & RE_BLINK);
-
-                // Start drawing if this character or the next one differs.
-                // We also take the next one into account to handle the situation
-                // where characters exceed their cell width.
-                if (dirtyMask[x])
-                {
-                    quint16 c = newLine[x+0].character;
-                    if ( !c )
-                        continue;
-                    int p = 0;
-                    disstrU[p++] = c; //fontMap(c);
-                    bool lineDraw = isLineChar(c);
-                    bool doubleWidth = (x+1 == columnsToUpdate) ? false : (newLine[x+1].character == 0);
-                    cr = newLine[x].rendition;
-                    _clipboard = newLine[x].backgroundColor;
-                    if (newLine[x].foregroundColor != cf) cf = newLine[x].foregroundColor;
-                    int lln = columnsToUpdate - x;
-                    for (len = 1; len < lln; ++len)
-                    {
-                        const Character& ch = newLine[x+len];
-
-                        if (!ch.character)
-                            continue; // Skip trailing part of multi-col chars.
-
-                        bool nextIsDoubleWidth = (x+len+1 == columnsToUpdate) ? false : (newLine[x+len+1].character == 0);
-
-                        if (  ch.foregroundColor != cf ||
-                                ch.backgroundColor != _clipboard ||
-                                ch.rendition != cr ||
-                                !dirtyMask[x+len] ||
-                                isLineChar(c) != lineDraw ||
-                                nextIsDoubleWidth != doubleWidth )
-                            break;
-
-                        disstrU[p++] = c; //fontMap(c);
-                    }
-
-                    QString unistr(disstrU, p);
-
-                    bool saveFixedFont = _fixedFont;
-                    if (lineDraw)
-                        _fixedFont = false;
-                    if (doubleWidth)
-                        _fixedFont = false;
-
-                    updateLine = true;
-
-                    _fixedFont = saveFixedFont;
-                    x += len - 1;
-                }
-
-            }
-
-        //both the top and bottom halves of double height _lines must always be redrawn
-        //although both top and bottom halves contain the same characters, only
-        //the top one is actually
-        //drawn.
-        if (_lineProperties.count() > y)
-            updateLine |= (_lineProperties[y] & LINE_DOUBLEHEIGHT);
-
-        // if the characters on the line are different in the old and the new _image
-        // then this line must be repainted.
-        if (updateLine)
-        {
-            dirtyLineCount++;
-
-            // add the area occupied by this line to the region which needs to be
-            // repainted
-            QRect dirtyRect = QRect( _leftMargin+tLx ,
-                                    _topMargin+tLy+_fontHeight*y ,
-                                    _fontWidth * columnsToUpdate ,
-                                    _fontHeight );
-
-            dirtyRegion |= dirtyRect;
-        }
-
-        // replace the line of characters in the old _image with the
-        // current line of the new _image
-        memcpy((void*)currentLine,(const void*)newLine,columnsToUpdate*sizeof(Character));
+      const Character *currentLine = &_image[y * this->_columns];
+      const Character *const newLine = &newimg[y * columns];
+
+      bool updateLine = false;
+
+      // The dirty mask indicates which characters need repainting. We also
+      // mark surrounding neighbours dirty, in case the character exceeds
+      // its cell boundaries
+      memset (dirtyMask, 0, columnsToUpdate + 2);
+
+      for (x = 0; x < columnsToUpdate; ++x)
+	{
+	  if (newLine[x] != currentLine[x])
+	    {
+	      dirtyMask[x] = true;
+	    }
+	}
+
+      if (!_resizing)		// not while _resizing, we're expecting a paintEvent
+	for (x = 0; x < columnsToUpdate; ++x)
+	  {
+	    _hasBlinker |= (newLine[x].rendition & RE_BLINK);
+
+	    // Start drawing if this character or the next one differs.
+	    // We also take the next one into account to handle the situation
+	    // where characters exceed their cell width.
+	    if (dirtyMask[x])
+	      {
+		quint16 c = newLine[x + 0].character;
+		if (!c)
+		  continue;
+		int p = 0;
+		disstrU[p++] = c;	//fontMap(c);
+		bool lineDraw = isLineChar (c);
+		bool doubleWidth =
+		  (x + 1 ==
+		   columnsToUpdate) ? false : (newLine[x + 1].character == 0);
+		cr = newLine[x].rendition;
+		_clipboard = newLine[x].backgroundColor;
+		if (newLine[x].foregroundColor != cf)
+		  cf = newLine[x].foregroundColor;
+		int lln = columnsToUpdate - x;
+		for (len = 1; len < lln; ++len)
+		  {
+		    const Character & ch = newLine[x + len];
+
+		    if (!ch.character)
+		      continue;	// Skip trailing part of multi-col chars.
+
+		    bool nextIsDoubleWidth =
+		      (x + len + 1 ==
+		       columnsToUpdate) ? false : (newLine[x + len +
+							   1].character == 0);
+
+		    if (ch.foregroundColor != cf ||
+			ch.backgroundColor != _clipboard ||
+			ch.rendition != cr ||
+			!dirtyMask[x + len] ||
+			isLineChar (c) != lineDraw ||
+			nextIsDoubleWidth != doubleWidth)
+		      break;
+
+		    disstrU[p++] = c;	//fontMap(c);
+		  }
+
+		QString unistr (disstrU, p);
+
+		bool saveFixedFont = _fixedFont;
+		if (lineDraw)
+		  _fixedFont = false;
+		if (doubleWidth)
+		  _fixedFont = false;
+
+		updateLine = true;
+
+		_fixedFont = saveFixedFont;
+		x += len - 1;
+	      }
+
+	  }
+
+      //both the top and bottom halves of double height _lines must always be redrawn
+      //although both top and bottom halves contain the same characters, only
+      //the top one is actually
+      //drawn.
+      if (_lineProperties.count () > y)
+	updateLine |= (_lineProperties[y] & LINE_DOUBLEHEIGHT);
+
+      // if the characters on the line are different in the old and the new _image
+      // then this line must be repainted.
+      if (updateLine)
+	{
+	  dirtyLineCount++;
+
+	  // add the area occupied by this line to the region which needs to be
+	  // repainted
+	  QRect dirtyRect = QRect (_leftMargin + tLx,
+				   _topMargin + tLy + _fontHeight * y,
+				   _fontWidth * columnsToUpdate,
+				   _fontHeight);
+
+	  dirtyRegion |= dirtyRect;
+	}
+
+      // replace the line of characters in the old _image with the
+      // current line of the new _image
+      memcpy ((void *) currentLine, (const void *) newLine,
+	      columnsToUpdate * sizeof (Character));
     }
 
-    // if the new _image is smaller than the previous _image, then ensure that the area
-    // outside the new _image is cleared
-    if ( linesToUpdate < _usedLines )
+  // if the new _image is smaller than the previous _image, then ensure that the area
+  // outside the new _image is cleared
+  if (linesToUpdate < _usedLines)
     {
-        dirtyRegion |= QRect(   _leftMargin+tLx ,
-                             _topMargin+tLy+_fontHeight*linesToUpdate ,
-                             _fontWidth * this->_columns ,
-                             _fontHeight * (_usedLines-linesToUpdate) );
+      dirtyRegion |= QRect (_leftMargin + tLx,
+			    _topMargin + tLy + _fontHeight * linesToUpdate,
+			    _fontWidth * this->_columns,
+			    _fontHeight * (_usedLines - linesToUpdate));
     }
-    _usedLines = linesToUpdate;
-
-    if ( columnsToUpdate < _usedColumns )
+  _usedLines = linesToUpdate;
+
+  if (columnsToUpdate < _usedColumns)
     {
-        dirtyRegion |= QRect(   _leftMargin+tLx+columnsToUpdate*_fontWidth ,
-                             _topMargin+tLy ,
-                             _fontWidth * (_usedColumns-columnsToUpdate) ,
-                             _fontHeight * this->_lines );
+      dirtyRegion |= QRect (_leftMargin + tLx + columnsToUpdate * _fontWidth,
+			    _topMargin + tLy,
+			    _fontWidth * (_usedColumns - columnsToUpdate),
+			    _fontHeight * this->_lines);
     }
-    _usedColumns = columnsToUpdate;
-
-    dirtyRegion |= _inputMethodData.previousPreeditRect;
-
-    // update the parts of the display which have changed
-    update(dirtyRegion);
-
-    if ( _hasBlinker && !_blinkTimer->isActive()) _blinkTimer->start( TEXT_BLINK_DELAY );
-    if (!_hasBlinker && _blinkTimer->isActive()) { _blinkTimer->stop(); _blinking = false; }
-    delete[] dirtyMask;
-    delete[] disstrU;
+  _usedColumns = columnsToUpdate;
+
+  dirtyRegion |= _inputMethodData.previousPreeditRect;
+
+  // update the parts of the display which have changed
+  update (dirtyRegion);
+
+  if (_hasBlinker && !_blinkTimer->isActive ())
+    _blinkTimer->start (TEXT_BLINK_DELAY);
+  if (!_hasBlinker && _blinkTimer->isActive ())
+    {
+      _blinkTimer->stop ();
+      _blinking = false;
+    }
+  delete[]dirtyMask;
+  delete[]disstrU;
 
 }
 
-void TerminalDisplay::showResizeNotification()
+void
+TerminalDisplay::showResizeNotification ()
 {
-    if (_terminalSizeHint && isVisible())
+  if (_terminalSizeHint && isVisible ())
     {
-        if (_terminalSizeStartup) {
-            _terminalSizeStartup=false;
-            return;
-        }
-        if (!_resizeWidget)
-        {
-            _resizeWidget = new QLabel(QString("Size: XXX x XXX"), this);
-            _resizeWidget->setMinimumWidth(_resizeWidget->fontMetrics().width(QString("Size: XXX x XXX")));
-            _resizeWidget->setMinimumHeight(_resizeWidget->sizeHint().height());
-            _resizeWidget->setAlignment(Qt::AlignCenter);
-
-            _resizeWidget->setStyleSheet("background-color:palette(window);border-style:solid;border-width:1px;border-color:palette(dark)");
-
-            _resizeTimer = new QTimer(this);
-            _resizeTimer->setSingleShot(true);
-            connect(_resizeTimer, SIGNAL(timeout()), _resizeWidget, SLOT(hide()));
-        }
-        QString sizeStr = QString("Size: %1 x %2").arg(_columns).arg(_lines);
-        _resizeWidget->setText(sizeStr);
-        _resizeWidget->move((width()-_resizeWidget->width())/2,
-                            (height()-_resizeWidget->height())/2+20);
-        _resizeWidget->show();
-        _resizeTimer->start(1000);
+      if (_terminalSizeStartup)
+	{
+	  _terminalSizeStartup = false;
+	  return;
+	}
+      if (!_resizeWidget)
+	{
+	  _resizeWidget = new QLabel (QString ("Size: XXX x XXX"), this);
+	  _resizeWidget->setMinimumWidth (_resizeWidget->fontMetrics ().
+					  width (QString
+						 ("Size: XXX x XXX")));
+	  _resizeWidget->setMinimumHeight (_resizeWidget->sizeHint ().
+					   height ());
+	  _resizeWidget->setAlignment (Qt::AlignCenter);
+
+	  _resizeWidget->
+	    setStyleSheet
+	    ("background-color:palette(window);border-style:solid;border-width:1px;border-color:palette(dark)");
+
+	  _resizeTimer = new QTimer (this);
+	  _resizeTimer->setSingleShot (true);
+	  connect (_resizeTimer, SIGNAL (timeout ()), _resizeWidget,
+		   SLOT (hide ()));
+	}
+      QString sizeStr = QString ("Size: %1 x %2").arg (_columns).arg (_lines);
+      _resizeWidget->setText (sizeStr);
+      _resizeWidget->move ((width () - _resizeWidget->width ()) / 2,
+			   (height () - _resizeWidget->height ()) / 2 + 20);
+      _resizeWidget->show ();
+      _resizeTimer->start (1000);
+    }
+}
+
+void
+TerminalDisplay::setBlinkingCursor (bool blink)
+{
+  _hasBlinkingCursor = blink;
+
+  if (blink && !_blinkCursorTimer->isActive ())
+    _blinkCursorTimer->start (QApplication::cursorFlashTime () / 2);
+
+  if (!blink && _blinkCursorTimer->isActive ())
+    {
+      _blinkCursorTimer->stop ();
+      if (_cursorBlinking)
+	blinkCursorEvent ();
+      else
+	_cursorBlinking = false;
     }
 }
 
-void TerminalDisplay::setBlinkingCursor(bool blink)
+void
+TerminalDisplay::setBlinkingTextEnabled (bool blink)
 {
-    _hasBlinkingCursor=blink;
-
-    if (blink && !_blinkCursorTimer->isActive())
-        _blinkCursorTimer->start(QApplication::cursorFlashTime() / 2);
-
-    if (!blink && _blinkCursorTimer->isActive())
+  _allowBlinkingText = blink;
+
+  if (blink && !_blinkTimer->isActive ())
+    _blinkTimer->start (TEXT_BLINK_DELAY);
+
+  if (!blink && _blinkTimer->isActive ())
     {
-        _blinkCursorTimer->stop();
-        if (_cursorBlinking)
-            blinkCursorEvent();
-        else
-            _cursorBlinking = false;
-    }
-}
-
-void TerminalDisplay::setBlinkingTextEnabled(bool blink)
-{
-    _allowBlinkingText = blink;
-
-    if (blink && !_blinkTimer->isActive()) 
-        _blinkTimer->start(TEXT_BLINK_DELAY);
-
-    if (!blink && _blinkTimer->isActive()) 
-    {
-        _blinkTimer->stop();
-        _blinking = false;
+      _blinkTimer->stop ();
+      _blinking = false;
     }
 }
 
-void TerminalDisplay::focusOutEvent(QFocusEvent*)
+void
+TerminalDisplay::focusOutEvent (QFocusEvent *)
 {
-    // trigger a repaint of the cursor so that it is both visible (in case
-    // it was hidden during blinking)
-    // and drawn in a focused out state
-    _cursorBlinking = false;
-    updateCursor();
-
-    _blinkCursorTimer->stop();
-    if (_blinking)
-        blinkEvent();
-
-    _blinkTimer->stop();
+  // trigger a repaint of the cursor so that it is both visible (in case
+  // it was hidden during blinking)
+  // and drawn in a focused out state
+  _cursorBlinking = false;
+  updateCursor ();
+
+  _blinkCursorTimer->stop ();
+  if (_blinking)
+    blinkEvent ();
+
+  _blinkTimer->stop ();
 }
-void TerminalDisplay::focusInEvent(QFocusEvent*)
+
+void
+TerminalDisplay::focusInEvent (QFocusEvent *)
 {
-    if (_hasBlinkingCursor)
+  if (_hasBlinkingCursor)
     {
-        _blinkCursorTimer->start();
+      _blinkCursorTimer->start ();
     }
-    updateCursor();
-
-    if (_hasBlinker)
-        _blinkTimer->start();
+  updateCursor ();
+
+  if (_hasBlinker)
+    _blinkTimer->start ();
 }
 
-void TerminalDisplay::paintEvent( QPaintEvent* pe )
+void
+TerminalDisplay::paintEvent (QPaintEvent * pe)
 {
-    QPainter paint(this);
-
-    foreach (const QRect &rect, (pe->region() & contentsRect()).rects())
-    {
-        drawBackground(paint,rect,palette().background().color(),
-                       true /* use opacity setting */);
-        drawContents(paint, rect);
-    }
-    drawInputMethodPreeditString(paint,preeditRect());
-    paintFilters(paint);
+  QPainter paint (this);
+
+  foreach (const QRect & rect, (pe->region () & contentsRect ()).rects ())
+  {
+    drawBackground (paint, rect, palette ().background ().color (),
+		    true /* use opacity setting */ );
+    drawContents (paint, rect);
+  }
+  drawInputMethodPreeditString (paint, preeditRect ());
+  paintFilters (paint);
 }
 
-QPoint TerminalDisplay::cursorPosition() const
+QPoint
+TerminalDisplay::cursorPosition () const
 {
-    if (_screenWindow)
-        return _screenWindow->cursorPosition();
-    else
-        return QPoint(0,0);
+  if (_screenWindow)
+    return _screenWindow->cursorPosition ();
+  else
+    return QPoint (0, 0);
 }
 
-QRect TerminalDisplay::preeditRect() const
+QRect
+TerminalDisplay::preeditRect () const
 {
-    const int preeditLength = string_width(_inputMethodData.preeditString);
-
-    if ( preeditLength == 0 )
-        return QRect();
-
-    return QRect(_leftMargin + _fontWidth*cursorPosition().x(),
-                 _topMargin + _fontHeight*cursorPosition().y(),
-                 _fontWidth*preeditLength,
-                 _fontHeight);
-}   
-
-void TerminalDisplay::drawInputMethodPreeditString(QPainter& painter , const QRect& rect)
+  const int preeditLength = string_width (_inputMethodData.preeditString);
+
+  if (preeditLength == 0)
+    return QRect ();
+
+  return QRect (_leftMargin + _fontWidth * cursorPosition ().x (),
+		_topMargin + _fontHeight * cursorPosition ().y (),
+		_fontWidth * preeditLength, _fontHeight);
+}
+
+void
+TerminalDisplay::drawInputMethodPreeditString (QPainter & painter,
+					       const QRect & rect)
 {
-    if ( _inputMethodData.preeditString.isEmpty() )
-        return;
-
-    const QPoint cursorPos = cursorPosition(); 
-
-    bool invertColors = false;
-    const QColor background = _colorTable[DEFAULT_BACK_COLOR].color;
-    const QColor foreground = _colorTable[DEFAULT_FORE_COLOR].color;
-    const Character* style = &_image[loc(cursorPos.x(),cursorPos.y())];
-
-    drawBackground(painter,rect,background,true);
-    drawCursor(painter,rect,foreground,background,invertColors);
-    drawCharacters(painter,rect,_inputMethodData.preeditString,style,invertColors);
-
-    _inputMethodData.previousPreeditRect = rect; 
+  if (_inputMethodData.preeditString.isEmpty ())
+    return;
+
+  const QPoint cursorPos = cursorPosition ();
+
+  bool invertColors = false;
+  const QColor background = _colorTable[DEFAULT_BACK_COLOR].color;
+  const QColor foreground = _colorTable[DEFAULT_FORE_COLOR].color;
+  const Character *style = &_image[loc (cursorPos.x (), cursorPos.y ())];
+
+  drawBackground (painter, rect, background, true);
+  drawCursor (painter, rect, foreground, background, invertColors);
+  drawCharacters (painter, rect, _inputMethodData.preeditString, style,
+		  invertColors);
+
+  _inputMethodData.previousPreeditRect = rect;
 }
 
-FilterChain* TerminalDisplay::filterChain() const
+FilterChain *
+TerminalDisplay::filterChain () const
 {
-    return _filterChain;
+  return _filterChain;
 }
 
-void TerminalDisplay::paintFilters(QPainter& painter)
+void
+TerminalDisplay::paintFilters (QPainter & painter)
 {
-    // get color of character under mouse and use it to draw
-    // lines for filters
-    QPoint cursorPos = mapFromGlobal(QCursor::pos());
-    int cursorLine;
-    int cursorColumn;
-    int scrollBarWidth = (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width() : 0;
-
-    getCharacterPosition( cursorPos , cursorLine , cursorColumn );
-    Character cursorCharacter = _image[loc(cursorColumn,cursorLine)];
-
-    painter.setPen( QPen(cursorCharacter.foregroundColor.color(colorTable())) );
-
-    // iterate over hotspots identified by the display's currently active filters 
-    // and draw appropriate visuals to indicate the presence of the hotspot
-
-    QList<Filter::HotSpot*> spots = _filterChain->hotSpots();
-    QListIterator<Filter::HotSpot*> iter(spots);
-    while (iter.hasNext())
+  // get color of character under mouse and use it to draw
+  // lines for filters
+  QPoint cursorPos = mapFromGlobal (QCursor::pos ());
+  int cursorLine;
+  int cursorColumn;
+  int scrollBarWidth =
+    (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width () : 0;
+
+  getCharacterPosition (cursorPos, cursorLine, cursorColumn);
+  Character cursorCharacter = _image[loc (cursorColumn, cursorLine)];
+
+  painter.
+    setPen (QPen (cursorCharacter.foregroundColor.color (colorTable ())));
+
+  // iterate over hotspots identified by the display's currently active filters 
+  // and draw appropriate visuals to indicate the presence of the hotspot
+
+  QList < Filter::HotSpot * >spots = _filterChain->hotSpots ();
+  QListIterator < Filter::HotSpot * >iter (spots);
+  while (iter.hasNext ())
     {
-        Filter::HotSpot* spot = iter.next();
-
-        QRegion region;
-        if ( spot->type() == Filter::HotSpot::Link ) {
-            QRect r;
-            if (spot->startLine()==spot->endLine()) {
-                r.setCoords( spot->startColumn()*_fontWidth + 1 + scrollBarWidth, 
-                            spot->startLine()*_fontHeight + 1,
-                            (spot->endColumn()-1)*_fontWidth - 1 + scrollBarWidth,
-                            (spot->endLine()+1)*_fontHeight - 1 );
-                region |= r;
-            } else {
-                r.setCoords( spot->startColumn()*_fontWidth + 1 + scrollBarWidth, 
-                            spot->startLine()*_fontHeight + 1,
-                            (_columns-1)*_fontWidth - 1 + scrollBarWidth,
-                            (spot->startLine()+1)*_fontHeight - 1 );
-                region |= r;
-                for ( int line = spot->startLine()+1 ; line < spot->endLine() ; line++ ) {
-                    r.setCoords( 0*_fontWidth + 1 + scrollBarWidth, 
-                                line*_fontHeight + 1,
-                                (_columns-1)*_fontWidth - 1 + scrollBarWidth,
-                                (line+1)*_fontHeight - 1 );
-                    region |= r;
-                }
-                r.setCoords( 0*_fontWidth + 1 + scrollBarWidth,
-                            spot->endLine()*_fontHeight + 1,
-                            (spot->endColumn()-1)*_fontWidth - 1 + scrollBarWidth,
-                            (spot->endLine()+1)*_fontHeight - 1 );
-                region |= r;
-            }
-        }
-
-        for ( int line = spot->startLine() ; line <= spot->endLine() ; line++ )
-        {
-            int startColumn = 0;
-            int endColumn = _columns-1; // TODO use number of _columns which are actually 
-            // occupied on this line rather than the width of the
-            // display in _columns
-
-            // ignore whitespace at the end of the lines
-            while ( QChar(_image[loc(endColumn,line)].character).isSpace() && endColumn > 0 )
-                endColumn--;
-
-            // increment here because the column which we want to set 'endColumn' to
-            // is the first whitespace character at the end of the line
-            endColumn++;
-
-            if ( line == spot->startLine() )
-                startColumn = spot->startColumn();
-            if ( line == spot->endLine() )
-                endColumn = spot->endColumn();
-
-            // subtract one pixel from
-            // the right and bottom so that
-            // we do not overdraw adjacent
-            // hotspots
-            //
-            // subtracting one pixel from all sides also prevents an edge case where
-            // moving the mouse outside a link could still leave it underlined 
-            // because the check below for the position of the cursor
-            // finds it on the border of the target area
-            QRect r;
-            r.setCoords( startColumn*_fontWidth + 1 + scrollBarWidth,
-                        line*_fontHeight + 1,
-                        endColumn*_fontWidth - 1 + scrollBarWidth,
-                        (line+1)*_fontHeight - 1 );
-            // Underline link hotspots 
-            if ( spot->type() == Filter::HotSpot::Link )
-            {
-                QFontMetrics metrics(font());
-
-                // find the baseline (which is the invisible line that the characters in the font sit on,
-                // with some having tails dangling below)
-                int baseline = r.bottom() - metrics.descent();
-                // find the position of the underline below that
-                int underlinePos = baseline + metrics.underlinePos();
-                if ( region.contains( mapFromGlobal(QCursor::pos()) ) ){
-                    painter.drawLine( r.left() , underlinePos , 
-                                     r.right() , underlinePos );
-                }
-            }
-            // Marker hotspots simply have a transparent rectanglular shape
-            // drawn on top of them
-            else if ( spot->type() == Filter::HotSpot::Marker )
-            {
-                //TODO - Do not use a hardcoded colour for this
-                painter.fillRect(r,QBrush(QColor(255,0,0,120)));
-            }
-        }
+      Filter::HotSpot * spot = iter.next ();
+
+      QRegion region;
+      if (spot->type () == Filter::HotSpot::Link)
+	{
+	  QRect r;
+	  if (spot->startLine () == spot->endLine ())
+	    {
+	      r.setCoords (spot->startColumn () * _fontWidth + 1 +
+			   scrollBarWidth,
+			   spot->startLine () * _fontHeight + 1,
+			   (spot->endColumn () - 1) * _fontWidth - 1 +
+			   scrollBarWidth,
+			   (spot->endLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	    }
+	  else
+	    {
+	      r.setCoords (spot->startColumn () * _fontWidth + 1 +
+			   scrollBarWidth,
+			   spot->startLine () * _fontHeight + 1,
+			   (_columns - 1) * _fontWidth - 1 + scrollBarWidth,
+			   (spot->startLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	      for (int line = spot->startLine () + 1; line < spot->endLine ();
+		   line++)
+		{
+		  r.setCoords (0 * _fontWidth + 1 + scrollBarWidth,
+			       line * _fontHeight + 1,
+			       (_columns - 1) * _fontWidth - 1 +
+			       scrollBarWidth, (line + 1) * _fontHeight - 1);
+		  region |= r;
+		}
+	      r.setCoords (0 * _fontWidth + 1 + scrollBarWidth,
+			   spot->endLine () * _fontHeight + 1,
+			   (spot->endColumn () - 1) * _fontWidth - 1 +
+			   scrollBarWidth,
+			   (spot->endLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	    }
+	}
+
+      for (int line = spot->startLine (); line <= spot->endLine (); line++)
+	{
+	  int startColumn = 0;
+	  int endColumn = _columns - 1;	// TODO use number of _columns which are actually 
+	  // occupied on this line rather than the width of the
+	  // display in _columns
+
+	  // ignore whitespace at the end of the lines
+	  while (QChar (_image[loc (endColumn, line)].character).isSpace ()
+		 && endColumn > 0)
+	    endColumn--;
+
+	  // increment here because the column which we want to set 'endColumn' to
+	  // is the first whitespace character at the end of the line
+	  endColumn++;
+
+	  if (line == spot->startLine ())
+	    startColumn = spot->startColumn ();
+	  if (line == spot->endLine ())
+	    endColumn = spot->endColumn ();
+
+	  // subtract one pixel from
+	  // the right and bottom so that
+	  // we do not overdraw adjacent
+	  // hotspots
+	  //
+	  // subtracting one pixel from all sides also prevents an edge case where
+	  // moving the mouse outside a link could still leave it underlined 
+	  // because the check below for the position of the cursor
+	  // finds it on the border of the target area
+	  QRect r;
+	  r.setCoords (startColumn * _fontWidth + 1 + scrollBarWidth,
+		       line * _fontHeight + 1,
+		       endColumn * _fontWidth - 1 + scrollBarWidth,
+		       (line + 1) * _fontHeight - 1);
+	  // Underline link hotspots 
+	  if (spot->type () == Filter::HotSpot::Link)
+	    {
+	      QFontMetrics metrics (font ());
+
+	      // find the baseline (which is the invisible line that the characters in the font sit on,
+	      // with some having tails dangling below)
+	      int baseline = r.bottom () - metrics.descent ();
+	      // find the position of the underline below that
+	      int underlinePos = baseline + metrics.underlinePos ();
+	      if (region.contains (mapFromGlobal (QCursor::pos ())))
+		{
+		  painter.drawLine (r.left (), underlinePos,
+				    r.right (), underlinePos);
+		}
+	    }
+	  // Marker hotspots simply have a transparent rectanglular shape
+	  // drawn on top of them
+	  else if (spot->type () == Filter::HotSpot::Marker)
+	    {
+	      //TODO - Do not use a hardcoded colour for this
+	      painter.fillRect (r, QBrush (QColor (255, 0, 0, 120)));
+	    }
+	}
     }
 }
-void TerminalDisplay::drawContents(QPainter &paint, const QRect &rect)
+
+void
+TerminalDisplay::drawContents (QPainter & paint, const QRect & rect)
 {
-    QPoint tL  = contentsRect().topLeft();
-    int    tLx = tL.x();
-    int    tLy = tL.y();
-
-    int lux = qMin(_usedColumns-1, qMax(0,(rect.left()   - tLx - _leftMargin ) / _fontWidth));
-    int luy = qMin(_usedLines-1,  qMax(0,(rect.top()    - tLy - _topMargin  ) / _fontHeight));
-    int rlx = qMin(_usedColumns-1, qMax(0,(rect.right()  - tLx - _leftMargin ) / _fontWidth));
-    int rly = qMin(_usedLines-1,  qMax(0,(rect.bottom() - tLy - _topMargin  ) / _fontHeight));
-
-    const int bufferSize = _usedColumns;
-    QString unistr;
-    unistr.reserve(bufferSize);
-    for (int y = luy; y <= rly; y++)
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+
+  int lux =
+    qMin (_usedColumns - 1,
+	  qMax (0, (rect.left () - tLx - _leftMargin) / _fontWidth));
+  int luy =
+    qMin (_usedLines - 1,
+	  qMax (0, (rect.top () - tLy - _topMargin) / _fontHeight));
+  int rlx =
+    qMin (_usedColumns - 1,
+	  qMax (0, (rect.right () - tLx - _leftMargin) / _fontWidth));
+  int rly =
+    qMin (_usedLines - 1,
+	  qMax (0, (rect.bottom () - tLy - _topMargin) / _fontHeight));
+
+  const int bufferSize = _usedColumns;
+  QString unistr;
+  unistr.reserve (bufferSize);
+  for (int y = luy; y <= rly; y++)
     {
-        quint16 c = _image[loc(lux,y)].character;
-        int x = lux;
-        if(!c && x)
-            x--; // Search for start of multi-column character
-        for (; x <= rlx; x++)
-        {
-            int len = 1;
-            int p = 0;
-
-            // reset our buffer to the maximal size
-            unistr.resize(bufferSize);
-            QChar *disstrU = unistr.data();
-
-            // is this a single character or a sequence of characters ?
-            if ( _image[loc(x,y)].rendition & RE_EXTENDED_CHAR )
-            {
-                // sequence of characters
-                ushort extendedCharLength = 0;
-                ushort* chars = ExtendedCharTable::instance
-                        .lookupExtendedChar(_image[loc(x,y)].charSequence,extendedCharLength);
-                for ( int index = 0 ; index < extendedCharLength ; index++ )
-                {
-                    Q_ASSERT( p < bufferSize );
-                    disstrU[p++] = chars[index];
-                }
-            }
-            else
-            {
-                // single character
-                c = _image[loc(x,y)].character;
-                if (c)
-                {
-                    Q_ASSERT( p < bufferSize );
-                    disstrU[p++] = c; //fontMap(c);
-                }
-            }
-
-            bool lineDraw = isLineChar(c);
-            bool doubleWidth = (_image[ qMin(loc(x,y)+1,_imageSize) ].character == 0);
-            CharacterColor currentForeground = _image[loc(x,y)].foregroundColor;
-            CharacterColor currentBackground = _image[loc(x,y)].backgroundColor;
-            quint8 currentRendition = _image[loc(x,y)].rendition;
-
-            while (x+len <= rlx &&
-                   _image[loc(x+len,y)].foregroundColor == currentForeground &&
-                   _image[loc(x+len,y)].backgroundColor == currentBackground &&
-                   _image[loc(x+len,y)].rendition == currentRendition &&
-                   (_image[ qMin(loc(x+len,y)+1,_imageSize) ].character == 0) == doubleWidth &&
-                   isLineChar( c = _image[loc(x+len,y)].character) == lineDraw) // Assignment!
-            {
-                if (c)
-                    disstrU[p++] = c; //fontMap(c);
-                if (doubleWidth) // assert((_image[loc(x+len,y)+1].character == 0)), see above if condition
-                    len++; // Skip trailing part of multi-column character
-                len++;
-            }
-            if ((x+len < _usedColumns) && (!_image[loc(x+len,y)].character))
-                len++; // Adjust for trailing part of multi-column character
-
-            bool save__fixedFont = _fixedFont;
-            if (lineDraw)
-                _fixedFont = false;
-            if (doubleWidth)
-                _fixedFont = false;
-            unistr.resize(p);
-
-            // Create a text scaling matrix for double width and double height lines.
-            QMatrix textScale;
-
-            if (y < _lineProperties.size())
-            {
-                if (_lineProperties[y] & LINE_DOUBLEWIDTH)
-                    textScale.scale(2,1);
-
-                if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
-                    textScale.scale(1,2);
-            }
-
-            //Apply text scaling matrix.
-            paint.setWorldMatrix(textScale, true);
-
-            //calculate the area in which the text will be drawn
-            QRect textArea = QRect( _leftMargin+tLx+_fontWidth*x , _topMargin+tLy+_fontHeight*y , _fontWidth*len , _fontHeight);
-
-            //move the calculated area to take account of scaling applied to the painter.
-            //the position of the area from the origin (0,0) is scaled
-            //by the opposite of whatever
-            //transformation has been applied to the painter.  this ensures that
-            //painting does actually start from textArea.topLeft()
-            //(instead of textArea.topLeft() * painter-scale)
-            textArea.moveTopLeft( textScale.inverted().map(textArea.topLeft()) );
-
-            //paint text fragment
-            drawTextFragment(    paint,
-                             textArea,
-                             unistr,
-                             &_image[loc(x,y)] ); //,
-            //0,
-            //!_isPrinting );
-
-            _fixedFont = save__fixedFont;
-
-            //reset back to single-width, single-height _lines
-            paint.setWorldMatrix(textScale.inverted(), true);
-
-            if (y < _lineProperties.size()-1)
-            {
-                //double-height _lines are represented by two adjacent _lines
-                //containing the same characters
-                //both _lines will have the LINE_DOUBLEHEIGHT attribute.
-                //If the current line has the LINE_DOUBLEHEIGHT attribute,
-                //we can therefore skip the next line
-                if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
-                    y++;
-            }
-
-            x += len - 1;
-        }
+      quint16 c = _image[loc (lux, y)].character;
+      int x = lux;
+      if (!c && x)
+	x--;			// Search for start of multi-column character
+      for (; x <= rlx; x++)
+	{
+	  int len = 1;
+	  int p = 0;
+
+	  // reset our buffer to the maximal size
+	  unistr.resize (bufferSize);
+	  QChar *disstrU = unistr.data ();
+
+	  // is this a single character or a sequence of characters ?
+	  if (_image[loc (x, y)].rendition & RE_EXTENDED_CHAR)
+	    {
+	      // sequence of characters
+	      ushort extendedCharLength = 0;
+	      ushort *chars =
+		ExtendedCharTable::instance.
+		lookupExtendedChar (_image[loc (x, y)].charSequence,
+				    extendedCharLength);
+	      for (int index = 0; index < extendedCharLength; index++)
+		{
+		  Q_ASSERT (p < bufferSize);
+		  disstrU[p++] = chars[index];
+		}
+	    }
+	  else
+	    {
+	      // single character
+	      c = _image[loc (x, y)].character;
+	      if (c)
+		{
+		  Q_ASSERT (p < bufferSize);
+		  disstrU[p++] = c;	//fontMap(c);
+		}
+	    }
+
+	  bool lineDraw = isLineChar (c);
+	  bool doubleWidth =
+	    (_image[qMin (loc (x, y) + 1, _imageSize)].character == 0);
+	  CharacterColor currentForeground =
+	    _image[loc (x, y)].foregroundColor;
+	  CharacterColor currentBackground =
+	    _image[loc (x, y)].backgroundColor;
+	  quint8 currentRendition = _image[loc (x, y)].rendition;
+
+	  while (x + len <= rlx && _image[loc (x + len, y)].foregroundColor == currentForeground && _image[loc (x + len, y)].backgroundColor == currentBackground && _image[loc (x + len, y)].rendition == currentRendition && (_image[qMin (loc (x + len, y) + 1, _imageSize)].character == 0) == doubleWidth && isLineChar (c = _image[loc (x + len, y)].character) == lineDraw)	// Assignment!
+	    {
+	      if (c)
+		disstrU[p++] = c;	//fontMap(c);
+	      if (doubleWidth)	// assert((_image[loc(x+len,y)+1].character == 0)), see above if condition
+		len++;		// Skip trailing part of multi-column character
+	      len++;
+	    }
+	  if ((x + len < _usedColumns)
+	      && (!_image[loc (x + len, y)].character))
+	    len++;		// Adjust for trailing part of multi-column character
+
+	  bool save__fixedFont = _fixedFont;
+	  if (lineDraw)
+	    _fixedFont = false;
+	  if (doubleWidth)
+	    _fixedFont = false;
+	  unistr.resize (p);
+
+	  // Create a text scaling matrix for double width and double height lines.
+	  QMatrix textScale;
+
+	  if (y < _lineProperties.size ())
+	    {
+	      if (_lineProperties[y] & LINE_DOUBLEWIDTH)
+		textScale.scale (2, 1);
+
+	      if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+		textScale.scale (1, 2);
+	    }
+
+	  //Apply text scaling matrix.
+	  paint.setWorldMatrix (textScale, true);
+
+	  //calculate the area in which the text will be drawn
+	  QRect textArea =
+	    QRect (_leftMargin + tLx + _fontWidth * x,
+		   _topMargin + tLy + _fontHeight * y, _fontWidth * len,
+		   _fontHeight);
+
+	  //move the calculated area to take account of scaling applied to the painter.
+	  //the position of the area from the origin (0,0) is scaled
+	  //by the opposite of whatever
+	  //transformation has been applied to the painter.  this ensures that
+	  //painting does actually start from textArea.topLeft()
+	  //(instead of textArea.topLeft() * painter-scale)
+	  textArea.moveTopLeft (textScale.inverted ().
+				map (textArea.topLeft ()));
+
+	  //paint text fragment
+	  drawTextFragment (paint, textArea, unistr, &_image[loc (x, y)]);	//,
+	  //0,
+	  //!_isPrinting );
+
+	  _fixedFont = save__fixedFont;
+
+	  //reset back to single-width, single-height _lines
+	  paint.setWorldMatrix (textScale.inverted (), true);
+
+	  if (y < _lineProperties.size () - 1)
+	    {
+	      //double-height _lines are represented by two adjacent _lines
+	      //containing the same characters
+	      //both _lines will have the LINE_DOUBLEHEIGHT attribute.
+	      //If the current line has the LINE_DOUBLEHEIGHT attribute,
+	      //we can therefore skip the next line
+	      if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+		y++;
+	    }
+
+	  x += len - 1;
+	}
     }
 }
 
-void TerminalDisplay::blinkEvent()
+void
+TerminalDisplay::blinkEvent ()
 {
-    if (!_allowBlinkingText) return;
-
-    _blinking = !_blinking;
-
-    //TODO:  Optimize to only repaint the areas of the widget
-    // where there is blinking text
-    // rather than repainting the whole widget.
-    update();
+  if (!_allowBlinkingText)
+    return;
+
+  _blinking = !_blinking;
+
+  //TODO:  Optimize to only repaint the areas of the widget
+  // where there is blinking text
+  // rather than repainting the whole widget.
+  update ();
 }
 
-QRect TerminalDisplay::imageToWidget(const QRect& imageArea) const
+QRect
+TerminalDisplay::imageToWidget (const QRect & imageArea) const
 {
-    QRect result;
-    result.setLeft( _leftMargin + _fontWidth * imageArea.left() );
-    result.setTop( _topMargin + _fontHeight * imageArea.top() );
-    result.setWidth( _fontWidth * imageArea.width() );
-    result.setHeight( _fontHeight * imageArea.height() );
-
-    return result;
+  QRect result;
+  result.setLeft (_leftMargin + _fontWidth * imageArea.left ());
+  result.setTop (_topMargin + _fontHeight * imageArea.top ());
+  result.setWidth (_fontWidth * imageArea.width ());
+  result.setHeight (_fontHeight * imageArea.height ());
+
+  return result;
 }
 
-void TerminalDisplay::updateCursor()
+void
+TerminalDisplay::updateCursor ()
 {
-    QRect cursorRect = imageToWidget( QRect(cursorPosition(),QSize(1,1)) );
-    update(cursorRect);
+  QRect cursorRect = imageToWidget (QRect (cursorPosition (), QSize (1, 1)));
+  update (cursorRect);
 }
 
-void TerminalDisplay::blinkCursorEvent()
+void
+TerminalDisplay::blinkCursorEvent ()
 {
-    _cursorBlinking = !_cursorBlinking;
-    updateCursor();
+  _cursorBlinking = !_cursorBlinking;
+  updateCursor ();
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                  Resizing                                 */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
-void TerminalDisplay::resizeEvent(QResizeEvent*)
+void
+TerminalDisplay::resizeEvent (QResizeEvent *)
 {
-    updateImageSize();
+  updateImageSize ();
 }
 
-void TerminalDisplay::propagateSize()
+void
+TerminalDisplay::propagateSize ()
 {
-    if (_isFixedSize)
+  if (_isFixedSize)
     {
-        setSize(_columns, _lines);
-        QWidget::setFixedSize(sizeHint());
-        parentWidget()->adjustSize();
-        parentWidget()->setFixedSize(parentWidget()->sizeHint());
-        return;
+      setSize (_columns, _lines);
+      QWidget::setFixedSize (sizeHint ());
+      parentWidget ()->adjustSize ();
+      parentWidget ()->setFixedSize (parentWidget ()->sizeHint ());
+      return;
     }
-    if (_image)
-        updateImageSize();
+  if (_image)
+    updateImageSize ();
 }
 
-void TerminalDisplay::updateImageSize()
+void
+TerminalDisplay::updateImageSize ()
 {
-    Character* oldimg = _image;
-    int oldlin = _lines;
-    int oldcol = _columns;
-
-    makeImage();
-
-    // copy the old image to reduce flicker
-    int lines = qMin(oldlin,_lines);
-    int columns = qMin(oldcol,_columns);
-
-    if (oldimg)
+  Character *oldimg = _image;
+  int oldlin = _lines;
+  int oldcol = _columns;
+
+  makeImage ();
+
+  // copy the old image to reduce flicker
+  int lines = qMin (oldlin, _lines);
+  int columns = qMin (oldcol, _columns);
+
+  if (oldimg)
     {
-        for (int line = 0; line < lines; line++)
-        {
-            memcpy((void*)&_image[_columns*line],
-                   (void*)&oldimg[oldcol*line],columns*sizeof(Character));
-        }
-        delete[] oldimg;
+      for (int line = 0; line < lines; line++)
+	{
+	  memcpy ((void *) &_image[_columns * line],
+		  (void *) &oldimg[oldcol * line],
+		  columns * sizeof (Character));
+	}
+      delete[]oldimg;
     }
 
-    if (_screenWindow)
-        _screenWindow->setWindowLines(_lines);
-
-    _resizing = (oldlin!=_lines) || (oldcol!=_columns);
-
-    if ( _resizing )
+  if (_screenWindow)
+    _screenWindow->setWindowLines (_lines);
+
+  _resizing = (oldlin != _lines) || (oldcol != _columns);
+
+  if (_resizing)
     {
-        showResizeNotification();
-        emit changedContentSizeSignal(_contentHeight, _contentWidth); // expose resizeEvent
+      showResizeNotification ();
+      emit changedContentSizeSignal (_contentHeight, _contentWidth);	// expose resizeEvent
     }
 
-    _resizing = false;
+  _resizing = false;
 }
 
 //showEvent and hideEvent are reimplemented here so that it appears to other classes that the 
 //display has been resized when the display is hidden or shown.
 //
 //TODO: Perhaps it would be better to have separate signals for show and hide instead of using
 //the same signal as the one for a content size change 
-void TerminalDisplay::showEvent(QShowEvent*)
+void
+TerminalDisplay::showEvent (QShowEvent *)
 {
-    emit changedContentSizeSignal(_contentHeight,_contentWidth);
+  emit changedContentSizeSignal (_contentHeight, _contentWidth);
 }
-void TerminalDisplay::hideEvent(QHideEvent*)
+
+void
+TerminalDisplay::hideEvent (QHideEvent *)
 {
-    emit changedContentSizeSignal(_contentHeight,_contentWidth);
+  emit changedContentSizeSignal (_contentHeight, _contentWidth);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Scrollbar                                  */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
-void TerminalDisplay::scrollBarPositionChanged(int)
+void
+TerminalDisplay::scrollBarPositionChanged (int)
 {
-    if ( !_screenWindow )
-        return;
-
-    _screenWindow->scrollTo( _scrollBar->value() );
-
-    // if the thumb has been moved to the bottom of the _scrollBar then set
-    // the display to automatically track new output,
-    // that is, scroll down automatically
-    // to how new _lines as they are added
-    const bool atEndOfOutput = (_scrollBar->value() == _scrollBar->maximum());
-    _screenWindow->setTrackOutput( atEndOfOutput );
-
-    updateImage();
+  if (!_screenWindow)
+    return;
+
+  _screenWindow->scrollTo (_scrollBar->value ());
+
+  // if the thumb has been moved to the bottom of the _scrollBar then set
+  // the display to automatically track new output,
+  // that is, scroll down automatically
+  // to how new _lines as they are added
+  const bool atEndOfOutput = (_scrollBar->value () == _scrollBar->maximum ());
+  _screenWindow->setTrackOutput (atEndOfOutput);
+
+  updateImage ();
 }
 
-void TerminalDisplay::setScroll(int cursor, int slines)
+void
+TerminalDisplay::setScroll (int cursor, int slines)
 {
-    // update _scrollBar if the range or value has changed,
-    // otherwise return
-    //
-    // setting the range or value of a _scrollBar will always trigger
-    // a repaint, so it should be avoided if it is not necessary
-    if ( _scrollBar->minimum() == 0                 &&
-            _scrollBar->maximum() == (slines - _lines) &&
-            _scrollBar->value()   == cursor )
+  // update _scrollBar if the range or value has changed,
+  // otherwise return
+  //
+  // setting the range or value of a _scrollBar will always trigger
+  // a repaint, so it should be avoided if it is not necessary
+  if (_scrollBar->minimum () == 0 &&
+      _scrollBar->maximum () == (slines - _lines) &&
+      _scrollBar->value () == cursor)
     {
-        return;
+      return;
     }
 
-    disconnect(_scrollBar, SIGNAL(valueChanged(int)), this, SLOT(scrollBarPositionChanged(int)));
-    _scrollBar->setRange(0,slines - _lines);
-    _scrollBar->setSingleStep(1);
-    _scrollBar->setPageStep(_lines);
-    _scrollBar->setValue(cursor);
-    connect(_scrollBar, SIGNAL(valueChanged(int)), this, SLOT(scrollBarPositionChanged(int)));
+  disconnect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	      SLOT (scrollBarPositionChanged (int)));
+  _scrollBar->setRange (0, slines - _lines);
+  _scrollBar->setSingleStep (1);
+  _scrollBar->setPageStep (_lines);
+  _scrollBar->setValue (cursor);
+  connect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	   SLOT (scrollBarPositionChanged (int)));
 }
 
-void TerminalDisplay::setScrollBarPosition(ScrollBarPosition position)
+void
+TerminalDisplay::setScrollBarPosition (ScrollBarPosition position)
 {
-    if (_scrollbarLocation == position)
-        return;
-
-    if ( position == NoScrollBar )
-        _scrollBar->hide();
-    else
-        _scrollBar->show();
-
-    _topMargin = _leftMargin = 1;
-    _scrollbarLocation = position;
-
-    propagateSize();
-    update();
+  if (_scrollbarLocation == position)
+    return;
+
+  if (position == NoScrollBar)
+    _scrollBar->hide ();
+  else
+    _scrollBar->show ();
+
+  _topMargin = _leftMargin = 1;
+  _scrollbarLocation = position;
+
+  propagateSize ();
+  update ();
 }
 
-void TerminalDisplay::mousePressEvent(QMouseEvent* ev)
+void
+TerminalDisplay::mousePressEvent (QMouseEvent * ev)
 {
-    if ( _possibleTripleClick && (ev->button()==Qt::LeftButton) ) {
-        mouseTripleClickEvent(ev);
-        return;
+  if (_possibleTripleClick && (ev->button () == Qt::LeftButton))
+    {
+      mouseTripleClickEvent (ev);
+      return;
     }
 
-    if ( !contentsRect().contains(ev->pos()) ) return;
-
-    if ( !_screenWindow ) return;
-
-    int charLine;
-    int charColumn;
-    getCharacterPosition(ev->pos(),charLine,charColumn);
-    QPoint pos = QPoint(charColumn,charLine);
-
-    if ( ev->button() == Qt::LeftButton)
+  if (!contentsRect ().contains (ev->pos ()))
+    return;
+
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+  QPoint pos = QPoint (charColumn, charLine);
+
+  if (ev->button () == Qt::LeftButton)
     {
-        _lineSelectionMode = false;
-        _wordSelectionMode = false;
-
-        emit isBusySelecting(true); // Keep it steady...
-        // Drag only when the Control key is hold
-        bool selected = false;
-
-        // The receiver of the testIsSelected() signal will adjust
-        // 'selected' accordingly.
-        //emit testIsSelected(pos.x(), pos.y(), selected);
-
-        selected =  _screenWindow->isSelected(pos.x(),pos.y());
-
-        if ((!_ctrlDrag || ev->modifiers() & Qt::ControlModifier) && selected ) {
-            // The user clicked inside selected text
-            dragInfo.state = diPending;
-            dragInfo.start = ev->pos();
-        }
-        else {
-            // No reason to ever start a drag event
-            dragInfo.state = diNone;
-
-            _preserveLineBreaks = !( ( ev->modifiers() & Qt::ControlModifier ) && !(ev->modifiers() & Qt::AltModifier) );
-            _columnSelectionMode = (ev->modifiers() & Qt::AltModifier) && (ev->modifiers() & Qt::ControlModifier);
-
-            if (_mouseMarks || (ev->modifiers() & Qt::ShiftModifier))
-            {
-                _screenWindow->clearSelection();
-
-                //emit clearSelectionSignal();
-                pos.ry() += _scrollBar->value();
-                _iPntSel = _pntSel = pos;
-                _actSel = 1; // left mouse button pressed but nothing selected yet.
-
-            }
-            else
-            {
-                emit mouseSignal( 0, charColumn + 1, charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 0);
-            }
-        }
+      _lineSelectionMode = false;
+      _wordSelectionMode = false;
+
+      emit isBusySelecting (true);	// Keep it steady...
+      // Drag only when the Control key is hold
+      bool selected = false;
+
+      // The receiver of the testIsSelected() signal will adjust
+      // 'selected' accordingly.
+      //emit testIsSelected(pos.x(), pos.y(), selected);
+
+      selected = _screenWindow->isSelected (pos.x (), pos.y ());
+
+      if ((!_ctrlDrag || ev->modifiers () & Qt::ControlModifier) && selected)
+	{
+	  // The user clicked inside selected text
+	  dragInfo.state = diPending;
+	  dragInfo.start = ev->pos ();
+	}
+      else
+	{
+	  // No reason to ever start a drag event
+	  dragInfo.state = diNone;
+
+	  _preserveLineBreaks = !((ev->modifiers () & Qt::ControlModifier)
+				  && !(ev->modifiers () & Qt::AltModifier));
+	  _columnSelectionMode = (ev->modifiers () & Qt::AltModifier)
+	    && (ev->modifiers () & Qt::ControlModifier);
+
+	  if (_mouseMarks || (ev->modifiers () & Qt::ShiftModifier))
+	    {
+	      _screenWindow->clearSelection ();
+
+	      //emit clearSelectionSignal();
+	      pos.ry () += _scrollBar->value ();
+	      _iPntSel = _pntSel = pos;
+	      _actSel = 1;	// left mouse button pressed but nothing selected yet.
+
+	    }
+	  else
+	    {
+	      emit mouseSignal (0, charColumn + 1,
+				charLine + 1 + _scrollBar->value () -
+				_scrollBar->maximum (), 0);
+	    }
+	}
     }
-    else if ( ev->button() == Qt::MidButton )
+  else if (ev->button () == Qt::MidButton)
     {
-        if ( _mouseMarks || (!_mouseMarks && (ev->modifiers() & Qt::ShiftModifier)) )
-            emitSelection(true,ev->modifiers() & Qt::ControlModifier);
-        else
-            emit mouseSignal( 1, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+      if (_mouseMarks
+	  || (!_mouseMarks && (ev->modifiers () & Qt::ShiftModifier)))
+	emitSelection (true, ev->modifiers () & Qt::ControlModifier);
+      else
+	emit mouseSignal (1, charColumn + 1,
+			  charLine + 1 + _scrollBar->value () -
+			  _scrollBar->maximum (), 0);
     }
-    else if ( ev->button() == Qt::RightButton )
+  else if (ev->button () == Qt::RightButton)
     {
-        if (_mouseMarks || (ev->modifiers() & Qt::ShiftModifier))
-            emit configureRequest(ev->pos());
-        else
-            emit mouseSignal( 2, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+      if (_mouseMarks || (ev->modifiers () & Qt::ShiftModifier))
+	emit configureRequest (ev->pos ());
+      else
+      emit mouseSignal (2, charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
     }
 }
 
-QList<QAction*> TerminalDisplay::filterActions(const QPoint& position)
+QList < QAction * >TerminalDisplay::filterActions (const QPoint & position)
 {
-    int charLine, charColumn;
-    getCharacterPosition(position,charLine,charColumn);
-
-    Filter::HotSpot* spot = _filterChain->hotSpotAt(charLine,charColumn);
-
-    return spot ? spot->actions() : QList<QAction*>();
+  int
+    charLine,
+    charColumn;
+  getCharacterPosition (position, charLine, charColumn);
+
+  Filter::HotSpot * spot = _filterChain->hotSpotAt (charLine, charColumn);
+
+  return spot ? spot->actions () : QList < QAction * >();
 }
 
-void TerminalDisplay::mouseMoveEvent(QMouseEvent* ev)
+void
+TerminalDisplay::mouseMoveEvent (QMouseEvent * ev)
 {
-    int charLine = 0;
-    int charColumn = 0;
-    int scrollBarWidth = (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width() : 0;
-
-    getCharacterPosition(ev->pos(),charLine,charColumn);
-
-    // handle filters
-    // change link hot-spot appearance on mouse-over
-    Filter::HotSpot* spot = _filterChain->hotSpotAt(charLine,charColumn);
-    if ( spot && spot->type() == Filter::HotSpot::Link)
+  int charLine = 0;
+  int charColumn = 0;
+  int scrollBarWidth =
+    (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width () : 0;
+
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  // handle filters
+  // change link hot-spot appearance on mouse-over
+  Filter::HotSpot * spot = _filterChain->hotSpotAt (charLine, charColumn);
+  if (spot && spot->type () == Filter::HotSpot::Link)
     {
-        QRegion previousHotspotArea = _mouseOverHotspotArea;
-        _mouseOverHotspotArea = QRegion();
-        QRect r;
-        if (spot->startLine()==spot->endLine()) {
-            r.setCoords( spot->startColumn()*_fontWidth + scrollBarWidth,
-                        spot->startLine()*_fontHeight,
-                        spot->endColumn()*_fontWidth + scrollBarWidth,
-                        (spot->endLine()+1)*_fontHeight - 1 );
-            _mouseOverHotspotArea |= r;
-        } else {
-            r.setCoords( spot->startColumn()*_fontWidth + scrollBarWidth,
-                        spot->startLine()*_fontHeight,
-                        _columns*_fontWidth - 1 + scrollBarWidth,
-                        (spot->startLine()+1)*_fontHeight );
-            _mouseOverHotspotArea |= r;
-            for ( int line = spot->startLine()+1 ; line < spot->endLine() ; line++ ) {
-                r.setCoords( 0*_fontWidth + scrollBarWidth,
-                            line*_fontHeight,
-                            _columns*_fontWidth + scrollBarWidth,
-                            (line+1)*_fontHeight );
-                _mouseOverHotspotArea |= r;
-            }
-            r.setCoords( 0*_fontWidth + scrollBarWidth,
-                        spot->endLine()*_fontHeight,
-                        spot->endColumn()*_fontWidth + scrollBarWidth,
-                        (spot->endLine()+1)*_fontHeight );
-            _mouseOverHotspotArea |= r;
-        }
-        // display tooltips when mousing over links
-        // TODO: Extend this to work with filter types other than links
-        const QString& tooltip = spot->tooltip();
-        if ( !tooltip.isEmpty() )
-        {
-            QToolTip::showText( mapToGlobal(ev->pos()) , tooltip , this , _mouseOverHotspotArea.boundingRect() );
-        }
-
-        update( _mouseOverHotspotArea | previousHotspotArea );
+      QRegion previousHotspotArea = _mouseOverHotspotArea;
+      _mouseOverHotspotArea = QRegion ();
+      QRect r;
+      if (spot->startLine () == spot->endLine ())
+	{
+	  r.setCoords (spot->startColumn () * _fontWidth + scrollBarWidth,
+		       spot->startLine () * _fontHeight,
+		       spot->endColumn () * _fontWidth + scrollBarWidth,
+		       (spot->endLine () + 1) * _fontHeight - 1);
+	  _mouseOverHotspotArea |= r;
+	}
+      else
+	{
+	  r.setCoords (spot->startColumn () * _fontWidth + scrollBarWidth,
+		       spot->startLine () * _fontHeight,
+		       _columns * _fontWidth - 1 + scrollBarWidth,
+		       (spot->startLine () + 1) * _fontHeight);
+	  _mouseOverHotspotArea |= r;
+	  for (int line = spot->startLine () + 1; line < spot->endLine ();
+	       line++)
+	    {
+	      r.setCoords (0 * _fontWidth + scrollBarWidth,
+			   line * _fontHeight,
+			   _columns * _fontWidth + scrollBarWidth,
+			   (line + 1) * _fontHeight);
+	      _mouseOverHotspotArea |= r;
+	    }
+	  r.setCoords (0 * _fontWidth + scrollBarWidth,
+		       spot->endLine () * _fontHeight,
+		       spot->endColumn () * _fontWidth + scrollBarWidth,
+		       (spot->endLine () + 1) * _fontHeight);
+	  _mouseOverHotspotArea |= r;
+	}
+      // display tooltips when mousing over links
+      // TODO: Extend this to work with filter types other than links
+      const QString & tooltip = spot->tooltip ();
+      if (!tooltip.isEmpty ())
+	{
+	  QToolTip::showText (mapToGlobal (ev->pos ()), tooltip, this,
+			      _mouseOverHotspotArea.boundingRect ());
+	}
+
+      update (_mouseOverHotspotArea | previousHotspotArea);
     }
-    else if ( !_mouseOverHotspotArea.isEmpty() )
+  else if (!_mouseOverHotspotArea.isEmpty ())
     {
-        update( _mouseOverHotspotArea );
-        // set hotspot area to an invalid rectangle
-        _mouseOverHotspotArea = QRegion();
+      update (_mouseOverHotspotArea);
+      // set hotspot area to an invalid rectangle
+      _mouseOverHotspotArea = QRegion ();
     }
 
-    // for auto-hiding the cursor, we need mouseTracking
-    if (ev->buttons() == Qt::NoButton ) return;
-
-    // if the terminal is interested in mouse movements
-    // then emit a mouse movement signal, unless the shift
-    // key is being held down, which overrides this.
-    if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
+  // for auto-hiding the cursor, we need mouseTracking
+  if (ev->buttons () == Qt::NoButton)
+    return;
+
+  // if the terminal is interested in mouse movements
+  // then emit a mouse movement signal, unless the shift
+  // key is being held down, which overrides this.
+  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
     {
-        int button = 3;
-        if (ev->buttons() & Qt::LeftButton)
-            button = 0;
-        if (ev->buttons() & Qt::MidButton)
-            button = 1;
-        if (ev->buttons() & Qt::RightButton)
-            button = 2;
-
-        
-        emit mouseSignal( button, 
-                         charColumn + 1,
-                         charLine + 1 +_scrollBar->value() -_scrollBar->maximum(),
-                         1 );
-
-        return;
+      int button = 3;
+      if (ev->buttons () & Qt::LeftButton)
+	button = 0;
+      if (ev->buttons () & Qt::MidButton)
+	button = 1;
+      if (ev->buttons () & Qt::RightButton)
+	button = 2;
+
+
+      emit mouseSignal (button,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 1);
+
+      return;
     }
 
-    if (dragInfo.state == diPending)
+  if (dragInfo.state == diPending)
     {
-        // we had a mouse down, but haven't confirmed a drag yet
-        // if the mouse has moved sufficiently, we will confirm
-
-        int distance = 10; //KGlobalSettings::dndEventDelay();
-        if ( ev->x() > dragInfo.start.x() + distance || ev->x() < dragInfo.start.x() - distance ||
-                ev->y() > dragInfo.start.y() + distance || ev->y() < dragInfo.start.y() - distance)
-        {
-            // we've left the drag square, we can start a real drag operation now
-            emit isBusySelecting(false); // Ok.. we can breath again.
-
-            _screenWindow->clearSelection();
-            doDrag();
-        }
-        return;
+      // we had a mouse down, but haven't confirmed a drag yet
+      // if the mouse has moved sufficiently, we will confirm
+
+      int distance = 10;	//KGlobalSettings::dndEventDelay();
+      if (ev->x () > dragInfo.start.x () + distance
+	  || ev->x () < dragInfo.start.x () - distance
+	  || ev->y () > dragInfo.start.y () + distance
+	  || ev->y () < dragInfo.start.y () - distance)
+	{
+	  // we've left the drag square, we can start a real drag operation now
+	  emit isBusySelecting (false);	// Ok.. we can breath again.
+
+	  _screenWindow->clearSelection ();
+	  doDrag ();
+	}
+      return;
     }
-    else if (dragInfo.state == diDragging)
+  else if (dragInfo.state == diDragging)
     {
-        // this isn't technically needed because mouseMoveEvent is suppressed during
-        // Qt drag operations, replaced by dragMoveEvent
-        return;
+      // this isn't technically needed because mouseMoveEvent is suppressed during
+      // Qt drag operations, replaced by dragMoveEvent
+      return;
     }
 
-    if (_actSel == 0) return;
-
-    // don't extend selection while pasting
-    if (ev->buttons() & Qt::MidButton) return;
-
-    extendSelection( ev->pos() );
+  if (_actSel == 0)
+    return;
+
+  // don't extend selection while pasting
+  if (ev->buttons () & Qt::MidButton)
+    return;
+
+  extendSelection (ev->pos ());
 }
 
-void TerminalDisplay::extendSelection( const QPoint& position )
+void
+TerminalDisplay::extendSelection (const QPoint & position)
 {
-    QPoint pos = position;
-
-    if ( !_screenWindow )
-        return;
-
-    //if ( !contentsRect().contains(ev->pos()) ) return;
-    QPoint tL  = contentsRect().topLeft();
-    int    tLx = tL.x();
-    int    tLy = tL.y();
-    int    scroll = _scrollBar->value();
-
-    // we're in the process of moving the mouse with the left button pressed
-    // the mouse cursor will kept caught within the bounds of the text in
-    // this widget.
-
-    int linesBeyondWidget = 0;
-
-    QRect textBounds(tLx + _leftMargin,
-                     tLy + _topMargin,
-                     _usedColumns*_fontWidth-1,
-                     _usedLines*_fontHeight-1);
-
-    // Adjust position within text area bounds.
-    QPoint oldpos = pos;
-
-    pos.setX( qBound(textBounds.left(),pos.x(),textBounds.right()) );
-    pos.setY( qBound(textBounds.top(),pos.y(),textBounds.bottom()) );
-
-    if ( oldpos.y() > textBounds.bottom() )
+  QPoint pos = position;
+
+  if (!_screenWindow)
+    return;
+
+  //if ( !contentsRect().contains(ev->pos()) ) return;
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+  int scroll = _scrollBar->value ();
+
+  // we're in the process of moving the mouse with the left button pressed
+  // the mouse cursor will kept caught within the bounds of the text in
+  // this widget.
+
+  int linesBeyondWidget = 0;
+
+  QRect textBounds (tLx + _leftMargin,
+		    tLy + _topMargin,
+		    _usedColumns * _fontWidth - 1,
+		    _usedLines * _fontHeight - 1);
+
+  // Adjust position within text area bounds.
+  QPoint oldpos = pos;
+
+  pos.setX (qBound (textBounds.left (), pos.x (), textBounds.right ()));
+  pos.setY (qBound (textBounds.top (), pos.y (), textBounds.bottom ()));
+
+  if (oldpos.y () > textBounds.bottom ())
+    {
+      linesBeyondWidget = (oldpos.y () - textBounds.bottom ()) / _fontHeight;
+      _scrollBar->setValue (_scrollBar->value () + linesBeyondWidget + 1);	// scrollforward
+    }
+  if (oldpos.y () < textBounds.top ())
     {
-        linesBeyondWidget = (oldpos.y()-textBounds.bottom()) / _fontHeight;
-        _scrollBar->setValue(_scrollBar->value()+linesBeyondWidget+1); // scrollforward
-    }
-    if ( oldpos.y() < textBounds.top() )
-    {
-        linesBeyondWidget = (textBounds.top()-oldpos.y()) / _fontHeight;
-        _scrollBar->setValue(_scrollBar->value()-linesBeyondWidget-1); // history
+      linesBeyondWidget = (textBounds.top () - oldpos.y ()) / _fontHeight;
+      _scrollBar->setValue (_scrollBar->value () - linesBeyondWidget - 1);	// history
     }
 
-    int charColumn = 0;
-    int charLine = 0;
-    getCharacterPosition(pos,charLine,charColumn);
-
-    QPoint here = QPoint(charColumn,charLine); //QPoint((pos.x()-tLx-_leftMargin+(_fontWidth/2))/_fontWidth,(pos.y()-tLy-_topMargin)/_fontHeight);
-    QPoint ohere;
-    QPoint _iPntSelCorr = _iPntSel;
-    _iPntSelCorr.ry() -= _scrollBar->value();
-    QPoint _pntSelCorr = _pntSel;
-    _pntSelCorr.ry() -= _scrollBar->value();
-    bool swapping = false;
-
-    if ( _wordSelectionMode )
+  int charColumn = 0;
+  int charLine = 0;
+  getCharacterPosition (pos, charLine, charColumn);
+
+  QPoint here = QPoint (charColumn, charLine);	//QPoint((pos.x()-tLx-_leftMargin+(_fontWidth/2))/_fontWidth,(pos.y()-tLy-_topMargin)/_fontHeight);
+  QPoint ohere;
+  QPoint _iPntSelCorr = _iPntSel;
+  _iPntSelCorr.ry () -= _scrollBar->value ();
+  QPoint _pntSelCorr = _pntSel;
+  _pntSelCorr.ry () -= _scrollBar->value ();
+  bool swapping = false;
+
+  if (_wordSelectionMode)
     {
-        // Extend to word boundaries
-        int i;
-        QChar selClass;
-
-        bool left_not_right = ( here.y() < _iPntSelCorr.y() ||
-                               ( here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() ) );
-        bool old_left_not_right = ( _pntSelCorr.y() < _iPntSelCorr.y() ||
-                                   ( _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() ) );
-        swapping = left_not_right != old_left_not_right;
-
-        // Find left (left_not_right ? from here : from start)
-        QPoint left = left_not_right ? here : _iPntSelCorr;
-        i = loc(left.x(),left.y());
-        if (i>=0 && i<=_imageSize) {
-            selClass = charClass(_image[i].character);
-            while ( ((left.x()>0) || (left.y()>0 && (_lineProperties[left.y()-1] & LINE_WRAPPED) ))
-                   && charClass(_image[i-1].character) == selClass )
-            { i--; if (left.x()>0) left.rx()--; else {left.rx()=_usedColumns-1; left.ry()--;} }
-        }
-
-        // Find left (left_not_right ? from start : from here)
-        QPoint right = left_not_right ? _iPntSelCorr : here;
-        i = loc(right.x(),right.y());
-        if (i>=0 && i<=_imageSize) {
-            selClass = charClass(_image[i].character);
-            while( ((right.x()<_usedColumns-1) || (right.y()<_usedLines-1 && (_lineProperties[right.y()] & LINE_WRAPPED) ))
-                  && charClass(_image[i+1].character) == selClass )
-            { i++; if (right.x()<_usedColumns-1) right.rx()++; else {right.rx()=0; right.ry()++; } }
-        }
-
-        // Pick which is start (ohere) and which is extension (here)
-        if ( left_not_right )
-        {
-            here = left; ohere = right;
-        }
-        else
-        {
-            here = right; ohere = left;
-        }
-        ohere.rx()++;
+      // Extend to word boundaries
+      int i;
+      QChar selClass;
+
+      bool left_not_right = (here.y () < _iPntSelCorr.y () ||
+			     (here.y () == _iPntSelCorr.y ()
+			      && here.x () < _iPntSelCorr.x ()));
+      bool old_left_not_right = (_pntSelCorr.y () < _iPntSelCorr.y ()
+				 || (_pntSelCorr.y () == _iPntSelCorr.y ()
+				     && _pntSelCorr.x () <
+				     _iPntSelCorr.x ()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+      i = loc (left.x (), left.y ());
+      if (i >= 0 && i <= _imageSize)
+	{
+	  selClass = charClass (_image[i].character);
+	  while (((left.x () > 0)
+		  || (left.y () > 0
+		      && (_lineProperties[left.y () - 1] & LINE_WRAPPED)))
+		 && charClass (_image[i - 1].character) == selClass)
+	    {
+	      i--;
+	      if (left.x () > 0)
+		left.rx ()--;
+	      else
+		{
+		  left.rx () = _usedColumns - 1;
+		  left.ry ()--;
+		}
+	    }
+	}
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      i = loc (right.x (), right.y ());
+      if (i >= 0 && i <= _imageSize)
+	{
+	  selClass = charClass (_image[i].character);
+	  while (((right.x () < _usedColumns - 1)
+		  || (right.y () < _usedLines - 1
+		      && (_lineProperties[right.y ()] & LINE_WRAPPED)))
+		 && charClass (_image[i + 1].character) == selClass)
+	    {
+	      i++;
+	      if (right.x () < _usedColumns - 1)
+		right.rx ()++;
+	      else
+		{
+		  right.rx () = 0;
+		  right.ry ()++;
+		}
+	    }
+	}
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right)
+	{
+	  here = left;
+	  ohere = right;
+	}
+      else
+	{
+	  here = right;
+	  ohere = left;
+	}
+      ohere.rx ()++;
     }
 
-    if ( _lineSelectionMode )
+  if (_lineSelectionMode)
     {
-        // Extend to complete line
-        bool above_not_below = ( here.y() < _iPntSelCorr.y() );
-
-        QPoint above = above_not_below ? here : _iPntSelCorr;
-        QPoint below = above_not_below ? _iPntSelCorr : here;
-
-        while (above.y()>0 && (_lineProperties[above.y()-1] & LINE_WRAPPED) )
-            above.ry()--;
-        while (below.y()<_usedLines-1 && (_lineProperties[below.y()] & LINE_WRAPPED) )
-            below.ry()++;
-
-        above.setX(0);
-        below.setX(_usedColumns-1);
-
-        // Pick which is start (ohere) and which is extension (here)
-        if ( above_not_below )
-        {
-            here = above; ohere = below;
-        }
-        else
-        {
-            here = below; ohere = above;
-        }
-
-        QPoint newSelBegin = QPoint( ohere.x(), ohere.y() );
-        swapping = !(_tripleSelBegin==newSelBegin);
-        _tripleSelBegin = newSelBegin;
-
-        ohere.rx()++;
+      // Extend to complete line
+      bool above_not_below = (here.y () < _iPntSelCorr.y ());
+
+      QPoint above = above_not_below ? here : _iPntSelCorr;
+      QPoint below = above_not_below ? _iPntSelCorr : here;
+
+      while (above.y () > 0
+	     && (_lineProperties[above.y () - 1] & LINE_WRAPPED))
+	above.ry ()--;
+      while (below.y () < _usedLines - 1
+	     && (_lineProperties[below.y ()] & LINE_WRAPPED))
+	below.ry ()++;
+
+      above.setX (0);
+      below.setX (_usedColumns - 1);
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (above_not_below)
+	{
+	  here = above;
+	  ohere = below;
+	}
+      else
+	{
+	  here = below;
+	  ohere = above;
+	}
+
+      QPoint newSelBegin = QPoint (ohere.x (), ohere.y ());
+      swapping = !(_tripleSelBegin == newSelBegin);
+      _tripleSelBegin = newSelBegin;
+
+      ohere.rx ()++;
     }
 
-    int offset = 0;
-    if ( !_wordSelectionMode && !_lineSelectionMode )
+  int offset = 0;
+  if (!_wordSelectionMode && !_lineSelectionMode)
     {
-        int i;
-        QChar selClass;
-
-        bool left_not_right = ( here.y() < _iPntSelCorr.y() ||
-                               ( here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() ) );
-        bool old_left_not_right = ( _pntSelCorr.y() < _iPntSelCorr.y() ||
-                                   ( _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() ) );
-        swapping = left_not_right != old_left_not_right;
-
-        // Find left (left_not_right ? from here : from start)
-        QPoint left = left_not_right ? here : _iPntSelCorr;
-
-        // Find left (left_not_right ? from start : from here)
-        QPoint right = left_not_right ? _iPntSelCorr : here;
-        if ( right.x() > 0 && !_columnSelectionMode )
-        {
-            i = loc(right.x(),right.y());
-            if (i>=0 && i<=_imageSize) {
-                selClass = charClass(_image[i-1].character);
-                /* if (selClass == ' ')
-        {
-          while ( right.x() < _usedColumns-1 && charClass(_image[i+1].character) == selClass && (right.y()<_usedLines-1) && 
-                          !(_lineProperties[right.y()] & LINE_WRAPPED))
-          { i++; right.rx()++; }
-          if (right.x() < _usedColumns-1)
-            right = left_not_right ? _iPntSelCorr : here;
-          else
-            right.rx()++;  // will be balanced later because of offset=-1;
-        }*/
-            }
-        }
-
-        // Pick which is start (ohere) and which is extension (here)
-        if ( left_not_right )
-        {
-            here = left; ohere = right; offset = 0;
-        }
-        else
-        {
-            here = right; ohere = left; offset = -1;
-        }
+      int i;
+      QChar selClass;
+
+      bool left_not_right = (here.y () < _iPntSelCorr.y () ||
+			     (here.y () == _iPntSelCorr.y ()
+			      && here.x () < _iPntSelCorr.x ()));
+      bool old_left_not_right = (_pntSelCorr.y () < _iPntSelCorr.y ()
+				 || (_pntSelCorr.y () == _iPntSelCorr.y ()
+				     && _pntSelCorr.x () <
+				     _iPntSelCorr.x ()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      if (right.x () > 0 && !_columnSelectionMode)
+	{
+	  i = loc (right.x (), right.y ());
+	  if (i >= 0 && i <= _imageSize)
+	    {
+	      selClass = charClass (_image[i - 1].character);
+	      /* if (selClass == ' ')
+	         {
+	         while ( right.x() < _usedColumns-1 && charClass(_image[i+1].character) == selClass && (right.y()<_usedLines-1) && 
+	         !(_lineProperties[right.y()] & LINE_WRAPPED))
+	         { i++; right.rx()++; }
+	         if (right.x() < _usedColumns-1)
+	         right = left_not_right ? _iPntSelCorr : here;
+	         else
+	         right.rx()++;  // will be balanced later because of offset=-1;
+	         } */
+	    }
+	}
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right)
+	{
+	  here = left;
+	  ohere = right;
+	  offset = 0;
+	}
+      else
+	{
+	  here = right;
+	  ohere = left;
+	  offset = -1;
+	}
     }
 
-    if ((here == _pntSelCorr) && (scroll == _scrollBar->value())) return; // not moved
-
-    if (here == ohere) return; // It's not left, it's not right.
-
-    if ( _actSel < 2 || swapping )
+  if ((here == _pntSelCorr) && (scroll == _scrollBar->value ()))
+    return;			// not moved
+
+  if (here == ohere)
+    return;			// It's not left, it's not right.
+
+  if (_actSel < 2 || swapping)
     {
-        if ( _columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode )
-        {
-            _screenWindow->setSelectionStart( ohere.x() , ohere.y() , true );
-        }
-        else
-        {
-            _screenWindow->setSelectionStart( ohere.x()-1-offset , ohere.y() , false );
-        }
+      if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode)
+	{
+	  _screenWindow->setSelectionStart (ohere.x (), ohere.y (), true);
+	}
+      else
+	{
+	  _screenWindow->setSelectionStart (ohere.x () - 1 - offset,
+					    ohere.y (), false);
+	}
 
     }
 
-    _actSel = 2; // within selection
-    _pntSel = here;
-    _pntSel.ry() += _scrollBar->value();
-
-    if ( _columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode )
+  _actSel = 2;			// within selection
+  _pntSel = here;
+  _pntSel.ry () += _scrollBar->value ();
+
+  if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode)
     {
-        _screenWindow->setSelectionEnd( here.x() , here.y() );
+      _screenWindow->setSelectionEnd (here.x (), here.y ());
     }
-    else
+  else
     {
-        _screenWindow->setSelectionEnd( here.x()+offset , here.y() );
+      _screenWindow->setSelectionEnd (here.x () + offset, here.y ());
     }
 
 }
 
-void TerminalDisplay::mouseReleaseEvent(QMouseEvent* ev)
+void
+TerminalDisplay::mouseReleaseEvent (QMouseEvent * ev)
 {
-    if ( !_screenWindow )
-        return;
-
-    int charLine;
-    int charColumn;
-    getCharacterPosition(ev->pos(),charLine,charColumn);
-
-    if ( ev->button() == Qt::LeftButton)
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  if (ev->button () == Qt::LeftButton)
     {
-        emit isBusySelecting(false);
-        if(dragInfo.state == diPending)
-        {
-            // We had a drag event pending but never confirmed.  Kill selection
-            _screenWindow->clearSelection();
-            //emit clearSelectionSignal();
-        }
-        else
-        {
-            if ( _actSel > 1 )
-            {
-                setSelection(  _screenWindow->selectedText(_preserveLineBreaks)  );
-            }
-
-            _actSel = 0;
-
-            //FIXME: emits a release event even if the mouse is
-            //       outside the range. The procedure used in `mouseMoveEvent'
-            //       applies here, too.
-
-            if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
-                emit mouseSignal( 3, // release
-                                 charColumn + 1,
-                                 charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 0);
-        }
-        dragInfo.state = diNone;
+      emit isBusySelecting (false);
+      if (dragInfo.state == diPending)
+	{
+	  // We had a drag event pending but never confirmed.  Kill selection
+	  _screenWindow->clearSelection ();
+	  //emit clearSelectionSignal();
+	}
+      else
+	{
+	  if (_actSel > 1)
+	    {
+	      setSelection (_screenWindow->
+			    selectedText (_preserveLineBreaks));
+	    }
+
+	  _actSel = 0;
+
+	  //FIXME: emits a release event even if the mouse is
+	  //       outside the range. The procedure used in `mouseMoveEvent'
+	  //       applies here, too.
+
+	  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
+	    emit mouseSignal (3,	// release
+			      charColumn + 1,
+			      charLine + 1 + _scrollBar->value () -
+			      _scrollBar->maximum (), 0);
+	}
+      dragInfo.state = diNone;
     }
 
 
-    if ( !_mouseMarks &&
-            ((ev->button() == Qt::RightButton && !(ev->modifiers() & Qt::ShiftModifier))
-             || ev->button() == Qt::MidButton) )
+  if (!_mouseMarks &&
+      ((ev->button () == Qt::RightButton
+	&& !(ev->modifiers () & Qt::ShiftModifier))
+       || ev->button () == Qt::MidButton))
     {
-        emit mouseSignal( 3,
-                         charColumn + 1,
-                         charLine + 1 +_scrollBar->value() -_scrollBar->maximum() ,
-                         0);
+      emit mouseSignal (3,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
     }
 }
 
-void TerminalDisplay::getCharacterPosition(const QPoint& widgetPoint,int& line,int& column) const
-{
-    column = (widgetPoint.x() + _fontWidth/2 -contentsRect().left()-_leftMargin) / _fontWidth;
-    line = (widgetPoint.y()-contentsRect().top()-_topMargin) / _fontHeight;
-
-    if ( line < 0 )
-        line = 0;
-    if ( column < 0 )
-        column = 0;
-
-    if ( line >= _usedLines )
-        line = _usedLines-1;
-
-    // the column value returned can be equal to _usedColumns, which
-    // is the position just after the last character displayed in a line.
-    //
-    // this is required so that the user can select characters in the right-most
-    // column (or left-most for right-to-left input)
-    if ( column > _usedColumns )
-        column = _usedColumns;
-}
-
-void TerminalDisplay::updateLineProperties()
-{
-    if ( !_screenWindow ) 
-        return;
-
-    _lineProperties = _screenWindow->getLineProperties();    
-}
-
-void TerminalDisplay::mouseDoubleClickEvent(QMouseEvent* ev)
+void
+TerminalDisplay::getCharacterPosition (const QPoint & widgetPoint, int &line,
+				       int &column) const
 {
-    if ( ev->button() != Qt::LeftButton) return;
-    if ( !_screenWindow ) return;
-
-    int charLine = 0;
-    int charColumn = 0;
-
-    getCharacterPosition(ev->pos(),charLine,charColumn);
-
-    QPoint pos(charColumn,charLine);
-
-    // pass on double click as two clicks.
-    if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
-    {
-        // Send just _ONE_ click event, since the first click of the double click
-        // was already sent by the click handler
-        emit mouseSignal( 0,
-                         pos.x()+1,
-                         pos.y()+1 +_scrollBar->value() -_scrollBar->maximum(),
-                         0 ); // left button
-        return;
-    }
-
-    _screenWindow->clearSelection();
-    QPoint bgnSel = pos;
-    QPoint endSel = pos;
-    int i = loc(bgnSel.x(),bgnSel.y());
-    _iPntSel = bgnSel;
-    _iPntSel.ry() += _scrollBar->value();
-
-    _wordSelectionMode = true;
-
-    // find word boundaries...
-    QChar selClass = charClass(_image[i].character);
+  column =
+    (widgetPoint.x () + _fontWidth / 2 - contentsRect ().left () -
+     _leftMargin) / _fontWidth;
+  line =
+    (widgetPoint.y () - contentsRect ().top () - _topMargin) / _fontHeight;
+
+  if (line < 0)
+    line = 0;
+  if (column < 0)
+    column = 0;
+
+  if (line >= _usedLines)
+    line = _usedLines - 1;
+
+  // the column value returned can be equal to _usedColumns, which
+  // is the position just after the last character displayed in a line.
+  //
+  // this is required so that the user can select characters in the right-most
+  // column (or left-most for right-to-left input)
+  if (column > _usedColumns)
+    column = _usedColumns;
+}
+
+void
+TerminalDisplay::updateLineProperties ()
+{
+  if (!_screenWindow)
+    return;
+
+  _lineProperties = _screenWindow->getLineProperties ();
+}
+
+void
+TerminalDisplay::mouseDoubleClickEvent (QMouseEvent * ev)
+{
+  if (ev->button () != Qt::LeftButton)
+    return;
+  if (!_screenWindow)
+    return;
+
+  int charLine = 0;
+  int charColumn = 0;
+
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  QPoint pos (charColumn, charLine);
+
+  // pass on double click as two clicks.
+  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
     {
-        // find the start of the word
-        int x = bgnSel.x();
-        while ( ((x>0) || (bgnSel.y()>0 && (_lineProperties[bgnSel.y()-1] & LINE_WRAPPED) ))
-               && charClass(_image[i-1].character) == selClass )
-        {
-            i--;
-            if (x>0)
-                x--;
-            else
-            {
-                x=_usedColumns-1;
-                bgnSel.ry()--;
-            }
-        }
-
-        bgnSel.setX(x);
-        _screenWindow->setSelectionStart( bgnSel.x() , bgnSel.y() , false );
-
-        // find the end of the word
-        i = loc( endSel.x(), endSel.y() );
-        x = endSel.x();
-        while( ((x<_usedColumns-1) || (endSel.y()<_usedLines-1 && (_lineProperties[endSel.y()] & LINE_WRAPPED) ))
-              && charClass(_image[i+1].character) == selClass )
-        {
-            i++;
-            if (x<_usedColumns-1)
-                x++;
-            else
-            {
-                x=0;
-                endSel.ry()++;
-            }
-        }
-
-        endSel.setX(x);
-
-        // In word selection mode don't select @ (64) if at end of word.
-        if ( ( QChar( _image[i].character ) == '@' ) && ( ( endSel.x() - bgnSel.x() ) > 0 ) )
-            endSel.setX( x - 1 );
-
-
-        _actSel = 2; // within selection
-
-        _screenWindow->setSelectionEnd( endSel.x() , endSel.y() );
-
-        setSelection( _screenWindow->selectedText(_preserveLineBreaks) );
+      // Send just _ONE_ click event, since the first click of the double click
+      // was already sent by the click handler
+      emit mouseSignal (0, pos.x () + 1, pos.y () + 1 + _scrollBar->value () - _scrollBar->maximum (), 0);	// left button
+      return;
     }
 
-    _possibleTripleClick=true;
-
-    QTimer::singleShot(QApplication::doubleClickInterval(),this,
-                       SLOT(tripleClickTimeout()));
+  _screenWindow->clearSelection ();
+  QPoint bgnSel = pos;
+  QPoint endSel = pos;
+  int i = loc (bgnSel.x (), bgnSel.y ());
+  _iPntSel = bgnSel;
+  _iPntSel.ry () += _scrollBar->value ();
+
+  _wordSelectionMode = true;
+
+  // find word boundaries...
+  QChar selClass = charClass (_image[i].character);
+  {
+    // find the start of the word
+    int x = bgnSel.x ();
+    while (((x > 0)
+	    || (bgnSel.y () > 0
+		&& (_lineProperties[bgnSel.y () - 1] & LINE_WRAPPED)))
+	   && charClass (_image[i - 1].character) == selClass)
+      {
+	i--;
+	if (x > 0)
+	  x--;
+	else
+	  {
+	    x = _usedColumns - 1;
+	    bgnSel.ry ()--;
+	  }
+      }
+
+    bgnSel.setX (x);
+    _screenWindow->setSelectionStart (bgnSel.x (), bgnSel.y (), false);
+
+    // find the end of the word
+    i = loc (endSel.x (), endSel.y ());
+    x = endSel.x ();
+    while (((x < _usedColumns - 1)
+	    || (endSel.y () < _usedLines - 1
+		&& (_lineProperties[endSel.y ()] & LINE_WRAPPED)))
+	   && charClass (_image[i + 1].character) == selClass)
+      {
+	i++;
+	if (x < _usedColumns - 1)
+	  x++;
+	else
+	  {
+	    x = 0;
+	    endSel.ry ()++;
+	  }
+      }
+
+    endSel.setX (x);
+
+    // In word selection mode don't select @ (64) if at end of word.
+    if ((QChar (_image[i].character) == '@')
+	&& ((endSel.x () - bgnSel.x ()) > 0))
+      endSel.setX (x - 1);
+
+
+    _actSel = 2;		// within selection
+
+    _screenWindow->setSelectionEnd (endSel.x (), endSel.y ());
+
+    setSelection (_screenWindow->selectedText (_preserveLineBreaks));
+  }
+
+  _possibleTripleClick = true;
+
+  QTimer::singleShot (QApplication::doubleClickInterval (), this,
+		      SLOT (tripleClickTimeout ()));
 }
 
-void TerminalDisplay::wheelEvent( QWheelEvent* ev )
+void
+TerminalDisplay::wheelEvent (QWheelEvent * ev)
 {
-    if (ev->orientation() != Qt::Vertical)
-        return;
-
-    // if the terminal program is not interested mouse events
-    // then send the event to the scrollbar if the slider has room to move
-    // or otherwise send simulated up / down key presses to the terminal program
-    // for the benefit of programs such as 'less'
-    if ( _mouseMarks )
+  if (ev->orientation () != Qt::Vertical)
+    return;
+
+  // if the terminal program is not interested mouse events
+  // then send the event to the scrollbar if the slider has room to move
+  // or otherwise send simulated up / down key presses to the terminal program
+  // for the benefit of programs such as 'less'
+  if (_mouseMarks)
     {
-        bool canScroll = _scrollBar->maximum() > 0;
-        if (canScroll)
-            _scrollBar->event(ev);
-        else
-        {
-            // assume that each Up / Down key event will cause the terminal application
-            // to scroll by one line.
-            //
-            // to get a reasonable scrolling speed, scroll by one line for every 5 degrees
-            // of mouse wheel rotation.  Mouse wheels typically move in steps of 15 degrees,
-            // giving a scroll of 3 lines
-            int key = ev->delta() > 0 ? Qt::Key_Up : Qt::Key_Down;
-
-            // QWheelEvent::delta() gives rotation in eighths of a degree
-            int wheelDegrees = ev->delta() / 8;
-            int linesToScroll = abs(wheelDegrees) / 5;
-
-            QKeyEvent keyScrollEvent(QEvent::KeyPress,key,Qt::NoModifier);
-
-            for (int i=0;i<linesToScroll;i++)
-                emit keyPressedSignal(&keyScrollEvent);
-        }
+      bool canScroll = _scrollBar->maximum () > 0;
+      if (canScroll)
+	_scrollBar->event (ev);
+      else
+	{
+	  // assume that each Up / Down key event will cause the terminal application
+	  // to scroll by one line.
+	  //
+	  // to get a reasonable scrolling speed, scroll by one line for every 5 degrees
+	  // of mouse wheel rotation.  Mouse wheels typically move in steps of 15 degrees,
+	  // giving a scroll of 3 lines
+	  int key = ev->delta () > 0 ? Qt::Key_Up : Qt::Key_Down;
+
+	  // QWheelEvent::delta() gives rotation in eighths of a degree
+	  int wheelDegrees = ev->delta () / 8;
+	  int linesToScroll = abs (wheelDegrees) / 5;
+
+	  QKeyEvent keyScrollEvent (QEvent::KeyPress, key, Qt::NoModifier);
+
+	  for (int i = 0; i < linesToScroll; i++)
+	    emit keyPressedSignal (&keyScrollEvent);
+	}
     }
-    else
+  else
     {
-        // terminal program wants notification of mouse activity
-
-        int charLine;
-        int charColumn;
-        getCharacterPosition( ev->pos() , charLine , charColumn );
-
-        emit mouseSignal( ev->delta() > 0 ? 4 : 5,
-                         charColumn + 1,
-                         charLine + 1 +_scrollBar->value() -_scrollBar->maximum() ,
-                         0);
+      // terminal program wants notification of mouse activity
+
+      int charLine;
+      int charColumn;
+      getCharacterPosition (ev->pos (), charLine, charColumn);
+
+      emit mouseSignal (ev->delta () > 0 ? 4 : 5,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
     }
 }
 
-void TerminalDisplay::tripleClickTimeout()
+void
+TerminalDisplay::tripleClickTimeout ()
 {
-    _possibleTripleClick=false;
+  _possibleTripleClick = false;
 }
 
-void TerminalDisplay::mouseTripleClickEvent(QMouseEvent* ev)
+void
+TerminalDisplay::mouseTripleClickEvent (QMouseEvent * ev)
 {
-    if ( !_screenWindow ) return;
-
-    int charLine;
-    int charColumn;
-    getCharacterPosition(ev->pos(),charLine,charColumn);
-    _iPntSel = QPoint(charColumn,charLine);
-
-    _screenWindow->clearSelection();
-
-    _lineSelectionMode = true;
-    _wordSelectionMode = false;
-
-    _actSel = 2; // within selection
-    emit isBusySelecting(true); // Keep it steady...
-
-    while (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
-        _iPntSel.ry()--;
-
-    if (_tripleClickMode == SelectForwardsFromCursor) {
-        // find word boundary start
-        int i = loc(_iPntSel.x(),_iPntSel.y());
-        QChar selClass = charClass(_image[i].character);
-        int x = _iPntSel.x();
-
-        while ( ((x>0) ||
-                 (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
-                 )
-               && charClass(_image[i-1].character) == selClass )
-        {
-            i--;
-            if (x>0)
-                x--;
-            else
-            {
-                x=_columns-1;
-                _iPntSel.ry()--;
-            }
-        }
-
-        _screenWindow->setSelectionStart( x , _iPntSel.y() , false );
-        _tripleSelBegin = QPoint( x, _iPntSel.y() );
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+  _iPntSel = QPoint (charColumn, charLine);
+
+  _screenWindow->clearSelection ();
+
+  _lineSelectionMode = true;
+  _wordSelectionMode = false;
+
+  _actSel = 2;			// within selection
+  emit isBusySelecting (true);	// Keep it steady...
+
+  while (_iPntSel.y () > 0
+	 && (_lineProperties[_iPntSel.y () - 1] & LINE_WRAPPED))
+    _iPntSel.ry ()--;
+
+  if (_tripleClickMode == SelectForwardsFromCursor)
+    {
+      // find word boundary start
+      int i = loc (_iPntSel.x (), _iPntSel.y ());
+      QChar selClass = charClass (_image[i].character);
+      int x = _iPntSel.x ();
+
+      while (((x > 0) ||
+	      (_iPntSel.y () > 0
+	       && (_lineProperties[_iPntSel.y () - 1] & LINE_WRAPPED)))
+	     && charClass (_image[i - 1].character) == selClass)
+	{
+	  i--;
+	  if (x > 0)
+	    x--;
+	  else
+	    {
+	      x = _columns - 1;
+	      _iPntSel.ry ()--;
+	    }
+	}
+
+      _screenWindow->setSelectionStart (x, _iPntSel.y (), false);
+      _tripleSelBegin = QPoint (x, _iPntSel.y ());
     }
-    else if (_tripleClickMode == SelectWholeLine) {
-        _screenWindow->setSelectionStart( 0 , _iPntSel.y() , false );
-        _tripleSelBegin = QPoint( 0, _iPntSel.y() );
+  else if (_tripleClickMode == SelectWholeLine)
+    {
+      _screenWindow->setSelectionStart (0, _iPntSel.y (), false);
+      _tripleSelBegin = QPoint (0, _iPntSel.y ());
     }
 
-    while (_iPntSel.y()<_lines-1 && (_lineProperties[_iPntSel.y()] & LINE_WRAPPED) )
-        _iPntSel.ry()++;
-
-    _screenWindow->setSelectionEnd( _columns - 1 , _iPntSel.y() );
-
-    setSelection(_screenWindow->selectedText(_preserveLineBreaks));
-
-    _iPntSel.ry() += _scrollBar->value();
+  while (_iPntSel.y () < _lines - 1
+	 && (_lineProperties[_iPntSel.y ()] & LINE_WRAPPED))
+    _iPntSel.ry ()++;
+
+  _screenWindow->setSelectionEnd (_columns - 1, _iPntSel.y ());
+
+  setSelection (_screenWindow->selectedText (_preserveLineBreaks));
+
+  _iPntSel.ry () += _scrollBar->value ();
 }
 
 
-bool TerminalDisplay::focusNextPrevChild( bool next )
+bool
+TerminalDisplay::focusNextPrevChild (bool next)
 {
-    if (next)
-        return false; // This disables changing the active part in konqueror
-    // when pressing Tab
-    return QWidget::focusNextPrevChild( next );
+  if (next)
+    return false;		// This disables changing the active part in konqueror
+  // when pressing Tab
+  return QWidget::focusNextPrevChild (next);
 }
 
 
-QChar TerminalDisplay::charClass(QChar qch) const
-{
-    if ( qch.isSpace() ) return ' ';
-
-    if ( qch.isLetterOrNumber() || _wordCharacters.contains(qch, Qt::CaseInsensitive ) )
-        return 'a';
-
-    return qch;
-}
-
-void TerminalDisplay::setWordCharacters(const QString& wc)
+QChar
+TerminalDisplay::charClass (QChar qch) const
 {
-    _wordCharacters = wc;
+  if (qch.isSpace ())
+    return ' ';
+
+  if (qch.isLetterOrNumber ()
+      || _wordCharacters.contains (qch, Qt::CaseInsensitive))
+    return 'a';
+
+  return qch;
 }
 
-void TerminalDisplay::setUsesMouse(bool on)
+void
+TerminalDisplay::setWordCharacters (const QString & wc)
 {
-    _mouseMarks = on;
-    setCursor( _mouseMarks ? Qt::IBeamCursor : Qt::ArrowCursor );
+  _wordCharacters = wc;
 }
-bool TerminalDisplay::usesMouse() const
+
+void
+TerminalDisplay::setUsesMouse (bool on)
 {
-    return _mouseMarks;
+  _mouseMarks = on;
+  setCursor (_mouseMarks ? Qt::IBeamCursor : Qt::ArrowCursor);
+}
+
+bool
+TerminalDisplay::usesMouse () const
+{
+  return _mouseMarks;
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                               Clipboard                                   */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 #undef KeyPress
 
-void TerminalDisplay::emitSelection(bool useXselection,bool appendReturn)
+void
+TerminalDisplay::emitSelection (bool useXselection, bool appendReturn)
 {
-    if ( !_screenWindow )
-        return;
-
-    // Paste Clipboard by simulating keypress events
-    QString text = QApplication::clipboard()->text(useXselection ? QClipboard::Selection :
-                                                                   QClipboard::Clipboard);
-    if(appendReturn)
-        text.append("\r");
-    if ( ! text.isEmpty() )
+  if (!_screenWindow)
+    return;
+
+  // Paste Clipboard by simulating keypress events
+  QString text =
+    QApplication::clipboard ()->
+    text (useXselection ? QClipboard::Selection : QClipboard::Clipboard);
+  if (appendReturn)
+    text.append ("\r");
+  if (!text.isEmpty ())
     {
-        text.replace('\n', '\r');
-        QKeyEvent e(QEvent::KeyPress, 0, Qt::NoModifier, text);
-        emit keyPressedSignal(&e); // expose as a big fat keypress event
-
-        _screenWindow->clearSelection();
+      text.replace ('\n', '\r');
+      QKeyEvent e (QEvent::KeyPress, 0, Qt::NoModifier, text);
+      emit keyPressedSignal (&e);	// expose as a big fat keypress event
+
+      _screenWindow->clearSelection ();
     }
 }
 
-void TerminalDisplay::setSelection(const QString& t)
+void
+TerminalDisplay::setSelection (const QString & t)
 {
-    QApplication::clipboard()->setText(t, QClipboard::Selection);
+  QApplication::clipboard ()->setText (t, QClipboard::Selection);
 }
 
-void TerminalDisplay::copyClipboard()
+void
+TerminalDisplay::copyClipboard ()
 {
-    if ( !_screenWindow )
-        return;
-
-    QString text = _screenWindow->selectedText(_preserveLineBreaks);
-    if (!text.isEmpty())
-        QApplication::clipboard()->setText(text);
+  if (!_screenWindow)
+    return;
+
+  QString text = _screenWindow->selectedText (_preserveLineBreaks);
+  if (!text.isEmpty ())
+    QApplication::clipboard ()->setText (text);
 }
 
-void TerminalDisplay::pasteClipboard()
+void
+TerminalDisplay::pasteClipboard ()
 {
-    emitSelection(false,false);
+  emitSelection (false, false);
 }
 
-void TerminalDisplay::pasteSelection()
+void
+TerminalDisplay::pasteSelection ()
 {
-    emitSelection(true,false);
+  emitSelection (true, false);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Keyboard                                   */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
-void TerminalDisplay::setFlowControlWarningEnabled( bool enable )
+void
+TerminalDisplay::setFlowControlWarningEnabled (bool enable)
+{
+  _flowControlWarningEnabled = enable;
+
+  // if the dialog is currently visible and the flow control warning has 
+  // been disabled then hide the dialog
+  if (!enable)
+    outputSuspended (false);
+}
+
+void
+TerminalDisplay::keyPressEvent (QKeyEvent * event)
 {
-    _flowControlWarningEnabled = enable;
-    
-    // if the dialog is currently visible and the flow control warning has 
-    // been disabled then hide the dialog
-    if (!enable)
-        outputSuspended(false);
-}
-
-void TerminalDisplay::keyPressEvent( QKeyEvent* event )
-{
-    bool emitKeyPressSignal = true;
-
-    if(event->modifiers() == Qt::ControlModifier)
+  bool emitKeyPressSignal = true;
+
+  if (event->modifiers () == Qt::ControlModifier)
+    {
+      switch (event->key ())
+	{
+	case Qt::Key_C:
+	  copyClipboard ();
+	  break;
+	case Qt::Key_V:
+	  pasteClipboard ();
+	  break;
+	};
+    }
+  else if (event->modifiers () == Qt::ShiftModifier)
     {
-        switch(event->key()) {
-        case Qt::Key_C:
-            copyClipboard();
-            break;
-        case Qt::Key_V:
-            pasteClipboard();
-            break;
-        };
-    } else if ( event->modifiers() == Qt::ShiftModifier ) {
-        bool update = true;
-
-        if ( event->key() == Qt::Key_PageUp )
-        {
-            _screenWindow->scrollBy( ScreenWindow::ScrollPages , -1 );
-        }
-        else if ( event->key() == Qt::Key_PageDown )
-        {
-            _screenWindow->scrollBy( ScreenWindow::ScrollPages , 1 );
-        }
-        else if ( event->key() == Qt::Key_Up )
-        {
-            _screenWindow->scrollBy( ScreenWindow::ScrollLines , -1 );
-        }
-        else if ( event->key() == Qt::Key_Down )
-        {
-            _screenWindow->scrollBy( ScreenWindow::ScrollLines , 1 );
-        }
-        else
-            update = false;
-
-        if ( update )
-        {
-            _screenWindow->setTrackOutput( _screenWindow->atEndOfOutput() );
-            
-            updateLineProperties();
-            updateImage();
-
-            // do not send key press to terminal
-            emitKeyPressSignal = false;
-        }
+      bool update = true;
+
+      if (event->key () == Qt::Key_PageUp)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollPages, -1);
+	}
+      else if (event->key () == Qt::Key_PageDown)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollPages, 1);
+	}
+      else if (event->key () == Qt::Key_Up)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollLines, -1);
+	}
+      else if (event->key () == Qt::Key_Down)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollLines, 1);
+	}
+      else
+	update = false;
+
+      if (update)
+	{
+	  _screenWindow->setTrackOutput (_screenWindow->atEndOfOutput ());
+
+	  updateLineProperties ();
+	  updateImage ();
+
+	  // do not send key press to terminal
+	  emitKeyPressSignal = false;
+	}
     }
 
-    _actSel=0; // Key stroke implies a screen update, so TerminalDisplay won't
-    // know where the current selection is.
-
-    if (_hasBlinkingCursor) 
+  _actSel = 0;			// Key stroke implies a screen update, so TerminalDisplay won't
+  // know where the current selection is.
+
+  if (_hasBlinkingCursor)
     {
-        _blinkCursorTimer->start(QApplication::cursorFlashTime() / 2);
-        if (_cursorBlinking)
-            blinkCursorEvent();
-        else
-            _cursorBlinking = false;
+      _blinkCursorTimer->start (QApplication::cursorFlashTime () / 2);
+      if (_cursorBlinking)
+	blinkCursorEvent ();
+      else
+	_cursorBlinking = false;
     }
 
-    if ( emitKeyPressSignal )
-        emit keyPressedSignal(event);
-
-    event->accept();
+  if (emitKeyPressSignal)
+    emit keyPressedSignal (event);
+
+  event->accept ();
 }
 
-void TerminalDisplay::inputMethodEvent( QInputMethodEvent* event )
+void
+TerminalDisplay::inputMethodEvent (QInputMethodEvent * event)
 {
-    QKeyEvent keyEvent(QEvent::KeyPress,0,(Qt::KeyboardModifiers)Qt::NoModifier,event->commitString());
-    emit keyPressedSignal(&keyEvent);
-
-    _inputMethodData.preeditString = event->preeditString();
-    update(preeditRect() | _inputMethodData.previousPreeditRect);
-    
-    event->accept();
+  QKeyEvent keyEvent (QEvent::KeyPress, 0,
+		      (Qt::KeyboardModifiers) Qt::NoModifier,
+		      event->commitString ());
+  emit keyPressedSignal (&keyEvent);
+
+  _inputMethodData.preeditString = event->preeditString ();
+  update (preeditRect () | _inputMethodData.previousPreeditRect);
+
+  event->accept ();
 }
-QVariant TerminalDisplay::inputMethodQuery( Qt::InputMethodQuery query ) const
+
+QVariant
+TerminalDisplay::inputMethodQuery (Qt::InputMethodQuery query) const
 {
-    const QPoint cursorPos = _screenWindow ? _screenWindow->cursorPosition() : QPoint(0,0);
-    switch ( query ) 
+  const QPoint cursorPos =
+    _screenWindow ? _screenWindow->cursorPosition () : QPoint (0, 0);
+  switch (query)
     {
     case Qt::ImMicroFocus:
-        return imageToWidget(QRect(cursorPos.x(),cursorPos.y(),1,1));
-        break;
+      return imageToWidget (QRect (cursorPos.x (), cursorPos.y (), 1, 1));
+      break;
     case Qt::ImFont:
-        return font();
-        break;
+      return font ();
+      break;
     case Qt::ImCursorPosition:
-        // return the cursor position within the current line
-        return cursorPos.x();
-        break;
+      // return the cursor position within the current line
+      return cursorPos.x ();
+      break;
     case Qt::ImSurroundingText:
-    {
-        // return the text from the current line
-        QString lineText;
-        QTextStream stream(&lineText);
-        PlainTextDecoder decoder;
-        decoder.begin(&stream);
-        decoder.decodeLine(&_image[loc(0,cursorPos.y())],_usedColumns,_lineProperties[cursorPos.y()]);
-        decoder.end();
-        return lineText;
+      {
+	// return the text from the current line
+	QString lineText;
+	QTextStream stream (&lineText);
+	PlainTextDecoder decoder;
+	decoder.begin (&stream);
+	decoder.decodeLine (&_image[loc (0, cursorPos.y ())], _usedColumns,
+			    _lineProperties[cursorPos.y ()]);
+	decoder.end ();
+	return lineText;
+      }
+      break;
+    case Qt::ImCurrentSelection:
+      return QString ();
+      break;
+    default:
+      break;
     }
-        break;
-    case Qt::ImCurrentSelection:
-        return QString();
-        break;
-    default:
-        break;
-    }
-
-    return QVariant();
+
+  return QVariant ();
 }
 
-bool TerminalDisplay::handleShortcutOverrideEvent(QKeyEvent* keyEvent)
+bool
+TerminalDisplay::handleShortcutOverrideEvent (QKeyEvent * keyEvent)
 {
-    int modifiers = keyEvent->modifiers();
-
-    //  When a possible shortcut combination is pressed, 
-    //  emit the overrideShortcutCheck() signal to allow the host
-    //  to decide whether the terminal should override it or not.
-    if (modifiers != Qt::NoModifier) 
+  int modifiers = keyEvent->modifiers ();
+
+  //  When a possible shortcut combination is pressed, 
+  //  emit the overrideShortcutCheck() signal to allow the host
+  //  to decide whether the terminal should override it or not.
+  if (modifiers != Qt::NoModifier)
     {
-        int modifierCount = 0;
-        unsigned int currentModifier = Qt::ShiftModifier;
-
-        while (currentModifier <= Qt::KeypadModifier)
-        {
-            if (modifiers & currentModifier)
-                modifierCount++;
-            currentModifier <<= 1;
-        }
-        if (modifierCount < 2) 
-        {
-            bool override = false;
-            emit overrideShortcutCheck(keyEvent,override);
-            if (override)
-            {
-                keyEvent->accept();
-                return true;
-            }
-        }
+      int modifierCount = 0;
+      unsigned int currentModifier = Qt::ShiftModifier;
+
+      while (currentModifier <= Qt::KeypadModifier)
+	{
+	  if (modifiers & currentModifier)
+	    modifierCount++;
+	  currentModifier <<= 1;
+	}
+      if (modifierCount < 2)
+	{
+	  bool override = false;
+	  emit overrideShortcutCheck (keyEvent, override);
+	  if (override)
+	    {
+	      keyEvent->accept ();
+	      return true;
+	    }
+	}
     }
 
-    // Override any of the following shortcuts because
-    // they are needed by the terminal
-    int keyCode = keyEvent->key() | modifiers;
-    switch ( keyCode )
+  // Override any of the following shortcuts because
+  // they are needed by the terminal
+  int keyCode = keyEvent->key () | modifiers;
+  switch (keyCode)
     {
-    // list is taken from the QLineEdit::event() code
+      // list is taken from the QLineEdit::event() code
     case Qt::Key_Tab:
     case Qt::Key_Delete:
     case Qt::Key_Home:
     case Qt::Key_End:
     case Qt::Key_Backspace:
     case Qt::Key_Left:
     case Qt::Key_Right:
-        keyEvent->accept();
-        return true;
+      keyEvent->accept ();
+      return true;
     }
-    return false;
+  return false;
 }
 
-bool TerminalDisplay::event(QEvent* event)
+bool
+TerminalDisplay::event (QEvent * event)
 {
-    bool eventHandled = false;
-    switch (event->type())
+  bool eventHandled = false;
+  switch (event->type ())
     {
     case QEvent::ShortcutOverride:
-        eventHandled = handleShortcutOverrideEvent((QKeyEvent*)event);
-        break;
+      eventHandled = handleShortcutOverrideEvent ((QKeyEvent *) event);
+      break;
     case QEvent::PaletteChange:
     case QEvent::ApplicationPaletteChange:
-        _scrollBar->setPalette( QApplication::palette() );
-        break;
+      _scrollBar->setPalette (QApplication::palette ());
+      break;
     default:
-        break;
+      break;
     }
-    return eventHandled ? true : QWidget::event(event);
+  return eventHandled ? true : QWidget::event (event);
 }
 
-void TerminalDisplay::setBellMode(int mode)
+void
+TerminalDisplay::setBellMode (int mode)
 {
-    _bellMode=mode;
+  _bellMode = mode;
 }
 
-void TerminalDisplay::enableBell()
+void
+TerminalDisplay::enableBell ()
 {
-    _allowBell = true;
+  _allowBell = true;
 }
 
-void TerminalDisplay::bell(const QString& message)
+void
+TerminalDisplay::bell (const QString & message)
 {
-    Q_UNUSED(message);
-    if (_bellMode==NoBell) return;
-
-    //limit the rate at which bells can occur
-    //...mainly for sound effects where rapid bells in sequence
-    //produce a horrible noise
-    if ( _allowBell )
+  Q_UNUSED (message);
+  if (_bellMode == NoBell)
+    return;
+
+  //limit the rate at which bells can occur
+  //...mainly for sound effects where rapid bells in sequence
+  //produce a horrible noise
+  if (_allowBell)
     {
-        _allowBell = false;
-        QTimer::singleShot(500,this,SLOT(enableBell()));
-
-        if (_bellMode==SystemBeepBell)
-        {
-            // TODO: This will need added back in at some point
-            //KNotification::beep();
-        }
-        else if (_bellMode==NotifyBell)
-        {
-            // TODO: This will need added back in at some point
-            //KNotification::event("BellVisible", message,QPixmap(),this);
-        }
-        else if (_bellMode==VisualBell)
-        {
-            swapColorTable();
-            QTimer::singleShot(200,this,SLOT(swapColorTable()));
-        }
+      _allowBell = false;
+      QTimer::singleShot (500, this, SLOT (enableBell ()));
+
+      if (_bellMode == SystemBeepBell)
+	{
+	  // TODO: This will need added back in at some point
+	  //KNotification::beep();
+	}
+      else if (_bellMode == NotifyBell)
+	{
+	  // TODO: This will need added back in at some point
+	  //KNotification::event("BellVisible", message,QPixmap(),this);
+	}
+      else if (_bellMode == VisualBell)
+	{
+	  swapColorTable ();
+	  QTimer::singleShot (200, this, SLOT (swapColorTable ()));
+	}
     }
 }
 
-void TerminalDisplay::swapColorTable()
+void
+TerminalDisplay::swapColorTable ()
 {
-    ColorEntry color = _colorTable[1];
-    _colorTable[1]=_colorTable[0];
-    _colorTable[0]= color;
-    _colorsInverted = !_colorsInverted;
-    update();
+  ColorEntry color = _colorTable[1];
+  _colorTable[1] = _colorTable[0];
+  _colorTable[0] = color;
+  _colorsInverted = !_colorsInverted;
+  update ();
 }
 
-void TerminalDisplay::clearImage()
+void
+TerminalDisplay::clearImage ()
 {
-    // We initialize _image[_imageSize] too. See makeImage()
-    for (int i = 0; i <= _imageSize; i++)
+  // We initialize _image[_imageSize] too. See makeImage()
+  for (int i = 0; i <= _imageSize; i++)
     {
-        _image[i].character = ' ';
-        _image[i].foregroundColor = CharacterColor(COLOR_SPACE_DEFAULT,
-                                                   DEFAULT_FORE_COLOR);
-        _image[i].backgroundColor = CharacterColor(COLOR_SPACE_DEFAULT,
-                                                   DEFAULT_BACK_COLOR);
-        _image[i].rendition = DEFAULT_RENDITION;
+      _image[i].character = ' ';
+      _image[i].foregroundColor = CharacterColor (COLOR_SPACE_DEFAULT,
+						  DEFAULT_FORE_COLOR);
+      _image[i].backgroundColor = CharacterColor (COLOR_SPACE_DEFAULT,
+						  DEFAULT_BACK_COLOR);
+      _image[i].rendition = DEFAULT_RENDITION;
     }
 }
 
-void TerminalDisplay::calcGeometry()
+void
+TerminalDisplay::calcGeometry ()
 {
-    _scrollBar->resize(_scrollBar->sizeHint().width(), contentsRect().height());
-    switch(_scrollbarLocation)
+  _scrollBar->resize (_scrollBar->sizeHint ().width (),
+		      contentsRect ().height ());
+  switch (_scrollbarLocation)
     {
-    case NoScrollBar :
-        _leftMargin = DEFAULT_LEFT_MARGIN;
-        _contentWidth = contentsRect().width() - 2 * DEFAULT_LEFT_MARGIN;
-        break;
-    case ScrollBarLeft :
-        _leftMargin = DEFAULT_LEFT_MARGIN + _scrollBar->width();
-        _contentWidth = contentsRect().width() - 2 * DEFAULT_LEFT_MARGIN - _scrollBar->width();
-        _scrollBar->move(contentsRect().topLeft());
-        break;
+    case NoScrollBar:
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth = contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN;
+      break;
+    case ScrollBarLeft:
+      _leftMargin = DEFAULT_LEFT_MARGIN + _scrollBar->width ();
+      _contentWidth =
+	contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN -
+	_scrollBar->width ();
+      _scrollBar->move (contentsRect ().topLeft ());
+      break;
     case ScrollBarRight:
-        _leftMargin = DEFAULT_LEFT_MARGIN;
-        _contentWidth = contentsRect().width()  - 2 * DEFAULT_LEFT_MARGIN - _scrollBar->width();
-        _scrollBar->move(contentsRect().topRight() - QPoint(_scrollBar->width()-1,0));
-        break;
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth =
+	contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN -
+	_scrollBar->width ();
+      _scrollBar->move (contentsRect ().topRight () -
+			QPoint (_scrollBar->width () - 1, 0));
+      break;
     }
 
-    _topMargin = DEFAULT_TOP_MARGIN;
-    _contentHeight = contentsRect().height() - 2 * DEFAULT_TOP_MARGIN + /* mysterious */ 1;
-
-    if (!_isFixedSize)
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _contentHeight =
+    contentsRect ().height () - 2 * DEFAULT_TOP_MARGIN + /* mysterious */ 1;
+
+  if (!_isFixedSize)
     {
-        // ensure that display is always at least one column wide
-        _columns = qMax(1,_contentWidth / _fontWidth);
-        _usedColumns = qMin(_usedColumns,_columns);
-
-        // ensure that display is always at least one line high
-        _lines = qMax(1,_contentHeight / _fontHeight);
-        _usedLines = qMin(_usedLines,_lines);
+      // ensure that display is always at least one column wide
+      _columns = qMax (1, _contentWidth / _fontWidth);
+      _usedColumns = qMin (_usedColumns, _columns);
+
+      // ensure that display is always at least one line high
+      _lines = qMax (1, _contentHeight / _fontHeight);
+      _usedLines = qMin (_usedLines, _lines);
     }
 }
 
-void TerminalDisplay::makeImage()
+void
+TerminalDisplay::makeImage ()
 {
-    calcGeometry();
-
-    // confirm that array will be of non-zero size, since the painting code
-    // assumes a non-zero array length
-    Q_ASSERT( _lines > 0 && _columns > 0 );
-    Q_ASSERT( _usedLines <= _lines && _usedColumns <= _columns );
-
-    _imageSize=_lines*_columns;
-
-    // We over-commit one character so that we can be more relaxed in dealing with
-    // certain boundary conditions: _image[_imageSize] is a valid but unused position
-    _image = new Character[_imageSize+1];
-
-    clearImage();
+  calcGeometry ();
+
+  // confirm that array will be of non-zero size, since the painting code
+  // assumes a non-zero array length
+  Q_ASSERT (_lines > 0 && _columns > 0);
+  Q_ASSERT (_usedLines <= _lines && _usedColumns <= _columns);
+
+  _imageSize = _lines * _columns;
+
+  // We over-commit one character so that we can be more relaxed in dealing with
+  // certain boundary conditions: _image[_imageSize] is a valid but unused position
+  _image = new Character[_imageSize + 1];
+
+  clearImage ();
 }
 
 // calculate the needed size, this must be synced with calcGeometry()
-void TerminalDisplay::setSize(int columns, int lines)
+void
+TerminalDisplay::setSize (int columns, int lines)
 {
-    int scrollBarWidth = _scrollBar->isHidden() ? 0 : _scrollBar->sizeHint().width();
-    int horizontalMargin = 2 * DEFAULT_LEFT_MARGIN;
-    int verticalMargin = 2 * DEFAULT_TOP_MARGIN;
-
-    QSize newSize = QSize( horizontalMargin + scrollBarWidth + (columns * _fontWidth)  ,
-                          verticalMargin + (lines * _fontHeight)   );
-
-    if ( newSize != size() )
+  int scrollBarWidth =
+    _scrollBar->isHidden ()? 0 : _scrollBar->sizeHint ().width ();
+  int horizontalMargin = 2 * DEFAULT_LEFT_MARGIN;
+  int verticalMargin = 2 * DEFAULT_TOP_MARGIN;
+
+  QSize newSize =
+    QSize (horizontalMargin + scrollBarWidth + (columns * _fontWidth),
+	   verticalMargin + (lines * _fontHeight));
+
+  if (newSize != size ())
     {
-        _size = newSize;
-        updateGeometry();
+      _size = newSize;
+      updateGeometry ();
     }
 }
 
-void TerminalDisplay::setFixedSize(int cols, int lins)
+void
+TerminalDisplay::setFixedSize (int cols, int lins)
 {
-    _isFixedSize = true;
-
-    //ensure that display is at least one line by one column in size
-    _columns = qMax(1,cols);
-    _lines = qMax(1,lins);
-    _usedColumns = qMin(_usedColumns,_columns);
-    _usedLines = qMin(_usedLines,_lines);
-
-    if (_image)
+  _isFixedSize = true;
+
+  //ensure that display is at least one line by one column in size
+  _columns = qMax (1, cols);
+  _lines = qMax (1, lins);
+  _usedColumns = qMin (_usedColumns, _columns);
+  _usedLines = qMin (_usedLines, _lines);
+
+  if (_image)
     {
-        delete[] _image;
-        makeImage();
+      delete[]_image;
+      makeImage ();
     }
-    setSize(cols, lins);
-    QWidget::setFixedSize(_size);
+  setSize (cols, lins);
+  QWidget::setFixedSize (_size);
 }
 
-QSize TerminalDisplay::sizeHint() const
+QSize
+TerminalDisplay::sizeHint () const
 {
-    return _size;
+  return _size;
 }
 
 
 /* --------------------------------------------------------------------- */
 /*                                                                       */
 /* Drag & Drop                                                           */
 /*                                                                       */
 /* --------------------------------------------------------------------- */
 
-void TerminalDisplay::dragEnterEvent(QDragEnterEvent* event)
+void
+TerminalDisplay::dragEnterEvent (QDragEnterEvent * event)
 {
-    if (event->mimeData()->hasFormat("text/plain"))
-        event->acceptProposedAction();
+  if (event->mimeData ()->hasFormat ("text/plain"))
+    event->acceptProposedAction ();
 }
 
-void TerminalDisplay::dropEvent(QDropEvent* event)
+void
+TerminalDisplay::dropEvent (QDropEvent * event)
 {
-    //KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
-
-    QString dropText;
-    /*
-  if (!urls.isEmpty()) 
-  {
-    for ( int i = 0 ; i < urls.count() ; i++ ) 
+  //KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
+
+  QString dropText;
+  /*
+     if (!urls.isEmpty()) 
+     {
+     for ( int i = 0 ; i < urls.count() ; i++ ) 
+     {
+     KUrl url = KIO::NetAccess::mostLocalUrl( urls[i] , 0 );
+     QString urlText;
+
+     if (url.isLocalFile())
+     urlText = url.path(); 
+     else
+     urlText = url.url();
+
+     // in future it may be useful to be able to insert file names with drag-and-drop
+     // without quoting them (this only affects paths with spaces in) 
+     urlText = KShell::quoteArg(urlText);
+
+     dropText += urlText;
+
+     if ( i != urls.count()-1 ) 
+     dropText += ' ';
+     }
+     }
+     else 
+     {
+     dropText = event->mimeData()->text();
+     }
+   */
+
+  if (event->mimeData ()->hasFormat ("text/plain"))
     {
-        KUrl url = KIO::NetAccess::mostLocalUrl( urls[i] , 0 );
-        QString urlText;
-
-        if (url.isLocalFile())
-            urlText = url.path(); 
-        else
-            urlText = url.url();
-
-        // in future it may be useful to be able to insert file names with drag-and-drop
-        // without quoting them (this only affects paths with spaces in) 
-        urlText = KShell::quoteArg(urlText);
-
-        dropText += urlText;
-
-        if ( i != urls.count()-1 ) 
-            dropText += ' ';
-    }
-  }
-  else 
-  {
-    dropText = event->mimeData()->text();
-  }
-  */
-
-    if(event->mimeData()->hasFormat("text/plain"))
-    {
-        emit sendStringToEmu(dropText.toLocal8Bit());
+      emit sendStringToEmu (dropText.toLocal8Bit ());
     }
 }
 
-void TerminalDisplay::doDrag()
+void
+TerminalDisplay::doDrag ()
 {
-    dragInfo.state = diDragging;
-    dragInfo.dragObject = new QDrag(this);
-    QMimeData *mimeData = new QMimeData;
-    mimeData->setText(QApplication::clipboard()->text(QClipboard::Selection));
-    dragInfo.dragObject->setMimeData(mimeData);
-    dragInfo.dragObject->start(Qt::CopyAction);
-    // Don't delete the QTextDrag object.  Qt will delete it when it's done with it.
+  dragInfo.state = diDragging;
+  dragInfo.dragObject = new QDrag (this);
+  QMimeData *mimeData = new QMimeData;
+  mimeData->setText (QApplication::clipboard ()->
+		     text (QClipboard::Selection));
+  dragInfo.dragObject->setMimeData (mimeData);
+  dragInfo.dragObject->start (Qt::CopyAction);
+  // Don't delete the QTextDrag object.  Qt will delete it when it's done with it.
 }
 
-void TerminalDisplay::outputSuspended(bool suspended)
+void
+TerminalDisplay::outputSuspended (bool suspended)
 {
-    //create the label when this function is first called
-    if (!_outputSuspendedLabel)
+  //create the label when this function is first called
+  if (!_outputSuspendedLabel)
     {
-        //This label includes a link to an English language website
-        //describing the 'flow control' (Xon/Xoff) feature found in almost
-        //all terminal emulators.
-        //If there isn't a suitable article available in the target language the link
-        //can simply be removed.
-        _outputSuspendedLabel = new QLabel( QString("<qt>Output has been "
-                                                    "<a href=\"http://en.wikipedia.org/wiki/Flow_control\">suspended</a>"
-                                                    " by pressing Ctrl+S."
-                                                    "  Press <b>Ctrl+Q</b> to resume.</qt>"),
-                                           this );
-
-        QPalette palette(_outputSuspendedLabel->palette());
-        //KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
-        _outputSuspendedLabel->setPalette(palette);
-        _outputSuspendedLabel->setAutoFillBackground(true);
-        _outputSuspendedLabel->setBackgroundRole(QPalette::Base);
-        _outputSuspendedLabel->setFont(QApplication::font());
-        _outputSuspendedLabel->setContentsMargins(5, 5, 5, 5);
-
-        //enable activation of "Xon/Xoff" link in label
-        _outputSuspendedLabel->setTextInteractionFlags(Qt::LinksAccessibleByMouse |
-                                                       Qt::LinksAccessibleByKeyboard);
-        _outputSuspendedLabel->setOpenExternalLinks(true);
-        _outputSuspendedLabel->setVisible(false);
-
-        _gridLayout->addWidget(_outputSuspendedLabel);
-        _gridLayout->addItem( new QSpacerItem(0,0,QSizePolicy::Expanding,
-                                              QSizePolicy::Expanding),
-                             1,0);
+      //This label includes a link to an English language website
+      //describing the 'flow control' (Xon/Xoff) feature found in almost
+      //all terminal emulators.
+      //If there isn't a suitable article available in the target language the link
+      //can simply be removed.
+      _outputSuspendedLabel = new QLabel (QString ("<qt>Output has been "
+						   "<a href=\"http://en.wikipedia.org/wiki/Flow_control\">suspended</a>"
+						   " by pressing Ctrl+S."
+						   "  Press <b>Ctrl+Q</b> to resume.</qt>"),
+					  this);
+
+      QPalette palette (_outputSuspendedLabel->palette ());
+      //KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
+      _outputSuspendedLabel->setPalette (palette);
+      _outputSuspendedLabel->setAutoFillBackground (true);
+      _outputSuspendedLabel->setBackgroundRole (QPalette::Base);
+      _outputSuspendedLabel->setFont (QApplication::font ());
+      _outputSuspendedLabel->setContentsMargins (5, 5, 5, 5);
+
+      //enable activation of "Xon/Xoff" link in label
+      _outputSuspendedLabel->
+	setTextInteractionFlags (Qt::LinksAccessibleByMouse | Qt::
+				 LinksAccessibleByKeyboard);
+      _outputSuspendedLabel->setOpenExternalLinks (true);
+      _outputSuspendedLabel->setVisible (false);
+
+      _gridLayout->addWidget (_outputSuspendedLabel);
+      _gridLayout->addItem (new QSpacerItem (0, 0, QSizePolicy::Expanding,
+					     QSizePolicy::Expanding), 1, 0);
 
     }
 
-    _outputSuspendedLabel->setVisible(suspended);
+  _outputSuspendedLabel->setVisible (suspended);
 }
 
-uint TerminalDisplay::lineSpacing() const
-{
-    return _lineSpacing;
-}
-
-void TerminalDisplay::setLineSpacing(uint i)
+uint
+TerminalDisplay::lineSpacing () const
 {
-    _lineSpacing = i;
-    setVTFont(font()); // Trigger an update.
+  return _lineSpacing;
 }
 
-AutoScrollHandler::AutoScrollHandler(QWidget* parent)
-    : QObject(parent)
-    , _timerId(0)
+void
+TerminalDisplay::setLineSpacing (uint i)
 {
-    //parent->installEventFilter(this);
+  _lineSpacing = i;
+  setVTFont (font ());		// Trigger an update.
+}
+
+AutoScrollHandler::AutoScrollHandler (QWidget * parent):QObject (parent),
+_timerId (0)
+{
+  //parent->installEventFilter(this);
 }
-void AutoScrollHandler::timerEvent(QTimerEvent* event)
+
+void
+AutoScrollHandler::timerEvent (QTimerEvent * event)
 {
-    if (event->timerId() != _timerId)
-        return;
-
-    QMouseEvent mouseEvent(    QEvent::MouseMove,
-                           widget()->mapFromGlobal(QCursor::pos()),
-                           Qt::NoButton,
-                           Qt::LeftButton,
-                           Qt::NoModifier);
-
-    QApplication::sendEvent(widget(),&mouseEvent);    
+  if (event->timerId () != _timerId)
+    return;
+
+  QMouseEvent mouseEvent (QEvent::MouseMove,
+			  widget ()->mapFromGlobal (QCursor::pos ()),
+			  Qt::NoButton, Qt::LeftButton, Qt::NoModifier);
+
+  QApplication::sendEvent (widget (), &mouseEvent);
 }
-bool AutoScrollHandler::eventFilter(QObject* watched,QEvent* event)
+
+bool
+AutoScrollHandler::eventFilter (QObject * watched, QEvent * event)
 {
-    Q_ASSERT( watched == parent() );
-    Q_UNUSED( watched );
-
-    QMouseEvent* mouseEvent = (QMouseEvent*)event;
-    switch (event->type())
+  Q_ASSERT (watched == parent ());
+  Q_UNUSED (watched);
+
+  QMouseEvent *mouseEvent = (QMouseEvent *) event;
+  switch (event->type ())
     {
     case QEvent::MouseMove:
-    {
-        bool mouseInWidget = widget()->rect().contains(mouseEvent->pos());
-
-        if (mouseInWidget)
-        {
-            if (_timerId)
-                killTimer(_timerId);
-            _timerId = 0;
-        }
-        else
-        {
-            if (!_timerId && (mouseEvent->buttons() & Qt::LeftButton))
-                _timerId = startTimer(100);
-        }
-        break;
-    }
+      {
+	bool mouseInWidget = widget ()->rect ().contains (mouseEvent->pos ());
+
+	if (mouseInWidget)
+	  {
+	    if (_timerId)
+	      killTimer (_timerId);
+	    _timerId = 0;
+	  }
+	else
+	  {
+	    if (!_timerId && (mouseEvent->buttons () & Qt::LeftButton))
+	      _timerId = startTimer (100);
+	  }
+	break;
+      }
     case QEvent::MouseButtonRelease:
-        if (_timerId && (mouseEvent->buttons() & ~Qt::LeftButton))
-        {
-            killTimer(_timerId);
-            _timerId = 0;
-        }
-        break;
+      if (_timerId && (mouseEvent->buttons () & ~Qt::LeftButton))
+	{
+	  killTimer (_timerId);
+	  _timerId = 0;
+	}
+      break;
     default:
-        break;
+      break;
     };
 
-    return false;
+  return false;
 }
diff --git a/gui/src/terminal/TerminalDisplay.h b/gui/src/terminal/TerminalDisplay.h
--- a/gui/src/terminal/TerminalDisplay.h
+++ b/gui/src/terminal/TerminalDisplay.h
@@ -54,763 +54,827 @@ class ScreenWindow;
  * A widget which displays output from a terminal emulation and sends input keypresses and mouse activity
  * to the terminal.
  *
  * When the terminal emulation receives new output from the program running in the terminal, 
  * it will update the display by calling updateImage().
  *
  * TODO More documentation
  */
-class TerminalDisplay : public QWidget
+class TerminalDisplay:public QWidget
 {
-   Q_OBJECT
-
-public:
+Q_OBJECT public:
     /** Constructs a new terminal display widget with the specified parent. */
-    TerminalDisplay(QWidget *parent=0);
-    virtual ~TerminalDisplay();
+  TerminalDisplay (QWidget * parent = 0);
+  virtual ~ TerminalDisplay ();
 
     /** Returns the terminal color palette used by the display. */
-    const ColorEntry* colorTable() const;
+  const ColorEntry *colorTable () const;
     /** Sets the terminal color palette used by the display. */
-    void setColorTable(const ColorEntry table[]);
+  void setColorTable (const ColorEntry table[]);
     /**
      * Sets the seed used to generate random colors for the display
      * (in color schemes that support them).
      */
-    void setRandomSeed(uint seed);
+  void setRandomSeed (uint seed);
     /**
      * Returns the seed used to generate random colors for the display
      * (in color schemes that support them).
      */
-    uint randomSeed() const;
+  uint randomSeed () const;
 
     /** Sets the opacity of the terminal display. */
-    void setOpacity(qreal opacity);
+  void setOpacity (qreal opacity);
 
     /** 
      * This enum describes the location where the scroll bar is positioned in the display widget.
      */
-    enum ScrollBarPosition 
-    { 
-        /** Do not show the scroll bar. */
-        NoScrollBar=0, 
-        /** Show the scroll bar on the left side of the display. */
-        ScrollBarLeft=1, 
-        /** Show the scroll bar on the right side of the display. */
-        ScrollBarRight=2 
-    };
+  enum ScrollBarPosition
+  {
+	/** Do not show the scroll bar. */
+    NoScrollBar = 0,
+	/** Show the scroll bar on the left side of the display. */
+    ScrollBarLeft = 1,
+	/** Show the scroll bar on the right side of the display. */
+    ScrollBarRight = 2
+  };
     /** 
      * Specifies whether the terminal display has a vertical scroll bar, and if so whether it
      * is shown on the left or right side of the display.
      */
-    void setScrollBarPosition(ScrollBarPosition position);
+  void setScrollBarPosition (ScrollBarPosition position);
 
     /** 
      * Sets the current position and range of the display's scroll bar.
      *
      * @param cursor The position of the scroll bar's thumb.
      * @param lines The maximum value of the scroll bar.
      */
-    void setScroll(int cursor, int lines);
+  void setScroll (int cursor, int lines);
 
     /** 
      * Returns the display's filter chain.  When the image for the display is updated,
      * the text is passed through each filter in the chain.  Each filter can define
      * hotspots which correspond to certain strings (such as URLs or particular words).
      * Depending on the type of the hotspots created by the filter ( returned by Filter::Hotspot::type() )
      * the view will draw visual cues such as underlines on mouse-over for links or translucent
      * rectangles for markers.
      *
      * To add a new filter to the view, call:
      *      viewWidget->filterChain()->addFilter( filterObject );
      */
-    FilterChain* filterChain() const;
+  FilterChain *filterChain () const;
 
     /** 
      * Updates the filters in the display's filter chain.  This will cause
      * the hotspots to be updated to match the current image.
      *
      * WARNING:  This function can be expensive depending on the 
      * image size and number of filters in the filterChain()
      *
      * TODO - This API does not really allow efficient usage.  Revise it so
      * that the processing can be done in a better way.
      *
      * eg:
      *      - Area of interest may be known ( eg. mouse cursor hovering
      *      over an area )
-     */  
-    void processFilters();
+     */
+  void processFilters ();
 
     /** 
      * Returns a list of menu actions created by the filters for the content
      * at the given @p position.
      */
-    QList<QAction*> filterActions(const QPoint& position);
+    QList < QAction * >filterActions (const QPoint & position);
 
     /** Returns true if the cursor is set to blink or false otherwise. */
-    bool blinkingCursor() { return _hasBlinkingCursor; }
+  bool blinkingCursor ()
+  {
+    return _hasBlinkingCursor;
+  }
     /** Specifies whether or not the cursor blinks. */
-    void setBlinkingCursor(bool blink);
+  void setBlinkingCursor (bool blink);
 
     /** Specifies whether or not text can blink. */
-    void setBlinkingTextEnabled(bool blink);
+  void setBlinkingTextEnabled (bool blink);
 
-    void setCtrlDrag(bool enable) { _ctrlDrag=enable; }
-    bool ctrlDrag() { return _ctrlDrag; }
+  void setCtrlDrag (bool enable)
+  {
+    _ctrlDrag = enable;
+  }
+  bool ctrlDrag ()
+  {
+    return _ctrlDrag;
+  }
 
     /** 
      *  This enum describes the methods for selecting text when
       *  the user triple-clicks within the display. 
       */
-    enum TripleClickMode
-    {
-        /** Select the whole line underneath the cursor. */
-        SelectWholeLine,
-        /** Select from the current cursor position to the end of the line. */
-        SelectForwardsFromCursor
-    };
-    /** Sets how the text is selected when the user triple clicks within the display. */    
-    void setTripleClickMode(TripleClickMode mode) { _tripleClickMode = mode; }
+  enum TripleClickMode
+  {
+	/** Select the whole line underneath the cursor. */
+    SelectWholeLine,
+	/** Select from the current cursor position to the end of the line. */
+    SelectForwardsFromCursor
+  };
+    /** Sets how the text is selected when the user triple clicks within the display. */
+  void setTripleClickMode (TripleClickMode mode)
+  {
+    _tripleClickMode = mode;
+  }
     /** See setTripleClickSelectionMode() */
-    TripleClickMode tripleClickMode() { return _tripleClickMode; }
+  TripleClickMode tripleClickMode ()
+  {
+    return _tripleClickMode;
+  }
 
-    void setLineSpacing(uint);
-    uint lineSpacing() const;
+  void setLineSpacing (uint);
+  uint lineSpacing () const;
 
-    void emitSelection(bool useXselection,bool appendReturn);
+  void emitSelection (bool useXselection, bool appendReturn);
 
     /**
      * This enum describes the available shapes for the keyboard cursor.
      * See setKeyboardCursorShape()
      */
-    enum KeyboardCursorShape
-    {
-        /** A rectangular block which covers the entire area of the cursor character. */
-        BlockCursor,
-        /** 
+  enum KeyboardCursorShape
+  {
+	/** A rectangular block which covers the entire area of the cursor character. */
+    BlockCursor,
+	/** 
          * A single flat line which occupies the space at the bottom of the cursor
          * character's area.
          */
-        UnderlineCursor,
-        /** 
+    UnderlineCursor,
+	/** 
          * An cursor shaped like the capital letter 'I', similar to the IBeam 
          * cursor used in Qt/KDE text editors.
          */
-        IBeamCursor
-    };
+    IBeamCursor
+  };
     /** 
      * Sets the shape of the keyboard cursor.  This is the cursor drawn   
      * at the position in the terminal where keyboard input will appear.
      *
      * In addition the terminal display widget also has a cursor for 
      * the mouse pointer, which can be set using the QWidget::setCursor()
      * method.
      *
      * Defaults to BlockCursor
      */
-    void setKeyboardCursorShape(KeyboardCursorShape shape);
+  void setKeyboardCursorShape (KeyboardCursorShape shape);
     /**
      * Returns the shape of the keyboard cursor.  See setKeyboardCursorShape()
      */
-    KeyboardCursorShape keyboardCursorShape() const;
+  KeyboardCursorShape keyboardCursorShape () const;
 
     /**
      * Sets the color used to draw the keyboard cursor.  
      *
      * The keyboard cursor defaults to using the foreground color of the character
      * underneath it.
      *
      * @param useForegroundColor If true, the cursor color will change to match
      * the foreground color of the character underneath it as it is moved, in this
      * case, the @p color parameter is ignored and the color of the character
      * under the cursor is inverted to ensure that it is still readable.
      * @param color The color to use to draw the cursor.  This is only taken into
      * account if @p useForegroundColor is false.
      */
-    void setKeyboardCursorColor(bool useForegroundColor , const QColor& color);
+  void setKeyboardCursorColor (bool useForegroundColor, const QColor & color);
 
     /** 
      * Returns the color of the keyboard cursor, or an invalid color if the keyboard
      * cursor color is set to change according to the foreground color of the character
      * underneath it. 
      */
-    QColor keyboardCursorColor() const;
+  QColor keyboardCursorColor () const;
 
     /**
      * Returns the number of lines of text which can be displayed in the widget.
      *
      * This will depend upon the height of the widget and the current font.
      * See fontHeight()
      */
-    int  lines()   { return _lines;   }
+  int lines ()
+  {
+    return _lines;
+  }
     /**
      * Returns the number of characters of text which can be displayed on
      * each line in the widget.
      *
      * This will depend upon the width of the widget and the current font.
      * See fontWidth()
      */
-    int  columns() { return _columns; }
+  int columns ()
+  {
+    return _columns;
+  }
 
     /**
      * Returns the height of the characters in the font used to draw the text in the display.
      */
-    int  fontHeight()   { return _fontHeight;   }
+  int fontHeight ()
+  {
+    return _fontHeight;
+  }
     /**
      * Returns the width of the characters in the display.  
      * This assumes the use of a fixed-width font.
      */
-    int  fontWidth()    { return _fontWidth; }
+  int fontWidth ()
+  {
+    return _fontWidth;
+  }
 
-    void setSize(int cols, int lins);
-    void setFixedSize(int cols, int lins);
-    
-    // reimplemented
-    QSize sizeHint() const;
+  void setSize (int cols, int lins);
+  void setFixedSize (int cols, int lins);
+
+  // reimplemented
+  QSize sizeHint () const;
 
     /**
      * Sets which characters, in addition to letters and numbers, 
      * are regarded as being part of a word for the purposes
      * of selecting words in the display by double clicking on them.
      *
      * The word boundaries occur at the first and last characters which
      * are either a letter, number, or a character in @p wc
      *
      * @param wc An array of characters which are to be considered parts
      * of a word ( in addition to letters and numbers ).
      */
-    void setWordCharacters(const QString& wc);
+  void setWordCharacters (const QString & wc);
     /** 
      * Returns the characters which are considered part of a word for the 
      * purpose of selecting words in the display with the mouse.
      *
      * @see setWordCharacters()
      */
-    QString wordCharacters() { return _wordCharacters; }
+  QString wordCharacters ()
+  {
+    return _wordCharacters;
+  }
 
     /** 
      * Sets the type of effect used to alert the user when a 'bell' occurs in the 
      * terminal session.
      *
      * The terminal session can trigger the bell effect by calling bell() with
      * the alert message.
      */
-    void setBellMode(int mode);
+  void setBellMode (int mode);
     /** 
      * Returns the type of effect used to alert the user when a 'bell' occurs in
      * the terminal session.
      * 
      * See setBellMode()
      */
-    int bellMode() { return _bellMode; }
+  int bellMode ()
+  {
+    return _bellMode;
+  }
 
     /**
      * This enum describes the different types of sounds and visual effects which
      * can be used to alert the user when a 'bell' occurs in the terminal
      * session.
      */
-    enum BellMode
-    { 
-        /** A system beep. */
-        SystemBeepBell=0, 
-        /** 
+  enum BellMode
+  {
+	/** A system beep. */
+    SystemBeepBell = 0,
+	/** 
          * KDE notification.  This may play a sound, show a passive popup
          * or perform some other action depending on the user's settings.
          */
-        NotifyBell=1, 
-        /** A silent, visual bell (eg. inverting the display's colors briefly) */
-        VisualBell=2, 
-        /** No bell effects */
-        NoBell=3 
-    };
+    NotifyBell = 1,
+	/** A silent, visual bell (eg. inverting the display's colors briefly) */
+    VisualBell = 2,
+	/** No bell effects */
+    NoBell = 3
+  };
 
-    void setSelection(const QString &t);
+  void setSelection (const QString & t);
 
     /** 
      * Reimplemented.  Has no effect.  Use setVTFont() to change the font
      * used to draw characters in the display.
      */
-    virtual void setFont(const QFont &);
+  virtual void setFont (const QFont &);
 
     /** Returns the font used to draw characters in the display */
-    QFont getVTFont() { return font(); }
+  QFont getVTFont ()
+  {
+    return font ();
+  }
 
     /** 
      * Sets the font used to draw the display.  Has no effect if @p font
      * is larger than the size of the display itself.    
      */
-    void setVTFont(const QFont& font);
+  void setVTFont (const QFont & font);
 
     /**
      * Specified whether anti-aliasing of text in the terminal display
      * is enabled or not.  Defaults to enabled.
      */
-    static void setAntialias( bool antialias ) { _antialiasText = antialias; }
+  static void setAntialias (bool antialias)
+  {
+    _antialiasText = antialias;
+  }
     /** 
      * Returns true if anti-aliasing of text in the terminal is enabled.
      */
-    static bool antialias()                 { return _antialiasText;   }
+  static bool antialias ()
+  {
+    return _antialiasText;
+  }
 
     /**
      * Specifies whether characters with intense colors should be rendered
      * as bold. Defaults to true.
      */
-    void setBoldIntense(bool value) { _boldIntense = value; }
+  void setBoldIntense (bool value)
+  {
+    _boldIntense = value;
+  }
     /**
      * Returns true if characters with intense colors are rendered in bold.
      */
-    bool getBoldIntense() { return _boldIntense; }
-    
+  bool getBoldIntense ()
+  {
+    return _boldIntense;
+  }
+
     /**
      * Sets whether or not the current height and width of the 
      * terminal in lines and columns is displayed whilst the widget
      * is being resized.
      */
-    void setTerminalSizeHint(bool on) { _terminalSizeHint=on; }
+  void setTerminalSizeHint (bool on)
+  {
+    _terminalSizeHint = on;
+  }
     /** 
      * Returns whether or not the current height and width of
      * the terminal in lines and columns is displayed whilst the widget
      * is being resized.
      */
-    bool terminalSizeHint() { return _terminalSizeHint; }
+  bool terminalSizeHint ()
+  {
+    return _terminalSizeHint;
+  }
     /** 
      * Sets whether the terminal size display is shown briefly
      * after the widget is first shown.
      *
      * See setTerminalSizeHint() , isTerminalSizeHint()
      */
-    void setTerminalSizeStartup(bool on) { _terminalSizeStartup=on; }
+  void setTerminalSizeStartup (bool on)
+  {
+    _terminalSizeStartup = on;
+  }
 
     /**
      * Sets the status of the BiDi rendering inside the terminal display.
      * Defaults to disabled.
      */
-    void setBidiEnabled(bool set) { _bidiEnabled=set; }
+  void setBidiEnabled (bool set)
+  {
+    _bidiEnabled = set;
+  }
     /**
      * Returns the status of the BiDi rendering in this widget.
      */
-    bool isBidiEnabled() { return _bidiEnabled; }
+  bool isBidiEnabled ()
+  {
+    return _bidiEnabled;
+  }
 
     /**
      * Sets the terminal screen section which is displayed in this widget.
      * When updateImage() is called, the display fetches the latest character image from the
      * the associated terminal screen window.
      *
      * In terms of the model-view paradigm, the ScreenWindow is the model which is rendered
      * by the TerminalDisplay.
      */
-    void setScreenWindow( ScreenWindow* window );
+  void setScreenWindow (ScreenWindow * window);
     /** Returns the terminal screen section which is displayed in this widget.  See setScreenWindow() */
-    ScreenWindow* screenWindow() const;
+  ScreenWindow *screenWindow () const;
 
-    static bool HAVE_TRANSPARENCY;
+  static bool HAVE_TRANSPARENCY;
 
-public slots:
-
+  public slots:
     /** 
      * Causes the terminal display to fetch the latest character image from the associated
      * terminal screen ( see setScreenWindow() ) and redraw the display.
      */
-    void updateImage(); 
+  void updateImage ();
     /**
      * Causes the terminal display to fetch the latest line status flags from the 
      * associated terminal screen ( see setScreenWindow() ).  
-     */ 
-    void updateLineProperties();
+     */
+  void updateLineProperties ();
 
     /** Copies the selected text to the clipboard. */
-    void copyClipboard();
+  void copyClipboard ();
     /** 
      * Pastes the content of the clipboard into the 
      * display.
      */
-    void pasteClipboard();
+  void pasteClipboard ();
     /**
      * Pastes the content of the selection into the
      * display.
      */
-    void pasteSelection();
+  void pasteSelection ();
 
     /** 
        * Changes whether the flow control warning box should be shown when the flow control
        * stop key (Ctrl+S) are pressed.
        */
-    void setFlowControlWarningEnabled(bool enabled);
+  void setFlowControlWarningEnabled (bool enabled);
     /** 
      * Returns true if the flow control warning box is enabled. 
      * See outputSuspended() and setFlowControlWarningEnabled()
      */
-    bool flowControlWarningEnabled() const
-    { return _flowControlWarningEnabled; }
+  bool flowControlWarningEnabled () const
+  {
+    return _flowControlWarningEnabled;
+  }
 
     /** 
      * Causes the widget to display or hide a message informing the user that terminal
      * output has been suspended (by using the flow control key combination Ctrl+S)
      *
      * @param suspended True if terminal output has been suspended and the warning message should
      *                     be shown or false to indicate that terminal output has been resumed and that
      *                     the warning message should disappear.
-     */ 
-    void outputSuspended(bool suspended);
+     */
+  void outputSuspended (bool suspended);
 
     /**
      * Sets whether the program whoose output is being displayed in the view
      * is interested in mouse events.
      *
      * If this is set to true, mouse signals will be emitted by the view when the user clicks, drags
      * or otherwise moves the mouse inside the view.
      * The user interaction needed to create selections will also change, and the user will be required
      * to hold down the shift key to create a selection or perform other mouse activities inside the 
      * view area - since the program running in the terminal is being allowed to handle normal mouse
      * events itself.
      *
      * @param usesMouse Set to true if the program running in the terminal is interested in mouse events
      * or false otherwise.
      */
-    void setUsesMouse(bool usesMouse);
-  
+  void setUsesMouse (bool usesMouse);
+
     /** See setUsesMouse() */
-    bool usesMouse() const;
+  bool usesMouse () const;
 
     /** 
      * Shows a notification that a bell event has occurred in the terminal.
      * TODO: More documentation here
      */
-    void bell(const QString& message);
+  void bell (const QString & message);
 
     /** 
      * Sets the background of the display to the specified color. 
      * @see setColorTable(), setForegroundColor() 
      */
-    void setBackgroundColor(const QColor& color);
+  void setBackgroundColor (const QColor & color);
 
     /** 
      * Sets the text of the display to the specified color. 
      * @see setColorTable(), setBackgroundColor()
      */
-    void setForegroundColor(const QColor& color);
+  void setForegroundColor (const QColor & color);
 
 signals:
 
     /**
      * Emitted when the user presses a key whilst the terminal widget has focus.
      */
-    void keyPressedSignal(QKeyEvent *e);
+  void keyPressedSignal (QKeyEvent * e);
 
     /** 
      * A mouse event occurred.
      * @param button The mouse button (0 for left button, 1 for middle button, 2 for right button, 3 for release)
      * @param column The character column where the event occurred
      * @param line The character row where the event occurred
      * @param eventType The type of event.  0 for a mouse press / release or 1 for mouse motion
      */
-    void mouseSignal(int button, int column, int line, int eventType);
-    void changedFontMetricSignal(int height, int width);
-    void changedContentSizeSignal(int height, int width);
+  void mouseSignal (int button, int column, int line, int eventType);
+  void changedFontMetricSignal (int height, int width);
+  void changedContentSizeSignal (int height, int width);
 
     /** 
      * Emitted when the user right clicks on the display, or right-clicks with the Shift
      * key held down if usesMouse() is true.
      *
      * This can be used to display a context menu.
      */
-    void configureRequest(const QPoint& position);
+  void configureRequest (const QPoint & position);
 
     /**
      * When a shortcut which is also a valid terminal key sequence is pressed while 
      * the terminal widget  has focus, this signal is emitted to allow the host to decide 
      * whether the shortcut should be overridden.  
      * When the shortcut is overridden, the key sequence will be sent to the terminal emulation instead
      * and the action associated with the shortcut will not be triggered.
      *
      * @p override is set to false by default and the shortcut will be triggered as normal.
      */
-    void overrideShortcutCheck(QKeyEvent* keyEvent,bool& override);
+  void overrideShortcutCheck (QKeyEvent * keyEvent, bool & override);
 
-   void isBusySelecting(bool);
-   void sendStringToEmu(const char*);
+  void isBusySelecting (bool);
+  void sendStringToEmu (const char *);
 
 protected:
-    virtual bool event( QEvent * );
+  virtual bool event (QEvent *);
 
-    virtual void paintEvent( QPaintEvent * );
+  virtual void paintEvent (QPaintEvent *);
 
-    virtual void showEvent(QShowEvent*);
-    virtual void hideEvent(QHideEvent*);
-    virtual void resizeEvent(QResizeEvent*);
+  virtual void showEvent (QShowEvent *);
+  virtual void hideEvent (QHideEvent *);
+  virtual void resizeEvent (QResizeEvent *);
 
-    virtual void fontChange(const QFont &font);
-    virtual void focusInEvent(QFocusEvent* event);
-    virtual void focusOutEvent(QFocusEvent* event);
-    virtual void keyPressEvent(QKeyEvent* event);
-    virtual void mouseDoubleClickEvent(QMouseEvent* ev);
-    virtual void mousePressEvent( QMouseEvent* );
-    virtual void mouseReleaseEvent( QMouseEvent* );
-    virtual void mouseMoveEvent( QMouseEvent* );
-    virtual void extendSelection( const QPoint& pos );
-    virtual void wheelEvent( QWheelEvent* );
+  virtual void fontChange (const QFont & font);
+  virtual void focusInEvent (QFocusEvent * event);
+  virtual void focusOutEvent (QFocusEvent * event);
+  virtual void keyPressEvent (QKeyEvent * event);
+  virtual void mouseDoubleClickEvent (QMouseEvent * ev);
+  virtual void mousePressEvent (QMouseEvent *);
+  virtual void mouseReleaseEvent (QMouseEvent *);
+  virtual void mouseMoveEvent (QMouseEvent *);
+  virtual void extendSelection (const QPoint & pos);
+  virtual void wheelEvent (QWheelEvent *);
 
-    virtual bool focusNextPrevChild( bool next );
-    
-    // drag and drop
-    virtual void dragEnterEvent(QDragEnterEvent* event);
-    virtual void dropEvent(QDropEvent* event);
-    void doDrag();
-    enum DragState { diNone, diPending, diDragging };
+  virtual bool focusNextPrevChild (bool next);
+
+  // drag and drop
+  virtual void dragEnterEvent (QDragEnterEvent * event);
+  virtual void dropEvent (QDropEvent * event);
+  void doDrag ();
+  enum DragState
+  { diNone, diPending, diDragging };
 
-    struct _dragInfo {
-      DragState       state;
-      QPoint          start;
-      QDrag           *dragObject;
-    } dragInfo;
+  struct _dragInfo
+  {
+    DragState state;
+    QPoint start;
+    QDrag *dragObject;
+  } dragInfo;
 
-    // classifies the 'ch' into one of three categories
-    // and returns a character to indicate which category it is in
-    //
-    //     - A space (returns ' ') 
-    //     - Part of a word (returns 'a')
-    //     - Other characters (returns the input character)
-    QChar charClass(QChar ch) const;
+  // classifies the 'ch' into one of three categories
+  // and returns a character to indicate which category it is in
+  //
+  //     - A space (returns ' ') 
+  //     - Part of a word (returns 'a')
+  //     - Other characters (returns the input character)
+  QChar charClass (QChar ch) const;
 
-    void clearImage();
-
-    void mouseTripleClickEvent(QMouseEvent* ev);
+  void clearImage ();
 
-    // reimplemented
-    virtual void inputMethodEvent ( QInputMethodEvent* event );
-    virtual QVariant inputMethodQuery( Qt::InputMethodQuery query ) const;
+  void mouseTripleClickEvent (QMouseEvent * ev);
 
-protected slots:
+  // reimplemented
+  virtual void inputMethodEvent (QInputMethodEvent * event);
+  virtual QVariant inputMethodQuery (Qt::InputMethodQuery query) const;
 
-    void scrollBarPositionChanged(int value);
-    void blinkEvent();
-    void blinkCursorEvent();
-    
-    //Renables bell noises and visuals.  Used to disable further bells for a short period of time
-    //after emitting the first in a sequence of bell events.
-    void enableBell();
+  protected slots:void scrollBarPositionChanged (int value);
+  void blinkEvent ();
+  void blinkCursorEvent ();
 
-private slots:
+  //Renables bell noises and visuals.  Used to disable further bells for a short period of time
+  //after emitting the first in a sequence of bell events.
+  void enableBell ();
 
-    void swapColorTable();
-    void tripleClickTimeout();  // resets possibleTripleClick
+  private slots:void swapColorTable ();
+  void tripleClickTimeout ();	// resets possibleTripleClick
 
 private:
 
-    // -- Drawing helpers --
+  // -- Drawing helpers --
 
-    // divides the part of the display specified by 'rect' into
-    // fragments according to their colors and styles and calls
-    // drawTextFragment() to draw the fragments 
-    void drawContents(QPainter &paint, const QRect &rect);
-    // draws a section of text, all the text in this section
-    // has a common color and style
-    void drawTextFragment(QPainter& painter, const QRect& rect, 
-                          const QString& text, const Character* style); 
-    // draws the background for a text fragment
-    // if useOpacitySetting is true then the color's alpha value will be set to
-    // the display's transparency (set with setOpacity()), otherwise the background
-    // will be drawn fully opaque
-    void drawBackground(QPainter& painter, const QRect& rect, const QColor& color,
-                        bool useOpacitySetting);
-    // draws the cursor character
-    void drawCursor(QPainter& painter, const QRect& rect , const QColor& foregroundColor, 
-                                       const QColor& backgroundColor , bool& invertColors);
-    // draws the characters or line graphics in a text fragment
-    void drawCharacters(QPainter& painter, const QRect& rect,  const QString& text, 
-                                           const Character* style, bool invertCharacterColor);
-    // draws a string of line graphics
-    void drawLineCharString(QPainter& painter, int x, int y, 
-                            const QString& str, const Character* attributes);
+  // divides the part of the display specified by 'rect' into
+  // fragments according to their colors and styles and calls
+  // drawTextFragment() to draw the fragments 
+  void drawContents (QPainter & paint, const QRect & rect);
+  // draws a section of text, all the text in this section
+  // has a common color and style
+  void drawTextFragment (QPainter & painter, const QRect & rect,
+			 const QString & text, const Character * style);
+  // draws the background for a text fragment
+  // if useOpacitySetting is true then the color's alpha value will be set to
+  // the display's transparency (set with setOpacity()), otherwise the background
+  // will be drawn fully opaque
+  void drawBackground (QPainter & painter, const QRect & rect,
+		       const QColor & color, bool useOpacitySetting);
+  // draws the cursor character
+  void drawCursor (QPainter & painter, const QRect & rect,
+		   const QColor & foregroundColor,
+		   const QColor & backgroundColor, bool & invertColors);
+  // draws the characters or line graphics in a text fragment
+  void drawCharacters (QPainter & painter, const QRect & rect,
+		       const QString & text, const Character * style,
+		       bool invertCharacterColor);
+  // draws a string of line graphics
+  void drawLineCharString (QPainter & painter, int x, int y,
+			   const QString & str, const Character * attributes);
 
-    // draws the preedit string for input methods
-    void drawInputMethodPreeditString(QPainter& painter , const QRect& rect);
+  // draws the preedit string for input methods
+  void drawInputMethodPreeditString (QPainter & painter, const QRect & rect);
 
-    // --
+  // --
 
-    // maps an area in the character image to an area on the widget 
-    QRect imageToWidget(const QRect& imageArea) const;
+  // maps an area in the character image to an area on the widget 
+  QRect imageToWidget (const QRect & imageArea) const;
 
-    // maps a point on the widget to the position ( ie. line and column ) 
-    // of the character at that point.
-    void getCharacterPosition(const QPoint& widgetPoint,int& line,int& column) const;
-
-    // the area where the preedit string for input methods will be draw
-    QRect preeditRect() const;
+  // maps a point on the widget to the position ( ie. line and column ) 
+  // of the character at that point.
+  void getCharacterPosition (const QPoint & widgetPoint, int &line,
+			     int &column) const;
 
-    // shows a notification window in the middle of the widget indicating the terminal's
-    // current size in columns and lines
-    void showResizeNotification();
+  // the area where the preedit string for input methods will be draw
+  QRect preeditRect () const;
 
-    // scrolls the image by a number of lines.  
-    // 'lines' may be positive ( to scroll the image down ) 
-    // or negative ( to scroll the image up )
-    // 'region' is the part of the image to scroll - currently only
-    // the top, bottom and height of 'region' are taken into account,
-    // the left and right are ignored.
-    void scrollImage(int lines , const QRect& region);
+  // shows a notification window in the middle of the widget indicating the terminal's
+  // current size in columns and lines
+  void showResizeNotification ();
 
-    void calcGeometry();
-    void propagateSize();
-    void updateImageSize();
-    void makeImage();
-    
-    void paintFilters(QPainter& painter);
+  // scrolls the image by a number of lines.  
+  // 'lines' may be positive ( to scroll the image down ) 
+  // or negative ( to scroll the image up )
+  // 'region' is the part of the image to scroll - currently only
+  // the top, bottom and height of 'region' are taken into account,
+  // the left and right are ignored.
+  void scrollImage (int lines, const QRect & region);
+
+  void calcGeometry ();
+  void propagateSize ();
+  void updateImageSize ();
+  void makeImage ();
 
-    // returns a region covering all of the areas of the widget which contain
-    // a hotspot
-    QRegion hotSpotRegion() const;
+  void paintFilters (QPainter & painter);
+
+  // returns a region covering all of the areas of the widget which contain
+  // a hotspot
+  QRegion hotSpotRegion () const;
 
-    // returns the position of the cursor in columns and lines
-    QPoint cursorPosition() const;
+  // returns the position of the cursor in columns and lines
+  QPoint cursorPosition () const;
 
-    // redraws the cursor
-    void updateCursor();
+  // redraws the cursor
+  void updateCursor ();
 
-    bool handleShortcutOverrideEvent(QKeyEvent* event);
+  bool handleShortcutOverrideEvent (QKeyEvent * event);
 
-    // the window onto the terminal screen which this display
-    // is currently showing.  
-    QPointer<ScreenWindow> _screenWindow;
+  // the window onto the terminal screen which this display
+  // is currently showing.  
+  QPointer < ScreenWindow > _screenWindow;
 
-    bool _allowBell;
+  bool _allowBell;
 
-    QGridLayout* _gridLayout;
+  QGridLayout *_gridLayout;
 
-    bool _fixedFont; // has fixed pitch
-    int  _fontHeight;     // height
-    int  _fontWidth;     // width
-    int  _fontAscent;     // ascend
-    bool _boldIntense;   // Whether intense colors should be rendered with bold font
+  bool _fixedFont;		// has fixed pitch
+  int _fontHeight;		// height
+  int _fontWidth;		// width
+  int _fontAscent;		// ascend
+  bool _boldIntense;		// Whether intense colors should be rendered with bold font
 
-    int _leftMargin;    // offset
-    int _topMargin;    // offset
+  int _leftMargin;		// offset
+  int _topMargin;		// offset
 
-    int _lines;      // the number of lines that can be displayed in the widget
-    int _columns;    // the number of columns that can be displayed in the widget
-    
-    int _usedLines;  // the number of lines that are actually being used, this will be less
-                    // than 'lines' if the character image provided with setImage() is smaller
-                    // than the maximum image size which can be displayed
+  int _lines;			// the number of lines that can be displayed in the widget
+  int _columns;			// the number of columns that can be displayed in the widget
+
+  int _usedLines;		// the number of lines that are actually being used, this will be less
+  // than 'lines' if the character image provided with setImage() is smaller
+  // than the maximum image size which can be displayed
+
+  int _usedColumns;		// the number of columns that are actually being used, this will be less
+  // than 'columns' if the character image provided with setImage() is smaller
+  // than the maximum image size which can be displayed
 
-    int _usedColumns; // the number of columns that are actually being used, this will be less
-                     // than 'columns' if the character image provided with setImage() is smaller
-                     // than the maximum image size which can be displayed
-    
-    int _contentHeight;
-    int _contentWidth;
-    Character* _image; // [lines][columns]
-               // only the area [usedLines][usedColumns] in the image contains valid data
+  int _contentHeight;
+  int _contentWidth;
+  Character *_image;		// [lines][columns]
+  // only the area [usedLines][usedColumns] in the image contains valid data
 
-    int _imageSize;
-    QVector<LineProperty> _lineProperties;
+  int _imageSize;
+  QVector < LineProperty > _lineProperties;
 
-    ColorEntry _colorTable[TABLE_COLORS];
-    uint _randomSeed;
+  ColorEntry _colorTable[TABLE_COLORS];
+  uint _randomSeed;
 
-    bool _resizing;
-    bool _terminalSizeHint;
-    bool _terminalSizeStartup;
-    bool _bidiEnabled;
-    bool _mouseMarks;
+  bool _resizing;
+  bool _terminalSizeHint;
+  bool _terminalSizeStartup;
+  bool _bidiEnabled;
+  bool _mouseMarks;
 
-    QPoint  _iPntSel; // initial selection point
-    QPoint  _pntSel; // current selection point
-    QPoint  _tripleSelBegin; // help avoid flicker
-    int     _actSel; // selection state
-    bool    _wordSelectionMode;
-    bool    _lineSelectionMode;
-    bool    _preserveLineBreaks;
-    bool    _columnSelectionMode;
+  QPoint _iPntSel;		// initial selection point
+  QPoint _pntSel;		// current selection point
+  QPoint _tripleSelBegin;	// help avoid flicker
+  int _actSel;			// selection state
+  bool _wordSelectionMode;
+  bool _lineSelectionMode;
+  bool _preserveLineBreaks;
+  bool _columnSelectionMode;
 
-    QClipboard*  _clipboard;
-    QScrollBar* _scrollBar;
-    ScrollBarPosition _scrollbarLocation;
-    QString     _wordCharacters;
-    int         _bellMode;
+  QClipboard *_clipboard;
+  QScrollBar *_scrollBar;
+  ScrollBarPosition _scrollbarLocation;
+  QString _wordCharacters;
+  int _bellMode;
 
-    bool _blinking;   // hide text in paintEvent
-    bool _hasBlinker; // has characters to blink
-    bool _cursorBlinking;     // hide cursor in paintEvent
-    bool _hasBlinkingCursor;  // has blinking cursor enabled
-    bool _allowBlinkingText;  // allow text to blink
-    bool _ctrlDrag;           // require Ctrl key for drag
-    TripleClickMode _tripleClickMode;
-    bool _isFixedSize; //Columns / lines are locked.
-    QTimer* _blinkTimer;  // active when hasBlinker
-    QTimer* _blinkCursorTimer;  // active when hasBlinkingCursor
+  bool _blinking;		// hide text in paintEvent
+  bool _hasBlinker;		// has characters to blink
+  bool _cursorBlinking;		// hide cursor in paintEvent
+  bool _hasBlinkingCursor;	// has blinking cursor enabled
+  bool _allowBlinkingText;	// allow text to blink
+  bool _ctrlDrag;		// require Ctrl key for drag
+  TripleClickMode _tripleClickMode;
+  bool _isFixedSize;		//Columns / lines are locked.
+  QTimer *_blinkTimer;		// active when hasBlinker
+  QTimer *_blinkCursorTimer;	// active when hasBlinkingCursor
 
-    KMenu* _drop;
-    QString _dropText;
-    int _dndFileCount;
+  KMenu *_drop;
+  QString _dropText;
+  int _dndFileCount;
 
-    bool _possibleTripleClick;  // is set in mouseDoubleClickEvent and deleted
-                               // after QApplication::doubleClickInterval() delay
+  bool _possibleTripleClick;	// is set in mouseDoubleClickEvent and deleted
+  // after QApplication::doubleClickInterval() delay
 
 
-    QLabel* _resizeWidget;
-    QTimer* _resizeTimer;
+  QLabel *_resizeWidget;
+  QTimer *_resizeTimer;
 
-    bool _flowControlWarningEnabled;
+  bool _flowControlWarningEnabled;
 
-    //widgets related to the warning message that appears when the user presses Ctrl+S to suspend
-    //terminal output - informing them what has happened and how to resume output
-    QLabel* _outputSuspendedLabel; 
-        
-    uint _lineSpacing;
+  //widgets related to the warning message that appears when the user presses Ctrl+S to suspend
+  //terminal output - informing them what has happened and how to resume output
+  QLabel *_outputSuspendedLabel;
 
-    bool _colorsInverted; // true during visual bell
+  uint _lineSpacing;
+
+  bool _colorsInverted;		// true during visual bell
 
-    QSize _size;
-    
-    QRgb _blendColor;
+  QSize _size;
+
+  QRgb _blendColor;
 
-    // list of filters currently applied to the display.  used for links and
-    // search highlight
-    TerminalImageFilterChain* _filterChain;
-    QRegion _mouseOverHotspotArea;
+  // list of filters currently applied to the display.  used for links and
+  // search highlight
+  TerminalImageFilterChain *_filterChain;
+  QRegion _mouseOverHotspotArea;
 
-    KeyboardCursorShape _cursorShape;
+  KeyboardCursorShape _cursorShape;
 
-    // custom cursor color.  if this is invalid then the foreground
-    // color of the character under the cursor is used
-    QColor _cursorColor;  
+  // custom cursor color.  if this is invalid then the foreground
+  // color of the character under the cursor is used
+  QColor _cursorColor;
 
 
-    struct InputMethodData
-    {
-        QString preeditString;
-        QRect previousPreeditRect;
-    };
-    InputMethodData _inputMethodData;
+  struct InputMethodData
+  {
+    QString preeditString;
+    QRect previousPreeditRect;
+  };
+  InputMethodData _inputMethodData;
 
-    static bool _antialiasText;   // do we antialias or not
+  static bool _antialiasText;	// do we antialias or not
 
-    //the delay in milliseconds between redrawing blinking text
-    static const int TEXT_BLINK_DELAY = 500;
-    static const int DEFAULT_LEFT_MARGIN = 1;
-    static const int DEFAULT_TOP_MARGIN = 1;
+  //the delay in milliseconds between redrawing blinking text
+  static const int TEXT_BLINK_DELAY = 500;
+  static const int DEFAULT_LEFT_MARGIN = 1;
+  static const int DEFAULT_TOP_MARGIN = 1;
 
 public:
-    static void setTransparencyEnabled(bool enable)
-    {
-        HAVE_TRANSPARENCY = enable;
-    }
+  static void setTransparencyEnabled (bool enable)
+  {
+    HAVE_TRANSPARENCY = enable;
+  }
 };
 
-class AutoScrollHandler : public QObject
+class AutoScrollHandler:public QObject
 {
-Q_OBJECT
-
-public:
-    AutoScrollHandler(QWidget* parent);
+Q_OBJECT public:
+  AutoScrollHandler (QWidget * parent);
 protected:
-    virtual void timerEvent(QTimerEvent* event);
-    virtual bool eventFilter(QObject* watched,QEvent* event);
+  virtual void timerEvent (QTimerEvent * event);
+  virtual bool eventFilter (QObject * watched, QEvent * event);
 private:
-    QWidget* widget() const { return static_cast<QWidget*>(parent()); }
-    int _timerId;
+    QWidget * widget () const
+  {
+    return static_cast < QWidget * >(parent ());
+  }
+  int _timerId;
 };
 
 
 #endif // TERMINALDISPLAY_H
diff --git a/gui/src/terminal/Vt102Emulation.cpp b/gui/src/terminal/Vt102Emulation.cpp
--- a/gui/src/terminal/Vt102Emulation.cpp
+++ b/gui/src/terminal/Vt102Emulation.cpp
@@ -22,69 +22,72 @@
 
 // Own
 #include "Vt102Emulation.h"
 
 
 // this allows konsole to be compiled without XKB and XTEST extensions
 // even though it might be available on a particular system.
 #if defined(AVOID_XKB)
-    #undef HAVE_XKB
+#undef HAVE_XKB
 #endif
 
 #if defined(HAVE_XKB)
-    void scrolllock_set_off();
-    void scrolllock_set_on();
+void scrolllock_set_off ();
+void scrolllock_set_on ();
 #endif
 
 // Standard 
 #include <stdio.h>
 #include <unistd.h>
 #include <assert.h>
 
 // Qt
 #include <QtCore/QEvent>
 #include <QtGui/QKeyEvent>
 #include <QtCore/QByteRef>
 
 // Konsole
 #include "KeyboardTranslator.h"
 #include "Screen.h"
 
-Vt102Emulation::Vt102Emulation() 
-    : Emulation(),
-     _titleUpdateTimer(new QTimer(this))
+Vt102Emulation::Vt102Emulation ():Emulation (),
+_titleUpdateTimer (new QTimer (this))
 {
-  _titleUpdateTimer->setSingleShot(true);
-  QObject::connect(_titleUpdateTimer , SIGNAL(timeout()) , this , SLOT(updateTitle()));
+  _titleUpdateTimer->setSingleShot (true);
+  QObject::connect (_titleUpdateTimer, SIGNAL (timeout ()), this,
+		    SLOT (updateTitle ()));
 
-  initTokenizer();
-  reset();
+  initTokenizer ();
+  reset ();
+}
+
+Vt102Emulation::~Vt102Emulation ()
+{
 }
 
-Vt102Emulation::~Vt102Emulation()
-{}
-
-void Vt102Emulation::clearEntireScreen()
+void
+Vt102Emulation::clearEntireScreen ()
 {
-  _currentScreen->clearEntireScreen();
-  bufferedUpdate(); 
+  _currentScreen->clearEntireScreen ();
+  bufferedUpdate ();
 }
 
-void Vt102Emulation::reset()
+void
+Vt102Emulation::reset ()
 {
-  resetTokenizer();
-  resetModes();
-  resetCharset(0);
-  _screen[0]->reset();
-  resetCharset(1);
-  _screen[1]->reset();
-  setCodec(LocaleCodec);
- 
-  bufferedUpdate();
+  resetTokenizer ();
+  resetModes ();
+  resetCharset (0);
+  _screen[0]->reset ();
+  resetCharset (1);
+  _screen[1]->reset ();
+  setCodec (LocaleCodec);
+
+  bufferedUpdate ();
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                     Processing the incoming byte stream                   */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
@@ -162,76 +165,81 @@ void Vt102Emulation::reset()
 
 /* The tokenizer's state
 
    The state is represented by the buffer (tokenBuffer, tokenBufferPos),
    and accompanied by decoded arguments kept in (argv,argc).
    Note that they are kept internal in the tokenizer.
 */
 
-void Vt102Emulation::resetTokenizer()
+void
+Vt102Emulation::resetTokenizer ()
 {
-  tokenBufferPos = 0; 
-  argc = 0; 
-  argv[0] = 0; 
+  tokenBufferPos = 0;
+  argc = 0;
+  argv[0] = 0;
   argv[1] = 0;
 }
 
-void Vt102Emulation::addDigit(int digit)
+void
+Vt102Emulation::addDigit (int digit)
 {
   if (argv[argc] < MAX_ARGUMENT)
-      argv[argc] = 10*argv[argc] + digit;
+    argv[argc] = 10 * argv[argc] + digit;
 }
 
-void Vt102Emulation::addArgument()
+void
+Vt102Emulation::addArgument ()
 {
-  argc = qMin(argc+1,MAXARGS-1);
+  argc = qMin (argc + 1, MAXARGS - 1);
   argv[argc] = 0;
 }
 
-void Vt102Emulation::addToCurrentToken(int cc)
+void
+Vt102Emulation::addToCurrentToken (int cc)
 {
   tokenBuffer[tokenBufferPos] = cc;
-  tokenBufferPos = qMin(tokenBufferPos+1,MAX_TOKEN_LENGTH-1);
+  tokenBufferPos = qMin (tokenBufferPos + 1, MAX_TOKEN_LENGTH - 1);
 }
 
 // Character Class flags used while decoding
 
-#define CTL  1  // Control character
-#define CHR  2  // Printable character
-#define CPN  4  // TODO: Document me 
-#define DIG  8  // Digit
-#define SCS 16  // TODO: Document me  
-#define GRP 32  // TODO: Document me
-#define CPS 64  // Character which indicates end of window resize
-                // escape sequence '\e[8;<row>;<col>t'
+#define CTL  1			// Control character
+#define CHR  2			// Printable character
+#define CPN  4			// TODO: Document me
+#define DIG  8			// Digit
+#define SCS 16			// TODO: Document me
+#define GRP 32			// TODO: Document me
+#define CPS 64			// Character which indicates end of window resize
+		// escape sequence '\e[8;<row>;<col>t'
 
-void Vt102Emulation::initTokenizer()
-{ 
-  int i; 
-  quint8* s;
-  for(i = 0;i < 256; ++i) 
+void
+Vt102Emulation::initTokenizer ()
+{
+  int i;
+  quint8 *s;
+  for (i = 0; i < 256; ++i)
     charClass[i] = 0;
-  for(i = 0;i < 32; ++i) 
+  for (i = 0; i < 32; ++i)
     charClass[i] |= CTL;
-  for(i = 32;i < 256; ++i) 
+  for (i = 32; i < 256; ++i)
     charClass[i] |= CHR;
-  for(s = (quint8*)"@ABCDGHILMPSTXZcdfry"; *s; ++s) 
+  for (s = (quint8 *) "@ABCDGHILMPSTXZcdfry"; *s; ++s)
     charClass[*s] |= CPN;
   // resize = \e[8;<row>;<col>t
-  for(s = (quint8*)"t"; *s; ++s) 
+  for (s = (quint8 *) "t"; *s; ++s)
     charClass[*s] |= CPS;
-  for(s = (quint8*)"0123456789"; *s; ++s) 
+  for (s = (quint8 *) "0123456789"; *s; ++s)
     charClass[*s] |= DIG;
-  for(s = (quint8*)"()+*%"; *s; ++s) 
+  for (s = (quint8 *) "()+*%"; *s; ++s)
     charClass[*s] |= SCS;
-  for(s = (quint8*)"()+*#[]%"; *s; ++s) 
+  for (s = (quint8 *) "()+*#[]%"; *s; ++s)
     charClass[*s] |= GRP;
 
-  resetTokenizer();
+  resetTokenizer ();
 }
 
 /* Ok, here comes the nasty part of the decoder.
 
    Instead of keeping an explicit state, we deduce it from the
    token scanned so far. It is then immediately combined with
    the current character to form a scanning decision.
 
@@ -260,154 +268,229 @@ void Vt102Emulation::initTokenizer()
 #define Xpe        (tokenBufferPos >= 2 && tokenBuffer[1] == ']')
 #define Xte        (Xpe      && cc ==  7 )
 #define ces(C)     (cc < 256 && (charClass[cc] & (C)) == (C) && !Xte)
 
 #define ESC 27
 #define CNTL(c) ((c)-'@')
 
 // process an incoming unicode character
-void Vt102Emulation::receiveChar(int cc)
-{ 
-  if (cc == 127) 
-    return; //VT100: ignore.
-
-  if (ces(CTL))
-  { 
-    // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
-    // This means, they do neither a resetTokenizer() nor a pushToToken(). Some of them, do
-    // of course. Guess this originates from a weakly layered handling of the X-on
-    // X-off protocol, which comes really below this level.
-    if (cc == CNTL('X') || cc == CNTL('Z') || cc == ESC) 
-        resetTokenizer(); //VT100: CAN or SUB
-    if (cc != ESC)    
-    { 
-        processToken(TY_CTL(cc+'@' ),0,0); 
-        return; 
-    }
-  }
-  // advance the state
-  addToCurrentToken(cc); 
+void
+Vt102Emulation::receiveChar (int cc)
+{
+  if (cc == 127)
+    return;			//VT100: ignore.
 
-  int* s = tokenBuffer;
-  int  p = tokenBufferPos;
+  if (ces (CTL))
+    {
+      // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
+      // This means, they do neither a resetTokenizer() nor a pushToToken(). Some of them, do
+      // of course. Guess this originates from a weakly layered handling of the X-on
+      // X-off protocol, which comes really below this level.
+      if (cc == CNTL ('X') || cc == CNTL ('Z') || cc == ESC)
+	resetTokenizer ();	//VT100: CAN or SUB
+      if (cc != ESC)
+	{
+	  processToken (TY_CTL (cc + '@'), 0, 0);
+	  return;
+	}
+    }
+  // advance the state
+  addToCurrentToken (cc);
 
-  if (getMode(MODE_Ansi)) 
-  {
-    if (lec(1,0,ESC)) { return; }
-    if (lec(1,0,ESC+128)) { s[0] = ESC; receiveChar('['); return; }
-    if (les(2,1,GRP)) { return; }
-    if (Xte         ) { processWindowAttributeChange(); resetTokenizer(); return; }
-    if (Xpe         ) { return; }
-    if (lec(3,2,'?')) { return; }
-    if (lec(3,2,'>')) { return; }
-    if (lec(3,2,'!')) { return; }
-    if (lun(       )) { processToken( TY_CHR(), applyCharset(cc), 0);   resetTokenizer(); return; }
-    if (lec(2,0,ESC)) { processToken( TY_ESC(s[1]), 0, 0);              resetTokenizer(); return; }
-    if (les(3,1,SCS)) { processToken( TY_ESC_CS(s[1],s[2]), 0, 0);      resetTokenizer(); return; }
-    if (lec(3,1,'#')) { processToken( TY_ESC_DE(s[2]), 0, 0);           resetTokenizer(); return; }
-    if (eps(    CPN)) { processToken( TY_CSI_PN(cc), argv[0],argv[1]);  resetTokenizer(); return; }
-
-    // resize = \e[8;<row>;<col>t
-    if (eps(CPS)) 
-    { 
-        processToken( TY_CSI_PS(cc, argv[0]), argv[1], argv[2]);   
-        resetTokenizer(); 
-        return; 
-    }
+  int *s = tokenBuffer;
+  int p = tokenBufferPos;
 
-    if (epe(   )) { processToken( TY_CSI_PE(cc), 0, 0); resetTokenizer(); return; }
-    if (ees(DIG)) { addDigit(cc-'0'); return; }
-    if (eec(';')) { addArgument();    return; }
-    for (int i=0;i<=argc;i++)
+  if (getMode (MODE_Ansi))
     {
-        if (epp())  
-            processToken( TY_CSI_PR(cc,argv[i]), 0, 0);
-        else if (egt())   
-            processToken( TY_CSI_PG(cc), 0, 0); // spec. case for ESC]>0c or ESC]>c
-        else if (cc == 'm' && argc - i >= 4 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 2)
-        { 
-            // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
-            i += 2;
-            processToken( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_RGB, (argv[i] << 16) | (argv[i+1] << 8) | argv[i+2]);
-            i += 2;
-        }
-        else if (cc == 'm' && argc - i >= 2 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 5)
-        { 
-            // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
-            i += 2;
-            processToken( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_256, argv[i]);
-        }
-        else
-            processToken( TY_CSI_PS(cc,argv[i]), 0, 0);
+      if (lec (1, 0, ESC))
+	{
+	  return;
+	}
+      if (lec (1, 0, ESC + 128))
+	{
+	  s[0] = ESC;
+	  receiveChar ('[');
+	  return;
+	}
+      if (les (2, 1, GRP))
+	{
+	  return;
+	}
+      if (Xte)
+	{
+	  processWindowAttributeChange ();
+	  resetTokenizer ();
+	  return;
+	}
+      if (Xpe)
+	{
+	  return;
+	}
+      if (lec (3, 2, '?'))
+	{
+	  return;
+	}
+      if (lec (3, 2, '>'))
+	{
+	  return;
+	}
+      if (lec (3, 2, '!'))
+	{
+	  return;
+	}
+      if (lun ())
+	{
+	  processToken (TY_CHR (), applyCharset (cc), 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (2, 0, ESC))
+	{
+	  processToken (TY_ESC (s[1]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (les (3, 1, SCS))
+	{
+	  processToken (TY_ESC_CS (s[1], s[2]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (3, 1, '#'))
+	{
+	  processToken (TY_ESC_DE (s[2]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (eps (CPN))
+	{
+	  processToken (TY_CSI_PN (cc), argv[0], argv[1]);
+	  resetTokenizer ();
+	  return;
+	}
+
+      // resize = \e[8;<row>;<col>t
+      if (eps (CPS))
+	{
+	  processToken (TY_CSI_PS (cc, argv[0]), argv[1], argv[2]);
+	  resetTokenizer ();
+	  return;
+	}
+
+      if (epe ())
+	{
+	  processToken (TY_CSI_PE (cc), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (ees (DIG))
+	{
+	  addDigit (cc - '0');
+	  return;
+	}
+      if (eec (';'))
+	{
+	  addArgument ();
+	  return;
+	}
+      for (int i = 0; i <= argc; i++)
+	{
+	  if (epp ())
+	    processToken (TY_CSI_PR (cc, argv[i]), 0, 0);
+	  else if (egt ())
+	    processToken (TY_CSI_PG (cc), 0, 0);	// spec. case for ESC]>0c or ESC]>c
+	  else if (cc == 'm' && argc - i >= 4
+		   && (argv[i] == 38 || argv[i] == 48) && argv[i + 1] == 2)
+	    {
+	      // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
+	      i += 2;
+	      processToken (TY_CSI_PS (cc, argv[i - 2]), COLOR_SPACE_RGB,
+			    (argv[i] << 16) | (argv[i + 1] << 8) | argv[i +
+									2]);
+	      i += 2;
+	    }
+	  else if (cc == 'm' && argc - i >= 2
+		   && (argv[i] == 38 || argv[i] == 48) && argv[i + 1] == 5)
+	    {
+	      // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
+	      i += 2;
+	      processToken (TY_CSI_PS (cc, argv[i - 2]), COLOR_SPACE_256,
+			    argv[i]);
+	    }
+	  else
+	    processToken (TY_CSI_PS (cc, argv[i]), 0, 0);
+	}
+      resetTokenizer ();
     }
-    resetTokenizer();
-  }
-  else 
-  {
-    // VT52 Mode
-    if (lec(1,0,ESC))                                                      
-        return;
-    if (les(1,0,CHR)) 
-    { 
-        processToken( TY_CHR(), s[0], 0); 
-        resetTokenizer(); 
-        return; 
+  else
+    {
+      // VT52 Mode
+      if (lec (1, 0, ESC))
+	return;
+      if (les (1, 0, CHR))
+	{
+	  processToken (TY_CHR (), s[0], 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (2, 1, 'Y'))
+	return;
+      if (lec (3, 1, 'Y'))
+	return;
+      if (p < 4)
+	{
+	  processToken (TY_VT52 (s[1]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      processToken (TY_VT52 (s[1]), s[2], s[3]);
+      resetTokenizer ();
+      return;
     }
-    if (lec(2,1,'Y'))                                                      
-        return;
-    if (lec(3,1,'Y'))                                                      
-        return;
-    if (p < 4) 
-    { 
-        processToken( TY_VT52(s[1] ), 0, 0); 
-        resetTokenizer(); 
-        return; 
-    }
-    processToken( TY_VT52(s[1]), s[2], s[3]); 
-    resetTokenizer(); 
-    return;
-  }
 }
-void Vt102Emulation::processWindowAttributeChange()
+
+void
+Vt102Emulation::processWindowAttributeChange ()
 {
   // Describes the window or terminal session attribute to change
   // See Session::UserTitleChange for possible values
   int attributeToChange = 0;
   int i;
-  for (i = 2; i < tokenBufferPos     && 
-              tokenBuffer[i] >= '0'  && 
-              tokenBuffer[i] <= '9'; i++)
-  {
-    attributeToChange = 10 * attributeToChange + (tokenBuffer[i]-'0');
-  }
+  for (i = 2; i < tokenBufferPos &&
+       tokenBuffer[i] >= '0' && tokenBuffer[i] <= '9'; i++)
+    {
+      attributeToChange = 10 * attributeToChange + (tokenBuffer[i] - '0');
+    }
 
-  if (tokenBuffer[i] != ';') 
-  { 
-    reportDecodingError(); 
-    return; 
-  }
-  
+  if (tokenBuffer[i] != ';')
+    {
+      reportDecodingError ();
+      return;
+    }
+
   QString newValue;
-  newValue.reserve(tokenBufferPos-i-2);
-  for (int j = 0; j < tokenBufferPos-i-2; j++)
-    newValue[j] = tokenBuffer[i+1+j];
- 
+  newValue.reserve (tokenBufferPos - i - 2);
+  for (int j = 0; j < tokenBufferPos - i - 2; j++)
+    newValue[j] = tokenBuffer[i + 1 + j];
+
   _pendingTitleUpdates[attributeToChange] = newValue;
-  _titleUpdateTimer->start(20);
+  _titleUpdateTimer->start (20);
 }
 
-void Vt102Emulation::updateTitle()
+void
+Vt102Emulation::updateTitle ()
 {
-    QListIterator<int> iter( _pendingTitleUpdates.keys() );
-    while (iter.hasNext()) {
-        int arg = iter.next();
-        emit titleChanged( arg , _pendingTitleUpdates[arg] );    
+  QListIterator < int >iter (_pendingTitleUpdates.keys ());
+  while (iter.hasNext ())
+    {
+      int arg = iter.next ();
+      emit titleChanged (arg, _pendingTitleUpdates[arg]);
     }
-    _pendingTitleUpdates.clear();    
+  _pendingTitleUpdates.clear ();
 }
 
 // Interpreting Codes ---------------------------------------------------------
 
 /*
    Now that the incoming character stream is properly tokenized,
    meaning is assigned to them. These are either operations of
    the current _screen, or of the emulation class itself.
@@ -418,552 +501,1016 @@ void Vt102Emulation::updateTitle()
    Likewise, the operations assigned to, come with up to two
    arguments. One could consider to make up a proper table
    from the function below.
 
    The technical reference manual provides more information
    about this mapping.
 */
 
-void Vt102Emulation::processToken(int token, int p, int q)
+void
+Vt102Emulation::processToken (int token, int p, int q)
 {
   switch (token)
-  {
+    {
 
-    case TY_CHR(         ) : _currentScreen->displayCharacter     (p         ); break; //UTF16
+    case TY_CHR ():
+      _currentScreen->displayCharacter (p);
+      break;			//UTF16
 
-    //             127 DEL    : ignored on input
+      //             127 DEL    : ignored on input
 
-    case TY_CTL('@'      ) : /* NUL: ignored                      */ break;
-    case TY_CTL('A'      ) : /* SOH: ignored                      */ break;
-    case TY_CTL('B'      ) : /* STX: ignored                      */ break;
-    case TY_CTL('C'      ) : /* ETX: ignored                      */ break;
-    case TY_CTL('D'      ) : /* EOT: ignored                      */ break;
-    case TY_CTL('E'      ) :      reportAnswerBack     (          ); break; //VT100
-    case TY_CTL('F'      ) : /* ACK: ignored                      */ break;
-    case TY_CTL('G'      ) : emit stateSet(NOTIFYBELL);
-                                break; //VT100
-    case TY_CTL('H'      ) : _currentScreen->backspace            (          ); break; //VT100
-    case TY_CTL('I'      ) : _currentScreen->tab                  (          ); break; //VT100
-    case TY_CTL('J'      ) : _currentScreen->newLine              (          ); break; //VT100
-    case TY_CTL('K'      ) : _currentScreen->newLine              (          ); break; //VT100
-    case TY_CTL('L'      ) : _currentScreen->newLine              (          ); break; //VT100
-    case TY_CTL('M'      ) : _currentScreen->toStartOfLine        (          ); break; //VT100
+    case TY_CTL ('@'):		/* NUL: ignored                      */
+      break;
+    case TY_CTL ('A'):		/* SOH: ignored                      */
+      break;
+    case TY_CTL ('B'):		/* STX: ignored                      */
+      break;
+    case TY_CTL ('C'):		/* ETX: ignored                      */
+      break;
+    case TY_CTL ('D'):		/* EOT: ignored                      */
+      break;
+    case TY_CTL ('E'):
+      reportAnswerBack ();
+      break;			//VT100
+    case TY_CTL ('F'):		/* ACK: ignored                      */
+      break;
+    case TY_CTL ('G'):
+      emit stateSet (NOTIFYBELL);
+      break;			//VT100
+    case TY_CTL ('H'):
+      _currentScreen->backspace ();
+      break;			//VT100
+    case TY_CTL ('I'):
+      _currentScreen->tab ();
+      break;			//VT100
+    case TY_CTL ('J'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('K'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('L'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('M'):
+      _currentScreen->toStartOfLine ();
+      break;			//VT100
 
-    case TY_CTL('N'      ) :      useCharset           (         1); break; //VT100
-    case TY_CTL('O'      ) :      useCharset           (         0); break; //VT100
+    case TY_CTL ('N'):
+      useCharset (1);
+      break;			//VT100
+    case TY_CTL ('O'):
+      useCharset (0);
+      break;			//VT100
 
-    case TY_CTL('P'      ) : /* DLE: ignored                      */ break;
-    case TY_CTL('Q'      ) : /* DC1: XON continue                 */ break; //VT100
-    case TY_CTL('R'      ) : /* DC2: ignored                      */ break;
-    case TY_CTL('S'      ) : /* DC3: XOFF halt                    */ break; //VT100
-    case TY_CTL('T'      ) : /* DC4: ignored                      */ break;
-    case TY_CTL('U'      ) : /* NAK: ignored                      */ break;
-    case TY_CTL('V'      ) : /* SYN: ignored                      */ break;
-    case TY_CTL('W'      ) : /* ETB: ignored                      */ break;
-    case TY_CTL('X'      ) : _currentScreen->displayCharacter     (    0x2592); break; //VT100
-    case TY_CTL('Y'      ) : /* EM : ignored                      */ break;
-    case TY_CTL('Z'      ) : _currentScreen->displayCharacter     (    0x2592); break; //VT100
-    case TY_CTL('['      ) : /* ESC: cannot be seen here.         */ break;
-    case TY_CTL('\\'     ) : /* FS : ignored                      */ break;
-    case TY_CTL(']'      ) : /* GS : ignored                      */ break;
-    case TY_CTL('^'      ) : /* RS : ignored                      */ break;
-    case TY_CTL('_'      ) : /* US : ignored                      */ break;
+    case TY_CTL ('P'):		/* DLE: ignored                      */
+      break;
+    case TY_CTL ('Q'):		/* DC1: XON continue                 */
+      break;			//VT100
+    case TY_CTL ('R'):		/* DC2: ignored                      */
+      break;
+    case TY_CTL ('S'):		/* DC3: XOFF halt                    */
+      break;			//VT100
+    case TY_CTL ('T'):		/* DC4: ignored                      */
+      break;
+    case TY_CTL ('U'):		/* NAK: ignored                      */
+      break;
+    case TY_CTL ('V'):		/* SYN: ignored                      */
+      break;
+    case TY_CTL ('W'):		/* ETB: ignored                      */
+      break;
+    case TY_CTL ('X'):
+      _currentScreen->displayCharacter (0x2592);
+      break;			//VT100
+    case TY_CTL ('Y'):		/* EM : ignored                      */
+      break;
+    case TY_CTL ('Z'):
+      _currentScreen->displayCharacter (0x2592);
+      break;			//VT100
+    case TY_CTL ('['):		/* ESC: cannot be seen here.         */
+      break;
+    case TY_CTL ('\\'):	/* FS : ignored                      */
+      break;
+    case TY_CTL (']'):		/* GS : ignored                      */
+      break;
+    case TY_CTL ('^'):		/* RS : ignored                      */
+      break;
+    case TY_CTL ('_'):		/* US : ignored                      */
+      break;
 
-    case TY_ESC('D'      ) : _currentScreen->index                (          ); break; //VT100
-    case TY_ESC('E'      ) : _currentScreen->nextLine             (          ); break; //VT100
-    case TY_ESC('H'      ) : _currentScreen->changeTabStop        (true      ); break; //VT100
-    case TY_ESC('M'      ) : _currentScreen->reverseIndex         (          ); break; //VT100
-    case TY_ESC('Z'      ) :      reportTerminalType   (          ); break;
-    case TY_ESC('c'      ) :      reset                (          ); break;
-
-    case TY_ESC('n'      ) :      useCharset           (         2); break;
-    case TY_ESC('o'      ) :      useCharset           (         3); break;
-    case TY_ESC('7'      ) :      saveCursor           (          ); break;
-    case TY_ESC('8'      ) :      restoreCursor        (          ); break;
+    case TY_ESC ('D'):
+      _currentScreen->index ();
+      break;			//VT100
+    case TY_ESC ('E'):
+      _currentScreen->nextLine ();
+      break;			//VT100
+    case TY_ESC ('H'):
+      _currentScreen->changeTabStop (true);
+      break;			//VT100
+    case TY_ESC ('M'):
+      _currentScreen->reverseIndex ();
+      break;			//VT100
+    case TY_ESC ('Z'):
+      reportTerminalType ();
+      break;
+    case TY_ESC ('c'):
+      reset ();
+      break;
 
-    case TY_ESC('='      ) :          setMode      (MODE_AppKeyPad); break;
-    case TY_ESC('>'      ) :        resetMode      (MODE_AppKeyPad); break;
-    case TY_ESC('<'      ) :          setMode      (MODE_Ansi     ); break; //VT100
+    case TY_ESC ('n'):
+      useCharset (2);
+      break;
+    case TY_ESC ('o'):
+      useCharset (3);
+      break;
+    case TY_ESC ('7'):
+      saveCursor ();
+      break;
+    case TY_ESC ('8'):
+      restoreCursor ();
+      break;
 
-    case TY_ESC_CS('(', '0') :      setCharset           (0,    '0'); break; //VT100
-    case TY_ESC_CS('(', 'A') :      setCharset           (0,    'A'); break; //VT100
-    case TY_ESC_CS('(', 'B') :      setCharset           (0,    'B'); break; //VT100
+    case TY_ESC ('='):
+      setMode (MODE_AppKeyPad);
+      break;
+    case TY_ESC ('>'):
+      resetMode (MODE_AppKeyPad);
+      break;
+    case TY_ESC ('<'):
+      setMode (MODE_Ansi);
+      break;			//VT100
 
-    case TY_ESC_CS(')', '0') :      setCharset           (1,    '0'); break; //VT100
-    case TY_ESC_CS(')', 'A') :      setCharset           (1,    'A'); break; //VT100
-    case TY_ESC_CS(')', 'B') :      setCharset           (1,    'B'); break; //VT100
+    case TY_ESC_CS ('(', '0'):
+      setCharset (0, '0');
+      break;			//VT100
+    case TY_ESC_CS ('(', 'A'):
+      setCharset (0, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('(', 'B'):
+      setCharset (0, 'B');
+      break;			//VT100
 
-    case TY_ESC_CS('*', '0') :      setCharset           (2,    '0'); break; //VT100
-    case TY_ESC_CS('*', 'A') :      setCharset           (2,    'A'); break; //VT100
-    case TY_ESC_CS('*', 'B') :      setCharset           (2,    'B'); break; //VT100
+    case TY_ESC_CS (')', '0'):
+      setCharset (1, '0');
+      break;			//VT100
+    case TY_ESC_CS (')', 'A'):
+      setCharset (1, 'A');
+      break;			//VT100
+    case TY_ESC_CS (')', 'B'):
+      setCharset (1, 'B');
+      break;			//VT100
 
-    case TY_ESC_CS('+', '0') :      setCharset           (3,    '0'); break; //VT100
-    case TY_ESC_CS('+', 'A') :      setCharset           (3,    'A'); break; //VT100
-    case TY_ESC_CS('+', 'B') :      setCharset           (3,    'B'); break; //VT100
-
-    case TY_ESC_CS('%', 'G') :      setCodec             (Utf8Codec   ); break; //LINUX
-    case TY_ESC_CS('%', '@') :      setCodec             (LocaleCodec ); break; //LINUX
+    case TY_ESC_CS ('*', '0'):
+      setCharset (2, '0');
+      break;			//VT100
+    case TY_ESC_CS ('*', 'A'):
+      setCharset (2, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('*', 'B'):
+      setCharset (2, 'B');
+      break;			//VT100
 
-    case TY_ESC_DE('3'      ) : /* Double height line, top half    */ 
-                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
-                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
-                                    break;
-    case TY_ESC_DE('4'      ) : /* Double height line, bottom half */ 
-                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
-                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
-                                    break;
-    case TY_ESC_DE('5'      ) : /* Single width, single height line*/
-                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , false);
-                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
-                                break;
-    case TY_ESC_DE('6'      ) : /* Double width, single height line*/ 
-                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true);    
-                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
-                                break;
-    case TY_ESC_DE('8'      ) : _currentScreen->helpAlign            (          ); break;
+    case TY_ESC_CS ('+', '0'):
+      setCharset (3, '0');
+      break;			//VT100
+    case TY_ESC_CS ('+', 'A'):
+      setCharset (3, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('+', 'B'):
+      setCharset (3, 'B');
+      break;			//VT100
+
+    case TY_ESC_CS ('%', 'G'):
+      setCodec (Utf8Codec);
+      break;			//LINUX
+    case TY_ESC_CS ('%', '@'):
+      setCodec (LocaleCodec);
+      break;			//LINUX
+
+    case TY_ESC_DE ('3'):	/* Double height line, top half    */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, true);
+      break;
+    case TY_ESC_DE ('4'):	/* Double height line, bottom half */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, true);
+      break;
+    case TY_ESC_DE ('5'):	/* Single width, single height line */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, false);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, false);
+      break;
+    case TY_ESC_DE ('6'):	/* Double width, single height line */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, false);
+      break;
+    case TY_ESC_DE ('8'):
+      _currentScreen->helpAlign ();
+      break;
 
 // resize = \e[8;<row>;<col>t
-    case TY_CSI_PS('t',   8) : setImageSize( q /* columns */, p /* lines */ );    break;
+    case TY_CSI_PS ('t', 8):
+      setImageSize (q /* columns */ , p /* lines */ );
+      break;
 
 // change tab text color : \e[28;<color>t  color: 0-16,777,215
-    case TY_CSI_PS('t',   28) : emit changeTabTextColorRequest      ( p        );          break;
+    case TY_CSI_PS ('t', 28):
+      emit changeTabTextColorRequest (p);
+      break;
 
-    case TY_CSI_PS('K',   0) : _currentScreen->clearToEndOfLine     (          ); break;
-    case TY_CSI_PS('K',   1) : _currentScreen->clearToBeginOfLine   (          ); break;
-    case TY_CSI_PS('K',   2) : _currentScreen->clearEntireLine      (          ); break;
-    case TY_CSI_PS('J',   0) : _currentScreen->clearToEndOfScreen   (          ); break;
-    case TY_CSI_PS('J',   1) : _currentScreen->clearToBeginOfScreen (          ); break;
-    case TY_CSI_PS('J',   2) : _currentScreen->clearEntireScreen    (          ); break;
-    case TY_CSI_PS('J',      3) : clearHistory();                            break;
-    case TY_CSI_PS('g',   0) : _currentScreen->changeTabStop        (false     ); break; //VT100
-    case TY_CSI_PS('g',   3) : _currentScreen->clearTabStops        (          ); break; //VT100
-    case TY_CSI_PS('h',   4) : _currentScreen->    setMode      (MODE_Insert   ); break;
-    case TY_CSI_PS('h',  20) :          setMode      (MODE_NewLine  ); break;
-    case TY_CSI_PS('i',   0) : /* IGNORE: attached printer          */ break; //VT100
-    case TY_CSI_PS('l',   4) : _currentScreen->  resetMode      (MODE_Insert   ); break;
-    case TY_CSI_PS('l',  20) :        resetMode      (MODE_NewLine  ); break;
-    case TY_CSI_PS('s',   0) :      saveCursor           (          ); break;
-    case TY_CSI_PS('u',   0) :      restoreCursor        (          ); break;
+    case TY_CSI_PS ('K', 0):
+      _currentScreen->clearToEndOfLine ();
+      break;
+    case TY_CSI_PS ('K', 1):
+      _currentScreen->clearToBeginOfLine ();
+      break;
+    case TY_CSI_PS ('K', 2):
+      _currentScreen->clearEntireLine ();
+      break;
+    case TY_CSI_PS ('J', 0):
+      _currentScreen->clearToEndOfScreen ();
+      break;
+    case TY_CSI_PS ('J', 1):
+      _currentScreen->clearToBeginOfScreen ();
+      break;
+    case TY_CSI_PS ('J', 2):
+      _currentScreen->clearEntireScreen ();
+      break;
+    case TY_CSI_PS ('J', 3):
+      clearHistory ();
+      break;
+    case TY_CSI_PS ('g', 0):
+      _currentScreen->changeTabStop (false);
+      break;			//VT100
+    case TY_CSI_PS ('g', 3):
+      _currentScreen->clearTabStops ();
+      break;			//VT100
+    case TY_CSI_PS ('h', 4):
+      _currentScreen->setMode (MODE_Insert);
+      break;
+    case TY_CSI_PS ('h', 20):
+      setMode (MODE_NewLine);
+      break;
+    case TY_CSI_PS ('i', 0):	/* IGNORE: attached printer          */
+      break;			//VT100
+    case TY_CSI_PS ('l', 4):
+      _currentScreen->resetMode (MODE_Insert);
+      break;
+    case TY_CSI_PS ('l', 20):
+      resetMode (MODE_NewLine);
+      break;
+    case TY_CSI_PS ('s', 0):
+      saveCursor ();
+      break;
+    case TY_CSI_PS ('u', 0):
+      restoreCursor ();
+      break;
 
-    case TY_CSI_PS('m',   0) : _currentScreen->setDefaultRendition  (          ); break;
-    case TY_CSI_PS('m',   1) : _currentScreen->  setRendition     (RE_BOLD     ); break; //VT100
-    case TY_CSI_PS('m',   4) : _currentScreen->  setRendition     (RE_UNDERLINE); break; //VT100
-    case TY_CSI_PS('m',   5) : _currentScreen->  setRendition     (RE_BLINK    ); break; //VT100
-    case TY_CSI_PS('m',   7) : _currentScreen->  setRendition     (RE_REVERSE  ); break;
-    case TY_CSI_PS('m',  10) : /* IGNORED: mapping related          */ break; //LINUX
-    case TY_CSI_PS('m',  11) : /* IGNORED: mapping related          */ break; //LINUX
-    case TY_CSI_PS('m',  12) : /* IGNORED: mapping related          */ break; //LINUX
-    case TY_CSI_PS('m',  22) : _currentScreen->resetRendition     (RE_BOLD     ); break;
-    case TY_CSI_PS('m',  24) : _currentScreen->resetRendition     (RE_UNDERLINE); break;
-    case TY_CSI_PS('m',  25) : _currentScreen->resetRendition     (RE_BLINK    ); break;
-    case TY_CSI_PS('m',  27) : _currentScreen->resetRendition     (RE_REVERSE  ); break;
+    case TY_CSI_PS ('m', 0):
+      _currentScreen->setDefaultRendition ();
+      break;
+    case TY_CSI_PS ('m', 1):
+      _currentScreen->setRendition (RE_BOLD);
+      break;			//VT100
+    case TY_CSI_PS ('m', 4):
+      _currentScreen->setRendition (RE_UNDERLINE);
+      break;			//VT100
+    case TY_CSI_PS ('m', 5):
+      _currentScreen->setRendition (RE_BLINK);
+      break;			//VT100
+    case TY_CSI_PS ('m', 7):
+      _currentScreen->setRendition (RE_REVERSE);
+      break;
+    case TY_CSI_PS ('m', 10):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 11):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 12):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 22):
+      _currentScreen->resetRendition (RE_BOLD);
+      break;
+    case TY_CSI_PS ('m', 24):
+      _currentScreen->resetRendition (RE_UNDERLINE);
+      break;
+    case TY_CSI_PS ('m', 25):
+      _currentScreen->resetRendition (RE_BLINK);
+      break;
+    case TY_CSI_PS ('m', 27):
+      _currentScreen->resetRendition (RE_REVERSE);
+      break;
 
-    case TY_CSI_PS('m',   30) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  0); break;
-    case TY_CSI_PS('m',   31) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  1); break;
-    case TY_CSI_PS('m',   32) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  2); break;
-    case TY_CSI_PS('m',   33) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  3); break;
-    case TY_CSI_PS('m',   34) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  4); break;
-    case TY_CSI_PS('m',   35) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  5); break;
-    case TY_CSI_PS('m',   36) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  6); break;
-    case TY_CSI_PS('m',   37) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  7); break;
-
-    case TY_CSI_PS('m',   38) : _currentScreen->setForeColor         (p,       q); break;
-
-    case TY_CSI_PS('m',   39) : _currentScreen->setForeColor         (COLOR_SPACE_DEFAULT,  0); break;
+    case TY_CSI_PS ('m', 30):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 0);
+      break;
+    case TY_CSI_PS ('m', 31):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 1);
+      break;
+    case TY_CSI_PS ('m', 32):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 2);
+      break;
+    case TY_CSI_PS ('m', 33):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 3);
+      break;
+    case TY_CSI_PS ('m', 34):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 4);
+      break;
+    case TY_CSI_PS ('m', 35):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 5);
+      break;
+    case TY_CSI_PS ('m', 36):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 6);
+      break;
+    case TY_CSI_PS ('m', 37):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 7);
+      break;
 
-    case TY_CSI_PS('m',   40) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  0); break;
-    case TY_CSI_PS('m',   41) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  1); break;
-    case TY_CSI_PS('m',   42) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  2); break;
-    case TY_CSI_PS('m',   43) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  3); break;
-    case TY_CSI_PS('m',   44) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  4); break;
-    case TY_CSI_PS('m',   45) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  5); break;
-    case TY_CSI_PS('m',   46) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  6); break;
-    case TY_CSI_PS('m',   47) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  7); break;
+    case TY_CSI_PS ('m', 38):
+      _currentScreen->setForeColor (p, q);
+      break;
 
-    case TY_CSI_PS('m',   48) : _currentScreen->setBackColor         (p,       q); break;
-
-    case TY_CSI_PS('m',   49) : _currentScreen->setBackColor         (COLOR_SPACE_DEFAULT,  1); break;
+    case TY_CSI_PS ('m', 39):
+      _currentScreen->setForeColor (COLOR_SPACE_DEFAULT, 0);
+      break;
 
-    case TY_CSI_PS('m',   90) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  8); break;
-    case TY_CSI_PS('m',   91) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  9); break;
-    case TY_CSI_PS('m',   92) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 10); break;
-    case TY_CSI_PS('m',   93) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 11); break;
-    case TY_CSI_PS('m',   94) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 12); break;
-    case TY_CSI_PS('m',   95) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 13); break;
-    case TY_CSI_PS('m',   96) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 14); break;
-    case TY_CSI_PS('m',   97) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 15); break;
+    case TY_CSI_PS ('m', 40):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 0);
+      break;
+    case TY_CSI_PS ('m', 41):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 1);
+      break;
+    case TY_CSI_PS ('m', 42):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 2);
+      break;
+    case TY_CSI_PS ('m', 43):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 3);
+      break;
+    case TY_CSI_PS ('m', 44):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 4);
+      break;
+    case TY_CSI_PS ('m', 45):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 5);
+      break;
+    case TY_CSI_PS ('m', 46):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 6);
+      break;
+    case TY_CSI_PS ('m', 47):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 7);
+      break;
+
+    case TY_CSI_PS ('m', 48):
+      _currentScreen->setBackColor (p, q);
+      break;
+
+    case TY_CSI_PS ('m', 49):
+      _currentScreen->setBackColor (COLOR_SPACE_DEFAULT, 1);
+      break;
 
-    case TY_CSI_PS('m',  100) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  8); break;
-    case TY_CSI_PS('m',  101) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  9); break;
-    case TY_CSI_PS('m',  102) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 10); break;
-    case TY_CSI_PS('m',  103) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 11); break;
-    case TY_CSI_PS('m',  104) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 12); break;
-    case TY_CSI_PS('m',  105) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 13); break;
-    case TY_CSI_PS('m',  106) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 14); break;
-    case TY_CSI_PS('m',  107) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 15); break;
+    case TY_CSI_PS ('m', 90):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 8);
+      break;
+    case TY_CSI_PS ('m', 91):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 9);
+      break;
+    case TY_CSI_PS ('m', 92):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 10);
+      break;
+    case TY_CSI_PS ('m', 93):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 11);
+      break;
+    case TY_CSI_PS ('m', 94):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 12);
+      break;
+    case TY_CSI_PS ('m', 95):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 13);
+      break;
+    case TY_CSI_PS ('m', 96):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 14);
+      break;
+    case TY_CSI_PS ('m', 97):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 15);
+      break;
 
-    case TY_CSI_PS('n',   5) :      reportStatus         (          ); break;
-    case TY_CSI_PS('n',   6) :      reportCursorPosition (          ); break;
-    case TY_CSI_PS('q',   0) : /* IGNORED: LEDs off                 */ break; //VT100
-    case TY_CSI_PS('q',   1) : /* IGNORED: LED1 on                  */ break; //VT100
-    case TY_CSI_PS('q',   2) : /* IGNORED: LED2 on                  */ break; //VT100
-    case TY_CSI_PS('q',   3) : /* IGNORED: LED3 on                  */ break; //VT100
-    case TY_CSI_PS('q',   4) : /* IGNORED: LED4 on                  */ break; //VT100
-    case TY_CSI_PS('x',   0) :      reportTerminalParms  (         2); break; //VT100
-    case TY_CSI_PS('x',   1) :      reportTerminalParms  (         3); break; //VT100
+    case TY_CSI_PS ('m', 100):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 8);
+      break;
+    case TY_CSI_PS ('m', 101):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 9);
+      break;
+    case TY_CSI_PS ('m', 102):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 10);
+      break;
+    case TY_CSI_PS ('m', 103):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 11);
+      break;
+    case TY_CSI_PS ('m', 104):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 12);
+      break;
+    case TY_CSI_PS ('m', 105):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 13);
+      break;
+    case TY_CSI_PS ('m', 106):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 14);
+      break;
+    case TY_CSI_PS ('m', 107):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 15);
+      break;
 
-    case TY_CSI_PN('@'      ) : _currentScreen->insertChars          (p         ); break;
-    case TY_CSI_PN('A'      ) : _currentScreen->cursorUp             (p         ); break; //VT100
-    case TY_CSI_PN('B'      ) : _currentScreen->cursorDown           (p         ); break; //VT100
-    case TY_CSI_PN('C'      ) : _currentScreen->cursorRight          (p         ); break; //VT100
-    case TY_CSI_PN('D'      ) : _currentScreen->cursorLeft           (p         ); break; //VT100
-    case TY_CSI_PN('G'      ) : _currentScreen->setCursorX           (p         ); break; //LINUX
-    case TY_CSI_PN('H'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
-    case TY_CSI_PN('I'      ) : _currentScreen->tab                  (p         ); break;
-    case TY_CSI_PN('L'      ) : _currentScreen->insertLines          (p         ); break;
-    case TY_CSI_PN('M'      ) : _currentScreen->deleteLines          (p         ); break;
-    case TY_CSI_PN('P'      ) : _currentScreen->deleteChars          (p         ); break;
-    case TY_CSI_PN('S'      ) : _currentScreen->scrollUp             (p         ); break;
-    case TY_CSI_PN('T'      ) : _currentScreen->scrollDown           (p         ); break;
-    case TY_CSI_PN('X'      ) : _currentScreen->eraseChars           (p         ); break;
-    case TY_CSI_PN('Z'      ) : _currentScreen->backtab              (p         ); break;
-    case TY_CSI_PN('c'      ) :      reportTerminalType   (          ); break; //VT100
-    case TY_CSI_PN('d'      ) : _currentScreen->setCursorY           (p         ); break; //LINUX
-    case TY_CSI_PN('f'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
-    case TY_CSI_PN('r'      ) :      setMargins           (p,      q); break; //VT100
-    case TY_CSI_PN('y'      ) : /* IGNORED: Confidence test          */ break; //VT100
+    case TY_CSI_PS ('n', 5):
+      reportStatus ();
+      break;
+    case TY_CSI_PS ('n', 6):
+      reportCursorPosition ();
+      break;
+    case TY_CSI_PS ('q', 0):	/* IGNORED: LEDs off                 */
+      break;			//VT100
+    case TY_CSI_PS ('q', 1):	/* IGNORED: LED1 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 2):	/* IGNORED: LED2 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 3):	/* IGNORED: LED3 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 4):	/* IGNORED: LED4 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('x', 0):
+      reportTerminalParms (2);
+      break;			//VT100
+    case TY_CSI_PS ('x', 1):
+      reportTerminalParms (3);
+      break;			//VT100
 
-    case TY_CSI_PR('h',   1) :          setMode      (MODE_AppCuKeys); break; //VT100
-    case TY_CSI_PR('l',   1) :        resetMode      (MODE_AppCuKeys); break; //VT100
-    case TY_CSI_PR('s',   1) :         saveMode      (MODE_AppCuKeys); break; //FIXME
-    case TY_CSI_PR('r',   1) :      restoreMode      (MODE_AppCuKeys); break; //FIXME
-
-    case TY_CSI_PR('l',   2) :        resetMode      (MODE_Ansi     ); break; //VT100
-
-    case TY_CSI_PR('h',   3) :          setMode      (MODE_132Columns);break; //VT100
-    case TY_CSI_PR('l',   3) :        resetMode      (MODE_132Columns);break; //VT100
-
-    case TY_CSI_PR('h',   4) : /* IGNORED: soft scrolling           */ break; //VT100
-    case TY_CSI_PR('l',   4) : /* IGNORED: soft scrolling           */ break; //VT100
-
-    case TY_CSI_PR('h',   5) : _currentScreen->    setMode      (MODE_Screen   ); break; //VT100
-    case TY_CSI_PR('l',   5) : _currentScreen->  resetMode      (MODE_Screen   ); break; //VT100
+    case TY_CSI_PN ('@'):
+      _currentScreen->insertChars (p);
+      break;
+    case TY_CSI_PN ('A'):
+      _currentScreen->cursorUp (p);
+      break;			//VT100
+    case TY_CSI_PN ('B'):
+      _currentScreen->cursorDown (p);
+      break;			//VT100
+    case TY_CSI_PN ('C'):
+      _currentScreen->cursorRight (p);
+      break;			//VT100
+    case TY_CSI_PN ('D'):
+      _currentScreen->cursorLeft (p);
+      break;			//VT100
+    case TY_CSI_PN ('G'):
+      _currentScreen->setCursorX (p);
+      break;			//LINUX
+    case TY_CSI_PN ('H'):
+      _currentScreen->setCursorYX (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('I'):
+      _currentScreen->tab (p);
+      break;
+    case TY_CSI_PN ('L'):
+      _currentScreen->insertLines (p);
+      break;
+    case TY_CSI_PN ('M'):
+      _currentScreen->deleteLines (p);
+      break;
+    case TY_CSI_PN ('P'):
+      _currentScreen->deleteChars (p);
+      break;
+    case TY_CSI_PN ('S'):
+      _currentScreen->scrollUp (p);
+      break;
+    case TY_CSI_PN ('T'):
+      _currentScreen->scrollDown (p);
+      break;
+    case TY_CSI_PN ('X'):
+      _currentScreen->eraseChars (p);
+      break;
+    case TY_CSI_PN ('Z'):
+      _currentScreen->backtab (p);
+      break;
+    case TY_CSI_PN ('c'):
+      reportTerminalType ();
+      break;			//VT100
+    case TY_CSI_PN ('d'):
+      _currentScreen->setCursorY (p);
+      break;			//LINUX
+    case TY_CSI_PN ('f'):
+      _currentScreen->setCursorYX (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('r'):
+      setMargins (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('y'):	/* IGNORED: Confidence test          */
+      break;			//VT100
 
-    case TY_CSI_PR('h',   6) : _currentScreen->    setMode      (MODE_Origin   ); break; //VT100
-    case TY_CSI_PR('l',   6) : _currentScreen->  resetMode      (MODE_Origin   ); break; //VT100
-    case TY_CSI_PR('s',   6) : _currentScreen->   saveMode      (MODE_Origin   ); break; //FIXME
-    case TY_CSI_PR('r',   6) : _currentScreen->restoreMode      (MODE_Origin   ); break; //FIXME
+    case TY_CSI_PR ('h', 1):
+      setMode (MODE_AppCuKeys);
+      break;			//VT100
+    case TY_CSI_PR ('l', 1):
+      resetMode (MODE_AppCuKeys);
+      break;			//VT100
+    case TY_CSI_PR ('s', 1):
+      saveMode (MODE_AppCuKeys);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 1):
+      restoreMode (MODE_AppCuKeys);
+      break;			//FIXME
 
-    case TY_CSI_PR('h',   7) : _currentScreen->    setMode      (MODE_Wrap     ); break; //VT100
-    case TY_CSI_PR('l',   7) : _currentScreen->  resetMode      (MODE_Wrap     ); break; //VT100
-    case TY_CSI_PR('s',   7) : _currentScreen->   saveMode      (MODE_Wrap     ); break; //FIXME
-    case TY_CSI_PR('r',   7) : _currentScreen->restoreMode      (MODE_Wrap     ); break; //FIXME
+    case TY_CSI_PR ('l', 2):
+      resetMode (MODE_Ansi);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 3):
+      setMode (MODE_132Columns);
+      break;			//VT100
+    case TY_CSI_PR ('l', 3):
+      resetMode (MODE_132Columns);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 4):	/* IGNORED: soft scrolling           */
+      break;			//VT100
+    case TY_CSI_PR ('l', 4):	/* IGNORED: soft scrolling           */
+      break;			//VT100
 
-    case TY_CSI_PR('h',   8) : /* IGNORED: autorepeat on            */ break; //VT100
-    case TY_CSI_PR('l',   8) : /* IGNORED: autorepeat off           */ break; //VT100
-    case TY_CSI_PR('s',   8) : /* IGNORED: autorepeat on            */ break; //VT100
-    case TY_CSI_PR('r',   8) : /* IGNORED: autorepeat off           */ break; //VT100
+    case TY_CSI_PR ('h', 5):
+      _currentScreen->setMode (MODE_Screen);
+      break;			//VT100
+    case TY_CSI_PR ('l', 5):
+      _currentScreen->resetMode (MODE_Screen);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 6):
+      _currentScreen->setMode (MODE_Origin);
+      break;			//VT100
+    case TY_CSI_PR ('l', 6):
+      _currentScreen->resetMode (MODE_Origin);
+      break;			//VT100
+    case TY_CSI_PR ('s', 6):
+      _currentScreen->saveMode (MODE_Origin);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 6):
+      _currentScreen->restoreMode (MODE_Origin);
+      break;			//FIXME
 
-    case TY_CSI_PR('h',   9) : /* IGNORED: interlace                */ break; //VT100
-    case TY_CSI_PR('l',   9) : /* IGNORED: interlace                */ break; //VT100
-    case TY_CSI_PR('s',   9) : /* IGNORED: interlace                */ break; //VT100
-    case TY_CSI_PR('r',   9) : /* IGNORED: interlace                */ break; //VT100
+    case TY_CSI_PR ('h', 7):
+      _currentScreen->setMode (MODE_Wrap);
+      break;			//VT100
+    case TY_CSI_PR ('l', 7):
+      _currentScreen->resetMode (MODE_Wrap);
+      break;			//VT100
+    case TY_CSI_PR ('s', 7):
+      _currentScreen->saveMode (MODE_Wrap);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 7):
+      _currentScreen->restoreMode (MODE_Wrap);
+      break;			//FIXME
+
+    case TY_CSI_PR ('h', 8):	/* IGNORED: autorepeat on            */
+      break;			//VT100
+    case TY_CSI_PR ('l', 8):	/* IGNORED: autorepeat off           */
+      break;			//VT100
+    case TY_CSI_PR ('s', 8):	/* IGNORED: autorepeat on            */
+      break;			//VT100
+    case TY_CSI_PR ('r', 8):	/* IGNORED: autorepeat off           */
+      break;			//VT100
 
-    case TY_CSI_PR('h',  12) : /* IGNORED: Cursor blink             */ break; //att610
-    case TY_CSI_PR('l',  12) : /* IGNORED: Cursor blink             */ break; //att610
-    case TY_CSI_PR('s',  12) : /* IGNORED: Cursor blink             */ break; //att610
-    case TY_CSI_PR('r',  12) : /* IGNORED: Cursor blink             */ break; //att610
+    case TY_CSI_PR ('h', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('l', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('s', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('r', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('l', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('s', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('r', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
 
-    case TY_CSI_PR('h',  25) :          setMode      (MODE_Cursor   ); break; //VT100
-    case TY_CSI_PR('l',  25) :        resetMode      (MODE_Cursor   ); break; //VT100
-    case TY_CSI_PR('s',  25) :         saveMode      (MODE_Cursor   ); break; //VT100
-    case TY_CSI_PR('r',  25) :      restoreMode      (MODE_Cursor   ); break; //VT100
+    case TY_CSI_PR ('h', 25):
+      setMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('l', 25):
+      resetMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('s', 25):
+      saveMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('r', 25):
+      restoreMode (MODE_Cursor);
+      break;			//VT100
 
-    case TY_CSI_PR('h',  40) :         setMode(MODE_Allow132Columns ); break; // XTERM
-    case TY_CSI_PR('l',  40) :       resetMode(MODE_Allow132Columns ); break; // XTERM
+    case TY_CSI_PR ('h', 40):
+      setMode (MODE_Allow132Columns);
+      break;			// XTERM
+    case TY_CSI_PR ('l', 40):
+      resetMode (MODE_Allow132Columns);
+      break;			// XTERM
 
-    case TY_CSI_PR('h',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
-    case TY_CSI_PR('l',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
-    case TY_CSI_PR('s',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
-    case TY_CSI_PR('r',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
+    case TY_CSI_PR ('h', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('s', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 47):
+      setMode (MODE_AppScreen);
+      break;			//VT100
+    case TY_CSI_PR ('l', 47):
+      resetMode (MODE_AppScreen);
+      break;			//VT100
+    case TY_CSI_PR ('s', 47):
+      saveMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 47):
+      restoreMode (MODE_AppScreen);
+      break;			//XTERM
 
-    case TY_CSI_PR('h',  47) :          setMode      (MODE_AppScreen); break; //VT100
-    case TY_CSI_PR('l',  47) :        resetMode      (MODE_AppScreen); break; //VT100
-    case TY_CSI_PR('s',  47) :         saveMode      (MODE_AppScreen); break; //XTERM
-    case TY_CSI_PR('r',  47) :      restoreMode      (MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR ('h', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('s', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
 
-    case TY_CSI_PR('h',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
-    case TY_CSI_PR('l',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
-    case TY_CSI_PR('s',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
-    case TY_CSI_PR('r',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
+      // XTerm defines the following modes:
+      // SET_VT200_MOUSE             1000
+      // SET_VT200_HIGHLIGHT_MOUSE   1001
+      // SET_BTN_EVENT_MOUSE         1002
+      // SET_ANY_EVENT_MOUSE         1003
+      //
+
+      //Note about mouse modes:
+      //There are four mouse modes which xterm-compatible terminals can support - 1000,1001,1002,1003
+      //Konsole currently supports mode 1000 (basic mouse press and release) and mode 1002 (dragging the mouse).
+      //TODO:  Implementation of mouse modes 1001 (something called hilight tracking) and 
+      //1003 (a slight variation on dragging the mouse)
+      //
 
-    // XTerm defines the following modes:
-    // SET_VT200_MOUSE             1000
-    // SET_VT200_HIGHLIGHT_MOUSE   1001
-    // SET_BTN_EVENT_MOUSE         1002
-    // SET_ANY_EVENT_MOUSE         1003
-    //
-    
-    //Note about mouse modes:
-    //There are four mouse modes which xterm-compatible terminals can support - 1000,1001,1002,1003
-    //Konsole currently supports mode 1000 (basic mouse press and release) and mode 1002 (dragging the mouse).
-    //TODO:  Implementation of mouse modes 1001 (something called hilight tracking) and 
-    //1003 (a slight variation on dragging the mouse)
-    //
- 
-    case TY_CSI_PR('h', 1000) :          setMode      (MODE_Mouse1000); break; //XTERM
-    case TY_CSI_PR('l', 1000) :        resetMode      (MODE_Mouse1000); break; //XTERM
-    case TY_CSI_PR('s', 1000) :         saveMode      (MODE_Mouse1000); break; //XTERM
-    case TY_CSI_PR('r', 1000) :      restoreMode      (MODE_Mouse1000); break; //XTERM
+    case TY_CSI_PR ('h', 1000):
+      setMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1000):
+      resetMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1000):
+      saveMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1000):
+      restoreMode (MODE_Mouse1000);
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1001):
+      resetMode (MODE_Mouse1001);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
 
-    case TY_CSI_PR('h', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
-    case TY_CSI_PR('l', 1001) :        resetMode      (MODE_Mouse1001); break; //XTERM
-    case TY_CSI_PR('s', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
-    case TY_CSI_PR('r', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
+    case TY_CSI_PR ('h', 1002):
+      setMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1002):
+      resetMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1002):
+      saveMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1002):
+      restoreMode (MODE_Mouse1002);
+      break;			//XTERM
 
-    case TY_CSI_PR('h', 1002) :          setMode      (MODE_Mouse1002); break; //XTERM
-    case TY_CSI_PR('l', 1002) :        resetMode      (MODE_Mouse1002); break; //XTERM
-    case TY_CSI_PR('s', 1002) :         saveMode      (MODE_Mouse1002); break; //XTERM
-    case TY_CSI_PR('r', 1002) :      restoreMode      (MODE_Mouse1002); break; //XTERM
+    case TY_CSI_PR ('h', 1003):
+      setMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1003):
+      resetMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1003):
+      saveMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1003):
+      restoreMode (MODE_Mouse1003);
+      break;			//XTERM
 
-    case TY_CSI_PR('h', 1003) :          setMode      (MODE_Mouse1003); break; //XTERM
-    case TY_CSI_PR('l', 1003) :        resetMode      (MODE_Mouse1003); break; //XTERM
-    case TY_CSI_PR('s', 1003) :         saveMode      (MODE_Mouse1003); break; //XTERM
-    case TY_CSI_PR('r', 1003) :      restoreMode      (MODE_Mouse1003); break; //XTERM
+    case TY_CSI_PR ('h', 1034):	/* IGNORED: 8bitinput activation     */
+      break;			//XTERM
 
-    case TY_CSI_PR('h', 1034) : /* IGNORED: 8bitinput activation     */ break; //XTERM
+    case TY_CSI_PR ('h', 1047):
+      setMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1047):
+      _screen[1]->clearEntireScreen ();
+      resetMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1047):
+      saveMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1047):
+      restoreMode (MODE_AppScreen);
+      break;			//XTERM
 
-    case TY_CSI_PR('h', 1047) :          setMode      (MODE_AppScreen); break; //XTERM
-    case TY_CSI_PR('l', 1047) : _screen[1]->clearEntireScreen(); resetMode(MODE_AppScreen); break; //XTERM
-    case TY_CSI_PR('s', 1047) :         saveMode      (MODE_AppScreen); break; //XTERM
-    case TY_CSI_PR('r', 1047) :      restoreMode      (MODE_AppScreen); break; //XTERM
+      //FIXME: Unitoken: save translations
+    case TY_CSI_PR ('h', 1048):
+      saveCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1048):
+      restoreCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1048):
+      saveCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1048):
+      restoreCursor ();
+      break;			//XTERM
 
-    //FIXME: Unitoken: save translations
-    case TY_CSI_PR('h', 1048) :      saveCursor           (          ); break; //XTERM
-    case TY_CSI_PR('l', 1048) :      restoreCursor        (          ); break; //XTERM
-    case TY_CSI_PR('s', 1048) :      saveCursor           (          ); break; //XTERM
-    case TY_CSI_PR('r', 1048) :      restoreCursor        (          ); break; //XTERM
+      //FIXME: every once new sequences like this pop up in xterm.
+      //       Here's a guess of what they could mean.
+    case TY_CSI_PR ('h', 1049):
+      saveCursor ();
+      _screen[1]->clearEntireScreen ();
+      setMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1049):
+      resetMode (MODE_AppScreen);
+      restoreCursor ();
+      break;			//XTERM
 
-    //FIXME: every once new sequences like this pop up in xterm.
-    //       Here's a guess of what they could mean.
-    case TY_CSI_PR('h', 1049) : saveCursor(); _screen[1]->clearEntireScreen(); setMode(MODE_AppScreen); break; //XTERM
-    case TY_CSI_PR('l', 1049) : resetMode(MODE_AppScreen); restoreCursor(); break; //XTERM
+      //FIXME: weird DEC reset sequence
+    case TY_CSI_PE ('p'):	/* IGNORED: reset         (        ) */
+      break;
 
-    //FIXME: weird DEC reset sequence
-    case TY_CSI_PE('p'      ) : /* IGNORED: reset         (        ) */ break;
+      //FIXME: when changing between vt52 and ansi mode evtl do some resetting.
+    case TY_VT52 ('A'):
+      _currentScreen->cursorUp (1);
+      break;			//VT52
+    case TY_VT52 ('B'):
+      _currentScreen->cursorDown (1);
+      break;			//VT52
+    case TY_VT52 ('C'):
+      _currentScreen->cursorRight (1);
+      break;			//VT52
+    case TY_VT52 ('D'):
+      _currentScreen->cursorLeft (1);
+      break;			//VT52
 
-    //FIXME: when changing between vt52 and ansi mode evtl do some resetting.
-    case TY_VT52('A'      ) : _currentScreen->cursorUp             (         1); break; //VT52
-    case TY_VT52('B'      ) : _currentScreen->cursorDown           (         1); break; //VT52
-    case TY_VT52('C'      ) : _currentScreen->cursorRight          (         1); break; //VT52
-    case TY_VT52('D'      ) : _currentScreen->cursorLeft           (         1); break; //VT52
-
-    case TY_VT52('F'      ) :      setAndUseCharset     (0,    '0'); break; //VT52
-    case TY_VT52('G'      ) :      setAndUseCharset     (0,    'B'); break; //VT52
+    case TY_VT52 ('F'):
+      setAndUseCharset (0, '0');
+      break;			//VT52
+    case TY_VT52 ('G'):
+      setAndUseCharset (0, 'B');
+      break;			//VT52
 
-    case TY_VT52('H'      ) : _currentScreen->setCursorYX          (1,1       ); break; //VT52
-    case TY_VT52('I'      ) : _currentScreen->reverseIndex         (          ); break; //VT52
-    case TY_VT52('J'      ) : _currentScreen->clearToEndOfScreen   (          ); break; //VT52
-    case TY_VT52('K'      ) : _currentScreen->clearToEndOfLine     (          ); break; //VT52
-    case TY_VT52('Y'      ) : _currentScreen->setCursorYX          (p-31,q-31 ); break; //VT52
-    case TY_VT52('Z'      ) :      reportTerminalType   (           ); break; //VT52
-    case TY_VT52('<'      ) :          setMode      (MODE_Ansi     ); break; //VT52
-    case TY_VT52('='      ) :          setMode      (MODE_AppKeyPad); break; //VT52
-    case TY_VT52('>'      ) :        resetMode      (MODE_AppKeyPad); break; //VT52
+    case TY_VT52 ('H'):
+      _currentScreen->setCursorYX (1, 1);
+      break;			//VT52
+    case TY_VT52 ('I'):
+      _currentScreen->reverseIndex ();
+      break;			//VT52
+    case TY_VT52 ('J'):
+      _currentScreen->clearToEndOfScreen ();
+      break;			//VT52
+    case TY_VT52 ('K'):
+      _currentScreen->clearToEndOfLine ();
+      break;			//VT52
+    case TY_VT52 ('Y'):
+      _currentScreen->setCursorYX (p - 31, q - 31);
+      break;			//VT52
+    case TY_VT52 ('Z'):
+      reportTerminalType ();
+      break;			//VT52
+    case TY_VT52 ('<'):
+      setMode (MODE_Ansi);
+      break;			//VT52
+    case TY_VT52 ('='):
+      setMode (MODE_AppKeyPad);
+      break;			//VT52
+    case TY_VT52 ('>'):
+      resetMode (MODE_AppKeyPad);
+      break;			//VT52
 
-    case TY_CSI_PG('c'      ) :  reportSecondaryAttributes(          ); break; //VT100
+    case TY_CSI_PG ('c'):
+      reportSecondaryAttributes ();
+      break;			//VT100
 
-    default: 
-        reportDecodingError();    
-        break;
-  };
+    default:
+      reportDecodingError ();
+      break;
+    };
 }
 
-void Vt102Emulation::clearScreenAndSetColumns(int columnCount)
+void
+Vt102Emulation::clearScreenAndSetColumns (int columnCount)
 {
-    setImageSize(_currentScreen->getLines(),columnCount); 
-    clearEntireScreen();
-    setDefaultMargins(); 
-    _currentScreen->setCursorYX(0,0);
+  setImageSize (_currentScreen->getLines (), columnCount);
+  clearEntireScreen ();
+  setDefaultMargins ();
+  _currentScreen->setCursorYX (0, 0);
 }
 
-void Vt102Emulation::sendString(const char* s , int length)
+void
+Vt102Emulation::sendString (const char *s, int length)
 {
-  if ( length >= 0 )
-    emit sendData(s,length);
+  if (length >= 0)
+    emit sendData (s, length);
   else
-    emit sendData(s,strlen(s));
+  emit sendData (s, strlen (s));
 }
 
-void Vt102Emulation::reportCursorPosition()
-{ 
+void
+Vt102Emulation::reportCursorPosition ()
+{
   char tmp[20];
-  sprintf(tmp,"\033[%d;%dR",_currentScreen->getCursorY()+1,_currentScreen->getCursorX()+1);
-  sendString(tmp);
+  sprintf (tmp, "\033[%d;%dR", _currentScreen->getCursorY () + 1,
+	   _currentScreen->getCursorX () + 1);
+  sendString (tmp);
 }
 
-void Vt102Emulation::reportTerminalType()
+void
+Vt102Emulation::reportTerminalType ()
 {
   // Primary device attribute response (Request was: ^[[0c or ^[[c (from TT321 Users Guide))
   // VT220:  ^[[?63;1;2;3;6;7;8c   (list deps on emul. capabilities)
   // VT100:  ^[[?1;2c
   // VT101:  ^[[?1;0c
   // VT102:  ^[[?6v
-  if (getMode(MODE_Ansi))
-    sendString("\033[?1;2c"); // I'm a VT100
+  if (getMode (MODE_Ansi))
+    sendString ("\033[?1;2c");	// I'm a VT100
   else
-    sendString("\033/Z"); // I'm a VT52
+    sendString ("\033/Z");	// I'm a VT52
 }
 
-void Vt102Emulation::reportSecondaryAttributes()
+void
+Vt102Emulation::reportSecondaryAttributes ()
 {
   // Seconday device attribute response (Request was: ^[[>0c or ^[[>c)
-  if (getMode(MODE_Ansi))
-    sendString("\033[>0;115;0c"); // Why 115?  ;)
+  if (getMode (MODE_Ansi))
+    sendString ("\033[>0;115;0c");	// Why 115?  ;)
   else
-    sendString("\033/Z");         // FIXME I don't think VT52 knows about it but kept for
-                                  // konsoles backward compatibility.
+    sendString ("\033/Z");	// FIXME I don't think VT52 knows about it but kept for
+  // konsoles backward compatibility.
 }
 
-void Vt102Emulation::reportTerminalParms(int p)
+void
+Vt102Emulation::reportTerminalParms (int p)
 // DECREPTPARM
-{ 
+{
   char tmp[100];
-  sprintf(tmp,"\033[%d;1;1;112;112;1;0x",p); // not really true.
-  sendString(tmp);
+  sprintf (tmp, "\033[%d;1;1;112;112;1;0x", p);	// not really true.
+  sendString (tmp);
 }
 
-void Vt102Emulation::reportStatus()
+void
+Vt102Emulation::reportStatus ()
 {
-  sendString("\033[0n"); //VT100. Device status report. 0 = Ready.
+  sendString ("\033[0n");	//VT100. Device status report. 0 = Ready.
 }
 
-void Vt102Emulation::reportAnswerBack()
+void
+Vt102Emulation::reportAnswerBack ()
 {
   // FIXME - Test this with VTTEST
   // This is really obsolete VT100 stuff.
-  const char* ANSWER_BACK = "";
-  sendString(ANSWER_BACK);
+  const char *ANSWER_BACK = "";
+  sendString (ANSWER_BACK);
 }
 
 /*!
     `cx',`cy' are 1-based.
     `eventType' indicates the button pressed (0-2)
                 or a general mouse release (3).
 
     eventType represents the kind of mouse action that occurred:
         0 = Mouse button press or release
         1 = Mouse drag
 */
 
-void Vt102Emulation::sendMouseEvent( int cb, int cx, int cy , int eventType )
-{ 
-  if (cx < 1 || cy < 1) 
+void
+Vt102Emulation::sendMouseEvent (int cb, int cx, int cy, int eventType)
+{
+  if (cx < 1 || cy < 1)
     return;
 
   // normal buttons are passed as 0x20 + button,
   // mouse wheel (buttons 4,5) as 0x5c + button
-  if (cb >= 4) 
+  if (cb >= 4)
     cb += 0x3c;
 
   //Mouse motion handling
-  if ((getMode(MODE_Mouse1002) || getMode(MODE_Mouse1003)) && eventType == 1)
-      cb += 0x20; //add 32 to signify motion event
+  if ((getMode (MODE_Mouse1002) || getMode (MODE_Mouse1003))
+      && eventType == 1)
+    cb += 0x20;			//add 32 to signify motion event
 
   char command[20];
-  sprintf(command,"\033[M%c%c%c",cb+0x20,cx+0x20,cy+0x20);
-  sendString(command);
+  sprintf (command, "\033[M%c%c%c", cb + 0x20, cx + 0x20, cy + 0x20);
+  sendString (command);
+}
+
+void
+Vt102Emulation::sendText (const QString & text)
+{
+  if (!text.isEmpty ())
+    {
+      QKeyEvent event (QEvent::KeyPress,
+		       0, (Qt::KeyboardModifiers) Qt::NoModifier, text);
+
+      sendKeyEvent (&event);	// expose as a big fat keypress event
+    }
 }
 
-void Vt102Emulation::sendText( const QString& text )
-{
-  if (!text.isEmpty()) 
-  {
-    QKeyEvent event(QEvent::KeyPress,
-                    0, 
-                    (Qt::KeyboardModifiers)Qt::NoModifier,
-                    text);
-
-    sendKeyEvent(&event); // expose as a big fat keypress event
-  }
-}
-void Vt102Emulation::sendKeyEvent( QKeyEvent* event )
+void
+Vt102Emulation::sendKeyEvent (QKeyEvent * event)
 {
-    Qt::KeyboardModifiers modifiers = event->modifiers();
-    KeyboardTranslator::States states = KeyboardTranslator::NoState;
+  Qt::KeyboardModifiers modifiers = event->modifiers ();
+  KeyboardTranslator::States states = KeyboardTranslator::NoState;
 
-    // get current states
-    if (getMode(MODE_NewLine)  ) states |= KeyboardTranslator::NewLineState;
-    if (getMode(MODE_Ansi)     ) states |= KeyboardTranslator::AnsiState;
-    if (getMode(MODE_AppCuKeys)) states |= KeyboardTranslator::CursorKeysState;
-    if (getMode(MODE_AppScreen)) states |= KeyboardTranslator::AlternateScreenState;
-    if (getMode(MODE_AppKeyPad) && (modifiers & Qt::KeypadModifier)) 
-        states |= KeyboardTranslator::ApplicationKeypadState;
+  // get current states
+  if (getMode (MODE_NewLine))
+    states |= KeyboardTranslator::NewLineState;
+  if (getMode (MODE_Ansi))
+    states |= KeyboardTranslator::AnsiState;
+  if (getMode (MODE_AppCuKeys))
+    states |= KeyboardTranslator::CursorKeysState;
+  if (getMode (MODE_AppScreen))
+    states |= KeyboardTranslator::AlternateScreenState;
+  if (getMode (MODE_AppKeyPad) && (modifiers & Qt::KeypadModifier))
+    states |= KeyboardTranslator::ApplicationKeypadState;
 
-    // check flow control state
-    if (modifiers & Qt::ControlModifier)
+  // check flow control state
+  if (modifiers & Qt::ControlModifier)
     {
-        if (event->key() == Qt::Key_S)
-            emit flowControlKeyPressed(true);
-        else if (event->key() == Qt::Key_Q)
-            emit flowControlKeyPressed(false);
+      if (event->key () == Qt::Key_S)
+	emit flowControlKeyPressed (true);
+      else
+    if (event->key () == Qt::Key_Q)
+      emit flowControlKeyPressed (false);
     }
 
-    // lookup key binding
-    if ( _keyTranslator )
+  // lookup key binding
+  if (_keyTranslator)
     {
-    KeyboardTranslator::Entry entry = _keyTranslator->findEntry( 
-                                                event->key() , 
-                                                modifiers,
-                                                states );
+      KeyboardTranslator::Entry entry =
+	_keyTranslator->findEntry (event->key (), modifiers, states);
 
-        // send result to terminal
-        QByteArray textToSend;
+      // send result to terminal
+      QByteArray textToSend;
 
-        // special handling for the Alt (aka. Meta) modifier.  pressing
-        // Alt+[Character] results in Esc+[Character] being sent
-        // (unless there is an entry defined for this particular combination
-        //  in the keyboard modifier)
-        bool wantsAltModifier = entry.modifiers() & entry.modifierMask() & Qt::AltModifier;
-        bool wantsAnyModifier = entry.state() & 
-                                entry.stateMask() & KeyboardTranslator::AnyModifierState;
+      // special handling for the Alt (aka. Meta) modifier.  pressing
+      // Alt+[Character] results in Esc+[Character] being sent
+      // (unless there is an entry defined for this particular combination
+      //  in the keyboard modifier)
+      bool wantsAltModifier =
+	entry.modifiers () & entry.modifierMask () & Qt::AltModifier;
+      bool wantsAnyModifier =
+	entry.state () & entry.
+	stateMask () & KeyboardTranslator::AnyModifierState;
 
-        if ( modifiers & Qt::AltModifier && !(wantsAltModifier || wantsAnyModifier) 
-             && !event->text().isEmpty() )
-        {
-            textToSend.prepend("\033");
-        }
+      if (modifiers & Qt::AltModifier
+	  && !(wantsAltModifier || wantsAnyModifier)
+	  && !event->text ().isEmpty ())
+	{
+	  textToSend.prepend ("\033");
+	}
 
-        if ( entry.command() != KeyboardTranslator::NoCommand )
-        {
-            if (entry.command() & KeyboardTranslator::EraseCommand)
-                textToSend += eraseChar();
+      if (entry.command () != KeyboardTranslator::NoCommand)
+	{
+	  if (entry.command () & KeyboardTranslator::EraseCommand)
+	    textToSend += eraseChar ();
+
+	  // TODO command handling
+	}
+      else if (!entry.text ().isEmpty ())
+	{
+	  textToSend += _codec->fromUnicode (entry.text (true, modifiers));
+	}
+      else
+	textToSend += _codec->fromUnicode (event->text ());
 
-            // TODO command handling
-        }
-        else if ( !entry.text().isEmpty() ) 
-        {
-            textToSend += _codec->fromUnicode(entry.text(true,modifiers));
-        }
-        else
-            textToSend += _codec->fromUnicode(event->text());
-
-        sendData( textToSend.constData() , textToSend.length() );
+      sendData (textToSend.constData (), textToSend.length ());
     }
-    else
+  else
     {
-        // print an error message to the terminal if no key translator has been
-        // set
-        QString translatorError =  QString("No keyboard translator available.  "
-                                         "The information needed to convert key presses "
-                                         "into characters to send to the terminal " 
-                                         "is missing.");
-        reset();
-        receiveData( translatorError.toAscii().constData() , translatorError.count() );
+      // print an error message to the terminal if no key translator has been
+      // set
+      QString translatorError = QString ("No keyboard translator available.  "
+					 "The information needed to convert key presses "
+					 "into characters to send to the terminal "
+					 "is missing.");
+      reset ();
+      receiveData (translatorError.toAscii ().constData (),
+		   translatorError.count ());
     }
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                VT100 Charsets                             */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
@@ -985,87 +1532,100 @@ void Vt102Emulation::sendKeyEvent( QKeyE
    it might involve VT100 enhanced fonts, which have these
    particular glyphs allocated in (0x00-0x1f) in their code page.
 */
 
 #define CHARSET _charset[_currentScreen==_screen[1]]
 
 // Apply current character map.
 
-unsigned short Vt102Emulation::applyCharset(unsigned short c)
+unsigned short
+Vt102Emulation::applyCharset (unsigned short c)
 {
-  if (CHARSET.graphic && 0x5f <= c && c <= 0x7e) return vt100_graphics[c-0x5f];
-  if (CHARSET.pound && c == '#' ) return 0xa3; //This mode is obsolete
+  if (CHARSET.graphic && 0x5f <= c && c <= 0x7e)
+    return vt100_graphics[c - 0x5f];
+  if (CHARSET.pound && c == '#')
+    return 0xa3;		//This mode is obsolete
   return c;
 }
 
 /*
    "Charset" related part of the emulation state.
    This configures the VT100 charset filter.
 
    While most operation work on the current _screen,
    the following two are different.
 */
 
-void Vt102Emulation::resetCharset(int scrno)
+void
+Vt102Emulation::resetCharset (int scrno)
 {
   _charset[scrno].cu_cs = 0;
-  strncpy(_charset[scrno].charset,"BBBB",4);
+  strncpy (_charset[scrno].charset, "BBBB", 4);
   _charset[scrno].sa_graphic = false;
   _charset[scrno].sa_pound = false;
   _charset[scrno].graphic = false;
   _charset[scrno].pound = false;
 }
 
-void Vt102Emulation::setCharset(int n, int cs) // on both screens.
+void
+Vt102Emulation::setCharset (int n, int cs)	// on both screens.
 {
-  _charset[0].charset[n&3] = cs; useCharset(_charset[0].cu_cs);
-  _charset[1].charset[n&3] = cs; useCharset(_charset[1].cu_cs);
+  _charset[0].charset[n & 3] = cs;
+  useCharset (_charset[0].cu_cs);
+  _charset[1].charset[n & 3] = cs;
+  useCharset (_charset[1].cu_cs);
 }
 
-void Vt102Emulation::setAndUseCharset(int n, int cs)
+void
+Vt102Emulation::setAndUseCharset (int n, int cs)
 {
-  CHARSET.charset[n&3] = cs;
-  useCharset(n&3);
+  CHARSET.charset[n & 3] = cs;
+  useCharset (n & 3);
 }
 
-void Vt102Emulation::useCharset(int n)
+void
+Vt102Emulation::useCharset (int n)
 {
-  CHARSET.cu_cs   = n&3;
-  CHARSET.graphic = (CHARSET.charset[n&3] == '0');
-  CHARSET.pound   = (CHARSET.charset[n&3] == 'A'); //This mode is obsolete
+  CHARSET.cu_cs = n & 3;
+  CHARSET.graphic = (CHARSET.charset[n & 3] == '0');
+  CHARSET.pound = (CHARSET.charset[n & 3] == 'A');	//This mode is obsolete
 }
 
-void Vt102Emulation::setDefaultMargins()
+void
+Vt102Emulation::setDefaultMargins ()
 {
-    _screen[0]->setDefaultMargins();
-    _screen[1]->setDefaultMargins();
+  _screen[0]->setDefaultMargins ();
+  _screen[1]->setDefaultMargins ();
 }
 
-void Vt102Emulation::setMargins(int t, int b)
+void
+Vt102Emulation::setMargins (int t, int b)
 {
-  _screen[0]->setMargins(t, b);
-  _screen[1]->setMargins(t, b);
+  _screen[0]->setMargins (t, b);
+  _screen[1]->setMargins (t, b);
 }
 
-void Vt102Emulation::saveCursor()
+void
+Vt102Emulation::saveCursor ()
 {
   CHARSET.sa_graphic = CHARSET.graphic;
-  CHARSET.sa_pound   = CHARSET.pound; //This mode is obsolete
+  CHARSET.sa_pound = CHARSET.pound;	//This mode is obsolete
   // we are not clear about these
   //sa_charset = charsets[cScreen->_charset];
   //sa_charset_num = cScreen->_charset;
-  _currentScreen->saveCursor();
+  _currentScreen->saveCursor ();
 }
 
-void Vt102Emulation::restoreCursor()
+void
+Vt102Emulation::restoreCursor ()
 {
   CHARSET.graphic = CHARSET.sa_graphic;
-  CHARSET.pound   = CHARSET.sa_pound; //This mode is obsolete
-  _currentScreen->restoreCursor();
+  CHARSET.pound = CHARSET.sa_pound;	//This mode is obsolete
+  _currentScreen->restoreCursor ();
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Mode Operations                            */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
@@ -1078,137 +1638,153 @@ void Vt102Emulation::restoreCursor()
    For strange reasons, the extend of the rendition attributes ranges over
    all screens and not over the actual _screen.
 
    We decided on the precise precise extend, somehow.
 */
 
 // "Mode" related part of the state. These are all booleans.
 
-void Vt102Emulation::resetModes()
+void
+Vt102Emulation::resetModes ()
 {
   // MODE_Allow132Columns is not reset here
   // to match Xterm's behaviour (see Xterm's VTReset() function)
 
-  resetMode(MODE_132Columns); saveMode(MODE_132Columns);
-  resetMode(MODE_Mouse1000);  saveMode(MODE_Mouse1000);
-  resetMode(MODE_Mouse1001);  saveMode(MODE_Mouse1001);
-  resetMode(MODE_Mouse1002);  saveMode(MODE_Mouse1002);
-  resetMode(MODE_Mouse1003);  saveMode(MODE_Mouse1003);
+  resetMode (MODE_132Columns);
+  saveMode (MODE_132Columns);
+  resetMode (MODE_Mouse1000);
+  saveMode (MODE_Mouse1000);
+  resetMode (MODE_Mouse1001);
+  saveMode (MODE_Mouse1001);
+  resetMode (MODE_Mouse1002);
+  saveMode (MODE_Mouse1002);
+  resetMode (MODE_Mouse1003);
+  saveMode (MODE_Mouse1003);
 
-  resetMode(MODE_AppScreen);  saveMode(MODE_AppScreen);
-  resetMode(MODE_AppCuKeys);  saveMode(MODE_AppCuKeys);
-  resetMode(MODE_AppKeyPad);  saveMode(MODE_AppKeyPad);
-  resetMode(MODE_NewLine);
-  setMode(MODE_Ansi);
+  resetMode (MODE_AppScreen);
+  saveMode (MODE_AppScreen);
+  resetMode (MODE_AppCuKeys);
+  saveMode (MODE_AppCuKeys);
+  resetMode (MODE_AppKeyPad);
+  saveMode (MODE_AppKeyPad);
+  resetMode (MODE_NewLine);
+  setMode (MODE_Ansi);
 }
 
-void Vt102Emulation::setMode(int m)
+void
+Vt102Emulation::setMode (int m)
 {
   _currentModes.mode[m] = true;
   switch (m)
-  {
+    {
     case MODE_132Columns:
-        if (getMode(MODE_Allow132Columns))
-            clearScreenAndSetColumns(132);
-        else
-            _currentModes.mode[m] = false;
-        break;
+      if (getMode (MODE_Allow132Columns))
+	clearScreenAndSetColumns (132);
+      else
+	_currentModes.mode[m] = false;
+      break;
+    case MODE_Mouse1000:
+    case MODE_Mouse1001:
+    case MODE_Mouse1002:
+    case MODE_Mouse1003:
+      emit programUsesMouseChanged (false);
+      break;
+
+    case MODE_AppScreen:
+      _screen[1]->clearSelection ();
+      setScreen (1);
+      break;
+    }
+  if (m < MODES_SCREEN || m == MODE_NewLine)
+    {
+      _screen[0]->setMode (m);
+      _screen[1]->setMode (m);
+    }
+}
+
+void
+Vt102Emulation::resetMode (int m)
+{
+  _currentModes.mode[m] = false;
+  switch (m)
+    {
+    case MODE_132Columns:
+      if (getMode (MODE_Allow132Columns))
+	clearScreenAndSetColumns (80);
+      break;
     case MODE_Mouse1000:
     case MODE_Mouse1001:
     case MODE_Mouse1002:
     case MODE_Mouse1003:
-         emit programUsesMouseChanged(false); 
-    break;
+      emit programUsesMouseChanged (true);
+      break;
 
-    case MODE_AppScreen : _screen[1]->clearSelection();
-                          setScreen(1);
-    break;
-  }
+    case MODE_AppScreen:
+      _screen[0]->clearSelection ();
+      setScreen (0);
+      break;
+    }
   if (m < MODES_SCREEN || m == MODE_NewLine)
-  {
-    _screen[0]->setMode(m);
-    _screen[1]->setMode(m);
-  }
+    {
+      _screen[0]->resetMode (m);
+      _screen[1]->resetMode (m);
+    }
 }
 
-void Vt102Emulation::resetMode(int m)
-{
-  _currentModes.mode[m] = false;
-  switch (m)
-  {
-    case MODE_132Columns:
-        if (getMode(MODE_Allow132Columns))
-            clearScreenAndSetColumns(80);
-        break;
-    case MODE_Mouse1000 : 
-    case MODE_Mouse1001 :
-    case MODE_Mouse1002 :
-    case MODE_Mouse1003 :
-        emit programUsesMouseChanged(true); 
-    break;
-
-    case MODE_AppScreen : 
-        _screen[0]->clearSelection();
-        setScreen(0);
-    break;
-  }
-  if (m < MODES_SCREEN || m == MODE_NewLine)
-  {
-    _screen[0]->resetMode(m);
-    _screen[1]->resetMode(m);
-  }
-}
-
-void Vt102Emulation::saveMode(int m)
+void
+Vt102Emulation::saveMode (int m)
 {
   _savedModes.mode[m] = _currentModes.mode[m];
 }
 
-void Vt102Emulation::restoreMode(int m)
+void
+Vt102Emulation::restoreMode (int m)
 {
-  if (_savedModes.mode[m]) 
-      setMode(m); 
-  else 
-      resetMode(m);
+  if (_savedModes.mode[m])
+    setMode (m);
+  else
+    resetMode (m);
 }
 
-bool Vt102Emulation::getMode(int m)
+bool
+Vt102Emulation::getMode (int m)
 {
   return _currentModes.mode[m];
 }
 
-char Vt102Emulation::eraseChar() const
+char
+Vt102Emulation::eraseChar () const
 {
-  KeyboardTranslator::Entry entry = _keyTranslator->findEntry(
-                                            Qt::Key_Backspace,
-                                            0,
-                                            0);
-  if ( entry.text().count() > 0 )
-      return entry.text()[0];
+  KeyboardTranslator::Entry entry =
+    _keyTranslator->findEntry (Qt::Key_Backspace, 0, 0);
+  if (entry.text ().count () > 0)
+    return entry.text ()[0];
   else
-      return '\b';
+    return '\b';
 }
 
 // print contents of the scan buffer
-static void hexdump(int* s, int len)
-{ int i;
+static void
+hexdump (int *s, int len)
+{
+  int i;
   for (i = 0; i < len; i++)
-  {
-    if (s[i] == '\\')
-      printf("\\\\");
-    else
-    if ((s[i]) > 32 && s[i] < 127)
-      printf("%c",s[i]);
-    else
-      printf("\\%04x(hex)",s[i]);
-  }
+    {
+      if (s[i] == '\\')
+	printf ("\\\\");
+      else if ((s[i]) > 32 && s[i] < 127)
+	printf ("%c", s[i]);
+      else
+	printf ("\\%04x(hex)", s[i]);
+    }
 }
 
-void Vt102Emulation::reportDecodingError()
+void
+Vt102Emulation::reportDecodingError ()
 {
-  if (tokenBufferPos == 0 || ( tokenBufferPos == 1 && (tokenBuffer[0] & 0xff) >= 32) ) 
+  if (tokenBufferPos == 0
+      || (tokenBufferPos == 1 && (tokenBuffer[0] & 0xff) >= 32))
     return;
-  printf("Undecodable sequence: "); 
-  hexdump(tokenBuffer,tokenBufferPos); 
-  printf("\n");
+  printf ("Undecodable sequence: ");
+  hexdump (tokenBuffer, tokenBufferPos);
+  printf ("\n");
 }
-
diff --git a/gui/src/terminal/Vt102Emulation.h b/gui/src/terminal/Vt102Emulation.h
--- a/gui/src/terminal/Vt102Emulation.h
+++ b/gui/src/terminal/Vt102Emulation.h
@@ -30,157 +30,158 @@
 #include <QtGui/QKeyEvent>
 #include <QtCore/QHash>
 #include <QtCore/QTimer>
 
 // Konsole
 #include "Emulation.h"
 #include "Screen.h"
 
-#define MODE_AppScreen       (MODES_SCREEN+0)   // Mode #1
-#define MODE_AppCuKeys       (MODES_SCREEN+1)   // Application cursor keys (DECCKM)
-#define MODE_AppKeyPad       (MODES_SCREEN+2)   // 
-#define MODE_Mouse1000       (MODES_SCREEN+3)   // Send mouse X,Y position on press and release
-#define MODE_Mouse1001       (MODES_SCREEN+4)   // Use Hilight mouse tracking
-#define MODE_Mouse1002       (MODES_SCREEN+5)   // Use cell motion mouse tracking
-#define MODE_Mouse1003       (MODES_SCREEN+6)   // Use all motion mouse tracking 
-#define MODE_Ansi            (MODES_SCREEN+7)   // Use US Ascii for character sets G0-G3 (DECANM) 
-#define MODE_132Columns      (MODES_SCREEN+8)   // 80 <-> 132 column mode switch (DECCOLM)
-#define MODE_Allow132Columns (MODES_SCREEN+9)   // Allow DECCOLM mode
+#define MODE_AppScreen       (MODES_SCREEN+0)	// Mode #1
+#define MODE_AppCuKeys       (MODES_SCREEN+1)	// Application cursor keys (DECCKM)
+#define MODE_AppKeyPad       (MODES_SCREEN+2)	//
+#define MODE_Mouse1000       (MODES_SCREEN+3)	// Send mouse X,Y position on press and release
+#define MODE_Mouse1001       (MODES_SCREEN+4)	// Use Hilight mouse tracking
+#define MODE_Mouse1002       (MODES_SCREEN+5)	// Use cell motion mouse tracking
+#define MODE_Mouse1003       (MODES_SCREEN+6)	// Use all motion mouse tracking
+#define MODE_Ansi            (MODES_SCREEN+7)	// Use US Ascii for character sets G0-G3 (DECANM)
+#define MODE_132Columns      (MODES_SCREEN+8)	// 80 <-> 132 column mode switch (DECCOLM)
+#define MODE_Allow132Columns (MODES_SCREEN+9)	// Allow DECCOLM mode
 #define MODE_total           (MODES_SCREEN+10)
 
 struct CharCodes
 {
   // coding info
-  char charset[4]; //
-  int  cu_cs;      // actual charset.
-  bool graphic;    // Some VT100 tricks
-  bool pound  ;    // Some VT100 tricks
-  bool sa_graphic; // saved graphic
-  bool sa_pound;   // saved pound
+  char charset[4];		//
+  int cu_cs;			// actual charset.
+  bool graphic;			// Some VT100 tricks
+  bool pound;			// Some VT100 tricks
+  bool sa_graphic;		// saved graphic
+  bool sa_pound;		// saved pound
 };
 
 /**
  * Provides an xterm compatible terminal emulation based on the DEC VT102 terminal.
  * A full description of this terminal can be found at
  * 
  * In addition, various additional xterm escape sequences are supported to provide 
  * features such as mouse input handling.
  * See http://rtfm.etla.org/xterm/ctlseq.html for a description of xterm's escape
  * sequences. 
  *
  */
-class Vt102Emulation : public Emulation
-{ 
-Q_OBJECT
+class Vt102Emulation:public Emulation
+{
+Q_OBJECT public:
+  /** Constructs a new emulation */
+  Vt102Emulation ();
+  ~Vt102Emulation ();
 
-public:
-  /** Constructs a new emulation */
-  Vt102Emulation();
-  ~Vt102Emulation();
-  
   // reimplemented from Emulation
-  virtual void clearEntireScreen();
-  virtual void reset();
-  virtual char eraseChar() const;
-  
-public slots: 
-  // reimplemented from Emulation 
-  virtual void sendString(const char*,int length = -1);
-  virtual void sendText(const QString& text);
-  virtual void sendKeyEvent(QKeyEvent*);
-  virtual void sendMouseEvent(int buttons, int column, int line, int eventType);
-  
+  virtual void clearEntireScreen ();
+  virtual void reset ();
+  virtual char eraseChar () const;
+
+  public slots:
+    // reimplemented from Emulation 
+    virtual void sendString (const char *, int length = -1);
+  virtual void sendText (const QString & text);
+  virtual void sendKeyEvent (QKeyEvent *);
+  virtual void sendMouseEvent (int buttons, int column, int line,
+			       int eventType);
+
 protected:
   // reimplemented from Emulation
-  virtual void setMode(int mode);
-  virtual void resetMode(int mode);
-  virtual void receiveChar(int cc);
-  
-private slots:
-  //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
-  //used to buffer multiple title updates
-  void updateTitle();
+    virtual void setMode (int mode);
+  virtual void resetMode (int mode);
+  virtual void receiveChar (int cc);
+
+  private slots:
+    //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
+    //used to buffer multiple title updates
+  void updateTitle ();
 
 private:
-  unsigned short applyCharset(unsigned short c);
-  void setCharset(int n, int cs);
-  void useCharset(int n);
-  void setAndUseCharset(int n, int cs);
-  void saveCursor();
-  void restoreCursor();
-  void resetCharset(int scrno);
+  unsigned short applyCharset (unsigned short c);
+  void setCharset (int n, int cs);
+  void useCharset (int n);
+  void setAndUseCharset (int n, int cs);
+  void saveCursor ();
+  void restoreCursor ();
+  void resetCharset (int scrno);
 
-  void setMargins(int top, int bottom);
+  void setMargins (int top, int bottom);
   //set margins for all screens back to their defaults
-  void setDefaultMargins();
+  void setDefaultMargins ();
 
   // returns true if 'mode' is set or false otherwise
-  bool getMode    (int mode);
+  bool getMode (int mode);
   // saves the current boolean value of 'mode'
-  void saveMode   (int mode);
+  void saveMode (int mode);
   // restores the boolean value of 'mode' 
-  void restoreMode(int mode);
+  void restoreMode (int mode);
   // resets all modes
   // (except MODE_Allow132Columns)
-  void resetModes();
+  void resetModes ();
 
-  void resetTokenizer();
-  #define MAX_TOKEN_LENGTH 80
-  void addToCurrentToken(int cc);
-  int tokenBuffer[MAX_TOKEN_LENGTH]; //FIXME: overflow?
+  void resetTokenizer ();
+#define MAX_TOKEN_LENGTH 80
+  void addToCurrentToken (int cc);
+  int tokenBuffer[MAX_TOKEN_LENGTH];	//FIXME: overflow?
   int tokenBufferPos;
 #define MAXARGS 15
-  void addDigit(int dig);
-  void addArgument();
+  void addDigit (int dig);
+  void addArgument ();
   int argv[MAXARGS];
   int argc;
-  void initTokenizer();
+  void initTokenizer ();
 
   // Set of flags for each of the ASCII characters which indicates
   // what category they fall into (printable character, control, digit etc.)
   // for the purposes of decoding terminal output
   int charClass[256];
 
-  void reportDecodingError(); 
+  void reportDecodingError ();
 
-  void processToken(int code, int p, int q);
-  void processWindowAttributeChange();
+  void processToken (int code, int p, int q);
+  void processWindowAttributeChange ();
 
-  void reportTerminalType();
-  void reportSecondaryAttributes();
-  void reportStatus();
-  void reportAnswerBack();
-  void reportCursorPosition();
-  void reportTerminalParms(int p);
+  void reportTerminalType ();
+  void reportSecondaryAttributes ();
+  void reportStatus ();
+  void reportAnswerBack ();
+  void reportCursorPosition ();
+  void reportTerminalParms (int p);
 
-  void onScrollLock();
-  void scrollLock(const bool lock);
+  void onScrollLock ();
+  void scrollLock (const bool lock);
 
   // clears the screen and resizes it to the specified
   // number of columns
-  void clearScreenAndSetColumns(int columnCount);
+  void clearScreenAndSetColumns (int columnCount);
 
   CharCodes _charset[2];
 
   class TerminalState
   {
   public:
     // Initializes all modes to false
-    TerminalState()
-    { memset(&mode,false,MODE_total * sizeof(bool)); }
+    TerminalState ()
+    {
+      memset (&mode, false, MODE_total * sizeof (bool));
+    }
 
     bool mode[MODE_total];
   };
 
   TerminalState _currentModes;
   TerminalState _savedModes;
 
   //hash table and timer for buffering calls to the session instance 
   //to update the name of the session
   //or window title.
   //these calls occur when certain escape sequences are seen in the 
   //output from the terminal
-  QHash<int,QString> _pendingTitleUpdates;
-  QTimer* _titleUpdateTimer;
+  QHash < int, QString > _pendingTitleUpdates;
+  QTimer *_titleUpdateTimer;
 };
 
 #endif // VT102EMULATION_H
diff --git a/gui/src/terminal/konsole_export.h b/gui/src/terminal/konsole_export.h
--- a/gui/src/terminal/konsole_export.h
+++ b/gui/src/terminal/konsole_export.h
@@ -23,45 +23,46 @@
 
 /* needed for KDE_EXPORT macros */
 //#include <kdemacros.h>
 #include <QtCore/qglobal.h>
 #define KDE_EXPORT
 #define KDE_IMPORT
 
 #ifndef KONSOLEPRIVATE_EXPORT
-# if defined(MAKE_KONSOLEPRIVATE_LIB)
+#if defined(MAKE_KONSOLEPRIVATE_LIB)
    /* We are building this library */
-#  define KONSOLEPRIVATE_EXPORT KDE_EXPORT
-# else
+#define KONSOLEPRIVATE_EXPORT KDE_EXPORT
+#else
    /* We are using this library */
-#  define KONSOLEPRIVATE_EXPORT KDE_IMPORT
-# endif
+#define KONSOLEPRIVATE_EXPORT KDE_IMPORT
+#endif
 #endif
 
 #include <iostream>
 //#define kWarning(x) std::cout
 
 #include <stdio.h>
 
 //#define i18n 
-inline QString tr(char *buff,...)
+inline QString
+tr (char *buff, ...)
 {
   char msg[2048];
-    va_list arglist;
+  va_list arglist;
 
-    va_start(arglist,buff);
+  va_start (arglist, buff);
 
-    snprintf(msg,2048,buff, arglist);
+  snprintf (msg, 2048, buff, arglist);
 
-    va_end(arglist);
+  va_end (arglist);
 
-    return QString(msg);
+  return QString (msg);
 }
 
-#define i18nc 
+#define i18nc
 
 
 //#define KDE_fseek ::fseek
 //#define KDE_lseek ::lseek
 
 
 #endif
diff --git a/gui/src/terminal/konsole_wcwidth.cpp b/gui/src/terminal/konsole_wcwidth.cpp
--- a/gui/src/terminal/konsole_wcwidth.cpp
+++ b/gui/src/terminal/konsole_wcwidth.cpp
@@ -4,37 +4,41 @@
  * "The Single UNIX Specification, Version 2, The Open Group, 1997"
  * <http://www.UNIX-systems.org/online.html>
  *
  * Markus Kuhn -- 2001-01-12 -- public domain
  */
 
 #include "konsole_wcwidth.h"
 
-struct interval {
+struct interval
+{
   unsigned short first;
   unsigned short last;
 };
 
 /* auxiliary function for binary search in interval table */
-static int bisearch(quint16 ucs, const struct interval *table, int max) {
+static int
+bisearch (quint16 ucs, const struct interval *table, int max)
+{
   int min = 0;
   int mid;
 
   if (ucs < table[0].first || ucs > table[max].last)
     return 0;
-  while (max >= min) {
-    mid = (min + max) / 2;
-    if (ucs > table[mid].last)
-      min = mid + 1;
-    else if (ucs < table[mid].first)
-      max = mid - 1;
-    else
-      return 1;
-  }
+  while (max >= min)
+    {
+      mid = (min + max) / 2;
+      if (ucs > table[mid].last)
+	min = mid + 1;
+      else if (ucs < table[mid].first)
+	max = mid - 1;
+      else
+	return 1;
+    }
 
   return 0;
 }
 
 
 /* The following functions define the column width of an ISO 10646
  * character as follows:
  *
@@ -60,157 +64,157 @@ static int bisearch(quint16 ucs, const s
  *    - All remaining characters (including all printable
  *      ISO 8859-1 and WGL4 characters, Unicode control characters,
  *      etc.) have a column width of 1.
  *
  * This implementation assumes that quint16 characters are encoded
  * in ISO 10646.
  */
 
-int konsole_wcwidth(quint16 ucs)
+int
+konsole_wcwidth (quint16 ucs)
 {
   /* sorted list of non-overlapping intervals of non-spacing characters */
   static const struct interval combining[] = {
-    { 0x0300, 0x034E }, { 0x0360, 0x0362 }, { 0x0483, 0x0486 },
-    { 0x0488, 0x0489 }, { 0x0591, 0x05A1 }, { 0x05A3, 0x05B9 },
-    { 0x05BB, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
-    { 0x05C4, 0x05C4 }, { 0x064B, 0x0655 }, { 0x0670, 0x0670 },
-    { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
-    { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
-    { 0x07A6, 0x07B0 }, { 0x0901, 0x0902 }, { 0x093C, 0x093C },
-    { 0x0941, 0x0948 }, { 0x094D, 0x094D }, { 0x0951, 0x0954 },
-    { 0x0962, 0x0963 }, { 0x0981, 0x0981 }, { 0x09BC, 0x09BC },
-    { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD }, { 0x09E2, 0x09E3 },
-    { 0x0A02, 0x0A02 }, { 0x0A3C, 0x0A3C }, { 0x0A41, 0x0A42 },
-    { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D }, { 0x0A70, 0x0A71 },
-    { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC }, { 0x0AC1, 0x0AC5 },
-    { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD }, { 0x0B01, 0x0B01 },
-    { 0x0B3C, 0x0B3C }, { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 },
-    { 0x0B4D, 0x0B4D }, { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 },
-    { 0x0BC0, 0x0BC0 }, { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 },
-    { 0x0C46, 0x0C48 }, { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 },
-    { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
-    { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D }, { 0x0DCA, 0x0DCA },
-    { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
-    { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
-    { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
-    { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
-    { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
-    { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 }, { 0x0F99, 0x0FBC },
-    { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1032 },
-    { 0x1036, 0x1037 }, { 0x1039, 0x1039 }, { 0x1058, 0x1059 },
-    { 0x1160, 0x11FF }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
-    { 0x17C9, 0x17D3 }, { 0x180B, 0x180E }, { 0x18A9, 0x18A9 },
-    { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x206A, 0x206F },
-    { 0x20D0, 0x20E3 }, { 0x302A, 0x302F }, { 0x3099, 0x309A },
-    { 0xFB1E, 0xFB1E }, { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF },
-    { 0xFFF9, 0xFFFB }
+    {0x0300, 0x034E}, {0x0360, 0x0362}, {0x0483, 0x0486},
+    {0x0488, 0x0489}, {0x0591, 0x05A1}, {0x05A3, 0x05B9},
+    {0x05BB, 0x05BD}, {0x05BF, 0x05BF}, {0x05C1, 0x05C2},
+    {0x05C4, 0x05C4}, {0x064B, 0x0655}, {0x0670, 0x0670},
+    {0x06D6, 0x06E4}, {0x06E7, 0x06E8}, {0x06EA, 0x06ED},
+    {0x070F, 0x070F}, {0x0711, 0x0711}, {0x0730, 0x074A},
+    {0x07A6, 0x07B0}, {0x0901, 0x0902}, {0x093C, 0x093C},
+    {0x0941, 0x0948}, {0x094D, 0x094D}, {0x0951, 0x0954},
+    {0x0962, 0x0963}, {0x0981, 0x0981}, {0x09BC, 0x09BC},
+    {0x09C1, 0x09C4}, {0x09CD, 0x09CD}, {0x09E2, 0x09E3},
+    {0x0A02, 0x0A02}, {0x0A3C, 0x0A3C}, {0x0A41, 0x0A42},
+    {0x0A47, 0x0A48}, {0x0A4B, 0x0A4D}, {0x0A70, 0x0A71},
+    {0x0A81, 0x0A82}, {0x0ABC, 0x0ABC}, {0x0AC1, 0x0AC5},
+    {0x0AC7, 0x0AC8}, {0x0ACD, 0x0ACD}, {0x0B01, 0x0B01},
+    {0x0B3C, 0x0B3C}, {0x0B3F, 0x0B3F}, {0x0B41, 0x0B43},
+    {0x0B4D, 0x0B4D}, {0x0B56, 0x0B56}, {0x0B82, 0x0B82},
+    {0x0BC0, 0x0BC0}, {0x0BCD, 0x0BCD}, {0x0C3E, 0x0C40},
+    {0x0C46, 0x0C48}, {0x0C4A, 0x0C4D}, {0x0C55, 0x0C56},
+    {0x0CBF, 0x0CBF}, {0x0CC6, 0x0CC6}, {0x0CCC, 0x0CCD},
+    {0x0D41, 0x0D43}, {0x0D4D, 0x0D4D}, {0x0DCA, 0x0DCA},
+    {0x0DD2, 0x0DD4}, {0x0DD6, 0x0DD6}, {0x0E31, 0x0E31},
+    {0x0E34, 0x0E3A}, {0x0E47, 0x0E4E}, {0x0EB1, 0x0EB1},
+    {0x0EB4, 0x0EB9}, {0x0EBB, 0x0EBC}, {0x0EC8, 0x0ECD},
+    {0x0F18, 0x0F19}, {0x0F35, 0x0F35}, {0x0F37, 0x0F37},
+    {0x0F39, 0x0F39}, {0x0F71, 0x0F7E}, {0x0F80, 0x0F84},
+    {0x0F86, 0x0F87}, {0x0F90, 0x0F97}, {0x0F99, 0x0FBC},
+    {0x0FC6, 0x0FC6}, {0x102D, 0x1030}, {0x1032, 0x1032},
+    {0x1036, 0x1037}, {0x1039, 0x1039}, {0x1058, 0x1059},
+    {0x1160, 0x11FF}, {0x17B7, 0x17BD}, {0x17C6, 0x17C6},
+    {0x17C9, 0x17D3}, {0x180B, 0x180E}, {0x18A9, 0x18A9},
+    {0x200B, 0x200F}, {0x202A, 0x202E}, {0x206A, 0x206F},
+    {0x20D0, 0x20E3}, {0x302A, 0x302F}, {0x3099, 0x309A},
+    {0xFB1E, 0xFB1E}, {0xFE20, 0xFE23}, {0xFEFF, 0xFEFF},
+    {0xFFF9, 0xFFFB}
   };
 
   /* test for 8-bit control characters */
   if (ucs == 0)
     return 0;
   if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
     return -1;
 
   /* binary search in table of non-spacing characters */
-  if (bisearch(ucs, combining,
-	       sizeof(combining) / sizeof(struct interval) - 1))
+  if (bisearch (ucs, combining,
+		sizeof (combining) / sizeof (struct interval) - 1))
     return 0;
 
   /* if we arrive here, ucs is not a combining or C0/C1 control character */
 
-  return 1 +
-    (ucs >= 0x1100 &&
-     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
-      (ucs >= 0x2e80 && ucs <= 0xa4cf && (ucs & ~0x0011) != 0x300a &&
-       ucs != 0x303f) ||                  /* CJK ... Yi */
-      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
-      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
-      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
-      (ucs >= 0xff00 && ucs <= 0xff5f) || /* Fullwidth Forms */
-      (ucs >= 0xffe0 && ucs <= 0xffe6) /* do not compare UINT16 with 0x20000 ||
-      (ucs >= 0x20000 && ucs <= 0x2ffff) */));
+  return 1 + (ucs >= 0x1100 && (ucs <= 0x115f ||	/* Hangul Jamo init. consonants */
+				(ucs >= 0x2e80 && ucs <= 0xa4cf && (ucs & ~0x0011) != 0x300a && ucs != 0x303f) ||	/* CJK ... Yi */
+				(ucs >= 0xac00 && ucs <= 0xd7a3) ||	/* Hangul Syllables */
+				(ucs >= 0xf900 && ucs <= 0xfaff) ||	/* CJK Compatibility Ideographs */
+				(ucs >= 0xfe30 && ucs <= 0xfe6f) ||	/* CJK Compatibility Forms */
+				(ucs >= 0xff00 && ucs <= 0xff5f) ||	/* Fullwidth Forms */
+				(ucs >= 0xffe0 && ucs <= 0xffe6)	/* do not compare UINT16 with 0x20000 ||
+									   (ucs >= 0x20000 && ucs <= 0x2ffff) */ ));
 }
 
 #if 0
 /*
  * The following function is the same as konsole_wcwidth(), except that
  * spacing characters in the East Asian Ambiguous (A) category as
  * defined in Unicode Technical Report #11 have a column width of 2.
  * This experimental variant might be useful for users of CJK legacy
  * encodings who want to migrate to UCS. It is not otherwise
  * recommended for general use.
  */
-int konsole_wcwidth_cjk(quint16 ucs)
+int
+konsole_wcwidth_cjk (quint16 ucs)
 {
   /* sorted list of non-overlapping intervals of East Asian Ambiguous
    * characters */
   static const struct interval ambiguous[] = {
-    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },
-    { 0x00AA, 0x00AA }, { 0x00AD, 0x00AD }, { 0x00B0, 0x00B4 },
-    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },
-    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },
-    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },
-    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },
-    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },
-    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },
-    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },
-    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },
-    { 0x0148, 0x014A }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },
-    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },
-    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },
-    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },
-    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },
-    { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB }, { 0x02CD, 0x02CD },
-    { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB }, { 0x02DD, 0x02DD },
-    { 0x0391, 0x03A1 }, { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 },
-    { 0x03C3, 0x03C9 }, { 0x0401, 0x0401 }, { 0x0410, 0x044F },
-    { 0x0451, 0x0451 }, { 0x2010, 0x2010 }, { 0x2013, 0x2016 },
-    { 0x2018, 0x2019 }, { 0x201C, 0x201D }, { 0x2020, 0x2021 },
-    { 0x2025, 0x2027 }, { 0x2030, 0x2030 }, { 0x2032, 0x2033 },
-    { 0x2035, 0x2035 }, { 0x203B, 0x203B }, { 0x2074, 0x2074 },
-    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },
-    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },
-    { 0x2113, 0x2113 }, { 0x2121, 0x2122 }, { 0x2126, 0x2126 },
-    { 0x212B, 0x212B }, { 0x2154, 0x2155 }, { 0x215B, 0x215B },
-    { 0x215E, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },
-    { 0x2190, 0x2199 }, { 0x21D2, 0x21D2 }, { 0x21D4, 0x21D4 },
-    { 0x2200, 0x2200 }, { 0x2202, 0x2203 }, { 0x2207, 0x2208 },
-    { 0x220B, 0x220B }, { 0x220F, 0x220F }, { 0x2211, 0x2211 },
-    { 0x2215, 0x2215 }, { 0x221A, 0x221A }, { 0x221D, 0x2220 },
-    { 0x2223, 0x2223 }, { 0x2225, 0x2225 }, { 0x2227, 0x222C },
-    { 0x222E, 0x222E }, { 0x2234, 0x2237 }, { 0x223C, 0x223D },
-    { 0x2248, 0x2248 }, { 0x224C, 0x224C }, { 0x2252, 0x2252 },
-    { 0x2260, 0x2261 }, { 0x2264, 0x2267 }, { 0x226A, 0x226B },
-    { 0x226E, 0x226F }, { 0x2282, 0x2283 }, { 0x2286, 0x2287 },
-    { 0x2295, 0x2295 }, { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 },
-    { 0x22BF, 0x22BF }, { 0x2312, 0x2312 }, { 0x2460, 0x24BF },
-    { 0x24D0, 0x24E9 }, { 0x2500, 0x254B }, { 0x2550, 0x2574 },
-    { 0x2580, 0x258F }, { 0x2592, 0x2595 }, { 0x25A0, 0x25A1 },
-    { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 }, { 0x25B6, 0x25B7 },
-    { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 }, { 0x25C6, 0x25C8 },
-    { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 }, { 0x25E2, 0x25E5 },
-    { 0x25EF, 0x25EF }, { 0x2605, 0x2606 }, { 0x2609, 0x2609 },
-    { 0x260E, 0x260F }, { 0x261C, 0x261C }, { 0x261E, 0x261E },
-    { 0x2640, 0x2640 }, { 0x2642, 0x2642 }, { 0x2660, 0x2661 },
-    { 0x2663, 0x2665 }, { 0x2667, 0x266A }, { 0x266C, 0x266D },
-    { 0x266F, 0x266F }, { 0x300A, 0x300B }, { 0x301A, 0x301B },
-    { 0xE000, 0xF8FF }, { 0xFFFD, 0xFFFD }
+    {0x00A1, 0x00A1}, {0x00A4, 0x00A4}, {0x00A7, 0x00A8},
+    {0x00AA, 0x00AA}, {0x00AD, 0x00AD}, {0x00B0, 0x00B4},
+    {0x00B6, 0x00BA}, {0x00BC, 0x00BF}, {0x00C6, 0x00C6},
+    {0x00D0, 0x00D0}, {0x00D7, 0x00D8}, {0x00DE, 0x00E1},
+    {0x00E6, 0x00E6}, {0x00E8, 0x00EA}, {0x00EC, 0x00ED},
+    {0x00F0, 0x00F0}, {0x00F2, 0x00F3}, {0x00F7, 0x00FA},
+    {0x00FC, 0x00FC}, {0x00FE, 0x00FE}, {0x0101, 0x0101},
+    {0x0111, 0x0111}, {0x0113, 0x0113}, {0x011B, 0x011B},
+    {0x0126, 0x0127}, {0x012B, 0x012B}, {0x0131, 0x0133},
+    {0x0138, 0x0138}, {0x013F, 0x0142}, {0x0144, 0x0144},
+    {0x0148, 0x014A}, {0x014D, 0x014D}, {0x0152, 0x0153},
+    {0x0166, 0x0167}, {0x016B, 0x016B}, {0x01CE, 0x01CE},
+    {0x01D0, 0x01D0}, {0x01D2, 0x01D2}, {0x01D4, 0x01D4},
+    {0x01D6, 0x01D6}, {0x01D8, 0x01D8}, {0x01DA, 0x01DA},
+    {0x01DC, 0x01DC}, {0x0251, 0x0251}, {0x0261, 0x0261},
+    {0x02C7, 0x02C7}, {0x02C9, 0x02CB}, {0x02CD, 0x02CD},
+    {0x02D0, 0x02D0}, {0x02D8, 0x02DB}, {0x02DD, 0x02DD},
+    {0x0391, 0x03A1}, {0x03A3, 0x03A9}, {0x03B1, 0x03C1},
+    {0x03C3, 0x03C9}, {0x0401, 0x0401}, {0x0410, 0x044F},
+    {0x0451, 0x0451}, {0x2010, 0x2010}, {0x2013, 0x2016},
+    {0x2018, 0x2019}, {0x201C, 0x201D}, {0x2020, 0x2021},
+    {0x2025, 0x2027}, {0x2030, 0x2030}, {0x2032, 0x2033},
+    {0x2035, 0x2035}, {0x203B, 0x203B}, {0x2074, 0x2074},
+    {0x207F, 0x207F}, {0x2081, 0x2084}, {0x20AC, 0x20AC},
+    {0x2103, 0x2103}, {0x2105, 0x2105}, {0x2109, 0x2109},
+    {0x2113, 0x2113}, {0x2121, 0x2122}, {0x2126, 0x2126},
+    {0x212B, 0x212B}, {0x2154, 0x2155}, {0x215B, 0x215B},
+    {0x215E, 0x215E}, {0x2160, 0x216B}, {0x2170, 0x2179},
+    {0x2190, 0x2199}, {0x21D2, 0x21D2}, {0x21D4, 0x21D4},
+    {0x2200, 0x2200}, {0x2202, 0x2203}, {0x2207, 0x2208},
+    {0x220B, 0x220B}, {0x220F, 0x220F}, {0x2211, 0x2211},
+    {0x2215, 0x2215}, {0x221A, 0x221A}, {0x221D, 0x2220},
+    {0x2223, 0x2223}, {0x2225, 0x2225}, {0x2227, 0x222C},
+    {0x222E, 0x222E}, {0x2234, 0x2237}, {0x223C, 0x223D},
+    {0x2248, 0x2248}, {0x224C, 0x224C}, {0x2252, 0x2252},
+    {0x2260, 0x2261}, {0x2264, 0x2267}, {0x226A, 0x226B},
+    {0x226E, 0x226F}, {0x2282, 0x2283}, {0x2286, 0x2287},
+    {0x2295, 0x2295}, {0x2299, 0x2299}, {0x22A5, 0x22A5},
+    {0x22BF, 0x22BF}, {0x2312, 0x2312}, {0x2460, 0x24BF},
+    {0x24D0, 0x24E9}, {0x2500, 0x254B}, {0x2550, 0x2574},
+    {0x2580, 0x258F}, {0x2592, 0x2595}, {0x25A0, 0x25A1},
+    {0x25A3, 0x25A9}, {0x25B2, 0x25B3}, {0x25B6, 0x25B7},
+    {0x25BC, 0x25BD}, {0x25C0, 0x25C1}, {0x25C6, 0x25C8},
+    {0x25CB, 0x25CB}, {0x25CE, 0x25D1}, {0x25E2, 0x25E5},
+    {0x25EF, 0x25EF}, {0x2605, 0x2606}, {0x2609, 0x2609},
+    {0x260E, 0x260F}, {0x261C, 0x261C}, {0x261E, 0x261E},
+    {0x2640, 0x2640}, {0x2642, 0x2642}, {0x2660, 0x2661},
+    {0x2663, 0x2665}, {0x2667, 0x266A}, {0x266C, 0x266D},
+    {0x266F, 0x266F}, {0x300A, 0x300B}, {0x301A, 0x301B},
+    {0xE000, 0xF8FF}, {0xFFFD, 0xFFFD}
   };
 
   /* binary search in table of non-spacing characters */
-  if (bisearch(ucs, ambiguous,
-	       sizeof(ambiguous) / sizeof(struct interval) - 1))
+  if (bisearch (ucs, ambiguous,
+		sizeof (ambiguous) / sizeof (struct interval) - 1))
     return 2;
 
-  return konsole_wcwidth(ucs);
+  return konsole_wcwidth (ucs);
 }
 #endif
 
 // single byte char: +1, multi byte char: +2
-int string_width( const QString &txt )
+int
+string_width (const QString & txt)
 {
   int w = 0;
-  for ( int i = 0; i < txt.length(); ++i )
-     w += konsole_wcwidth( txt[ i ].unicode() );
- return w;
+  for (int i = 0; i < txt.length (); ++i)
+    w += konsole_wcwidth (txt[i].unicode ());
+  return w;
 }
diff --git a/gui/src/terminal/konsole_wcwidth.h b/gui/src/terminal/konsole_wcwidth.h
--- a/gui/src/terminal/konsole_wcwidth.h
+++ b/gui/src/terminal/konsole_wcwidth.h
@@ -9,16 +9,16 @@
 
 #ifndef	_KONSOLE_WCWIDTH_H_
 #define	_KONSOLE_WCWIDTH_H_
 
 // Qt
 #include <QtCore/QBool>
 #include <QtCore/QString>
 
-int konsole_wcwidth(quint16 ucs);
+int konsole_wcwidth (quint16 ucs);
 #if 0
-int konsole_wcwidth_cjk(Q_UINT16 ucs);
+int konsole_wcwidth_cjk (Q_UINT16 ucs);
 #endif
 
-int string_width( const QString &txt );
+int string_width (const QString & txt);
 
 #endif
diff --git a/gui/src/terminal/kprocess.cpp b/gui/src/terminal/kprocess.cpp
--- a/gui/src/terminal/kprocess.cpp
+++ b/gui/src/terminal/kprocess.cpp
@@ -19,327 +19,361 @@
     Boston, MA 02110-1301, USA.
 */
 
 #include "kprocess_p.h"
 
 #include <qfile.h>
 
 #ifdef Q_OS_WIN
-# include <windows.h>
+#include <windows.h>
 #else
-# include <unistd.h>
-# include <errno.h>
+#include <unistd.h>
+#include <errno.h>
 #endif
 
 #ifndef Q_OS_WIN
-# define STD_OUTPUT_HANDLE 1
-# define STD_ERROR_HANDLE 2
+#define STD_OUTPUT_HANDLE 1
+#define STD_ERROR_HANDLE 2
 #endif
 
 #ifdef _WIN32_WCE
 #include <stdio.h>
 #endif
 
-void KProcessPrivate::writeAll(const QByteArray &buf, int fd)
+void
+KProcessPrivate::writeAll (const QByteArray & buf, int fd)
 {
 #ifdef Q_OS_WIN
 #ifndef _WIN32_WCE
-    HANDLE h = GetStdHandle(fd);
-    if (h) {
-        DWORD wr;
-        WriteFile(h, buf.data(), buf.size(), &wr, 0);
+  HANDLE h = GetStdHandle (fd);
+  if (h)
+    {
+      DWORD wr;
+      WriteFile (h, buf.data (), buf.size (), &wr, 0);
     }
 #else
-    fwrite(buf.data(), 1, buf.size(), (FILE*)fd);
+  fwrite (buf.data (), 1, buf.size (), (FILE *) fd);
 #endif
 #else
-    int off = 0;
-    do {
-        int ret = ::write(fd, buf.data() + off, buf.size() - off);
-        if (ret < 0) {
-            if (errno != EINTR)
-                return;
-        } else {
-            off += ret;
-        }
-    } while (off < buf.size());
+  int off = 0;
+  do
+    {
+      int ret =::write (fd, buf.data () + off, buf.size () - off);
+      if (ret < 0)
+	{
+	  if (errno != EINTR)
+	    return;
+	}
+      else
+	{
+	  off += ret;
+	}
+    }
+  while (off < buf.size ());
 #endif
 }
 
-void KProcessPrivate::forwardStd(KProcess::ProcessChannel good, int fd)
+void
+KProcessPrivate::forwardStd (KProcess::ProcessChannel good, int fd)
 {
-    Q_Q(KProcess);
+  Q_Q (KProcess);
 
-    QProcess::ProcessChannel oc = q->readChannel();
-    q->setReadChannel(good);
-    writeAll(q->readAll(), fd);
-    q->setReadChannel(oc);
+  QProcess::ProcessChannel oc = q->readChannel ();
+  q->setReadChannel (good);
+  writeAll (q->readAll (), fd);
+  q->setReadChannel (oc);
 }
 
-void KProcessPrivate::_k_forwardStdout()
+void
+KProcessPrivate::_k_forwardStdout ()
 {
 #ifndef _WIN32_WCE
-    forwardStd(KProcess::StandardOutput, STD_OUTPUT_HANDLE);
+  forwardStd (KProcess::StandardOutput, STD_OUTPUT_HANDLE);
 #else
-    forwardStd(KProcess::StandardOutput, (int)stdout);
+  forwardStd (KProcess::StandardOutput, (int) stdout);
 #endif
 }
 
-void KProcessPrivate::_k_forwardStderr()
+void
+KProcessPrivate::_k_forwardStderr ()
 {
 #ifndef _WIN32_WCE
-    forwardStd(KProcess::StandardError, STD_ERROR_HANDLE);
+  forwardStd (KProcess::StandardError, STD_ERROR_HANDLE);
 #else
-    forwardStd(KProcess::StandardError, (int)stderr);
+  forwardStd (KProcess::StandardError, (int) stderr);
 #endif
 }
 
 /////////////////////////////
 // public member functions //
 /////////////////////////////
 
-KProcess::KProcess(QObject *parent) :
-    QProcess(parent),
-    d_ptr(new KProcessPrivate)
+KProcess::KProcess (QObject * parent):
+QProcess (parent), d_ptr (new KProcessPrivate)
 {
-    d_ptr->q_ptr = this;
-    setOutputChannelMode(ForwardedChannels);
+  d_ptr->q_ptr = this;
+  setOutputChannelMode (ForwardedChannels);
 }
 
-KProcess::KProcess(KProcessPrivate *d, QObject *parent) :
-    QProcess(parent),
-    d_ptr(d)
+KProcess::KProcess (KProcessPrivate * d, QObject * parent):
+QProcess (parent), d_ptr (d)
 {
-    d_ptr->q_ptr = this;
-    setOutputChannelMode(ForwardedChannels);
+  d_ptr->q_ptr = this;
+  setOutputChannelMode (ForwardedChannels);
 }
 
-KProcess::~KProcess()
+KProcess::~KProcess ()
 {
-    delete d_ptr;
+  delete d_ptr;
 }
 
-void KProcess::setOutputChannelMode(OutputChannelMode mode)
+void
+KProcess::setOutputChannelMode (OutputChannelMode mode)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    d->outputChannelMode = mode;
-    disconnect(this, SIGNAL(readyReadStandardOutput()));
-    disconnect(this, SIGNAL(readyReadStandardError()));
-    switch (mode) {
+  d->outputChannelMode = mode;
+  disconnect (this, SIGNAL (readyReadStandardOutput ()));
+  disconnect (this, SIGNAL (readyReadStandardError ()));
+  switch (mode)
+    {
     case OnlyStdoutChannel:
-        connect(this, SIGNAL(readyReadStandardError()), SLOT(_k_forwardStderr()));
-        break;
+      connect (this, SIGNAL (readyReadStandardError ()),
+	       SLOT (_k_forwardStderr ()));
+      break;
     case OnlyStderrChannel:
-        connect(this, SIGNAL(readyReadStandardOutput()), SLOT(_k_forwardStdout()));
-        break;
+      connect (this, SIGNAL (readyReadStandardOutput ()),
+	       SLOT (_k_forwardStdout ()));
+      break;
     default:
-        QProcess::setProcessChannelMode((ProcessChannelMode)mode);
-        return;
+      QProcess::setProcessChannelMode ((ProcessChannelMode) mode);
+      return;
     }
-    QProcess::setProcessChannelMode(QProcess::SeparateChannels);
+  QProcess::setProcessChannelMode (QProcess::SeparateChannels);
 }
 
-KProcess::OutputChannelMode KProcess::outputChannelMode() const
+KProcess::OutputChannelMode KProcess::outputChannelMode () const
 {
-    Q_D(const KProcess);
+  Q_D (const KProcess);
 
-    return d->outputChannelMode;
+  return d->outputChannelMode;
 }
 
-void KProcess::setNextOpenMode(QIODevice::OpenMode mode)
+void
+KProcess::setNextOpenMode (QIODevice::OpenMode mode)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    d->openMode = mode;
+  d->openMode = mode;
 }
 
 #define DUMMYENV "_KPROCESS_DUMMY_="
 
-void KProcess::clearEnvironment()
+void
+KProcess::clearEnvironment ()
 {
-    setEnvironment(QStringList() << QString::fromLatin1(DUMMYENV));
+  setEnvironment (QStringList () << QString::fromLatin1 (DUMMYENV));
 }
 
-void KProcess::setEnv(const QString &name, const QString &value, bool overwrite)
+void
+KProcess::setEnv (const QString & name, const QString & value, bool overwrite)
 {
-    QStringList env = environment();
-    if (env.isEmpty()) {
-        env = systemEnvironment();
-        env.removeAll(QString::fromLatin1(DUMMYENV));
+  QStringList env = environment ();
+  if (env.isEmpty ())
+    {
+      env = systemEnvironment ();
+      env.removeAll (QString::fromLatin1 (DUMMYENV));
     }
-    QString fname(name);
-    fname.append(QLatin1Char('='));
-    for (QStringList::Iterator it = env.begin(); it != env.end(); ++it)
-        if ((*it).startsWith(fname)) {
-            if (overwrite) {
-                *it = fname.append(value);
-                setEnvironment(env);
-            }
-            return;
-        }
-    env.append(fname.append(value));
-    setEnvironment(env);
+  QString fname (name);
+  fname.append (QLatin1Char ('='));
+  for (QStringList::Iterator it = env.begin (); it != env.end (); ++it)
+    if ((*it).startsWith (fname))
+      {
+	if (overwrite)
+	  {
+	    *it = fname.append (value);
+	    setEnvironment (env);
+	  }
+	return;
+      }
+  env.append (fname.append (value));
+  setEnvironment (env);
 }
 
-void KProcess::unsetEnv(const QString &name)
+void
+KProcess::unsetEnv (const QString & name)
 {
-    QStringList env = environment();
-    if (env.isEmpty()) {
-        env = systemEnvironment();
-        env.removeAll(QString::fromLatin1(DUMMYENV));
+  QStringList env = environment ();
+  if (env.isEmpty ())
+    {
+      env = systemEnvironment ();
+      env.removeAll (QString::fromLatin1 (DUMMYENV));
     }
-    QString fname(name);
-    fname.append(QLatin1Char('='));
-    for (QStringList::Iterator it = env.begin(); it != env.end(); ++it)
-        if ((*it).startsWith(fname)) {
-            env.erase(it);
-            if (env.isEmpty())
-                env.append(QString::fromLatin1(DUMMYENV));
-            setEnvironment(env);
-            return;
-        }
+  QString fname (name);
+  fname.append (QLatin1Char ('='));
+  for (QStringList::Iterator it = env.begin (); it != env.end (); ++it)
+    if ((*it).startsWith (fname))
+      {
+	env.erase (it);
+	if (env.isEmpty ())
+	  env.append (QString::fromLatin1 (DUMMYENV));
+	setEnvironment (env);
+	return;
+      }
 }
 
-void KProcess::setProgram(const QString &exe, const QStringList &args)
+void
+KProcess::setProgram (const QString & exe, const QStringList & args)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    d->prog = exe;
-    d->args = args;
+  d->prog = exe;
+  d->args = args;
 #ifdef Q_OS_WIN
-    setNativeArguments(QString());
+  setNativeArguments (QString ());
 #endif
 }
 
-void KProcess::setProgram(const QStringList &argv)
+void
+KProcess::setProgram (const QStringList & argv)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    Q_ASSERT( !argv.isEmpty() );
-    d->args = argv;
-    d->prog = d->args.takeFirst();
+  Q_ASSERT (!argv.isEmpty ());
+  d->args = argv;
+  d->prog = d->args.takeFirst ();
 #ifdef Q_OS_WIN
-    setNativeArguments(QString());
+  setNativeArguments (QString ());
 #endif
 }
 
-KProcess &KProcess::operator<<(const QString &arg)
+KProcess & KProcess::operator<< (const QString & arg)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    if (d->prog.isEmpty())
-        d->prog = arg;
-    else
-        d->args << arg;
-    return *this;
+  if (d->prog.isEmpty ())
+    d->prog = arg;
+  else
+    d->args << arg;
+  return *this;
 }
 
-KProcess &KProcess::operator<<(const QStringList &args)
+KProcess & KProcess::operator<< (const QStringList & args)
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    if (d->prog.isEmpty())
-        setProgram(args);
-    else
-        d->args << args;
-    return *this;
+  if (d->prog.isEmpty ())
+    setProgram (args);
+  else
+    d->args << args;
+  return *this;
 }
 
-void KProcess::clearProgram()
+void
+KProcess::clearProgram ()
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    d->prog.clear();
-    d->args.clear();
+  d->prog.clear ();
+  d->args.clear ();
 #ifdef Q_OS_WIN
-    setNativeArguments(QString());
+  setNativeArguments (QString ());
 #endif
 }
 
-void KProcess::setShellCommand(const QString &cmd)
+void
+KProcess::setShellCommand (const QString & cmd)
 {
-    Q_D(KProcess);
-    d->args.clear();
-    d->prog = QString::fromLatin1("/bin/sh");
-    d->args << QString::fromLatin1("-c") << cmd;
+  Q_D (KProcess);
+  d->args.clear ();
+  d->prog = QString::fromLatin1 ("/bin/sh");
+  d->args << QString::fromLatin1 ("-c") << cmd;
 }
 
-QStringList KProcess::program() const
+QStringList
+KProcess::program () const
 {
-    Q_D(const KProcess);
+  Q_D (const KProcess);
 
-    QStringList argv = d->args;
-    argv.prepend(d->prog);
-    return argv;
+  QStringList argv = d->args;
+  argv.prepend (d->prog);
+  return argv;
 }
 
-void KProcess::start()
+void
+KProcess::start ()
 {
-    Q_D(KProcess);
+  Q_D (KProcess);
 
-    QProcess::start(d->prog, d->args, d->openMode);
+  QProcess::start (d->prog, d->args, d->openMode);
 }
 
-int KProcess::execute(int msecs)
+int
+KProcess::execute (int msecs)
 {
-    start();
-    if (!waitForFinished(msecs)) {
-        kill();
-        waitForFinished(-1);
-        return -2;
+  start ();
+  if (!waitForFinished (msecs))
+    {
+      kill ();
+      waitForFinished (-1);
+      return -2;
     }
-    return (exitStatus() == QProcess::NormalExit) ? exitCode() : -1;
-}
-
-// static
-int KProcess::execute(const QString &exe, const QStringList &args, int msecs)
-{
-    KProcess p;
-    p.setProgram(exe, args);
-    return p.execute(msecs);
+  return (exitStatus () == QProcess::NormalExit) ? exitCode () : -1;
 }
 
 // static
-int KProcess::execute(const QStringList &argv, int msecs)
+int
+KProcess::execute (const QString & exe, const QStringList & args, int msecs)
 {
-    KProcess p;
-    p.setProgram(argv);
-    return p.execute(msecs);
-}
-
-int KProcess::startDetached()
-{
-    Q_D(KProcess);
-
-    qint64 pid;
-    if (!QProcess::startDetached(d->prog, d->args, workingDirectory(), &pid))
-        return 0;
-    return (int) pid;
+  KProcess p;
+  p.setProgram (exe, args);
+  return p.execute (msecs);
 }
 
 // static
-int KProcess::startDetached(const QString &exe, const QStringList &args)
+int
+KProcess::execute (const QStringList & argv, int msecs)
 {
-    qint64 pid;
-    if (!QProcess::startDetached(exe, args, QString(), &pid))
-        return 0;
-    return (int) pid;
+  KProcess p;
+  p.setProgram (argv);
+  return p.execute (msecs);
+}
+
+int
+KProcess::startDetached ()
+{
+  Q_D (KProcess);
+
+  qint64 pid;
+  if (!QProcess::startDetached (d->prog, d->args, workingDirectory (), &pid))
+    return 0;
+  return (int) pid;
 }
 
 // static
-int KProcess::startDetached(const QStringList &argv)
+int
+KProcess::startDetached (const QString & exe, const QStringList & args)
 {
-    QStringList args = argv;
-    QString prog = args.takeFirst();
-    return startDetached(prog, args);
+  qint64 pid;
+  if (!QProcess::startDetached (exe, args, QString (), &pid))
+    return 0;
+  return (int) pid;
 }
 
-int KProcess::pid() const
+// static
+int
+KProcess::startDetached (const QStringList & argv)
+{
+  QStringList args = argv;
+  QString prog = args.takeFirst ();
+  return startDetached (prog, args);
+}
+
+int
+KProcess::pid () const
 {
 #ifdef Q_OS_UNIX
-    return (int) QProcess::pid();
+  return (int) QProcess::pid ();
 #else
-    return QProcess::pid() ? QProcess::pid()->dwProcessId : 0;
+  return QProcess::pid ()? QProcess::pid ()->dwProcessId : 0;
 #endif
 }
-
diff --git a/gui/src/terminal/kprocess.h b/gui/src/terminal/kprocess.h
--- a/gui/src/terminal/kprocess.h
+++ b/gui/src/terminal/kprocess.h
@@ -35,131 +35,131 @@ class KProcessPrivate;
  * This class extends QProcess by some useful functionality, overrides
  * some defaults with saner values and wraps parts of the API into a more
  * accessible one.
  * This is the preferred way of spawning child processes in KDE; don't
  * use QProcess directly.
  *
  * @author Oswald Buddenhagen <ossi@kde.org>
  **/
-class KProcess : public QProcess
+class KProcess:public QProcess
 {
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(KProcess)
-
-public:
+Q_OBJECT Q_DECLARE_PRIVATE (KProcess) public:
 
     /**
      * Modes in which the output channels can be opened.
      */
-    enum OutputChannelMode {
-        SeparateChannels = QProcess::SeparateChannels,
-            /**< Standard output and standard error are handled by KProcess
+  enum OutputChannelMode
+  {
+    SeparateChannels = QProcess::SeparateChannels,
+	    /**< Standard output and standard error are handled by KProcess
                  as separate channels */
-        MergedChannels = QProcess::MergedChannels,
-            /**< Standard output and standard error are handled by KProcess
+    MergedChannels = QProcess::MergedChannels,
+	    /**< Standard output and standard error are handled by KProcess
                  as one channel */
-        ForwardedChannels = QProcess::ForwardedChannels,
-            /**< Both standard output and standard error are forwarded
+    ForwardedChannels = QProcess::ForwardedChannels,
+	    /**< Both standard output and standard error are forwarded
                  to the parent process' respective channel */
-        OnlyStdoutChannel,
-            /**< Only standard output is handled; standard error is forwarded */
-        OnlyStderrChannel  /**< Only standard error is handled; standard output is forwarded */
-    };
+    OnlyStdoutChannel,
+	    /**< Only standard output is handled; standard error is forwarded */
+    OnlyStderrChannel	   /**< Only standard error is handled; standard output is forwarded */
+  };
 
     /**
      * Constructor
      */
-    explicit KProcess(QObject *parent = 0);
+  explicit KProcess (QObject * parent = 0);
 
     /**
      * Destructor
      */
-    virtual ~KProcess();
+    virtual ~ KProcess ();
 
     /**
      * Set how to handle the output channels of the child process.
      *
      * The default is ForwardedChannels, which is unlike in QProcess.
      * Do not request more than you actually handle, as this output is
      * simply lost otherwise.
      *
      * This function must be called before starting the process.
      *
      * @param mode the output channel handling mode
      */
-    void setOutputChannelMode(OutputChannelMode mode);
+  void setOutputChannelMode (OutputChannelMode mode);
 
     /**
      * Query how the output channels of the child process are handled.
      *
      * @return the output channel handling mode
      */
-    OutputChannelMode outputChannelMode() const;
+  OutputChannelMode outputChannelMode () const;
 
     /**
      * Set the QIODevice open mode the process will be opened in.
      *
      * This function must be called before starting the process, obviously.
      *
      * @param mode the open mode. Note that this mode is automatically
      *   "reduced" according to the channel modes and redirections.
      *   The default is QIODevice::ReadWrite.
      */
-    void setNextOpenMode(QIODevice::OpenMode mode);
+  void setNextOpenMode (QIODevice::OpenMode mode);
 
     /**
      * Adds the variable @p name to the process' environment.
      *
      * This function must be called before starting the process.
      *
      * @param name the name of the environment variable
      * @param value the new value for the environment variable
      * @param overwrite if @c false and the environment variable is already
      *   set, the old value will be preserved
      */
-    void setEnv(const QString &name, const QString &value, bool overwrite = true);
+  void setEnv (const QString & name, const QString & value, bool overwrite =
+	       true);
 
     /**
      * Removes the variable @p name from the process' environment.
      *
      * This function must be called before starting the process.
      *
      * @param name the name of the environment variable
      */
-    void unsetEnv(const QString &name);
+  void unsetEnv (const QString & name);
 
     /**
      * Empties the process' environment.
      *
      * Note that LD_LIBRARY_PATH/DYLD_LIBRARY_PATH is automatically added
      * on *NIX.
      *
      * This function must be called before starting the process.
      */
-    void clearEnvironment();
+  void clearEnvironment ();
 
     /**
      * Set the program and the command line arguments.
      *
      * This function must be called before starting the process, obviously.
      *
      * @param exe the program to execute
      * @param args the command line arguments for the program,
      *   one per list element
      */
-    void setProgram(const QString &exe, const QStringList &args = QStringList());
+  void setProgram (const QString & exe, const QStringList & args =
+		   QStringList ());
 
     /**
      * @overload
      *
      * @param argv the program to execute and the command line arguments
      *   for the program, one per list element
      */
-    void setProgram(const QStringList &argv);
+  void setProgram (const QStringList & argv);
 
     /**
      * Append an element to the command line argument list for this process.
      *
      * If no executable is set yet, it will be set instead.
      *
      * For example, doing an "ls -l /usr/local/bin" can be achieved by:
      *  \code
@@ -168,30 +168,30 @@ public:
      *  ...
      *  \endcode
      *
      * This function must be called before starting the process, obviously.
      *
      * @param arg the argument to add
      * @return a reference to this KProcess
      */
-    KProcess &operator<<(const QString& arg);
+    KProcess & operator<< (const QString & arg);
 
     /**
      * @overload
      *
      * @param args the arguments to add
      * @return a reference to this KProcess
      */
-    KProcess &operator<<(const QStringList& args);
+    KProcess & operator<< (const QStringList & args);
 
     /**
      * Clear the program and command line argument list.
      */
-    void clearProgram();
+  void clearProgram ();
 
     /**
      * Set a command to execute through a shell (a POSIX sh on *NIX
      * and cmd.exe on Windows).
      *
      * Using this for anything but user-supplied commands is usually a bad
      * idea, as the command's syntax depends on the platform.
      * Redirections including pipes, etc. are better handled by the
@@ -203,32 +203,32 @@ public:
      *
      * This function must be called before starting the process, obviously.
      *
      * @param cmd the command to execute through a shell.
      *   The caller must make sure that all filenames etc. are properly
      *   quoted when passed as argument. Failure to do so often results in
      *   serious security holes. See KShell::quoteArg().
      */
-    void setShellCommand(const QString &cmd);
+  void setShellCommand (const QString & cmd);
 
     /**
      * Obtain the currently set program and arguments.
      *
      * @return a list, the first element being the program, the remaining ones
      *  being command line arguments to the program.
      */
-    QStringList program() const;
+  QStringList program () const;
 
     /**
      * Start the process.
      *
      * @see QProcess::start(const QString &, const QStringList &, OpenMode)
      */
-    void start();
+  void start ();
 
     /**
      * Start the process, wait for it to finish, and return the exit code.
      *
      * This method is roughly equivalent to the sequence:
      * <code>
      *   start();
      *   waitForFinished(msecs);
@@ -237,106 +237,106 @@ public:
      *
      * Unlike the other execute() variants this method is not static,
      * so the process can be parametrized properly and talked to.
      *
      * @param msecs time to wait for process to exit before killing it
      * @return -2 if the process could not be started, -1 if it crashed,
      *  otherwise its exit code
      */
-    int execute(int msecs = -1);
+  int execute (int msecs = -1);
 
     /**
      * @overload
      *
      * @param exe the program to execute
      * @param args the command line arguments for the program,
      *   one per list element
      * @param msecs time to wait for process to exit before killing it
      * @return -2 if the process could not be started, -1 if it crashed,
      *  otherwise its exit code
      */
-    static int execute(const QString &exe, const QStringList &args = QStringList(), int msecs = -1);
+  static int execute (const QString & exe, const QStringList & args =
+		      QStringList (), int msecs = -1);
 
     /**
      * @overload
      *
      * @param argv the program to execute and the command line arguments
      *   for the program, one per list element
      * @param msecs time to wait for process to exit before killing it
      * @return -2 if the process could not be started, -1 if it crashed,
      *  otherwise its exit code
      */
-    static int execute(const QStringList &argv, int msecs = -1);
+  static int execute (const QStringList & argv, int msecs = -1);
 
     /**
      * Start the process and detach from it. See QProcess::startDetached()
      * for details.
      *
      * Unlike the other startDetached() variants this method is not static,
      * so the process can be parametrized properly.
      * @note Currently, only the setProgram()/setShellCommand() and
      * setWorkingDirectory() parametrizations are supported.
      *
      * The KProcess object may be re-used immediately after calling this
      * function.
      *
      * @return the PID of the started process or 0 on error
      */
-    int startDetached();
+  int startDetached ();
 
     /**
      * @overload
      *
      * @param exe the program to start
      * @param args the command line arguments for the program,
      *   one per list element
      * @return the PID of the started process or 0 on error
      */
-    static int startDetached(const QString &exe, const QStringList &args = QStringList());
+  static int startDetached (const QString & exe, const QStringList & args =
+			    QStringList ());
 
     /**
      * @overload
      *
      * @param argv the program to start and the command line arguments
      *   for the program, one per list element
      * @return the PID of the started process or 0 on error
      */
-    static int startDetached(const QStringList &argv);
+  static int startDetached (const QStringList & argv);
 
     /**
      * Obtain the process' ID as known to the system.
      *
      * Unlike with QProcess::pid(), this is a real PID also on Windows.
      *
      * This function can be called only while the process is running.
      * It cannot be applied to detached processes.
      *
      * @return the process ID
      */
-    int pid() const;
+  int pid () const;
 
 protected:
     /**
      * @internal
      */
-    KProcess(KProcessPrivate *d, QObject *parent);
+    KProcess (KProcessPrivate * d, QObject * parent);
 
     /**
      * @internal
      */
-    KProcessPrivate * const d_ptr;
+  KProcessPrivate *const d_ptr;
 
 private:
-    // hide those
+  // hide those
     using QProcess::setReadChannelMode;
-    using QProcess::readChannelMode;
-    using QProcess::setProcessChannelMode;
-    using QProcess::processChannelMode;
+  using QProcess::readChannelMode;
+  using QProcess::setProcessChannelMode;
+  using QProcess::processChannelMode;
 
-    Q_PRIVATE_SLOT(d_func(), void _k_forwardStdout())
-    Q_PRIVATE_SLOT(d_func(), void _k_forwardStderr())
-};
+  Q_PRIVATE_SLOT (d_func (), void _k_forwardStdout ())
+    Q_PRIVATE_SLOT (d_func (), void _k_forwardStderr ())};
 
 #include "kprocess_p.h"
 
 #endif
-
diff --git a/gui/src/terminal/kprocess_p.h b/gui/src/terminal/kprocess_p.h
--- a/gui/src/terminal/kprocess_p.h
+++ b/gui/src/terminal/kprocess_p.h
@@ -20,30 +20,29 @@
 */
 
 #ifndef KPROCESS_P_H
 #define KPROCESS_P_H
 class KProcess;
 class KProcessPrivate;
 
 #include "kprocess.h"
-class KProcessPrivate {
-    Q_DECLARE_PUBLIC(KProcess)
-protected:
-    KProcessPrivate() :
-        openMode(QIODevice::ReadWrite)
-    {
-    }
-    void writeAll(const QByteArray &buf, int fd);
-    void forwardStd(KProcess::ProcessChannel good, int fd);
-    void _k_forwardStdout();
-    void _k_forwardStderr();
+class KProcessPrivate
+{
+Q_DECLARE_PUBLIC (KProcess) protected:
+  KProcessPrivate ():openMode (QIODevice::ReadWrite)
+  {
+  }
+  void writeAll (const QByteArray & buf, int fd);
+  void forwardStd (KProcess::ProcessChannel good, int fd);
+  void _k_forwardStdout ();
+  void _k_forwardStderr ();
 
-    QString prog;
-    QStringList args;
-    KProcess::OutputChannelMode outputChannelMode;
-    QIODevice::OpenMode openMode;
+  QString prog;
+  QStringList args;
+  KProcess::OutputChannelMode outputChannelMode;
+  QIODevice::OpenMode openMode;
 
-    KProcess *q_ptr;
+  KProcess *q_ptr;
 };
 
 
 #endif
diff --git a/gui/src/terminal/kpty.cpp b/gui/src/terminal/kpty.cpp
--- a/gui/src/terminal/kpty.cpp
+++ b/gui/src/terminal/kpty.cpp
@@ -35,19 +35,19 @@
 
 #ifdef _AIX
 #define _ALL_SOURCE
 #endif
 
 // __USE_XOPEN isn't defined by default in ICC
 // (needed for ptsname(), grantpt() and unlockpt())
 #ifdef __INTEL_COMPILER
-#  ifndef __USE_XOPEN
-#    define __USE_XOPEN
-#  endif
+#ifndef __USE_XOPEN
+#define __USE_XOPEN
+#endif
 #endif
 
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
 #include <sys/param.h>
@@ -57,145 +57,154 @@
 #include <time.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <grp.h>
 
 #if defined(HAVE_PTY_H)
-# include <pty.h>
+#include <pty.h>
 #endif
 
 #ifdef HAVE_LIBUTIL_H
-# include <libutil.h>
+#include <libutil.h>
 #elif defined(HAVE_UTIL_H)
-# include <util.h>
+#include <util.h>
 #endif
 
 #define HAVE_UTMPX
 #define _UTMPX_COMPAT
 
 #ifdef HAVE_UTEMPTER
-extern "C" {
-# include <utempter.h>
+extern "C"
+{
+#include <utempter.h>
 }
 #else
-# include <utmp.h>
-# ifdef HAVE_UTMPX
-#  include <utmpx.h>
-# endif
-# if !defined(_PATH_UTMPX) && defined(_UTMPX_FILE)
-#  define _PATH_UTMPX _UTMPX_FILE
-# endif
-# if !defined(_PATH_WTMPX) && defined(_WTMPX_FILE)
-#  define _PATH_WTMPX _WTMPX_FILE
-# endif
+#include <utmp.h>
+#ifdef HAVE_UTMPX
+#include <utmpx.h>
+#endif
+#if !defined(_PATH_UTMPX) && defined(_UTMPX_FILE)
+#define _PATH_UTMPX _UTMPX_FILE
+#endif
+#if !defined(_PATH_WTMPX) && defined(_WTMPX_FILE)
+#define _PATH_WTMPX _WTMPX_FILE
+#endif
 #endif
 
 /* for HP-UX (some versions) the extern C is needed, and for other
    platforms it doesn't hurt */
-extern "C" {
+extern "C"
+{
 #include <termios.h>
 #if defined(HAVE_TERMIO_H)
-# include <termio.h> // struct winsize on some systems
+#include <termio.h>		// struct winsize on some systems
 #endif
 }
 
 #if defined (_HPUX_SOURCE)
-# define _TERMIOS_INCLUDED
-# include <bsdtty.h>
+#define _TERMIOS_INCLUDED
+#include <bsdtty.h>
 #endif
 
 #ifdef HAVE_SYS_STROPTS_H
-# include <sys/stropts.h>	// Defines I_PUSH
-# define _NEW_TTY_CTRL
+#include <sys/stropts.h>	// Defines I_PUSH
+#define _NEW_TTY_CTRL
 #endif
 
 #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
-# define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
+#define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
 #else
-# if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__) || defined(__sun)
-#  define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
-# else
-#  define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
-# endif
+#if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__) || defined(__sun)
+#define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
+#else
+#define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
+#endif
 #endif
 
 #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
-# define _tcsetattr(fd, ttmode) ioctl(fd, TIOCSETA, (char *)ttmode)
+#define _tcsetattr(fd, ttmode) ioctl(fd, TIOCSETA, (char *)ttmode)
 #else
-# if defined(_HPUX_SOURCE) || defined(__CYGWIN__) || defined(__sun)
-#  define _tcsetattr(fd, ttmode) tcsetattr(fd, TCSANOW, ttmode)
-# else
-#  define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
-# endif
+#if defined(_HPUX_SOURCE) || defined(__CYGWIN__) || defined(__sun)
+#define _tcsetattr(fd, ttmode) tcsetattr(fd, TCSANOW, ttmode)
+#else
+#define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
+#endif
 #endif
 
 #include <QtCore/Q_PID>
 
 #define TTY_GROUP "tty"
 
 #ifndef PATH_MAX
-# ifdef MAXPATHLEN
-#  define PATH_MAX MAXPATHLEN
-# else
-#  define PATH_MAX 1024
-# endif
+#ifdef MAXPATHLEN
+#define PATH_MAX MAXPATHLEN
+#else
+#define PATH_MAX 1024
+#endif
 #endif
 
 ///////////////////////
 // private functions //
 ///////////////////////
 
 //////////////////
 // private data //
 //////////////////
 
-KPtyPrivate::KPtyPrivate(KPty* parent) :
-    masterFd(-1), slaveFd(-1), ownMaster(true), q_ptr(parent)
+KPtyPrivate::KPtyPrivate (KPty * parent):
+masterFd (-1),
+slaveFd (-1),
+ownMaster (true),
+q_ptr (parent)
 {
 }
 
-KPtyPrivate::~KPtyPrivate()
+KPtyPrivate::~KPtyPrivate ()
 {
 }
 
 #ifndef HAVE_OPENPTY
-bool KPtyPrivate::chownpty(bool grant)
+bool
+KPtyPrivate::chownpty (bool grant)
 {
-    return !QProcess::execute(KStandardDirs::findExe("kgrantpty"),
-        QStringList() << (grant?"--grant":"--revoke") << QString::number(masterFd));
+  return !QProcess::execute (KStandardDirs::findExe ("kgrantpty"),
+			     QStringList () << (grant ? "--grant" :
+						"--revoke") << QString::
+			     number (masterFd));
 }
 #endif
 
 /////////////////////////////
 // public member functions //
 /////////////////////////////
 
-KPty::KPty() :
-    d_ptr(new KPtyPrivate(this))
+KPty::KPty ():
+d_ptr (new KPtyPrivate (this))
 {
 }
 
-KPty::KPty(KPtyPrivate *d) :
-    d_ptr(d)
+KPty::KPty (KPtyPrivate * d):
+d_ptr (d)
 {
-    d_ptr->q_ptr = this;
+  d_ptr->q_ptr = this;
 }
 
-KPty::~KPty()
+KPty::~KPty ()
 {
-    close();
-    delete d_ptr;
+  close ();
+  delete d_ptr;
 }
 
-bool KPty::open()
+bool
+KPty::open ()
 {
-  Q_D(KPty);
+  Q_D (KPty);
 
   if (d->masterFd >= 0)
     return true;
 
   d->ownMaster = true;
 
   QByteArray ptyName;
 
@@ -204,507 +213,552 @@ bool KPty::open()
   // Because not all the pty animals are created equal, they want to
   // be opened by several different methods.
 
   // We try, as we know them, one by one.
 
 #ifdef HAVE_OPENPTY
 
   char ptsn[PATH_MAX];
-  if (::openpty( &d->masterFd, &d->slaveFd, ptsn, 0, 0))
-  {
-    d->masterFd = -1;
-    d->slaveFd = -1;
-    //kWarning(175) << "Can't open a pseudo teletype";
-    return false;
-  }
+  if (::openpty (&d->masterFd, &d->slaveFd, ptsn, 0, 0))
+    {
+      d->masterFd = -1;
+      d->slaveFd = -1;
+      //kWarning(175) << "Can't open a pseudo teletype";
+      return false;
+    }
   d->ttyName = ptsn;
 
 #else
 
-#ifdef HAVE__GETPTY // irix
+#ifdef HAVE__GETPTY		// irix
 
-  char *ptsn = _getpty(&d->masterFd, O_RDWR|O_NOCTTY, S_IRUSR|S_IWUSR, 0);
-  if (ptsn) {
-    d->ttyName = ptsn;
-    goto grantedpt;
-  }
+  char *ptsn =
+    _getpty (&d->masterFd, O_RDWR | O_NOCTTY, S_IRUSR | S_IWUSR, 0);
+  if (ptsn)
+    {
+      d->ttyName = ptsn;
+      goto grantedpt;
+    }
 
 #elif defined(HAVE_PTSNAME) || defined(TIOCGPTN)
 
 #ifdef HAVE_POSIX_OPENPT
-  d->masterFd = ::posix_openpt(O_RDWR|O_NOCTTY);
+  d->masterFd =::posix_openpt (O_RDWR | O_NOCTTY);
 #elif defined(HAVE_GETPT)
-  d->masterFd = ::getpt();
+  d->masterFd =::getpt ();
 #elif defined(PTM_DEVICE)
   //d->masterFd = KDE_open(PTM_DEVICE, O_RDWR|O_NOCTTY);
-d->masterFd = ::open(PTM_DEVICE, O_RDWR|O_NOCTTY);
+  d->masterFd =::open (PTM_DEVICE, O_RDWR | O_NOCTTY);
 #else
-# error No method to open a PTY master detected.
+#error No method to open a PTY master detected.
 #endif
   if (d->masterFd >= 0)
-  {
+    {
 #ifdef HAVE_PTSNAME
-    char *ptsn = ptsname(d->masterFd);
-    if (ptsn) {
-        d->ttyName = ptsn;
+      char *ptsn = ptsname (d->masterFd);
+      if (ptsn)
+	{
+	  d->ttyName = ptsn;
 #else
-    int ptyno;
-    if (!ioctl(d->masterFd, TIOCGPTN, &ptyno)) {
-        char buf[32];
-        sprintf(buf, "/dev/pts/%d", ptyno);
-        d->ttyName = buf;
+      int ptyno;
+      if (!ioctl (d->masterFd, TIOCGPTN, &ptyno))
+	{
+	  char buf[32];
+	  sprintf (buf, "/dev/pts/%d", ptyno);
+	  d->ttyName = buf;
 #endif
 #ifdef HAVE_GRANTPT
-        if (!grantpt(d->masterFd))
-           goto grantedpt;
+	  if (!grantpt (d->masterFd))
+	    goto grantedpt;
 #else
-        goto gotpty;
+	  goto gotpty;
 #endif
+	}
+      ::close (d->masterFd);
+      d->masterFd = -1;
     }
-    ::close(d->masterFd);
-    d->masterFd = -1;
-  }
 #endif // HAVE_PTSNAME || TIOCGPTN
 
   // Linux device names, FIXME: Trouble on other systems?
-  for (const char* s3 = "pqrstuvwxyzabcde"; *s3; s3++)
-  {
-    for (const char* s4 = "0123456789abcdef"; *s4; s4++)
+  for (const char *s3 = "pqrstuvwxyzabcde"; *s3; s3++)
     {
-      ptyName = QString().sprintf("/dev/pty%c%c", *s3, *s4).toAscii();
-      d->ttyName = QString().sprintf("/dev/tty%c%c", *s3, *s4).toAscii();
+      for (const char *s4 = "0123456789abcdef"; *s4; s4++)
+	{
+	  ptyName = QString ().sprintf ("/dev/pty%c%c", *s3, *s4).toAscii ();
+	  d->ttyName =
+	    QString ().sprintf ("/dev/tty%c%c", *s3, *s4).toAscii ();
 
-      d->masterFd = ::open(ptyName.data(), O_RDWR);
-      if (d->masterFd >= 0)
-      {
+	  d->masterFd =::open (ptyName.data (), O_RDWR);
+	  if (d->masterFd >= 0)
+	    {
 #ifdef Q_OS_SOLARIS
-        /* Need to check the process group of the pty.
-         * If it exists, then the slave pty is in use,
-         * and we need to get another one.
-         */
-        int pgrp_rtn;
-        if (ioctl(d->masterFd, TIOCGPGRP, &pgrp_rtn) == 0 || errno != EIO) {
-          ::close(d->masterFd);
-          d->masterFd = -1;
-          continue;
-        }
+	      /* Need to check the process group of the pty.
+	       * If it exists, then the slave pty is in use,
+	       * and we need to get another one.
+	       */
+	      int pgrp_rtn;
+	      if (ioctl (d->masterFd, TIOCGPGRP, &pgrp_rtn) == 0
+		  || errno != EIO)
+		{
+		  ::close (d->masterFd);
+		  d->masterFd = -1;
+		  continue;
+		}
 #endif /* Q_OS_SOLARIS */
-        if (!access(d->ttyName.data(),R_OK|W_OK)) // checks availability based on permission bits
-        {
-          if (!geteuid())
-          {
-            struct group* p = getgrnam(TTY_GROUP);
-            if (!p)
-              p = getgrnam("wheel");
-            gid_t gid = p ? p->gr_gid : getgid ();
+	      if (!access (d->ttyName.data (), R_OK | W_OK))	// checks availability based on permission bits
+		{
+		  if (!geteuid ())
+		    {
+		      struct group *p = getgrnam (TTY_GROUP);
+		      if (!p)
+			p = getgrnam ("wheel");
+		      gid_t gid = p ? p->gr_gid : getgid ();
 
-            chown(d->ttyName.data(), getuid(), gid);
-            chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IWGRP);
-          }
-          goto gotpty;
-        }
-        ::close(d->masterFd);
-        d->masterFd = -1;
-      }
+		      chown (d->ttyName.data (), getuid (), gid);
+		      chmod (d->ttyName.data (), S_IRUSR | S_IWUSR | S_IWGRP);
+		    }
+		  goto gotpty;
+		}
+	      ::close (d->masterFd);
+	      d->masterFd = -1;
+	    }
+	}
     }
-  }
 
   //kWarning(175) << "Can't open a pseudo teletype";
   return false;
 
- gotpty:
+gotpty:
   KDE_struct_stat st;
-  if (KDE_stat(d->ttyName.data(), &st))
-    return false; // this just cannot happen ... *cough*  Yeah right, I just
-                  // had it happen when pty #349 was allocated.  I guess
-                  // there was some sort of leak?  I only had a few open.
-  if (((st.st_uid != getuid()) ||
-       (st.st_mode & (S_IRGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH))) &&
-      !d->chownpty(true))
-  {
+  if (KDE_stat (d->ttyName.data (), &st))
+    return false;		// this just cannot happen ... *cough*  Yeah right, I just
+  // had it happen when pty #349 was allocated.  I guess
+  // there was some sort of leak?  I only had a few open.
+  if (((st.st_uid != getuid ()) ||
+       (st.st_mode & (S_IRGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH))) &&
+      !d->chownpty (true))
+    {
 
-    /*kWarning(175)
-      << "chownpty failed for device " << ptyName << "::" << d->ttyName
-      << "\nThis means the communication can be eavesdropped." << endl;
-*/  
-}
+      /*kWarning(175)
+         << "chownpty failed for device " << ptyName << "::" << d->ttyName
+         << "\nThis means the communication can be eavesdropped." << endl;
+       */
+    }
 
- grantedpt:
+grantedpt:
 
 #ifdef HAVE_REVOKE
-  revoke(d->ttyName.data());
+  revoke (d->ttyName.data ());
 #endif
 
 #ifdef HAVE_UNLOCKPT
-  unlockpt(d->masterFd);
+  unlockpt (d->masterFd);
 #elif defined(TIOCSPTLCK)
   int flag = 0;
-  ioctl(d->masterFd, TIOCSPTLCK, &flag);
+  ioctl (d->masterFd, TIOCSPTLCK, &flag);
 #endif
 
-  d->slaveFd = ::open(d->ttyName.data(), O_RDWR | O_NOCTTY);
+  d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
   if (d->slaveFd < 0)
-  {
-    //kWarning(175) << "Can't open slave pseudo teletype";
-    ::close(d->masterFd);
-    d->masterFd = -1;
-    return false;
-  }
+    {
+      //kWarning(175) << "Can't open slave pseudo teletype";
+      ::close (d->masterFd);
+      d->masterFd = -1;
+      return false;
+    }
 
 #if (defined(__svr4__) || defined(__sgi__) || defined(Q_OS_SOLARIS))
   // Solaris uses STREAMS for terminal handling. It is possible
   // for the pty handling modules to be left off the stream; in that
   // case push them on. ioctl(fd, I_FIND, ...) is documented to return
   // 1 if the module is on the stream already.
   {
     static const char *pt = "ptem";
     static const char *ld = "ldterm";
-    if (ioctl(d->slaveFd, I_FIND, pt) == 0)
-      ioctl(d->slaveFd, I_PUSH, pt);
-    if (ioctl(d->slaveFd, I_FIND, ld) == 0)
-      ioctl(d->slaveFd, I_PUSH, ld);
+    if (ioctl (d->slaveFd, I_FIND, pt) == 0)
+      ioctl (d->slaveFd, I_PUSH, pt);
+    if (ioctl (d->slaveFd, I_FIND, ld) == 0)
+      ioctl (d->slaveFd, I_PUSH, ld);
   }
 #endif
 
 #endif /* HAVE_OPENPTY */
 
-  fcntl(d->masterFd, F_SETFD, FD_CLOEXEC);
-  fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
+  fcntl (d->masterFd, F_SETFD, FD_CLOEXEC);
+  fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
 
   return true;
 }
 
-bool KPty::open(int fd)
+bool
+KPty::open (int fd)
 {
 #if !defined(HAVE_PTSNAME) && !defined(TIOCGPTN)
-    //kWarning(175) << "Unsupported attempt to open pty with fd" << fd;
-    return false;
+  //kWarning(175) << "Unsupported attempt to open pty with fd" << fd;
+  return false;
 #else
-    Q_D(KPty);
+  Q_D (KPty);
 
-    if (d->masterFd >= 0) {
-        //kWarning(175) << "Attempting to open an already open pty";
-        return false;
+  if (d->masterFd >= 0)
+    {
+      //kWarning(175) << "Attempting to open an already open pty";
+      return false;
     }
 
-    d->ownMaster = false;
+  d->ownMaster = false;
 
-# ifdef HAVE_PTSNAME
-    char *ptsn = ptsname(fd);
-    if (ptsn) {
-        d->ttyName = ptsn;
-# else
-    int ptyno;
-    if (!ioctl(fd, TIOCGPTN, &ptyno)) {
-        char buf[32];
-        sprintf(buf, "/dev/pts/%d", ptyno);
-        d->ttyName = buf;
-# endif
-    } else {
-        //kWarning(175) << "Failed to determine pty slave device for fd" << fd;
-        return false;
+#ifdef HAVE_PTSNAME
+  char *ptsn = ptsname (fd);
+  if (ptsn)
+    {
+      d->ttyName = ptsn;
+#else
+  int ptyno;
+  if (!ioctl (fd, TIOCGPTN, &ptyno))
+    {
+      char buf[32];
+      sprintf (buf, "/dev/pts/%d", ptyno);
+      d->ttyName = buf;
+#endif
+    }
+  else
+    {
+      //kWarning(175) << "Failed to determine pty slave device for fd" << fd;
+      return false;
     }
 
-    d->masterFd = fd;
-    if (!openSlave()) {
-        d->masterFd = -1;
-        return false;
+  d->masterFd = fd;
+  if (!openSlave ())
+    {
+      d->masterFd = -1;
+      return false;
     }
 
-    return true;
+  return true;
 #endif
 }
 
-void KPty::closeSlave()
+void
+KPty::closeSlave ()
 {
-    Q_D(KPty);
+  Q_D (KPty);
 
-    if (d->slaveFd < 0)
-        return;
-    ::close(d->slaveFd);
-    d->slaveFd = -1;
+  if (d->slaveFd < 0)
+    return;
+  ::close (d->slaveFd);
+  d->slaveFd = -1;
 }
 
-bool KPty::openSlave()
+bool
+KPty::openSlave ()
 {
-    Q_D(KPty);
+  Q_D (KPty);
 
-    if (d->slaveFd >= 0)
-        return true;
-    if (d->masterFd < 0) {
-        //kWarning(175) << "Attempting to open pty slave while master is closed";
-        return false;
+  if (d->slaveFd >= 0)
+    return true;
+  if (d->masterFd < 0)
+    {
+      //kWarning(175) << "Attempting to open pty slave while master is closed";
+      return false;
     }
-    d->slaveFd = ::open(d->ttyName.data(), O_RDWR | O_NOCTTY);
-    if (d->slaveFd < 0) {
-        //kWarning(175) << "Can't open slave pseudo teletype";
-        return false;
+  d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
+  if (d->slaveFd < 0)
+    {
+      //kWarning(175) << "Can't open slave pseudo teletype";
+      return false;
     }
-    fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
-    return true;
+  fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
+  return true;
 }
 
-void KPty::close()
+void
+KPty::close ()
 {
-    Q_D(KPty);
+  Q_D (KPty);
 
-    if (d->masterFd < 0)
-        return;
-    closeSlave();
-    if (d->ownMaster) {
+  if (d->masterFd < 0)
+    return;
+  closeSlave ();
+  if (d->ownMaster)
+    {
 #ifndef HAVE_OPENPTY
-        // don't bother resetting unix98 pty, it will go away after closing master anyway.
-        if (memcmp(d->ttyName.data(), "/dev/pts/", 9)) {
-            if (!geteuid()) {
-                struct stat st;
-                if (!stat(d->ttyName.data(), &st)) {
-                    chown(d->ttyName.data(), 0, st.st_gid == getgid() ? 0 : -1);
-                    chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
-                }
-            } else {
-                fcntl(d->masterFd, F_SETFD, 0);
-                d->chownpty(false);
-            }
-        }
+      // don't bother resetting unix98 pty, it will go away after closing master anyway.
+      if (memcmp (d->ttyName.data (), "/dev/pts/", 9))
+	{
+	  if (!geteuid ())
+	    {
+	      struct stat st;
+	      if (!stat (d->ttyName.data (), &st))
+		{
+		  chown (d->ttyName.data (), 0,
+			 st.st_gid == getgid ()? 0 : -1);
+		  chmod (d->ttyName.data (),
+			 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH |
+			 S_IWOTH);
+		}
+	    }
+	  else
+	    {
+	      fcntl (d->masterFd, F_SETFD, 0);
+	      d->chownpty (false);
+	    }
+	}
 #endif
-        ::close(d->masterFd);
+      ::close (d->masterFd);
     }
-    d->masterFd = -1;
+  d->masterFd = -1;
 }
 
-void KPty::setCTty()
+void
+KPty::setCTty ()
 {
-    Q_D(KPty);
+  Q_D (KPty);
 
-    // Setup job control //////////////////////////////////
+  // Setup job control //////////////////////////////////
 
-    // Become session leader, process group leader,
-    // and get rid of the old controlling terminal.
-    setsid();
+  // Become session leader, process group leader,
+  // and get rid of the old controlling terminal.
+  setsid ();
 
-    // make our slave pty the new controlling terminal.
+  // make our slave pty the new controlling terminal.
 #ifdef TIOCSCTTY
-    ioctl(d->slaveFd, TIOCSCTTY, 0);
+  ioctl (d->slaveFd, TIOCSCTTY, 0);
 #else
-    // __svr4__ hack: the first tty opened after setsid() becomes controlling tty
-    ::close(open(d->ttyName, O_WRONLY, 0));
+  // __svr4__ hack: the first tty opened after setsid() becomes controlling tty
+  ::close (open (d->ttyName, O_WRONLY, 0));
 #endif
 
-    // make our new process group the foreground group on the pty
-    int pgrp = getpid();
+  // make our new process group the foreground group on the pty
+  int pgrp = getpid ();
 #if defined(_POSIX_VERSION) || defined(__svr4__)
-    tcsetpgrp(d->slaveFd, pgrp);
+  tcsetpgrp (d->slaveFd, pgrp);
 #elif defined(TIOCSPGRP)
-    ioctl(d->slaveFd, TIOCSPGRP, (char *)&pgrp);
+  ioctl (d->slaveFd, TIOCSPGRP, (char *) &pgrp);
 #endif
 }
 
-void KPty::login(const char *user, const char *remotehost)
+void
+KPty::login (const char *user, const char *remotehost)
 {
 #ifdef HAVE_UTEMPTER
-    Q_D(KPty);
+  Q_D (KPty);
 
-    addToUtmp(d->ttyName, remotehost, d->masterFd);
-    Q_UNUSED(user);
+  addToUtmp (d->ttyName, remotehost, d->masterFd);
+  Q_UNUSED (user);
+#else
+#ifdef HAVE_UTMPX
+  struct utmpx l_struct;
 #else
-# ifdef HAVE_UTMPX
-    struct utmpx l_struct;
-# else
-    struct utmp l_struct;
-# endif
-    memset(&l_struct, 0, sizeof(l_struct));
-    // note: strncpy without terminators _is_ correct here. man 4 utmp
+  struct utmp l_struct;
+#endif
+  memset (&l_struct, 0, sizeof (l_struct));
+  // note: strncpy without terminators _is_ correct here. man 4 utmp
+
+  if (user)
+    strncpy (l_struct.ut_name, user, sizeof (l_struct.ut_name));
 
-    if (user)
-      strncpy(l_struct.ut_name, user, sizeof(l_struct.ut_name));
-
-    if (remotehost) {
-      strncpy(l_struct.ut_host, remotehost, sizeof(l_struct.ut_host));
-# ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
-      l_struct.ut_syslen = qMin(strlen(remotehost), sizeof(l_struct.ut_host));
-# endif
+  if (remotehost)
+    {
+      strncpy (l_struct.ut_host, remotehost, sizeof (l_struct.ut_host));
+#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
+      l_struct.ut_syslen =
+	qMin (strlen (remotehost), sizeof (l_struct.ut_host));
+#endif
     }
 
-# ifndef __GLIBC__
-    Q_D(KPty);
-    const char *str_ptr = d->ttyName.data();
-    if (!memcmp(str_ptr, "/dev/", 5))
-        str_ptr += 5;
-    strncpy(l_struct.ut_line, str_ptr, sizeof(l_struct.ut_line));
-#  ifdef HAVE_STRUCT_UTMP_UT_ID
-    strncpy(l_struct.ut_id,
-            str_ptr + strlen(str_ptr) - sizeof(l_struct.ut_id),
-            sizeof(l_struct.ut_id));
-#  endif
-# endif
+#ifndef __GLIBC__
+  Q_D (KPty);
+  const char *str_ptr = d->ttyName.data ();
+  if (!memcmp (str_ptr, "/dev/", 5))
+    str_ptr += 5;
+  strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
+#ifdef HAVE_STRUCT_UTMP_UT_ID
+  strncpy (l_struct.ut_id,
+	   str_ptr + strlen (str_ptr) - sizeof (l_struct.ut_id),
+	   sizeof (l_struct.ut_id));
+#endif
+#endif
 
-# ifdef HAVE_UTMPX
-    //gettimeofday(&l_struct.ut_tv, 0);
-    gettimeofday((struct timeval *)&l_struct.ut_tv, 0);
-# else
-    l_struct.ut_time = time(0);
-# endif
+#ifdef HAVE_UTMPX
+  //gettimeofday(&l_struct.ut_tv, 0);
+  gettimeofday ((struct timeval *) &l_struct.ut_tv, 0);
+#else
+  l_struct.ut_time = time (0);
+#endif
 
-# ifdef HAVE_LOGIN
-#  ifdef HAVE_LOGINX
-    ::loginx(&l_struct);
-#  else
-    ::login(&l_struct);
-#  endif
-# else
-#  ifdef HAVE_STRUCT_UTMP_UT_TYPE
-    l_struct.ut_type = USER_PROCESS;
-#  endif
-#  ifdef HAVE_STRUCT_UTMP_UT_PID
-    l_struct.ut_pid = getpid();
-#   ifdef HAVE_STRUCT_UTMP_UT_SESSION
-    l_struct.ut_session = getsid(0);
-#   endif
-#  endif
-#  ifdef HAVE_UTMPX
-    utmpxname(_PATH_UTMPX);
-    setutxent();
-    pututxline(&l_struct);
-    endutxent();
-    //updwtmpx(_PATH_WTMPX, &l_struct);
-#  else
-    utmpname(_PATH_UTMP);
-    setutent();
-    pututline(&l_struct);
-    endutent();
-    updwtmp(_PATH_WTMP, &l_struct);
-#  endif
-# endif
+#ifdef HAVE_LOGIN
+#ifdef HAVE_LOGINX
+  ::loginx (&l_struct);
+#else
+  ::login (&l_struct);
+#endif
+#else
+#ifdef HAVE_STRUCT_UTMP_UT_TYPE
+  l_struct.ut_type = USER_PROCESS;
+#endif
+#ifdef HAVE_STRUCT_UTMP_UT_PID
+  l_struct.ut_pid = getpid ();
+#ifdef HAVE_STRUCT_UTMP_UT_SESSION
+  l_struct.ut_session = getsid (0);
+#endif
+#endif
+#ifdef HAVE_UTMPX
+  utmpxname (_PATH_UTMPX);
+  setutxent ();
+  pututxline (&l_struct);
+  endutxent ();
+  //updwtmpx(_PATH_WTMPX, &l_struct);
+#else
+  utmpname (_PATH_UTMP);
+  setutent ();
+  pututline (&l_struct);
+  endutent ();
+  updwtmp (_PATH_WTMP, &l_struct);
+#endif
+#endif
 #endif
 }
 
-void KPty::logout()
+void
+KPty::logout ()
 {
 #ifdef HAVE_UTEMPTER
-    Q_D(KPty);
+  Q_D (KPty);
 
-    removeLineFromUtmp(d->ttyName, d->masterFd);
+  removeLineFromUtmp (d->ttyName, d->masterFd);
 #else
-    Q_D(KPty);
+  Q_D (KPty);
 
-    const char *str_ptr = d->ttyName.data();
-    if (!memcmp(str_ptr, "/dev/", 5))
-        str_ptr += 5;
-# ifdef __GLIBC__
-    else {
-        const char *sl_ptr = strrchr(str_ptr, '/');
-        if (sl_ptr)
-            str_ptr = sl_ptr + 1;
+  const char *str_ptr = d->ttyName.data ();
+  if (!memcmp (str_ptr, "/dev/", 5))
+    str_ptr += 5;
+#ifdef __GLIBC__
+  else
+    {
+      const char *sl_ptr = strrchr (str_ptr, '/');
+      if (sl_ptr)
+	str_ptr = sl_ptr + 1;
     }
-# endif
-# ifdef HAVE_LOGIN
-#  ifdef HAVE_LOGINX
-    ::logoutx(str_ptr, 0, DEAD_PROCESS);
-#  else
-    ::logout(str_ptr);
-#  endif
-# else
-#  ifdef HAVE_UTMPX
-    struct utmpx l_struct, *ut;
-#  else
-    struct utmp l_struct, *ut;
-#  endif
-    memset(&l_struct, 0, sizeof(l_struct));
+#endif
+#ifdef HAVE_LOGIN
+#ifdef HAVE_LOGINX
+  ::logoutx (str_ptr, 0, DEAD_PROCESS);
+#else
+  ::logout (str_ptr);
+#endif
+#else
+#ifdef HAVE_UTMPX
+  struct utmpx l_struct, *ut;
+#else
+  struct utmp l_struct, *ut;
+#endif
+  memset (&l_struct, 0, sizeof (l_struct));
+
+  strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
 
-    strncpy(l_struct.ut_line, str_ptr, sizeof(l_struct.ut_line));
-
-#  ifdef HAVE_UTMPX
-    utmpxname(_PATH_UTMPX);
-    setutxent();
-    if ((ut = getutxline(&l_struct))) {
-#  else
-    utmpname(_PATH_UTMP);
-    setutent();
-    if ((ut = getutline(&l_struct))) {
-#  endif
-        memset(ut->ut_name, 0, sizeof(*ut->ut_name));
-        memset(ut->ut_host, 0, sizeof(*ut->ut_host));
-#  ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
-        ut->ut_syslen = 0;
-#  endif
-#  ifdef HAVE_STRUCT_UTMP_UT_TYPE
-        ut->ut_type = DEAD_PROCESS;
-#  endif
-#  ifdef HAVE_UTMPX
-        //gettimeofday(&(ut->ut_tv), 0);
-	gettimeofday((struct timeval *)&(ut->ut_tv), 0);
-        pututxline(ut);
+#ifdef HAVE_UTMPX
+  utmpxname (_PATH_UTMPX);
+  setutxent ();
+  if ((ut = getutxline (&l_struct)))
+    {
+#else
+  utmpname (_PATH_UTMP);
+  setutent ();
+  if ((ut = getutline (&l_struct)))
+    {
+#endif
+      memset (ut->ut_name, 0, sizeof (*ut->ut_name));
+      memset (ut->ut_host, 0, sizeof (*ut->ut_host));
+#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
+      ut->ut_syslen = 0;
+#endif
+#ifdef HAVE_STRUCT_UTMP_UT_TYPE
+      ut->ut_type = DEAD_PROCESS;
+#endif
+#ifdef HAVE_UTMPX
+      //gettimeofday(&(ut->ut_tv), 0);
+      gettimeofday ((struct timeval *) &(ut->ut_tv), 0);
+      pututxline (ut);
     }
-    endutxent();
-#  else
-        ut->ut_time = time(0);
-        pututline(ut);
+  endutxent ();
+#else
+      ut->ut_time = time (0);
+      pututline (ut);
     }
-    endutent();
-#  endif
-# endif
+  endutent ();
+#endif
+#endif
 #endif
 }
 
-bool KPty::tcGetAttr(struct ::termios *ttmode) const
+bool
+KPty::tcGetAttr (struct::termios * ttmode) const
 {
-    Q_D(const KPty);
-
-#ifdef Q_OS_SOLARIS
-    if (_tcgetattr(d->slaveFd, ttmode) == 0) return true;
-#endif
-    return _tcgetattr(d->masterFd, ttmode) == 0;
-}
-
-bool KPty::tcSetAttr(struct ::termios *ttmode)
-{
-    Q_D(KPty);
+  Q_D (const KPty);
 
 #ifdef Q_OS_SOLARIS
-    if (_tcsetattr(d->slaveFd, ttmode) == 0) return true;
+  if (_tcgetattr (d->slaveFd, ttmode) == 0)
+    return true;
 #endif
-    return _tcsetattr(d->masterFd, ttmode) == 0;
+  return _tcgetattr (d->masterFd, ttmode) == 0;
 }
 
-bool KPty::setWinSize(int lines, int columns)
+bool
+KPty::tcSetAttr (struct::termios * ttmode)
 {
-    Q_D(KPty);
+  Q_D (KPty);
 
-    struct winsize winSize;
-    memset(&winSize, 0, sizeof(winSize));
-    winSize.ws_row = (unsigned short)lines;
-    winSize.ws_col = (unsigned short)columns;
-    return ioctl(d->masterFd, TIOCSWINSZ, (char *)&winSize) == 0;
+#ifdef Q_OS_SOLARIS
+  if (_tcsetattr (d->slaveFd, ttmode) == 0)
+    return true;
+#endif
+  return _tcsetattr (d->masterFd, ttmode) == 0;
+}
+
+bool
+KPty::setWinSize (int lines, int columns)
+{
+  Q_D (KPty);
+
+  struct winsize winSize;
+  memset (&winSize, 0, sizeof (winSize));
+  winSize.ws_row = (unsigned short) lines;
+  winSize.ws_col = (unsigned short) columns;
+  return ioctl (d->masterFd, TIOCSWINSZ, (char *) &winSize) == 0;
 }
 
-bool KPty::setEcho(bool echo)
+bool
+KPty::setEcho (bool echo)
 {
-    struct ::termios ttmode;
-    if (!tcGetAttr(&ttmode))
-        return false;
-    if (!echo)
-        ttmode.c_lflag &= ~ECHO;
-    else
-        ttmode.c_lflag |= ECHO;
-    return tcSetAttr(&ttmode);
+  struct::termios ttmode;
+  if (!tcGetAttr (&ttmode))
+    return false;
+  if (!echo)
+    ttmode.c_lflag &= ~ECHO;
+  else
+    ttmode.c_lflag |= ECHO;
+  return tcSetAttr (&ttmode);
 }
 
-const char *KPty::ttyName() const
+const char *
+KPty::ttyName () const
 {
-    Q_D(const KPty);
+  Q_D (const KPty);
 
-    return d->ttyName.data();
+  return d->ttyName.data ();
 }
 
-int KPty::masterFd() const
+int
+KPty::masterFd () const
 {
-    Q_D(const KPty);
+  Q_D (const KPty);
 
-    return d->masterFd;
+  return d->masterFd;
 }
 
-int KPty::slaveFd() const
+int
+KPty::slaveFd () const
 {
-    Q_D(const KPty);
+  Q_D (const KPty);
 
-    return d->slaveFd;
+  return d->slaveFd;
 }
diff --git a/gui/src/terminal/kpty.h b/gui/src/terminal/kpty.h
--- a/gui/src/terminal/kpty.h
+++ b/gui/src/terminal/kpty.h
@@ -24,181 +24,179 @@
 
 struct KPtyPrivate;
 struct termios;
 
 /**
  * Provides primitives for opening & closing a pseudo TTY pair, assigning the
  * controlling TTY, utmp registration and setting various terminal attributes.
  */
-class KPty {
-    Q_DECLARE_PRIVATE(KPty)
-
-public:
+class KPty
+{
+Q_DECLARE_PRIVATE (KPty) public:
 
   /**
    * Constructor
    */
-  KPty();
+  KPty ();
 
   /**
    * Destructor:
    *
    *  If the pty is still open, it will be closed. Note, however, that
    *  an utmp registration is @em not undone.
   */
-  ~KPty();
+  ~KPty ();
 
   /**
    * Create a pty master/slave pair.
    *
    * @return true if a pty pair was successfully opened
    */
-  bool open();
+  bool open ();
 
   /**
    * Open using an existing pty master.
    *
    * @param fd an open pty master file descriptor.
    *   The ownership of the fd remains with the caller;
    *   it will not be automatically closed at any point.
    * @return true if a pty pair was successfully opened
    */
-  bool open(int fd);
+  bool open (int fd);
 
   /**
    * Close the pty master/slave pair.
    */
-  void close();
+  void close ();
 
   /**
    * Close the pty slave descriptor.
    *
    * When creating the pty, KPty also opens the slave and keeps it open.
    * Consequently the master will never receive an EOF notification.
    * Usually this is the desired behavior, as a closed pty slave can be
    * reopened any time - unlike a pipe or socket. However, in some cases
    * pipe-alike behavior might be desired.
    *
    * After this function was called, slaveFd() and setCTty() cannot be
    * used.
    */
-  void closeSlave();
+  void closeSlave ();
 
   /**
    * Open the pty slave descriptor.
    *
    * This undoes the effect of closeSlave().
    *
    * @return true if the pty slave was successfully opened
    */
-  bool openSlave();
+  bool openSlave ();
 
   /**
    * Creates a new session and process group and makes this pty the
    * controlling tty.
    */
-  void setCTty();
+  void setCTty ();
 
   /**
    * Creates an utmp entry for the tty.
    * This function must be called after calling setCTty and
    * making this pty the stdin.
    * @param user the user to be logged on
    * @param remotehost the host from which the login is coming. This is
    *  @em not the local host. For remote logins it should be the hostname
    *  of the client. For local logins from inside an X session it should
    *  be the name of the X display. Otherwise it should be empty.
    */
-  void login(const char *user = 0, const char *remotehost = 0);
+  void login (const char *user = 0, const char *remotehost = 0);
 
   /**
    * Removes the utmp entry for this tty.
    */
-  void logout();
+  void logout ();
 
   /**
    * Wrapper around tcgetattr(3).
    *
    * This function can be used only while the PTY is open.
    * You will need an #include &lt;termios.h&gt; to do anything useful
    * with it.
    *
    * @param ttmode a pointer to a termios structure.
    *  Note: when declaring ttmode, @c struct @c ::termios must be used -
    *  without the '::' some version of HP-UX thinks, this declares
    *  the struct in your class, in your method.
    * @return @c true on success, false otherwise
    */
-  bool tcGetAttr(struct ::termios *ttmode) const;
+  bool tcGetAttr (struct::termios * ttmode) const;
 
   /**
    * Wrapper around tcsetattr(3) with mode TCSANOW.
    *
    * This function can be used only while the PTY is open.
    *
    * @param ttmode a pointer to a termios structure.
    * @return @c true on success, false otherwise. Note that success means
    *  that @em at @em least @em one attribute could be set.
    */
-  bool tcSetAttr(struct ::termios *ttmode);
+  bool tcSetAttr (struct::termios * ttmode);
 
   /**
    * Change the logical (screen) size of the pty.
    * The default is 24 lines by 80 columns.
    *
    * This function can be used only while the PTY is open.
    *
    * @param lines the number of rows
    * @param columns the number of columns
    * @return @c true on success, false otherwise
    */
-  bool setWinSize(int lines, int columns);
+  bool setWinSize (int lines, int columns);
 
   /**
    * Set whether the pty should echo input.
    *
    * Echo is on by default.
    * If the output of automatically fed (non-interactive) PTY clients
    * needs to be parsed, disabling echo often makes it much simpler.
    *
    * This function can be used only while the PTY is open.
    *
    * @param echo true if input should be echoed.
    * @return @c true on success, false otherwise
    */
-  bool setEcho(bool echo);
+  bool setEcho (bool echo);
 
   /**
    * @return the name of the slave pty device.
    *
    * This function should be called only while the pty is open.
    */
-  const char *ttyName() const;
+  const char *ttyName () const;
 
   /**
    * @return the file descriptor of the master pty
    *
    * This function should be called only while the pty is open.
    */
-  int masterFd() const;
+  int masterFd () const;
 
   /**
    * @return the file descriptor of the slave pty
    *
    * This function should be called only while the pty slave is open.
    */
-  int slaveFd() const;
+  int slaveFd () const;
 
 protected:
   /**
    * @internal
    */
-  KPty(KPtyPrivate *d);
+    KPty (KPtyPrivate * d);
 
   /**
    * @internal
    */
-  KPtyPrivate * const d_ptr;
+  KPtyPrivate *const d_ptr;
 };
 
 #endif
-
diff --git a/gui/src/terminal/kpty_export.h b/gui/src/terminal/kpty_export.h
--- a/gui/src/terminal/kpty_export.h
+++ b/gui/src/terminal/kpty_export.h
@@ -22,25 +22,25 @@
 
 /* needed for KDE_EXPORT and KDE_IMPORT macros */
 //#include <kdemacros.h>
 #include <QtCore/qglobal.h>
 #define KDE_EXPORT
 #define KDE_IMPORT
 
 #ifndef KPTY_EXPORT
-# if defined(KDELIBS_STATIC_LIBS)
+#if defined(KDELIBS_STATIC_LIBS)
    /* No export/import for static libraries */
-#  define KPTY_EXPORT
-# elif defined(MAKE_KDECORE_LIB)
-   /* We are building this library */ 
-#  define KPTY_EXPORT KDE_EXPORT
-# else
-   /* We are using this library */ 
-#  define KPTY_EXPORT KDE_IMPORT
-# endif
+#define KPTY_EXPORT
+#elif defined(MAKE_KDECORE_LIB)
+   /* We are building this library */
+#define KPTY_EXPORT KDE_EXPORT
+#else
+   /* We are using this library */
+#define KPTY_EXPORT KDE_IMPORT
+#endif
 #endif
 
-# ifndef KPTY_EXPORT_DEPRECATED
-#  define KPTY_EXPORT_DEPRECATED KDE_DEPRECATED KPTY_EXPORT
-# endif
+#ifndef KPTY_EXPORT_DEPRECATED
+#define KPTY_EXPORT_DEPRECATED KDE_DEPRECATED KPTY_EXPORT
+#endif
 
 #endif
diff --git a/gui/src/terminal/kpty_p.h b/gui/src/terminal/kpty_p.h
--- a/gui/src/terminal/kpty_p.h
+++ b/gui/src/terminal/kpty_p.h
@@ -32,27 +32,26 @@
 #else
 #define HAVE_PTY_H
 #endif
 
 #define HAVE_OPENPTY
 
 #include <QtCore/QByteArray>
 
-struct KPtyPrivate {
-    Q_DECLARE_PUBLIC(KPty)
-
-    KPtyPrivate(KPty* parent);
-    virtual ~KPtyPrivate();
+struct KPtyPrivate
+{
+  Q_DECLARE_PUBLIC (KPty) KPtyPrivate (KPty * parent);
+  virtual ~ KPtyPrivate ();
 #ifndef HAVE_OPENPTY
-    bool chownpty(bool grant);
+  bool chownpty (bool grant);
 #endif
 
-    int masterFd;
-    int slaveFd;
-    bool ownMaster:1;
+  int masterFd;
+  int slaveFd;
+  bool ownMaster:1;
 
-    QByteArray ttyName;
+  QByteArray ttyName;
 
-    KPty *q_ptr;
+  KPty *q_ptr;
 };
 
 #endif
diff --git a/gui/src/terminal/kptydevice.cpp b/gui/src/terminal/kptydevice.cpp
--- a/gui/src/terminal/kptydevice.cpp
+++ b/gui/src/terminal/kptydevice.cpp
@@ -29,385 +29,427 @@
 
 #include <unistd.h>
 #include <errno.h>
 #include <signal.h>
 #include <termios.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #ifdef HAVE_SYS_FILIO_H
-# include <sys/filio.h>
+#include <sys/filio.h>
 #endif
 #ifdef HAVE_SYS_TIME_H
-# include <sys/time.h>
+#include <sys/time.h>
 #endif
 
 #if defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
   // "the other end's output queue size" - kinda braindead, huh?
-# define PTY_BYTES_AVAILABLE TIOCOUTQ
+#define PTY_BYTES_AVAILABLE TIOCOUTQ
 #elif defined(TIOCINQ)
   // "our end's input queue size"
-# define PTY_BYTES_AVAILABLE TIOCINQ
+#define PTY_BYTES_AVAILABLE TIOCINQ
 #else
   // likewise. more generic ioctl (theoretically)
-# define PTY_BYTES_AVAILABLE FIONREAD
+#define PTY_BYTES_AVAILABLE FIONREAD
 #endif
 
 //////////////////
 // private data //
 //////////////////
 
 // Lifted from Qt. I don't think they would mind. ;)
 // Re-lift again from Qt whenever a proper replacement for pthread_once appears
-static void qt_ignore_sigpipe()
+static void
+qt_ignore_sigpipe ()
 {
-    static QBasicAtomicInt atom = Q_BASIC_ATOMIC_INITIALIZER(0);
-    if (atom.testAndSetRelaxed(0, 1)) {
-        struct sigaction noaction;
-        memset(&noaction, 0, sizeof(noaction));
-        noaction.sa_handler = SIG_IGN;
-        sigaction(SIGPIPE, &noaction, 0);
+  static QBasicAtomicInt atom = Q_BASIC_ATOMIC_INITIALIZER (0);
+  if (atom.testAndSetRelaxed (0, 1))
+    {
+      struct sigaction noaction;
+      memset (&noaction, 0, sizeof (noaction));
+      noaction.sa_handler = SIG_IGN;
+      sigaction (SIGPIPE, &noaction, 0);
     }
 }
 
 #define NO_INTR(ret,func) do { ret = func; } while (ret < 0 && errno == EINTR)
 
-bool KPtyDevicePrivate::_k_canRead()
+bool
+KPtyDevicePrivate::_k_canRead ()
 {
-    Q_Q(KPtyDevice);
-    qint64 readBytes = 0;
+  Q_Q (KPtyDevice);
+  qint64 readBytes = 0;
 
-#ifdef Q_OS_IRIX // this should use a config define, but how to check it?
-    size_t available;
+#ifdef Q_OS_IRIX		// this should use a config define, but how to check it?
+  size_t available;
 #else
-    int available;
+  int available;
 #endif
-    if (!::ioctl(q->masterFd(), PTY_BYTES_AVAILABLE, (char *) &available)) {
+  if (!::ioctl (q->masterFd (), PTY_BYTES_AVAILABLE, (char *) &available))
+    {
 #ifdef Q_OS_SOLARIS
-        // A Pty is a STREAMS module, and those can be activated
-        // with 0 bytes available. This happens either when ^C is
-        // pressed, or when an application does an explicit write(a,b,0)
-        // which happens in experiments fairly often. When 0 bytes are
-        // available, you must read those 0 bytes to clear the STREAMS
-        // module, but we don't want to hit the !readBytes case further down.
-        if (!available) {
-            char c;
-            // Read the 0-byte STREAMS message
-            NO_INTR(readBytes, read(q->masterFd(), &c, 0));
-            // Should return 0 bytes read; -1 is error
-            if (readBytes < 0) {
-                readNotifier->setEnabled(false);
-                emit q->readEof();
-                return false;
-            }
-            return true;
-        }
+      // A Pty is a STREAMS module, and those can be activated
+      // with 0 bytes available. This happens either when ^C is
+      // pressed, or when an application does an explicit write(a,b,0)
+      // which happens in experiments fairly often. When 0 bytes are
+      // available, you must read those 0 bytes to clear the STREAMS
+      // module, but we don't want to hit the !readBytes case further down.
+      if (!available)
+	{
+	  char c;
+	  // Read the 0-byte STREAMS message
+	  NO_INTR (readBytes, read (q->masterFd (), &c, 0));
+	  // Should return 0 bytes read; -1 is error
+	  if (readBytes < 0)
+	    {
+	      readNotifier->setEnabled (false);
+	      emit q->readEof ();
+	      return false;
+	    }
+	  return true;
+	}
 #endif
 
-        char *ptr = readBuffer.reserve(available);
+      char *ptr = readBuffer.reserve (available);
 #ifdef Q_OS_SOLARIS
-        // Even if available > 0, it is possible for read()
-        // to return 0 on Solaris, due to 0-byte writes in the stream.
-        // Ignore them and keep reading until we hit *some* data.
-        // In Solaris it is possible to have 15 bytes available
-        // and to (say) get 0, 0, 6, 0 and 9 bytes in subsequent reads.
-        // Because the stream is set to O_NONBLOCK in finishOpen(),
-        // an EOF read will return -1.
-        readBytes = 0;
-        while (!readBytes)
+      // Even if available > 0, it is possible for read()
+      // to return 0 on Solaris, due to 0-byte writes in the stream.
+      // Ignore them and keep reading until we hit *some* data.
+      // In Solaris it is possible to have 15 bytes available
+      // and to (say) get 0, 0, 6, 0 and 9 bytes in subsequent reads.
+      // Because the stream is set to O_NONBLOCK in finishOpen(),
+      // an EOF read will return -1.
+      readBytes = 0;
+      while (!readBytes)
 #endif
-        // Useless block braces except in Solaris
-        {
-          NO_INTR(readBytes, read(q->masterFd(), ptr, available));
-        }
-        if (readBytes < 0) {
-            readBuffer.unreserve(available);
-            q->setErrorString(i18n("Error reading from PTY"));
-            return false;
-        }
-        readBuffer.unreserve(available - readBytes); // *should* be a no-op
+	// Useless block braces except in Solaris
+	{
+	  NO_INTR (readBytes, read (q->masterFd (), ptr, available));
+	}
+      if (readBytes < 0)
+	{
+	  readBuffer.unreserve (available);
+	  q->setErrorString (i18n ("Error reading from PTY"));
+	  return false;
+	}
+      readBuffer.unreserve (available - readBytes);	// *should* be a no-op
     }
 
-    if (!readBytes) {
-        readNotifier->setEnabled(false);
-        emit q->readEof();
-        return false;
-    } else {
-        if (!emittedReadyRead) {
-            emittedReadyRead = true;
-            emit q->readyRead();
-            emittedReadyRead = false;
-        }
-        return true;
+  if (!readBytes)
+    {
+      readNotifier->setEnabled (false);
+      emit q->readEof ();
+      return false;
+    }
+  else
+    {
+      if (!emittedReadyRead)
+	{
+	  emittedReadyRead = true;
+	  emit q->readyRead ();
+	  emittedReadyRead = false;
+	}
+      return true;
     }
 }
 
-bool KPtyDevicePrivate::_k_canWrite()
+bool
+KPtyDevicePrivate::_k_canWrite ()
 {
-    Q_Q(KPtyDevice);
+  Q_Q (KPtyDevice);
 
-    writeNotifier->setEnabled(false);
-    if (writeBuffer.isEmpty())
-        return false;
+  writeNotifier->setEnabled (false);
+  if (writeBuffer.isEmpty ())
+    return false;
 
-    qt_ignore_sigpipe();
-    int wroteBytes;
-    NO_INTR(wroteBytes,
-            write(q->masterFd(),
-                  writeBuffer.readPointer(), writeBuffer.readSize()));
-    if (wroteBytes < 0) {
-        q->setErrorString(i18n("Error writing to PTY"));
-        return false;
+  qt_ignore_sigpipe ();
+  int wroteBytes;
+  NO_INTR (wroteBytes,
+	   write (q->masterFd (),
+		  writeBuffer.readPointer (), writeBuffer.readSize ()));
+  if (wroteBytes < 0)
+    {
+      q->setErrorString (i18n ("Error writing to PTY"));
+      return false;
     }
-    writeBuffer.free(wroteBytes);
+  writeBuffer.free (wroteBytes);
 
-    if (!emittedBytesWritten) {
-        emittedBytesWritten = true;
-        emit q->bytesWritten(wroteBytes);
-        emittedBytesWritten = false;
+  if (!emittedBytesWritten)
+    {
+      emittedBytesWritten = true;
+      emit q->bytesWritten (wroteBytes);
+      emittedBytesWritten = false;
     }
 
-    if (!writeBuffer.isEmpty())
-        writeNotifier->setEnabled(true);
-    return true;
+  if (!writeBuffer.isEmpty ())
+    writeNotifier->setEnabled (true);
+  return true;
 }
 
 #ifndef timeradd
 // Lifted from GLIBC
-# define timeradd(a, b, result) \
+#define timeradd(a, b, result) \
     do { \
         (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; \
         (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; \
         if ((result)->tv_usec >= 1000000) { \
             ++(result)->tv_sec; \
             (result)->tv_usec -= 1000000; \
         } \
     } while (0)
-# define timersub(a, b, result) \
+#define timersub(a, b, result) \
     do { \
         (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \
         (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
         if ((result)->tv_usec < 0) { \
             --(result)->tv_sec; \
             (result)->tv_usec += 1000000; \
         } \
     } while (0)
 #endif
 
-bool KPtyDevicePrivate::doWait(int msecs, bool reading)
+bool
+KPtyDevicePrivate::doWait (int msecs, bool reading)
 {
-    Q_Q(KPtyDevice);
+  Q_Q (KPtyDevice);
 #ifndef __linux__
-    struct timeval etv;
+  struct timeval etv;
 #endif
-    struct timeval tv, *tvp;
+  struct timeval tv, *tvp;
 
-    if (msecs < 0)
-        tvp = 0;
-    else {
-        tv.tv_sec = msecs / 1000;
-        tv.tv_usec = (msecs % 1000) * 1000;
+  if (msecs < 0)
+    tvp = 0;
+  else
+    {
+      tv.tv_sec = msecs / 1000;
+      tv.tv_usec = (msecs % 1000) * 1000;
 #ifndef __linux__
-        gettimeofday(&etv, 0);
-        timeradd(&tv, &etv, &etv);
+      gettimeofday (&etv, 0);
+      timeradd (&tv, &etv, &etv);
 #endif
-        tvp = &tv;
+      tvp = &tv;
     }
 
-    while (reading ? readNotifier->isEnabled() : !writeBuffer.isEmpty()) {
-        fd_set rfds;
-        fd_set wfds;
+  while (reading ? readNotifier->isEnabled () : !writeBuffer.isEmpty ())
+    {
+      fd_set rfds;
+      fd_set wfds;
 
-        FD_ZERO(&rfds);
-        FD_ZERO(&wfds);
+      FD_ZERO (&rfds);
+      FD_ZERO (&wfds);
 
-        if (readNotifier->isEnabled())
-            FD_SET(q->masterFd(), &rfds);
-        if (!writeBuffer.isEmpty())
-            FD_SET(q->masterFd(), &wfds);
+      if (readNotifier->isEnabled ())
+	FD_SET (q->masterFd (), &rfds);
+      if (!writeBuffer.isEmpty ())
+	FD_SET (q->masterFd (), &wfds);
 
 #ifndef __linux__
-        if (tvp) {
-            gettimeofday(&tv, 0);
-            timersub(&etv, &tv, &tv);
-            if (tv.tv_sec < 0)
-                tv.tv_sec = tv.tv_usec = 0;
-        }
+      if (tvp)
+	{
+	  gettimeofday (&tv, 0);
+	  timersub (&etv, &tv, &tv);
+	  if (tv.tv_sec < 0)
+	    tv.tv_sec = tv.tv_usec = 0;
+	}
 #endif
 
-        switch (select(q->masterFd() + 1, &rfds, &wfds, 0, tvp)) {
-        case -1:
-            if (errno == EINTR)
-                break;
-            return false;
-        case 0:
-            q->setErrorString(i18n("PTY operation timed out"));
-            return false;
-        default:
-            if (FD_ISSET(q->masterFd(), &rfds)) {
-                bool canRead = _k_canRead();
-                if (reading && canRead)
-                    return true;
-            }
-            if (FD_ISSET(q->masterFd(), &wfds)) {
-                bool canWrite = _k_canWrite();
-                if (!reading)
-                    return canWrite;
-            }
-            break;
-        }
+      switch (select (q->masterFd () + 1, &rfds, &wfds, 0, tvp))
+	{
+	case -1:
+	  if (errno == EINTR)
+	    break;
+	  return false;
+	case 0:
+	  q->setErrorString (i18n ("PTY operation timed out"));
+	  return false;
+	default:
+	  if (FD_ISSET (q->masterFd (), &rfds))
+	    {
+	      bool canRead = _k_canRead ();
+	      if (reading && canRead)
+		return true;
+	    }
+	  if (FD_ISSET (q->masterFd (), &wfds))
+	    {
+	      bool canWrite = _k_canWrite ();
+	      if (!reading)
+		return canWrite;
+	    }
+	  break;
+	}
     }
-    return false;
+  return false;
 }
 
-void KPtyDevicePrivate::finishOpen(QIODevice::OpenMode mode)
+void
+KPtyDevicePrivate::finishOpen (QIODevice::OpenMode mode)
 {
-    Q_Q(KPtyDevice);
+  Q_Q (KPtyDevice);
 
-    q->QIODevice::open(mode);
-    fcntl(q->masterFd(), F_SETFL, O_NONBLOCK);
-    readBuffer.clear();
-    readNotifier = new QSocketNotifier(q->masterFd(), QSocketNotifier::Read, q);
-    writeNotifier = new QSocketNotifier(q->masterFd(), QSocketNotifier::Write, q);
-    QObject::connect(readNotifier, SIGNAL(activated(int)), q, SLOT(_k_canRead()));
-    QObject::connect(writeNotifier, SIGNAL(activated(int)), q, SLOT(_k_canWrite()));
-    readNotifier->setEnabled(true);
+  q->QIODevice::open (mode);
+  fcntl (q->masterFd (), F_SETFL, O_NONBLOCK);
+  readBuffer.clear ();
+  readNotifier =
+    new QSocketNotifier (q->masterFd (), QSocketNotifier::Read, q);
+  writeNotifier =
+    new QSocketNotifier (q->masterFd (), QSocketNotifier::Write, q);
+  QObject::connect (readNotifier, SIGNAL (activated (int)), q,
+		    SLOT (_k_canRead ()));
+  QObject::connect (writeNotifier, SIGNAL (activated (int)), q,
+		    SLOT (_k_canWrite ()));
+  readNotifier->setEnabled (true);
 }
 
 /////////////////////////////
 // public member functions //
 /////////////////////////////
 
-KPtyDevice::KPtyDevice(QObject *parent) :
-    QIODevice(parent),
-    KPty(new KPtyDevicePrivate(this))
+KPtyDevice::KPtyDevice (QObject * parent):
+QIODevice (parent), KPty (new KPtyDevicePrivate (this))
 {
 }
 
-KPtyDevice::~KPtyDevice()
+KPtyDevice::~KPtyDevice ()
 {
-    close();
+  close ();
 }
 
-bool KPtyDevice::open(OpenMode mode)
+bool
+KPtyDevice::open (OpenMode mode)
 {
-    Q_D(KPtyDevice);
+  Q_D (KPtyDevice);
 
-    if (masterFd() >= 0)
-        return true;
+  if (masterFd () >= 0)
+    return true;
 
-    if (!KPty::open()) {
-        setErrorString(i18n("Error opening PTY"));
-        return false;
+  if (!KPty::open ())
+    {
+      setErrorString (i18n ("Error opening PTY"));
+      return false;
     }
 
-    d->finishOpen(mode);
+  d->finishOpen (mode);
 
-    return true;
+  return true;
 }
 
-bool KPtyDevice::open(int fd, OpenMode mode)
+bool
+KPtyDevice::open (int fd, OpenMode mode)
 {
-    Q_D(KPtyDevice);
+  Q_D (KPtyDevice);
 
-    if (!KPty::open(fd)) {
-        setErrorString(i18n("Error opening PTY"));
-        return false;
+  if (!KPty::open (fd))
+    {
+      setErrorString (i18n ("Error opening PTY"));
+      return false;
     }
 
-    d->finishOpen(mode);
+  d->finishOpen (mode);
 
-    return true;
+  return true;
 }
 
-void KPtyDevice::close()
+void
+KPtyDevice::close ()
 {
-    Q_D(KPtyDevice);
-
-    if (masterFd() < 0)
-        return;
+  Q_D (KPtyDevice);
 
-    delete d->readNotifier;
-    delete d->writeNotifier;
+  if (masterFd () < 0)
+    return;
 
-    QIODevice::close();
+  delete d->readNotifier;
+  delete d->writeNotifier;
 
-    KPty::close();
+  QIODevice::close ();
+
+  KPty::close ();
 }
 
-bool KPtyDevice::isSequential() const
+bool
+KPtyDevice::isSequential () const
 {
-    return true;
+  return true;
 }
 
-bool KPtyDevice::canReadLine() const
+bool
+KPtyDevice::canReadLine () const
 {
-    Q_D(const KPtyDevice);
-    return QIODevice::canReadLine() || d->readBuffer.canReadLine();
+  Q_D (const KPtyDevice);
+  return QIODevice::canReadLine () || d->readBuffer.canReadLine ();
 }
 
-bool KPtyDevice::atEnd() const
+bool
+KPtyDevice::atEnd () const
 {
-    Q_D(const KPtyDevice);
-    return QIODevice::atEnd() && d->readBuffer.isEmpty();
+  Q_D (const KPtyDevice);
+  return QIODevice::atEnd () && d->readBuffer.isEmpty ();
 }
 
-qint64 KPtyDevice::bytesAvailable() const
+qint64
+KPtyDevice::bytesAvailable () const
 {
-    Q_D(const KPtyDevice);
-    return QIODevice::bytesAvailable() + d->readBuffer.size();
+  Q_D (const KPtyDevice);
+  return QIODevice::bytesAvailable () + d->readBuffer.size ();
 }
 
-qint64 KPtyDevice::bytesToWrite() const
+qint64
+KPtyDevice::bytesToWrite () const
 {
-    Q_D(const KPtyDevice);
-    return d->writeBuffer.size();
+  Q_D (const KPtyDevice);
+  return d->writeBuffer.size ();
 }
 
-bool KPtyDevice::waitForReadyRead(int msecs)
+bool
+KPtyDevice::waitForReadyRead (int msecs)
 {
-    Q_D(KPtyDevice);
-    return d->doWait(msecs, true);
+  Q_D (KPtyDevice);
+  return d->doWait (msecs, true);
 }
 
-bool KPtyDevice::waitForBytesWritten(int msecs)
+bool
+KPtyDevice::waitForBytesWritten (int msecs)
 {
-    Q_D(KPtyDevice);
-    return d->doWait(msecs, false);
+  Q_D (KPtyDevice);
+  return d->doWait (msecs, false);
 }
 
-void KPtyDevice::setSuspended(bool suspended)
+void
+KPtyDevice::setSuspended (bool suspended)
 {
-    Q_D(KPtyDevice);
-    d->readNotifier->setEnabled(!suspended);
+  Q_D (KPtyDevice);
+  d->readNotifier->setEnabled (!suspended);
 }
 
-bool KPtyDevice::isSuspended() const
+bool
+KPtyDevice::isSuspended () const
 {
-    Q_D(const KPtyDevice);
-    return !d->readNotifier->isEnabled();
+  Q_D (const KPtyDevice);
+  return !d->readNotifier->isEnabled ();
 }
 
 // protected
-qint64 KPtyDevice::readData(char *data, qint64 maxlen)
+qint64
+KPtyDevice::readData (char *data, qint64 maxlen)
 {
-    Q_D(KPtyDevice);
-    return d->readBuffer.read(data, (int)qMin<qint64>(maxlen, KMAXINT));
+  Q_D (KPtyDevice);
+  return d->readBuffer.read (data, (int) qMin < qint64 > (maxlen, KMAXINT));
 }
 
 // protected
-qint64 KPtyDevice::readLineData(char *data, qint64 maxlen)
+qint64
+KPtyDevice::readLineData (char *data, qint64 maxlen)
 {
-    Q_D(KPtyDevice);
-    return d->readBuffer.readLine(data, (int)qMin<qint64>(maxlen, KMAXINT));
+  Q_D (KPtyDevice);
+  return d->readBuffer.readLine (data,
+				 (int) qMin < qint64 > (maxlen, KMAXINT));
 }
 
 // protected
-qint64 KPtyDevice::writeData(const char *data, qint64 len)
+qint64
+KPtyDevice::writeData (const char *data, qint64 len)
 {
-    Q_D(KPtyDevice);
-    Q_ASSERT(len <= KMAXINT);
+  Q_D (KPtyDevice);
+  Q_ASSERT (len <= KMAXINT);
 
-    d->writeBuffer.write(data, len);
-    d->writeNotifier->setEnabled(true);
-    return len;
+  d->writeBuffer.write (data, len);
+  d->writeNotifier->setEnabled (true);
+  return len;
 }
-
diff --git a/gui/src/terminal/kptydevice.h b/gui/src/terminal/kptydevice.h
--- a/gui/src/terminal/kptydevice.h
+++ b/gui/src/terminal/kptydevice.h
@@ -32,322 +32,326 @@ struct KPtyDevicePrivate;
 #define Q_DECLARE_PRIVATE_MI(Class, SuperClass) \
     inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(SuperClass::d_ptr); } \
     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(SuperClass::d_ptr); } \
     friend class Class##Private;
 
 /**
  * Encapsulates KPty into a QIODevice, so it can be used with Q*Stream, etc.
  */
-class KPtyDevice : public QIODevice, public KPty { //krazy:exclude=dpointer (via macro)
-    Q_OBJECT
-    Q_DECLARE_PRIVATE_MI(KPtyDevice, KPty)
-
-public:
+class KPtyDevice:public QIODevice, public KPty
+{				//krazy:exclude=dpointer (via macro)
+Q_OBJECT Q_DECLARE_PRIVATE_MI (KPtyDevice, KPty) public:
 
     /**
      * Constructor
      */
-    KPtyDevice(QObject *parent = 0);
+  KPtyDevice (QObject * parent = 0);
 
     /**
      * Destructor:
      *
      *  If the pty is still open, it will be closed. Note, however, that
      *  an utmp registration is @em not undone.
      */
-    virtual ~KPtyDevice();
+  virtual ~ KPtyDevice ();
 
     /**
      * Create a pty master/slave pair.
      *
      * @return true if a pty pair was successfully opened
      */
-    virtual bool open(OpenMode mode = ReadWrite | Unbuffered);
+  virtual bool open (OpenMode mode = ReadWrite | Unbuffered);
 
     /**
      * Open using an existing pty master. The ownership of the fd
      * remains with the caller, i.e., close() will not close the fd.
      *
      * This is useful if you wish to attach a secondary "controller" to an
      * existing pty device such as a terminal widget.
      * Note that you will need to use setSuspended() on both devices to
      * control which one gets the incoming data from the pty.
      *
      * @param fd an open pty master file descriptor.
      * @param mode the device mode to open the pty with.
      * @return true if a pty pair was successfully opened
      */
-    bool open(int fd, OpenMode mode = ReadWrite | Unbuffered);
+  bool open (int fd, OpenMode mode = ReadWrite | Unbuffered);
 
     /**
      * Close the pty master/slave pair.
      */
-    virtual void close();
+  virtual void close ();
 
     /**
      * Sets whether the KPtyDevice monitors the pty for incoming data.
      *
      * When the KPtyDevice is suspended, it will no longer attempt to buffer
      * data that becomes available from the pty and it will not emit any
      * signals.
      *
      * Do not use on closed ptys.
      * After a call to open(), the pty is not suspended. If you need to
      * ensure that no data is read, call this function before the main loop
      * is entered again (i.e., immediately after opening the pty).
      */
-    void setSuspended(bool suspended);
+  void setSuspended (bool suspended);
 
     /**
      * Returns true if the KPtyDevice is not monitoring the pty for incoming
      * data.
      *
      * Do not use on closed ptys.
      *
      * See setSuspended()
      */
-    bool isSuspended() const;
+  bool isSuspended () const;
 
     /**
      * @return always true
      */
-    virtual bool isSequential() const;
+  virtual bool isSequential () const;
 
     /**
      * @reimp
      */
-    bool canReadLine() const;
+  bool canReadLine () const;
 
     /**
      * @reimp
      */
-    bool atEnd() const;
+  bool atEnd () const;
 
     /**
      * @reimp
      */
-    qint64 bytesAvailable() const;
+  qint64 bytesAvailable () const;
 
     /**
      * @reimp
      */
-    qint64 bytesToWrite() const;
+  qint64 bytesToWrite () const;
 
-    bool waitForBytesWritten(int msecs = -1);
-    bool waitForReadyRead(int msecs = -1);
+  bool waitForBytesWritten (int msecs = -1);
+  bool waitForReadyRead (int msecs = -1);
 
 
-Q_SIGNALS:
+    Q_SIGNALS:
     /**
      * Emitted when EOF is read from the PTY.
      *
      * Data may still remain in the buffers.
      */
-    void readEof();
+  void readEof ();
 
 protected:
-    virtual qint64 readData(char *data, qint64 maxSize);
-    virtual qint64 readLineData(char *data, qint64 maxSize);
-    virtual qint64 writeData(const char *data, qint64 maxSize);
+    virtual qint64 readData (char *data, qint64 maxSize);
+  virtual qint64 readLineData (char *data, qint64 maxSize);
+  virtual qint64 writeData (const char *data, qint64 maxSize);
 
 private:
-    Q_PRIVATE_SLOT(d_func(), bool _k_canRead())
-    Q_PRIVATE_SLOT(d_func(), bool _k_canWrite())
-};
+  Q_PRIVATE_SLOT (d_func (), bool _k_canRead ())
+    Q_PRIVATE_SLOT (d_func (), bool _k_canWrite ())};
 
 #define KMAXINT ((int)(~0U >> 1))
 
 /////////////////////////////////////////////////////
 // Helper. Remove when QRingBuffer becomes public. //
 /////////////////////////////////////////////////////
 
 #include <QtCore/qbytearray.h>
 #include <QtCore/qlinkedlist.h>
 
 #define CHUNKSIZE 4096
 
 class KRingBuffer
 {
 public:
-    KRingBuffer()
-    {
-        clear();
-    }
+  KRingBuffer ()
+  {
+    clear ();
+  }
 
-    void clear()
-    {
-        buffers.clear();
-        QByteArray tmp;
-        tmp.resize(CHUNKSIZE);
-        buffers << tmp;
-        head = tail = 0;
-        totalSize = 0;
-    }
+  void clear ()
+  {
+    buffers.clear ();
+    QByteArray tmp;
+    tmp.resize (CHUNKSIZE);
+    buffers << tmp;
+    head = tail = 0;
+    totalSize = 0;
+  }
+
+  inline bool isEmpty () const
+  {
+    return buffers.count () == 1 && !tail;
+  }
 
-    inline bool isEmpty() const
-    {
-        return buffers.count() == 1 && !tail;
-    }
+  inline int size () const
+  {
+    return totalSize;
+  }
+
+  inline int readSize () const
+  {
+    return (buffers.count () == 1 ? tail : buffers.first ().size ()) - head;
+  }
 
-    inline int size() const
-    {
-        return totalSize;
-    }
+  inline const char *readPointer () const
+  {
+    Q_ASSERT (totalSize > 0);
+    return buffers.first ().constData () + head;
+  }
 
-    inline int readSize() const
-    {
-        return (buffers.count() == 1 ? tail : buffers.first().size()) - head;
-    }
+  void free (int bytes)
+  {
+    totalSize -= bytes;
+    Q_ASSERT (totalSize >= 0);
 
-    inline const char *readPointer() const
+    forever
     {
-        Q_ASSERT(totalSize > 0);
-        return buffers.first().constData() + head;
-    }
+      int nbs = readSize ();
 
-    void free(int bytes)
-    {
-        totalSize -= bytes;
-        Q_ASSERT(totalSize >= 0);
-
-        forever {
-            int nbs = readSize();
+      if (bytes < nbs)
+	{
+	  head += bytes;
+	  if (head == tail && buffers.count () == 1)
+	    {
+	      buffers.first ().resize (CHUNKSIZE);
+	      head = tail = 0;
+	    }
+	  break;
+	}
 
-            if (bytes < nbs) {
-                head += bytes;
-                if (head == tail && buffers.count() == 1) {
-                    buffers.first().resize(CHUNKSIZE);
-                    head = tail = 0;
-                }
-                break;
-            }
+      bytes -= nbs;
+      if (buffers.count () == 1)
+	{
+	  buffers.first ().resize (CHUNKSIZE);
+	  head = tail = 0;
+	  break;
+	}
 
-            bytes -= nbs;
-            if (buffers.count() == 1) {
-                buffers.first().resize(CHUNKSIZE);
-                head = tail = 0;
-                break;
-            }
+      buffers.removeFirst ();
+      head = 0;
+    }
+  }
 
-            buffers.removeFirst();
-            head = 0;
-        }
-    }
-
-    char *reserve(int bytes)
-    {
-        totalSize += bytes;
+  char *reserve (int bytes)
+  {
+    totalSize += bytes;
 
-        char *ptr;
-        if (tail + bytes <= buffers.last().size()) {
-            ptr = buffers.last().data() + tail;
-            tail += bytes;
-        } else {
-            buffers.last().resize(tail);
-            QByteArray tmp;
-            tmp.resize(qMax(CHUNKSIZE, bytes));
-            ptr = tmp.data();
-            buffers << tmp;
-            tail = bytes;
-        }
-        return ptr;
-    }
+    char *ptr;
+    if (tail + bytes <= buffers.last ().size ())
+      {
+	ptr = buffers.last ().data () + tail;
+	tail += bytes;
+      }
+    else
+      {
+	buffers.last ().resize (tail);
+	QByteArray tmp;
+	tmp.resize (qMax (CHUNKSIZE, bytes));
+	ptr = tmp.data ();
+	buffers << tmp;
+	tail = bytes;
+      }
+    return ptr;
+  }
 
-    // release a trailing part of the last reservation
-    inline void unreserve(int bytes)
-    {
-        totalSize -= bytes;
-        tail -= bytes;
-    }
+  // release a trailing part of the last reservation
+  inline void unreserve (int bytes)
+  {
+    totalSize -= bytes;
+    tail -= bytes;
+  }
 
-    inline void write(const char *data, int len)
-    {
-        memcpy(reserve(len), data, len);
-    }
+  inline void write (const char *data, int len)
+  {
+    memcpy (reserve (len), data, len);
+  }
 
-    // Find the first occurrence of c and return the index after it.
-    // If c is not found until maxLength, maxLength is returned, provided
-    // it is smaller than the buffer size. Otherwise -1 is returned.
-    int indexAfter(char c, int maxLength = KMAXINT) const
+  // Find the first occurrence of c and return the index after it.
+  // If c is not found until maxLength, maxLength is returned, provided
+  // it is smaller than the buffer size. Otherwise -1 is returned.
+  int indexAfter (char c, int maxLength = KMAXINT) const
+  {
+    int index = 0;
+    int start = head;
+      QLinkedList < QByteArray >::ConstIterator it = buffers.begin ();
+      forever
     {
-        int index = 0;
-        int start = head;
-        QLinkedList<QByteArray>::ConstIterator it = buffers.begin();
-        forever {
-            if (!maxLength)
-                return index;
-            if (index == size())
-                return -1;
-            const QByteArray &buf = *it;
-            ++it;
-            int len = qMin((it == buffers.end() ? tail : buf.size()) - start,
-                           maxLength);
-            const char *ptr = buf.data() + start;
-            if (const char *rptr = (const char *)memchr(ptr, c, len))
-                return index + (rptr - ptr) + 1;
-            index += len;
-            maxLength -= len;
-            start = 0;
-        }
-    }
-
-    inline int lineSize(int maxLength = KMAXINT) const
-    {
-        return indexAfter('\n', maxLength);
+      if (!maxLength)
+	return index;
+      if (index == size ())
+	return -1;
+      const QByteArray & buf = *it;
+      ++it;
+      int len = qMin ((it == buffers.end ()? tail : buf.size ()) - start,
+		      maxLength);
+      const char *ptr = buf.data () + start;
+      if (const char *rptr = (const char *)memchr (ptr, c, len))
+	return index + (rptr - ptr) + 1;
+        index += len;
+        maxLength -= len;
+        start = 0;
     }
+  }
 
-    inline bool canReadLine() const
-    {
-        return lineSize() != -1;
-    }
+  inline int lineSize (int maxLength = KMAXINT) const
+  {
+    return indexAfter ('\n', maxLength);
+  }
+
+  inline bool canReadLine () const
+  {
+    return lineSize () != -1;
+  }
 
-    int read(char *data, int maxLength)
-    {
-        int bytesToRead = qMin(size(), maxLength);
-        int readSoFar = 0;
-        while (readSoFar < bytesToRead) {
-            const char *ptr = readPointer();
-            int bs = qMin(bytesToRead - readSoFar, readSize());
-            memcpy(data + readSoFar, ptr, bs);
-            readSoFar += bs;
-            free(bs);
-        }
-        return readSoFar;
-    }
+  int read (char *data, int maxLength)
+  {
+    int bytesToRead = qMin (size (), maxLength);
+    int readSoFar = 0;
+    while (readSoFar < bytesToRead)
+      {
+	const char *ptr = readPointer ();
+	int bs = qMin (bytesToRead - readSoFar, readSize ());
+	memcpy (data + readSoFar, ptr, bs);
+	readSoFar += bs;
+	free (bs);
+      }
+    return readSoFar;
+  }
 
-    int readLine(char *data, int maxLength)
-    {
-        return read(data, lineSize(qMin(maxLength, size())));
-    }
+  int readLine (char *data, int maxLength)
+  {
+    return read (data, lineSize (qMin (maxLength, size ())));
+  }
 
 private:
-    QLinkedList<QByteArray> buffers;
-    int head, tail;
-    int totalSize;
+  QLinkedList < QByteArray > buffers;
+  int head, tail;
+  int totalSize;
 };
 
-struct KPtyDevicePrivate : public KPtyPrivate {
-    Q_DECLARE_PUBLIC(KPtyDevice)
-
-    KPtyDevicePrivate(KPty* parent) :
-        KPtyPrivate(parent),
-        emittedReadyRead(false), emittedBytesWritten(false),
-        readNotifier(0), writeNotifier(0)
-    {
-    }
+struct KPtyDevicePrivate:public KPtyPrivate
+{
+  Q_DECLARE_PUBLIC (KPtyDevice)
+    KPtyDevicePrivate (KPty * parent):KPtyPrivate (parent),
+    emittedReadyRead (false), emittedBytesWritten (false),
+    readNotifier (0), writeNotifier (0)
+  {
+  }
 
-    bool _k_canRead();
-    bool _k_canWrite();
+  bool _k_canRead ();
+  bool _k_canWrite ();
 
-    bool doWait(int msecs, bool reading);
-    void finishOpen(QIODevice::OpenMode mode);
+  bool doWait (int msecs, bool reading);
+  void finishOpen (QIODevice::OpenMode mode);
 
-    bool emittedReadyRead;
-    bool emittedBytesWritten;
-    QSocketNotifier *readNotifier;
-    QSocketNotifier *writeNotifier;
-    KRingBuffer readBuffer;
-    KRingBuffer writeBuffer;
+  bool emittedReadyRead;
+  bool emittedBytesWritten;
+  QSocketNotifier *readNotifier;
+  QSocketNotifier *writeNotifier;
+  KRingBuffer readBuffer;
+  KRingBuffer writeBuffer;
 };
 
 #endif
-
diff --git a/gui/src/terminal/kptyprocess.cpp b/gui/src/terminal/kptyprocess.cpp
--- a/gui/src/terminal/kptyprocess.cpp
+++ b/gui/src/terminal/kptyprocess.cpp
@@ -26,94 +26,100 @@
 
 #include <stdlib.h>
 #include <unistd.h>
 
 //////////////////
 // private data //
 //////////////////
 
-KPtyProcess::KPtyProcess(QObject *parent) :
-    KProcess(new KPtyProcessPrivate, parent)
+KPtyProcess::KPtyProcess (QObject * parent):
+KProcess (new KPtyProcessPrivate, parent)
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    d->pty = new KPtyDevice(this);
-    d->pty->open();
-    connect(this, SIGNAL(stateChanged(QProcess::ProcessState)),
-            SLOT(_k_onStateChanged(QProcess::ProcessState)));
+  d->pty = new KPtyDevice (this);
+  d->pty->open ();
+  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
+	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
 }
 
-KPtyProcess::KPtyProcess(int ptyMasterFd, QObject *parent) :
-    KProcess(new KPtyProcessPrivate, parent)
+KPtyProcess::KPtyProcess (int ptyMasterFd, QObject * parent):
+KProcess (new KPtyProcessPrivate, parent)
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    d->pty = new KPtyDevice(this);
-    d->pty->open(ptyMasterFd);
-    connect(this, SIGNAL(stateChanged(QProcess::ProcessState)),
-            SLOT(_k_onStateChanged(QProcess::ProcessState)));
+  d->pty = new KPtyDevice (this);
+  d->pty->open (ptyMasterFd);
+  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
+	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
 }
 
-KPtyProcess::~KPtyProcess()
+KPtyProcess::~KPtyProcess ()
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    if (state() != QProcess::NotRunning && d->addUtmp) {
-        d->pty->logout();
-        disconnect(SIGNAL(stateChanged(QProcess::ProcessState)),
-                   this, SLOT(_k_onStateChanged(QProcess::ProcessState)));
+  if (state () != QProcess::NotRunning && d->addUtmp)
+    {
+      d->pty->logout ();
+      disconnect (SIGNAL (stateChanged (QProcess::ProcessState)),
+		  this, SLOT (_k_onStateChanged (QProcess::ProcessState)));
     }
-    delete d->pty;
+  delete d->pty;
 }
 
-void KPtyProcess::setPtyChannels(PtyChannels channels)
+void
+KPtyProcess::setPtyChannels (PtyChannels channels)
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    d->ptyChannels = channels;
+  d->ptyChannels = channels;
 }
 
-KPtyProcess::PtyChannels KPtyProcess::ptyChannels() const
+KPtyProcess::PtyChannels KPtyProcess::ptyChannels () const
 {
-    Q_D(const KPtyProcess);
+  Q_D (const KPtyProcess);
 
-    return d->ptyChannels;
+  return d->ptyChannels;
 }
 
-void KPtyProcess::setUseUtmp(bool value)
+void
+KPtyProcess::setUseUtmp (bool value)
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    d->addUtmp = value;
+  d->addUtmp = value;
 }
 
-bool KPtyProcess::isUseUtmp() const
+bool
+KPtyProcess::isUseUtmp () const
 {
-    Q_D(const KPtyProcess);
+  Q_D (const KPtyProcess);
 
-    return d->addUtmp;
+  return d->addUtmp;
 }
 
-KPtyDevice *KPtyProcess::pty() const
+KPtyDevice *
+KPtyProcess::pty () const
 {
-    Q_D(const KPtyProcess);
+  Q_D (const KPtyProcess);
 
-    return d->pty;
+  return d->pty;
 }
 
-void KPtyProcess::setupChildProcess()
+void
+KPtyProcess::setupChildProcess ()
 {
-    Q_D(KPtyProcess);
+  Q_D (KPtyProcess);
 
-    d->pty->setCTty();
-    if (d->addUtmp)
-      d->pty->login(getenv("USER"), getenv("DISPLAY"));
-      //d->pty->login(KUser(KUser::UseRealUserID).loginName().toLocal8Bit().data(), qgetenv("DISPLAY"));
-    if (d->ptyChannels & StdinChannel)
-        dup2(d->pty->slaveFd(), 0);
-    if (d->ptyChannels & StdoutChannel)
-        dup2(d->pty->slaveFd(), 1);
-    if (d->ptyChannels & StderrChannel)
-        dup2(d->pty->slaveFd(), 2);
+  d->pty->setCTty ();
+  if (d->addUtmp)
+    d->pty->login (getenv ("USER"), getenv ("DISPLAY"));
+  //d->pty->login(KUser(KUser::UseRealUserID).loginName().toLocal8Bit().data(), qgetenv("DISPLAY"));
+  if (d->ptyChannels & StdinChannel)
+    dup2 (d->pty->slaveFd (), 0);
+  if (d->ptyChannels & StdoutChannel)
+    dup2 (d->pty->slaveFd (), 1);
+  if (d->ptyChannels & StderrChannel)
+    dup2 (d->pty->slaveFd (), 2);
 
-    KProcess::setupChildProcess();
+  KProcess::setupChildProcess ();
 }
diff --git a/gui/src/terminal/kptyprocess.h b/gui/src/terminal/kptyprocess.h
--- a/gui/src/terminal/kptyprocess.h
+++ b/gui/src/terminal/kptyprocess.h
@@ -40,118 +40,113 @@ struct KPtyProcessPrivate;
  * Utmp registration and connecting the stdio handles to the PTY are optional.
  *
  * No attempt to integrate with QProcess' waitFor*() functions was made,
  * for it is impossible. Note that execute() does not work with the PTY, too.
  * Use the PTY device's waitFor*() functions or use it asynchronously.
  *
  * @author Oswald Buddenhagen <ossi@kde.org>
  */
-class KPtyProcess : public KProcess
+class KPtyProcess:public KProcess
 {
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(KPtyProcess)
+Q_OBJECT Q_DECLARE_PRIVATE (KPtyProcess) public:
+  enum PtyChannelFlag
+  {
+    NoChannels = 0,	/**< The PTY is not connected to any channel. */
+    StdinChannel = 1,	  /**< Connect PTY to stdin. */
+    StdoutChannel = 2,	   /**< Connect PTY to stdout. */
+    StderrChannel = 4,	   /**< Connect PTY to stderr. */
+    AllOutputChannels = 6,     /**< Connect PTY to all output channels. */
+    AllChannels = 7	/**< Connect PTY to all channels. */
+  };
 
-public:
-    enum PtyChannelFlag {
-        NoChannels = 0, /**< The PTY is not connected to any channel. */
-        StdinChannel = 1, /**< Connect PTY to stdin. */
-        StdoutChannel = 2, /**< Connect PTY to stdout. */
-        StderrChannel = 4, /**< Connect PTY to stderr. */
-        AllOutputChannels = 6, /**< Connect PTY to all output channels. */
-        AllChannels = 7 /**< Connect PTY to all channels. */
-    };
-
-    Q_DECLARE_FLAGS(PtyChannels, PtyChannelFlag)
-
+    Q_DECLARE_FLAGS (PtyChannels, PtyChannelFlag)
     /**
      * Constructor
      */
-    explicit KPtyProcess(QObject *parent = 0);
+  explicit KPtyProcess (QObject * parent = 0);
 
     /**
      * Construct a process using an open pty master.
      *
      * @param ptyMasterFd an open pty master file descriptor.
      *   The process does not take ownership of the descriptor;
      *   it will not be automatically closed at any point.
      */
-    KPtyProcess(int ptyMasterFd, QObject *parent = 0);
+    KPtyProcess (int ptyMasterFd, QObject * parent = 0);
 
     /**
      * Destructor
      */
-    virtual ~KPtyProcess();
+    virtual ~ KPtyProcess ();
 
     /**
      * Set to which channels the PTY should be assigned.
      *
      * This function must be called before starting the process.
      *
      * @param channels the output channel handling mode
      */
-    void setPtyChannels(PtyChannels channels);
+  void setPtyChannels (PtyChannels channels);
 
     /**
      * Query to which channels the PTY is assigned.
      *
      * @return the output channel handling mode
      */
-    PtyChannels ptyChannels() const;
+  PtyChannels ptyChannels () const;
 
     /**
      * Set whether to register the process as a TTY login in utmp.
      *
      * Utmp is disabled by default.
      * It should enabled for interactively fed processes, like terminal
      * emulations.
      *
      * This function must be called before starting the process.
      *
      * @param value whether to register in utmp.
      */
-    void setUseUtmp(bool value);
+  void setUseUtmp (bool value);
 
     /**
      * Get whether to register the process as a TTY login in utmp.
      *
      * @return whether to register in utmp
      */
-    bool isUseUtmp() const;
+  bool isUseUtmp () const;
 
     /**
      * Get the PTY device of this process.
      *
      * @return the PTY device
      */
-    KPtyDevice *pty() const;
+  KPtyDevice *pty () const;
 
 protected:
     /**
      * @reimp
      */
-    virtual void setupChildProcess();
+    virtual void setupChildProcess ();
 
 private:
-    Q_PRIVATE_SLOT(d_func(), void _k_onStateChanged(QProcess::ProcessState))
+  Q_PRIVATE_SLOT (d_func (),
+		    void _k_onStateChanged (QProcess::ProcessState))};
+
+struct KPtyProcessPrivate:KProcessPrivate
+{
+  KPtyProcessPrivate ():ptyChannels (KPtyProcess::NoChannels), addUtmp (false)
+  {
+  }
+
+  void _k_onStateChanged (QProcess::ProcessState newState)
+  {
+    if (newState == QProcess::NotRunning && addUtmp)
+      pty->logout ();
+  }
+
+  KPtyDevice *pty;
+  KPtyProcess::PtyChannels ptyChannels;
+  bool addUtmp:1;
 };
 
-struct KPtyProcessPrivate : KProcessPrivate {
-    KPtyProcessPrivate() :
-        ptyChannels(KPtyProcess::NoChannels),
-        addUtmp(false)
-    {
-    }
-
-    void _k_onStateChanged(QProcess::ProcessState newState)
-    {
-        if (newState == QProcess::NotRunning && addUtmp)
-            pty->logout();
-    }
-
-    KPtyDevice *pty;
-    KPtyProcess::PtyChannels ptyChannels;
-    bool addUtmp : 1;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(KPtyProcess::PtyChannels)
-
+Q_DECLARE_OPERATORS_FOR_FLAGS (KPtyProcess::PtyChannels)
 #endif
