# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1327452826 -3600
#      Wed Jan 25 01:53:46 2012 +0100
# Node ID aeab072c37a91f3726f43d0007e1c5f9f8aa67bc
# Parent  1073b2efaa9309f18c12c8e0ed0a66bcfa16604a
Removed code that forked a process. Instead, connected pty directly to parent process.

diff --git a/libqterminal/PseudoTerminal.cpp b/libqterminal/PseudoTerminal.cpp
deleted file mode 100644
--- a/libqterminal/PseudoTerminal.cpp
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
-    This file is part of Konsole, an X terminal.
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-// Own
-#include "PseudoTerminal.h"
-
-// System
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <errno.h>
-#include <termios.h>
-
-// Qt
-#include <QtCore>
-
-// KDE
-#include "kpty.h"
-
-void PseudoTerminal::donePty()
-{
-  emit done(exitStatus());
-}
-
-void PseudoTerminal::setWindowSize(int lines, int cols)
-{
-  _windowColumns = cols;
-  _windowLines = lines;
-
-  if (pty()->masterFd() >= 0)
-    pty()->setWinSize(lines, cols);
-}
-QSize PseudoTerminal::windowSize() const
-{
-    return QSize(_windowColumns,_windowLines);
-}
-
-void PseudoTerminal::setXonXoff(bool enable)
-{
-  _xonXoff = enable;
-
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-    pty()->tcGetAttr(&ttmode);
-    if (!enable)
-      ttmode.c_iflag &= ~(IXOFF | IXON);
-    else
-      ttmode.c_iflag |= (IXOFF | IXON);
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
-  }
-}
-
-void PseudoTerminal::setUtf8Mode(bool enable)
-{
-#ifdef IUTF8 // XXX not a reasonable place to check it.
-  _utf8 = enable;
-
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-    pty()->tcGetAttr(&ttmode);
-    if (!enable)
-      ttmode.c_iflag &= ~IUTF8;
-    else
-      ttmode.c_iflag |= IUTF8;
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
-  }
-#endif
-}
-
-void PseudoTerminal::setErase(char erase)
-{
-  _eraseChar = erase;
-  
-  if (pty()->masterFd() >= 0)
-  {
-    struct ::termios ttmode;
-
-    pty()->tcGetAttr(&ttmode);
-
-    ttmode.c_cc[VERASE] = erase;
-
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
-  }  
-}
-
-char PseudoTerminal::erase() const
-{
-	if (pty()->masterFd() >= 0)
-	{
-		qDebug() << "Getting erase char";
-		struct ::termios ttyAttributes;
-		pty()->tcGetAttr(&ttyAttributes);
-		return ttyAttributes.c_cc[VERASE];
-	}
-
-	return _eraseChar;
-}
-
-void PseudoTerminal::addEnvironmentVariables(const QStringList& environment)
-{
-    QListIterator<QString> iter(environment);
-    while (iter.hasNext())
-    {
-        QString pair = iter.next();
-
-        // split on the first '=' character
-        int pos = pair.indexOf('=');
-        
-        if ( pos >= 0 )
-        {
-            QString variable = pair.left(pos);
-            QString value = pair.mid(pos+1);
-
-            //kDebug() << "Setting environment pair" << variable <<
-            //    " set to " << value;
-
-            setEnvironment(variable,value);
-        }
-    }
-}
-
-int PseudoTerminal::start(const QString& program,
-               const QStringList& programArguments, 
-               const QStringList& environment, 
-               ulong winid, 
-               bool addToUtmp
-//               const QString& dbusService,
-//               const QString& dbusSession)
-		)
-{
-  clearArguments();
-
-  setBinaryExecutable(program.toLatin1());
-
-  addEnvironmentVariables(environment);
-
-  QStringListIterator it( programArguments );
-  while (it.hasNext())
-    arguments.append( it.next().toUtf8() );
-
-//  if ( !dbusService.isEmpty() )
-//     setEnvironment("KONSOLE_DBUS_SERVICE",dbusService);
-//  if ( !dbusSession.isEmpty() )
-//     setEnvironment("KONSOLE_DBUS_SESSION", dbusSession);
-
-  setEnvironment("WINDOWID", QString::number(winid));
-
-  // unless the LANGUAGE environment variable has been set explicitly
-  // set it to a null string
-  // this fixes the problem where KCatalog sets the LANGUAGE environment
-  // variable during the application's startup to something which
-  // differs from LANG,LC_* etc. and causes programs run from
-  // the terminal to display mesages in the wrong language
-  //
-  // this can happen if LANG contains a language which KDE
-  // does not have a translation for
-  //
-  // BR:149300
-  if (!environment.contains("LANGUAGE"))
-      setEnvironment("LANGUAGE",QString());
-
-  setUsePty(All, addToUtmp, _pty);
-
-  pty()->open();
-  
-  struct ::termios ttmode;
-  pty()->tcGetAttr(&ttmode);
-  if (!_xonXoff)
-    ttmode.c_iflag &= ~(IXOFF | IXON);
-  else
-    ttmode.c_iflag |= (IXOFF | IXON);
-#ifdef IUTF8 // XXX not a reasonable place to check it.
-  if (!_utf8)
-    ttmode.c_iflag &= ~IUTF8;
-  else
-    ttmode.c_iflag |= IUTF8;
-#endif
-
-  if (_eraseChar != 0)
-  	ttmode.c_cc[VERASE] = _eraseChar;
-  
-  if (!pty()->tcSetAttr(&ttmode))
-    qWarning("Unable to set terminal attributes.");
-  
-  pty()->setWinSize(_windowLines, _windowColumns);
-
-  if ( K3Process::start(NotifyOnExit, (Communication) (Stdin | Stdout)) == false )
-     return -1;
-
-  resume(); // Start...
-  return 0;
-
-}
-
-void PseudoTerminal::setWriteable(bool writeable)
-{
-  struct stat sbuf;
-  stat(pty()->ttyName(), &sbuf);
-  if (writeable)
-    chmod(pty()->ttyName(), sbuf.st_mode | S_IWGRP);
-  else
-    chmod(pty()->ttyName(), sbuf.st_mode & ~(S_IWGRP|S_IWOTH));
-}
-
-PseudoTerminal::PseudoTerminal()
-    : _bufferFull(false),
-      _windowColumns(0),
-      _windowLines(0),
-      _eraseChar(0),
-      _xonXoff(true),
-      _utf8(true)
-{
-  connect(this, SIGNAL(receivedStdout(K3Process *, char *, int )),
-	  this, SLOT(dataReceived(K3Process *,char *, int)));
-  connect(this, SIGNAL(processExited(K3Process *)),
-          this, SLOT(donePty()));
-  connect(this, SIGNAL(wroteStdin(K3Process *)),
-          this, SLOT(writeReady()));
-  _pty = new KPty;
-
-  setUsePty(All, false); // utmp will be overridden later
-}
-
-PseudoTerminal::PseudoTerminal(KPty *kpty)
-    : _bufferFull(false),
-      _windowColumns(0),
-      _windowLines(0),
-      _eraseChar(0),
-      _xonXoff(true),
-      _utf8(true)
-{
-  connect(this, SIGNAL(receivedStdout(K3Process *, char *, int )),
-          this, SLOT(dataReceived(K3Process *,char *, int)));
-  connect(this, SIGNAL(processExited(K3Process *)),
-          this, SLOT(donePty()));
-  connect(this, SIGNAL(wroteStdin(K3Process *)),
-          this, SLOT(writeReady()));
-  _pty = kpty;
-
-  setUsePty(All, false, _pty); // utmp will be overridden later
-}
-
-PseudoTerminal::~PseudoTerminal()
-{
-    delete _pty;
-}
-
-void PseudoTerminal::writeReady()
-{
-  _pendingSendJobs.erase(_pendingSendJobs.begin());
-  _bufferFull = false;
-  doSendJobs();
-}
-
-void PseudoTerminal::doSendJobs() {
-  if(_pendingSendJobs.isEmpty())
-  {
-     emit bufferEmpty(); 
-     return;
-  }
-  
-  SendJob& job = _pendingSendJobs.first();
-
-  
-  if (!writeStdin( job.data(), job.length() ))
-  {
-    qWarning("Pty::doSendJobs - Could not send input data to terminal process.");
-    return;
-  }
-  _bufferFull = true;
-}
-
-void PseudoTerminal::appendSendJob(const char* s, int len)
-{
-  _pendingSendJobs.append(SendJob(s,len));
-}
-
-void PseudoTerminal::sendData(const char* s, int len)
-{
-  appendSendJob(s,len);
-  if (!_bufferFull)
-     doSendJobs();
-}
-
-void PseudoTerminal::dataReceived(K3Process *,char *buf, int len)
-{
-  emit receivedData(buf,len);
-}
-
-void PseudoTerminal::lockPty(bool lock)
-{
-  if (lock)
-    suspend();
-  else
-    resume();
-}
-
-int PseudoTerminal::foregroundProcessGroup() const
-{
-    int pid = tcgetpgrp(pty()->masterFd());
-
-    if ( pid != -1 )
-    {
-        return pid;
-    } 
-
-    return 0;
-}
-
diff --git a/libqterminal/PseudoTerminal.h b/libqterminal/PseudoTerminal.h
deleted file mode 100644
--- a/libqterminal/PseudoTerminal.h
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
-    This file is part of Konsole, KDE's terminal emulator. 
-    
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-#ifndef PTY_H
-#define PTY_H
-
-// Qt
-#include <QtCore/QStringList>
-#include <QtCore/QVector>
-#include <QtCore/QList>
-#include <QtCore>
-
-#include "k3process.h"
-
-/**
- * The Pty class is used to start the terminal process, 
- * send data to it, receive data from it and manipulate 
- * various properties of the pseudo-teletype interface
- * used to communicate with the process.
- *
- * To use this class, construct an instance and connect
- * to the sendData slot and receivedData signal to
- * send data to or receive data from the process.
- *
- * To start the terminal process, call the start() method
- * with the program name and appropriate arguments. 
- */
-class PseudoTerminal: public K3Process
-{
-Q_OBJECT
-
-  public:
-    
-    /** 
-     * Constructs a new Pty.
-     * 
-     * Connect to the sendData() slot and receivedData() signal to prepare
-     * for sending and receiving data from the terminal process.
-     *
-     * To start the terminal process, call the run() method with the 
-     * name of the program to start and appropriate arguments.
-     */
-    PseudoTerminal();
-    PseudoTerminal(KPty *kpty);
-
-    ~PseudoTerminal();
-
-    /**
-     * Starts the terminal process.  
-     *
-     * Returns 0 if the process was started successfully or non-zero
-     * otherwise.
-     *
-     * @param program Path to the program to start
-     * @param arguments Arguments to pass to the program being started
-     * @param environment A list of key=value pairs which will be added
-     * to the environment for the new process.  At the very least this
-     * should include an assignment for the TERM environment variable.
-     * @param winid Specifies the value of the WINDOWID environment variable
-     * in the process's environment.
-     * @param addToUtmp Specifies whether a utmp entry should be created for
-     * the pty used.  See K3Process::setUsePty() 
-     * @param dbusService Specifies the value of the KONSOLE_DBUS_SERVICE 
-     * environment variable in the process's environment.
-     * @param dbusSession Specifies the value of the KONSOLE_DBUS_SESSION
-     * environment variable in the process's environment. 
-     */
-    int start( const QString& program, 
-               const QStringList& arguments, 
-               const QStringList& environment, 
-               ulong winid, 
-               bool addToUtmp
-//               const QString& dbusService,
-//               const QString& dbusSession
-             );
-
-    /** TODO: Document me */
-    void setWriteable(bool writeable);
-
-    /** 
-     * Enables or disables Xon/Xoff flow control.
-     */
-    void setXonXoff(bool on);
-
-    /** 
-     * Sets the size of the window (in lines and columns of characters) 
-     * used by this teletype.
-     */
-    void setWindowSize(int lines, int cols);
-    
-    /** Returns the size of the window used by this teletype.  See setWindowSize() */
-    QSize windowSize() const;
-
-    /** TODO Document me */
-    void setErase(char erase);
-
-	/** */
-	char erase() const;
-
-    /**
-     * Returns the process id of the teletype's current foreground
-     * process.  This is the process which is currently reading
-     * input sent to the terminal via. sendData()
-     *
-     * If there is a problem reading the foreground process group,
-     * 0 will be returned.
-     */
-    int foregroundProcessGroup() const;
-   
-    /**
-     * Returns whether the buffer used to send data to the
-     * terminal process is full.
-     */
-    bool bufferFull() const { return _bufferFull; }
-
-
-  public slots:
-
-    /**
-     * Put the pty into UTF-8 mode on systems which support it.
-     */
-    void setUtf8Mode(bool on);
-
-    /**
-     * Suspend or resume processing of data from the standard 
-     * output of the terminal process.
-     *
-     * See K3Process::suspend() and K3Process::resume()
-     *
-     * @param lock If true, processing of output is suspended,
-     * otherwise processing is resumed.
-     */
-    void lockPty(bool lock);
-    
-    /** 
-     * Sends data to the process currently controlling the 
-     * teletype ( whose id is returned by foregroundProcessGroup() )
-     *
-     * @param buffer Pointer to the data to send.
-     * @param length Length of @p buffer.
-     */
-    void sendData(const char* buffer, int length);
-
-  signals:
-
-    /**
-     * Emitted when the terminal process terminates.
-     *
-     * @param exitCode The status code which the process exited with.
-     */
-    void done(int exitCode);
-
-    /**
-     * Emitted when a new block of data is received from
-     * the teletype.
-     *
-     * @param buffer Pointer to the data received.
-     * @param length Length of @p buffer
-     */
-    void receivedData(const char* buffer, int length);
-    
-    /**
-     * Emitted when the buffer used to send data to the terminal
-     * process becomes empty, i.e. all data has been sent.
-     */
-    void bufferEmpty();
-    
-
-  private slots:
-    
-    // called when terminal process exits
-    void donePty();
-    // called when data is received from the terminal process 
-    void dataReceived(K3Process*, char* buffer, int length);
-    // sends the first enqueued buffer of data to the
-    // terminal process
-    void doSendJobs();
-    // called when the terminal process is ready to
-    // receive more data
-    void writeReady();
-
-  private:
-    // takes a list of key=value pairs and adds them
-    // to the environment for the process
-    void addEnvironmentVariables(const QStringList& environment);
-
-    // enqueues a buffer of data to be sent to the 
-    // terminal process
-    void appendSendJob(const char* buffer, int length);
-   
-    // a buffer of data in the queue to be sent to the 
-    // terminal process 
-    class SendJob {
-	public:
-      		SendJob() {}
-      		SendJob(const char* b, int len) : buffer(len)
-		{
-			memcpy( buffer.data() , b , len );
-        }
-	
-		const char* data() const { return buffer.constData(); }
-		int length() const { return buffer.size(); }	
-	private:
-      		QVector<char> buffer;
-    };
-
-    QList<SendJob> _pendingSendJobs;
-    bool _bufferFull;
-
-    int  _windowColumns; 
-    int  _windowLines;
-    char _eraseChar;
-    bool _xonXoff;
-    bool _utf8;
-    KPty *_pty;
-};
-
-#endif // PTY_H
diff --git a/libqterminal/QTerminal.cpp b/libqterminal/QTerminal.cpp
--- a/libqterminal/QTerminal.cpp
+++ b/libqterminal/QTerminal.cpp
@@ -49,16 +49,17 @@ void QTerminal::init()
     m_sessionModel->setArguments(args);
     m_sessionModel->setAutoClose(true);
     m_sessionModel->setCodec(QTextCodec::codecForName("UTF-8"));
     m_sessionModel->setFlowControlEnabled(true);
     m_sessionModel->setHistoryType(HistoryTypeBuffer(1000));
     m_sessionModel->setDarkBackground(true);
     m_sessionModel->setKeyBindings("");
 
+
     m_sessionView = new SessionView(this);
     m_sessionView->setBellMode(SessionView::NotifyBell);
     m_sessionView->setTerminalSizeHint(true);
     m_sessionView->setTripleClickMode(SessionView::SelectWholeLine);
     m_sessionView->setTerminalSizeStartup(true);
     m_sessionView->setRandomSeed(m_sessionModel->sessionId() * 31);
     m_sessionView->setSize(80, 40);
     
diff --git a/libqterminal/SelfListener.cpp b/libqterminal/SelfListener.cpp
new file mode 100644
--- /dev/null
+++ b/libqterminal/SelfListener.cpp
@@ -0,0 +1,19 @@
+#include "SelfListener.h"
+
+SelfListener::SelfListener(int a, QObject *parent) :
+    QThread(parent) {
+    _a = a;
+}
+
+void SelfListener::run() {
+    char buf[1025];
+    int len;
+
+    while(1) {
+        len = ::read(_a, buf, 1024);
+        if (len > 0) {
+           buf[len] = 0; // Just in case.
+           emit recvData(buf, len);
+        }
+    }
+}
diff --git a/libqterminal/SelfListener.h b/libqterminal/SelfListener.h
new file mode 100644
--- /dev/null
+++ b/libqterminal/SelfListener.h
@@ -0,0 +1,22 @@
+#ifndef SELFLISTENER_H
+#define SELFLISTENER_H
+
+#include <QThread>
+
+class SelfListener : public QThread
+{
+    Q_OBJECT
+public:
+    explicit SelfListener(int a, QObject *parent = 0);
+
+signals:
+    void recvData(const char* stdOutBuffer, int stdOutlen);
+
+public slots:
+
+protected:
+    void run();
+    int _a;
+};
+
+#endif // SELFLISTENER_H
diff --git a/libqterminal/SessionModel.cpp b/libqterminal/SessionModel.cpp
--- a/libqterminal/SessionModel.cpp
+++ b/libqterminal/SessionModel.cpp
@@ -33,17 +33,16 @@
 #include <QtGui/QApplication>
 #include <QtCore/QByteRef>
 #include <QtCore/QDir>
 #include <QtCore/QFile>
 #include <QtCore/QRegExp>
 #include <QtCore/QStringList>
 #include <QtCore>
 
-#include "PseudoTerminal.h"
 #include "SessionView.h"
 #include "ShellCommand.h"
 #include "Vt102Emulation.h"
 
 int SessionModel::lastSessionId = 0;
 
 SessionModel::SessionModel(KPty *kpty) :
     _shellProcess(0)
@@ -62,24 +61,24 @@ SessionModel::SessionModel(KPty *kpty) :
   , _flowControl(true)
   , _fullScripting(false)
   , _sessionId(0)
   //   , _zmodemBusy(false)
   //   , _zmodemProc(0)
   //   , _zmodemProgress(0)
   , _hasDarkBackground(false)
 {
-
+    _kpty = kpty;
     //prepare DBus communication
     //    new SessionAdaptor(this);
-    _sessionId = ++lastSessionId;
+    //_sessionId = ++lastSessionId;
     //    QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
 
     //create teletype for I/O with shell process
-    _shellProcess = new PseudoTerminal(kpty);
+    //_shellProcess = new PseudoTerminal(kpty);
 
     //create emulation backend
     _emulation = new Vt102Emulation();
 
     connect( _emulation, SIGNAL( titleChanged( int, const QString & ) ),
              this, SLOT( setUserTitle( int, const QString & ) ) );
     connect( _emulation, SIGNAL( stateSet(int) ),
              this, SLOT( activityStateSet(int) ) );
@@ -89,27 +88,34 @@ SessionModel::SessionModel(KPty *kpty) :
              this, SIGNAL( changeTabTextColorRequest( int ) ) );
     connect( _emulation, SIGNAL(profileChangeCommandReceived(const QString&)),
              this, SIGNAL( profileChangeCommandReceived(const QString&)) );
     // TODO
     // connect( _emulation,SIGNAL(imageSizeChanged(int,int)) , this ,
     //        SLOT(onEmulationSizeChange(int,int)) );
 
     //connect teletype to emulation backend
-    _shellProcess->setUtf8Mode(_emulation->utf8());
+    //_shellProcess->setUtf8Mode(_emulation->utf8());
+
+    //connect( _shellProcess,SIGNAL(receivedData(const char*,int)),this,
+    //         SLOT(onReceiveBlock(const char*,int)) );
 
-    connect( _shellProcess,SIGNAL(receivedData(const char*,int)),this,
-             SLOT(onReceiveBlock(const char*,int)) );
-    connect( _emulation,SIGNAL(sendData(const char*,int)),_shellProcess,
-             SLOT(sendData(const char*,int)) );
-    connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
-    connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
+    _selfListener = new SelfListener(kpty->masterFd());
+    _selfListener->start();
+    connect( _selfListener, SIGNAL(recvData(const char*,int)),
+             this, SLOT(onReceiveBlock(const char*,int)));
+
+    connect( _emulation, SIGNAL(sendData(const char*,int))
+             ,this,SLOT(sendData(const char*,int)) );
+
+    //connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
+    //connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
 
 
-    connect( _shellProcess,SIGNAL(done(int)), this, SLOT(done(int)) );
+    //connect( _shellProcess,SIGNAL(done(int)), this, SLOT(done(int)) );
 
     //setup timer for monitoring session activity
     _monitorTimer = new QTimer(this);
     _monitorTimer->setSingleShot(true);
     connect(_monitorTimer, SIGNAL(timeout()), this, SLOT(monitorTimerDone()));
 }
 
 WId SessionModel::windowId() const
@@ -146,17 +152,17 @@ void SessionModel::setDarkBackground(boo
     _hasDarkBackground = darkBackground;
 }
 bool SessionModel::hasDarkBackground() const
 {
     return _hasDarkBackground;
 }
 bool SessionModel::isRunning() const
 {
-    return _shellProcess->isRunning();
+    return true; //_shellProcess->isRunning();
 }
 
 void SessionModel::setCodec(QTextCodec* codec)
 {
     emulation()->setCodec(codec);
 }
 
 void SessionModel::setProgram(const QString& program)
@@ -205,29 +211,33 @@ void SessionModel::addView(SessionView* 
 
     //connect view signals and slots
     QObject::connect( widget ,SIGNAL(changedContentSizeSignal(int,int)),this,
                       SLOT(onViewSizeChange(int,int)));
 
     QObject::connect( widget ,SIGNAL(destroyed(QObject*)) , this ,
                       SLOT(viewDestroyed(QObject*)) );
     //slot for close
-    QObject::connect(this, SIGNAL(finished()), widget, SLOT(close()));		    
-    
+    //QObject::connect(this, SIGNAL(finished()), widget, SLOT(close()));
 }
 
 void SessionModel::viewDestroyed(QObject* view)
 {
     SessionView* display = (SessionView*)view;
 
     Q_ASSERT( _views.contains(display) );
 
     removeView(display);
 }
 
+void SessionModel::sendData(const char *buf, int len)
+{
+    ::write(_kpty->masterFd(), buf, len);
+}
+
 void SessionModel::removeView(SessionView* widget)
 {
     _views.removeAll(widget);
 
     disconnect(widget,0,this,0);
 
     if ( _emulation != 0 )
     {
@@ -247,16 +257,17 @@ void SessionModel::removeView(SessionVie
     if ( _views.count() == 0 )
     {
         close();
     }
 }
 
 void SessionModel::run()
 {
+    /*
     //check that everything is in place to run the session
     if (_program.isEmpty())
         qDebug() << "Session::run() - program to run not set.";
     if (_arguments.isEmpty())
         qDebug() << "Session::run() - no command line arguments specified.";
 
     // Upon a KPty error, there is no description on what that error was...
     // Check to see if the given program is executable.
@@ -304,17 +315,17 @@ void SessionModel::run()
                                       _addToUtmp);
 
     if (result < 0)
     {
         return;
     }
 
     _shellProcess->setWriteable(false);  // We are reachable via kwrited.
-
+*/
     emit started();
 }
 
 void SessionModel::setUserTitle( int what, const QString &caption )
 {
     //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
     bool modified = false;
 
@@ -502,17 +513,17 @@ void SessionModel::updateTerminalSize()
             minColumns = (minColumns == -1) ? view->columns() : qMin( minColumns , view->columns() );
         }
     }
 
     // backend emulation must have a _terminal of at least 1 column x 1 line in size
     if ( minLines > 0 && minColumns > 0 )
     {
         _emulation->setImageSize( minLines , minColumns );
-        _shellProcess->setWindowSize( minLines , minColumns );
+        //_shellProcess->setWindowSize( minLines , minColumns );
     }
 }
 
 void SessionModel::refresh()
 {
     // attempt to get the shell process to redraw the display
     //
     // this requires the program running in the shell
@@ -522,58 +533,60 @@ void SessionModel::refresh()
     // the window size is changed twice, first made slightly larger and then
     // resized back to its normal size so that there is actually a change
     // in the window size (some shells do nothing if the
     // new and old sizes are the same)
     //
     // if there is a more 'correct' way to do this, please
     // send an email with method or patches to konsole-devel@kde.org
 
-    const QSize existingSize = _shellProcess->windowSize();
-    _shellProcess->setWindowSize(existingSize.height(),existingSize.width()+1);
-    _shellProcess->setWindowSize(existingSize.height(),existingSize.width());
+    //const QSize existingSize = _shellProcess->windowSize();
+    //_shellProcess->setWindowSize(existingSize.height(),existingSize.width()+1);
+    //_shellProcess->setWindowSize(existingSize.height(),existingSize.width());
 }
 
 bool SessionModel::sendSignal(int signal)
 {
-    return _shellProcess->kill(signal);
+    return 0; //_shellProcess->kill(signal);
 }
 
 void SessionModel::close()
 {
     _autoClose = true;
     _wantedClose = true;
+    /*
     if (!_shellProcess->isRunning() || !sendSignal(SIGHUP))
     {
         // Forced close.
         QTimer::singleShot(1, this, SIGNAL(finished()));
-    }
+    }*/
 }
 
 void SessionModel::sendText(const QString &text) const
 {
     _emulation->sendText(text);
 }
 
 SessionModel::~SessionModel()
 {
     delete _emulation;
-    delete _shellProcess;
+    //delete _shellProcess;
     //  delete _zmodemProc;
 }
 
 void SessionModel::setProfileKey(const QString& key)
 {
     _profileKey = key;
     emit profileChanged(key);
 }
 QString SessionModel::profileKey() const { return _profileKey; }
 
 void SessionModel::done(int exitStatus)
 {
+    /*
     if (!_autoClose)
     {
         _userTitle = ("<Finished>");
         emit titleChanged();
         return;
     }
     if (!_wantedClose && (exitStatus || _shellProcess->signalled()))
     {
@@ -594,17 +607,17 @@ void SessionModel::done(int exitStatus)
         }
         else
             message.sprintf ("Session '%s' exited unexpectedly.", _nameTitle.toAscii().data());
 
         //FIXME: See comments in Session::monitorTimerDone()
         //    KNotification::event("Finished", message , QPixmap(),
         //                         QApplication::activeWindow(),
         //                         KNotification::CloseWhenWidgetActivated);
-    }
+    }*/
     emit finished();
 }
 
 Emulation* SessionModel::emulation() const
 {
     return _emulation;
 }
 
@@ -750,18 +763,18 @@ void SessionModel::setAddToUtmp(bool set
 
 void SessionModel::setFlowControlEnabled(bool enabled)
 {
     if (_flowControl == enabled)
   	return;
 
     _flowControl = enabled;
 
-    if (_shellProcess)
-	_shellProcess->setXonXoff(_flowControl);
+    //if (_shellProcess)
+    //	_shellProcess->setXonXoff(_flowControl);
 
     emit flowControlEnabledChanged(enabled);
 }
 bool SessionModel::flowControlEnabled() const
 {
     return _flowControl;
 }
 //void Session::fireZModemDetected()
@@ -872,16 +885,17 @@ void Session::zmodemFinished()
     connect( _shellProcess,SIGNAL(block_in(const char*,int)), this, SLOT(onReceiveBlock(const char*,int)) );
 
     _shellProcess->sendData("\030\030\030\030", 4); // Abort
     _shellProcess->sendData("\001\013\n", 3); // Try to get prompt back
     _zmodemProgress->transferDone();
   }
 }
 */
+
 void SessionModel::onReceiveBlock( const char* buf, int len )
 {
     _emulation->receiveData( buf, len );
     emit receivedData( QString::fromLatin1( buf, len ) );
 }
 
 QSize SessionModel::size()
 {
@@ -892,21 +906,21 @@ void SessionModel::setSize(const QSize& 
 {
     if ((size.width() <= 1) || (size.height() <= 1))
         return;
 
     emit resizeRequest(size);
 }
 int SessionModel::foregroundProcessId() const
 {
-    return _shellProcess->foregroundProcessGroup();
+    return 0; //_shellProcess->foregroundProcessGroup();
 }
 int SessionModel::processId() const
 {
-    return _shellProcess->pid();
+    return 0; //_shellProcess->pid();
 }
 
 SessionGroup::SessionGroup()
     : _masterMode(0)
 {
 }
 SessionGroup::~SessionGroup()
 {
diff --git a/libqterminal/SessionModel.h b/libqterminal/SessionModel.h
--- a/libqterminal/SessionModel.h
+++ b/libqterminal/SessionModel.h
@@ -25,16 +25,18 @@
 #ifndef SESSION_H
 #define SESSION_H
 
 // Qt
 #include <QtCore/QStringList>
 #include <QtCore>
 #include <QWidget>
 
+#include "SelfListener.h"
+
 // Konsole
 #include "History.h"
 #include "kpty.h"
 
 class KProcess;
 
 class Emulation;
 class PseudoTerminal;
@@ -472,16 +474,17 @@ private slots:
 
   //automatically detach views from sessions when view is destroyed
   void viewDestroyed(QObject* view);
 
 //  void zmodemReadStatus();
 //  void zmodemReadAndSendBlock();
 //  void zmodemRcvBlock(const char *data, int len);
 //  void zmodemFinished();
+  void sendData(const char* buf, int len);
 
 private:
 
   void updateTerminalSize();
   WId windowId() const;
 
   int            _uniqueIdentifier;
 
@@ -516,17 +519,18 @@ private:
   QString        _program;
   QStringList    _arguments;
 
   QStringList    _environment;
   int            _sessionId;
   int            _masterFd;
   int            _slaveFd;
   QString        _initialWorkingDir;
-
+  SelfListener  *_selfListener;
+  KPty         * _kpty;
   // ZModem
 //  bool           _zmodemBusy;
 //  KProcess*      _zmodemProc;
 //  ZModemDialog*  _zmodemProgress;
 
   // Color/Font Changes by ESC Sequences
 
   QColor         _modifiedBackground; // as set by: echo -en '\033]11;Color\007
diff --git a/libqterminal/k3process.cpp b/libqterminal/k3process.cpp
deleted file mode 100644
--- a/libqterminal/k3process.cpp
+++ /dev/null
@@ -1,1065 +0,0 @@
-/*
-   This file is part of the KDE libraries
-   Copyright (C) 1997 Christian Czezatke (e9025461@student.tuwien.ac.at)
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-
-#include "k3process.h"
-//#include <config.h>
-
-#include "k3processcontroller.h"
-#include "kpty.h"
-
-#ifdef __osf__
-#define _OSF_SOURCE
-#include <float.h>
-#endif
-
-#ifdef _AIX
-#define _ALL_SOURCE
-#endif
-
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-
-#ifdef HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif
-
-#include <errno.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <time.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <pwd.h>
-#include <grp.h>
-
-#include <QtCore/QMap>
-#include <QtCore/QFile>
-#include <QtCore/QSocketNotifier>
-
-
-//////////////////
-// private data //
-//////////////////
-
-class K3ProcessPrivate {
-public:
-   K3ProcessPrivate() :
-     usePty(K3Process::NoCommunication),
-     addUtmp(false), useShell(false),
-     pty(0),
-     priority(0)
-   {
-   }
-
-   K3Process::Communication usePty;
-   bool addUtmp : 1;
-   bool useShell : 1;
-
-   KPty *pty;
-
-   int priority;
-
-   QMap<QString,QString> env;
-   QString wd;
-   QByteArray shell;
-   QByteArray executable;
-};
-
-/////////////////////////////
-// public member functions //
-/////////////////////////////
-
-K3Process::K3Process( QObject* parent )
-  : QObject( parent ),
-    run_mode(NotifyOnExit),
-    runs(false),
-    pid_(0),
-    status(0),
-    keepPrivs(false),
-    innot(0),
-    outnot(0),
-    errnot(0),
-    communication(NoCommunication),
-    input_data(0),
-    input_sent(0),
-    input_total(0),
-	 d(new K3ProcessPrivate)
-{
-  K3ProcessController::ref();
-  K3ProcessController::instance()->addKProcess(this);
-
-
-  out[0] = out[1] = -1;
-  in[0] = in[1] = -1;
-  err[0] = err[1] = -1;
-}
-
-void
-K3Process::setEnvironment(const QString &name, const QString &value)
-{
-   d->env.insert(name, value);
-}
-
-void
-K3Process::setWorkingDirectory(const QString &dir)
-{
-   d->wd = dir;
-}
-
-void
-K3Process::setupEnvironment()
-{
-   QMap<QString,QString>::Iterator it;
-   for(it = d->env.begin(); it != d->env.end(); ++it)
-   {
-      setenv(QFile::encodeName(it.key()).data(),
-             QFile::encodeName(it.value()).data(), 1);
-   }
-   if (!d->wd.isEmpty())
-   {
-      if (-1 == chdir(QFile::encodeName(d->wd).constData())) {
-	 qDebug() << "Can't change directory: " << strerror(errno) << endl;
-      }
-   }
-}
-
-void
-K3Process::setRunPrivileged(bool keepPrivileges)
-{
-   keepPrivs = keepPrivileges;
-}
-
-bool
-K3Process::runPrivileged() const
-{
-   return keepPrivs;
-}
-
-bool
-K3Process::setPriority(int prio)
-{
-    if (runs) {
-        if (setpriority(PRIO_PROCESS, pid_, prio))
-            return false;
-    } else {
-        if (prio > 19 || prio < (geteuid() ? getpriority(PRIO_PROCESS, 0) : -20))
-            return false;
-    }
-    d->priority = prio;
-    return true;
-}
-
-K3Process::~K3Process()
-{
-  if (run_mode != DontCare)
-    kill(SIGKILL);
-  detach();
-
-  delete d->pty;
-  delete d;
-
-  K3ProcessController::instance()->removeKProcess(this);
-  K3ProcessController::deref();
-}
-
-void K3Process::detach()
-{
-  if (runs) {
-    K3ProcessController::instance()->addProcess(pid_);
-    runs = false;
-    pid_ = 0; // close without draining
-    commClose(); // Clean up open fd's and socket notifiers.
-  }
-}
-
-void K3Process::setBinaryExecutable(const char *filename)
-{
-   d->executable = filename;
-}
-
-K3Process &K3Process::operator<<(const QStringList& args)
-{
-  QStringList::ConstIterator it = args.begin();
-  for ( ; it != args.end() ; ++it )
-      arguments.append(QFile::encodeName(*it));
-  return *this;
-}
-
-K3Process &K3Process::operator<<(const QByteArray& arg)
-{
-  return operator<< (arg.data());
-}
-
-K3Process &K3Process::operator<<(const char* arg)
-{
-  arguments.append(arg);
-  return *this;
-}
-
-K3Process &K3Process::operator<<(const QString& arg)
-{
-  arguments.append(QFile::encodeName(arg));
-  return *this;
-}
-
-void K3Process::clearArguments()
-{
-  arguments.clear();
-}
-
-bool K3Process::start(RunMode runmode, Communication comm)
-{
-
-  if (runs) {
-    qDebug() << "Attempted to start an already running process" << endl;
-    return false;
-  }
-/*
-
-  uint n = arguments.count();
-  if (n == 0) {
-    qDebug() << "Attempted to start a process without arguments" << endl;
-    return false;
-  }
-  char **arglist;
-  QByteArray shellCmd;
-  if (d->useShell)
-  {
-      if (d->shell.isEmpty()) {
-        qDebug() << "Invalid shell specified" << endl;
-        return false;
-      }
-
-      for (uint i = 0; i < n; i++) {
-          shellCmd += arguments[i];
-          shellCmd += ' '; // CC: to separate the arguments
-      }
-
-      arglist = static_cast<char **>(malloc( 4 * sizeof(char *)));
-      arglist[0] = d->shell.data();
-      arglist[1] = (char *) "-c";
-      arglist[2] = shellCmd.data();
-      arglist[3] = 0;
-  }
-  else
-  {
-      arglist = static_cast<char **>(malloc( (n + 1) * sizeof(char *)));
-      for (uint i = 0; i < n; i++)
-         arglist[i] = arguments[i].data();
-      arglist[n] = 0;
-  }*/
-
-  run_mode = runmode;
-
-  if (!setupCommunication(comm))
-  {
-      qDebug() << "Could not setup Communication!" << endl;
-      //free(arglist);
-      return false;
-  }
-
-  // We do this in the parent because if we do it in the child process
-  // gdb gets confused when the application runs from gdb.
-#ifdef HAVE_INITGROUPS
-  struct passwd *pw = geteuid() ? 0 : getpwuid(getuid());
-#endif
-
-/*
-  int fd[2];
-
-  if (pipe(fd)) {
-      qDebug("Pipe failed!");
-      fd[0] = fd[1] = -1; // Pipe failed.. continue
-  }
-*/
-  // we don't use vfork() because
-  // - it has unclear semantics and is not standardized
-  // - we do way too much magic in the child
-  //pid_ = fork();
-  //if (pid_ == 0) {
-        // The child process
-
-        //close(fd[0]);
-        // Closing of fd[1] indicates that the execvp() succeeded!
-        //fcntl(fd[1], F_SETFD, FD_CLOEXEC);
-
-        if (!commSetupDoneC())
-          qDebug() << "Could not finish comm setup in child!" << endl;
-
-        // reset all signal handlers
-        struct sigaction act;
-        sigemptyset(&act.sa_mask);
-        act.sa_handler = SIG_DFL;
-        act.sa_flags = 0;
-        for (int sig = 1; sig < NSIG; sig++)
-          sigaction(sig, &act, 0L);
-
-        if (d->priority)
-            setpriority(PRIO_PROCESS, 0, d->priority);
-
-        if (!runPrivileged())
-        {
-           setgid(getgid());
-#ifdef HAVE_INITGROUPS
-           if (pw)
-              initgroups(pw->pw_name, pw->pw_gid);
-#endif
-	   if (geteuid() != getuid())
-	       setuid(getuid());
-	   if (geteuid() != getuid())
-	       _exit(1);
-        }
-
-        setupEnvironment();
-
-        if (runmode == DontCare || runmode == OwnGroup)
-          setsid();
-/*
-        const char *executable = arglist[0];
-        if (!d->executable.isEmpty())
-           executable = d->executable.data();
-*/
-        //execvp(executable, arglist);
-
-        //char resultByte = 1;
-        //ssize_t result = write(fd[1], &resultByte, 1);
-        //if (result<0) {
-        //    qDebug() << "Write failed with the error code " << result << endl;
-        //}
-        //_exit(-1);
-  /*} else if (pid_ == -1) {
-        // forking failed
-
-        // commAbort();
-        pid_ = 0;
-        free(arglist);
-        return false;
-  }*/
-  // the parent continues here
-  //free(arglist);
-
-  if (!commSetupDoneP())
-    qDebug() << "Could not finish comm setup in parent!" << endl;
-
-  // Check whether client could be started.
-  //close(fd[1]);
-
-  /*
-  for(;;)
-  {
-     char resultByte;
-     int n = ::read(fd[0], &resultByte, 1);
-     if (n == 1)
-     {
-         // exec() failed
-         close(fd[0]);
-         waitpid(pid_, 0, 0);
-         pid_ = 0;
-         commClose();
-         return false;
-     }
-     if (n == -1)
-     {
-        if (errno == EINTR)
-           continue; // Ignore
-     }
-     break; // success
-  }
-  close(fd[0]);
-*/
-  runs = true;
-  return true;
-  switch (runmode)
-  {
-  case Block:
-    for (;;)
-    {
-      commClose(); // drain only, unless obsolete reimplementation
-      if (!runs)
-      {
-        // commClose detected data on the process exit notifification pipe
-        K3ProcessController::instance()->unscheduleCheck();
-        if (waitpid(pid_, &status, WNOHANG) != 0) // error finishes, too
-        {
-          commClose(); // this time for real (runs is false)
-          K3ProcessController::instance()->rescheduleCheck();
-          break;
-        }
-        runs = true; // for next commClose() iteration
-      }
-      else
-      {
-        // commClose is an obsolete reimplementation and waited until
-        // all output channels were closed (or it was interrupted).
-        // there is a chance that it never gets here ...
-        waitpid(pid_, &status, 0);
-        runs = false;
-        break;
-      }
-    }
-    // why do we do this? i think this signal should be emitted _only_
-    // after the process has successfully run _asynchronously_ --ossi
-    emit processExited(this);
-    break;
-  default: // NotifyOnExit & OwnGroup
-    input_data = 0; // Discard any data for stdin that might still be there
-    break;
-  }
-
-  return true;
-}
-
-
-
-bool K3Process::kill(int signo)
-{
-  if (runs && pid_ > 0 && !::kill(run_mode == OwnGroup ? -pid_ : pid_, signo))
-    return true;
-  return false;
-}
-
-
-
-bool K3Process::isRunning() const
-{
-  return runs;
-}
-
-
-
-pid_t K3Process::pid() const
-{
-  return pid_;
-}
-
-#ifndef timersub
-# define timersub(a, b, result) \
-  do { \
-    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \
-    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
-    if ((result)->tv_usec < 0) { \
-      --(result)->tv_sec; \
-      (result)->tv_usec += 1000000; \
-    } \
-  } while (0)
-#endif
-
-bool K3Process::wait(int timeout)
-{
-  if (!runs)
-    return true;
-
-#ifndef __linux__
-  struct timeval etv;
-#endif
-  struct timeval tv, *tvp;
-  if (timeout < 0)
-    tvp = 0;
-  else
-  {
-#ifndef __linux__
-    gettimeofday(&etv, 0);
-    etv.tv_sec += timeout;
-#else
-    tv.tv_sec = timeout;
-    tv.tv_usec = 0;
-#endif
-    tvp = &tv;
-  }
-
-  int fd = K3ProcessController::instance()->notifierFd();
-  for(;;)
-  {
-    fd_set fds;
-    FD_ZERO( &fds );
-    FD_SET( fd, &fds );
-
-#ifndef __linux__
-    if (tvp)
-    {
-      gettimeofday(&tv, 0);
-      timersub(&etv, &tv, &tv);
-      if (tv.tv_sec < 0)
-        tv.tv_sec = tv.tv_usec = 0;
-    }
-#endif
-
-    switch( select( fd+1, &fds, 0, 0, tvp ) )
-    {
-    case -1:
-      if( errno == EINTR )
-        break;
-      // fall through; should happen if tvp->tv_sec < 0
-    case 0:
-      K3ProcessController::instance()->rescheduleCheck();
-      return false;
-    default:
-      K3ProcessController::instance()->unscheduleCheck();
-      if (waitpid(pid_, &status, WNOHANG) != 0) // error finishes, too
-      {
-        processHasExited(status);
-        K3ProcessController::instance()->rescheduleCheck();
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-
-
-bool K3Process::normalExit() const
-{
-  return (pid_ != 0) && !runs && WIFEXITED(status);
-}
-
-
-bool K3Process::signalled() const
-{
-  return (pid_ != 0) && !runs && WIFSIGNALED(status);
-}
-
-
-bool K3Process::coreDumped() const
-{
-#ifdef WCOREDUMP
-  return signalled() && WCOREDUMP(status);
-#else
-  return false;
-#endif
-}
-
-
-int K3Process::exitStatus() const
-{
-  return WEXITSTATUS(status);
-}
-
-
-int K3Process::exitSignal() const
-{
-  return WTERMSIG(status);
-}
-
-
-bool K3Process::writeStdin(const char *buffer, int buflen)
-{
-  // if there is still data pending, writing new data
-  // to stdout is not allowed (since it could also confuse
-  // kprocess ...)
-  if (input_data != 0)
-    return false;
-
-  if (communication & Stdin) {
-    input_data = buffer;
-    input_sent = 0;
-    input_total = buflen;
-    innot->setEnabled(true);
-    if (input_total)
-       slotSendData(0);
-    return true;
-  } else
-    return false;
-}
-
-void K3Process::suspend()
-{
-  if (outnot)
-     outnot->setEnabled(false);
-}
-
-void K3Process::resume()
-{
-  if (outnot)
-     outnot->setEnabled(true);
-}
-
-bool K3Process::closeStdin()
-{
-  if (communication & Stdin) {
-    communication = communication & ~Stdin;
-    delete innot;
-    innot = 0;
-    if (!(d->usePty & Stdin))
-      close(in[1]);
-    in[1] = -1;
-    return true;
-  } else
-    return false;
-}
-
-bool K3Process::closeStdout()
-{
-  if (communication & Stdout) {
-    communication = communication & ~Stdout;
-    delete outnot;
-    outnot = 0;
-    if (!(d->usePty & Stdout))
-      close(out[0]);
-    out[0] = -1;
-    return true;
-  } else
-    return false;
-}
-
-bool K3Process::closeStderr()
-{
-  if (communication & Stderr) {
-    communication = communication & ~Stderr;
-    delete errnot;
-    errnot = 0;
-    if (!(d->usePty & Stderr))
-      close(err[0]);
-    err[0] = -1;
-    return true;
-  } else
-    return false;
-}
-
-bool K3Process::closePty()
-{
-  if (d->pty && d->pty->masterFd() >= 0) {
-    if (d->addUtmp)
-      d->pty->logout();
-    d->pty->close();
-    return true;
-  } else
-    return false;
-}
-
-void K3Process::closeAll()
-{
-  closeStdin();
-  closeStdout();
-  closeStderr();
-  closePty();
-}
-
-/////////////////////////////
-// protected slots         //
-/////////////////////////////
-
-
-
-void K3Process::slotChildOutput(int fdno)
-{
-  if (!childOutput(fdno))
-     closeStdout();
-}
-
-
-void K3Process::slotChildError(int fdno)
-{
-  if (!childError(fdno))
-     closeStderr();
-}
-
-
-void K3Process::slotSendData(int)
-{
-  if (input_sent == input_total) {
-    innot->setEnabled(false);
-    input_data = 0;
-    emit wroteStdin(this);
-  } else {
-    int result = ::write(in[1], input_data+input_sent, input_total-input_sent);
-    if (result >= 0)
-    {
-       input_sent += result;
-    }
-    else if ((errno != EAGAIN) && (errno != EINTR))
-    {
-       qDebug() << "Error writing to stdin of child process" << endl;
-       closeStdin();
-    }
-  }
-}
-
-void K3Process::setUseShell(bool useShell, const char *shell)
-{
-  d->useShell = useShell;
-  if (shell && *shell)
-    d->shell = shell;
-  else
-// #ifdef NON_FREE // ... as they ship non-POSIX /bin/sh
-#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__GNU__) && !defined(__DragonFly__)
-  // Solaris POSIX ...
-  if (!access( "/usr/xpg4/bin/sh", X_OK ))
-    d->shell = "/usr/xpg4/bin/sh";
-  else
-  // ... which links here anyway
-  if (!access( "/bin/ksh", X_OK ))
-    d->shell = "/bin/ksh";
-  else
-  // dunno, maybe superfluous?
-  if (!access( "/usr/ucb/sh", X_OK ))
-    d->shell = "/usr/ucb/sh";
-  else
-#endif
-    d->shell = "/bin/sh";
-}
-
-void K3Process::setUsePty(Communication usePty, bool addUtmp, KPty *kpty)
-{
-  d->usePty = usePty;
-  d->addUtmp = addUtmp;
-  if (usePty) {
-    if (!d->pty) {
-          d->pty = kpty;
-    }
-  } else {
-    delete d->pty;
-    d->pty = 0;
-  }
-}
-
-KPty *K3Process::pty() const
-{
-  return d->pty;
-}
-
-QString K3Process::quote(const QString &arg)
-{
-    QChar q('\'');
-    return QString(arg).replace(q, "'\\''").prepend(q).append(q);
-}
-
-
-//////////////////////////////
-// private member functions //
-//////////////////////////////
-
-
-void K3Process::processHasExited(int state)
-{
-    // only successfully run NotifyOnExit processes ever get here
-
-    status = state;
-    runs = false; // do this before commClose, so it knows we're dead
-
-    commClose(); // cleanup communication sockets
-
-    if (run_mode != DontCare)
-      emit processExited(this);
-}
-
-
-
-int K3Process::childOutput(int fdno)
-{
-  if (communication & NoRead) {
-     int len = -1;
-     emit receivedStdout(fdno, len);
-     errno = 0; // Make sure errno doesn't read "EAGAIN"
-     return len;
-  }
-  else
-  {
-     char buffer[1025];
-     int len;
-
-     len = ::read(fdno, buffer, 1024);
-
-     if (len > 0) {
-        buffer[len] = 0; // Just in case.
-        emit receivedStdout(this, buffer, len);
-     }
-     return len;
-  }
-}
-
-int K3Process::childError(int fdno)
-{
-  char buffer[1025];
-  int len;
-
-  len = ::read(fdno, buffer, 1024);
-
-  if (len > 0) {
-     buffer[len] = 0; // Just in case.
-     emit receivedStderr(this, buffer, len);
-  }
-  return len;
-}
-
-
-int K3Process::setupCommunication(Communication comm)
-{
-  // PTY stuff //
-  if (d->usePty)
-  {
-    // cannot communicate on both stderr and stdout if they are both on the pty
-    if (!(~(comm & d->usePty) & (Stdout | Stderr))) {
-       qWarning() << "Invalid usePty/communication combination (" << d->usePty << "/" << comm << ")" << endl;
-       return 0;
-    }
-    if (!d->pty->open())
-       return 0;
-
-    int rcomm = comm & d->usePty;
-    int mfd = d->pty->masterFd();
-    if (rcomm & Stdin)
-      in[1] = mfd;
-    if (rcomm & Stdout)
-      out[0] = mfd;
-    if (rcomm & Stderr)
-      err[0] = mfd;
-  }
-
-  communication = comm;
-
-  comm = comm & ~d->usePty;
-  if (comm & Stdin) {
-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, in))
-      goto fail0;
-    fcntl(in[0], F_SETFD, FD_CLOEXEC);
-    fcntl(in[1], F_SETFD, FD_CLOEXEC);
-  }
-  if (comm & Stdout) {
-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, out))
-      goto fail1;
-    fcntl(out[0], F_SETFD, FD_CLOEXEC);
-    fcntl(out[1], F_SETFD, FD_CLOEXEC);
-  }
-  if (comm & Stderr) {
-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, err))
-      goto fail2;
-    fcntl(err[0], F_SETFD, FD_CLOEXEC);
-    fcntl(err[1], F_SETFD, FD_CLOEXEC);
-  }
-  return 1; // Ok
- fail2:
-  if (comm & Stdout)
-  {
-    close(out[0]);
-    close(out[1]);
-    out[0] = out[1] = -1;
-  }
- fail1:
-  if (comm & Stdin)
-  {
-    close(in[0]);
-    close(in[1]);
-    in[0] = in[1] = -1;
-  }
- fail0:
-  communication = NoCommunication;
-  return 0; // Error
-}
-
-
-
-int K3Process::commSetupDoneP()
-{
-  int rcomm = communication & ~d->usePty;
-  if (rcomm & Stdin)
-    close(in[0]);
-  if (rcomm & Stdout)
-    close(out[1]);
-  if (rcomm & Stderr)
-    close(err[1]);
-  in[0] = out[1] = err[1] = -1;
-
-  // Don't create socket notifiers if no interactive comm is to be expected
-  if (run_mode != NotifyOnExit && run_mode != OwnGroup)
-    return 1;
-
-  if (communication & Stdin) {
-    fcntl(in[1], F_SETFL, O_NONBLOCK | fcntl(in[1], F_GETFL));
-    innot =  new QSocketNotifier(in[1], QSocketNotifier::Write, this);
-    Q_CHECK_PTR(innot);
-    innot->setEnabled(false); // will be enabled when data has to be sent
-    QObject::connect(innot, SIGNAL(activated(int)),
-                     this, SLOT(slotSendData(int)));
-  }
-
-  if (communication & Stdout) {
-    outnot = new QSocketNotifier(out[0], QSocketNotifier::Read, this);
-    Q_CHECK_PTR(outnot);
-    QObject::connect(outnot, SIGNAL(activated(int)),
-                     this, SLOT(slotChildOutput(int)));
-    if (communication & NoRead)
-        suspend();
-  }
-
-  if (communication & Stderr) {
-    errnot = new QSocketNotifier(err[0], QSocketNotifier::Read, this );
-    Q_CHECK_PTR(errnot);
-    QObject::connect(errnot, SIGNAL(activated(int)),
-                     this, SLOT(slotChildError(int)));
-  }
-
-  return 1;
-}
-
-
-
-int K3Process::commSetupDoneC()
-{
-  int ok = 1;
-
-  if (d->usePty & Stdin) {
-    if (dup2(d->pty->slaveFd(), STDIN_FILENO) < 0) ok = 0;
-  } else if (communication & Stdin) {
-    if (dup2(in[0], STDIN_FILENO) < 0) ok = 0;
-  } else {
-    int null_fd = open( "/dev/null", O_RDONLY );
-    if (dup2( null_fd, STDIN_FILENO ) < 0) ok = 0;
-    close( null_fd );
-  }
-  struct linger so;
-  memset(&so, 0, sizeof(so));
-  if (d->usePty & Stdout) {
-    if (dup2(d->pty->slaveFd(), STDOUT_FILENO) < 0) ok = 0;
-  } else if (communication & Stdout) {
-    if (dup2(out[1], STDOUT_FILENO) < 0 ||
-        setsockopt(out[1], SOL_SOCKET, SO_LINGER, (char *)&so, sizeof(so)))
-      ok = 0;
-    if (communication & MergedStderr) {
-      if (dup2(out[1], STDERR_FILENO) < 0)
-        ok = 0;
-    }
-  }
-  if (d->usePty & Stderr) {
-    if (dup2(d->pty->slaveFd(), STDERR_FILENO) < 0) ok = 0;
-  } else if (communication & Stderr) {
-    if (dup2(err[1], STDERR_FILENO) < 0 ||
-        setsockopt(err[1], SOL_SOCKET, SO_LINGER, (char *)&so, sizeof(so)))
-      ok = 0;
-  }
-
-  // don't even think about closing all open fds here or anywhere else
-
-  // PTY stuff //
-  if (d->usePty) {
-    d->pty->setCTty();
-    if (d->addUtmp)
-      d->pty->login(getenv("USER"), getenv("DISPLAY"));
-  }
-
-  return ok;
-}
-
-
-
-void K3Process::commClose()
-{
-  closeStdin();
-
-  if (pid_) { // detached, failed, and killed processes have no output. basta. :)
-    // If both channels are being read we need to make sure that one socket
-    // buffer doesn't fill up whilst we are waiting for data on the other
-    // (causing a deadlock). Hence we need to use select.
-
-    int notfd = K3ProcessController::instance()->notifierFd();
-
-    while ((communication & (Stdout | Stderr)) || runs) {
-      fd_set rfds;
-      FD_ZERO(&rfds);
-      struct timeval timeout, *p_timeout;
-
-      int max_fd = 0;
-      if (communication & Stdout) {
-        FD_SET(out[0], &rfds);
-        max_fd = out[0];
-      }
-      if (communication & Stderr) {
-        FD_SET(err[0], &rfds);
-        if (err[0] > max_fd)
-          max_fd = err[0];
-      }
-      if (runs) {
-        FD_SET(notfd, &rfds);
-        if (notfd > max_fd)
-          max_fd = notfd;
-        // If the process is still running we block until we
-        // receive data or the process exits.
-        p_timeout = 0; // no timeout
-      } else {
-        // If the process has already exited, we only check
-        // the available data, we don't wait for more.
-        timeout.tv_sec = timeout.tv_usec = 0; // timeout immediately
-        p_timeout = &timeout;
-      }
-
-      int fds_ready = select(max_fd+1, &rfds, 0, 0, p_timeout);
-      if (fds_ready < 0) {
-        if (errno == EINTR)
-          continue;
-        break;
-      } else if (!fds_ready)
-        break;
-
-      if ((communication & Stdout) && FD_ISSET(out[0], &rfds))
-        slotChildOutput(out[0]);
-
-      if ((communication & Stderr) && FD_ISSET(err[0], &rfds))
-        slotChildError(err[0]);
-
-      if (runs && FD_ISSET(notfd, &rfds)) {
-        runs = false; // hack: signal potential exit
-        return; // don't close anything, we will be called again
-      }
-    }
-  }
-
-  closeStdout();
-  closeStderr();
-
-  closePty();
-}
-
-
-
-///////////////////////////
-// CC: Class K3ShellProcess
-///////////////////////////
-
-K3ShellProcess::K3ShellProcess(const char *shellname):
-  K3Process(), d(0)
-{
-  setUseShell( true, shellname ? shellname : getenv("SHELL") );
-}
-
-K3ShellProcess::~K3ShellProcess() {
-}
-
-QString K3ShellProcess::quote(const QString &arg)
-{
-    return K3Process::quote(arg);
-}
-
-bool K3ShellProcess::start(RunMode runmode, Communication comm)
-{
-  return K3Process::start(runmode, comm);
-}
-
diff --git a/libqterminal/k3process.h b/libqterminal/k3process.h
deleted file mode 100644
--- a/libqterminal/k3process.h
+++ /dev/null
@@ -1,890 +0,0 @@
-/* This file is part of the KDE libraries
-    Copyright (C) 1997 Christian Czezakte (e9025461@student.tuwien.ac.at)
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef K3PROCESS_H
-#define K3PROCESS_H
-
-#include <QtCore/QObject>
-
-#include <sys/types.h> // for pid_t
-#include <sys/wait.h>
-#include <signal.h>
-#include <unistd.h>
-
-class QSocketNotifier;
-class K3ProcessPrivate;
-class KPty;
-
-/**
- * @obsolete Use KProcess and KPtyProcess instead.
- *
- * Child process invocation, monitoring and control.
- * This class works only in the application's main thread.
- *
- * <b>General usage and features:</b>\n
- *
- * This class allows a KDE application to start child processes without having
- * to worry about UN*X signal handling issues and zombie process reaping.
- *
- * @see K3ProcIO
- *
- * Basically, this class distinguishes three different ways of running
- * child processes:
- *
- * @li  DontCare -- The child process is invoked and both the child
- * process and the parent process continue concurrently.
- *
- * The process is started in an own session (see setsid(2)).
- *
- * @li  NotifyOnExit -- The child process is invoked and both the
- * child and the parent process run concurrently.
- *
- * When the child process exits, the K3Process instance
- * corresponding to it emits the Qt signal processExited().
- * Since this signal is @em not emitted from within a UN*X
- * signal handler, arbitrary function calls can be made.
- *
- * Be aware: When the K3Process object gets destructed, the child
- * process will be killed if it is still running!
- * This means in particular, that it usually makes no sense to use
- * a K3Process on the stack with NotifyOnExit.
- *
- * @li  OwnGroup -- like NotifyOnExit, but the child process is started
- * in an own process group (and an own session, FWIW). The behavior of
- * kill() changes to killing the whole process group - this makes
- * this mode useful for implementing primitive job management. It can be
- * used to work around broken wrapper scripts that don't propagate signals
- * to the "real" program. However, use this with care, as you disturb the
- * shell's job management if your program is started from the command line.
- *
- * @li  Block -- The child process starts and the parent process
- * is suspended until the child process exits. (@em Really not recommended
- * for programs with a GUI.)
- * In this mode the parent can read the child's output, but can't send it any
- * input.
- *
- * K3Process also provides several functions for determining the exit status
- * and the pid of the child process it represents.
- *
- * Furthermore it is possible to supply command-line arguments to the process
- * in a clean fashion (no null-terminated stringlists and such...)
- *
- * A small usage example:
- * \code
- *   K3Process *proc = new K3Process;
- *
- *   *proc << "my_executable";
- *   *proc << "These" << "are" << "the" << "command" << "line" << "args";
- *   QApplication::connect(proc, SIGNAL(processExited(K3Process *)),
- *                         pointer_to_my_object, SLOT(my_objects_slot(K3Process *)));
- *   proc->start();
- * \endcode
- *
- * This will start "my_executable" with the commandline arguments "These"...
- *
- * When the child process exits, the slot will be invoked.
- *
- * <b>Communication with the child process:</b>\n
- *
- * K3Process supports communication with the child process through
- * stdin/stdout/stderr.
- *
- * The following functions are provided for getting data from the child
- * process or sending data to the child's stdin (For more information,
- * have a look at the documentation of each function):
- *
- * @li writeStdin()
- *  -- Transmit data to the child process' stdin. When all data was sent, the
- * signal wroteStdin() is emitted.
- *
- * @li When data arrives at stdout or stderr, the signal receivedStdout()
- * resp. receivedStderr() is emitted.
- *
- * @li You can shut down individual communication channels with
- * closeStdin(), closeStdout(), and closeStderr(), resp.
- *
- * @author Christian Czezatke e9025461@student.tuwien.ac.at
- *
- **/
-class K3Process : public QObject
-{
-  Q_OBJECT
-
-public:
-
-  /**
-   * Modes in which the communication channels can be opened.
-   *
-   * If communication for more than one channel is required,
-   * the values should be or'ed together, for example to get
-   * communication with stdout as well as with stdin, you would
-   * specify @p Stdin | @p Stdout
-   *
-   */
-  enum CommunicationFlag {
-       NoCommunication = 0, /**< No communication with the process. */
-       Stdin = 1, /**< Connect to write to the process with writeStdin(). */
-       Stdout = 2, /**< Connect to read from the process' output. */
-       Stderr = 4, /**< Connect to read from the process' stderr. */
-       AllOutput = 6, /**< Connects to all output channels. */
-       All = 7, /**< Connects to all channels. */
-       NoRead = 8, /**< If specified with Stdout, no data is actually read from stdout,
-                    * only the signal receivedStdout(int fd, int &len) is emitted. */
-       CTtyOnly = NoRead, /**< Tells setUsePty() to create a PTY for the process
-                           * and make it the process' controlling TTY, but does not
-                           * redirect any I/O channel to the PTY. */
-       MergedStderr = 16  /**< If specified with Stdout, the process' stderr will be
-                           * redirected onto the same file handle as its stdout, i.e.,
-                           * all error output will be signalled with receivedStdout().
-                           * Don't specify Stderr if you specify MergedStderr. */
-  };
-
-  Q_DECLARE_FLAGS(Communication, CommunicationFlag)
-
-  /**
-   * Run-modes for a child process.
-   */
-  enum RunMode {
-      /**
-       * The application does not receive notifications from the subprocess when
-       * it is finished or aborted.
-       */
-       DontCare,
-       /**
-        * The application is notified when the subprocess dies.
-        */
-       NotifyOnExit,
-       /**
-        * The application is suspended until the started process is finished.
-        */
-       Block,
-       /**
-        * Same as NotifyOnExit, but the process is run in an own session,
-        * just like with DontCare.
-        */
-       OwnGroup
-  };
-
-  /**
-   * Constructor
-   */
-  explicit K3Process( QObject* parent=0L );
-
-  /**
-   *Destructor:
-   *
-   *  If the process is running when the destructor for this class
-   *  is called, the child process is killed with a SIGKILL, but
-   *  only if the run mode is not of type @p DontCare.
-   *  Processes started as @p DontCare keep running anyway.
-  */
-  virtual ~K3Process();
-
-  /**
-   * Sets the executable and the command line argument list for this process.
-   *
-   * For example, doing an "ls -l /usr/local/bin" can be achieved by:
-   *  \code
-   *  K3Process p;
-   *  ...
-   *  p << "ls" << "-l" << "/usr/local/bin"
-   *  \endcode
-   *
-   * @param arg the argument to add
-   * @return a reference to this K3Process
-   **/
-  K3Process &operator<<(const QString& arg);
-  /**
-   * Similar to previous method, takes a char *, supposed to be in locale 8 bit already.
-   */
-  K3Process &operator<<(const char * arg);
-  /**
-   * Similar to previous method, takes a QByteArray, supposed to be in locale 8 bit already.
-   * @param arg the argument to add
-   * @return a reference to this K3Process
-   */
-  K3Process &operator<<(const QByteArray & arg);
-
-  /**
-   * Sets the executable and the command line argument list for this process,
-   * in a single method call, or add a list of arguments.
-   * @param args the arguments to add
-   * @return a reference to this K3Process
-   **/
-  K3Process &operator<<(const QStringList& args);
-
-  /**
-   * Clear a command line argument list that has been set by using
-   * operator<<.
-  */
-  void clearArguments();
-
-  /**
-   *  Starts the process.
-   *  For a detailed description of the
-   *  various run modes and communication semantics, have a look at the
-   *  general description of the K3Process class. Note that if you use
-   * setUsePty( Stdout | Stderr, \<bool\> ), you cannot use Stdout | Stderr
-   *  here - instead, use Stdout only to receive the mixed output.
-   *
-   *  The following problems could cause this function to
-   *    return false:
-   *
-   *  @li The process is already running.
-   *  @li The command line argument list is empty.
-   *  @li The the @p comm parameter is incompatible with the selected pty usage.
-   *  @li The starting of the process failed (could not fork).
-   *  @li The executable was not found.
-   *
-   *  @param runmode The Run-mode for the process.
-   *  @param comm  Specifies which communication channels should be
-   *  established to the child process (stdin/stdout/stderr). By default,
-   *  no communication takes place and the respective communication
-   *  signals will never get emitted.
-   *
-   *  @return true on success, false on error
-   *  (see above for error conditions)
-   **/
-  virtual bool start(RunMode  runmode = NotifyOnExit,
-                     Communication comm = NoCommunication);
-
-  /**
-   * Stop the process (by sending it a signal).
-   *
-   * @param signo The signal to send. The default is SIGTERM.
-   * @return true if the signal was delivered successfully.
-  */
-  virtual bool kill(int signo = SIGTERM);
-
-  /**
-   * Checks whether the process is running.
-   * @return true if the process is (still) considered to be running
-  */
-  bool isRunning() const;
-
-  /** Returns the process id of the process.
-   *
-   * If it is called after
-   * the process has exited, it returns the process id of the last
-   *  child process that was created by this instance of K3Process.
-   *
-   *  Calling it before any child process has been started by this
-   *  K3Process instance causes pid() to return 0.
-   * @return the pid of the process or 0 if no process has been started yet.
-   **/
-  pid_t pid() const;
-
-  /**
-   * Suspend processing of data from stdout of the child process.
-   */
-  void suspend();
-
-  /**
-   * Resume processing of data from stdout of the child process.
-   */
-  void resume();
-
-  /**
-   * Suspend execution of the current thread until the child process dies
-   * or the timeout hits. This function is not recommended for programs
-   * with a GUI.
-   * @param timeout timeout in seconds. -1 means wait indefinitely.
-   * @return true if the process exited, false if the timeout hit.
-   */
-  bool wait(int timeout = -1);
-
-  /**
-   * Checks whether the process exited cleanly.
-   *
-   * @return true if the process has already finished and has exited
-   *  "voluntarily", ie: it has not been killed by a signal.
-   */
-  bool normalExit() const;
-
-  /**
-   * Checks whether the process was killed by a signal.
-   *
-   * @return true if the process has already finished and has not exited
-   * "voluntarily", ie: it has been killed by a signal.
-   */
-  bool signalled() const;
-
-  /**
-   * Checks whether a killed process dumped core.
-   *
-   * @return true if signalled() returns true and the process
-   * dumped core. Note that on systems that don't define the
-   * WCOREDUMP macro, the return value is always false.
-   */
-  bool coreDumped() const;
-
-  /**
-   * Returns the exit status of the process.
-   *
-   * @return the exit status of the process. Note that this value
-   * is not valid if normalExit() returns false.
-   */
-  int exitStatus() const;
-
-  /**
-   * Returns the signal the process was killed by.
-   *
-   * @return the signal number that caused the process to exit.
-   * Note that this value is not valid if signalled() returns false.
-   */
-  int exitSignal() const;
-
-  /**
-   *	 Transmit data to the child process' stdin.
-   *
-   * This function may return false in the following cases:
-   *
-   *     @li The process is not currently running.
-   * This implies that you cannot use this function in Block mode.
-   *
-   *     @li Communication to stdin has not been requested in the start() call.
-   *
-   *     @li Transmission of data to the child process by a previous call to
-   * writeStdin() is still in progress.
-   *
-   * Please note that the data is sent to the client asynchronously,
-   * so when this function returns, the data might not have been
-   * processed by the child process.
-   * That means that you must not free @p buffer or call writeStdin()
-   * again until either a wroteStdin() signal indicates that the
-   * data has been sent or a processExited() signal shows that
-   * the child process is no longer alive.
-   *
-   * If all the data has been sent to the client, the signal
-   * wroteStdin() will be emitted.
-   *
-   * This function does not work when the process is start()ed in Block mode.
-   *
-   * @param buffer the buffer to write
-   * @param buflen the length of the buffer
-   * @return false if an error has occurred
-   **/
-  bool writeStdin(const char *buffer, int buflen);
-
-  /**
-   * Shuts down the Stdin communication link. If no pty is used, this
-   * causes "EOF" to be indicated on the child's stdin file descriptor.
-   *
-   * @return false if no Stdin communication link exists (any more).
-   */
-  bool closeStdin();
-
-  /**
-   * Shuts down the Stdout communication link. If no pty is used, any further
-   * attempts by the child to write to its stdout file descriptor will cause
-   * it to receive a SIGPIPE.
-   *
-   * @return false if no Stdout communication link exists (any more).
-   */
-  bool closeStdout();
-
-  /**
-   * Shuts down the Stderr communication link. If no pty is used, any further
-   * attempts by the child to write to its stderr file descriptor will cause
-   * it to receive a SIGPIPE.
-   *
-   * @return false if no Stderr communication link exists (any more).
-   */
-  bool closeStderr();
-
-  /**
-   * Deletes the optional utmp entry and closes the pty.
-   *
-   * Make sure to shut down any communication links that are using the pty
-   * before calling this function.
-   *
-   * @return false if the pty is not open (any more).
-   */
-  bool closePty();
-
-  /**
-   * @brief Close stdin, stdout, stderr and the pty
-   *
-   * This is the same that calling all close* functions in a row:
-   * @see closeStdin, @see closeStdout, @see closeStderr and @see closePty
-   */
-  void closeAll();
-
-  /**
-   * Lets you see what your arguments are for debugging.
-   * @return the list of arguments
-   */
-  const QList<QByteArray> &args() /* const */ { return arguments; }
-
-  /**
-   * Controls whether the started process should drop any
-   * setuid/setgid privileges or whether it should keep them.
-   * Note that this function is mostly a dummy, as the KDE libraries
-   * currently refuse to run with setuid/setgid privileges.
-   *
-   * The default is false: drop privileges
-   * @param keepPrivileges true to keep the privileges
-   */
-  void setRunPrivileged(bool keepPrivileges);
-
-  /**
-   * Returns whether the started process will drop any
-   * setuid/setgid privileges or whether it will keep them.
-   * @return true if the process runs privileged
-   */
-  bool runPrivileged() const;
-
-  /**
-   * Adds the variable @p name to the process' environment.
-   * This function must be called before starting the process.
-   * @param name the name of the environment variable
-   * @param value the new value for the environment variable
-   */
-  void setEnvironment(const QString &name, const QString &value);
-
-  /**
-   * Changes the current working directory (CWD) of the process
-   * to be started.
-   * This function must be called before starting the process.
-   * @param dir the new directory
-   */
-  void setWorkingDirectory(const QString &dir);
-
-  /**
-   * Specify whether to start the command via a shell or directly.
-   * The default is to start the command directly.
-   * If @p useShell is true @p shell will be used as shell, or
-   * if shell is empty, /bin/sh will be used.
-   *
-   * When using a shell, the caller should make sure that all filenames etc.
-   * are properly quoted when passed as argument.
-   * @see quote()
-   * @param useShell true if the command should be started via a shell
-   * @param shell the path to the shell that will execute the process, or
-   *              0 to use /bin/sh. Use getenv("SHELL") to use the user's
-   *              default shell, but note that doing so is usually a bad idea
-   *              for shell compatibility reasons.
-   */
-  void setUseShell(bool useShell, const char *shell = 0);
-
-  /**
-   * This function can be used to quote an argument string such that
-   * the shell processes it properly. This is e. g. necessary for
-   * user-provided file names which may contain spaces or quotes.
-   * It also prevents expansion of wild cards and environment variables.
-   * @param arg the argument to quote
-   * @return the quoted argument
-   */
-  static QString quote(const QString &arg);
-
-  /**
-   * Detaches K3Process from child process. All communication is closed.
-   * No exit notification is emitted any more for the child process.
-   * Deleting the K3Process will no longer kill the child process.
-   * Note that the current process remains the parent process of the
-   * child process.
-   */
-  void detach();
-
-  /**
-   * Specify whether to create a pty (pseudo-terminal) for running the
-   * command.
-   * This function should be called before starting the process.
-   *
-   * @param comm for which stdio handles to use a pty. Note that it is not
-   *  allowed to specify Stdout and Stderr at the same time both here and to
-   * start (there is only one pty, so they cannot be distinguished).
-   * @param addUtmp true if a utmp entry should be created for the pty
-   */
-  void setUsePty(Communication comm, bool addUtmp, KPty *kpty = 0);
-
-  /**
-   * Obtains the pty object used by this process. The return value is
-   * valid only after setUsePty() was used with a non-zero argument.
-   * The pty is open only while the process is running.
-   * @return a pointer to the pty object
-   */
-  KPty *pty() const;
-
-  /**
-   * More or less intuitive constants for use with setPriority().
-   */
-  enum { PrioLowest = 20, PrioLow = 10, PrioLower = 5, PrioNormal = 0,
-    PrioHigher = -5, PrioHigh = -10, PrioHighest = -19 };
-
-  /**
-   * Sets the scheduling priority of the process.
-   * @param prio the new priority in the range -20 (high) to 19 (low).
-   * @return false on error; see setpriority(2) for possible reasons.
-   */
-  bool setPriority(int prio);
-
-Q_SIGNALS:
-  /**
-   * Emitted after the process has terminated when
-   * the process was run in the @p NotifyOnExit  (==default option to
-   * start() ) or the Block mode.
-   * @param proc a pointer to the process that has exited
-   **/
-  void processExited(K3Process *proc);
-
-
-  /**
-   * Emitted, when output from the child process has
-   * been received on stdout.
-   *
-   * To actually get this signal, the Stdout communication link
-   * has to be turned on in start().
-   *
-   * @param proc a pointer to the process that has received the output
-   * @param buffer The data received.
-   * @param buflen The number of bytes that are available.
-   *
-   * You should copy the information contained in @p buffer to your private
-   * data structures before returning from the slot.
-   * Example:
-   * \code
-   *     QString myBuf = QLatin1String(buffer, buflen);
-   * \endcode
-   **/
-  void receivedStdout(K3Process *proc, char *buffer, int buflen);
-
-  /**
-   * Emitted when output from the child process has
-   * been received on stdout.
-   *
-   * To actually get this signal, the Stdout communication link
-   * has to be turned on in start() and the
-   * NoRead flag must have been passed.
-   *
-   * You will need to explicitly call resume() after your call to start()
-   * to begin processing data from the child process' stdout.  This is
-   * to ensure that this signal is not emitted when no one is connected
-   * to it, otherwise this signal will not be emitted.
-   *
-   * The data still has to be read from file descriptor @p fd.
-   * @param fd the file descriptor that provides the data
-   * @param len the number of bytes that have been read from @p fd must
-   *  be written here
-   **/
-  void receivedStdout(int fd, int &len); // KDE4: change, broken API
-
-
-  /**
-   * Emitted, when output from the child process has
-   * been received on stderr.
-   *
-   * To actually get this signal, the Stderr communication link
-   * has to be turned on in start().
-   *
-   * You should copy the information contained in @p buffer to your private
-   * data structures before returning from the slot.
-   *
-   * @param proc a pointer to the process that has received the data
-   * @param buffer The data received.
-   * @param buflen The number of bytes that are available.
-   **/
-  void receivedStderr(K3Process *proc, char *buffer, int buflen);
-
-  /**
-   * Emitted after all the data that has been
-   * specified by a prior call to writeStdin() has actually been
-   * written to the child process.
-   * @param proc a pointer to the process
-   **/
-  void wroteStdin(K3Process *proc);
-
-
-protected Q_SLOTS:
-
- /**
-  * This slot gets activated when data from the child's stdout arrives.
-  * It usually calls childOutput().
-  * @param fdno the file descriptor for the output
-  */
-  void slotChildOutput(int fdno);
-
- /**
-  * This slot gets activated when data from the child's stderr arrives.
-  * It usually calls childError().
-  * @param fdno the file descriptor for the output
-  */
-  void slotChildError(int fdno);
-
-  /**
-   * Called when another bulk of data can be sent to the child's
-   * stdin. If there is no more data to be sent to stdin currently
-   * available, this function must disable the QSocketNotifier innot.
-   * @param dummy ignore this argument
-   */
-  void slotSendData(int dummy);	// KDE 4: remove dummy
-
-protected:
-
-  /**
-   * Sets up the environment according to the data passed via
-   * setEnvironment()
-   */
-  void setupEnvironment();
-
-  /**
-   * The list of the process' command line arguments. The first entry
-   * in this list is the executable itself.
-   */
-  QList<QByteArray> arguments;
-  /**
-   * How to run the process (Block, NotifyOnExit, DontCare). You should
-   *  not modify this data member directly from derived classes.
-   */
-  RunMode run_mode;
-  /**
-   * true if the process is currently running. You should not
-   * modify this data member directly from derived classes. Please use
-   * isRunning() for reading the value of this data member since it
-   * will probably be made private in later versions of K3Process.
-   */
-  bool runs;
-
-  /**
-   * The PID of the currently running process.
-   * You should not modify this data member in derived classes.
-   * Please use pid() instead of directly accessing this
-   * member since it will probably be made private in
-   * later versions of K3Process.
-   */
-  pid_t pid_;
-
-  /**
-   * The process' exit status as returned by waitpid(). You should not
-   * modify the value of this data member from derived classes. You should
-   * rather use exitStatus() than accessing this data member directly
-   * since it will probably be made private in further versions of
-   * K3Process.
-   */
-  int status;
-
-
-  /**
-   * If false, the child process' effective uid & gid will be reset to the
-   * real values.
-   * @see setRunPrivileged()
-   */
-  bool keepPrivs;
-
-  /**
-   * This function is called from start() right before a fork() takes
-   * place. According to the @p comm parameter this function has to initialize
-   * the in, out and err data members of K3Process.
-   *
-   * This function should return 1 if setting the needed communication channels
-   * was successful.
-   *
-   * The default implementation is to create UNIX STREAM sockets for the
-   * communication, but you could reimplement this function to establish a
-   * TCP/IP communication for network communication, for example.
-   */
-  virtual int setupCommunication(Communication comm);
-
-  /**
-   * Called right after a (successful) fork() on the parent side. This function
-   * will usually do some communications cleanup, like closing in[0],
-   * out[1] and out[1].
-   *
-   * Furthermore, it must also create the QSocketNotifiers innot,
-   * outnot and errnot and connect their Qt signals to the respective
-   * K3Process slots.
-   *
-   * For a more detailed explanation, it is best to have a look at the default
-   * implementation in kprocess.cpp.
-   */
-  virtual int commSetupDoneP();
-
-  /**
-   * Called right after a (successful) fork(), but before an exec() on the child
-   * process' side. It usually duplicates the in[0], out[1] and
-   * err[1] file handles to the respective standard I/O handles.
-   */
-  virtual int commSetupDoneC();
-
-
-  /**
-   * Immediately called after a successfully started process in NotifyOnExit
-   * mode has exited. This function normally calls commClose()
-   * and emits the processExited() signal.
-   * @param state the exit code of the process as returned by waitpid()
-   */
-  virtual void processHasExited(int state);
-
-  /**
-   * Cleans up the communication links to the child after it has exited.
-   * This function should act upon the values of pid() and runs.
-   * See the kprocess.cpp source for details.
-   * @li If pid() returns zero, the communication links should be closed
-   *  only.
-   * @li if pid() returns non-zero and runs is false, all data
-   *  immediately available from the communication links should be processed
-   *  before closing them.
-   * @li if pid() returns non-zero and runs is true, the communication
-   *  links should be monitored for data until the file handle returned by
-   *  K3ProcessController::theKProcessController->notifierFd() becomes ready
-   *  for reading - when it triggers, runs should be reset to false, and
-   *  the function should be immediately left without closing anything.
-   *
-   * The previous semantics of this function are forward-compatible, but should
-   * be avoided, as they are prone to race conditions and can cause K3Process
-   * (and thus the whole program) to lock up under certain circumstances. At the
-   * end the function closes the communication links in any case. Additionally
-   * @li if runs is true, the communication links are monitored for data
-   *  until all of them have returned EOF. Note that if any system function is
-   *  interrupted (errno == EINTR) the polling loop should be aborted.
-   * @li if runs is false, all data immediately available from the
-   *  communication links is processed.
-   */
-  virtual void commClose();
-
-  /* KDE 4 - commClose will be changed to perform cleanup only in all cases *
-   * If @p notfd is -1, all data immediately available from the
-   *  communication links should be processed.
-   * If @p notfd is not -1, the communication links should be monitored
-   *  for data until the file handle @p notfd becomes ready for reading.
-   */
-//  virtual void commDrain(int notfd);
-
-  /**
-   * Specify the actual executable that should be started (first argument to execve)
-   * Normally the the first argument is the executable but you can
-   * override that with this function.
-   */
-  void setBinaryExecutable(const char *filename);
-
-  /**
-   * The socket descriptors for stdout.
-   */
-  int out[2];
-  /**
-   * The socket descriptors for stdin.
-   */
-  int in[2];
-  /**
-   * The socket descriptors for stderr.
-   */
-  int err[2];
-
-  /**
-   * The socket notifier for in[1].
-   */
-  QSocketNotifier *innot;
-  /**
-   * The socket notifier for out[0].
-   */
-  QSocketNotifier *outnot;
-  /**
-   * The socket notifier for err[0].
-   */
-  QSocketNotifier *errnot;
-
-  /**
-   * Lists the communication links that are activated for the child
-   * process.  Should not be modified from derived classes.
-   */
-  Communication communication;
-
-  /**
-   * Called by slotChildOutput() this function copies data arriving from
-   * the child process' stdout to the respective buffer and emits the signal
-   * receivedStdout().
-   */
-  int childOutput(int fdno);
-
-  /**
-   * Called by slotChildError() this function copies data arriving from
-   * the child process' stderr to the respective buffer and emits the signal
-   * receivedStderr().
-   */
-  int childError(int fdno);
-
-  /**
-   * The buffer holding the data that has to be sent to the child
-   */
-  const char *input_data;
-  /**
-   * The number of bytes already transmitted
-   */
-  int input_sent;
-  /**
-   * The total length of input_data
-   */
-  int input_total;
-
-  /**
-   * K3ProcessController is a friend of K3Process because it has to have
-   * access to various data members.
-   */
-  friend class K3ProcessController;
-
-private:
-  K3ProcessPrivate* const d;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(K3Process::Communication)
-
-class K3ShellProcessPrivate;
-
-/**
-* @obsolete
-*
-* Use K3Process and K3Process::setUseShell(true) instead.
-*
-*   @short A class derived from K3Process to start child
-*   	processes through a shell.
-*   @author Christian Czezatke <e9025461@student.tuwien.ac.at>
-*/
-class K3ShellProcess : public K3Process
-{
-  Q_OBJECT
-
-public:
-
-  /**
-   * Constructor
-   *
-   * If no shellname is specified, the user's default shell is used.
-   */
-  explicit K3ShellProcess(const char *shellname=0);
-
-  /**
-   * Destructor.
-   */
-  ~K3ShellProcess();
-
-  virtual bool start(RunMode  runmode = NotifyOnExit,
-		  Communication comm = NoCommunication);
-
-  static QString quote(const QString &arg);
-
-private:
-  K3ShellProcessPrivate* const d;
-};
-
-
-
-#endif
-
diff --git a/libqterminal/k3processcontroller.cpp b/libqterminal/k3processcontroller.cpp
deleted file mode 100644
--- a/libqterminal/k3processcontroller.cpp
+++ /dev/null
@@ -1,345 +0,0 @@
-/* This file is part of the KDE libraries
-    Copyright (C) 1997 Christian Czezakte (e9025461@student.tuwien.ac.at)
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#include "k3processcontroller.h"
-#include "k3process.h"
-
-//#include <config.h>
-
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <QtCore/QSocketNotifier>
-#include <QDebug>
-
-class K3ProcessController::Private
-{
-public:
-    Private()
-        : needcheck( false ),
-          notifier( 0 )
-    {
-    }
-
-    ~Private()
-    {
-        delete notifier;
-    }
-
-    int fd[2];
-    bool needcheck;
-    QSocketNotifier *notifier;
-    QList<K3Process*> kProcessList;
-    QList<int> unixProcessList;
-    static struct sigaction oldChildHandlerData;
-    static bool handlerSet;
-    static int refCount;
-    static K3ProcessController* instance;
-};
-
-K3ProcessController *K3ProcessController::Private::instance = 0;
-int K3ProcessController::Private::refCount = 0;
-
-void K3ProcessController::ref()
-{
-    if ( !Private::refCount ) {
-        Private::instance = new K3ProcessController;
-        setupHandlers();
-    }
-    Private::refCount++;
-}
-
-void K3ProcessController::deref()
-{
-    Private::refCount--;
-    if( !Private::refCount ) {
-        resetHandlers();
-        delete Private::instance;
-        Private::instance = 0;
-    }
-}
-
-K3ProcessController* K3ProcessController::instance()
-{
-    /*
-     * there were no safety guards in previous revisions, is that ok?
-    if ( !Private::instance ) {
-        ref();
-    }
-     */
-
-    return Private::instance;
-}
-
-K3ProcessController::K3ProcessController()
-  : d( new Private )
-{
-  if( pipe( d->fd ) )
-  {
-    perror( "pipe" );
-    abort();
-  }
-
-  fcntl( d->fd[0], F_SETFL, O_NONBLOCK ); // in case slotDoHousekeeping is called without polling first
-  fcntl( d->fd[1], F_SETFL, O_NONBLOCK ); // in case it fills up
-  fcntl( d->fd[0], F_SETFD, FD_CLOEXEC );
-  fcntl( d->fd[1], F_SETFD, FD_CLOEXEC );
-
-  d->notifier = new QSocketNotifier( d->fd[0], QSocketNotifier::Read );
-  d->notifier->setEnabled( true );
-  QObject::connect( d->notifier, SIGNAL(activated(int)),
-                    SLOT(slotDoHousekeeping()));
-}
-
-K3ProcessController::~K3ProcessController()
-{
-#ifndef Q_OS_MAC
-/* not sure why, but this is causing lockups */
-  close( d->fd[0] );
-  close( d->fd[1] );
-#else
-#warning FIXME: why does close() freeze up destruction?
-#endif
-
-  delete d;
-}
-
-
-extern "C" {
-static void theReaper( int num )
-{
-  K3ProcessController::theSigCHLDHandler( num );
-}
-}
-
-#ifdef Q_OS_UNIX
-struct sigaction K3ProcessController::Private::oldChildHandlerData;
-#endif
-bool K3ProcessController::Private::handlerSet = false;
-
-void K3ProcessController::setupHandlers()
-{
-  if( Private::handlerSet )
-      return;
-  Private::handlerSet = true;
-
-#ifdef Q_OS_UNIX
-  struct sigaction act;
-  sigemptyset( &act.sa_mask );
-
-  act.sa_handler = SIG_IGN;
-  act.sa_flags = 0;
-  sigaction( SIGPIPE, &act, 0L );
-
-  act.sa_handler = theReaper;
-  act.sa_flags = SA_NOCLDSTOP;
-  // CC: take care of SunOS which automatically restarts interrupted system
-  // calls (and thus does not have SA_RESTART)
-#ifdef SA_RESTART
-  act.sa_flags |= SA_RESTART;
-#endif
-  sigaction( SIGCHLD, &act, &Private::oldChildHandlerData );
-
-  sigaddset( &act.sa_mask, SIGCHLD );
-  // Make sure we don't block this signal. gdb tends to do that :-(
-  sigprocmask( SIG_UNBLOCK, &act.sa_mask, 0 );
-#else
-  //TODO: win32
-#endif
-}
-
-void K3ProcessController::resetHandlers()
-{
-  if( !Private::handlerSet )
-      return;
-  Private::handlerSet = false;
-
-#ifdef Q_OS_UNIX
-  sigset_t mask, omask;
-  sigemptyset( &mask );
-  sigaddset( &mask, SIGCHLD );
-  sigprocmask( SIG_BLOCK, &mask, &omask );
-
-  struct sigaction act;
-  sigaction( SIGCHLD, &Private::oldChildHandlerData, &act );
-  if (act.sa_handler != theReaper) {
-     sigaction( SIGCHLD, &act, 0 );
-     Private::handlerSet = true;
-  }
-
-  sigprocmask( SIG_SETMASK, &omask, 0 );
-#else
-  //TODO: win32
-#endif
-  // there should be no problem with SIGPIPE staying SIG_IGN
-}
-
-// the pipe is needed to sync the child reaping with our event processing,
-// as otherwise there are race conditions, locking requirements, and things
-// generally get harder
-void K3ProcessController::theSigCHLDHandler( int arg )
-{
-  int saved_errno = errno;
-
-  char dummy = 0;
-  ssize_t result = ::write( instance()->d->fd[1], &dummy, 1 );
-  if (result < 0) {
-     qDebug() << "Write failed with the error code " << result << endl;
-  }
-
-#ifdef Q_OS_UNIX
-    if ( Private::oldChildHandlerData.sa_handler != SIG_IGN &&
-         Private::oldChildHandlerData.sa_handler != SIG_DFL ) {
-        Private::oldChildHandlerData.sa_handler( arg ); // call the old handler
-    }
-#else
-  //TODO: win32
-#endif
-
-  errno = saved_errno;
-}
-
-int K3ProcessController::notifierFd() const
-{
-  return d->fd[0];
-}
-
-void K3ProcessController::unscheduleCheck()
-{
-  char dummy[16]; // somewhat bigger - just in case several have queued up
-  if( ::read( d->fd[0], dummy, sizeof(dummy) ) > 0 )
-    d->needcheck = true;
-}
-
-void
-K3ProcessController::rescheduleCheck()
-{
-  if( d->needcheck )
-  {
-    d->needcheck = false;
-    char dummy = 0;
-    ssize_t result = ::write( d->fd[1], &dummy, 1 );
-    if (result < 0) {
-     qDebug() << "Write failed with the error code " << result << endl;
-    }
-
-  }
-}
-
-void K3ProcessController::slotDoHousekeeping()
-{
-  char dummy[16]; // somewhat bigger - just in case several have queued up
-  ssize_t result = ::read( d->fd[0], dummy, sizeof(dummy) );
-  if (result < 0) {
-     qDebug() << "Write failed with the error code " << result << endl;
-  }
-
-  int status;
- again:
-  QList<K3Process*>::iterator it( d->kProcessList.begin() );
-  QList<K3Process*>::iterator eit( d->kProcessList.end() );
-  while( it != eit )
-  {
-    K3Process *prc = *it;
-    if( prc->runs && waitpid( prc->pid_, &status, WNOHANG ) > 0 )
-    {
-      prc->processHasExited( status );
-      // the callback can nuke the whole process list and even 'this'
-      if (!instance())
-        return;
-      goto again;
-    }
-    ++it;
-  }
-  QList<int>::iterator uit( d->unixProcessList.begin() );
-  QList<int>::iterator ueit( d->unixProcessList.end() );
-  while( uit != ueit )
-  {
-    if( waitpid( *uit, 0, WNOHANG ) > 0 )
-    {
-      uit = d->unixProcessList.erase( uit );
-      deref(); // counterpart to addProcess, can invalidate 'this'
-    } else
-      ++uit;
-  }
-}
-
-bool K3ProcessController::waitForProcessExit( int timeout )
-{
-#ifdef Q_OS_UNIX
-  for(;;)
-  {
-    struct timeval tv, *tvp;
-    if (timeout < 0)
-      tvp = 0;
-    else
-    {
-      tv.tv_sec = timeout;
-      tv.tv_usec = 0;
-      tvp = &tv;
-    }
-
-    fd_set fds;
-    FD_ZERO( &fds );
-    FD_SET( d->fd[0], &fds );
-
-    switch( select( d->fd[0]+1, &fds, 0, 0, tvp ) )
-    {
-    case -1:
-      if( errno == EINTR )
-        continue;
-      // fall through; should never happen
-    case 0:
-      return false;
-    default:
-      slotDoHousekeeping();
-      return true;
-    }
-  }
-#else
-  //TODO: win32
-  return false;
-#endif
-}
-
-void K3ProcessController::addKProcess( K3Process* p )
-{
-  d->kProcessList.append( p );
-}
-
-void K3ProcessController::removeKProcess( K3Process* p )
-{
-  d->kProcessList.removeAll( p );
-}
-
-void K3ProcessController::addProcess( int pid )
-{
-  d->unixProcessList.append( pid );
-  ref(); // make sure we stay around when the K3Process goes away
-}
-
-//#include "moc_k3processcontroller.cpp"
diff --git a/libqterminal/k3processcontroller.h b/libqterminal/k3processcontroller.h
deleted file mode 100644
--- a/libqterminal/k3processcontroller.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/* This file is part of the KDE libraries
-    Copyright (C) 1997 Christian Czezakte (e9025461@student.tuwien.ac.at)
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef K3PROCCTRL_H
-#define K3PROCCTRL_H
-
-#include <QtCore/QList>
-#include <k3process.h>
-
-
-/**
- * @short Used internally by K3Process
- * @internal
- * @author Christian Czezatke <e9025461@student.tuwien.ac.at>
- *
- *  A class for internal use by K3Process only. -- Exactly one instance
- *  of this class is created by KApplication.
- *
- * This class takes care of the actual (UN*X) signal handling.
- */
-class K3ProcessController : public QObject
-{
-  Q_OBJECT
-
-public:
-  /**
-   * Create an instance if none exists yet.
-   * Called by KApplication::KApplication()
-   */
-  static void ref();
-
-  /**
-   * Destroy the instance if one exists and it is not referenced any more.
-   * Called by KApplication::~KApplication()
-   */
-  static void deref();
-
-  /**
-   * Only a single instance of this class is allowed at a time.
-   * This method provides access to that instance.
-   */
-  static K3ProcessController *instance();
-
-  /**
-   * Automatically called upon SIGCHLD. Never call it directly.
-   * If your application (or some library it uses) redirects SIGCHLD,
-   * the new signal handler (and only it) should call the old handler
-   * returned by sigaction().
-   * @internal
-   */
-  static void theSigCHLDHandler(int signal); // KDE4: private
-
-  /**
-   * Wait for any process to exit and handle their exit without
-   * starting an event loop.
-   * This function may cause K3Process to emit any of its signals.
-   *
-   * @param timeout the timeout in seconds. -1 means no timeout.
-   * @return true if a process exited, false
-   *         if no process exited within @p timeout seconds.
-   */
-  bool waitForProcessExit(int timeout);
-
-  /**
-   * Call this function to defer processing of the data that became available
-   * on notifierFd().
-   */
-  void unscheduleCheck();
-
-  /**
-   * This function @em must be called at some point after calling
-   * unscheduleCheck().
-   */
-  void rescheduleCheck();
-
-  /*
-   * Obtain the file descriptor K3ProcessController uses to get notified
-   * about process exits. select() or poll() on it if you create a custom
-   * event loop that needs to act upon SIGCHLD.
-   * @return the file descriptor of the reading end of the notification pipe
-   */
-  int notifierFd() const;
-
-  /**
-   * @internal
-   */
-  void addKProcess( K3Process* );
-  /**
-   * @internal
-   */
-  void removeKProcess( K3Process* );
-  /**
-   * @internal
-   */
-  void addProcess( int pid );
-
-private Q_SLOTS:
-  void slotDoHousekeeping();
-
-private:
-  friend class I_just_love_gcc;
-
-  static void setupHandlers();
-  static void resetHandlers();
-
-  // Disallow instantiation
-  K3ProcessController();
-  ~K3ProcessController();
-
-  // Disallow assignment and copy-construction
-  K3ProcessController( const K3ProcessController& );
-  K3ProcessController& operator= ( const K3ProcessController& );
-
-  class Private;
-  Private * const d;
-};
-
-#endif
-
diff --git a/libqterminal/libqterminal.pro b/libqterminal/libqterminal.pro
--- a/libqterminal/libqterminal.pro
+++ b/libqterminal/libqterminal.pro
@@ -12,42 +12,38 @@ DEFINES 	+= HAVE_POSIX_OPENPT
 
 HEADERS  = BlockArray.h \
            Character.h \
            CharacterColor.h \
            Emulation.h \
            ExtendedDefaultTranslator.h \
            Filter.h \
            History.h \
-           k3process.h \
-           k3processcontroller.h \
            KeyboardTranslator.h \
            konsole_wcwidth.h \
            kpty.h \
            kpty_p.h \
            LineFont.h \
            QTerminal.h \
            Screen.h \
            ScreenWindow.h \
            ShellCommand.h \
            TerminalCharacterDecoder.h \
            Vt102Emulation.h \
-    PseudoTerminal.h \
     SessionModel.h \
-    SessionView.h
+    SessionView.h \
+    SelfListener.h
 SOURCES  = BlockArray.cpp \
            Emulation.cpp \
            Filter.cpp \
            History.cpp \
-           k3process.cpp \
-           k3processcontroller.cpp \
            KeyboardTranslator.cpp \
            konsole_wcwidth.cpp \
            kpty.cpp \
            QTerminal.cpp \
            Screen.cpp \
            ScreenWindow.cpp \
            ShellCommand.cpp \
            TerminalCharacterDecoder.cpp \
            Vt102Emulation.cpp \
-    PseudoTerminal.cpp \
     SessionModel.cpp \
-    SessionView.cpp
+    SessionView.cpp \
+    SelfListener.cpp
