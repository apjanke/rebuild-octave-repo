# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1342197111 14400
#      Fri Jul 13 12:31:51 2012 -0400
# Node ID 6bc39019f7260fb4b0f81f0ea311240a79ad094b
# Parent  149d1e2224f0778885b79973d2f0a5c30d93520e
# Parent  e027f98403c39b488fbec3d48f3fb447d9b53326
maint: periodic merge of default to jit

diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -449,17 +449,17 @@ function defined in a @file{.m} file is 
 @node Coherent syntax
 @section Coherent syntax
 
 Indexing other things than variables is possible, as in:
 @example
 @group
 octave:1> [3 1 4 1 5 9](3)
 ans = 4
-octave:2> cos([0 pi pi/4 7])(3)
+octave:2> cos ([0 pi pi/4 7])(3)
 ans = 0.70711
 @end group
 @end example
 
 @node Exclamation mark as not operator
 @section Exclamation mark as not operator
 
 The exclamation mark @samp{!} (aka ``Bang!'') is a negation operator, just
@@ -866,30 +866,30 @@ The major differences between Octave 3.4
 @itemize @bullet
 @item Nested Functions
 
 Octave has limited support for nested functions. That is
 
 @example
 @group
 function y = foo (x)
-  y = bar(x)
+  y = bar (x)
   function y = bar (x)
     y = @dots{};
   end
 end
 @end group
 @end example
 
 is equivalent to
 
 @example
 @group
 function y = foo (x)
-   y = bar(x)
+   y = bar (x)
 end
 function y = bar (x)
    y = @dots{};
 end
 @end group
 @end example
 
 The main difference with @sc{Matlab} is a matter of scope. While nested
@@ -1060,17 +1060,17 @@ are different in @sc{Matlab}. This is re
 there is too much code out there that relies on this behaviour to change
 it. Prefer the || and && operators in if statements if possible. If you
 need to use code written for @sc{Matlab} that depends on this buggy
 behaviour, you can enable it since Octave 3.4.0 with the following
 command:
 
 @example
 @group
-  do_braindead_shortcircuit_evaluation(1)
+  do_braindead_shortcircuit_evaluation (1)
 @end group
 @end example
 
 Note that the difference with @sc{Matlab} is also significant when
 either argument is a function with side effects or if the first argument
 is a scalar and the second argument is an empty matrix. For example,
 note the difference between
 
@@ -1097,17 +1097,17 @@ Another case that is documented in the @
 @end example
 
 Also @sc{Matlab} requires the operands of && and || to be scalar values
 but Octave does not (it just applies the rule that for an operand to be
 considered true, every element of the object must be nonzero or
 logically true).
 
 Finally, note the inconsistence of thinking of the condition of an if
-statement as being equivalent to @code{all(X(:))} when @var{X} is a
+statement as being equivalent to @code{all (X(:))} when @var{X} is a
 matrix.  This is true for all cases EXCEPT empty matrices:
 
 @example
 @group
   if ([0, 1]) == if (all ([0, 1]))   ==>  i.e., condition is false.
   if ([1, 1]) == if (all ([1, 1]))   ==>  i.e., condition is true.
 @end group
 @end example
@@ -1142,57 +1142,57 @@ result for these cases.
 
 In the case of under- or over-determined matrices, Octave continues to
 use a minimum norm solution, whereas @sc{Matlab} uses an approach that
 is equivalent to
 
 @example
 @group
 function x = mldivide (A, b)
-  [Q, R, E] = qr(A);
+  [Q, R, E] = qr (A);
   x = [A \ b, E(:, 1:m) * (R(:, 1:m) \ (Q' * b))]
 end
 @end group
 @end example
 
 @noindent
 While this approach is certainly faster and uses less memory than
 Octave's minimum norm approach, this approach seems to be inferior in
 other ways.
 
 A numerical question arises: how big can the null space component
 become, relative to the minimum-norm solution? Can it be nicely bounded,
 or can it be arbitrarily big? Consider this example:
-
+OctaveFAQ.texi
 @example
 @group
 m = 10;
 n = 10000;
-A = ones(m, n) + 1e-6 * randn(m,n);
-b = ones(m, 1) + 1e-6 * randn(m,1);
-norm(A \ b)
+A = ones (m, n) + 1e-6 * randn (m,n);
+b = ones (m, 1) + 1e-6 * randn (m,1);
+norm (A \ b)
 @end group
 @end example
 
 @noindent
 while Octave's minimum-norm values are around 3e-2, @sc{Matlab}'s
 results are 50-times larger. For another issue, try this code:
 
 @example
 @group
 m = 5;
 n = 100;
-j = floor(m * rand(1, n)) + 1;
-b = ones(m, 1);
-A = zeros(m, n);
-A(sub2ind(size(A),j,1:n)) = 1;
+j = floor (m * rand (1, n)) + 1;
+b = ones (m, 1);
+A = zeros (m, n);
+A(sub2ind (size (A),j,1:n)) = 1;
 x = A \ b;
-[dummy,p] = sort(rand(1,n));
-y = A(:,p)\b;
-norm(x(p)-y)
+[dummy,p] = sort (rand (1,n));
+y = A(:,p) \ b;
+norm (x(p)-y)
 @end group
 @end example
 
 @noindent
 It shows that unlike in Octave, mldivide in @sc{Matlab} is not invariant
 with respect to column permutations. If there are multiple columns of
 the same norm, permuting columns of the matrix gets you different
 result than permuting the solution vector. This will surprise many
@@ -1277,20 +1277,20 @@ compared to
 @end example
 
 Typing Ctrl-C in the first case returns the user directly to the
 prompt, and the variable "a" is not reset to the saved value. In the
 second case the variable "a" is reset correctly.  Therefore @sc{Matlab}
 gives no safe way of temporarily changing global variables.
 
 @item
-Indexing can be applied to all objects in Octave and not just
+Indexing can be applied to all objects in Octave and not just a
 variable. Therefore @code{sin(x)(1:10);} for example is perfectly valid
 in Octave but not @sc{Matlab}. To do the same in @sc{Matlab} you must do
-@code{y = sin(x); y = y([1:10]);}
+@code{y = sin (x); y = y([1:10]);}
 
 @item
 Octave has the operators "++", "--", "-=", "+=", "*=", etc.  As
 @sc{Matlab} doesn't, if you are sharing code these should be avoided.
 
 @item
 Character strings in Octave can be denoted with double or single
 quotes. There is a subtle difference between the two in that escaped
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1018,20 +1018,20 @@ character, @samp{#}, or the percent symb
 end of the line.  Any text following the sharp sign or percent symbol is
 ignored by the Octave interpreter and not executed.  The following example
 shows whole line and partial line comments.
 
 @example
 @group
 function countdown
   # Count down for main rocket engines 
-  disp(3);
-  disp(2);
-  disp(1);
-  disp("Blast Off!");  # Rocket leaves pad
+  disp (3);
+  disp (2);
+  disp (1);
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @node Block Comments
 @subsection Block Comments
 @cindex block comments
 @cindex multi-line comments
@@ -1041,29 +1041,29 @@ endfunction
 Entire blocks of code can be commented by enclosing the code between 
 matching @samp{#@{} and @samp{#@}} or @samp{%@{} and @samp{%@}} markers.  
 For example,
 
 @example
 @group
 function quick_countdown
   # Count down for main rocket engines 
-  disp(3);
+  disp (3);
  #@{
-  disp(2);
-  disp(1);
+  disp (2);
+  disp (1);
  #@}
-  disp("Blast Off!");  # Rocket leaves pad
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
-lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
+lines "@code{disp (2);}" and "@code{disp (1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
 (excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -303,46 +303,46 @@ x.a
 @end group
 @end example
 
 Here is another example, using this comma separated list on the
 left-hand side of an assignment:
 
 @example
 @group
-[x.a] = deal("new string1", "new string2");
+[x.a] = deal ("new string1", "new string2");
  x(1).a
      @result{} ans = new string1
  x(2).a
      @result{} ans = new string2
 @end group
 @end example
 
 Just as for numerical arrays, it is possible to use vectors as indices
 (@pxref{Index Expressions}):
 
 @example
 @group
 x(3:4) = x(1:2);
-[x([1,3]).a] = deal("other string1", "other string2");
+[x([1,3]).a] = deal ("other string1", "other string2");
 x.a
      @result{}
         ans = other string1
         ans = new string2
         ans = other string2
         ans = new string2
 @end group
 @end example
 
 The function @code{size} will return the size of the structure.  For
 the example above
 
 @example
 @group
-size(x)
+size (x)
      @result{} ans =
 
           1   4
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
@@ -600,20 +600,20 @@ function.
 
 @DOCSTRING(celldisp)
 
 To test if an object is a cell array, use the @code{iscell}
 function.  For example:
 
 @example
 @group
-iscell(c)
+iscell (c)
      @result{} ans = 1
 
-iscell(3)
+iscell (3)
      @result{} ans = 0
 
 @end group
 @end example
 
 @DOCSTRING(iscell)
 
 @node Creating Cell Arrays
@@ -626,17 +626,17 @@ then fill it with data.
 
 The @code{cell} function returns a cell array of a given size, containing
 empty matrices.  This function is similar to the @code{zeros}
 function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
-c = cell(2,2)
+c = cell (2,2)
      @result{} c =
          
          @{
            [1,1] = [](0x0)
            [2,1] = [](0x0)
            [1,2] = [](0x0)
            [2,2] = [](0x0)
          @}
@@ -647,19 +647,19 @@ Just like numerical arrays, cell arrays 
 @code{cell} function accepts any number of positive integers to describe
 the size of the returned cell array.  It is also possible to set the size
 of the cell array through a vector of positive integers.  In the
 following example two cell arrays of equal size are created, and the size
 of the first one is displayed
 
 @example
 @group
-c1 = cell(3, 4, 5);
-c2 = cell( [3, 4, 5] );
-size(c1)
+c1 = cell (3, 4, 5);
+c2 = cell ( [3, 4, 5] );
+size (c1)
      @result{} ans =
          3   4   5
 @end group
 @end example
 
 @noindent
 As can be seen, the @ref{doc-size, @code{size}} function also works
 for cell arrays.  As do other functions describing the size of an
@@ -761,17 +761,17 @@ c([1, 2], :) = c([2, 1], :)
 Accessing multiple elements of a cell array with the @samp{@{} and
 @samp{@}} operators will result in a comma-separated list of all the
 requested elements (@pxref{Comma Separated Lists}).  Using the
 @samp{@{} and @samp{@}} operators the first two rows in the above
 example can be swapped back like this:
 
 @example
 @group
-[c@{[1,2], :@}] = deal(c@{[2, 1], :@})
+[c@{[1,2], :@}] = deal (c@{[2, 1], :@})
      @result{} = 
         @{
           [1,1] =  1
           [2,1] =  4
           [1,2] =  2
           [2,2] =  5
           [1,3] =  3
           [2,3] =  6
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -61,57 +61,67 @@ gnulib sources that Octave depends on ar
 @end table
 
 Once you have the required tools installed, you can build Octave by
 doing
 
 @itemize @bullet
 @item
 Check out a copy of the Octave sources:
+
 @example
 hg clone http://hg.savannah.gnu.org/hgweb/octave
 @end example
 
 @item
 Change to the top-level directory of the newly checked out sources:
+
 @example
 cd octave
 @end example
 
 @item
 Generate the necessary configuration files:
+
 @example
 ./autogen.sh
 @end example
 
 @item
 Create a build directory and change to it:
+
 @example
+@group
 mkdir build
 cd build
+@end group
 @end example
+
 By using a separate build directory, you will keep the source directory
 clean and it will be easy to completely remove all files generated by
 the build.  You can also have parallel build trees for different
 purposes that all share the same sources.  For example, one build tree
 may be configured to disable compiler optimization in order to allow for
 easier debugging while another may be configured to test building with
 other specialized compiler flags.
 
 @item
 Run Octave's configure script from the build directory:
+
 @example
 ../configure
 @end example
 
 @item
 Run make in the build directory:
+
 @example
 make
 @end example
+
 @end itemize
 
 Once the build is finished, you will see a message like the following:
 
 @example
 @group
 Octave successfully built.  Now choose from the following:
 
@@ -316,17 +326,17 @@ Always use a specific end-of-block state
 @code{endswitch}) rather than generic @code{end}.
 
 Enclose the @code{if}, @code{while}, @code{until} and @code{switch}
 conditions in parentheses, like in C:
 
 @example
 @group
 if (isvector (a))
-  s = sum(a);
+  s = sum (a);
 endif
 @end group
 @end example
 
 @noindent
 Do not do this, however, with the iteration counter portion of a
 @code{for} statement.  Write:
 
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -88,17 +88,17 @@ Example:
 @result{}
 Diagonal Matrix
 
    1   0   0   0
    0   2   0   0
    0   0   3   0
    0   0   0   4
 
-  diag(1:3,5,3)
+  diag (1:3,5,3)
 
 @result{}
 Diagonal Matrix
 
    1   0   0
    0   2   0
    0   0   3
    0   0   0
@@ -506,16 +506,17 @@ or divided by @code{NaN}.
 The reason for this behavior is that the numerical multiplication is not
 actually performed anywhere by the underlying algorithm; the result is
 just assumed to be zero.  Equivalently, one can say that the part of the
 computation involving assumed zeros is performed symbolically, not numerically.
 
 This behavior not only facilitates the most straightforward and efficient
 implementation of algorithms, but also preserves certain useful invariants,
 like:
+
 @itemize
 @item scalar * diagonal matrix is a diagonal matrix
 
 @item sparse matrix / scalar preserves the sparsity pattern
 
 @item permutation matrix * matrix is equivalent to permuting rows
 @end itemize
 all of these natural mathematical truths would be invalidated by treating
@@ -548,23 +549,23 @@ Inf * full (eye (3))
    Inf   NaN   NaN
    NaN   Inf   NaN
    NaN   NaN   Inf
 
 @end example
 
 @example
 @group
-diag(1:3) * [NaN; 1; 1]
+diag (1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 
-sparse(1:3,1:3,1:3) * [NaN; 1; 1]
+sparse (1:3,1:3,1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 [1,0,0;0,2,0;0,0,3] * [NaN; 1; 1]
 @result{}
    NaN
    NaN
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -95,18 +95,18 @@ y = lsode ("f", x0, t);
 @end example
 
 If you try this, you will see that the value of the result changes
 dramatically between @var{t} = 0 and 5, and again around @var{t} = 305.
 A more efficient set of output points might be
 
 @example
 @group
-t = [0, logspace (-1, log10(303), 150), \
-        logspace (log10(304), log10(500), 150)];
+t = [0, logspace(-1, log10(303), 150), \
+        logspace(log10(304), log10(500), 150)];
 @end group
 @end example
 
 See Alan C. Hindmarsh, @cite{ODEPACK, A Systematized Collection of ODE
 Solvers}, in Scientific Computing, R. S. Stepleman, editor, (1983) for
 more information about the inner workings of @code{lsode}.
 
 @node Differential-Algebraic Equations
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -135,16 +135,17 @@ cmd
 cmember
 cntrl
 cof
 coffset
 colamd
 collectoutput
 colorbar
 colormap
+colormaps
 ColorOrder
 colperm
 Comint
 Commandline
 commentstyle
 ComplexEqn
 cond
 condest
@@ -334,16 +335,17 @@ geoinv
 geopdf
 geornd
 GEP
 geq
 gesdd
 gesvd
 gfortan
 Ghostscript
+Ghostscript's
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
 gnulib
 gnuplot
@@ -354,16 +356,17 @@ Gonnet
 goto
 Goto
 gotos
 GPL
 GPLK
 gplot
 grabdemo
 GradObj
+GraphicsAlphaBits
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
 gswin
 GUIs
 gunzipped
@@ -859,16 +862,17 @@ stepsize
 STFT
 STL
 stochastically
 strcmp
 stringanchors
 strncmp
 strncmpi
 strread
+strread's
 struct
 structs
 subarrays
 subdirectories
 subdirectory
 subexpressions
 subfunction
 Subfunction
@@ -915,16 +919,17 @@ symamd
 symbfact
 symrcm
 tcdf
 Tcv
 terminal's
 tex
 texinfo
 Texinfo
+TextAlphaBits
 textscan
 th
 ths
 tif
 Tikhonov
 TikZ
 tinv
 Tisseur
@@ -981,16 +986,17 @@ unifpdf
 unifrnd
 unimodal
 Uninstall
 uninstalled
 univariate
 unnormalized
 unpadded
 unpivoted
+unregister
 unshare
 unsymmetric
 untabified
 uparrow
 Uparrow
 uplus
 userdata
 Username
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -546,17 +546,17 @@ int nel = sm.nelem ();
 @end example
 
 @noindent
 returns the number of non-zero elements.  If the user really requires the
 number of elements in the matrix, including the non-zero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
 large matrices, where the product of the two dimensions is larger than
 the representation of an unsigned int, then @code{numel} can overflow.
-An example is @code{speye(1e6)} which will create a matrix with a million
+An example is @code{speye (1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
 Extreme care must be take with the elem method and the "()" operator,
 which perform basically the same function.  The reason is that if a
@@ -896,19 +896,19 @@ passing a function to an oct-file.
 
 The first argument to this demonstration is the user supplied function
 and the following arguments are all passed to the user function.
 
 @example
 @group
 funcdemo (@@sin,1)
 @result{} 0.84147
-funcdemo (@@(x) sin(x), 1)
+funcdemo (@@(x) sin (x), 1)
 @result{} 0.84147
-funcdemo (inline ("sin(x)"), 1)
+funcdemo (inline ("sin (x)"), 1)
 @result{} 0.84147
 funcdemo ("sin",1)
 @result{} 0.84147
 funcdemo (@@atan2, 1, 1)
 @result{} 0.78540
 @end group
 @end example
 
@@ -1003,17 +1003,17 @@ external Fortran function, including pas
 as exception handling.  An example of the behavior of this function is
 
 @example
 @group
 [b, s] = fortdemo (1:3)
 @result{}
   b = 1.00000   0.50000   0.33333
   s = There are   3 values in the input vector
-[b, s] = fortdemo(0:3)
+[b, s] = fortdemo (0:3)
 error: fortsub:divide by zero
 error: exception encountered in Fortran subroutine fortsub_
 error: fortdemo: error in Fortran
 @end group
 @end example
 
 @node Allocating Local Memory in Oct-Files
 @subsection Allocating Local Memory in Oct-Files
@@ -1081,17 +1081,17 @@ methods are automatically released when 
 writing an oct-file, to allow Octave to treat the user typing @kbd{Control-C},
 the @w{@code{OCTAVE_QUIT}} macro is supplied.  For example:
 
 @example
 @group
 for (octave_idx_type i = 0; i < a.nelem (); i++)
   @{
     OCTAVE_QUIT;
-    b.elem(i) = 2. * a.elem(i);
+    b.elem (i) = 2. * a.elem (i);
   @}
 @end group
 @end example
 
 The presence of the @w{@code{OCTAVE_QUIT}} macro in the inner loop allows
 Octave to treat the user request with the @kbd{Control-C}.  Without this macro,
 the user must either wait for the function to return before the interrupt is
 processed, or press @kbd{Control-C} three times to force Octave to exit.
@@ -1190,19 +1190,19 @@ the compiler.  Finally, the Octave test 
 access to the source code of the oct-file and not just the compiled code
 as the tests are stripped from the compiled code.  An example in an
 oct-file might be
 
 @example
 @group
 /*
 
-%!error (sin())
-%!error (sin(1,1))
-%!assert (sin([1,2]),[sin(1),sin(2)])
+%!error (sin ())
+%!error (sin (1,1))
+%!assert (sin ([1,2]),[sin(1),sin(2)])
 
 */
 @end group
 @end example
 
 @c @node Application Programming Interface for Oct-Files
 @c @subsection Application Programming Interface for Oct-Files
 @c 
@@ -1366,17 +1366,17 @@ exists the generic function @code{mxGetD
 that perform the same operation on all matrix types.  For example:
 
 @example
 @group
 mxArray *m;
 mwSize *dims;
 UINT32_T *pr;
 
-dims = (mwSize *) mxMalloc (2 * sizeof(mwSize));
+dims = (mwSize *) mxMalloc (2 * sizeof (mwSize));
 dims[0] = 2;
 dims[1] = 2;
 m = mxCreateNumericArray (2, dims, mxUINT32_CLASS, mxREAL);
 pr =  = (UINT32_T *) mxGetData (m);
 @end group
 @end example
 
 There are also the functions @code{mxSetPr}, etc., that perform the
@@ -1398,18 +1398,18 @@ below.
 @EXAMPLEFILE(mypow2.c)
 @end example
 
 @noindent
 with an example of its use
 
 @example
 @group
-b = randn(4,1) + 1i * randn(4,1);
-all(b.^2 == mypow2(b))
+b = randn (4,1) + 1i * randn (4,1);
+all (b.^2 == mypow2 (b))
 @result{} 1
 @end group
 @end example
 
 
 The example above uses the functions @code{mxGetDimensions},
 @code{mxGetNumberOfElements}, and @code{mxGetNumberOfDimensions} to work
 with the dimensions of multi-dimensional arrays.  The functions
@@ -1429,17 +1429,17 @@ file @file{mystring.c}, as seen below.
 @EXAMPLEFILE(mystring.c)
 @end example
 
 @noindent
 An example of its expected output is
 
 @example
 @group
-mystring(["First String"; "Second String"])
+mystring (["First String"; "Second String"])
 @result{} s1 = Second String
         First String
 @end group
 @end example
 
 Other functions in the mex interface for handling character strings are
 @code{mxCreateString}, @code{mxArrayToString}, and
 @code{mxCreateCharMatrixFromStrings}.  In a mex-file, a character string
@@ -1544,17 +1544,17 @@ found in the file @file{mystruct.c}, as 
 @EXAMPLEFILE(mystruct.c)
 @end example
 
 An example of the behavior of this function within Octave is then
 
 @example
 a(1).f1 = "f11"; a(1).f2 = "f12"; 
 a(2).f1 = "f21"; a(2).f2 = "f22";
-b = mystruct(a)
+b = mystruct (a)
 @result{} field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
     b =
     @{
       this =
     
@@ -1646,18 +1646,18 @@ using @code{mexCallMATLAB}.  An example 
 @EXAMPLEFILE(myfeval.c)
 @end example
 
 If this code is in the file @file{myfeval.c}, and is compiled to
 @file{myfeval.mex}, then an example of its use is
 
 @example
 @group
-myfeval("sin", 1)
-a = myfeval("sin", 1)
+myfeval ("sin", 1)
+a = myfeval ("sin", 1)
 @result{} Hello, World!
     I have 2 inputs and 1 outputs
     I'm going to call the interpreter function sin
     a =  0.84147
 @end group
 @end example
 
 Note that it is not possible to use function handles or inline functions
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -324,16 +324,17 @@ Normally @samp{\}.
 
 @item octave-mode-startup-message
 If @code{t} (default), a startup message is displayed when Octave mode
 is called.
 
 @end table
 
 If Font Lock mode is enabled, Octave mode will display
+
 @itemize @bullet
 @item
 strings in @code{font-lock-string-face}
 
 @item
 comments in @code{font-lock-comment-face}
 
 @item
@@ -431,16 +432,17 @@ Delete all windows that display the infe
 
 @item C-c i k
 Kill the inferior Octave process and its buffer
 (@code{octave-kill-process}).
 @end table
 
 The effect of the commands which send code to the Octave process can be
 customized by the following variables.
+
 @table @code
 @item octave-send-echo-input
 Non-@code{nil} means echo input sent to the inferior Octave process.
 Default is @code{t}.
 
 @item octave-send-show-buffer
 Non-@code{nil} means display the buffer running the Octave process after
 sending a command (but without selecting it).
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -58,17 +58,17 @@ described in @ref{The @code{try} Stateme
 The most common use of errors is for checking input arguments to
 functions.  The following example calls the @code{error} function if
 the function @code{f} is called without any input arguments.
 
 @example
 @group
 function f (arg1)
   if (nargin == 0)
-    error("not enough input arguments");
+    error ("not enough input arguments");
   endif
 endfunction
 @end group
 @end example
 
 When the @code{error} function is called, it prints the given message
 and returns to the Octave prompt.  This means that no code following
 a call to @code{error} will be executed.
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -122,18 +122,18 @@ endfunction
 @end example
 
 With @code{evalin}, you could write @code{save} as follows:
 
 @example
 @group
 function save (file, name1, name2)
   f = open_save_file (file);
-  save_var(f, name1, evalin ("caller", name1));
-  save_var(f, name2, evalin ("caller", name2));
+  save_var (f, name1, evalin ("caller", name1));
+  save_var (f, name2, evalin ("caller", name2));
 endfunction
 @end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{create_data} function and @code{name1}
 is the string @code{"x"}, which evaluates simply as the value of @code{x}.
 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -253,17 +253,17 @@ operation and judicious use of it can re
 looping over individual array elements which is a slow operation.
 
 Consider the following example which creates a 10-element row vector
 @math{a} containing the values
 @tex
 $a_i = \sqrt{i}$.
 @end tex
 @ifnottex
-a(i) = sqrt(i).
+a(i) = sqrt (i).
 @end ifnottex
 
 @example
 @group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
 @end group
@@ -767,18 +767,18 @@ True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
 iff
 
 @example
 @group
-  abs(@var{z1}) < abs(@var{z2}) 
-  || (abs(@var{z1}) == abs(@var{z2}) && arg(@var{z1}) < arg(@var{z2}))
+  abs (@var{z1}) < abs (@var{z2}) 
+  || (abs (@var{z1}) == abs (@var{z2}) && arg (@var{z1}) < arg (@var{z2}))
 @end group
 @end example
 
 This is consistent with the ordering used by @dfn{max}, @dfn{min} and
 @dfn{sort}, but is not consistent with @sc{matlab}, which only compares the real
 parts.
 
 String comparisons may also be performed with the @code{strcmp}
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -39,37 +39,45 @@ like built-in functions.
 * Default Arguments::   
 * Function Files::              
 * Script Files::                
 * Function Handles Inline Functions and Anonymous Functions::
 * Commands::
 * Organization of Functions::   
 @end menu
 
-@node  Introduction to Function and Script Files
-@section  Introduction to Function and Script Files
+@node Introduction to Function and Script Files
+@section Introduction to Function and Script Files
 
-There are six different things covered in this section.
+There are seven different things covered in this section.
 @enumerate
 @item
 Typing in a function at the command prompt.
+
 @item
-Storing a group of commands in a file - called a script file.
+Storing a group of commands in a file --- called a script file.
+
 @item
-Storing a function in a file - called a function file.
+Storing a function in a file---called a function file.
+
 @item
-Sub-functions in function files.
+Subfunctions in function files.
+
 @item
 Multiple functions in one script file.
+
 @item
 Private functions.
+
+@item
+Nested functions.
 @end enumerate
 
 Both function files and script files end with an extension of .m, for
-@sc{Matlab} compatibility. If you want more than one independent
+@sc{matlab} compatibility.  If you want more than one independent
 functions in a file, it must be a script file (@pxref{Script Files}),
 and to use these functions you must execute the script file before you
 can use the functions that are in the script file.
 
 @node Defining Functions
 @section Defining Functions
 @cindex @code{function} statement
 @cindex @code{endfunction} statement
@@ -738,16 +746,17 @@ ignore the time stamps for all function 
 @DOCSTRING(mfilename)
 
 @DOCSTRING(ignore_function_time_stamp)
 
 @menu
 * Manipulating the Load Path::
 * Subfunctions::
 * Private Functions::
+* Nested Functions::
 * Overloading and Autoloading::
 * Function Locking::
 * Function Precedence::
 @end menu
 
 @node Manipulating the Load Path
 @subsection Manipulating the Load Path
 
@@ -758,17 +767,17 @@ a list of directories distributed with O
 working directory.  To see your current load path call the @code{path}
 function without any input or output arguments.
 
 It is possible to add or remove directories to or from the load path
 using @code{addpath} and @code{rmpath}.  As an example, the following
 code adds @samp{~/Octave} to the load path.
 
 @example
-addpath("~/Octave")
+addpath ("~/Octave")
 @end example
 
 @noindent
 After this the directory @samp{~/Octave} will be searched for functions.
  
 @DOCSTRING(addpath)
 
 @DOCSTRING(genpath)
@@ -846,16 +855,167 @@ endfunction
 @end example
 
 @noindent
 Then if the path to @code{func1} is @code{<directory>/func1.m}, and if
 @code{func2} is found in the directory @code{<directory>/private/func2.m}, 
 then @code{func2} is only available for use of the functions, like 
 @code{func1}, that are found in @code{<directory>}.
 
+@node Nested Functions
+@subsection Nested Functions
+
+Nested functions are similar to subfunctions in that only the main function is
+visible outside the file.  However, they also allow for child functions to
+access the local variables in their parent function.  This shared access mimics
+using a global variable to share information --- but a global variable which is
+not visible to the rest of Octave.  As a programming strategy, sharing data
+this way can create code which is difficult to maintain.  It is recommended to
+use subfunctions in place of nested functions when possible.
+
+As a simple example, consider a parent function @code{foo}, that calls a nested
+child function @code{bar}, with a shared variable @var{x}.
+
+@example
+@group
+function y = foo ()
+  x = 10;
+  bar ();
+  y = x;
+
+  function bar ()
+    x = 20;
+  endfunction
+endfunction
+
+foo ()
+ @result{} 20
+@end group
+@end example
+
+@noindent
+Notice that there is no special syntax for sharing @var{x}.  This can lead to
+problems with accidental variable sharing between a parent function and its
+child.  While normally variables are inherited, child function parameters and
+return values are local to the child function.
+
+Now consider the function @code{foobar} that uses variables @var{x} and
+@var{y}.  @code{foobar} calls a nested function @code{foo} which takes
+@var{x} as a parameter and returns @var{y}.  @code{foo} then calls @code{bat}
+which does some computation.
+
+@example
+@group
+function z = foobar ()
+  x = 0;
+  y = 0;
+  z = foo (5);
+  z += x + y;
+
+  function y = foo (x)
+    y = x + bat ();
+
+    function z = bat ()
+      z = x;
+    endfunction
+  endfunction
+endfunction
+
+foobar ()
+    @result{} 10
+@end group
+@end example
+
+@noindent
+It is important to note that the @var{x} and @var{y} in @code{foobar} remain
+zero, as in @code{foo} they are a return value and parameter respectively.  The
+@var{x} in @code{bat} refers to the @var{x} in @code{foo}.
+
+Variable inheritance leads to a problem for @code{eval} and scripts.  If a
+new variable is created in a parent function, it is not clear what should happen
+in nested child functions.  For example, consider a parent function @code{foo}
+with a nested child function @code{bar}:
+
+@example
+@group
+function y = foo (to_eval)
+  bar ();
+  eval (to_eval);
+
+  function bar ()
+    eval ("x = 100;");
+    eval ("y = x;");
+  endfunction
+endfunction
+
+foo ("x = 5;")
+    @result{} error: can not add variable "x" to a static workspace
+
+foo ("y = 10;")
+    @result{} 10
+
+foo ("")
+    @result{} 100
+@end group
+@end example
+
+@noindent
+The parent function @code{foo} is unable to create a new variable
+@var{x}, but the child function @code{bar} was successful.  Furthermore, even
+in an @code{eval} statement @var{y} in @code{bar} is the same @var{y} as in its
+parent function @code{foo}.  The use of @code{eval} in conjunction with nested
+functions is best avoided.
+
+As with subfunctions, only the first nested function in a file may be called
+from the outside.  Inside a function the rules are more complicated.  In
+general a nested function may call:
+
+@enumerate 0
+@item
+Globally visible functions
+
+@item
+Any function that the nested function's parent can call
+
+@item
+Sibling functions (functions that have the same parents)
+
+@item
+Direct children
+
+@end enumerate
+
+As a complex example consider a parent function @code{ex_top} with two
+child functions, @code{ex_a} and @code{ex_b}.  In addition, @code{ex_a} has two
+more child functions, @code{ex_aa} and @code{ex_ab}.  For example:
+
+@example
+function ex_top ()
+  ## Can call: ex_top, ex_a, and ex_b
+  ## Can NOT call: ex_aa and ex_ab
+
+  function ex_a ()
+    ## Call call everything
+
+    function ex_aa ()
+      ## Can call everything
+    endfunction
+
+    function ex_ab ()
+      ## Can call everything
+    endfunction
+  endfunction
+
+  function ex_b ()
+    ## Can call: ex_top, ex_a, and ex_b
+    ## Can NOT call: ex_aa and ex_ab
+  endfunction
+endfunction
+@end example
+
 @node Overloading and Autoloading
 @subsection Overloading and Autoloading
 
 Functions can be overloaded to work with different input arguments.  For
 example, the operator '+' has been overloaded in Octave to work with single,
 double, uint8, int32, and many other arguments.  The preferred way to overload
 functions is through classes and object oriented programming 
 (@pxref{Function Overloading}).  Occasionally, however, one needs to undo
@@ -1235,17 +1395,17 @@ environment.
 @node Inline Functions
 @subsection Inline Functions
 
 An inline function is created from a string containing the function
 body using the @code{inline} function.  The following code defines the
 function @math{f(x) = x^2 + 2}.
 
 @example
-f = inline("x^2 + 2");
+f = inline ("x^2 + 2");
 @end example
 
 @noindent
 After this it is possible to evaluate @math{f} at any @math{x} by
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
@@ -1265,17 +1425,17 @@ it can also be called without the parent
 @example
 my_command hello world
 @end example
 
 @noindent
 is equivalent to 
 
 @example
-my_command("hello", "world")
+my_command ("hello", "world")
 @end example
 
 @noindent
 The general form of a command call is
 
 @example
 @var{cmdname} @var{arg1} @var{arg2} @dots{}
 @end example
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -67,17 +67,17 @@ An example of a Delaunay triangulation o
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 T = delaunay (x, y);
 X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
 Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
 axis ([0, 1, 0, 1]);
-plot(X, Y, "b", x, y, "r*");
+plot (X, Y, "b", x, y, "r*");
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:delaunay}.
 
 @float Figure,fig:delaunay
@@ -167,28 +167,28 @@ sum (@var{beta}(1:@var{N}+1)) == 1
 @end example
 
 @noindent
 is imposed, and we can therefore write the above as
 
 @example
 @group
 @var{p} - @var{t}(end, :) = @var{beta}(1:end-1) * (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :)
+      - ones (@var{N}, 1) * @var{t}(end, :)
 @end group
 @end example
 
 @noindent
 Solving for @var{beta} we can then write
 
 @example
 @group
 @var{beta}(1:end-1) = (@var{p} - @var{t}(end, :)) / (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :))
-@var{beta}(end) = sum(@var{beta}(1:end-1))
+      - ones (@var{N}, 1) * @var{t}(end, :))
+@var{beta}(end) = sum (@var{beta}(1:end-1))
 @end group
 @end example
 
 @noindent
 which gives the formula for the conversion of the Cartesian coordinates
 of the point @var{p} to the Barycentric coordinates @var{beta}.  An
 important property of the Barycentric coordinates is that for all points
 in the N-simplex
@@ -293,19 +293,19 @@ simplices of the Delaunay tessellation.
 @DOCSTRING(voronoi)
 
 @DOCSTRING(voronoin)
 
 An example of the use of @code{voronoi} is
 
 @example
 @group
-rand("state",9);
-x = rand(10,1);
-y = rand(10,1);
+rand ("state",9);
+x = rand (10,1);
+y = rand (10,1);
 tri = delaunay (x, y);
 [vx, vy] = voronoi (x, y, tri);
 triplot (tri, x, y, "b");
 hold on;
 plot (vx, vy, "r");
 @end group
 @end example
 
@@ -331,17 +331,17 @@ with the @code{polyarea} and @code{inpol
 An example of the use of @code{polyarea} might be 
 
 @example
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 [c, f] = voronoin ([x, y]);
-af = zeros (size(f));
+af = zeros (size (f));
 for i = 1 : length (f)
   af(i) = polyarea (c (f @{i, :@}, 1), c (f @{i, :@}, 2));
 endfor
 @end group
 @end example
 
 Facets of the Voronoi diagram with a vertex at infinity have infinity
 area.  A simplified version of @code{polyarea} for rectangles is
@@ -356,17 +356,17 @@ An example of the use of @code{inpolygon
 @example
 @group
 randn ("state", 2);
 x = randn (100, 1);
 y = randn (100, 1);
 vx = cos (pi * [-1 : 0.1: 1]);
 vy = sin (pi * [-1 : 0.1 : 1]);
 in = inpolygon (x, y, vx, vy);
-plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
+plot (vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
 axis ([-2, 2, -2, 2]);
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:inpolygon}.
 
@@ -429,22 +429,22 @@ interpolation are @code{griddata}, @code
 @DOCSTRING(griddata3)
 
 @DOCSTRING(griddatan)
 
 An example of the use of the @code{griddata} function is
 
 @example
 @group
-rand("state",1);
-x=2*rand(1000,1)-1;
-y=2*rand(size(x))-1;
-z=sin(2*(x.^2+y.^2));
-[xx,yy]=meshgrid(linspace(-1,1,32));
-griddata(x,y,z,xx,yy);
+rand ("state", 1);
+x = 2*rand (1000,1) - 1;
+y = 2*rand (size (x)) - 1;
+z = sin (2*(x.^2+y.^2));
+[xx,yy] = meshgrid (linspace (-1,1,32));
+griddata (x,y,z,xx,yy);
 @end group
 @end example
 
 @noindent
 that interpolates from a random scattering of points, to a uniform
 grid. 
 @ifnotinfo
 The output of the above can be seen in @ref{fig:griddata}.
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -69,17 +69,17 @@ yourself.
 * Build Tools::
 * External Packages::
 @end menu
 
 @node Obtaining the Dependencies Automatically
 @subsection Obtaining the Dependencies Automatically
 
 On some systems you can obtain many of Octave's build dependencies
-automatically. The commands for doing this vary by system. Similarly,
+automatically.  The commands for doing this vary by system.  Similarly,
 the names of pre-compiled packages vary by system and do not always
 match exactly the names listed in @ref{Build Tools} and @ref{External
 Packages}.
 
 You will usually need the development version of an external dependency
 so that you get the libraries and header files for building software,
 not just for running already compiled programs.  These packages
 typically have names that end with the suffix @code{-dev} or @code{-devel}.
@@ -177,18 +177,20 @@ Automake.
 The following external packages are required:
 
 @table @asis
 @item BLAS
 Basic Linear Algebra Subroutine library
 (@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
 ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
 better performance.
+
 @item LAPACK
 Linear Algebra Package (@url{http://www.netlib.org/lapack}).
+
 @item PCRE
 The Perl Compatible Regular Expression library (http://www.pcre.org).
 @end table
 
 The following external package is optional but strongly recommended:
 
 @table @asis
 @item GNU Readline
@@ -244,17 +246,17 @@ GraphicsMagick++ is used to provide the 
 functions.
 
 @item HDF5
 Library for manipulating portable data files
 (@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
 @code{load} and @code{save} commands to read and write HDF data files.
 
 @item OpenGL
-API for portable 2D and 3D graphics (@url{http://www.opengl.org}).  An
+API for portable 2-D and 3-D graphics (@url{http://www.opengl.org}).  An
 OpenGL implementation is required to provide Octave's OpenGL-based
 graphics functions.  Octave's OpenGL-based graphics functions usually
 outperform the gnuplot-based graphics functions because plot data can be
 rendered directly instead of sending data and commands to gnuplot for
 interpretation and rendering.
 
 @item Qhull
 Computational geometry library (@url{http://www.qhull.org}).  Qhull is
@@ -272,17 +274,17 @@ provide improved performance for the fun
 Sparse matrix factorization library
 (@url{http://www.cise.ufl.edu/research/sparse/SuiteSparse}).
 SuiteSparse is required to provide sparse matrix factorizations and
 solution of linear equations for sparse systems.
 
 @item zlib
 Data compression library (@url{http://zlib.net}).  The zlib library is
 required for Octave's @code{load} and @code{save} commands to handle
-compressed data, including @sc{Matlab} v5 MAT files.
+compressed data, including @sc{matlab} v5 MAT files.
 @end table
 
 @node Running Configure and Make
 @section Running Configure and Make
 
 @itemize @bullet
 @item
 Run the shell script @file{configure}.  This will determine the features
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -45,27 +45,27 @@ discontinuous, then 'pchip' interpolatio
 This can be demonstrated by the code
 
 @example
 @group
 t = -2:2;
 dt = 1;
 ti =-2:0.025:2;
 dti = 0.025;
-y = sign(t);
-ys = interp1(t,y,ti,'spline');
-yp = interp1(t,y,ti,'pchip');
-ddys = diff(diff(ys)./dti)./dti;
-ddyp = diff(diff(yp)./dti)./dti;
-figure(1);
-plot (ti, ys,'r-', ti, yp,'g-');
-legend('spline','pchip',4);
-figure(2);
-plot (ti, ddys,'r+', ti, ddyp,'g*');
-legend('spline','pchip');
+y = sign (t);
+ys = interp1 (t,y,ti,'spline');
+yp = interp1 (t,y,ti,'pchip');
+ddys = diff (diff (ys)./dti) ./ dti;
+ddyp = diff (diff (yp)./dti) ./ dti;
+figure (1);
+plot (ti,ys,'r-', ti,yp,'g-');
+legend ('spline', 'pchip', 4);
+figure (2);
+plot (ti,ddys,'r+', ti,ddyp,'g*');
+legend ('spline', 'pchip');
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:interpderiv1} and
 @ref{fig:interpderiv2}.
 
@@ -102,19 +102,19 @@ points.  An example of the use of @code{
 
 @example
 @group
 t = 0 : 0.3 : pi; dt = t(2)-t(1);
 n = length (t); k = 100;
 ti = t(1) + [0 : k-1]*dt*n/k;
 y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
+plot (ti, yp, 'g', ti, interp1 (t, y, ti, 'spline'), 'b', ...
       ti, interpft (y, k), 'c', t, y, 'r+');
-legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
+legend ('sin(4t+0.3)cos(3t-0.1', 'spline', 'interpft', 'data');
 @end group
 @end example
 
 @noindent
 @ifinfo
 which demonstrates the poor behavior of Fourier interpolation for non-periodic
 functions.
 @end ifinfo
@@ -159,19 +159,19 @@ Consider the example,
 @example
 @group
 x = y = z = -1:1;
 f = @@(x,y,z) x.^2 - y - z.^2;
 [xx, yy, zz] = meshgrid (x, y, z);
 v = f (xx,yy,zz);
 xi = yi = zi = -1:0.1:1;
 [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-vi = interp3(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi = interp3 (x, y, z, v, xxi, yyi, zzi, 'spline');
 [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-vi2 = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi2 = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
 mesh (zi, yi, squeeze (vi2(1,:,:)));
 @end group
 @end example
 
 @noindent
 where @code{vi} and @code{vi2} are identical.  The reversal of the
 dimensions is treated in the @code{meshgrid} and @code{ndgrid} functions
 respectively.
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -99,17 +99,17 @@ e     = -1
 @end display
 @end ifnottex
 
 @noindent
 type the following which will evaluate to @code{-1} within the
 tolerance of the calculation. 
 
 @example
-octave:1> exp(i*pi)
+octave:1> exp (i*pi)
 @end example
 
 @subsection Creating a Matrix
 
 Vectors and matrices are the basic building blocks for numerical analysis.  
 To create a new matrix and store it in a variable so that you can
 refer to it later, type the command
 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -565,17 +565,17 @@ can't be represented using the chosen in
 not possible to represent the result of @math{10 - 20} when using
 unsigned integers.  Octave makes sure that the result of integer
 computations is the integer that is closest to the true result.  So, the
 result of @math{10 - 20} when using unsigned integers is zero.
 
 When doing integer division Octave will round the result to the nearest
 integer.  This is different from most programming languages, where the
 result is often floored to the nearest integer.  So, the result of
-@code{int32(5) ./ int32(8)} is @code{1}.
+@code{int32 (5) ./ int32 (8)} is @code{1}.
 
 @DOCSTRING(idivide)
 
 @node Bit Manipulations
 @section Bit Manipulations
 
 Octave provides a number of functions for the manipulation of numeric
 values on a bit by bit basis.  The basic functions to set and obtain the
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -179,17 +179,17 @@ An example of a display method for the p
 @example
 @group
 @EXAMPLEFILE(@polynomial/display.m)
 @end group
 @end example
 
 @noindent
 Note that in the display method, it makes sense to start the method
-with the line @code{fprintf("%s =", inputname(1))} to be consistent
+with the line @code{fprintf ("%s =", inputname (1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
 when displaying the class. 
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
 all of the properties of the class.  For example:
@@ -312,17 +312,17 @@ look like
 
 @noindent
 which is a fairly generic @code{end} method that has a behavior similar to
 the @code{end} keyword for Octave Array classes.  It can then be used as 
 follows:
 
 @example
 @group
-p = polynomial([1,2,3,4]);
+p = polynomial ([1,2,3,4]);
 p(end-1)
   @result{} 3
 @end group
 @end example
 
 Objects can also be used as the index in a subscripted expression themselves
 and this is controlled with the @code{subsindex} function.
 
@@ -349,17 +349,17 @@ a call to subsasgn:
 
 @noindent
 and the corresponding method looking like this:
 
 @example
 @group
   function x = subsasgn (x, ss, val)
     @dots{}
-    x.myfield(ss.subs@{1@}) = val;
+    x.myfield (ss.subs@{1@}) = val;
   endfunction
 @end group
 @end example
 
 The problem is that on entry to the subsasgn method, @code{x} is still
 referenced from the caller's scope, which means that the method will 
 first need to unshare (copy) @code{x} and @code{x.myfield} before performing
 the assignment.  Upon completing the call, unless an error occurs,
@@ -721,25 +721,25 @@ Note that we have used the polynomial fi
 the filter coefficients.
 
 Once we have the class constructor and display method, we may create
 an object by calling the class constructor.  We may also check the
 class type and examine the underlying structure.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3))
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3))
 f.polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
-octave:2> class(f)
+octave:2> class (f)
 ans = FIRfilter
-octave:3> isa(f,"FIRfilter")
+octave:3> isa (f,"FIRfilter")
 ans =  1
-octave:4> isa(f,"polynomial")
+octave:4> isa (f,"polynomial")
 ans =  1
-octave:5> struct(f)
+octave:5> struct (f)
 ans = 
 @{
 polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @}
 @end group
 @end example
 
 We only need to define a method to actually process data with our
@@ -754,34 +754,34 @@ to access the fields.  The @code{subsref
 @end group
 @end example
 
 The "()" case allows us to filter data using the polynomial provided
 to the constructor.
 
 @example
 @group
-octave:2> f=FIRfilter(polynomial([1 1 1]/3));
-octave:3> x=ones(5,1);
-octave:4> y=f(x)
+octave:2> f = FIRfilter (polynomial ([1 1 1]/3));
+octave:3> x = ones (5,1);
+octave:4> y = f(x)
 y =
 
    0.33333
    0.66667
    1.00000
    1.00000
    1.00000
 @end group
 @end example
 
 The "." case allows us to view the contents of the polynomial field.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3));
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3));
 octave:2> f.polynomial
 ans = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @end group
 @end example
 
 In order to change the contents of the object, we need to define a
 @code{subsasgn} method.  For example, we may make the polynomial field
 publicly writable.
@@ -791,23 +791,22 @@ publicly writable.
 @EXAMPLEFILE(@FIRfilter/subsasgn.m)
 @end group
 @end example
 
 So that
 
 @example
 @group
-octave:6> f=FIRfilter ();
-octave:7> f.polynomial = polynomial([1 2 3]);
+octave:6> f = FIRfilter ();
+octave:7> f.polynomial = polynomial ([1 2 3]);
 f.polynomial = 1 + 2 * X + 3 * X ^ 2
 @end group
 @end example
 
-
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
 polynomial may be used.  This is not a normal use of a filter, so that
 aggregation may be a more sensible design approach.  In this case, the
 polynomial is simply a field in the class structure.  A class
 constructor for this case might be
 
 @example
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2012 SÔøΩren Hauberg
+@c Copyright (C) 2007-2012 S√∏ren Hauberg
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -176,17 +176,16 @@ called without a new path, the current p
 @node Creating Packages
 @section Creating Packages
 
 Internally a package is simply a gzipped tar file that contains a
 top level directory of any given name.  This directory will in the
 following be referred to as @code{package} and may contain the
 following files:
 
-@noindent
 @table @code
 @item package/COPYING
 This is a required file containing the license of the package.  No
 restrictions is made on the license in general.  If however the
 package contains dynamically linked functions the license must be
 compatible with the GNU General Public License.
 
 @item package/DESCRIPTION
@@ -255,17 +254,16 @@ package.
 @item package/on_uninstall.m
 This is an optional script that is run prior to the removal of a
 package. 
 @end table
 
 Besides the above mentioned files, a package can also contain on or
 more of the following directories:
 
-@noindent
 @table @code
 @item package/inst
 An optional directory containing any files that are directly installed
 by the package.  Typically this will include any @code{m}-files. 
 
 @item package/src
 An optional directory containing code that must be built prior to the
 packages installation.  The Octave package manager will execute
@@ -300,17 +298,16 @@ external scripts, etc., called by functi
 
 @node The DESCRIPTION File
 @subsection The DESCRIPTION File
 
 The @file{DESCRIPTION} file contains various information about the
 package, such as its name, author, and version.  This file has a very
 simple format
 
-@noindent
 @itemize
 @item
 Lines starting with @samp{#} are comments.
 
 @item
 Lines starting with a blank character are continuations from the 
 previous line.
 
@@ -335,17 +332,16 @@ Description: A short description of the 
  on the next by adding a space to the beginning of the
  following lines.
 License: GPL version 3 or later
 @end group
 @end example
 
 The package manager currently recognizes the following keywords
 
-@noindent
 @table @code
 @item Name
 Name of the package.
 
 @item Version
 Version of the package.  A package version must be 3 numbers separated
 by a dot.
 
@@ -436,17 +432,16 @@ RPMs are built on a Mandriva distributio
 name will be used instead. 
 
 @node The INDEX File
 @subsection The INDEX File
 
 The optional @file{INDEX} file provides a categorical view of the
 functions in the package.  This file has a very simple format
 
-@noindent
 @itemize
 @item Lines beginning with @samp{#} are comments.
 
 @item The first non-comment line should look like this
 
 @example
 toolbox >> Toolbox name
 @end example
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -806,21 +806,21 @@ width 0.6pt \tabskip=0pt\cr
 @caption{Available special characters in @TeX{} mode}
 @end float
 
 A complete example showing the capabilities of the extended text is
 
 @example
 @group
 x = 0:0.01:3;
-plot(x,erf(x));
+plot (x, erf (x));
 hold on;
-plot(x,x,"r");
-axis([0, 3, 0, 1]);
-text(0.65, 0.6175, strcat('\leftarrow x = @{2/\surd\pi',
+plot (x,x,"r");
+axis ([0, 3, 0, 1]);
+text (0.65, 0.6175, strcat ('\leftarrow x = @{2/\surd\pi',
 ' @{\fontsize@{16@}\int_@{\fontsize@{8@}0@}^@{\fontsize@{8@}x@}@}',
 ' e^@{-t^2@} dt@} = 0.6175'))
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:extendedtext}
@@ -839,17 +839,17 @@ The result of which can be seen in @ref{
 The @code{print} command allows you to send plots to you printer and
 to save plots in a variety of formats.  For example,
 
 @example
 print -dpsc
 @end example
 
 @noindent
-prints the current figure to a color PostScript printer. And,
+prints the current figure to a color PostScript printer.  And,
 
 @example
 print -deps foo.eps
 @end example
 
 @noindent
 saves the current figure to an encapsulated PostScript file called
 @file{foo.eps}.
@@ -1175,16 +1175,17 @@ In this Section the object properties ar
 with the root figure properties and continuing through the graphics object
 hierarchy.
 
 @node Root Figure Properties
 @subsubsection Root Figure Properties
 @cindex root figure properties
 
 The @code{root figure} properties are:
+
 @table @code
 @item __modified__  
 --- Values: "on," "off"
 
 @item __myhandle__
 
 @item beingdeleted  
 --- Values: "on," "off"
@@ -1247,16 +1248,17 @@ The @code{root figure} properties are:
 @item visible
 @end table
 
 @node Figure Properties
 @subsubsection Figure Properties
 @cindex figure properties
 
 The @code{figure} properties are:
+
 @table @code
 @item __graphics_toolkit__  
 --- The graphics toolkit currently in use.
 
 @item __enhanced__
 
 @item __modified__
 
@@ -1330,16 +1332,17 @@ mouse pointer is when the function gets 
 see @code{"keypressfcn"}
 
 @item keyreleasefcn
 With @code{"keypressfcn"}, The keyboard callback functions.  These
 callback functions get called when a key is pressed/released
 respectively.  The functions are called with two input arguments.  The
 first argument holds the handle of the calling figure.  The second
 argument holds the event structure which has the following members:
+
 @table @code
 @item Character
 The ASCII value of the key
 
 @item Key
 lowercase value of the key
 
 @item Modifier
@@ -1351,16 +1354,17 @@ the key.  Possible values are @code{"shi
 @item menubar
 
 @item mincolormap
 
 @item name
 
 @item nextplot
 May be one of
+
 @table @code
 @item "new"
 
 @item "add"
 
 @item "replace"
 
 @item "replacechildren"
@@ -1446,16 +1450,17 @@ holds the current coordinates of the cur
 @item xvisualmode
 @end table
 
 @node Axes Properties
 @subsubsection Axes Properties
 @cindex axes properties
 
 The @code{axes} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item activepositionproperty
 
 @item alim
@@ -1575,16 +1580,17 @@ Octave.
 @item linestyleorder
 
 @item linewidth
 
 @item minorgridlinestyle
 
 @item nextplot
 May be one of
+
 @table @code
 @item "new"
 
 @item "add"
 
 @item "replace"
 
 @item "replacechildren"
@@ -1791,16 +1797,17 @@ Either @code{"manual"} or @code{"auto"}.
 
 @end table
 
 @node Line Properties
 @subsubsection Line Properties
 @cindex line properties
 
 The @code{line} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item beingdeleted
 
 @item busyaction
@@ -1902,16 +1909,17 @@ The data to be plotted.
 @item zliminclude
 @end table
 
 @node Text Properties
 @subsubsection Text Properties
 @cindex text properties
 
 The @code{text} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item backgroundcolor
 
 @item beingdeleted
@@ -2019,16 +2027,17 @@ May be @code{"normalized"} or @code{"gra
 
 @end table
 
 @node Image Properties
 @subsubsection Image Properties
 @cindex image properties
 
 The @code{image} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item beingdeleted
 
 @item busyaction
@@ -2095,16 +2104,17 @@ the image.
 @item yliminclude
 @end table
 
 @node Patch Properties
 @subsubsection Patch Properties
 @cindex patch properties
 
 The @code{patch} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item alim
 
 @item aliminclude
@@ -2243,16 +2253,17 @@ Data defining the patch object.
 
 @end table
 
 @node Surface Properties
 @subsubsection Surface Properties
 @cindex surface properties
 
 The @code{surface} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item alim
 
 @item aliminclude
@@ -2518,16 +2529,17 @@ one, or by name.  Recognized color names
 @cindex line styles, graphics
 @cindex graphics line styles
 
 Line styles are specified by the following properties:
 
 @table @code
 @item linestyle
 May be one of
+
 @table @code
 @item "-"
 Solid line.  [default]
 
 @item "--"
 Dashed line.
 
 @item ":"
@@ -2546,16 +2558,17 @@ of 2 is twice as wide as the default, et
 @end table
 
 @node Marker Styles
 @subsection Marker Styles
 @cindex graphics marker styles
 @cindex marker styles, graphics
 
 Marker styles are specified by the following properties:
+
 @table @code
 @item marker
 A character indicating a plot marker to be place at each data point, or
 @code{"none"}, meaning no markers should be displayed.
 
 @itemx markeredgecolor
 The color of the edge around the marker, or @code{"auto"}, meaning that
 the edge color is the same as the face color.  @xref{Colors}.
@@ -2592,17 +2605,17 @@ endfunction
 
 @noindent
 where @code{src} gives a handle to the source of the callback, and
 @code{code} gives some event specific data.  This can then be associated
 with an object either at the objects creation or later with the
 @code{set} function.  For example,
 
 @example
-plot (x, "DeleteFcn", @@(s, e) disp("Window Deleted"))
+plot (x, "DeleteFcn", @@(s, e) disp ("Window Deleted"))
 @end example
 
 @noindent
 where at the moment that the plot is deleted, the message "Window
 Deleted" will be displayed.
 
 Additional user arguments can be passed to callback functions, and will
 be passed after the 2 default arguments.  For example:
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -49,18 +49,18 @@ p(x) = @var{c}(1) x^@var{N} + @dots{} + 
 @node Evaluating Polynomials
 @section Evaluating Polynomials
 
 The value of a polynomial represented by the vector @var{c} can be evaluated
 at the point @var{x} very easily, as the following example shows:
 
 @example
 @group
-N = length(c)-1;
-val = dot( x.^(N:-1:0), c );
+N = length (c) - 1;
+val = dot (x.^(N:-1:0), c);
 @end group
 @end example
 
 @noindent
 While the above example shows how easy it is to compute the value of a
 polynomial, it isn't the most stable algorithm.  With larger polynomials
 you should use more elegant algorithms, such as Horner's Method, which
 is exactly what the Octave function @code{polyval} does.
@@ -109,18 +109,18 @@ for a definition), and then finding its 
 Octave comes with functions for computing the derivative and the integral
 of a polynomial.  The functions @code{polyder} and @code{polyint}
 both return new polynomials describing the result.  As an example we'll
 compute the definite integral of @math{p(x) = x^2 + 1} from 0 to 3.
 
 @example
 @group
 c = [1, 0, 1];
-integral = polyint(c);
-area = polyval(integral, 3) - polyval(integral, 0)
+integral = polyint (c);
+area = polyval (integral, 3) - polyval (integral, 0)
 @result{} 12
 @end group
 @end example
 
 @DOCSTRING(polyder)
 
 @DOCSTRING(polyint)
 
@@ -144,17 +144,17 @@ In situations where a single polynomial 
 is to use several polynomials pieced together.  The function
 @code{splinefit} fits a peicewise polynomial (spline) to a set of
 data.
 
 @DOCSTRING(splinefit)
 
 The number of @var{breaks} (or knots) used to construct the piecewise
 polynomial is a significant factor in suppressing the noise present in
-the input data, @var{x} and @var{y}. This is demostrated by the example
+the input data, @var{x} and @var{y}.  This is demonstrated by the example
 below.
 
 @example
 @group
 x = 2 * pi * rand (1, 200);
 y = sin (x) + sin (2 * x) + 0.2 * randn (size (x));
 ## Uniform breaks
 breaks = linspace (0, 2 * pi, 41); % 41 breaks, 40 pieces
@@ -174,28 +174,27 @@ legend (@{"data", "41 breaks, 40 pieces"
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit1}.
 
 @float Figure,fig:splinefit1
 @center @image{splinefit1,4in}
 @caption{Comparison of a fitting a piecewise polynomial with 41 breaks to one
-with 11 breaks. The fit with the large number of breaks exhibits a fast ripple
+with 11 breaks.  The fit with the large number of breaks exhibits a fast ripple
 that is not present in the underlying function.}
 @end float
 @end ifnotinfo
 
-The piece-wise polynomial fit, provided by @code{splinefit}, has
-continuous derivatives up to the @var{order}-1. For example, a cubic fit
-has continuous first and second derivatives.   This is demonstrated by
+The piecewise polynomial fit, provided by @code{splinefit}, has
+continuous derivatives up to the @var{order}-1.  For example, a cubic fit
+has continuous first and second derivatives.  This is demonstrated by
 the code
 
 @example
-@group
 ## Data (200 points)
 x = 2 * pi * rand (1, 200);
 y = sin (x) + sin (2 * x) + 0.1 * randn (size (x));
 ## Piecewise constant
 pp1 = splinefit (x, y, 8, "order", 0);
 ## Piecewise linear
 pp2 = splinefit (x, y, 8, "order", 1);
 ## Piecewise quadratic
@@ -210,27 +209,26 @@ y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 y3 = ppval (pp3, xx);
 y4 = ppval (pp4, xx);
 y5 = ppval (pp5, xx);
 plot (x, y, ".", xx, [y1; y2; y3; y4; y5])
 axis tight
 ylim auto
 legend (@{"data", "order 0", "order 1", "order 2", "order 3", "order 4"@})
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit2}.
 
 @float Figure,fig:splinefit2
 @center @image{splinefit2,4in}
 @caption{Comparison of a piecewise constant, linear, quadratic, cubic, and
-quartic polynomials with 8 breaks to noisy data. The higher order solutions
+quartic polynomials with 8 breaks to noisy data.  The higher order solutions
 more accurately represent the underlying function, but come with the
 expense of computational complexity.}
 @end float
 @end ifnotinfo
 
 When the underlying function to provide a fit to is periodic, @code{splinefit}
 is able to apply the boundary conditions needed to manifest a periodic fit.
 This is demonstrated by the code below.
@@ -261,22 +259,21 @@ The result of which can be seen in @ref{
 
 @float Figure,fig:splinefit3
 @center @image{splinefit3,4in}
 @caption{Comparison of piecewise polynomial fits to a noisy periodic
 function with, and without, periodic boundary conditions.}
 @end float
 @end ifnotinfo
 
-More complex constraints may be added as well. For example, the code below
-illustrates a periodic fit with values that have been clamped at the end points,
-and a second periodic fit which is hinged at the end points.
+More complex constraints may be added as well.  For example, the code below
+illustrates a periodic fit with values that have been clamped at the endpoints,
+and a second periodic fit which is hinged at the endpoints.
 
 @example
-@group
 ## Data (200 points)
 x = 2 * pi * rand (1, 200);
 y = sin (2 * x) + 0.1 * randn (size (x));
 ## Breaks
 breaks = linspace (0, 2 * pi, 10);
 ## Clamped endpoints, y = y' = 0
 xc = [0, 0, 2*pi, 2*pi];
 cc = [(eye (2)), (eye (2))];
@@ -288,38 +285,36 @@ pp2 = splinefit (x, y, breaks, "constrai
 ## Plot
 xx = linspace (0, 2 * pi, 400);
 y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 plot (x, y, ".", xx, [y1; y2])
 axis tight
 ylim auto
 legend (@{"data", "clamped", "hinged periodic"@})
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit4}.
 
 @float Figure,fig:splinefit4
 @center @image{splinefit4,4in}
 @caption{Comparison of two periodic piecewise cubic fits to a noisy periodic
-signal. One fit has its end points clamped and the second has its end points
+signal.  One fit has its endpoints clamped and the second has its endpoints
 hinged.}
 @end float
 @end ifnotinfo
 
 The @code{splinefit} function also provides the convenience of a @var{robust}
 fitting, where the effect of outlying data is reduced.  In the example below,
 three different fits are provided.  Two with differing levels of outlier
 suppression and a third illustrating the non-robust solution.
 
 @example
-@group
 ## Data
 x = linspace (0, 2*pi, 200);
 y = sin (x) + sin (2 * x) + 0.05 * randn (size (x));
 ## Add outliers
 x = [x, linspace(0,2*pi,60)];
 y = [y, -ones(1,60)];
 ## Fit splines with hinged conditions
 con = struct ("xc", [0, 2*pi]);
@@ -334,26 +329,25 @@ xx = linspace (0, 2*pi, 400);
 y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 y3 = ppval (pp3, xx);
 plot (x, y, ".", xx, [y1; y2; y3])
 legend (@{"data with outliers","robust, beta = 0.25", ...
          "robust, beta = 0.75", "no robust fitting"@})
 axis tight
 ylim auto
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit6}.
 
 @float Figure,fig:splinefit6
 @center @image{splinefit6,4in}
-@caption{Comparison of two different levels of robust fitting (@var{beta} = 0.25 and 0.75) to noisy data combined with outlying data. A conventional fit, without
+@caption{Comparison of two different levels of robust fitting (@var{beta} = 0.25 and 0.75) to noisy data combined with outlying data.  A conventional fit, without
 robust fitting (@var{beta} = 0) is also included.}
 @end float
 @end ifnotinfo
 
 The function, @code{ppval}, evaluates the piecewise polynomials, created
 by @code{mkpp} or other means, and @code{unmkpp} returns detailed
 information about the piecewise polynomial.
 
@@ -362,20 +356,20 @@ quadratic into one function.  Each of th
 on adjoined intervals.
 
 @example
 @group
 x = [-2, -1, 1, 2];
 p = [ 0,  1, 0;
       1, -2, 1;
       0, -1, 1 ];
-pp = mkpp(x, p);
-xi = linspace(-2, 2, 50);
-yi = ppval(pp, xi);
-plot(xi, yi);
+pp = mkpp (x, p);
+xi = linspace (-2, 2, 50);
+yi = ppval (pp, xi);
+plot (xi, yi);
 @end group
 @end example
 
 @DOCSTRING(mkpp)
 
 @DOCSTRING(unmkpp)
 
 @DOCSTRING(ppval)
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -333,17 +333,17 @@ using @math{n} points by
 @tex
 $$
  \int_0^1 \int_0^1 f(x,y) d x d y \approx \sum_{i=1}^n \sum_{j=1}^n q_i q_j f(r_i, r_j),
 $$
 @end tex
 @ifnottex
 the sum over @code{i=1:n} and @code{j=1:n} of @code{q(i)*q(j)*f(r(i),r(j))},
 @end ifnottex
-where @math{q} and @math{r} is as returned by @code{colloc(n)}.  The
+where @math{q} and @math{r} is as returned by @code{colloc (n)}.  The
 generalization to more than two variables is straight forward.  The
 following code computes the studied integral using @math{n=8} points.
 
 @example
 @group
 f = @@(x,y) sin (pi*x*y') .* sqrt (x*y');
 n = 8;
 [t, ~, ~, q] = colloc (n);
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -35,17 +35,17 @@ represented as a vector of numbers.
 Octave supports the basic set operations.  That is, Octave can compute
 the union, intersection, and difference of two sets.
 Octave also supports the @emph{Exclusive Or} set operation, and
 membership determination.  The functions for set operations all work in
 pretty much the same way.  As an example, assume that @code{x} and
 @code{y} contains two sets, then
 
 @example
-union(x, y)
+union (x, y)
 @end example
 
 @noindent
 computes the union of the two sets.
 
 @DOCSTRING(ismember)
 
 @DOCSTRING(union)
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -101,17 +101,17 @@ In fact, the column index contains one m
 columns, with the first element always being zero.  The advantage of
 this is a simplification in the code, in that there is no special case
 for the first or last columns.  A short example, demonstrating this in
 C is.
 
 @example
 @group
   for (j = 0; j < nc; j++)
-    for (i = cidx (j); i < cidx(j+1); i++)
+    for (i = cidx(j); i < cidx(j+1); i++)
        printf ("non-zero element (%i,%i) is %d\n", 
            ridx(i), j, data(i));
 @end group
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix.  Consider the matrix
 
@@ -207,17 +207,17 @@ creates an @var{r}-by-@var{c} sparse mat
 elements of @var{d}.
 
 Other functions of interest that directly create sparse matrices, are
 @dfn{diag} or its generalization @dfn{spdiags}, that can take the
 definition of the diagonals of the matrix and create the sparse matrix 
 that corresponds to this.  For example,
 
 @example
-s = diag (sparse(randn(1,n)), -1);
+s = diag (sparse (randn (1,n)), -1);
 @end example
 
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
@@ -343,32 +343,32 @@ determines the means to solve the equati
 matrix as discussed in @ref{Sparse Linear Algebra}.  Octave probes the
 matrix type when the div (/) or ldiv (\) operator is first used with
 the matrix and then caches the type.  However the @dfn{matrix_type}
 function can be used to determine the type of the sparse matrix prior
 to use of the div or ldiv operators.  For example,
 
 @example
 @group
-a = tril (sprandn(1024, 1024, 0.02), -1) ...
-    + speye(1024); 
+a = tril (sprandn (1024, 1024, 0.02), -1) ...
+    + speye (1024); 
 matrix_type (a);
 ans = Lower
 @end group
 @end example
 
 @noindent
 shows that Octave correctly determines the matrix type for lower
 triangular matrices.  @dfn{matrix_type} can also be used to force
 the type of a matrix to be a particular type.  For example:
 
 @example
 @group
 a = matrix_type (tril (sprandn (1024, ...
-   1024, 0.02), -1) + speye(1024), 'Lower');
+   1024, 0.02), -1) + speye (1024), "Lower");
 @end group
 @end example
 
 This allows the cost of determining the matrix type to be
 avoided.  However, incorrectly defining the matrix type will result in
 incorrect results from solutions of linear equations, and so it is
 entirely the responsibility of the user to correctly identify the
 matrix type
@@ -393,20 +393,20 @@ ji-th node) of the sparse adjacency matr
 is then associated with a set of coordinates, then the @dfn{gplot}
 command can be used to graphically display the interconnections
 between nodes.
 
 As a trivial example of the use of @dfn{gplot} consider the example,
 
 @example
 @group
-A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
+A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
     [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
 xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
-gplot(A,xy)
+gplot (A,xy)
 @end group
 @end example
 
 @noindent
 which creates an adjacency matrix @code{A} where node 1 is connected
 to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
 the nodes are given in the n-by-2 matrix @code{xy}.
 @ifset htmltex 
@@ -417,18 +417,18 @@ the nodes are given in the n-by-2 matrix
 @caption{Simple use of the @dfn{gplot} command.}
 @end float
 @end ifset
 
 The dependencies between the nodes of a Cholesky@tie{}factorization can be
 calculated in linear time without explicitly needing to calculate the
 Cholesky@tie{}factorization by the @code{etree} command.  This command
 returns the elimination tree of the matrix and can be displayed
-graphically by the command @code{treeplot(etree(A))} if @code{A} is
-symmetric or @code{treeplot(etree(A+A'))} otherwise.
+graphically by the command @code{treeplot (etree (A))} if @code{A} is
+symmetric or @code{treeplot (etree (A+A'))} otherwise.
 
 @DOCSTRING(spy)
 
 @DOCSTRING(etree)
 
 @DOCSTRING(etreeplot)
 
 @DOCSTRING(gplot)
@@ -514,17 +514,17 @@ Therefore, there is a certain density of
 where it no longer makes sense to store it as a sparse matrix, but rather
 as a full matrix.  For this reason operators and functions that have a 
 high probability of returning a full matrix will always return one.  For
 example adding a scalar constant to a sparse matrix will almost always
 make it a full matrix, and so the example,
 
 @example
 @group
-speye(3) + 0
+speye (3) + 0
 @result{}   1  0  0
   0  1  0
   0  0  1
 @end group
 @end example
 
 @noindent
 returns a full matrix as can be seen. 
@@ -536,27 +536,27 @@ amount of storage used is larger than th
 equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
 
 As all of the mixed operators and functions between full and sparse 
 matrices exist, in general this does not cause any problems.  However,
 one area where it does cause a problem is where a sparse matrix is
 promoted to a full matrix, where subsequent operations would resparsify
 the matrix.  Such cases are rare, but can be artificially created, for
-example @code{(fliplr(speye(3)) + speye(3)) - speye(3)} gives a full
+example @code{(fliplr (speye (3)) + speye (3)) - speye (3)} gives a full
 matrix when it should give a sparse one.  In general, where such cases 
 occur, they impose only a small memory penalty.
 
 There is however one known case where this behavior of Octave's
 sparse matrices will cause a problem.  That is in the handling of the
 @dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
 depending on the type of its input arguments.  So 
 
 @example
- a = diag (sparse([1,2,3]), -1);
+ a = diag (sparse ([1,2,3]), -1);
 @end example
 
 @noindent
 should return a sparse matrix.  To ensure this actually happens, the
 @dfn{sparse} function, and other functions based on it like @dfn{speye}, 
 always returns a sparse matrix, even if the memory used will be larger 
 than its full representation.
 
@@ -650,17 +650,17 @@ positive definite matrix.
 @float Figure,fig:simplematrix
 @center @image{spmatrix,4in}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 The standard Cholesky@tie{}factorization of this matrix can be
 obtained by the same command that would be used for a full
 matrix.  This can be visualized with the command 
-@code{r = chol(A); spy(r);}.
+@code{r = chol (A); spy (r);}.
 @xref{fig:simplechol}.
 The original matrix had 
 @ifinfo
 @ifnothtml
 43
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
@@ -677,47 +677,47 @@ 10200,
 @end ifset
 with only half of the symmetric matrix being stored.  This
 is a significant level of fill in, and although not an issue
 for such a small test case, can represents a large overhead 
 in working with other sparse matrices.
 
 The appropriate sparsity preserving permutation of the original
 matrix is given by @dfn{symamd} and the factorization using this
-reordering can be visualized using the command @code{q = symamd(A);
-r = chol(A(q,q)); spy(r)}.  This gives 
+reordering can be visualized using the command @code{q = symamd (A);
+r = chol (A(q,q)); spy (r)}.  This gives 
 @ifinfo
 @ifnothtml
 29
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 399
 @end ifset
 non-zero terms which is a significant improvement.
 
 The Cholesky@tie{}factorization itself can be used to determine the
 appropriate sparsity preserving reordering of the matrix during the
 factorization, In that case this might be obtained with three return
-arguments as r@code{[r, p, q] = chol(A); spy(r)}.
+arguments as @code{[r, p, q] = chol (A); spy (r)}.
 
 @float Figure,fig:simplechol
 @center @image{spchol,4in}
 @caption{Structure of the un-permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 @float Figure,fig:simplecholperm
 @center @image{spcholperm,4in}
 @caption{Structure of the permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 In the case of an asymmetric matrix, the appropriate sparsity
 preserving permutation is @dfn{colamd} and the factorization using
 this reordering can be visualized using the command
-@code{q = colamd(A); [l, u, p] = lu(A(:,q)); spy(l+u)}.
+@code{q = colamd (A); [l, u, p] = lu (A(:,q)); spy (l+u)}.
 
 Finally, Octave implicitly reorders the matrix when using the div (/)
 and ldiv (\) operators, and so no the user does not need to explicitly
 reorder the matrix to maximize performance.
 
 @DOCSTRING(amd)
 
 @DOCSTRING(ccolamd)
@@ -943,33 +943,33 @@ vertices @code{nodes} and simplices @cod
 
 The following example creates a simple rectangular 2-D electrically
 conductive medium with 10 V and 20 V imposed on opposite sides 
 (Dirichlet boundary conditions).  All other edges are electrically
 isolated.
 
 @example
 @group
-   node_y= [1;1.2;1.5;1.8;2]*ones(1,11);
-   node_x= ones(5,1)*[1,1.05,1.1,1.2, ...
+   node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
+   node_x = ones(5,1)*[1,1.05,1.1,1.2, ...
              1.3,1.5,1.7,1.8,1.9,1.95,2];
-   nodes= [node_x(:), node_y(:)];
+   nodes = [node_x(:), node_y(:)];
 
-   [h,w]= size(node_x);
-   elems= [];
-   for idx= 1:w-1
-     widx= (idx-1)*h;
-     elems= [elems; ...
+   [h,w] = size (node_x);
+   elems = [];
+   for idx = 1:w-1
+     widx = (idx-1)*h;
+     elems = [elems; ...
        widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
        widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
    endfor
 
-   E= size(elems,1); # No. of simplices
-   N= size(nodes,1); # No. of vertices
-   D= size(elems,2); # dimensions+1
+   E = size (elems,1); # No. of simplices
+   N = size (nodes,1); # No. of vertices
+   D = size (elems,2); # dimensions+1
 @end group
 @end example
 
 This creates a N-by-2 matrix @code{nodes} and a E-by-3 matrix
 @code{elems} with values, which define finite element triangles:
 
 @example
 @group
@@ -996,42 +996,42 @@ as constant on each simplex (represented
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
 diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
 and a N-by-DE connectivity matrix @code{C}, representing the connections 
 between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
-  # Element conductivity
-  conductivity= [1*ones(1,16), ...
+  ## Element conductivity
+  conductivity = [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
-  # Connectivity matrix
+  ## Connectivity matrix
   C = sparse ((1:D*E), reshape (elems', ...
          D*E, 1), 1, D*E, N);
 
-  # Calculate system matrix
+  ## Calculate system matrix
   Siidx = floor ([0:D*E-1]'/D) * D * ...
          ones(1,D) + ones(D*E,1)*(1:D) ;
-  Sjidx = [1:D*E]'*ones(1,D);
-  Sdata = zeros(D*E,D);
-  dfact = factorial(D-1);
-  for j=1:E
-     a = inv([ones(D,1), ... 
+  Sjidx = [1:D*E]'*ones (1,D);
+  Sdata = zeros (D*E,D);
+  dfact = factorial (D-1);
+  for j = 1:E
+     a = inv ([ones(D,1), ... 
          nodes(elems(j,:), :)]);
      const = conductivity(j) * 2 / ...
-         dfact / abs(det(a));
+         dfact / abs (det (a));
      Sdata(D*(j-1)+(1:D),:) = const * ...
          a(2:D,:)' * a(2:D,:);
   endfor
-  # Element-wise system matrix
-  SE= sparse(Siidx,Sjidx,Sdata);
-  # Global system matrix
-  S= C'* SE *C;
+  ## Element-wise system matrix
+  SE = sparse(Siidx,Sjidx,Sdata);
+  ## Global system matrix
+  S = C'* SE *C;
 @end example
 
 The system matrix acts like the conductivity 
 @tex
 $S$ 
 @end tex
 @ifnottex
 @code{S}
@@ -1042,33 +1042,33 @@ in Ohm's law
 @end tex
 @ifnottex
 @code{S * V = I}.
 @end ifnottex
 Based on the Dirichlet and Neumann boundary conditions, we are able to 
 solve for the voltages at each vertex @code{V}. 
 
 @example
-  # Dirichlet boundary conditions
-  D_nodes=[1:5, 51:55]; 
-  D_value=[10*ones(1,5), 20*ones(1,5)]; 
+  ## Dirichlet boundary conditions
+  D_nodes = [1:5, 51:55]; 
+  D_value = [10*ones(1,5), 20*ones(1,5)]; 
 
-  V= zeros(N,1);
+  V = zeros (N,1);
   V(D_nodes) = D_value;
   idx = 1:N; # vertices without Dirichlet 
              # boundary condns
   idx(D_nodes) = [];
 
-  # Neumann boundary conditions.  Note that
-  # N_value must be normalized by the
-  # boundary length and element conductivity
-  N_nodes=[];
-  N_value=[];
+  ## Neumann boundary conditions.  Note that
+  ## N_value must be normalized by the
+  ## boundary length and element conductivity
+  N_nodes = [];
+  N_value = [];
 
-  Q = zeros(N,1);
+  Q = zeros (N,1);
   Q(N_nodes) = N_value;
 
   V(idx) = S(idx,idx) \ ( Q(idx) - ...
             S(idx,D_nodes) * V(D_nodes));
 @end example
 
 Finally, in order to display the solution, we show each solved voltage 
 value in the z-axis for each simplex vertex.
@@ -1077,18 +1077,18 @@ value in the z-axis for each simplex ver
 @end ifset
 
 @example
 @group
   elemx = elems(:,[1,2,3,1])';
   xelems = reshape (nodes(elemx, 1), 4, E);
   yelems = reshape (nodes(elemx, 2), 4, E);
   velems = reshape (V(elemx), 4, E);
-  plot3 (xelems,yelems,velems,'k'); 
-  print ('grid.eps');
+  plot3 (xelems,yelems,velems,"k"); 
+  print "grid.eps";
 @end group
 @end example
 
 
 @ifset htmltex
 @float Figure,fig:femmodel
 @center @image{grid,4in}
 @caption{Example finite element model the showing triangular elements. 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -555,47 +555,47 @@ next value in the range is assigned to t
 loop body is executed again.  This process continues until there are no
 more elements to assign.
 
 Within Octave is it also possible to iterate over matrices or cell arrays
 using the @code{for} statement.  For example consider
 
 @example
 @group
-disp("Loop over a matrix")
+disp ("Loop over a matrix")
 for i = [1,3;2,4]
   i
 endfor
-disp("Loop over a cell array")
+disp ("Loop over a cell array")
 for i = @{1,"two";"three",4@}
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In this case the variable @code{i} takes on the value of the columns of
 the matrix or cell matrix.  So the first loop iterates twice, producing
 two column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise
 for the loop over the cell array.  This can be extended to loops over
 multi-dimensional arrays.  For example:
 
 @example
 @group
-a = [1,3;2,4]; c = cat(3, a, 2*a);
+a = [1,3;2,4]; c = cat (3, a, 2*a);
 for i = c
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In the above case, the multi-dimensional matrix @var{c} is reshaped to a
-two-dimensional matrix as @code{reshape (c, rows(c),
-prod(size(c)(2:end)))} and then the same behavior as a loop over a two
+two-dimensional matrix as @code{reshape (c, rows (c),
+prod (size (c)(2:end)))} and then the same behavior as a loop over a two
 dimensional matrix is produced.
 
 Although it is possible to rewrite all @code{for} loops as @code{while}
 loops, the Octave language has both statements because often a
 @code{for} loop is both less work to type and more natural to think of.
 Counting the number of iterations is very common in loops and it can be
 easier to think of this counting as part of looping rather than as
 something to do inside the loop.
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -67,17 +67,17 @@ produces a correct value.  A real test m
 @example
 @group
 %!test
 %! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
 %! expect = [ @var{a} ; 2*@var{a} ];
 %! get = kron (@var{b}, @var{a});
 %! if (any (size (expect) != size (get)))
 %!   error ("wrong size: expected %d,%d but got %d,%d",
-%!          size(expect), size(get));
+%!          size (expect), size (get));
 %! elseif (any (any (expect != get)))
 %!   error ("didn't get what was expected.");
 %! endif
 @end group
 @end example
 
 To make the process easier, use the @code{assert} function.  For example,
 with @code{assert} the previous test is reduced to:
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -186,26 +186,28 @@ unique
 lookup
 
 @item
 ifelse / merge
 @end itemize
 
 @item
 Repetition
+
 @itemize
 @item
 repmat
 
 @item
 repelems
 @end itemize
 
 @item
 Vectorized arithmetic
+
 @itemize
 @item
 sum
 
 @item
 prod
 
 @item
@@ -227,16 +229,17 @@ dot
 cummax
 
 @item
 cummin
 @end itemize
 
 @item
 Shape of higher dimensional arrays
+
 @itemize
 @item
 reshape
 
 @item
 resize
 
 @item
@@ -337,18 +340,18 @@ y - y'
 @end example
 
 @noindent
 Here the vectors of size @code{[1 3]} and @code{[3 1]} both get
 broadcast into matrices of size @code{[3 3]} before ordinary matrix
 subtraction takes place.
 
 A special case of broadcasting that may be familiar is when all
-dimensions of the array being broadcast are 1, i.e. the array is a
-scalar. Thus for example, operations like @code{x - 42} and @code{max
+dimensions of the array being broadcast are 1, i.e., the array is a
+scalar.  Thus for example, operations like @code{x - 42} and @code{max
 (x, 2)} are basic examples of broadcasting.
 
 For a higher-dimensional example, suppose @code{img} is an RGB image of
 size @code{[m n 3]} and we wish to multiply each color by a different
 scalar.  The following code accomplishes this with broadcasting,
 
 @example
 img .*= permute ([0.8, 0.9, 1.2], [1, 3, 2]);
@@ -652,17 +655,17 @@ users of Octave and their solutions.
 @itemize @bullet
 @item
 For a vector @code{A}, the following loop
 
 @example
 @group
 n = length (A);
 B = zeros (n, 2);
-for i = 1:length(A)
+for i = 1:length (A)
   ## this will be two columns, the first is the difference and
   ## the second the mean of the two elements used for the diff.
   B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
 endfor
 @end group
 @end example
 
 @noindent
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -674,27 +674,27 @@ realmin&minimum representable value\cr
 \char'136\ \ .\char'136&exponentiation\cr
 \endsec
 
 \vfill\eject
 
 \sec Paths and Packages;
 path&display the current Octave function path.\cr
 pathdef&display the default path.\cr
-addpath({\it dir})&add a directory to the path.\cr
+addpath ({\it dir})&add a directory to the path.\cr
 EXEC\_PATH&manipulate the Octave executable path.\cr
 pkg list&display installed packages.\cr
 pkg load {\it pack}&Load an installed package.\cr
 \endsec
 
 \sec Cells and Structures;
 {\it{var}}.{\it{field}} = ...&set a field of a structure.\cr
 {\it{var}}$\{${\it{idx}}$\}$ = ...&set an element of a cell array.\cr
-cellfun({\it f}, {\it c})&apply a function to elements of cell array.\cr
-fieldnames({\it s})&returns the fields of a structure.\cr
+cellfun ({\it f}, {\it c})&apply a function to elements of cell array.\cr
+fieldnames ({\it s})&returns the fields of a structure.\cr
 \endsec
 
 \widesec Statements;
 for {\it identifier} = {\it expr} {\it stmt-list} endfor\cr
 \hfill\vbox{\hsize=\idnwid\rm\vskip0.25ex
   Execute {\it stmt-list} once for each column of {\it expr}.  The
   variable {\it identifier} is set to the value of the current column
   during each iteration.}\cr\cr
@@ -798,20 +798,20 @@ logspace ({\it b}, {\it l}, {\it n})&cre
   elements\cr
 eye ({\it n}, {\it m})&create {\it n\/} by {\it m\/} identity matrix\cr
 ones ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of ones\cr
 zeros ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of zeros\cr
 rand ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of random
   values\cr 
 \endsec
 
-% sin({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
-% asin({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
-% sinh({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
-% asinh({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
+% sin ({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
+% asin ({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
+% sinh ({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
+% asinh ({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
 % functions\cr\cr 
 
 \sec Linear Algebra;
 chol ({\it a})&Cholesky factorization\cr
 det ({\it a})&compute the determinant of a matrix\cr
 eig ({\it a})&eigenvalues and eigenvectors\cr
 expm ({\it a})&compute the exponential of a matrix\cr
 hess ({\it a})&compute Hessenberg decomposition\cr
diff --git a/etc/OLD-ChangeLogs/ChangeLog b/etc/OLD-ChangeLogs/ChangeLog
--- a/etc/OLD-ChangeLogs/ChangeLog
+++ b/etc/OLD-ChangeLogs/ChangeLog
@@ -1877,17 +1877,17 @@ 2009-03-09  John W. Eaton  <jwe@octave.o
 	* run-octave.in: Use doc-cache instead of DOC for doc cache file.
 	* configure.in: Likewise.
 
 	* configure.in (--enable-extra-warning-flags): New option to
 	control extra compiler warning flags.
 	(--enable-strict-warning-flags): Rename from --enable-picky-flags.
 	(GXX_STRICT_FLAGS): Remove -Wenum-clash from the list.
 
-2009-03-08  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-03-08  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* NEWS: Mention 'histc'.
 
 2009-03-07  John W. Eaton  <jwe@octave.org>
 
 	* config.guess, config.sub: Update from FSF sources.
 
 2009-02-25  John W. Eaton  <jwe@octave.org>
@@ -2647,17 +2647,17 @@ 2007-08-23  John W. Eaton  <jwe@octave.o
 	* aclocal.m4 (OCTAVE_PROG_SED): Don't clobber value from environment.
 	From: Christian Cornelssen <ccorn@cs.tu-berlin.de>.
 
 2007-08-23  Thomas Weber  <thomas.weber.mail@gmail.com>
 
 	* aclocal.m4 (OCTAVE_PROG_GNUPLOT): Drop check for multiple plot
 	windows.
 
-2007-08-10  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-08-10  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* ROADMAP: Update for current sources.
 
 2007-07-26  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: Also look for glpk/glpk.h.
 
 2007-07-25  David Bateman  <dbateman@free.fr>
@@ -2968,17 +2968,17 @@ 2006-11-13  Rafael Laboissiere  <rafael@
 2006-11-11  John W. Eaton  <jwe@octave.org>
 
 	* examples/Makefile.in (octave.desktop):
 	Use $(simple-move-if-change-rule) here.
 
 	* Makeconf.in (simple-move-if-change-rule,
 	(builddir-move-if-change-rule): New macros.
 
-2006-11-11  SÔøΩren Hauberg  <hauberg@gmail.com>
+2006-11-11  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* examples/Makefile.in (uninstall): Add missing semicolon.
 
 2006-11-09  John W. Eaton  <jwe@octave.org>
 
 	* examples/Makefile.in (uninstall): New target.
 
 2006-11-09  Michael Goffioul  <michael.goffioul@swing.be>
@@ -3178,17 +3178,17 @@ 2006-10-03  John W. Eaton  <jwe@octave.o
 2006-10-03  David Bateman  <dbateman@free.fr>
 
 	* configure.in: Check for libcamd.
 	* Makeconf.in (CAMD_LIBS): New variable.
 
 2006-09-27  John W. Eaton  <jwe@octave.org>
 
 	* mkoctfile.in [--mex]: Include -I. in incflags.
-	From SÔøΩren Hauberg <hauberg@gmail.com>.
+	From S√∏ren Hauberg <hauberg@gmail.com>.
 
 2006-09-26  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (AC_CONFIG_FILES):
 	Remove doc/interpreter/images/Makefile from the list.
 
 2006-09-16  John W. Eaton  <jwe@octave.org>
 
@@ -3560,17 +3560,17 @@ 2005-09-23  John W. Eaton  <jwe@octave.o
 	(IMAGE_FILES, IMAGE_FILES_NO_DIR): New macros.
 	(DISTFILES): Include IMAGE_FILES in list.
 	(install install-strip): Install image file.
 
 	* aclocal.m4 (OCTAVE_PROG_DESKTOP_FILE_INSTALL): New macro
 	* configure.in: Use it.
 	* Makeconf.in: Substitute DESKTOP_FILE_INSTALL.
 
-	* octave.desktop.in: New file.  From SÔøΩren Hauberg <hauberg@gmail.com>.
+	* octave.desktop.in: New file.  From S√∏ren Hauberg <hauberg@gmail.com>.
 	* examples/Makefile.in (SOURCES): Add it to the list.
 	(octave.desktop): New target.
 	(all): Depend on octave.desktop.
 
 2005-09-22  John W. Eaton  <jwe@octave.org>
 
 	* aclocal.m4 (OCTAVE_PROG_PERL): New macro.
 	* configure.in: Use it.
diff --git a/etc/OLD-ChangeLogs/doc-ChangeLog b/etc/OLD-ChangeLogs/doc-ChangeLog
--- a/etc/OLD-ChangeLogs/doc-ChangeLog
+++ b/etc/OLD-ChangeLogs/doc-ChangeLog
@@ -1306,21 +1306,21 @@ 2009-06-03  Jaroslav Hajek  <highegg@gma
 
 	* Makefile.in: Omit conf.texi in DISTFILES.
 
 2009-06-02  Jaroslav Hajek  <highegg@gmail.com>
 
 	* interpreter/oop.txi: Update docs of polynomial class, mention
 	chained indexing.
 
-2009-05-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-05-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/errors.txi: fix 'print_usage' output.
 
-2009-05-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-05-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/bugs.txi: fix call to 'page_screen_output'.
 
 2009-05-25  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/Makefile.in: Add texmf.cnf to list of distributed files
 	(DIST_FILES) so that pdfs will build.
 
@@ -1451,17 +1451,17 @@ 2009-03-25  John W. Eaton  <jwe@octave.o
 	* interpreter/munge-texi.cc (process_texi_input_file):
 	Copy leading comment with file name info to output.
 
 2009-03-09  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DISTFILES): Use doc-cache instead of
 	DOC for doc cache file.
 
-2009-03-08  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-03-08  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/stats.txi (Basic Statistical Functions):
 	Add the 'histc' function.
 
 2009-03-07  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/basics.txi (Command Line Options):
 	Document --doc-cache-file command-line option.
@@ -1537,37 +1537,37 @@ 2009-02-11  John W. Eaton  <jwe@octave.o
 	list of directories to make.
 
 2009-02-10  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DOC): New target.
 	(DISTFILES): Add DOC nad mk_doc_cache.m to the list.
 	* mk_doc_cache.m: New file.
 
-2009-02-01  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-02-01  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/nonlin.txi: Remove reference to 'fsolve_options'.
 
-2009-02-01  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-02-01  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/system.txi: Remove reference to 'eomdate'.
 
 2009-01-24  Thorsten Meyer  <thorsten@hexe>
 
 	* interpreter/container.txi (Data Structures): Update examples for
 	structure arrays.
 
 2009-01-22  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/io.txi (Terminal Output): Remove @DOCSTRING(ans).
 
 	* vr-idx.txi: Delete.
 	* interpreter/Makefile.in (SUB_SOURCE): Remove it from the list.
 
-2009-01-22  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-22  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/func.txi: Put varargin and varargout in concept index.
 	* interpreter/var.txi: Put ans in concept index.
 	* interpreter/octave.texi: Don't include vr-idx.texi.
 
 	* interpreter/var.txi: Remove sections on built-in variables.
 
 2009-01-20  John W. Eaton  <jwe@octave.org>
@@ -1679,22 +1679,22 @@ 2008-10-03  Thorsten Meyer  <thorsten.me
 
 	* interpreter/contrib.txi: added example for mercurial queues
 
 08-10-03  Thorsten Meyer  <thorsten.meyier@gmx.de>
 
 	* interpreter/contrib.txi: correction of the mercurial example
 	* interpreter/container.txi: minor correction of the text
 
-2008-09-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-09-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/image.txi: Update for imread and imwrite instead of
 	loadimge and saveimage.
 
-2008-09-24  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-09-24  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/image.txi: Document imfinfo.
 
 2008-09-23  Francesco Potorti`  <Potorti@isti.cnr.it>.
 
 	* interpreter/container.txi: Fix cross reference in struct docs.
 
 2008-09-23  Brian Gough  <bjg@network-theory.co.uk>
@@ -1733,17 +1733,17 @@ 2008-08-26  Jaroslav Hajek  <highegg@gma
 2008-08-21  David Bateman  <dbateman@free.fr>
 
 	* interpreter/plot.txi: Document ezplot.
 
 2008-08-19  David Bateman  <dbateman@free.fr>
 
 	* interpreter/numbers.txi: Document intwarning.
 
-2008-08-06  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-08-06  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/basics.txi, interpreter/errors.txi,
 	interpreter/expr.txi, interpreter/func.txi,
 	interpreter/numbers.txi: Update format of error messages in examples.
 
 2008-07-29  David Bateman  <dbateman@free.fr>
 
 	* interpreter/numbers.txi, interpreter/plot.txi,
@@ -1950,17 +1950,17 @@ 2007-10-26  Michael Goffioul  <michael.g
 2007-10-22  Kim Hansen  <kimhanse@gmail.com>
 
 	* interpreter/munge-texi.cc: Include <cstdlib> and <cstring>.
 
 2007-10-19  David Bateman  <dbateman@free.fr>
 
 	* refcard/refcard.tex: Update for 3.0.
 
-2007-10-15  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-10-15  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/preface.txi, interpreter/basics.txi,
 	interpreter/strings.txi, interpreter/container.txi,
 	interpreter/var.txi, interpreter/expr.txi, interpreter/errors.txi,
 	interpreter/io.txi, interpreter/func.txi, interpreter/package.txi:
 	Make text fit on pages when using smallbook.
 
 2007-10-12  John W. Eaton  <jwe@octave.org>
@@ -1982,17 +1982,17 @@ 2007-10-10  Olli Saarela  <Olli.Saarela@
 	interpreter/geometry.txi, interpreter/intro.txi,
 	interpreter/numbers.txi, interpreter/plot.txi,
 	interpreter/poly.txi, interpreter/set.txi, interpreter/sparse.txi,
 	interpreter/stmt.txi, interpreter/strings.txi,
 	interpreter/testfun.txi, interpreter/tips.txi: Spelling fixes.
 
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
-	* interpreter/octave.texi: Add David Bateman and SÔøΩren Hauberg as
+	* interpreter/octave.texi: Add David Bateman and S√∏ren Hauberg as
 	authors.
 
 2006-09-28  Henry Mollet  mollet@pacbell.net
 
 	* interpreter/func.txi: Correct results of a couple of examples.
 
 2007-09-14  John W. Eaton  <jwe@octave.org>
 
@@ -2014,17 +2014,17 @@ 2007-09-01  David Bateman  <dbateman@fre
 	* interpreter/Makefile.in: Remove stray character from
 	INTERIMAGES_PNG target.
 	* conf.texi.in: Substitute for the variable TEXINFO_QHULL
 	* interpreter/geometryimages.m: Check for the HAVE_QHULL build
 	flag before creating certain figures.
 	* interpreter/geometry.txi: Check whether TEXINFO_QHULL is set
 	before including certain figures.
 
-2007-08-31  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-08-31  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/nonlin.txi: Extended the example.
 
 	* interpreter/poly.txi: Sectioning and documentation.
 	* interpreter/octave.texi: Adapt to changes in poly.txi.
 
 2007-08-30  David Bateman  <dbateman@free.fr>
 
@@ -2097,17 +2097,17 @@ 2007-06-25  John W. Eaton  <jwe@octave.o
 
 2007-06-18  David Bateman  <dbateman@free.fr>
 
 	* interpreter/interpimages.m: Simpler images to demonstrate
 	the continuity of the second derivative of splines.
 	* interpreter/interp.txi: Also change figures here.
 	* interpreter/Makefile.in: and here.
 
-2007-06-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/optim.txi: Added some introductory text to each
 	section.
 
 	* interpreter/set.txi: Added some introductory text.
 	* interpreter/octave.texi: Updated to reflect changes in set.txi.
 
 2007-06-15  David Bateman  <dbateman@free.fr>
@@ -2143,17 +2143,17 @@ 2007-06-12  David Bateman  <dbateman@fre
 	between interpn and interp3.
 	* hashing.txi: Remove.
 	* system.txi: Move it here as a subsection. Include explanation
 	and example.
 	* interpreter/octave.texi: Add sections for the Interpolation
 	chapter. Remove references to Hashing chapter and hashing.texi,
 	and subsections for hashing to system utilities chapter.
 
-2007-06-12  2007-06-10  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-12  2007-06-10  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/diffeq.txi: Note that x-dot is the derivative of x.
 
 2007-06-03  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/dynamic.txi: Use "mwSize" and "mwIndex" rather than
 	"int" for indexing in mex-files and document them.
 
@@ -2171,25 +2171,25 @@ 2007-05-30  G. D. McBain  <gdmcbain@free
 
 	* interpreter/expr.txi (Assignment Ops): Doc fix.
 
 2007-05-29  Steven Mestdagh  <steven.mestdagh@esat.kuleuven.be>
 
 	* interpreter/Makefile.in ($(HTML_IMAGES_PNG)): Use cp instead of
 	INSTALL_DATA to copy files to the HTML directory.
 
-2007-05-28  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-05-28  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/errors.txi: Add new sections and some more detailed
 	descriptions on errors and warnings.
 	* interpreter/octave.texi, interpreter/stmt.txi,
 	interpreter/var.txi: Add references to the new sections in
 	errors.txi.
 
-2007-05-28  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-05-28  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/io.txi: Rearrange some sections, and add
 	a few examples.
 
 2007-05-28  G. D. McBain  <geordie_mcbain@yahoo.com.au>
 
 	* interpreter/struct.txi: Doc fix.
 
@@ -2213,17 +2213,17 @@ 2007-05-22  Thomas Weber  <thomas.weber.
 2007-05-22  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DISTFILES): Add mkcontrib.awk to the list.
 
 2007-05-21  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/debug.txi, io.txi, octave.txi: Doc fixes.
 
-2007-05-21  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-05-21  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/expr.txi: Describe +=, -=, *=, and /= operators.
 	Add new example.
 
 	* interpreter/eval.txi: Partition the chapter into sections.
 	Describe evalin and assignin functions using text from Paul
 	Kienzle.  Change "See See" to "See".  Use @ref instead of @xref to
 	avoid "See" to be written with a capital letter in the middle of a
@@ -2235,27 +2235,27 @@ 2007-05-21  SÔøΩren Hauberg  <hauberg@gmail.com>
 	* interpreter/stmt.txi: Describe cell array cases for the switch
 	statement.  Minor layout changes.
 
 2007-05-19  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/func.txi: Additional documentation for function
 	locking, dispatch and autoloading.
 
-2007-05-16  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-05-16  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/expr.txi: Improve docs.
 
 2007-05-14  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/basics.txi, interpreter/data.txi,
 	interpreter/intro.txi, interpreter/numbers.txi,
 	interpreter/octave.texi, interpreter/preface.txi: Doc fixes.
 
-2007-04-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/package.texi: Document "*" flag for loaded packages.
 
 	* interpreter.var.txi: Improve explanation of clear, exist, and who.
 
 	* interpreter/intro.txi: Change @unnumberedsubsec to @subsection.
 
 	* interpreter/container.txi: Doc fix.
@@ -2328,17 +2328,17 @@ 2007-04-24  David Bateman  <dbateman@fre
 	interpreter/fortdemo.cc, interpreter/funcdemo.cc,
 	interpreter/globaldemo.cc, interpreter/helloworld.cc,
 	interpreter/stringdemo.cc, interpreter/structdemo.cc,
 	interpreter/unwinddemo.cc, interpreter/fortsub.f,
 	interpreter/dynamic.txi: New files.
 
 	* Makefile.in (SUB_SOURCE): Include dynamic.txi in the list.
 
-2007-04-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/package.texi: New file.
 	* octave/texi: @include it, add it to the menus.
 
 2007-04-18  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/contributors.in: New file.
 	* interpreter/Makefile.in (contributors.texi): New target.
@@ -2353,37 +2353,37 @@ 2007-04-17  David Bateman  <dbateman@fre
 	* interpreter/octave.texi: Include it in menu.
 	* interpreter/sparse.txi: Delete discusion of matrix_type.
 
 2007-04-16  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/stream.txi: Delete.
 	* interpreter/Makefile.in (SUB_SOURCE): Remove it from the list.
 
-2007-04-16  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-16  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* intrepreter/stmt.txi: Improve documentation of switch statement.
 
 	* interpreter/tips.txi: Update description of how copyright
 	statements are recognized.
 
 	* interpreter/octave.texi: Don't include stream.texi.
 	Remove menu entry for I/O streams.
 
 	* interpreter/image.txi: Update docs.
 
-2007-04-11  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-11  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/container.txi: Document indexing with ().
 
-2007-04-11  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-11  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/container.txi: Improve cell array documentation.
 
-2007-04-09  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-04-09  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/func.txi: Document varargin, varargout, and default
 	argument values.
 
 2007-04-03  Rafael Laboissiere  <rafael@debian.org>
 
 	* interpreter/basics.txi: Clarified some limitations of the #!
 	script mechanism, in particular related to the parsing of the
diff --git a/etc/OLD-ChangeLogs/liboctave-ChangeLog b/etc/OLD-ChangeLogs/liboctave-ChangeLog
--- a/etc/OLD-ChangeLogs/liboctave-ChangeLog
+++ b/etc/OLD-ChangeLogs/liboctave-ChangeLog
@@ -1475,17 +1475,17 @@ 2010-03-09  Jaroslav Hajek  <highegg@gma
 	octave_int_base::fnan, octave_int_base::get_trunc_flag,
 	octave_int_base::get_nan_flag,
 	octave_int_base::get_non_int_flag,
 	octave_int_base::get_math_trunc_flag,
 	octave_int_base::clear_conv_flags): Remove.
 	Remove occurences of ftrunc, fnon_int and fnan eveywhere.
 	* oct-inttypes.cc: Ditto last sentence. Remove warning tests.
 
-2010-03-07  Soren Hauberg  <hauberg@gmail.com>
+2010-03-07  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* dim-vector.h: New constructor accepting a C array of dimensions.
 
 2010-03-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* MArray.cc (MArray<T>::idx_add_nd): New method.
 	* MArray.h: Declare it.
 
diff --git a/etc/OLD-ChangeLogs/scripts-ChangeLog b/etc/OLD-ChangeLogs/scripts-ChangeLog
--- a/etc/OLD-ChangeLogs/scripts-ChangeLog
+++ b/etc/OLD-ChangeLogs/scripts-ChangeLog
@@ -1580,17 +1580,17 @@ 2010-12-26  Michael Godfrey <godfrey@isl
 2010-12-24  Rik  <octave@nomad.inbox5.com>
 
 	* testfun/test.m: Use 'Command' for deftype in docstring.
 
 2010-12-24  Rik  <octave@nomad.inbox5.com>
 
 	* audio/setaudio.m: Re-write docstring.
 
-2010-12-23  Soren Hauberg  <hauberg@gmail.com>
+2010-12-23  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* signal/detrend.m: Also accept polynomial order as a string
 	("constant" or "linear") for compatibility with Matlab.
 
 2010-12-22  Konstantinos Poulios  <logari81@gmail.com>
 
 	* plot/private/__axis_label__.m: Trigger fltk graphics redraw
 	immediately after setting an axis label.
@@ -2858,17 +2858,17 @@ 2010-07-26  Rik  <octave@nomad.inbox5.co
 	Add newlines between @items for readability.
 
 2010-07-26  Ben Abbott  <bpabbott@mac.com>
 
 	* general/interp1.m: When absent set X equal to the inices of Y.
 	* general/interpn.m: Convert interpolation vectors of non-equal
 	length to nd-arrays.
 
-2010-07-26  Soren Hauberg  <hauberg@gmail.com>
+2010-07-26  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/image.m: Replace parenthesis with curly bracket in Texinfo.
 
 2010-07-25  Rik  <octave@nomad.inbox5.com>
 
 	* image/image.m: Always reverse 'ydir' property when displaying images.
 
 2010-07-19  Rik  <octave@nomad.inbox5.com>
@@ -3060,17 +3060,17 @@ 2010-07-07  David Bateman  <dbateman@fre
 	* __next_line_color__.m: Allow conditional initialisation of the
 	color_rotation variable.
 	* __next_line_style__.m: Allow conditional initialisation of the
 	style_rotation variable.
 	* hold.m: Support "hold all".
 	* newplot.m: Conditionally initialisation the line style and color
 	based on the __hold_all__ axes property.
 
-2010-07-04  Soren Hauberg  <hauberg@gmail.com>
+2010-07-04  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/deconv.m: ensure that the orientation of the third
 	input to 'filter' matches the orientation of 'y'.
 
 2010-07-02  Rik  <octave@nomad.inbox5.com>
 
 	* audio/wavread.m: Correctly handle non-word aligned data chunks.
 	(bug #30309).
@@ -3728,27 +3728,27 @@ 2010-03-24  Jaroslav Hajek  <highegg@gma
 2010-03-24  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/cell2mat.m: Support cells of cells.
 
 2010-03-23  John W. Eaton  <jwe@octave.org>
 
 	* plot/refreshdata.m: Don't use cell2mat on cell array of cell arrays.
 
-2010-03-22  Soren Hauberg  <hauberg@gmail.com>
+2010-03-22  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/gmap40.m, image/hot.m, image/hsv2rgb.m, image/image.m,
 	image/image_viewer.m, image/imfinfo.m, image/imread.m, image/imshow.m,
 	image/saveimage: Detabify.
 
-2010-03-21  Soren Hauberg  <hauberg@gmail.com>
+2010-03-21  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/quadv.m: Replace 'quadl' with 'quadv' in help text.
 
-2010-03-20  Soren Hauberg  <hauberg@gmail.com>
+2010-03-20  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/interp2.m: For nearest neighbour interpolation ceil
 	(instead of floor) at the center of the data intervals to be
 	compatible with Matlab.  Add test.
 	* general/interpn.m: Ditto.
 
 2010-03-19  Jaroslav Hajek  <highegg@gmail.com>
 
@@ -3777,22 +3777,22 @@ 2010-03-16  Jaroslav Hajek  <highegg@gma
 2010-03-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* strings/index.m: Make it a wrapper for strfind.
 
 2010-03-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* strings/strchr.m: Optimize.
 
-2010-03-05  Soren Hauberg  <hauberg@gmail.com>
+2010-03-05  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (write_index): include classes in autogenerated
 	INDEX files.
 
-2010-03-05  Soren Hauberg  <hauberg@gmail.com>
+2010-03-05  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* plot/fplot.m: Ensure that 'limits' is a 2 or 4 vector, and
 	that 'fn' is a function.
 
 2010-03-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* testfun/test.m: Support catching warnings and errors by IDs.
 
@@ -4733,40 +4733,40 @@ 2009-11-02  Jaroslav Hajek  <highegg@gma
 	* polynomial/spline.m: Update.
 	* general/__splinen__.m: Update.
 
 2009-10-23  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/tril.m, general/triu.m: Remove sources.
 	* general/Makefile.in: Update.
 
-2009-10-20  Soren Hauberg  <hauberg@gmail.com>
+2009-10-20  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/interp2.m: improved error checking and support for bicubic
 	interpolation when X and Y are meshgrid format.
 
 2009-10-22  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/interp1.m: Perform optimizations, improve code (use switch
 	instead of multiple ifs).
 	* polynomial/pchip.m: Employ more optimized formulas (from SLATEC).
 
-2009-10-22  Soren Hauberg  <hauberg@gmail.com>
+2009-10-22  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/autumn.m, image/bone.m, image/cool.m, image/copper.m,
 	image/flag.m, image/gmap40.m, image/gray.m, image/hot.m,
 	image/hsv.m, image/jet.m, image/ocean.m, image/pink.m,
 	image/prism.m, image/rainbow.m, image/spring.m, image/summer.m,
 	image/white.m, image/winter.m: Add demos.
 
-2009-10-20  Soren Hauberg  <hauberg@gmail.com>
+2009-10-20  S√∏ren Hauberg  <hauberg@gmail.com>
 
  	* general/interp2.m: improved error checking and support for bicubic
 
-2009-10-19  Soren Hauberg  <hauberg@gmail.com>
+2009-10-19  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* io/strread.m, io/textread.m: New functions.
 
 2009-10-20  Jaroslav Hajek  <highegg@gmail.com>
 
 	* statistics/base/center.m: Rewrite using bsxfun.
 
 2009-10-15  David Bateman  <dbateman@free.fr>
@@ -5237,25 +5237,25 @@ 2009-05-27  John W. Eaton  <jwe@octave.o
 	* image/imshow.m: In demo, convert image to rgb before scaling
 	components.  Use imread instead of loadimage.
 
 2009-05-26  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: Fix rendering of overlaping images and
 	line objects.  Add demos as well.
 
-2009-05-27 SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-05-27 S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* geometry/delaunay.m: Support cellstr's as options.
 
 2009-05-27  Jaroslav Hajek  <highegg@gmail.com>
 
 	* plot/imshow.m: Fix handling of indexed images.
 
-2009-05-26 SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-05-26 S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help/__makeinfo__.m: Support several @seealso's in one text.
 
 2009-05-26  John W. Eaton  <jwe@octave.org>
 
 	* plot/colorbar.m: Downcase location argument.
 
 2009-05-26 Carlo de Falco  <kingcrimson@tiscali.it>
@@ -5616,17 +5616,17 @@ 2009-03-09  John W. Eaton  <jwe@octave.o
 	Use doc-cache instead of DOC for doc cache file.
 
 2009-03-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/accumarray.m: Reorder tests. Call either "sparse" or
 	__accumarray_sum__ for the default summation case.
 	* statistics/base/histc.m: Reimplement using lookup & accumarray.
 
-2009-03-08  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-03-08  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* statistics/base/histc.m: New function.
 
 2009-03-06  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: Preserve the order of axes' children
 	when pruning the handles for the {x,y,z}labels and title.
 	* plot/legend.m: Change demo to add colors to lines. This change
@@ -5954,22 +5954,22 @@ 2009-02-15  Ben Abbott  <bpabbott@mac.co
 2009-02-13 Ben Abbott  <bpabott@mac.com>
 
 	* plot/__go_draw_axes__.m: Respect axes ticklength property.
 
 2009-02-12  John W. Eaton  <jwe@octave.org>
 
 	* general/sortrows.m: Call __sort_rows_idx__, not __sortrows_idx__.
 
-2009-02-12  Soren Hauberg  <hauberg@gmail.com>
+2009-02-12  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help/gen_doc_cache.m: Change API so we only handle one directory per
 	call to this function.
 
-2009-02-12  Soren Hauberg  <hauberg@gmail.com>
+2009-02-12  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help/lookfor.m: Adapt to new cache scheme.
 
 2009-02-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/sortrows.m: Employ __sortrows_idx__ when applicable,
 	gripe for sparse matrices.
 
@@ -6007,17 +6007,17 @@ 2009-02-05  Thomas D. Dean  <tomdean@spe
 
 	* polynomial/polyout.m: Replace com2str with num2str, and minor
 	style changes.
 
 2009-02-04  John W. Eaton  <jwe@octave.org>
 
 	* help/which.m: Still print something sensible if type is empty.
 
-2009-02-04  Soren Hauberg  <hauberg@gmail.com>
+2009-02-04  S√∏ren Hauberg  <hauberg@gmail.com>
 	    Thomas Treichl  <Thomas.Treichl@gmx.net>
 
 	* miscellaneous/Makefile.in (SOURCES): Add bzip2.m to the list.
 
 2009-02-04  Frederick Umminger  <Frederick_Umminger@playstation.sony.com>
 
 	* signal/freqz.m: Ensure causal phase response.
 	Handle long input correctly.
@@ -6102,17 +6102,17 @@ 2009-01-30  Ben Abbott  <bpabbott@mac.co
 2009-01-29  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/fileparts.m: Match all possible file separators.
 
 2009-01-29  Kai Habel  <kai.habel@gmx.de>
 
 	* plot/__go_draw_axes__.m: Add support for transparent patches.
 
-2009-01-29  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-29  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help/help.m, help/print_usage.m, help/get_first_help_sentence.m:
 	print sensible error message when function is found but not documented.
 
 	* help/help.m: Allow displaying 'Contents.m' files.
 
 2009-01-29  Kai Habel  <kai.habel@gmx.de>
 
@@ -6155,17 +6155,17 @@ 2009-01-27  Jason Riedy  <jason@acm.org>
 
 	* miscellaneous/orderfields.m: Really fix the indexing for struct
 	arrays.
 
 2009-01-27  Carlo de Falco  <kingcrimson@tsicali.it>
 
 	* polynomial/spline.m: Doc fix.
 
-2009-01-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/gradient.m: Handle computing the gradient of a function
 	handle.
 
 2009-01-27  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/lsqnonneg.m: Reimplement using QR updating for
 	square and overdetermined systems.
@@ -6201,31 +6201,31 @@ 2009-01-17  Jaroslav Hajek  <highegg@gma
 2008-12-24 Ben Abbott  <bpabbott@mac.com>
 
 	* path/savepath.m: Respect cmd-line and env paths.
 
 2009-01-24 Ben Abbott  <bpabbott@mac.com>
 
 	* sparse/svds.m: svds.m: skip tests if ARPACK is missing.
 
-2009-01-23  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-23  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help/type.m: Make 'type X' work, when X is the name of a variable.
 
 2009-01-22  John W. Eaton  <jwe@octave.org>
 
 	* help/which.m: New function.
 	* help/Makefile.in (SOURCES): Add it to the list.
 
 	* help/help.m: Also display location of the file before the help text.
 	* help/print_usage: Also display additional help text.
 	* help/__additional_help_message__.m: Return message instead of
 	displaying it.
 
-2009-01-22  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-22  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help: New directory.
 	* configure.in (AC_CONFIG_FILES): Add help/Makefile to the list.
 	* Makefile.in (SUBDIRS): Add it to the list.
 	* help/__additional_help_message__.m, help/__strip_html_tags__.m,
 	help/gen_doc_cache.m, help/get_first_help_sentence.m, help/help.m,
 	help/lookfor.m, help/makeinfo.m, help/print_usage.m, help/type.m:
 	New functions.
@@ -6306,17 +6306,17 @@ 2008-01-15  Rafael Laboissiere  <rafael@
 
 	* gethelp.cc: Include <cstdio>.
 
 2009-01-14  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m (ticklabel_to_cell): New function.
 	Use it to handle non-cell ticklabels.
 
-2009-01-14  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-14  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/diff.m, general/logspace.m, general/nextpow2.m,
 	linear-algebra/commutation_matrix.m,
 	linear-algebra/duplication_matrix.m, linear-algebra/expm.m,
 	miscellaneous/bincoeff.m, miscellaneous/list_primes.m,
 	optimization/fsolve.m, plot/subplot.m, polynomial/pchip.m,
 	polynomial/polyout.m, polynomial/residue.m, polynomial/spline.m,
 	signal/freqz.m, signal/sinc.m, specfun/beta.m, specfun/betaln.m,
@@ -6690,17 +6690,17 @@ 2008-10-29  John W. Eaton  <jwe@octave.o
 
 	* plot/cla.m: In test, set visible off when creating figure.
 
 2008-10-28  Gabriele Pannocchia  <g.pannocchia@ing.unipi.it>
 
 	* optimization/qp.m: Convert bounds of the form b <= x <= b and
 	constraints of the form b <= A*x <= b to equality constraints.
 
-2008-10-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-10-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* plot/ellipsoid.m: Check nargin == 6, not nargin == 5.
 
 2008-10-22  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/cla.m: Fix error when no children to clear.
 
 	* plot/findobj.m: Allow handle to be empty.
@@ -6967,25 +6967,25 @@ 2008-09-26  David Bateman  <dbateman@fre
 	* general/subsindex.m: Dummy subsindex function for help string
 	and to throw error for use outside of a class
 	* general/Makefile.in (SOURCES): Include it here.
 
 2008-09-26  John W. Eaton  <jwe@octave.org>
 
 	* image/imfinfo.m: Delete temporary file.
 
-2008-09-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-09-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imread.m, image/imwrite.m: Doc fix.
 
 2008-09-24  John W. Eaton  <jwe@octave.org>
 
 	* plot/fplot.m: Call axis after calling plot.
 
-2008-09-24  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-09-24  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imfinfo.m: New function.
 	* image/Makefile.in (SOURCES): Add it to the list.
 
 2008-09-24  Ben Abbott  <bpabbott@mac.com>
 
 	* strings/strcat.m: Improve Matlab compatibility for non-character
 	data.
@@ -7445,17 +7445,17 @@ 2008-04-25  John W. Eaton  <jwe@octave.o
 	* miscellaneous/Makefile.in (SOURCES): Add it to the list.
 
 2008-04-21  David Bateman  <dbateman@free.fr>
 
 	* plot/__go_draw_axes__.m (gnuplot_position_colorbox): New arg, obj.
 	Change caller.  Improve sizing and position of colorbox for subplots.
 	* plot/colorbar.m: New demos.
 
-2008-04-16  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-04-16  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* plot/__gnuplot_version__.m: Display error if gnuplot is not found.
 
 2008-04-15  John W. Eaton  <jwe@octave.org>
 
 	* plot/view.m: Get values from current axes if nargin == 0.
 
 2008-04-15  David Bateman  <dbateman@free.fr>
@@ -7735,17 +7735,17 @@ 2008-03-28  Jaroslav Hajek  <highegg@gma
 
 	* general/del2.m: Missing semicolon.
 
 2008-03-28  Julian Schnidder  <j.schnidder@gmx.de>
 
 	* miscellaneous/info.m: New function.
 	* miscellaneous/Makefile.in (SOURCES): Add it to the list.
 
-2008-03-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* plot/xlim.m, plot/ylim.m, plot/zlim.m, strings/strtrim.m:
 	Doc fixes.
 
 2008-03-27  David Bateman  <dbateman@free.fr>
 
 	* plot/__plt2__.m: Test if args are empty first so that
 	plot(zeros(1,0),zeros(1,0)) works as expected.
@@ -7793,29 +7793,29 @@ 2008-03-26  John W. Eaton  <jwe@octave.o
 	plot/patch.m, plot/ribbon.m, plot/surface.m, polynomial/mkpp.m,
 	polynomial/pchip.m, polynomial/spline.m, set/unique.m:
 	Texinfo fixes.
 
 2008-03-26  Jaroslav Hajek  <highegg@gmail.com>
 
 	* linear-algebra/dmult.m: Handle scaling along arbitrary dimension.
 
-2008-03-26  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-26  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/convn.m: New tests.
 
 2008-03-20  Ben Abbott  <bpabbott@mac.com>
 
 	* statistics/base/statistics.m: Calculate median and quantiles in
 	a manner consistent with method #7 used by GNU R.
 	* statistics/base/__quantile__.m, statistics/base/quantile.m,
 	statistics/base/prctile.m: New functions.
 	* statistics/base/Makefile.in (SOURCES): Add them to the list.
 
-2008-03-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/convn.m: New function.
 	* polynomial/Makefile.in (SOURCES): Add it to the list.
 
 2008-03-25  David Bateman  <dbateman@free.fr>
 
 	* image/contrast.m: New function.
 	* image/Makefile.in (SOURCES): Add it to the list.
@@ -8322,17 +8322,17 @@ 2008-01-15  Ben Abbott  <bpabbott@mac.co
 	* linear-algebra/__norm__.m: Avoid divide by zero error for
 	Frobenius norm if matrix is all zeros.  Use transpose instead of
 	hermitian operator.
 
 2008-01-14  Bill Denney  <bill@denney.ws>
 
 	* plot/axis.m: Correctly handle "tight" and "image" options.
 
-2008-01-14  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-01-14  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/hsv2rgb.m, image/ntsc2rgb.m, image/rgb2hsv.m,
 	image/rgb2ntsc.m: Also accept images as input.
 
 	* image/gray2ind.m: Handle image type other than double.
 	Improve error checking and documentation.
 
 2008-01-14  John W. Eaton  <jwe@octave.org>
@@ -8383,17 +8383,17 @@ 2008-01-07  John W. Eaton  <jwe@octave.o
 2008-01-04  Thomas Treichl  <Thomas.Treichl@gmx.net>
 
 	* strings/strtrim.m: Doc fix.
 
 2008-01-04  Muthiah Annamalai  <muthuspost@gmail.com>
 
 	* general/sub2ind.m, general/ind2sub.m: Doc fix.
 
-2008-01-04  SÔøΩren Hauberg   <hauberg@gmail.com>
+2008-01-04  S√∏ren Hauberg   <hauberg@gmail.com>
 
 	* set/create_set.m, set/union.m: Accept "rows" argument.
 
 2008-01-02  John W. Eaton  <jwe@octave.org>
 
 	* plot/print.m: Correctly handle pbm terminal.
 
 2007-12-28  John W. Eaton  <jwe@octave.org>
@@ -8411,25 +8411,25 @@ 2007-12-28  Kai Habel  <kai.habel@gmx.de
 
 	* plot/pcolor.m: Swap 1st and 2nd argument in call to meshgrid.
 	Remove unnecessary call of size function.
 
 2007-12-21  John W. Eaton  <jwe@octave.org>
 
 	Version 3.0.0 released.
 
-2007-12-21  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-12-21  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Accept empty value for display_range.
 
 2007-12-20  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* pkg/pkg.m: Add .lib as architecture-dependent suffix.
 
-2007-12-19  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-12-19  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Store uint8 images as doubles.  Handle default
 	display ranges correctly.
 
 2007-12-19  Alexander Barth  <barth.alexander@gmail.com>
 	    Peter A. Gustafson  <petegus@umich.edu>
 
 	* plot/contourc.m: Allow usage of irregular spaced x, y data.
@@ -9222,17 +9222,17 @@ 2007-10-19  David Bateman  <dbateman@fre
 
 	* plot/__bar__.m, plot/fill.m: Call newplot as needed.
 
 2007-10-17  Carlo de Falco  <kingcrimson@tiscali.it>
 
 	* plot/print.m: Handle -textspecial and -textnormal flags for fig
 	output.
 
-2007-10-15  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-10-15  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/rat.m, sparse/pcg.m, sparse/pcr.m, optimization/sqp.m,
 	statistics/models/logistic_regression.m, polynomial/polygcd.m,
 	control/system/ss.m, signal/arch_rnd.m, control/system/ss2sys.m,
 	control/system/syssetsignals.m, control/base/lqg.m,
 	strings/str2double.m, control/system/sysscale.m,
 	control/hinf/hinfdemo.m, general/cplxpair.m:
 	Make help text fit on pages when using smallbook.
@@ -9407,17 +9407,17 @@ 2007-10-08  John Swensen  <jpswensen@com
 	* general/num2str.m: Eliminate extra whitespace in output.
 	* strings/strtrim.m: New function.
 	* strings/Makefile.in (SOURCES): Add it to the list.
 
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
 	* polynomial/residue.m: New test from test/test_poly.m.
 
-2007-10-06  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-10-06  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/saveimage.m: Handle saving color images without a colormap.
 	* image/__img_via_file__.m: Add missing semicolon.
 
 2007-10-06  Bill Denney  <wsloand@gmail.com>
 
 	* general/__splinen__.m, general/isscalar.m, general/rat.m,
 	strings/dec2base.m: Use numel(x) instead of prod(size(x)).
@@ -9650,17 +9650,17 @@ 2007-08-31  Michael goffioul  <michael.g
 
 	* plot/axes.m: Allow parent to be specified when creating axes
 	objects.  Support non-figure parents.
 
 2007-08-31  John W. Eaton  <jwe@octave.org>
 
 	* plot/ancestor.m: New function, adapted from Octave Forge.
 
-2007-08-31  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-08-31  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/polygcd.m: Better layout of example.
 	* polynomial/compan.m: Remove unnecessary check.
 	* polynomial/roots.m: Added example to help text.
 	* polynomial/polyderiv.m: Change 'polyder' to 'polyderiv' in help text.
 	* polynomial/poly.m: Added example to help text.
 
 2007-08-30  John W. Eaton  <jwe@octave.org>
@@ -9884,25 +9884,25 @@ 2007-06-27  Michael Goffioul  <michael.g
 	* image/colormap.m: Only return colormap if nargout > 0.
 	Mark as command.
 
 2007-06-25  John W. Eaton  <jwe@octave.org>
 
 	* plot/drawnow.m, plot/__go_draw_axes__.m: Use strcmpi instead of
 	strcmp for selected property comparisons.
 
-2007-06-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Fix check for colormap arguments.
 
 2007-06-25  Joel Keay  <keay@nhn.ou.edu>
 
 	* plot/drawnow.m: Handle GNUTERM=aqua if DISPLAY is not set.
 
-2007-06-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* statistics/base/median.m: Update help text to mention 'dim'
 	argument, and note that the data should be sorted for the
 	definition of the median to be correct.
 
 	* statistics/base/std.m: Add missing square to definition of
 	standard deviation.
 
@@ -9985,29 +9985,29 @@ 2007-06-19  David Bateman  <dbateman@fre
 	* sparse/gplot.m: ditto.
 	* sparse/treeplot.m: ditto.
 
 2007-06-19  John W. Eaton  <jwe@octave.org>
 
 	* plot/__go_draw_axes__.m (do_tics, do_tics_1): New functions.
 	(__go_draw_axes__): Call do_tics to handle tic marks.
 
-2007-06-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/interp1.m, general/interp2.m, general/interp3.m,
 	general/interpn.m: Replace, NaN with NA.  Use isna instead of ==
 	to check for NA.
 
-2007-06-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* optimization/glpk.m: TeXified the help text.
 	* optimization/qp.m: TeXified the help text.
 	* optimization/sqp.m: TeXified the help text.
 
-2007-06-16  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-16  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* plot/legend.m: Replace 'vargin' with 'varargin'.
 
 2007-06-15  John W. Eaton  <jwe@octave.org>
 
 	* plot/__go_draw_axes__.m: Only attempt label rotation if
 	have_newer_gnuplot is true.
 
@@ -10089,17 +10089,17 @@ 2007-06-12  David Bateman  <dbateman@fre
 	* general/interp3.m: New function for 3-dimensional, linear, nearest
 	and spline interpolation.
 	* polynomial/spline.m: Change examples to use new graphics interface.
 
 2007-06-12  Steve M. Robbins  <steve@sumost.ca>
 
 	* statistics/tests/wilcoxon_test.m: Error if N <= 25.
 
-2007-06-12  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-06-12  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* plot/fplot.m: If function is inline, vectorize it.
 
 2007-06-10  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m (pkg:installed_packages): truncate start of package
 	directory if need to, so that it fits on a line.
 
@@ -10116,17 +10116,17 @@ 2007-06-07  David Bateman  <dbateman@fre
 	(pkg:save_order): New function to sort package list with dependent
 	packages first.
 	(pkg:load_packages_and_dependencies): New function to load both a
 	list of packages and their dependencies.
 	(pkg:load_package_dirs): New function that returns a vector of the
 	indexes into the installed package list indicating the packages to
 	load and the order to load them in to respect the dependencies.
 
-2007-06-03  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-06-03  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* plot/axes.m: Eliminate redundant else clause.
 
 2007-06-03  David Bateman  <dbateman@free.fr>
 
 	* polynomial/spline.m: Add a small tolerance to spline tests.
 	* pkg/pkg.m: Protect against multiple actions being define.
 
@@ -10228,17 +10228,17 @@ 2007-05-18  David Bateman  <dbateman@fre
 	it exists to address issues with autoload/mfilename.
 	(write_INDEX): Check in archiecture dependent directories as well.
 
 2007-05-17  David Bateman  <dbateman@free.fr>
 
 	* plot/hbar.m: Remove.
 	* plot/barh.m: and move it here.
 
-2007-05-16  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-16  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* general/sub2ind.m, general/ind2sub.m: Doc fix.
 
 2007-05-16  John W. Eaton  <jwe@octave.org>
 
 	* general/logspace.m: Return second arg if fewer than two values
 	are requested.
 
@@ -10259,17 +10259,17 @@ 2007-05-14  Tarmigan Casebolt  <tarmigan
 	* deprecated/normal_cdf.m, deprecated/normal_inv.m,
 	deprecated/normal_pdf.m, deprecated/normal_rnd.m: Preserve
 	backward compatibility.
 
 2007-05-14  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m: Mark loaded packages with "*".
 
-2007-05-13  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-13  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/single.m: Doc fix.
 	Convert to double instead of returning argument unchanged.
 
 	* miscellaneous/doc.m: Doc fix.
 
 	* miscellaneous/ver.m: Doc fix.
 	Don't display information about Octave Forge.
@@ -10344,17 +10344,17 @@ 2007-04-25  John W. Eaton  <jwe@octave.o
 	* plot/__go_draw_axes__.m: For images, set titlespec{data_idx} to
 	"title \"\"", not "".
 
 	* plot/legend.m: Initialize WARNED to false.
 
 2007-04-24  John W. Eaton  <jwe@octave.org>
 
 	* io/beep.m: Fix cut and paste error.
-	From SÔøΩren Hauberg  <soren@hauberg.org>.
+	From S√∏ren Hauberg  <soren@hauberg.org>.
 
 2007-04-23  John W. Eaton  <jwe@octave.org>
 
 	* plot/box.m: Delete extra endfunction keyword.
 
 2007-04-23  David Bateman  <dbateman@free.fr>
 
 	* plot/plot3.m: Call newplot.
@@ -10395,17 +10395,17 @@ 2007-04-17  Paul Kienzle  <pkienzle@user
 
 	* specfun/factorial.m: Use gamma function instead of cumprod.
 	Add tests.
 
 2007-04-16  John W. Eaton  <jwe@octave.org>
 
 	* gethelp.cc (looks_like_octave_copyright): Use same logic as in
 	looks_like_copyright in src/help.cc.
-	From SÔøΩren Hauberg <soren@hauberg.org>.
+	From S√∏ren Hauberg <soren@hauberg.org>.
 
 	* plot/__go_draw_axes__.m: For log plots, omit zero values too.
 
 2007-04-13  John W. Eaton  <jwe@octave.org>
 
 	* optimization/sqp.m: Initialize info to 0.
 
 	* optimization/qp.m: Undo previous change.
@@ -10760,17 +10760,17 @@ 2007-03-14  John W. Eaton  <jwe@octave.o
 	* miscellaneous/delete.m: Call __go_delete__, not
 	__uiobject_delete__.  Check that arg is a graphics handle before
 	calling __go_delete__.
 
 2007-03-13  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/cast.m: Use feval and strcmp with cell to check
 	arg instead of switch statement.
-	From SÔøΩren Hauberg <soren@hauberg.org>.
+	From S√∏ren Hauberg <soren@hauberg.org>.
 
 2007-03-12  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/cast.m: New function.
 
 	* miscellaneous/delete.m: Call __go_delete__, not __uiobject_delete__.
 
 2007-03-08  John W. Eaton  <jwe@octave.org>
@@ -11433,17 +11433,17 @@ 2007-01-23  Luis F. Ortiz  <lortiz@inter
 2007-01-22  Bob Weigel  <rweigel@gmu.edu>
 
 	* testfun/test.m: Check for all files in path, use first found.
 
 2007-01-22  David Bateman  <dbateman@free.fr>
 
 	* polynomial/spline.m: Make DG a column instead of a row vector.
 
-2007-01-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-01-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (copy_files): Call write_INDEX with correct target
 	file name.
 
 	* image/ind2rgb.m: Better input checking.  Return 3-d array if
 	nargout is 1.  Handle colormaps that have too few colors.
 
 	* pkg/pkg.m (create_pkgadddel): Call fullfile with nm, not "nm".
@@ -11455,58 +11455,58 @@ 2007-01-10  Baylis Shanks  <bshanks3@hot
 
 2007-01-10  David Bateman  <dbateman@free.fr>
 
 	* elfun/acosd.m, elfun/acotd.m, elfun/acscd.m, elfun/asecd.m,
 	elfun/asind.m, elfun/atand.m, elfun/cosd.m, elfun/cotd.m,
 	elfun/cscd.m, elfun/secd.m, elfun/sind.m, elfun/tand.m:
 	New files.
 
-2007-01-09  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-01-09  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m: Allow filenames to contain glob patterns.
 
-2007-01-08  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-01-08  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m: Use copyfile instead of calling system.  Use fullfile
 	instead of concatenating with "/".  Use mlock to ensure that
 	persistent variables are not clobbered if user types clear all.
 
 2007-01-08  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/copyfile.m, miscellaneous/movefile.m:
 	Improve handling of file names containing globbing characters.
-	From SÔøΩren Hauberg <hauberg@gmail.com>.
+	From S√∏ren Hauberg <hauberg@gmail.com>.
 
 2007-01-05  John W. Eaton  <jwe@octave.org>
 
 	* optimization/optimset.m, optimization/__fsolve_defopts__.m:
 	New files.
 
 2006-12-30  John W. Eaton  <jwe@octave.org>
 
 	* sparse/spfun.m: Check for "function_handle" not "function handle".
 	* plot/fplot.m: Likewise.  Use isa instead of strcmp + class.
 
-2006-12-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2006-12-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Strip NaNs from image.
 
 2006-12-08  David Bateman  <dbateman@free.fr>
 
 	* sparse/normest.m: New file.
 
 2006-12-06  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* miscellaneous/copyfile.m, miscellaneous/movefile.m:
 	Work on Windows systems without cp or mv.
 
 	* startup/inputrc: Include sequences for Windows.
 
-2006-12-06  SÔøΩren Hauberg  <hauberg@gmail.com>
+2006-12-06  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (unload_packages): New function.
 	(pkg): Handle unload action.
 
 	* __errplot__.m: Add missing semicolon.
 
 2006-11-30  John W. Eaton  <jwe@octave.org>
 
@@ -11573,17 +11573,17 @@ 2006-11-14  John W. Eaton  <jwe@octave.o
 	* plot/bottom_title.m, plot/top_title.m: Delete.
 
 	* image/image_viewer.m: Set default values here.
 	* image/image.m: Not here.
 
 	* image/image_viewer.m: Always return old values.  Check arguments.
 	* image/__img_gnuplot__.m: Rename from __img__m.
 
-2006-11-14  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-11-14  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* image/image_viewer.m: New function.
 	* image/__img_via_file__.m: New function.
 	* image/image.m: Use image_viewer to determine which program to
 	use for image viewing.
 	* image/__img__.m: Silently accept more than 3 args.
 
 2006-11-14  John W. Eaton  <jwe@octave.org>
@@ -11603,35 +11603,35 @@ 2006-11-13  John W. Eaton  <jwe@octave.o
 	* miscellaneous/substruct.m: New function.
 
 	* testfun/assert.m: Force orientation to match when comparing
 	struct elements.
 
 	* general/__isequal__.m: Avoid assignment of comma-separated lists
 	when comparing structs.
 
-2006-11-13  SÔøΩren Hauberg  <hauberg@gmail.com>
+2006-11-13  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* general/bicubic.m, general/cart2pol.m, general/cart2sph.m,
 	plot/contour.m, linear-algebra/cross.m, general/cumtrapz.m,
 	linear-algebra/dot.m, image/imshow.m, general/interp2.m,
 	general/mod.m, plot/plot3.m, plot/__plr2__.m, plot/__plr__.m,
 	general/pol2cart.m, general/polyarea.m, polynomial/polyfit.m,
 	general/rem.m, image/rgb2ind.m, general/sph2cart.m,
 	general/trapz.m, miscellaneous/xor.m: Use size_equal.
 
 2006-11-13  John W. Eaton  <jwe@octave.org>
 
 	* plot/mesh.m: Use size_equal to compare dimensions.
 
-2006-11-13  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-11-13  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* plot/mesh.m: Simplify.  Set hidden3d for the plot.
 
-2006-11-11  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-11-11  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/copyfile.m: Fix docs to match function.
 
 2006-11-08  John W. Eaton  <jwe@octave.org>
 
 	* plot/legend.m: New function, adapted from Octave Forge.
 
 	* plot/__do_legend__.m: New function.
@@ -11669,17 +11669,17 @@ 2006-11-08  John W. Eaton  <jwe@octave.o
 
 	* strings/strcat.m: Disable Octave:empty-list-elements warning
 	whle concatenating args.
 
 2006-11-07  John W. Eaton  <jwe@octave.org>
 
 	* startup/main-rcfile: Conditionally set PAGER_FLAGS.
 
-2006-11-06  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-11-06  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m (extract_pkg): No need to pass "dotexceptnewline"
 	option to regexp.
 
 	* image/__img__.m: Send "set size ratio -1" before plotting.
 
 2006-11-03  Bill Denney  <denney@seas.upenn.edu>
 
@@ -11715,17 +11715,17 @@ 2006-10-25  Quentin Spencer  <qspencer@i
 	Daniel J Sebald <daniel.sebald@ieee.org>.
 
 2006-10-25  John W. Eaton  <jwe@octave.org>
 
 	* plot/__gnuplot_version__.m: New function, originally from
 	Daniel J Sebald <daniel.sebald@ieee.org> by way of
 	Quentin Spencer <qspencer@ieee.org>.
 
-2006-10-25  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-10-25  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* plot/__pltopt__.m: Update symbol marker id numbers for gnuplot 4.
 
 2006-10-24  Bill Denney  <denney@seas.upenn.edu>
 
 	* miscellaneous/unpack.m, miscellaneous/bunzip2.m,
 	miscellaneous/gunzip.m: New files.
 	* miscellaneous/untar.m, miscellaneous/unzip.m:
@@ -12029,30 +12029,30 @@ 2006-10-09  Bill Denney  <denney@seas.up
 
 	* miscellaneous/untar.m: Check more rigorously to see if the tar
 	file exists.
 
 2006-10-04  John W. Eaton  <jwe@octave.org>
 
 	* pkg/pkg.m: Use fullfile to concatenate directory and file names.
 
-2006-10-04  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-10-04  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Update docs.  Handle prefix option.
 	Handle dependencies for load option.
 
 2006-10-04  John W. Eaton  <jwe@octave.org>
 
 	* deprecated/clearplot.m, deprecated/clg.m: New functions.
 
 	* plot/clg.m: Delete.
 	* plot/__init_plot_vars__.m: New function.
 	* plot/__setup_plot__.m: Use __init_plot_vars__.
 
-2006-10-03  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-10-03  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Avoid calling addpath with no args.
 
 2006-10-03  Bill Denney  <denney@seas.upenn.edu>
 
  	* audio/loadaudio.m, control/base/nyquist.m,
  	control/system/__zp2ssg2__.m, linear-algebra/cross.m,
  	linear-algebra/krylov.m, statistics/base/center.m,
@@ -12098,17 +12098,17 @@ 2006-09-26  David Bateman  <dbateman@fre
 	* mesh.m: ditto.
 	* plot3.m: Error checking, setting of parametric state and
 	formation of matrix to plot moved from old __plt3__.
 
 2006-09-22  Michael Creel  <michael.creel@uab.es>
 
 	* deprecated/chisquare_pdf.m: Typo in documentation.
 
-2006-09-22  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-09-22  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* signal/filter2.m: Correct texinfo doc.
 
 2006-09-22  David Bateman  <dbateman@free.fr>
 
 	* miscellaneous/parseparams.m: Correct texinfo doc.
 
 2006-09-15  David Bateman  <dbateman@free.fr>
@@ -12177,17 +12177,17 @@ 2006-08-25  David Bateman  <dbateman@fre
 	(copy_files): Install both bin/ and doc/ directories, adding the
 	bin/ to the EXEC_PATH when the package is loaded.
 
 2006-08-24  John W. Eaton  <jwe@octave.org>
 
 	* image/saveimage.m: Use logical indexing instead of
 	indices computed by calling find on the logical index.
 
-2006-08-24  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-08-24  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/bincoeff.m, specfun/factorial.m:
 	Use logical indexing instead of indices computed by calling find
 	on the logical index.
 
 	* linear-algebra/krylov.m: Delete unused local var nzidx.
 
 2006-08-23  Quentin Spencer  <qspencer@ieee.org>
@@ -12205,17 +12205,17 @@ 2006-08-23  A S Hodel  <hodelas@auburn.e
 
 2006-08-22  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m (extract_pkgadd, create_pkgadd): New functions to
 	Search inst/*.m and src/*.m files in the package for
 	PKG_ADD directives and append user supplied PKG_ADD.
 	(pkg): Call create_pkgadd after copying files.
 
-2006-08-21  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-08-21  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Handle multiple packages in a single file.
 	Insert directory separator between OCTAVE_HOME and rest of package
 	installation directory.
 
 2006-08-21  John W. Eaton  <jwe@octave.org>
 
 	* general/num2str.m: Early return if arg is empty.
@@ -12224,34 +12224,34 @@ 2006-08-21  John W. Eaton  <jwe@octave.o
 2006-08-21  David Bateman  <dbateman@free.fr>
 
 	* strings/mat2str.m: Compute NC before using.
 
 2006-08-17  John W. Eaton  <jwe@octave.org>
 
 	* audio/wavread.m: Fix calculation of sample count.
 
-2006-08-14  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-08-14  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* image/imshow.m: New Matlab-compatible version.
 
 2006-08-15  John W. Eaton  <jwe@octave.org>
 
 	* deprecated/is_global.m: Delete.
 
 2006-08-14  John W. Eaton  <jwe@octave.org>
 
 	* pkg/Makefile.in (script_sub_dir): Change from plot to pkg.
 
 2006-08-14  Dmitri A. Sergatskov  <dasergatskov@gmail.com>
 
 	* sparse/spy.m, control/base/bode.m, control/base/__stepimp__.m,
 	signal/freqz_plot.m: Adapt to new automatic_replot definition.
 
-2006-08-14  SÔøΩren Hauberg  <soren@hauberg.org>
+2006-08-14  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Don't pass function name to print_usage.
 	Use addpath and rmpath instead of manipulating LOADPATH.
 	Handle changes to system function.
 	(rm_rf): New subfunction.  Use it to avoid confirmation dialog for
 	recursive directory removal.
 
 	* strings/bin2dec.m: Ignore spaces in input for compatibility.
@@ -12372,17 +12372,17 @@ 2006-05-11  John W. Eaton  <jwe@octave.o
 	* configure.in (AC_CONFIG_FILES): Add pkg/Makefile to the list.
 	* Makefile.in (SUBDIRS): Add pkg to the list.
 
 2006-05-10  John W. Eaton  <jwe@octave.org>
 
 	* tar.m, untar.m, unzip.m: Adapt to Octave coding style.
 	* tar.m, untar.m: Only tar; don't compress or uncompress.
 
-2006-05-10  SÔøΩren Hauberg  <hauberg@gmail.com>
+2006-05-10  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* tar.m, untar.m, unzip.m: New files.
 
 2006-05-10  John W. Eaton  <jwe@octave.org>
 
 	* path/addpath.m, path/rmpath.m: Improve compatibility.
 	* path/setpath.m: Delete.
 
@@ -12589,17 +12589,17 @@ 2006-03-15  William Poetra Yoga Hadisoes
 	* strings/strncmpi.m: Import from octave-forge, simplify.
 	* strings/strtrunc.m: New file.
 
 	* strings/lower.m, strings/upper.m: Handle cellstr arguments.
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/doc.m: New file.
-	From SÔøΩren Hauberg <soren@hauberg.org>.
+	From S√∏ren Hauberg <soren@hauberg.org>.
 
 2006-03-15  Keith Goodman  <kwgoodman@gmail.com>
 
 	* miscellaneous/mkoctfile.m: New file.
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* polynomial/residue.m: Use & instead of && to generate arg for find.
@@ -13377,17 +13377,17 @@ 2005-03-22  John W. Eaton  <jwe@octave.o
 	Avoid looping when checking character classes.
 
 	* optimization: New directory.
 	* Makefile.in (SUBDIRS): Add it to the list.
 	* optimization/Makefile.in: New file.
 	* optimization/glpk.m, optimization/glpkparams.m,
 	optimization/glpktest1, optimization/glpktest2: New files.
 
-2005-03-16  SÔøΩren Hauberg  <soren@hauberg.org>
+2005-03-16  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* strings/split.m: Quick return for empty second arg.
 	Improve warning for multi-line strings.
 	Speed up by avoiding sprintf in loop and eval.
 
 2005-03-16  Paul Kienzle  <pkienzle@users.sf.net>
 
 	* polynomial/polyderiv.m : Accept a*b, a/b.  Auto-reduce common terms.
diff --git a/etc/OLD-ChangeLogs/src-ChangeLog b/etc/OLD-ChangeLogs/src-ChangeLog
--- a/etc/OLD-ChangeLogs/src-ChangeLog
+++ b/etc/OLD-ChangeLogs/src-ChangeLog
@@ -3022,17 +3022,17 @@ 2010-07-06  David Bateman  <dbateman@fre
 	of digits in a value.
 	(static void pr_any_float (const float_format *, std::ostream&,
 	double, int)): Print engineering formats.
 	(static void init_format_state (void)): Set default state of print_eng.
 	(static void set_format_style (int, const string_vector&)): Parse
 	the "eng" argument.
 	(Fformat): Document the new engineering format.
 
-2010-07-04  Soren Hauberg  <hauberg@gmail.com>
+2010-07-04  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD_FUNCTIONS/__magick_read__.cc: restore locale after
 	GraphicsMagick initialisation.
 
 2010-07-02  Jaroslav Hajek  <highegg@gmail.com>
 
 	* toplev.cc (octave_call_stack::do_backtrace): Use static
 	octave_fields struct.
@@ -4221,17 +4221,17 @@ 2010-02-18  Thorsten Meyer  <thorsten.me
 
 	* dirfns.cc (Fglob): Document globbing patterns, add test.
 
 2010-02-18  Jaroslav Hajek  <highegg@gmail.com>
 
 	* load-path.cc (in_path_list): New helper function.
 	(add_to_fcn_map): Use it here.
 
-2010-02-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2010-02-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (__magick_finfo__):
 	Handle multiple frames in a single image file.
 
 2010-02-18  John W. Eaton  <jwe@octave.org>
 
 	* oct-map.h (Octave_map::Octave_map): Allow dimension to also be
 	specified in string_vector constructor.
@@ -7559,17 +7559,17 @@ 2009-07-23  Shai Ayal  <shaiay@users.sou
 
 	* DLD-FUNCTIONS/fltk_backend.cc (plot_window::pixel2axes_or_ca):
 	Replace plot_window::pixel2axes and use algorithm from octavede.
 	(plot_window::handle): Zooming now works on the axes below the
 	mouse pointer instead of the current axes. Combine old and new
 	zooming methods.
 	(help_text): Update to reflect new mouse/key bindings.
 
-2009-07-23  Soren Hauberg  <hauberg@gmail.com>
+2009-07-23  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* graphics.cc (axes::properties::zoom_about_point,
 	axes::properties::translate_view): New functions.
 	(axes::properties::zoom): make zoom_stack usage optional.
 	* DLD-FUNCTIONS/fltk_backend.cc (plot_window::handle): Use new
 	zoom API.
 
 2009-07-23  John W. Eaton  <jwe@octave.org>
@@ -10241,22 +10241,22 @@ 2008-12-25 Ben Abbott  <bpabbott@mac.com
 	* load-path.cc (Fcommandlinepath): New function.
 	* load-path.h (load_path::get_command_line_path,
 	load_path::do_get_command_line_path): New functions.
 
 2009-01-24 Ben Abbott  <bpabbott@mac.com>
 
 	* DLD-FUNCTIONS/eigs.cc: eigs.cc: skip tests if ARPACK is missing.
 
-2009-01-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help.cc (do_get_help_text, raw_help_from_symbol_table): new output to
 	flag the a function is found but not documented.
 
-2009-01-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* help.cc (raw_help_from_file): No longer search for files called
 	'Contents.m', as this is moved to 'script/help.m'.
 
 
 2009-01-23  John W. Eaton  <jwe@octave.org>
 
 	* toplev.cc (octave_call_stack::do_goto_caller_frame):
@@ -10297,17 +10297,17 @@ 2009-01-22  John W. Eaton  <jwe@octave.o
 
 	* help.cc (do_which (std::ostream&, const std::string&), Fwhich):
 	Delete.
 	(do_which (const std::string&, std::string&), F__which__):
 	New functions.
 	* do_which (const std::string&):
 	Call do_which (const std::string&, std::string&) to do the work.
 
-2009-01-22  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-22  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* defun-int.h (print_usage): No longer mark as deprecated.
 	* defun.cc (print_usage): Simply call feval to execute print_usage.m.
 	* help.cc (additional_help_message, display_names_from_help_list,
 	display_symtab_names, simple_help, try_info, help_from_info,
 	display_help_text, display_usage_text, raw_help_from_list,
 	help_from_list, help_from_symbol_table, help_from_file,
 	builtin_help, Fhelp, display_file, do_type, Ftype,
@@ -10447,22 +10447,22 @@ 2009-01-14  Jaroslav Hajek  <highegg@gma
 	* oct-obj.cc (octave_value_list::normalize_null_values):
 	Rename to make_storable_values, use make_storable_value.
 	* oct-obj.h: Ditto.
 	* ov-builtin.cc: non_null_value -> storable_value.
 	* ov-cell.cc: Ditto.
 	* ov-struct.cc: Ditto.
 	* pt-decl.h: Ditto.
 
-2009-01-15  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-15  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (encode_uint_image):
 	Initialize bitdepth.
 
-2009-01-14  SÔøΩren Hauberg  <hauberg@gmail.com>
+2009-01-14  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/betainc.cc, DLD-FUNCTIONS/chol.cc,
 	DLD-FUNCTIONS/daspk.cc, DLD-FUNCTIONS/dasrt.cc,
 	DLD-FUNCTIONS/dassl.cc, DLD-FUNCTIONS/filter.cc,
 	DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/gcd.cc,
 	DLD-FUNCTIONS/givens.cc, DLD-FUNCTIONS/hess.cc,
 	DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/qz.cc,
 	DLD-FUNCTIONS/schur.cc, DLD-FUNCTIONS/svd.cc,
@@ -11424,17 +11424,17 @@ 2008-09-25  David Bateman  <dbateman@fre
 	concatenate is a class object, dispatch to the appropriate
 	vertcat/horzcat function.
 
 2008-09-25  John W. Eaton  <jwe@octave.org>
 
 	* symtab.cc (symbol_table::do_find): Don't set evaluated_args and
 	args_evaluated here, prior to call to symbol_table::fcn_info::find.
 
-2008-09-24  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-09-24  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (magick_to_octave_value): New
 	template function with specializations for various
 	GraphicsMagick++ types.
 	(F__magick_finfo__): New function.
 
 2008-09-24  John W. Eaton  <jwe@octave.org>
 
@@ -11868,17 +11868,17 @@ 2008-08-07  John W. Eaton  <jwe@octave.o
 	* ov.cc (octave_value::idx_type_value): Move definition here.
 	* ov.h: From here.
 
 	* DLD-FUNCTIONS/fsolve.cc (override_options): Don't fail if
 	options_map does not contain an expected keyword.
 	Fix typo in warning identifier.
 	(make_unimplemented_options): Use CamelCase names here.
 
-2008-08-06  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-08-06  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* error.cc (Ferror): Update format of error messages in exmple.
 	* parse.y: (Feval): Likewise.
 
 2008-08-06  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/fsolve.cc (hybrd_info_to_fsolve_info):
 	Update INFO values to be compatible with Matlab's current fsolve.
@@ -14460,17 +14460,17 @@ 2008-03-28  David Bateman  <dbateman@fre
 2008-03-27  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/max.cc: Rename from minmax.cc.
 	* Makefile.in (DLD_XSRC): Rename minmax.cc to max.cc.
 
 	* DLD-FUNCTIONS/__convn__.cc (convn): Use traits class and
 	typedefs to allow all types to be deduced from argument types.
 
-2008-03-27  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-27  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc (Fconvn): Allow convolving real data with
 	complex data.
 
 2008-03-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-range.h (octave_range::subsref (const std::string&,
 	const std::list<octave_value_list>&, int)):
@@ -14510,27 +14510,27 @@ 2008-03-26  John W. Eaton  <jwe@octave.o
 	is_constant method to decide which type of subsref method to call.
 	(octave_value::assign): Always call simple subref method here.
 
 	* DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/det.cc,
 	DLD-FUNCTIONS/getpwent.cc, DLD-FUNCTIONS/inv.cc,
 	DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/symrcm.cc, file-io.cc):
 	Texinfo fixes.
 
-2008-03-26  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-26  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc (Fconvn):
 	Call complex_array_value to extract N-d array.
 
 2008-03-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-base-sparse.cc (octave_base_sparse<T>::print_raw):
 	Also display percentage of elements that are nonzero.
 
-2008-03-25  SÔøΩren Hauberg  <hauberg@gmail.com>
+2008-03-25  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc: New file.
 	* Makefile.in: Add __convn__.cc
 
 2008-03-25  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/hex2num.cc: New function
 	* Makefile.in (DLD_XSRC): Add hex2num.cc.
@@ -16800,17 +16800,17 @@ 2007-10-19  Olli Saarela  <Olli.Saarela@
 2007-10-17  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/spchol.cc (Fsymbfact): Delete special code for METIS.
 
 2007-10-17  Gabriele Pannocchia  <g.pannocchia@ing.unipi.it>
 
 	* DLD-FUNCTIONS/__qp__.cc (qp): Fix check for Wact(j).
 
-2007-10-15  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-10-15  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* error.cc (Ferror): Make text fit on pages when using smallbook.
 	* load-save.cc (Fsave_header_format_string): Ditto.
 	* ov-struct.cc (Fcell2struct): Ditto.
 	* DLD-FUNCTIONS/besselj.cc (Fairy): Ditto.
 	* DLD-FUNCTIONS/urlwrite.cc (Furlwrite, Furlread): Ditto.
 
 2007-10-15  David Bateman  <dbateman@free.fr>
@@ -17528,17 +17528,17 @@ 2007-06-25  Olaf Till  <i7tiol@t-online.
 	octave_steam_list::do_open_file_numbers,
 	octave_steam_list::do_get_file_number):
  	Use new octave_stream_list::list type.
 	(octave_stream_list::do_insert): Insert octave_stream with key
 	corresponding to file-descriptor.
 	(octave_stream_list::do_insert, octave_steam_list::insert):
 	Remove const qualifier of argument.
 
-2007-06-18  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-06-18  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__lin_interpn__.cc: Replace octave_NaN with octave_NA.
 
 2007-06-15  Shai Ayal  <shaiay@users.sourceforge.net>
 
 	* graphics.h (OCTAVE_GRAPHICS_PROPERTY_INTERNAL,
 	OCTAVE_GRAPHICS_PROPERTY, OCTAVE_GRAPHICS_MUTABLE_PROPERTY):
 	New macros. Use them to declare individual properties and define
@@ -17743,17 +17743,17 @@ 2007-05-22  John W. Eaton  <jwe@octave.o
 	(OCTAVE_RELEASE_DATE): Now 2007-05-22.
 
 2007-05-21  David Bateman  <dbateman@free.fr>
 
 	* debug.cc (Fdbstop): handle integer, vector and multiple line
 	arguments.
 	(Fdbclar): ditto. Eliminate extraneous debugging messages.
 
-2007-05-21  SÔøΩren Hauberg  <hauberg@gmail.com>
+2007-05-21  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* load-path.cc (Fpath, Frehash): Replace "LOADPATH" with "load
 	path" in doc strings.
 
 	* parse.y (Feval): Add example.
 
 2007-05-21  David Bateman  <dbateman@free.fr>
 
@@ -17764,26 +17764,26 @@ 2007-05-21  David Bateman  <dbateman@fre
 2007-05-21  John W. Eaton  <jwe@octave.org>
 
 	* oct-map.h (Octave_map::numel): Return number of array elements,
 	not number of map elements.
 	(Octave_map::nfields): Rename from length.
 	(Octave_map::empty): Delete.
 	Change all uses of empty to check nfields () == 0 instead.
 
-2007-05-21  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-21  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* help.cc (Fautoload): Doc fix.
 	* variables.cc (Fiscommand): Doc fix.
 
 2007-05-19  David Bateman  <dbatemna@free.fr>
 
 	* ov-fcn-inline.cc (Fvectorize): Doc fix.
 
-2007-05-16  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-16  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* ov.cc (Fsubsref, Fsubsasgn): Doc fix.
 
 2007-05-16  John W. Eaton  <jwe@octave.org>
 
 	* load-path.h (load_path::sys_path): New static data member.
 	(load_path::system_path): New static function.
 	(load_path::do_system_path): New function.
@@ -17841,24 +17841,24 @@ 2007-05-16  David Bateman  <dbateman@fre
 2007-05-14  Bob Weigel  <rweigel@gmu.edu>
 
 	* DLD-FUNCTIONS/svd.cc: Doc fix.
 
 2007-05-14  Thomas Weber  <thomas.weber.mail@gmail.com>
 
 	* DLD-FUNCTIONS/fft.cc (do_fft): Handle empty matrices.  New tests.
 
-2007-05-14  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-14  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* toplev.cc (Fatexit): Simplify example in doc string.
 	* help.cc (Flookfor): Doc fix.
 	* DLD-FUNCTIONS/cellfun.cc (Fcellfun):
 	Reformat to avoid long lines in doc string example.
 
-2007-05-13  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-05-13  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* toplev.cc (Fquit): Doc fix.
 	* help.cc (Fhelp): Doc fix.
 	* oct-hist.cc (Fsaving_history): Doc fix.
 
 2007-05-11  John W. Eaton  <jwe@octave.org>
 
 	* variables.cc (symbol_out_of_date):
@@ -17929,17 +17929,17 @@ 2007-04-27  David Bateman  <dbateman@fre
 	and mexSet.
 	* Makefile.in (INCLUDES): Add graphics.h
 
 2007-04-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-usr-fcn.cc (octave_user_function::do_multi_index_op):
 	Only deal with varargout if ret_list->takes_varargs () is true.
 
-2007-04-26  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-04-26  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* DLD-FUNCTIONS/urlwrite.cc: Doc fix.
 
 2007-04-26  David Bateman  <dbateman@free.fr>
 
 	* pt-loop.cc (tree_simple_for_command::eval (void)): Correct
 	reshaping of dim_vector in for loop for multi-dimensional array.
 
@@ -17958,17 +17958,17 @@ 2007-04-23  Shai Ayal  <shaiay@users.sou
 	New arg A for alpha channel.  Set rgba instead of red, green, blue.
 	(color_property::color_property (char)): New constructor.
 	(color_propery::rgba): New data member.
 	(color_property::red, color_property::green, color_property::blue):
 	Delete.
 	(color_property::validate): Use rgba.
 	(color_property::c2rgba): New function.
 
-2007-04-23  SÔøΩren Hauberg  <soren@hauberg.org>
+2007-04-23  S√∏ren Hauberg  <soren@hauberg.org>
 
 	* data.cc (Fsize_equal): Allow more than two arguments.
 
 2007-04-20  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/__gnuplot_raw__.l (deftypefn):
 	(Vautomatic_replot): Delete static variable.
 	(Fautomatic_replot): Delete function.
@@ -19361,17 +19361,17 @@ 2006-09-15  John W. Eaton  <jwe@octave.o
 	* OPERATORS/op-double-conv.cc: Declare and install sq_string
 	conversions too.
 
 	* ov-base-int.cc (octave_base_int_scalar<T>::convert_to_str_internal,
 	octave_base_int_matrix<T>::convert_to_str_internal):
 	New functions.
 	* ov-base-int.h: Provide decls.
 
-2006-09-15  SÔøΩren Hauberg  <soren@hauberg.org>.
+2006-09-15  S√∏ren Hauberg  <soren@hauberg.org>.
 
 	* data.cc (Fsize): If nargout > ndims, fill with 1.
 
 2006-09-15  John W. Eaton  <jwe@octave.org>
 
 	* octave.cc: Fix xerbla decl.
 
 2006-09-13  John W. Eaton  <jwe@octave.org>
@@ -21467,17 +21467,17 @@ 2006-03-15  William Poetra Yoga Hadisoes
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* pager.cc (Fterminal_size): New function.
 
 	* help.cc (help_from_info): Simplify.
 	(try_info): Use feval to call doc instead of executing info program.
 	(additional_help_message): Point users to doc instead of help -i.
-	From SÔøΩren Hauberg <soren@hauberg.org>.
+	From S√∏ren Hauberg <soren@hauberg.org>.
 
 	* toplev.cc (Fsystem): Return output if nargout > 1, not 0.
 
 2006-03-14  Keith Goodman  <kwgoodman@gmail.com>
 
 	* help.cc (Fhelp, Fwhich, Flookfor): Doc string fix.
 
 2006-03-14  John W. Eaton  <jwe@octave.org>
@@ -22314,17 +22314,17 @@ 2005-08-25  David Bateman  <dbateman@fre
 
 	* OPERATORS/op-sm-m.cc, OPERATORS/op-sm-cm.cc, OPERATORS/op-scm-m.cc,
 	OPERATORS/op-scm-cm.cc, OPERATORS/op-m-sm.cc, OPERATORS/op-m-scm.cc,
 	OPERATORS/op-cm-sm.cc, OPERATORS/op-cm-scm.cc: Use mixed matrix/sparse
 	multiply operator rather than casting sparse to matrix.
 
 2005-07-18  John W. Eaton  <jwe@octave.org>
 
-	* strfns.cc (Fstrcmp): New function from SÔøΩren Hauberg
+	* strfns.cc (Fstrcmp): New function from S√∏ren Hauberg
 	<soren@hauberg.org> and Tom Holroyd <tomh@kurage.nimh.nih.gov>.
 	Adapt to Octave conventions.
 
 2005-07-11  David Bateman  <dbateman@free.fr>
 
 	* ov-fc-inline.cc (Fvectorize): Allow string arguments
 
 2005-07-08  John W. Eaton  <jwe@octave.org>
diff --git a/etc/OLD-ChangeLogs/test-ChangeLog b/etc/OLD-ChangeLogs/test-ChangeLog
--- a/etc/OLD-ChangeLogs/test-ChangeLog
+++ b/etc/OLD-ChangeLogs/test-ChangeLog
@@ -280,17 +280,17 @@ 2009-02-09  John W. Eaton  <jwe@octave.o
 2009-01-29  John W. Eaton  <jwe@octave.org>
 
 	* test_system.m: Use isfield instead of struct_contains.
 
 2009-01-25  Thorsten Meyer  <thorsten@hexe>
 
 	* test_struct.m: Add struct array tests.
 
-2009-01-23  S¯ren Hauberg  <hauberg@gmail.com>
+2009-01-23  S√∏ren Hauberg  <hauberg@gmail.com>
 
 	* test_prefer.m: Update to match new API of the 'type' function.
 
 2008-12-24  John W. Eaton  <jwe@octave.org>
 
 	* fntests.m (hastests): Use fread instead of fscanf to preserve
 	whitespace.
 
diff --git a/examples/@FIRfilter/display.m b/examples/@FIRfilter/display.m
--- a/examples/@FIRfilter/display.m
+++ b/examples/@FIRfilter/display.m
@@ -1,6 +1,6 @@
 function display (f)
 
-  display(f.polynomial);
+  display (f.polynomial);
 
 endfunction
 
diff --git a/examples/@FIRfilter/subsref.m b/examples/@FIRfilter/subsref.m
--- a/examples/@FIRfilter/subsref.m
+++ b/examples/@FIRfilter/subsref.m
@@ -1,13 +1,13 @@
 function out = subsref (f, x)
   switch x.type
     case "()"
       n = f.polynomial;
-      out = filter(n.poly, 1, x.subs{1});
+      out = filter (n.poly, 1, x.subs{1});
     case "."
       fld = x.subs;
       if (strcmp (fld, "polynomial"))
         out = f.polynomial;
       else
         error ("@FIRfilter/subsref: invalid property \"%s\"", fld);
       endif
     otherwise
diff --git a/examples/@polynomial/display.m b/examples/@polynomial/display.m
--- a/examples/@polynomial/display.m
+++ b/examples/@polynomial/display.m
@@ -1,12 +1,12 @@
 function display (p)
   a = p.poly;
   first = true;
-  fprintf("%s =", inputname(1));
+  fprintf ("%s =", inputname (1));
   for i = 1 : length (a);
     if (a(i) != 0)
       if (first)
         first = false;
       elseif (a(i) > 0)
         fprintf (" +");
       endif
       if (a(i) < 0)
@@ -21,12 +21,12 @@ function display (p)
         fprintf (" X");
       endif
       if (i > 2)
         fprintf (" ^ %d", i - 1);
       endif
     endif
   endfor
   if (first)
-    fprintf(" 0");
+    fprintf (" 0");
   endif
-  fprintf("\n");
+  fprintf ("\n");
 endfunction
diff --git a/examples/@polynomial/mtimes.m b/examples/@polynomial/mtimes.m
--- a/examples/@polynomial/mtimes.m
+++ b/examples/@polynomial/mtimes.m
@@ -1,3 +1,3 @@
 function y = mtimes (a, b)
-  y = polynomial (conv (double(a),double(b)));
-endfunction
\ No newline at end of file
+  y = polynomial (conv (double (a), double (b)));
+endfunction
diff --git a/examples/@polynomial/plot.m b/examples/@polynomial/plot.m
--- a/examples/@polynomial/plot.m
+++ b/examples/@polynomial/plot.m
@@ -1,10 +1,10 @@
-function h = plot(p, varargin)
+function h = plot (p, varargin)
   n = 128;
   rmax = max (abs (roots (p.poly)));
   x = [0 : (n - 1)] / (n - 1) * 2.2 * rmax - 1.1 * rmax;
   if (nargout > 0)
-    h = plot(x, p(x), varargin{:});
+    h = plot (x, p(x), varargin{:});
   else
-    plot(x, p(x), varargin{:});
+    plot (x, p(x), varargin{:});
   endif
-endfunction
\ No newline at end of file
+endfunction
diff --git a/examples/@polynomial/polyval.m b/examples/@polynomial/polyval.m
--- a/examples/@polynomial/polyval.m
+++ b/examples/@polynomial/polyval.m
@@ -1,7 +1,7 @@
 function [y, dy] = polyval (p, varargin)
   if (nargout == 2)
-    [y, dy] = polyval (fliplr(p.poly), varargin{:});
+    [y, dy] = polyval (fliplr (p.poly), varargin{:});
   else
-    y = polyval (fliplr(p.poly), varargin{:});
+    y = polyval (fliplr (p.poly), varargin{:});
   endif
 endfunction
diff --git a/examples/myprop.c b/examples/myprop.c
--- a/examples/myprop.c
+++ b/examples/myprop.c
@@ -3,17 +3,17 @@
 void
 mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
 {
   double handle;
   char property[256];
 
   if (nrhs < 2 || nrhs > 3)
     mexErrMsgTxt ("incorrect number of arguments");
-  if (!mxIsDouble(prhs[0]))
+  if (!mxIsDouble (prhs[0]))
     mexErrMsgTxt ("handle expected to be a double scalar");
   if (!mxIsChar (prhs[1]))
     mexErrMsgTxt ("expected property to be a string");
   
   handle = mxGetScalar (prhs[0]);
   mxGetString (prhs[1], property, 256);
   plhs[0] = mxDuplicateArray (mexGet (handle, property));
   
diff --git a/examples/stringdemo.cc b/examples/stringdemo.cc
--- a/examples/stringdemo.cc
+++ b/examples/stringdemo.cc
@@ -17,17 +17,17 @@ DEFUN_DLD (stringdemo, args, , "String D
             retval(1) = octave_value (ch, true);
           else
             retval(1) = octave_value (ch, true, '\'');
 
           octave_idx_type nr = ch.rows ();
           for (octave_idx_type i = 0; i < nr / 2; i++)
             {
               std::string tmp = ch.row_as_string (i);
-              ch.insert (ch.row_as_string(nr-i-1).c_str (),
+              ch.insert (ch.row_as_string (nr-i-1).c_str (),
                          i, 0);
               ch.insert (tmp.c_str (), nr-i-1, 0);
             }
           retval(0) = octave_value (ch, true);
         }
     }
   return retval;
 }
diff --git a/examples/unwinddemo.cc b/examples/unwinddemo.cc
--- a/examples/unwinddemo.cc
+++ b/examples/unwinddemo.cc
@@ -17,15 +17,15 @@ DEFUN_DLD (unwinddemo, args, nargout, "U
     {
       NDArray a = args(0).array_value ();
       NDArray b = args(1).array_value ();
 
       if (! error_state)
         {
           unwind_protect::begin_frame ("Funwinddemo");
           unwind_protect_ptr (current_liboctave_warning_handler);
-          set_liboctave_warning_handler(err_hand);
+          set_liboctave_warning_handler (err_hand);
           retval = octave_value (quotient (a, b));
           unwind_protect::run_frame ("Funwinddemo");
         }
     }
   return retval;
 }
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -163,17 +163,17 @@
 ## Data columns are padded with empty fields or Nan so that all columns
 ## have equal length 
 ##
 ## @item last character is not "\n"
 ## Data columns are not padded; strread returns columns of unequal length
 ##
 ## @end table
 ##
-# @seealso{textscan, textread, load, dlmread, fscanf}
+## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -21,18 +21,18 @@
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{n})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{param}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{n}, @var{param}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{str}, @dots{})
 ## @deftypefnx {Function File} {[@var{C}, @var{position}] =} textscan (@var{fid}, @dots{})
 ## Read data from a text file or string.
 ##
 ## The string @var{str} or file associated with @var{fid} is read from and
-## parsed according to @var{format}. The function behaves like @code{strread}
-## except it can also read from file instead of a string. See the documentation
+## parsed according to @var{format}.  The function behaves like @code{strread}
+## except it can also read from file instead of a string.  See the documentation
 ## of @code{strread} for details.
 ##
 ## In addition to the options supported by @code{strread}, this function
 ## supports a few more:
 ##
 ## @itemize
 ## @item "collectoutput":
 ## A value of 1 or true instructs textscan to concatenate consecutive columns
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -416,25 +416,38 @@ function [local_packages, global_package
       if (length (files) == 0 && nargout == 0)
         printf ("Installation prefix:             %s\n", prefix);
         printf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (length (files) == 0 && nargout >= 1)
         local_packages = prefix;
         global_packages = archprefix;
       elseif (length (files) >= 1 && nargout <= 2 && ischar (files{1}))
         prefix = files{1};
+        try
+          prefix = absolute_pathname (prefix);
+        catch
+          [status, msg, msgid] = mkdir (prefix);
+          if (status == 0)
+            error("cannot create prefix %s: %s", prefix, msg);
+          endif
+          warning ("creating the directory %s\n", prefix);
+          prefix = absolute_pathname (prefix);
+        end_try_catch
         prefix = absolute_pathname (prefix);
         local_packages = prefix;
         user_prefix = true;
         if (length (files) >= 2 && ischar (files{2}))
           archprefix = files{2};
           try
             archprefix = absolute_pathname (archprefix);
           catch
-            mkdir (archprefix);
+            [status, msg, msgid] = mkdir (archprefix);
+            if (status == 0)
+              error("cannot create archprefix %s: %s", archprefix, msg);
+            endif
             warning ("creating the directory %s\n", archprefix);
             archprefix = absolute_pathname (archprefix);
           end_try_catch
           global_packages = archprefix;
         endif
       else
         error ("you must specify a prefix directory, or request an output argument");
       endif
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -12,27 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
-## Returns the default graphics toolkit. The default graphics toolkit value
+## @deftypefn {Function File} {@var{name} =} graphics_toolkit ()
+## Return the default graphics toolkit.  The default graphics toolkit value
 ## is assigned to new figures.
 ## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
-## Returns the graphics toolkits for the figures with handles @var{hlist}.
+## Return the graphics toolkits for the figures with handles @var{hlist}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
-## Sets the default graphics toolkit to @var{name}.  If the toolkit is not
+## Set the default graphics toolkit to @var{name}.  If the toolkit is not
 ## already loaded, it is initialized by calling the function
 ## @code{__init_@var{name}__}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Sets the graphics toolkit for the figues with handles @var{hlist} to
+## Set the graphics toolkit for the figures with handles @var{hlist} to
 ## @var{name}.
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -72,19 +72,19 @@
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
 ## @item -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
-## vector formats by using ghostscript.
-## For bitmap and printer output antialiasing is applied using
-## ghostscript's TextAlphaBits and GraphicsAlphaBits options.
+## vector formats by using Ghostscript.
+## For bitmap and printer output anti-aliasing is applied using
+## Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
 ## The default number of bits for each is 4.
 ## Allowed values, for @var{N}, are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device},
 ##   and is one of:
 ##
 ##   @table @code
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -41,16 +41,17 @@
 ## a function handle or inline function @code{g} such that
 ## @code{g(x, "notransp") = M1 \ x} or @code{g(x, "notransp") = M2 \ x} and
 ## @code{g(x, "transp") = M1' \ x} or @code{g(x, "transp") = M2' \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -43,16 +43,17 @@
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -43,16 +43,17 @@
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -26,17 +26,17 @@
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
 ## (see @code{datestr}).  If @var{date} is a string, but no format is
 ## specified, then a relatively slow search is performed through various
-## formats.  It is always preferable to specifiy the format string @var{f}
+## formats.  It is always preferable to specify the format string @var{f}
 ## if it is known.  Formats which do not specify a particular time component
 ## will have the value set to zero.  Formats which do not specify a date will
 ## default to January 1st of the current year.
 ##
 ## @var{p} is the year at the start of the century to which two-digit years
 ## will be referenced.  If not specified, it defaults to the current year
 ## minus 50.
 ## @seealso{datenum, datestr, clock, now, date}
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -104,17 +104,17 @@ Undocumented internal function.\n\
       if (file_count == 1 && multi_type != Fl_File_Chooser::DIRECTORY)
         {
           fname = fc.value ();
           idx = fname.find_last_of (sep);
           retval(0) = fname.substr (idx + 1);
         }
       else
         {
-          Cell file_cell = Cell(file_count, 1);
+          Cell file_cell = Cell (file_count, 1);
           for (octave_idx_type n = 1; n <= file_count; n++)
             {
               fname = fc.value (n);
               idx = fname.find_last_of (sep);
               file_cell(n - 1) = fname.substr (idx + 1);
             }
           retval(0) = file_cell;
         }
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -277,26 +277,26 @@ glpk (int sense, int n, int m, double *c
       if (lpx_write_cpxlp (lp, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
   //-- scale the problem data (if required)
-  //-- if (scale && (!presol || method == 1)) lpx_scale_prob(lp);
+  //-- if (scale && (!presol || method == 1)) lpx_scale_prob (lp);
   //-- LPX_K_SCALE=IParam[1]  LPX_K_PRESOL=IParam[16]
   if (lpxIntParam[1] && (! lpxIntParam[16] || lpsolver != 1))
     lpx_scale_prob (lp);
 
   //-- build advanced initial basis (if required)
   if (lpsolver == 1 && ! lpxIntParam[16])
     lpx_adv_basis (lp);
 
-  for(int i = 0; i < NIntP; i++)
+  for (int i = 0; i < NIntP; i++)
     lpx_set_int_parm (lp, IParam[i], lpxIntParam[i]);
 
   for (int i = 0; i < NRealP; i++)
     lpx_set_real_parm (lp, RParam[i], lpxRealParam[i]);
 
   if (lpsolver == 1)
     method = 'S';
   else
@@ -308,22 +308,22 @@ glpk (int sense, int n, int m, double *c
       {
         if (isMIP)
           {
             method = 'I';
             errnum = lpx_simplex (lp);
             errnum = lpx_integer (lp);
           }
         else
-          errnum = lpx_simplex(lp);
+          errnum = lpx_simplex (lp);
       }
      break;
 
     case 'T':
-      errnum = lpx_interior(lp);
+      errnum = lpx_interior (lp);
       break;
 
     default:
       break;
 #if 0
 #ifdef GLPK_PRE_4_14
       insist (method != method);
 #else
@@ -526,20 +526,20 @@ Undocumented internal function.\n\
 
       if (Anc != mrowsc)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       for (octave_idx_type j = 0; j < Anc; j++)
-        for (octave_idx_type i = A.cidx(j); i < A.cidx(j+1); i++)
+        for (octave_idx_type i = A.cidx (j); i < A.cidx (j+1); i++)
           {
             nz++;
-            rn(nz) = A.ridx(i) + 1;
+            rn(nz) = A.ridx (i) + 1;
             cn(nz) = j + 1;
             a(nz) = A.data(i);
           }
     }
   else
     {
       Matrix A (args(1).matrix_value ()); // get the matrix
 
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -252,29 +252,29 @@ private:
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double wheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
-void script_cb(Fl_Widget*, void* data)
+void script_cb (Fl_Widget*, void* data)
   {
     static_cast<uimenu::properties*> (data)->execute_callback ();
   }
 
 
 class fltk_uimenu
 {
 public:
   fltk_uimenu (int xx, int yy, int ww, int hh)
     {
       menubar = new
-        Fl_Menu_Bar(xx, yy, ww, hh);
+        Fl_Menu_Bar (xx, yy, ww, hh);
     }
 
   int items_to_show (void)
     {
       //returns the number of visible menu items
       int len = menubar->size ();
       int n = 0;
       for (int t = 0; t < len; t++ )
@@ -680,17 +680,17 @@ public:
     {
 
       canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
 
       uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
       bottom = new Fl_Box (0, hh - status_h, ww, status_h);
-      bottom->box(FL_FLAT_BOX);
+      bottom->box (FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
       autoscale = new Fl_Button (0, hh - status_h, status_h, status_h, "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
       autoscale->tooltip ("Autoscale");
 
       togglegrid = new Fl_Button (status_h, hh - status_h, status_h,
@@ -1919,18 +1919,18 @@ public:
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
         if (id == uimenu::properties::ID_LABEL)
           uimenu_set_fltk_label (go);
 
-        graphics_object fig = go.get_ancestor("figure");
-        figure_manager::uimenu_update(fig.get_handle (), go.get_handle (), id);
+        graphics_object fig = go.get_ancestor ("figure");
+        figure_manager::uimenu_update (fig.get_handle (), go.get_handle (), id);
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -398,19 +398,19 @@ maybe_initialize_magick (void)
 
       initialized = true;
     }
 #endif
 }
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
+@deftypefn  {Function File} {@var{m} =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{index})\n\
 Read images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
@@ -599,17 +599,17 @@ encode_bool_image (std::vector<Magick::I
 
   Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
 
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
-      Magick::Image im(Magick::Geometry (columns, rows), "black");
+      Magick::Image im (Magick::Geometry (columns, rows), "black");
       im.classType (Magick::DirectClass);
       im.depth (1);
 
       for (int y = 0; y < columns; y++)
         {
           idx(1) = y;
 
           for (int x = 0; x < rows; x++)
@@ -866,18 +866,18 @@ write_image (const std::string& filename
       error ("Magick++ exception: %s", e.what ());
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
-@deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
+@deftypefn  {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img})\n\
+@deftypefnx {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
 Write images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
@@ -1002,17 +1002,17 @@ magick_to_octave_value (const Magick::Im
   catch (Magick::Warning& w) \
     { \
     }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_finfo__(@var{fname})\n\
+@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick++.  In general you should\n\
 not be using this function.  Instead use @code{imfinfo}.\n\
 @seealso{imfinfo, imread}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_MAGICK
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -383,31 +383,31 @@ DEFUN_DLD (besselj, args, nargout,
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item bessely\n\
 Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item besseli\n\
 \n\
 Modified Bessel functions of the first kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(-abs(real(@var{x})))}.\n\
+supplied, the result is multiplied by @code{exp (-abs (real (@var{x})))}.\n\
 \n\
 @item besselk\n\
 \n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(@var{x})}.\n\
+supplied, the result is multiplied by @code{exp (@var{x})}.\n\
 \n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
 = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied\n\
 by @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
@@ -528,18 +528,18 @@ Compute Airy functions of the first and 
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
  1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
@@ -1068,18 +1068,18 @@ Table 9.8 - I and K for integer orders 0
 %!         [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
 %!         [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
 %!         [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
 %!         [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
 %!         [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
 %!         [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
 %!
 %! tbl = [besseli(n,z1,1), besselk(n,z1,1)];
-%! tbl(:,3) = tbl(:,3) .* (exp(z1).*z1.^(-2));
-%! tbl(:,6) = tbl(:,6) .* (exp(-z1).*z1.^(2));
+%! tbl(:,3) = tbl(:,3) .* (exp (z1) .* z1.^(-2));
+%! tbl(:,6) = tbl(:,6) .* (exp (-z1) .* z1.^(2));
 %! tbl = [tbl;[besseli(n,z2,1),besselk(n,z2,1)]];
 %!
 %! assert (tbl, rtbl, -2e-8);
 
 Table 9.9 - I and K for orders 3-9.
 
 %!test
 %! It = [[  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00];
@@ -1106,17 +1106,17 @@ Table 9.9 - I and K for orders 3-9.
 %!      [  3.7411e-01  4.5162e-01  5.7483e-01  7.7097e-01  1.0888e+00  1.6178e+00  2.5269e+00];
 %!      [  3.4684e-01  4.1114e-01  5.1130e-01  6.6679e-01  9.1137e-01  1.3048e+00  1.9552e+00]];
 %!
 %! n = (3:9);
 %! z = (0:2:20).';
 %! I = besseli (n,z,1);
 %! K = besselk (n,z,1);
 %!
-%! assert (abs (I(1,:)), zeros (1, columns(I)));
+%! assert (abs (I(1,:)), zeros (1, columns (I)));
 %! assert (I(2:end,:), It(2:end,:), -5e-5);
 %! assert (Kt(1,:), K(1,:));
 %! assert (K(2:end,:), Kt(2:end,:), -5e-5);
 
 Table 9.11 - I and K for various integer orders and arguments.
 
 %!test
 %! It = [[   1.266065878e+00    2.279585302e+00    2.723987182e+01    2.815716628e+03     2.93255378e+20     1.07375171e+42 ];
@@ -1149,17 +1149,17 @@ Table 9.11 - I and K for various integer
 The next section checks that negative integer orders and positive
 integer orders are appropriately related.
 
 %!test
 %! n = (0:2:20);
 %! assert (besselj (n,1), besselj (-n,1), 1e-8);
 %! assert (-besselj (n+1,1), besselj (-n-1,1), 1e-8);
 
-besseli(n,z) = besseli(-n,z);
+besseli (n,z) = besseli (-n,z);
 
 %!test
 %! n = (0:2:20);
 %! assert (besseli (n,1), besseli (-n,1), 1e-8);
 
 Table 10.1 - j and y for integer orders 0, 1, 2.
 Compare against excerpts of Table 10.1, Abramowitz and Stegun.
 
@@ -1174,32 +1174,32 @@ Compare against excerpts of Table 10.1, 
 %!       [   -5.4402e-02      7.8467e-02     7.7942e-02 ]];
 %!
 %! yt = [[-9.9500417e+00  -1.0049875e+02 -3.0050125e+03 ];
 %!       [ 3.2045745e-01  -1.1120588e-01 -4.5390450e-01 ];
 %!       [-5.6732437e-02   1.8043837e-01  1.6499546e-01 ];
 %!       [   -4.6218e-02     -1.3123e-01    -6.2736e-03 ];
 %!       [    8.3907e-02      6.2793e-02    -6.5069e-02 ]];
 %!
-%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
-%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
-%! assert(jt, j, -5e-5);
-%! assert(yt, y, -5e-5);
+%! j = sqrt ((pi/2)./z) .* besselj (n+1/2,z);
+%! y = sqrt ((pi/2)./z) .* bessely (n+1/2,z);
+%! assert (jt, j, -5e-5);
+%! assert (yt, y, -5e-5);
 
 Table 10.2 - j and y for orders 3-8.
 Compare against excerpts of Table 10.2, Abramowitzh and Stegun.
 
  Important note: In A&S, y_4(0.1) = -1.0507e+7, but Octave returns
- y_4(0.1) = -1.0508e+07 (-10507503.75). If I compute the same term using
+ y_4(0.1) = -1.0508e+07 (-10507503.75).  If I compute the same term using
  a series, the difference is in the eighth significant digit so I left
  the Octave results in place.
 
 %!test
 %! n = (3:8);
-%! z = (0:2.5:10).';  z(1)=0.1;
+%! z = (0:2.5:10).';  z(1) = 0.1;
 %!
 %! jt = [[ 9.5185e-06  1.0577e-07  9.6163e-10  7.3975e-12  4.9319e-14  2.9012e-16];
 %!       [ 1.0392e-01  3.0911e-02  7.3576e-03  1.4630e-03  2.5009e-04  3.7516e-05];
 %!       [ 2.2982e-01  1.8702e-01  1.0681e-01  4.7967e-02  1.7903e-02  5.7414e-03];
 %!       [-6.1713e-02  7.9285e-02  1.5685e-01  1.5077e-01  1.0448e-01  5.8188e-02];
 %!       [-3.9496e-02 -1.0559e-01 -5.5535e-02  4.4501e-02  1.1339e-01  1.2558e-01]];
 %!
 %! yt = [[-1.5015e+05 -1.0508e+07 -9.4553e+08 -1.0400e+11 -1.3519e+13 -2.0277e+15];
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -228,19 +228,19 @@ maybe_update_column (octave_value& Ac, c
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
           if (dva (j) == 1)
-            idx (j) = octave_value (1);
+            idx(j) = octave_value (1);
           else
-            idx (j) = octave_value ((i % dvc(j)) + 1);
+            idx(j) = octave_value ((i % dvc(j)) + 1);
 
           i = i / dvc (j);
         }
 
       Ac = A;
       Ac = Ac.single_subsref ("(", idx);
       return true;
     }
@@ -780,18 +780,18 @@ dimensionality as the other array.\n\
 %! float_types = {@single, @double};
 %! int_types = {@int8, @int16, @int32, @int64, \
 %!              @uint8, @uint16, @uint32, @uint64};
 %!
 %! x = rand (3) * 10-5;
 %! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
-%!   for j = 1:length(float_types)
-%!     for k = 1:length(int_types)
+%!   for j = 1:length (float_types)
+%!     for k = 1:length (int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
 %!
 %!         assert (bsxfun (fun, f_type (x), i_type (y)), \
 %!                 fun (f_type(x), i_type (y)));
 %!         assert (bsxfun (fun, f_type (y), i_type (x)), \
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -98,17 +98,17 @@ if nonzero, statistics and knobs are pri
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length @math{n}.  It defines the\n\
 constraints on the column ordering.  If @code{@var{cmember}(j) = @var{c}},\n\
 then column @var{j} is in constraint set @var{c} (@var{c} must be in the\n\
 range 1 to\n\
 n).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
-ones(1,n)} if not present or empty.\n\
+ones (1,n)} if not present or empty.\n\
 @code{ccolamd (@var{S}, [], 1 : n)} returns @code{1 : n}\n\
 \n\
 @code{@var{p} = ccolamd (@var{S})} is about the same as\n\
 @code{@var{p} = colamd (@var{S})}.  @var{knobs} and its default values\n\
 differ.  @code{colamd} always does aggressive absorption, and it finds an\n\
 ordering suitable for both @code{lu (@var{S}(:, @var{p}))} and @code{chol\n\
 (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))}; it cannot optimize its\n\
 ordering for @code{lu (@var{S}(:, @var{p}))} to the extent that\n\
@@ -176,33 +176,33 @@ colamd, symamd, and other related orderi
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                             << ":\nknobs(1): " << User_knobs (0) << ", order for ";
               if ( knobs [CCOLAMD_LU] != 0)
-                octave_stdout << "lu(A)\n";
+                octave_stdout << "lu (A)\n";
               else
-                octave_stdout << "chol(A'*A)\n";
+                octave_stdout << "chol (A'*A)\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", rows with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", no dense rows removed\n";
 
               if (knobs [CCOLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(3): " << User_knobs (2)
-                              << ", cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", no dense columns removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
@@ -297,17 +297,17 @@ colamd, symamd, and other related orderi
               error ("ccolamd: internal error!");
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [i] + 1;
+        out_perm(i) = p[i] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
@@ -367,21 +367,21 @@ If nonzero, aggressive absorption is per
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
 on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
-by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}\n\
-if not present or empty.  @code{csymamd(@var{S},[],1:n)} returns @code{1:n}.\n\
+by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones (1,n)}\n\
+if not present or empty.  @code{csymamd (@var{S},[],1:n)} returns @code{1:n}.\n\
 \n\
-@code{@var{p} = csymamd(@var{S})} is about the same as @code{@var{p} =\n\
-symamd(@var{S})}.  @var{knobs} and its default values differ.\n\
+@code{@var{p} = csymamd (@var{S})} is about the same as @code{@var{p} =\n\
+symamd (@var{S})}.  @var{knobs} and its default values differ.\n\
 \n\
 @code{@var{stats}(4:7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
 such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
@@ -428,18 +428,18 @@ colamd, symamd, and other related orderi
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows/cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows/cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", no dense rows/cols removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
@@ -529,17 +529,17 @@ colamd, symamd, and other related orderi
               error ("csymamd: internal error!") ;
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [i] + 1;
+        out_perm(i) = perm[i] + 1;
 
       retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -111,69 +111,69 @@ try_cellfun_internal_ops (const octave_v
   const Cell f_args = args(1).cell_value ();
 
   octave_idx_type k = f_args.numel ();
 
   if (name == "isempty")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = f_args.elem(count).is_empty ();
+        result(count) = f_args.elem (count).is_empty ();
       retval(0) = result;
     }
   else if (name == "islogical")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_bool_type ();
+        result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_real_type ();
+        result(count) = f_args.elem (count).is_real_type ();
       retval(0) = result;
     }
   else if (name == "length")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).length ());
+        result(count) = static_cast<double> (f_args.elem (count).length ());
       retval(0) = result;
     }
   else if (name == "ndims")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).ndims ());
+        result(count) = static_cast<double> (f_args.elem (count).ndims ());
       retval(0) = result;
     }
   else if (name == "prodofsize" || name == "numel")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).numel ());
+        result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
       if (nargin == 3)
         {
           int d = args(2).nint_value () - 1;
 
           if (d < 0)
             error ("cellfun: K must be a positive integer");
 
           if (! error_state)
             {
               NDArray result (f_args.dims ());
               for (octave_idx_type count = 0; count < k; count++)
                 {
-                  dim_vector dv = f_args.elem(count).dims ();
+                  dim_vector dv = f_args.elem (count).dims ();
                   if (d < dv.length ())
                     result(count) = static_cast<double> (dv(d));
                   else
                     result(count) = 1.0;
                 }
               retval(0) = result;
             }
         }
@@ -182,17 +182,17 @@ try_cellfun_internal_ops (const octave_v
     }
   else if (name == "isclass")
     {
       if (nargin == 3)
         {
           std::string class_name = args(2).string_value ();
           boolNDArray result (f_args.dims ());
           for (octave_idx_type count = 0; count < k; count++)
-            result(count) = (f_args.elem(count).class_name () == class_name);
+            result(count) = (f_args.elem (count).class_name () == class_name);
 
           retval(0) = result;
         }
       else
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
@@ -312,17 +312,17 @@ arguments of the function.  The outputs 
 into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
 @group\n\
 function [a, b] = twoouts (x)\n\
   a = x;\n\
   b = x*x;\n\
 endfunction\n\
-[aa, bb] = cellfun(@@twoouts, @{1, 2, 3@})\n\
+[aa, bb] = cellfun (@@twoouts, @{1, 2, 3@})\n\
      @result{}\n\
         aa =\n\
            1 2 3\n\
         bb =\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
@@ -370,17 +370,17 @@ useful tool for avoiding loops.  It is o
 function handles; however, calling an anonymous function involves an\n\
 overhead quite comparable to the overhead of an m-file function.\n\
 Passing a handle to a built-in function is faster, because the\n\
 interpreter is not involved in the internal loop.  For example:\n\
 \n\
 @example\n\
 @group\n\
 a = @{@dots{}@}\n\
-v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@(x) det (x), a); # compute determinants\n\
 v = cellfun (@@det, a); # faster\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -762,17 +762,17 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@islogical, {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
-%! A = cellfun (@(x) islogical(x), {true, 0.1, false, i*2});
+%! A = cellfun (@(x) islogical (x), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 
 %% First input argument can be the special string "isreal",
 %% "isempty", "islogical", "length", "ndims" or "prodofsize"
 %!test
 %! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
 %! assert (A, [true, true, false, false, true, true]);
 %!test
@@ -859,26 +859,26 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -887,25 +887,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
@@ -921,25 +921,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", false);
 %! assert (A, {true, false});
 %!test
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
@@ -1484,17 +1484,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@isequal, [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
-%! A = arrayfun (@(x,y) isequal(x,y), [false, true], [true, true]);
+%! A = arrayfun (@(x,y) isequal (x,y), [false, true], [true, true]);
 %! assert (A, [false, true]);
 
 %% Number of input and output arguments may be greater than one
 %#!test
 %! A = arrayfun (@(x) islogical (x), false);
 %! assert (A, true);
 %!test
 %! A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
@@ -1556,26 +1556,26 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -1585,17 +1585,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], \
+%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
@@ -1637,17 +1637,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
+%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
@@ -1785,17 +1785,17 @@ do_object2cell (const octave_value& obj,
           octave_value_list idx (1);
 
           for (octave_idx_type i = 0; i < dv.numel (); i++)
             {
               octave_quit ();
 
               idx(0) = double (i+1);
 
-              retval.xelem(i) = array.single_subsref ("(", idx);
+              retval.xelem (i) = array.single_subsref ("(", idx);
 
               if (error_state)
                 break;
             }
         }
     }
   else
     {
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -367,21 +367,21 @@ sparse matrices.\n\
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
-%!assert (chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
+%!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
 
+%!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
-%!error chol ()
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Use the Cholesky@tie{}factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{A}.\n\
@@ -984,17 +984,17 @@ If @var{info} is not present, an error m
 
 %!test
 %! u2 = single ([  0.35080 ;
 %!                 0.63930 ;
 %!                 3.31057 ;
 %!                -0.13825 ;
 %!                 0.45266 ]);
 %!
-%! R = chol(single(A));
+%! R = chol (single (A));
 %!
 %! j = 3;  p = [1:j-1, j+1:5];
 %! R1 = cholinsert (R, j, u2);
 %! A1 = R1'*R1;
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (A1(p,p) - A, Inf) < 1e1*eps ("single"));
 
@@ -1178,17 +1178,17 @@ triangular, return the Cholesky@tie{}fac
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! R = chol(A);
+%! R = chol (A);
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
@@ -1205,20 +1205,20 @@ triangular, return the Cholesky@tie{}fac
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
 
 %!test
-%! R = chol(single(Ac));
+%! R = chol (single (Ac));
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
+%! R1 = choldelete (R,j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
@@ -1330,18 +1330,18 @@ triangular, return the Cholesky@tie{}fac
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 %!
 %! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
 %!
-%! assert (norm(triu(R1)-R1, Inf), 0);
-%! assert (norm(R1'*R1 - A(p,p), Inf) < 1e1*eps);
+%! assert (norm (triu (R1) - R1, Inf), 0);
+%! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
 %! R = chol (Ac);
 %!
 %! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -221,17 +221,17 @@ degree permutation vector for the sparse
 non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
 sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
 @code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
 than that of @code{@var{S}' * @var{S}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{S} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))}\n\
 entries are ignored.  Columns with more than\n\
-@code{max(16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
+@code{max (16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
 ordering, and ordered last in the output permutation @var{p}.  Only\n\
 completely dense rows or columns are removed if @code{@var{knobs}(1)} and\n\
 @code{@var{knobs}(2)} are < 0, respectively.  If @code{@var{knobs}(3)} is\n\
 nonzero, @var{stats} and @var{knobs} are printed.  The default is\n\
 @code{@var{knobs} = [10 10 0]}.  Note that @var{knobs} differs from earlier\n\
 versions of colamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
@@ -309,27 +309,27 @@ Ng, Oak Ridge National Laboratory.  (see
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
               if (knobs [COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows with > max(16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
               if (knobs [COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", cols with > max(16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -410,17 +410,17 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [colbeg [i]] + 1;
+        out_perm(i) = p[colbeg [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
@@ -459,17 +459,17 @@ For a symmetric positive definite matrix
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
 well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
 to be symmetric; only the strictly lower triangular part is referenced.\n\
 @var{S} must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
-@code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
+@code{max (16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
 @code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs}\n\
 = [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
 statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1) =\n\
@@ -603,17 +603,17 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [post [i]] + 1;
+        out_perm(i) = perm[post [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -316,17 +316,17 @@ parameters for @code{daspk}.\n\
               if (daspk_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     daspk_jac = c(1).function_value ();
                   else
                     {
                       jac_name = unique_symbol_name ("__daspk_jac__");
                       jname = "function jac = ";
-                      jname.append(jac_name);
+                      jname.append (jac_name);
                       jname.append (" (x, xdot, t, cj) jac = ");
                       daspk_jac = extract_function
                         (c(1), "daspk", jac_name, jname, "; endfunction");
 
                       if (!daspk_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
@@ -372,17 +372,17 @@ parameters for @code{daspk}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         daspk_fcn = extract_function
                           (tmp(0), "daspk", fcn_name, fname, "; endfunction");
 
                         if (daspk_fcn)
                           {
                             jac_name = unique_symbol_name ("__daspk_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             daspk_jac = extract_function
                               (tmp(1), "daspk", jac_name, jname,
                                "; endfunction");
 
                             if (!daspk_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -404,17 +404,17 @@ parameters for @code{dasrt}.\n\
           if (dasrt_f)
             {
               if (c(1).is_function_handle () || c(1).is_inline_function ())
                 dasrt_j = c(1).function_value ();
               else
                 {
                   jac_name = unique_symbol_name ("__dasrt_jac__");
                   jname = "function jac = ";
-                  jname.append(jac_name);
+                  jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function
                     (c(1), "dasrt", jac_name, jname, "; endfunction");
 
                   if (!dasrt_j)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
@@ -456,17 +456,17 @@ parameters for @code{dasrt}.\n\
                     fname.append (" (x, xdot, t) y = ");
                     dasrt_f = extract_function
                       (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
 
                     if (dasrt_f)
                       {
                         jac_name = unique_symbol_name ("__dasrt_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dasrt_j = extract_function
                           (tmp(1), "dasrt", jac_name, jname, "; endfunction");
 
                         if (! dasrt_j)
                           dasrt_f = 0;
                       }
                   }
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -317,17 +317,17 @@ parameters for @code{dassl}.\n\
               if (dassl_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     dassl_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__dassl_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dassl_jac = extract_function
                           (c(1), "dassl", jac_name, jname, "; endfunction");
 
                         if (!dassl_jac)
                           {
                             if (fcn_name.length ())
                               clear_function (fcn_name);
@@ -373,17 +373,17 @@ parameters for @code{dassl}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         dassl_fcn = extract_function
                           (tmp(0), "dassl", fcn_name, fname, "; endfunction");
 
                         if (dassl_fcn)
                           {
                             jac_name = unique_symbol_name ("__dassl_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             dassl_jac = extract_function
                               (tmp(1), "dassl", jac_name, jname,
                                "; endfunction");
 
                             if (!dassl_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
-    ret.xelem(i) = p[i] + 1;
+    ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
 #if HAVE_CXSPARSE
 static octave_value_list
 dmperm_internal (bool rank, const octave_value arg, int nargout)
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -275,17 +275,17 @@ dimension of the matrix along which the 
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
-%! S = zeros (size(t));
+%! S = zeros (size (t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -711,19 +711,19 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!test
 %! a = [1,1];
 %! b=[1,1];
 %! x = zeros (4,4,2);  x(1,1:4,1) = +1;  x(1,1:4,2) = -1;
 %! y0 = zeros (4,4,2);  y0(1:2,1:4,1) = +1;  y0(1:2,1:4,2) = -1;
 %! y = filter (b, [1], x);
 %! assert (y, y0);
 
-%!assert (filter (1, ones(10,1)/10, []), [])
-%!assert (filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10))
-%!assert (filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5))
+%!assert (filter (1, ones (10,1) / 10, []), [])
+%!assert (filter (1, ones (10,1) / 10, zeros (0,10)), zeros (0,10))
+%!assert (filter (1, ones (10,1) / 10, single (1:5)), repmat (single (10), 1, 5))
 
 %% Test using initial conditions
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2])
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2])
 %!assert (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18])
 %!error (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'))
 %!assert (filter ([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21])
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -106,42 +106,42 @@ find_nonzero_elem_idx (const Sparse<T>& 
       n_to_find = nz;
       count = nz;
     }
   else if (direction > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == 0 && v.cidx(j+1) != 0)
+          if (v.cidx (j) == 0 && v.cidx (j+1) != 0)
             start_nc = j;
-          if (v.cidx(j+1) >= n_to_find)
+          if (v.cidx (j+1) >= n_to_find)
             {
               end_nc = j + 1;
               break;
             }
         }
     }
   else
     {
       for (octave_idx_type j = nc; j > 0; j--)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == nz && v.cidx(j-1) != nz)
+          if (v.cidx (j) == nz && v.cidx (j-1) != nz)
             end_nc = j;
-          if (nz - v.cidx(j-1) >= n_to_find)
+          if (nz - v.cidx (j-1) >= n_to_find)
             {
               start_nc = j - 1;
               break;
             }
         }
     }
 
-  count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ?
-           v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
+  count = (n_to_find > v.cidx (end_nc) - v.cidx (start_nc) ?
+           v.cidx (end_nc) - v.cidx (start_nc) : n_to_find);
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
   octave_idx_type result_nr = count;
   octave_idx_type result_nc = 1;
 
@@ -163,24 +163,24 @@ find_nonzero_elem_idx (const Sparse<T>& 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
-        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ )
+        for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++ )
           {
             OCTAVE_QUIT;
             if (direction < 0 && i < nz - count)
               continue;
-            i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
+            i_idx(cx) = static_cast<double> (v.ridx (i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
-            idx(cx) = j * nr + v.ridx(i) + 1;
+            idx(cx) = j * nr + v.ridx (i) + 1;
             val(cx) = v.data(i);
             cx++;
             if (cx == count)
               break;
           }
     }
   else if (scalar_arg)
     {
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -71,18 +71,18 @@ divide (const std::complex<FP>& a, const
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
 simple_gcd (const std::complex<FP>& a, const std::complex<FP>& b)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
 
   if (abs (aa) < abs (bb))
     std::swap (aa, bb);
@@ -151,18 +151,18 @@ extended_gcd (double a, double b, double
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a, bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -83,17 +83,17 @@ kron (const MDiagArray2<R>& a, const MAr
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
   MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
-        mx_inline_mul (nrb, &c.xelem(ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
+        mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
       }
 
   return c;
 }
 
 template <class T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
@@ -105,17 +105,17 @@ kron (const MSparse<T>& A, const MSparse
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
         octave_quit ();
         for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
           {
-            octave_idx_type Ci = A.ridx(Ai) * B.rows ();
+            octave_idx_type Ci = A.ridx (Ai) * B.rows ();
             const T v = A.data (Ai);
 
             for (octave_idx_type Bi = B.cidx (Bj); Bi < B.cidx (Bj+1); Bi++)
               {
                 C.data (idx) = v * B.data (Bi);
                 C.ridx (idx++) = Ci + B.ridx (Bi);
               }
           }
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -166,17 +166,17 @@ Solve the set of differential equations\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 dx\n\
--- = f(x, t)\n\
+-- = f (x, t)\n\
 dt\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 with\n\
 \n\
 @example\n\
@@ -317,17 +317,17 @@ parameters for @code{lsode}.\n\
               if (lsode_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     lsode_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__lsode_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, t) jac = ");
                         lsode_jac = extract_function
                           (c(1), "lsode", jac_name, jname, "; endfunction");
 
                       if (!lsode_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
@@ -373,17 +373,17 @@ parameters for @code{lsode}.\n\
                         fname.append (" (x, t) y = ");
                         lsode_fcn = extract_function
                           (tmp(0), "lsode", fcn_name, fname, "; endfunction");
 
                         if (lsode_fcn)
                           {
                             jac_name = unique_symbol_name ("__lsode_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, t) jac = ");
                             lsode_jac = extract_function
                               (tmp(1), "lsode", jac_name, jname,
                               "; endfunction");
 
                             if (!lsode_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -174,17 +174,17 @@ information.\n\
           Matrix tmp = args(n++).matrix_value ();
 
           if (! error_state )
             {
               if (!issparse)
                 error ("lu: can not define pivoting threshold THRES for full matrices");
               else if (tmp.nelem () == 1)
                 {
-                  thres.resize(1,2);
+                  thres.resize (1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
                 }
               else if (tmp.nelem () == 2)
                 thres = tmp;
               else
                 error ("lu: expecting 2-element vector for THRES");
             }
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -149,17 +149,17 @@ Given the string argument \"vector\", @c
 
               tmp = map.getfield ("thresh");
               if (tmp.is_defined ())
                 {
                   thresh = tmp.matrix_value ();
 
                   if (thresh.nelem () == 1)
                     {
-                      thresh.resize(1,2);
+                      thresh.resize (1,2);
                       thresh(1) = thresh(0);
                     }
                   else if (thresh.nelem () != 2)
                     {
                       error ("luinc: expecting 2-element vector for thresh");
                       return retval;
                     }
                 }
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -187,17 +187,17 @@ evaluate.  The function must have the fo
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both may be infinite.\n\
 \n\
 The optional argument @var{tol} is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.  To choose a relative test only, set the absolute\n\
 tolerance to zero.  To choose an absolute test only, set the relative\n\
-tolerance to zero.  Both tolerances default to @code{sqrt(eps)} or\n\
+tolerance to zero.  Both tolerances default to @code{sqrt (eps)} or\n\
 approximately @math{1.5e^{-8}}.\n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is known to be singular.\n\
 \n\
 The result of the integration is returned in @var{q}.  @var{ier}\n\
 contains an integer error code (0 indicates a successful integration).\n\
 @var{nfun} indicates the number of function evaluations that were\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1488,17 +1488,17 @@ values if given a vector of input values
 f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element `dot' form for all operators.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both limits may be infinite.  @code{quadcc} handles an inifinite limit\n\
-by substituting the variable of integration with @code{x=tan(pi/2*u)}.\n\
+by substituting the variable of integration with @code{x = tan (pi/2*u)}.\n\
 \n\
 The optional argument @var{tol} defines the relative tolerance used to stop\n\
 the integration procedure.  The default value is @math{1e^{-6}}.\n\
 \n\
 The optional argument @var{sing} contains a list of points where the\n\
 integrand has known singularities, or discontinuities\n\
 in any of its derivatives, inside the integration interval.\n\
 For the example above, which has a discontinuity at x=1, the call to\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -443,17 +443,17 @@ However, it should be noted that queryin
 @code{rand} to use the old generators, only setting the seed will.\n\
 To cause @code{rand} to once again use the new generators, the\n\
 keyword \"state\" should be used to reset the state of the @code{rand}.\n\
 \n\
 The state or seed of the generator can be reset to a new random value\n\
 using the \"reset\" keyword.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{randn, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   retval = do_rand (args, nargin, "rand", "uniform");
@@ -551,17 +551,17 @@ DEFUN_DLD (randn, args, ,
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
@@ -621,17 +621,17 @@ DEFUN_DLD (rande, args, ,
 @deftypefnx {Loadable Function} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to an exponential distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
@@ -686,17 +686,17 @@ DEFUN_DLD (randg, args, ,
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"single\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"double\")\n\
-Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
+Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
 \n\
@@ -767,17 +767,17 @@ r(df > 0) += 2 * randg (df(df > 0)/2)\n\
 r = (randg (a1), @dots{}, randg (ak))\n\
 r = r / sum (r)\n\
 @end group\n\
 @end example\n\
 \n\
 @end table\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -989,17 +989,17 @@ unimodal distributions}, Doctoral Disser
 University Graz, Austria, 1994.\n\
 \n\
 @item For @var{l} > 1e8, use normal approximation.\n\
 L. Montanet, et al., @cite{Review of Particle Properties}, Physical Review\n\
 D 50 p1284, 1994.\n\
 @end table\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{rand, randn, rande, randg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -1100,17 +1100,17 @@ DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
 O(@var{m}) memory is used as well.  The randomization is performed using\n\
-rand(). All permutations are equally likely.\n\
+rand().  All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
 
 #ifdef USE_UNORDERED_MAP_WITH_TR1
 using std::tr1::unordered_map;
 #else
 using std::unordered_map;
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -503,17 +503,17 @@ octcellregexp (const octave_value_list &
     }
   else if (args(1).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
-        newretval[j].resize(cellpat.dims ());
+        newretval[j].resize (cellpat.dims ());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
         {
           new_args(1) = cellpat(i);
           octave_value_list tmp = octregexp (new_args, nargout, who,
                                              case_insensitive);
 
           if (error_state)
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -281,17 +281,17 @@ Riccati equations in control (see @code{
 %! assert (u' * a * u, s, sqrt (eps));
 
 %!test
 %! a = single ([1, 2, 3; 4, 5, 9; 7, 8, 6]);
 %! [u, s] = schur (a);
 %! assert (u' * a * u, s, sqrt (eps ("single")));
 
 %!test
-%! fail("schur ([1, 2; 3, 4], 2)", "warning");
+%! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
 DEFUN_DLD (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -397,10 +397,10 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("iNF*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
-%!assert (str2double (zeros(3,1,2)), NaN (3,1,2))
+%!assert (str2double (zeros (3,1,2)), NaN (3,1,2))
 */
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -218,32 +218,32 @@ factorization as determined by @var{typ}
           Aup = F ;
           Alo = A ;
         }
 
       CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
         {
-          error("postorder failed");
+          error ("postorder failed");
           goto symbfact_error;
         }
 
       CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
                                   ColCount, First, Level, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (nargout > 4)
         {
           cholmod_sparse *A1, *A2;
 
           if (A->stype == 1)
@@ -284,17 +284,17 @@ factorization as determined by @var{typ}
               lnz += ColCount [j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            W [j] = L.xcidx(j);
+            W[j] = L.xcidx (j);
 
           // get workspace for computing one row of L
           cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true,
                                                        0, CHOLMOD_PATTERN, cm);
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -177,17 +177,17 @@ H_insert (CMK_Node *H, octave_idx_type& 
 // reorganizes the heap optionally in O(log(n))
 
 inline static CMK_Node
 H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
 {
   CMK_Node r = H[0];
   H[0] = H[--h];
   if (reorg)
-    H_heapify_min(H, 0, h);
+    H_heapify_min (H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
 #define H_empty(H, h)   ((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
@@ -596,72 +596,72 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
                 {
                   octave_idx_type r2 = ridx2[j2++];
                   if (! visit[r2])
                     {
                       // the distance of node j is dist(i)+1
                       w.id = r2;
                       w.deg = D[r2];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r2] = true;
                     }
                 }
               else if (j2 == cidx2[i+1])
                 {
                   octave_idx_type r1 = ridx[j1++];
                   if (! visit[r1])
                     {
                       w.id = r1;
                       w.deg = D[r1];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r1] = true;
                     }
                 }
               else
                 {
                   octave_idx_type r1 = ridx[j1];
                   octave_idx_type r2 = ridx2[j2];
                   if (r1 <= r2)
                     {
                       if (! visit[r1])
                         {
                           w.id = r1;
                           w.deg = D[r1];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r1] = true;
                         }
                       j1++;
                       if (r1 == r2)
                         j2++;
                     }
                   else
                     {
                       if (! visit[r2])
                         {
                           w.id = r2;
                           w.deg = D[r2];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r2] = true;
                         }
                       j2++;
                     }
                 }
             }
 
           // add the neighbors to the queue (sorted by node degree)
           while (! H_empty (S, s))
             {
               OCTAVE_QUIT;
 
               // locate a neighbor of i with minimal degree in O(log(N))
-              v = H_remove_min(S, s, 1);
+              v = H_remove_min (S, s, 1);
 
               // entered the BFS a new level?
               if (v.dist > level)
                 {
                   // adjustment of bandwith:
                   // "[...] the minimum bandwidth that
                   // can be obtained [...] is the
                   //  maximum number of nodes per level"
@@ -695,16 +695,16 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     {
-      double tmp = P.elem(i);
-      P.elem(i) = P.elem(j);
-      P.elem(j) = tmp;
+      double tmp = P.elem (i);
+      P.elem (i) = P.elem (j);
+      P.elem (j) = tmp;
     }
 
   // increment all indices, since Octave is not C
   return octave_value (P+1);
 }
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -132,18 +132,18 @@ do_tril (const Sparse<T>& a, octave_idx_
       error ("tril: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) < j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 template <class T>
 static Sparse<T>
@@ -154,18 +154,18 @@ do_triu (const Sparse<T>& a, octave_idx_
       error ("triu: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) > j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) > j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 // Convenience dispatchers.
 template <class T>
@@ -285,32 +285,32 @@ do_trilu (const std::string& name,
 
                 octave_value_list ov_idx;
                 std::list<octave_value_list> idx_tmp;
                 ov_idx(1) = static_cast<double> (nc+1);
                 ov_idx(0) = Range (1, nr);
                 idx_tmp.push_back (ov_idx);
                 ov_idx(1) = static_cast<double> (nc);
                 tmp = tmp.resize (dim_vector (0,0));
-                tmp = tmp.subsasgn("(",idx_tmp, arg.do_index_op (ov_idx));
-                tmp = tmp.resize(dims);
+                tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+                tmp = tmp.resize (dims);
 
                 if (lower)
                   {
                     octave_idx_type st = nc < nr + k ? nc : nr + k;
 
                     for (octave_idx_type j = 1; j <= st; j++)
                       {
                         octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (nr_limit, nr);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
                 else
                   {
                     octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
@@ -318,17 +318,17 @@ do_trilu (const std::string& name,
                     for (octave_idx_type j = st; j <= nc; j++)
                       {
                         octave_idx_type nr_limit = nr < j - k ? nr : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (1, nr_limit);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
 
                 retval = tmp;
               }
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -415,27 +415,27 @@ public:
       setopt (CURLOPT_URL, url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
         {
-          pos = str.find_first_of('\n', pos);
+          pos = str.find_first_of ('\n', pos);
           if (pos == std::string::npos)
             break;
           pos++;
           n++;
         }
       string_vector retval (n);
       pos = 0;
       for (octave_idx_type i = 0; i < n; i++)
         {
-          size_t newpos = str.find_first_of('\n', pos);
+          size_t newpos = str.find_first_of ('\n', pos);
           if (newpos == std::string::npos)
             break;
 
           retval(i) = str.substr(pos, newpos - pos);
           pos = newpos + 1;
         }
       return retval;
     }
@@ -462,21 +462,21 @@ public:
               fileisdir = true;
               filetime = -1;
               filesize = 0;
             }
           else
             {
               fileisdir = false;
               time_t ft;
-              curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
+              curl_easy_getinfo (rep->handle (), CURLINFO_FILETIME, &ft);
               filetime = ft;
               double fs;
-              curl_easy_getinfo(rep->handle (),
-                                CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+              curl_easy_getinfo (rep->handle (),
+                                 CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0);
       url = "ftp://" + rep->host;
@@ -503,17 +503,17 @@ public:
       if (! error_state)
         {
           perform ();
           retval = buf.str ();
 
           // Can I assume that the path is alway in "" on the last line
           size_t pos2 = retval.rfind ('"');
           size_t pos1 = retval.rfind ('"', pos2 - 1);
-          retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
+          retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
         }
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_WRITEHEADER, 0);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
 
       return retval;
     }
@@ -603,17 +603,17 @@ curl_handles
 {
 public:
 
   typedef std::map<std::string, curl_handle>::iterator iterator;
   typedef std::map<std::string, curl_handle>::const_iterator const_iterator;
 
   curl_handles (void) : map ()
    {
-     curl_global_init(CURL_GLOBAL_DEFAULT);
+     curl_global_init (CURL_GLOBAL_DEFAULT);
    }
 
   ~curl_handles (void)
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
       map.erase (begin (), end ());
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -5643,17 +5643,17 @@ At least one argument is required.\n\
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} tic ()\n\
-@deftypefnx  {Built-in Function} {@var{id} =} tic ()\n\
+@deftypefnx {Built-in Function} {@var{id} =} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
 @deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
 output argument sets the internal timer state.  Subsequent calls\n\
 to @code{toc} return the number of seconds since the timer was set.\n\
 For example,\n\
 \n\
@@ -5710,19 +5710,19 @@ doing nothing at all.\n\
   else
     tic_toc_timestamp = tmp;
 
   return retval;
 }
 
 DEFUN (toc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} toc ()\n\
+@deftypefn  {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
-@deftypefnx {Built-in Function} {@var{val} = } toc (@dots{})\n\
+@deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 See tic.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   double start_time = tic_toc_timestamp;
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1534,19 +1534,19 @@ Query or set the character used to separ
 the subfunction names contained within the file.  This can be used in\n\
 a generic manner to interact with subfunctions.  For example,\n\
 \n\
 @example\n\
 help ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
-returns the help string associated with the sub-function @code{mysubfunc}\n\
+returns the help string associated with the subfunction @code{mysubfunc}\n\
 of the function @code{myfunc}.  Another use of @code{filemarker} is when\n\
-debugging it allows easier placement of breakpoints within sub-functions.\n\
+debugging it allows easier placement of breakpoints within subfunctions.\n\
 For example,\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 will set a breakpoint at the first line of the subfunction @code{mysubfunc}.\n\
