# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463698523 14400
#      Thu May 19 18:55:23 2016 -0400
# Node ID 176536b15d6897f423a8b357f998c20c9cbda1ab
# Parent  61f3575250e45eacf26fb109fd629de8234d1842
use namespace for command_editor and command_history classes

* cmd-edit.h, cmd-edit.cc: Put command_editor class in octave
namespace.  Change all uses.
* cmd-hist.h, cmd-hist.cc: Put command_history class in octave
namespace.  Change all uses.

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -2095,37 +2095,37 @@ main_window::rename_variable_callback (c
 
   //  else
   //    ; // we need an octave_link action that runs a GUI error option.
 }
 
 void
 main_window::command_window_undo_callback (void)
 {
-  command_editor::undo ();
-  command_editor::redisplay ();
+  octave::command_editor::undo ();
+  octave::command_editor::redisplay ();
 }
 
 void
 main_window::clear_command_window_callback (void)
 {
-  command_editor::kill_full_line ();
-  command_editor::clear_screen ();
+  octave::command_editor::kill_full_line ();
+  octave::command_editor::clear_screen ();
 }
 
 void
 main_window::resize_command_window_callback (void)
 {
-  command_editor::resize_terminal ();
+  octave::command_editor::resize_terminal ();
 }
 
 void
 main_window::set_screen_size_callback (const int_pair& sz)
 {
-  command_editor::set_screen_size (sz.first, sz.second);
+  octave::command_editor::set_screen_size (sz.first, sz.second);
 }
 
 void
 main_window::clear_history_callback (void)
 {
   Fhistory (ovl ("-c"));
 }
 
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -35,55 +35,55 @@ along with Octave; see the file COPYING.
 
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_exec: executing a command
 
 void
 octave_cmd_exec::execute ()
 {
-  std::string pending_input = command_editor::get_current_line ();
+  std::string pending_input = octave::command_editor::get_current_line ();
 
-  command_editor::set_initial_input (pending_input);
-  command_editor::replace_line (_cmd.toStdString ());
-  command_editor::redisplay ();
-  command_editor::accept_line ();
+  octave::command_editor::set_initial_input (pending_input);
+  octave::command_editor::replace_line (_cmd.toStdString ());
+  octave::command_editor::redisplay ();
+  octave::command_editor::accept_line ();
 }
 
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_eval: running a file
 
 void
 octave_cmd_eval::execute ()
 {
   QString function_name = _info.fileName ();
   function_name.chop (_info.suffix ().length () + 1);
   std::string file_path = _info.absoluteFilePath ().toStdString ();
 
-  std::string pending_input = command_editor::get_current_line ();
+  std::string pending_input = octave::command_editor::get_current_line ();
 
   if (valid_identifier (function_name.toStdString ()))
     {
       // valid identifier: call as function with possibility to debug
       std::string path = _info.absolutePath ().toStdString ();
       if (octave_qt_link::file_in_path (file_path, path))
-        command_editor::replace_line (function_name.toStdString ());
+        octave::command_editor::replace_line (function_name.toStdString ());
     }
   else
     {
       // no valid identifier: use Fsource (), no debug possible
       Fsource (ovl (file_path));
-      command_editor::replace_line ("");
+      octave::command_editor::replace_line ("");
     }
 
-  command_editor::set_initial_input (pending_input);
-  command_editor::redisplay ();
+  octave::command_editor::set_initial_input (pending_input);
+  octave::command_editor::redisplay ();
 
-  command_editor::accept_line ();
+  octave::command_editor::accept_line ();
 }
 
 
 // ---------------------------------------------------------------------
 //  class octave_cmd_debug: executing a debugger command
 
 void
 octave_cmd_debug::execute ()
@@ -101,17 +101,17 @@ octave_cmd_debug::execute ()
   else if (_cmd == "quit")
     Fdbquit ();
   else
     {
       F__db_next_breakpoint_quiet__ (ovl (_suppress_dbg_location));
       Fdbstep (ovl (_cmd.toStdString ()));
     }
 
-  command_editor::interrupt (true);
+  octave::command_editor::interrupt (true);
 }
 
 
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
 // add_cmd: add a command to the queue
 void
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9357,17 +9357,17 @@ gh_manager::do_execute_callback (const g
     }
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
 {
   event_queue.push_back (e);
 
-  command_editor::add_event_hook (gh_manager::process_events);
+  octave::command_editor::add_event_hook (gh_manager::process_events);
 }
 
 void
 gh_manager::do_post_callback (const graphics_handle& h, const std::string& name,
                               const octave_value& data)
 {
   gh_manager::auto_lock guard;
 
@@ -9468,17 +9468,17 @@ gh_manager::do_process_events (bool forc
         }
     }
   while (e.ok ());
 
   {
     gh_manager::auto_lock guard;
 
     if (event_queue.empty () && event_processing == 0)
-      command_editor::remove_event_hook (gh_manager::process_events);
+      octave::command_editor::remove_event_hook (gh_manager::process_events);
   }
 
   if (events_executed)
     flush_octave_stdout ();
 
   if (Vdrawnow_requested && ! old_Vdrawnow_requested)
     {
       Fdrawnow ();
@@ -9493,24 +9493,24 @@ void
 gh_manager::do_enable_event_processing (bool enable)
 {
   gh_manager::auto_lock guard;
 
   if (enable)
     {
       event_processing++;
 
-      command_editor::add_event_hook (gh_manager::process_events);
+      octave::command_editor::add_event_hook (gh_manager::process_events);
     }
   else
     {
       event_processing--;
 
       if (event_queue.empty () && event_processing == 0)
-        command_editor::remove_event_hook (gh_manager::process_events);
+        octave::command_editor::remove_event_hook (gh_manager::process_events);
     }
 }
 
 property_list::plist_map_type
 root_figure::init_factory_properties (void)
 {
   property_list::plist_map_type plist_map;
 
@@ -11432,17 +11432,17 @@ In all cases, typing CTRL-C stops progra
           else
             break;
         }
 
       octave_sleep (0.1); // FIXME: really needed?
 
       OCTAVE_QUIT;
 
-      command_editor::run_event_hooks ();
+      octave::command_editor::run_event_hooks ();
 
       if (timeout > 0)
         {
           if (start + timeout < time (0))
             break;
         }
     }
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -155,22 +155,22 @@ octave_base_reader::do_input_echo (const
     ? (Vecho_executing_commands & ECHO_SCRIPTS)
     : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
         {
           if (pflag > 0)
-            octave_stdout << command_editor::decode_prompt_string (VPS1);
+            octave_stdout << octave::command_editor::decode_prompt_string (VPS1);
           else
-            octave_stdout << command_editor::decode_prompt_string (VPS2);
+            octave_stdout << octave::command_editor::decode_prompt_string (VPS2);
         }
       else
-        octave_stdout << command_editor::decode_prompt_string (VPS4);
+        octave_stdout << octave::command_editor::decode_prompt_string (VPS4);
 
       if (! input_string.empty ())
         {
           octave_stdout << input_string;
 
           if (input_string[input_string.length () - 1] != '\n')
             octave_stdout << "\n";
         }
@@ -179,17 +179,17 @@ octave_base_reader::do_input_echo (const
 
 static std::string
 gnu_readline (const std::string& s, bool& eof)
 {
   octave_quit ();
 
   eof = false;
 
-  std::string retval = command_editor::readline (s, eof);
+  std::string retval = octave::command_editor::readline (s, eof);
 
   if (! eof && retval.empty ())
     retval = "\n";
 
   return retval;
 }
 
 static inline std::string
@@ -253,17 +253,17 @@ octave_base_reader::octave_gets (bool& e
 
       octave_link::set_workspace ();
     }
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   std::string ps = (pflag > 0) ? VPS1 : VPS2;
 
-  std::string prompt = command_editor::decode_prompt_string (ps);
+  std::string prompt = octave::command_editor::decode_prompt_string (ps);
 
   pipe_handler_error_count = 0;
 
   flush_octave_stdout ();
 
   octave_pager_stream::reset ();
   octave_diary_stream::reset ();
 
@@ -288,17 +288,17 @@ octave_base_reader::octave_gets (bool& e
       retval = last_debugging_command;
       history_skip_auto_repeated_debugging_command = true;
     }
 
   if (retval != "\n")
     {
       if (! history_skip_auto_repeated_debugging_command)
         {
-          if (command_history::add (retval))
+          if (octave::command_history::add (retval))
             octave_link::append_history (retval);
         }
 
       octave_diary << retval;
 
       if (retval[retval.length () - 1] != '\n')
         octave_diary << "\n";
 
@@ -336,18 +336,18 @@ octave_base_reader::reading_script_file 
 
 // Fix things up so that input can come from the standard input.  This
 // may need to become much more complicated, which is why it's in a
 // separate function.
 
 FILE *
 get_input_from_stdin (void)
 {
-  command_editor::set_input_stream (stdin);
-  return command_editor::get_input_stream ();
+  octave::command_editor::set_input_stream (stdin);
+  return octave::command_editor::get_input_stream ();
 }
 
 // FIXME: make this generate filenames when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
                                std::string& hint)
 {
@@ -370,17 +370,17 @@ generate_possible_completions (const std
 static bool
 is_completing_dirfns (void)
 {
   static std::string dirfns_commands[] = {"cd", "ls"};
   static const size_t dirfns_commands_length = 2;
 
   bool retval = false;
 
-  std::string line = command_editor::get_line_buffer ();
+  std::string line = octave::command_editor::get_line_buffer ();
 
   for (size_t i = 0; i < dirfns_commands_length; i++)
     {
       int index = line.find (dirfns_commands[i] + " ");
 
       if (index == 0)
         {
           retval = true;
@@ -422,17 +422,17 @@ generate_completion (const std::string& 
 
       if (is_completing_dirfns ())
         name_list = string_vector ();
       else
         name_list = generate_possible_completions (text, prefix, hint);
 
       name_list_len = name_list.numel ();
 
-      file_name_list = command_editor::generate_filename_completions (text);
+      file_name_list = octave::command_editor::generate_filename_completions (text);
 
       name_list.append (file_name_list);
 
       name_list_total_len = name_list.numel ();
 
       hint_len = hint.length ();
 
       matches = 0;
@@ -460,20 +460,20 @@ generate_completion (const std::string& 
               // FIXME: looks_like_struct is broken for now,
               //        so it always returns false.
 
               if (matches == 1 && looks_like_struct (retval))
                 {
                   // Don't append anything, since we don't know
                   // whether it should be '(' or '.'.
 
-                  command_editor::set_completion_append_character ('\0');
+                  octave::command_editor::set_completion_append_character ('\0');
                 }
               else
-                command_editor::set_completion_append_character
+                octave::command_editor::set_completion_append_character
                   (Vcompletion_append_char);
 
               break;
             }
         }
     }
 
   return retval;
@@ -489,35 +489,35 @@ quoting_filename (const std::string &tex
 }
 
 void
 initialize_command_input (void)
 {
   // If we are using readline, this allows conditional parsing of the
   // .inputrc file.
 
-  command_editor::set_name ("Octave");
+  octave::command_editor::set_name ("Octave");
 
   // FIXME: this needs to include a comma too, but that
   // causes trouble for the new struct element completion code.
 
   static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
 
-  command_editor::set_basic_word_break_characters (s);
+  octave::command_editor::set_basic_word_break_characters (s);
 
-  command_editor::set_completer_word_break_characters (s);
+  octave::command_editor::set_completer_word_break_characters (s);
 
-  command_editor::set_basic_quote_characters ("\"");
+  octave::command_editor::set_basic_quote_characters ("\"");
 
-  command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
-  command_editor::set_completer_quote_characters ("'\"");
+  octave::command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
+  octave::command_editor::set_completer_quote_characters ("'\"");
 
-  command_editor::set_completion_function (generate_completion);
+  octave::command_editor::set_completion_function (generate_completion);
 
-  command_editor::set_quoting_function (quoting_filename);
+  octave::command_editor::set_quoting_function (quoting_filename);
 }
 
 static void
 execute_in_debugger_handler (const std::pair<std::string, int>& arg)
 {
   octave_link::execute_in_debugger_event (arg.first, arg.second);
 }
 
@@ -590,17 +590,17 @@ get_debug_input (const std::string& prom
                   if (! line_buf.empty ())
                     buf << "\n" << curr_debug_line << ": " << line_buf;
                 }
             }
         }
     }
 
   if (silent)
-    command_editor::erase_empty_line (true);
+    octave::command_editor::erase_empty_line (true);
 
   std::string msg = buf.str ();
 
   if (! msg.empty ())
     std::cerr << msg << std::endl;
 
   frame.protect_var (VPS1);
   VPS1 = prompt;
@@ -620,17 +620,17 @@ get_debug_input (const std::string& prom
       try
         {
           reset_error_handler ();
 
           curr_parser.reset ();
 
           int retval = curr_parser.run ();
 
-          if (command_editor::interrupt (false))
+          if (octave::command_editor::interrupt (false))
             break;
           else
             {
               if (retval == 0 && curr_parser.stmt_list)
                 {
                   curr_parser.stmt_list->accept (*current_evaluator);
 
                   if (octave_completion_matches_called)
@@ -861,20 +861,20 @@ do_keyboard (const octave_value_list& ar
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
   octave::unwind_protect frame;
 
-  frame.add_fcn (command_history::ignore_entries,
-                 command_history::ignoring_entries ());
+  frame.add_fcn (octave::command_history::ignore_entries,
+                 octave::command_history::ignoring_entries ());
 
-  command_history::ignore_entries (false);
+  octave::command_history::ignore_entries (false);
 
   frame.protect_var (Vdebugging);
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
   // FIXME: probably we just want to print one line, not the
   // entire statement, which might span many lines...
@@ -1168,22 +1168,22 @@ for details.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 0)
-    command_editor::read_init_file ();
+    octave::command_editor::read_init_file ();
   else
     {
       std::string file = args(0).string_value ();
 
-      command_editor::read_init_file (file);
+      octave::command_editor::read_init_file (file);
     }
 
   return ovl ();
 }
 
 DEFUN (readline_re_read_init_file, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} readline_re_read_init_file ()\n\
@@ -1192,28 +1192,28 @@ Re-read the last readline library initia
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_read_init_file}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  command_editor::re_read_init_file ();
+  octave::command_editor::re_read_init_file ();
 
   return ovl ();
 }
 
 static int
 internal_input_event_hook_fcn (void)
 {
   input_event_hook_functions.run ();
 
   if (input_event_hook_functions.empty ())
-    command_editor::remove_event_hook (internal_input_event_hook_fcn);
+    octave::command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return 0;
 }
 
 DEFUN (add_input_event_hook, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{id} =} add_input_event_hook (@var{fcn})\n\
 @deftypefnx {} {@var{id} =} add_input_event_hook (@var{fcn}, @var{data})\n\
@@ -1241,17 +1241,17 @@ list of input hook functions.\n\
   octave_value user_data;
 
   if (nargin == 2)
     user_data = args(1);
 
   hook_function hook_fcn (args(0), user_data);
 
   if (input_event_hook_functions.empty ())
-    command_editor::add_event_hook (internal_input_event_hook_fcn);
+    octave::command_editor::add_event_hook (internal_input_event_hook_fcn);
 
   input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
 
   return ovl (hook_fcn.id ());
 }
 
 DEFUN (remove_input_event_hook, args, ,
        "-*- texinfo -*-\n\
@@ -1277,17 +1277,17 @@ for input.\n\
 
   if (p != input_event_hook_functions.end ())
     input_event_hook_functions.erase (p);
   else if (warn)
     warning ("remove_input_event_hook: %s not found in list",
              hook_fcn_id.c_str ());
 
   if (input_event_hook_functions.empty ())
-    command_editor::remove_event_hook (internal_input_event_hook_fcn);
+    octave::command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return ovl ();
 }
 
 DEFUN (PS1, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} PS1 ()\n\
 @deftypefnx {} {@var{old_val} =} PS1 (@var{new_val})\n\
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -133,17 +133,18 @@ static string_vector
 do_history (const octave_value_list& args, int nargout)
 {
   bool numbered_output = nargout == 0;
 
   octave::unwind_protect frame;
 
   string_vector hlist;
 
-  frame.add_fcn (command_history::set_file, command_history::file ());
+  frame.add_fcn (octave::command_history::set_file,
+                 octave::command_history::file ());
 
   int nargin = args.length ();
 
   // Number of history lines to show (-1 = all)
   int limit = -1;
 
   for (octave_idx_type i = 0; i < nargin; i++)
     {
@@ -167,51 +168,51 @@ do_history (const octave_value_list& arg
           || option == "-n")
         {
           if (i < nargin - 1)
             {
               std::string fname
                 = args(++i).xstring_value ("history: filename must be a string for %s option",
                                            option.c_str ());
 
-              command_history::set_file (fname);
+              octave::command_history::set_file (fname);
             }
           else
-            command_history::set_file (default_history_file ());
+            octave::command_history::set_file (default_history_file ());
 
           if (option == "-a")
             // Append 'new' lines to file.
-            command_history::append ();
+            octave::command_history::append ();
 
           else if (option == "-w")
             // Write entire history.
-            command_history::write ();
+            octave::command_history::write ();
 
           else if (option == "-r")
             {
               // Read entire file.
-              command_history::read ();
-              octave_link::set_history (command_history::list ());
+              octave::command_history::read ();
+              octave_link::set_history (octave::command_history::list ());
             }
 
           else if (option == "-n")
             {
               // Read 'new' history from file.
-              command_history::read_range ();
-              octave_link::set_history (command_history::list ());
+              octave::command_history::read_range ();
+              octave_link::set_history (octave::command_history::list ());
             }
 
           else
             panic_impossible ();
 
           return hlist;
         }
       else if (option == "-c")
         {
-          command_history::clear ();
+          octave::command_history::clear ();
           octave_link::clear_history ();
         }
       else if (option == "-q")
         numbered_output = false;
       else if (option == "--")
         {
           i++;
           break;
@@ -235,17 +236,17 @@ do_history (const octave_value_list& arg
               if (option.length () > 0 && option[0] == '-')
                 error ("history: unrecognized option '%s'", option.c_str ());
               else
                 error ("history: bad non-numeric arg '%s'", option.c_str ());
             }
         }
     }
 
-  hlist = command_history::list (limit, numbered_output);
+  hlist = octave::command_history::list (limit, numbered_output);
 
   int len = hlist.numel ();
 
   if (nargout == 0)
     {
       for (octave_idx_type i = 0; i < len; i++)
         octave_stdout << hlist[i] << "\n";
     }
@@ -315,17 +316,17 @@ edit_history_add_hist (const std::string
       std::string tmp = line;
 
       int len = tmp.length ();
 
       if (len > 0 && tmp[len-1] == '\n')
         tmp.resize (len - 1);
 
       if (! tmp.empty ())
-        if (command_history::add (tmp))
+        if (octave::command_history::add (tmp))
           octave_link::append_history (tmp);
     }
 }
 
 static bool
 get_int_arg (const octave_value& arg, int& val)
 {
   bool ok = true;
@@ -343,27 +344,27 @@ get_int_arg (const octave_value& arg, in
 
   return ok;
 }
 
 static std::string
 mk_tmp_hist_file (const octave_value_list& args,
                   bool insert_curr, const char *warn_for)
 {
-  string_vector hlist = command_history::list ();
+  string_vector hlist = octave::command_history::list ();
 
   int hist_count = hlist.numel () - 1;  // switch to zero-based indexing
 
   // The current command line is already part of the history list by
   // the time we get to this point.  Delete the cmd from the list when
   // executing 'edit_history' so that it doesn't show up in the history
   // but the actual commands performed will.
 
   if (! insert_curr)
-    command_history::remove (hist_count);
+    octave::command_history::remove (hist_count);
 
   hist_count--;  // skip last entry in history list
 
   // If no numbers have been specified, the default is to edit the
   // last command in the history list.
 
   int hist_beg = hist_count;
   int hist_end = hist_count;
@@ -528,33 +529,33 @@ do_run_history (const octave_value_list&
   input_from_tmp_history_file = true;
 
   source_file (name);
 }
 
 void
 initialize_history (bool read_history_file)
 {
-  command_history::initialize (read_history_file,
-                               default_history_file (),
-                               default_history_size (),
-                               octave::sys::env::getenv ("OCTAVE_HISTCONTROL"));
+  octave::command_history::initialize (read_history_file,
+                                       default_history_file (),
+                                       default_history_size (),
+                                       octave::sys::env::getenv ("OCTAVE_HISTCONTROL"));
 
-  octave_link::set_history (command_history::list ());
+  octave_link::set_history (octave::command_history::list ());
 }
 
 void
 octave_history_write_timestamp (void)
 {
   octave::sys::localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
-    if (command_history::add (timestamp))
+    if (octave::command_history::add (timestamp))
       octave_link::append_history (timestamp);
 }
 
 DEFUN (edit_history, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} edit_history\n\
 @deftypefnx {} {} edit_history @var{cmd_number}\n\
 @deftypefnx {} {} edit_history @var{first} @var{last}\n\
@@ -726,24 +727,24 @@ matching the current line to be removed 
 line is saved.  Any value not in the above list is ignored.  If\n\
 @code{history_control} is the empty string, all commands are saved on\n\
 the history list, subject to the value of @code{history_save}.\n\
 @seealso{history_file, history_size, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  std::string old_history_control = command_history::histcontrol ();
+  std::string old_history_control = octave::command_history::histcontrol ();
 
   std::string tmp = old_history_control;
 
   retval = set_internal_variable (tmp, args, nargout, "history_control");
 
   if (tmp != old_history_control)
-    command_history::process_histcontrol (tmp);
+    octave::command_history::process_histcontrol (tmp);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} history_size ()\n\
 @deftypefnx {} {@var{old_val} =} history_size (@var{new_val})\n\
@@ -752,26 +753,26 @@ to store in the history file.\n\
 \n\
 The default value is @code{1000}, but may be overridden by the environment\n\
 variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int old_history_size = command_history::size ();
+  int old_history_size = octave::command_history::size ();
 
   int tmp = old_history_size;
 
   retval = set_internal_variable (tmp, args, nargout,
                                   "history_size", -1,
                                   std::numeric_limits<int>::max ());
 
   if (tmp != old_history_size)
-    command_history::set_size (tmp);
+    octave::command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} history_file ()\n\
 @deftypefnx {} {@var{old_val} =} history_file (@var{new_val})\n\
@@ -780,24 +781,24 @@ file used to store command history.\n\
 \n\
 The default value is @file{~/.octave_hist}, but may be overridden by the\n\
 environment variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, history_save, history_timestamp_format_string}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  std::string old_history_file = command_history::file ();
+  std::string old_history_file = octave::command_history::file ();
 
   std::string tmp = old_history_file;
 
   retval = set_internal_variable (tmp, args, nargout, "history_file");
 
   if (tmp != old_history_file)
-    command_history::set_file (tmp);
+    octave::command_history::set_file (tmp);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} history_timestamp_format_string ()\n\
 @deftypefnx {} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
@@ -832,19 +833,19 @@ on the command line are saved in the his
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{history_control, history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  bool old_history_save = ! command_history::ignoring_entries ();
+  bool old_history_save = ! octave::command_history::ignoring_entries ();
 
   bool tmp = old_history_save;
 
   retval = set_internal_variable (tmp, args, nargout, "history_save");
 
   if (tmp != old_history_save)
-    command_history::ignore_entries (! tmp);
+    octave::command_history::ignore_entries (! tmp);
 
   return retval;
 }
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -47,17 +47,17 @@ octave_readline_hook (void)
 }
 
 octave_link *octave_link::instance = 0;
 
 octave_link::octave_link (void)
   : event_queue_mutex (new octave_mutex ()), gui_event_queue (),
     debugging (false), link_enabled (true)
 {
-  command_editor::add_event_hook (octave_readline_hook);
+  octave::command_editor::add_event_hook (octave_readline_hook);
 }
 
 octave_link::~octave_link (void)
 {
   delete event_queue_mutex;
 }
 
 void
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -197,19 +197,19 @@ do_sync (const char *msg, int len, bool 
 
 // Assume our terminal wraps long lines.
 
 static bool
 more_than_a_screenful (const char *s, int len)
 {
   if (s)
     {
-      int available_rows = command_editor::terminal_rows () - 2;
+      int available_rows = octave::command_editor::terminal_rows () - 2;
 
-      int cols = command_editor::terminal_cols ();
+      int cols = octave::command_editor::terminal_cols ();
 
       int count = 0;
 
       int chars_this_line = 0;
 
       for (int i = 0; i < len; i++)
         {
           if (*s++ == '\n')
@@ -627,18 +627,18 @@ DEFUN (terminal_size, , ,
 @deftypefn {} {} terminal_size ()\n\
 Return a two-element row vector containing the current size of the terminal\n\
 window in characters (rows and columns).\n\
 @seealso{list_in_columns}\n\
 @end deftypefn")
 {
   RowVector size (2, 0.0);
 
-  size(0) = command_editor::terminal_rows ();
-  size(1) = command_editor::terminal_cols ();
+  size(0) = octave::command_editor::terminal_rows ();
+  size(1) = octave::command_editor::terminal_cols ();
 
   return ovl (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} page_output_immediately ()\n\
 @deftypefnx {} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -1765,17 +1765,17 @@ octave_print_internal (std::ostream& os,
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (m, fw, scale);
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
-      octave_idx_type max_width = command_editor::terminal_cols ();
+      octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
 
       if (max_width < 0)
         max_width = 0;
@@ -1901,17 +1901,17 @@ octave_print_internal (std::ostream& os,
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (Matrix (m.diag ()), fw, scale);
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
-      octave_idx_type max_width = command_editor::terminal_cols ();
+      octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
 
       if (max_width < 0)
         max_width = 0;
@@ -2183,17 +2183,17 @@ octave_print_internal (std::ostream& os,
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (cm, r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
       column_width += (rat_format || bank_format || hex_format
                        || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
-      octave_idx_type max_width = command_editor::terminal_cols ();
+      octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
 
       if (max_width < 0)
         max_width = 0;
@@ -2321,17 +2321,17 @@ octave_print_internal (std::ostream& os,
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (ComplexMatrix (cm.diag ()), r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
       column_width += (rat_format || bank_format || hex_format
                        || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
-      octave_idx_type max_width = command_editor::terminal_cols ();
+      octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
 
       if (max_width < 0)
         max_width = 0;
@@ -2466,17 +2466,17 @@ octave_print_internal (std::ostream& os,
             os << "\n";
         }
     }
   else
     {
       int fw = 2;
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
-      octave_idx_type max_width = command_editor::terminal_cols ();
+      octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
 
       if (max_width < 0)
         max_width = 0;
@@ -2709,17 +2709,17 @@ octave_print_internal (std::ostream& os,
             }
         }
       else
         {
           octave_preserve_stream_state stream_state (os);
 
           int column_width = fw + 2;
           octave_idx_type total_width = num_elem * column_width;
-          octave_idx_type max_width = command_editor::terminal_cols ();
+          octave_idx_type max_width = octave::command_editor::terminal_cols ();
 
           if (free_format)
             {
               os << r;
               return;
             }
 
           octave_idx_type inc = num_elem;
@@ -3271,17 +3271,17 @@ octave_print_internal_template (std::ost
                 isneg = (abs (nda(i).value ()) != nda(i).value ());
             }
 
           fw = digits + isneg;
         }
 
       int column_width = fw + (rat_format ?  0 : (bank_format ? 5 : 2));
       octave_idx_type total_width = nc * column_width;
-      int max_width = command_editor::terminal_cols () - extra_indent;
+      int max_width = octave::command_editor::terminal_cols () - extra_indent;
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
           if (inc == 0)
             inc++;
         }
 
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -452,17 +452,17 @@ sig_hup_or_term_handler (int sig)
 }
 #endif
 
 #if 0
 #  if defined (SIGWINCH)
 static void
 sigwinch_handler (int /* sig */)
 {
-  command_editor::resize_terminal ();
+  octave::command_editor::resize_terminal ();
 }
 #endif
 #endif
 
 // Handle SIGINT by restarting the parser (see octave.cc).
 //
 // This also has to work for SIGBREAK (on systems that have it), so we
 // use the value of sig, instead of just assuming that it is called
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -177,18 +177,18 @@ error message.\n\
     {
       exec_args.resize (1);
 
       exec_args[0] = exec_file;
     }
 
   octave_history_write_timestamp ();
 
-  if (! command_history::ignoring_entries ())
-    command_history::clean_up_and_save ();
+  if (! octave::command_history::ignoring_entries ())
+    octave::command_history::clean_up_and_save ();
 
   std::string msg;
 
   int status = octave::sys::execvp (exec_file, exec_args, msg);
 
   return ovl (status, msg);
 }
 
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -176,17 +176,17 @@ MINGW_signal_cleanup (void)
   w32_set_quiet_shutdown ();
 }
 
 static void
 w32_init (void)
 {
   w32_set_octave_home ();
 
-  command_editor::prefer_env_winsize (true);
+  octave::command_editor::prefer_env_winsize (true);
 }
 
 static bool
 w32_shell_execute (const std::string& file)
 {
 }
 #endif
 
@@ -602,17 +602,17 @@ DEFUN (clc, , ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} clc ()\n\
 @deftypefnx {} {} home ()\n\
 Clear the terminal screen and move the cursor to the upper left corner.\n\
 @end deftypefn")
 {
   bool skip_redisplay = true;
 
-  command_editor::clear_screen (skip_redisplay);
+  octave::command_editor::clear_screen (skip_redisplay);
 
   return ovl ();
 }
 
 DEFALIAS (home, clc);
 
 DEFUN (getenv, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -723,17 +723,17 @@ main_loop (void)
 
                       if (quit)
                         break;
                     }
 
                   if (octave_completion_matches_called)
                     octave_completion_matches_called = false;
                   else
-                    command_editor::increment_current_command_number ();
+                    octave::command_editor::increment_current_command_number ();
                 }
               else if (parser.lexer.end_of_input)
                 break;
             }
         }
       catch (const octave_interrupt_exception&)
         {
           recover_from_exception ();
@@ -829,25 +829,25 @@ do_octave_atexit (void)
 
       octave_link::process_events (true);
 
       // Do this explicitly so that destructors for mex file objects
       // are called, so that functions registered with mexAtExit are
       // called.
       OCTAVE_SAFE_CALL (clear_mex_functions, ());
 
-      OCTAVE_SAFE_CALL (command_editor::restore_terminal_state, ());
+      OCTAVE_SAFE_CALL (octave::command_editor::restore_terminal_state, ());
 
       // FIXME: is this needed?  Can it cause any trouble?
       OCTAVE_SAFE_CALL (raw_mode, (0));
 
       OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
 
-      if (! command_history::ignoring_entries ())
-        OCTAVE_SAFE_CALL (command_history::clean_up_and_save, ());
+      if (! octave::command_history::ignoring_entries ())
+        OCTAVE_SAFE_CALL (octave::command_history::clean_up_and_save, ());
 
       OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
 
       OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
 
       OCTAVE_SAFE_CALL (close_files, ());
 
       OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1697,17 +1697,17 @@ initialize_java (void)
   if (! jvm)
     {
       try
         {
           initialize_jvm ();
 
           JNIEnv *current_env = thread_jni_env ();
 
-          command_editor::add_event_hook (java_event_hook);
+          octave::command_editor::add_event_hook (java_event_hook);
 
           octave_thread_ID = get_current_thread_ID (current_env);
           //printf ("octave thread ID=%ld\n", octave_thread_ID);
         }
       catch (std::string msg)
         {
           error (msg.c_str ());
         }
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -870,17 +870,17 @@ octave_initialize_interpreter (int argc,
     line_editing = false;
 
   // Also skip start-up message unless session is interactive.
   if (! interactive)
     inhibit_startup_message = true;
 
   // Force default line editor if we don't want readline editing.
   if (! line_editing)
-    command_editor::force_default_editor ();
+    octave::command_editor::force_default_editor ();
 
   // These can come after command line args since none of them set any
   // defaults that might be changed by command line options.
 
   if (line_editing)
     initialize_command_input ();
 
   octave_interpreter_ready = true;
@@ -965,27 +965,27 @@ octave_execute_interpreter (void)
           quitting_gracefully = true;
 
           clean_up_and_exit (exit_status);
         }
     }
 
   // Avoid counting commands executed from startup files.
 
-  command_editor::reset_current_command_number (1);
+  octave::command_editor::reset_current_command_number (1);
 
   // Now argv should have the full set of args.
   intern_argv (octave_cmdline_argc, octave_cmdline_argv);
 
   // Force input to be echoed if not really interactive,
   // but the user has forced interactive behavior.
 
   if (forced_interactive)
     {
-      command_editor::blink_matching_paren (false);
+      octave::command_editor::blink_matching_paren (false);
 
       // FIXME: is this the right thing to do?
       Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
     }
 
   if (octave_embedded)
     {
       // FIXME: Do we need to do any cleanup here before returning?
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4141,24 +4141,24 @@ parse_fcn_file (const std::string& full_
                 bool relative_lookup, const std::string& warn_for)
 {
   octave::unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
-  FILE *in_stream = command_editor::get_input_stream ();
-
-  frame.add_fcn (command_editor::set_input_stream, in_stream);
-
-  frame.add_fcn (command_history::ignore_entries,
-                 command_history::ignoring_entries ());
-
-  command_history::ignore_entries ();
+  FILE *in_stream = octave::command_editor::get_input_stream ();
+
+  frame.add_fcn (octave::command_editor::set_input_stream, in_stream);
+
+  frame.add_fcn (octave::command_history::ignore_entries,
+                 octave::command_history::ignoring_entries ());
+
+  octave::command_history::ignore_entries ();
 
   FILE *ffile = 0;
 
   if (! full_file.empty ())
     ffile = gnulib::fopen (full_file.c_str (), "rb");
 
   if (ffile)
     {
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -39,1800 +39,1805 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
 #include "oct-time.h"
 #include "singleton-cleanup.h"
 
-command_editor *command_editor::instance = 0;
-
-std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
-
-std::set<command_editor::pre_input_hook_fcn> command_editor::pre_input_hook_set;
-
-std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
-
-static octave_mutex event_hook_lock;
-
 #if defined (USE_READLINE)
-
 #include <cstdio>
 #include <cstdlib>
 
 #include "oct-rl-edit.h"
+#endif
 
-class
-gnu_readline : public command_editor
+namespace octave
 {
-public:
+  command_editor *command_editor::instance = 0;
+
+  std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
+
+  std::set<command_editor::pre_input_hook_fcn> command_editor::pre_input_hook_set;
+
+  std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
+
+  static octave_mutex event_hook_lock;
+
+#if defined (USE_READLINE)
+
+  class
+  gnu_readline : public command_editor
+  {
+  public:
+
+    typedef command_editor::startup_hook_fcn startup_hook_fcn;
+
+    typedef command_editor::pre_input_hook_fcn pre_input_hook_fcn;
+
+    typedef command_editor::event_hook_fcn event_hook_fcn;
+
+    typedef command_editor::completion_fcn completion_fcn;
 
-  typedef command_editor::startup_hook_fcn startup_hook_fcn;
+    gnu_readline (void);
+
+    ~gnu_readline (void) { }
+
+    void do_set_name (const std::string& n);
+
+    std::string do_readline (const std::string& prompt, bool& eof);
+
+    void do_set_input_stream (FILE *f);
+
+    FILE *do_get_input_stream (void);
+
+    void do_set_output_stream (FILE *f);
 
-  typedef command_editor::pre_input_hook_fcn pre_input_hook_fcn;
+    FILE *do_get_output_stream (void);
+
+    void do_redisplay (void);
+
+    int do_terminal_rows (void);
+
+    int do_terminal_cols (void);
+
+    void do_clear_screen (bool skip_redisplay);
+
+    void do_resize_terminal (void);
+
+    void do_set_screen_size (int ht, int wd);
 
-  typedef command_editor::event_hook_fcn event_hook_fcn;
+    std::string newline_chars (void);
+
+    void do_restore_terminal_state (void);
+
+    void do_blink_matching_paren (bool flag);
+
+    bool do_erase_empty_line (bool flag);
+
+    void do_set_basic_word_break_characters (const std::string& s);
+
+    void do_set_completer_word_break_characters (const std::string& s);
+
+    void do_set_basic_quote_characters (const std::string& s);
 
-  typedef command_editor::completion_fcn completion_fcn;
+    void do_set_filename_quote_characters (const std::string& s);
+
+    void do_set_completer_quote_characters (const std::string& s);
+
+    void do_set_completion_append_character (char c);
+
+    void do_set_completion_function (completion_fcn f);
+
+    void do_set_quoting_function (quoting_fcn f);
+
+    void do_set_dequoting_function (dequoting_fcn f);
+
+    void do_set_char_is_quoted_function (char_is_quoted_fcn f);
 
-  gnu_readline (void);
+    void do_set_user_accept_line_function (user_accept_line_fcn f);
+
+    completion_fcn do_get_completion_function (void) const;
+
+    quoting_fcn do_get_quoting_function (void) const;
+
+    dequoting_fcn do_get_dequoting_function (void) const;
+
+    char_is_quoted_fcn do_get_char_is_quoted_function (void) const;
+
+    user_accept_line_fcn do_get_user_accept_line_function (void) const;
+
+    string_vector
+    do_generate_filename_completions (const std::string& text);
 
-  ~gnu_readline (void) { }
+    std::string do_get_line_buffer (void) const;
+
+    std::string do_get_current_line (void) const;
+
+    void do_replace_line (const std::string& text, bool clear_undo);
+
+    void do_kill_full_line (void);
 
-  void do_set_name (const std::string& n);
+    void do_insert_text (const std::string& text);
+
+    void do_newline (void);
+
+    void do_accept_line (void);
+
+    bool do_undo (void);
 
-  std::string do_readline (const std::string& prompt, bool& eof);
+    void do_clear_undo_list (void);
+
+    void set_startup_hook (startup_hook_fcn f);
+
+    void restore_startup_hook (void);
+
+    void set_pre_input_hook (pre_input_hook_fcn f);
+
+    void restore_pre_input_hook (void);
+
+    void set_event_hook (event_hook_fcn f);
+
+    void restore_event_hook (void);
 
-  void do_set_input_stream (FILE *f);
+    void do_restore_event_hook (void);
+
+    void do_read_init_file (const std::string& file);
+
+    void do_re_read_init_file (void);
+
+    bool do_filename_completion_desired (bool);
+
+    bool do_filename_quoting_desired (bool);
+
+    bool do_prefer_env_winsize (bool);
+
+    void do_interrupt (bool);
 
-  FILE *do_get_input_stream (void);
+    static int operate_and_get_next (int, int);
+
+    static int history_search_backward (int, int);
+
+    static int history_search_forward (int, int);
+
+  private:
+
+    startup_hook_fcn previous_startup_hook;
+
+    pre_input_hook_fcn previous_pre_input_hook;
+
+    event_hook_fcn previous_event_hook;
 
-  void do_set_output_stream (FILE *f);
+    completion_fcn completion_function;
+
+    quoting_fcn quoting_function;
+
+    dequoting_fcn dequoting_function;
 
-  FILE *do_get_output_stream (void);
+    char_is_quoted_fcn char_is_quoted_function;
+
+    user_accept_line_fcn user_accept_line_function;
+
+    static char *command_generator (const char *text, int state);
+
+    static char *command_quoter (char *text, int match_type, char *quote_pointer);
+    static char *command_dequoter (char *text, int match_type);
 
-  void do_redisplay (void);
+    static int command_char_is_quoted (char *text, int index);
+
+    static int command_accept_line (int count, int key);
+
+    static char **command_completer (const char *text, int start, int end);
+  };
 
-  int do_terminal_rows (void);
+  gnu_readline::gnu_readline ()
+    : command_editor (), previous_startup_hook (0),
+      previous_pre_input_hook (0),
+      previous_event_hook (0), completion_function (0),
+      quoting_function (0), dequoting_function (0),
+      char_is_quoted_function (0), user_accept_line_function (0)
+  {
+    // FIXME: need interface to rl_add_defun, rl_initialize, and
+    // a function to set rl_terminal_name
+
+    std::string term = octave::sys::env::getenv ("TERM");
+
+    octave_rl_set_terminal_name (term.c_str ());
+
+    octave_rl_initialize ();
+
+    do_blink_matching_paren (true);
+
+    // Bind operate-and-get-next.
 
-  int do_terminal_cols (void);
+    octave_rl_add_defun ("operate-and-get-next",
+                         gnu_readline::operate_and_get_next,
+                         octave_rl_ctrl ('O'));
+
+    // And the history search functions.
+
+    octave_rl_add_defun ("history-search-backward",
+                         gnu_readline::history_search_backward,
+                         octave_rl_meta ('P'));
+
+    octave_rl_add_defun ("history-search-forward",
+                         gnu_readline::history_search_forward,
+                         octave_rl_meta ('N'));
+  }
 
-  void do_clear_screen (bool skip_redisplay);
+  void
+  gnu_readline::do_set_name (const std::string& nm)
+  {
+    ::octave_rl_set_name (nm.c_str ());
+  }
 
-  void do_resize_terminal (void);
+  std::string
+  gnu_readline::do_readline (const std::string& prompt, bool& eof)
+  {
+    std::string retval;
+
+    eof = false;
+
+    const char *p = prompt.c_str ();
+
+    BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-  void do_set_screen_size (int ht, int wd);
+    char *line = ::octave_rl_readline (p);
+
+    if (line)
+      {
+        retval = line;
+
+        free (line);
+      }
+    else
+      eof = true;
+
+    END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-  std::string newline_chars (void);
+    return retval;
+  }
+
+  void
+  gnu_readline::do_set_input_stream (FILE *f)
+  {
+    ::octave_rl_set_input_stream (f);
+  }
+
+  FILE *
+  gnu_readline::do_get_input_stream (void)
+  {
+    return ::octave_rl_get_input_stream ();
+  }
 
-  void do_restore_terminal_state (void);
+  void
+  gnu_readline::do_set_output_stream (FILE *f)
+  {
+    ::octave_rl_set_output_stream (f);
+  }
+
+  FILE *
+  gnu_readline::do_get_output_stream (void)
+  {
+    return ::octave_rl_get_output_stream ();
+  }
 
-  void do_blink_matching_paren (bool flag);
+  void
+  gnu_readline::do_redisplay (void)
+  {
+    ::octave_rl_redisplay ();
+  }
 
-  bool do_erase_empty_line (bool flag);
+  // GNU readline handles SIGWINCH, so these values have a good chance
+  // of being correct even if the window changes size (they may be
+  // wrong if, for example, the luser changes the window size while the
+  // pager is running, and the signal is handled by the pager instead of
+  // us.
+
+  int
+  gnu_readline::do_terminal_rows (void)
+  {
+    int sh = ::octave_rl_screen_height ();
 
-  void do_set_basic_word_break_characters (const std::string& s);
+    return sh > 0 ? sh : 24;
+  }
+
+  int
+  gnu_readline::do_terminal_cols (void)
+  {
+    int sw = ::octave_rl_screen_width ();
+
+    return sw > 0 ? sw : 80;
+  }
 
-  void do_set_completer_word_break_characters (const std::string& s);
+  void
+  gnu_readline::do_clear_screen (bool skip_redisplay)
+  {
+    ::octave_rl_clear_screen (skip_redisplay);
+  }
+
+  void
+  gnu_readline::do_resize_terminal (void)
+  {
+    ::octave_rl_resize_terminal ();
+  }
+
+  void
+  gnu_readline::do_set_screen_size (int ht, int wd)
+  {
+    ::octave_rl_set_screen_size (ht, wd);
+  }
 
-  void do_set_basic_quote_characters (const std::string& s);
+  std::string
+  gnu_readline::newline_chars (void)
+  {
+    return "\r\n";
+  }
+
+  void
+  gnu_readline::do_restore_terminal_state (void)
+  {
+    ::octave_rl_restore_terminal_state ();
+  }
 
-  void do_set_filename_quote_characters (const std::string& s);
+  void
+  gnu_readline::do_blink_matching_paren (bool flag)
+  {
+    ::octave_rl_enable_paren_matching (flag ? 1 : 0);
+  }
 
-  void do_set_completer_quote_characters (const std::string& s);
+  bool
+  gnu_readline::do_erase_empty_line (bool flag)
+  {
+    return ::octave_rl_erase_empty_line (flag ? 1 : 0);
+  }
+
+  void
+  gnu_readline::do_set_basic_word_break_characters (const std::string& s)
+  {
+    ::octave_rl_set_basic_word_break_characters (s.c_str ());
+  }
 
-  void do_set_completion_append_character (char c);
+  void
+  gnu_readline::do_set_completer_word_break_characters (const std::string& s)
+  {
+    ::octave_rl_set_completer_word_break_characters (s.c_str ());
+  }
+
+  void
+  gnu_readline::do_set_basic_quote_characters (const std::string& s)
+  {
+    ::octave_rl_set_basic_quote_characters (s.c_str ());
+  }
 
-  void do_set_completion_function (completion_fcn f);
+  void
+  gnu_readline::do_set_filename_quote_characters (const std::string& s)
+  {
+    ::octave_rl_set_filename_quote_characters (s.c_str ());
+  }
+
+  void
+  gnu_readline::do_set_completer_quote_characters (const std::string& s)
+  {
+    ::octave_rl_set_completer_quote_characters (s.c_str ());
+  }
 
-  void do_set_quoting_function (quoting_fcn f);
+  void
+  gnu_readline::do_set_completion_append_character (char c)
+  {
+    ::octave_rl_set_completion_append_character (c);
+  }
+
+  void
+  gnu_readline::do_set_completion_function (completion_fcn f)
+  {
+    completion_function = f;
+
+    rl_attempted_completion_fcn_ptr fp
+      = f ? gnu_readline::command_completer : 0;
 
-  void do_set_dequoting_function (dequoting_fcn f);
+    ::octave_rl_set_completion_function (fp);
+  }
+
+  void
+  gnu_readline::do_set_quoting_function (quoting_fcn f)
+  {
+    quoting_function = f;
 
-  void do_set_char_is_quoted_function (char_is_quoted_fcn f);
+    rl_quoting_fcn_ptr fp
+      = f ? gnu_readline::command_quoter : 0;
+
+    ::octave_rl_set_quoting_function (fp);
+  }
+
+  void
+  gnu_readline::do_set_dequoting_function (dequoting_fcn f)
+  {
+    dequoting_function = f;
 
-  void do_set_user_accept_line_function (user_accept_line_fcn f);
+    rl_dequoting_fcn_ptr fp
+      = f ? gnu_readline::command_dequoter : 0;
+
+    ::octave_rl_set_dequoting_function (fp);
+  }
+
+  void
+  gnu_readline::do_set_char_is_quoted_function (char_is_quoted_fcn f)
+  {
+    char_is_quoted_function = f;
+
+    rl_char_is_quoted_fcn_ptr fp
+      = f ? gnu_readline::command_char_is_quoted : 0;
 
-  completion_fcn do_get_completion_function (void) const;
+    ::octave_rl_set_char_is_quoted_function (fp);
+  }
+
+  void
+  gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
+  {
+    user_accept_line_function = f;
 
-  quoting_fcn do_get_quoting_function (void) const;
+    if (f)
+      octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line,
+                           ::octave_rl_ctrl ('M'));
+    else
+      octave_rl_add_defun ("accept-line", ::octave_rl_newline,
+                           ::octave_rl_ctrl ('M'));
+  }
 
-  dequoting_fcn do_get_dequoting_function (void) const;
+  gnu_readline::completion_fcn
+  gnu_readline::do_get_completion_function (void) const
+  {
+    return completion_function;
+  }
+
+  gnu_readline::quoting_fcn
+  gnu_readline::do_get_quoting_function (void) const
+  {
+    return quoting_function;
+  }
 
-  char_is_quoted_fcn do_get_char_is_quoted_function (void) const;
+  gnu_readline::dequoting_fcn
+  gnu_readline::do_get_dequoting_function (void) const
+  {
+    return dequoting_function;
+  }
 
-  user_accept_line_fcn do_get_user_accept_line_function (void) const;
+  gnu_readline::char_is_quoted_fcn
+  gnu_readline::do_get_char_is_quoted_function (void) const
+  {
+    return char_is_quoted_function;
+  }
+
+  gnu_readline::user_accept_line_fcn
+  gnu_readline::do_get_user_accept_line_function (void) const
+  {
+    return user_accept_line_function;
+  }
 
   string_vector
-  do_generate_filename_completions (const std::string& text);
-
-  std::string do_get_line_buffer (void) const;
-
-  std::string do_get_current_line (void) const;
-
-  void do_replace_line (const std::string& text, bool clear_undo);
-
-  void do_kill_full_line (void);
-
-  void do_insert_text (const std::string& text);
-
-  void do_newline (void);
-
-  void do_accept_line (void);
-
-  bool do_undo (void);
-
-  void do_clear_undo_list (void);
+  gnu_readline::do_generate_filename_completions (const std::string& text)
+  {
+    string_vector retval;
 
-  void set_startup_hook (startup_hook_fcn f);
-
-  void restore_startup_hook (void);
-
-  void set_pre_input_hook (pre_input_hook_fcn f);
-
-  void restore_pre_input_hook (void);
-
-  void set_event_hook (event_hook_fcn f);
+    int n = 0;
+    int count = 0;
 
-  void restore_event_hook (void);
-
-  void do_restore_event_hook (void);
+    char *fn = 0;
 
-  void do_read_init_file (const std::string& file);
-
-  void do_re_read_init_file (void);
-
-  bool do_filename_completion_desired (bool);
+    while (1)
+      {
+        fn = ::octave_rl_filename_completion_function (text.c_str (), count);
 
-  bool do_filename_quoting_desired (bool);
-
-  bool do_prefer_env_winsize (bool);
-
-  void do_interrupt (bool);
-
-  static int operate_and_get_next (int, int);
-
-  static int history_search_backward (int, int);
-
-  static int history_search_forward (int, int);
-
-private:
-
-  startup_hook_fcn previous_startup_hook;
-
-  pre_input_hook_fcn previous_pre_input_hook;
-
-  event_hook_fcn previous_event_hook;
+        if (fn)
+          {
+            if (count == n)
+              {
+                // Famous last words:  Most large directories will not
+                // have more than a few hundred files, so we should not
+                // resize too many times even if the growth is linear...
 
-  completion_fcn completion_function;
-
-  quoting_fcn quoting_function;
+                n += 100;
+                retval.resize (n);
+              }
 
-  dequoting_fcn dequoting_function;
-
-  char_is_quoted_fcn char_is_quoted_function;
-
-  user_accept_line_fcn user_accept_line_function;
+            retval[count++] = fn;
 
-  static char *command_generator (const char *text, int state);
-
-  static char *command_quoter (char *text, int match_type, char *quote_pointer);
-  static char *command_dequoter (char *text, int match_type);
+            free (fn);
+          }
+        else
+          break;
+      }
 
-  static int command_char_is_quoted (char *text, int index);
-
-  static int command_accept_line (int count, int key);
-
-  static char **command_completer (const char *text, int start, int end);
-};
+    retval.resize (count);
 
-gnu_readline::gnu_readline ()
-  : command_editor (), previous_startup_hook (0),
-    previous_pre_input_hook (0),
-    previous_event_hook (0), completion_function (0),
-    quoting_function (0), dequoting_function (0),
-    char_is_quoted_function (0), user_accept_line_function (0)
-{
-  // FIXME: need interface to rl_add_defun, rl_initialize, and
-  // a function to set rl_terminal_name
-
-  std::string term = octave::sys::env::getenv ("TERM");
-
-  octave_rl_set_terminal_name (term.c_str ());
-
-  octave_rl_initialize ();
-
-  do_blink_matching_paren (true);
-
-  // Bind operate-and-get-next.
+    return retval;
+  }
 
-  octave_rl_add_defun ("operate-and-get-next",
-                       gnu_readline::operate_and_get_next,
-                       octave_rl_ctrl ('O'));
-
-  // And the history search functions.
-
-  octave_rl_add_defun ("history-search-backward",
-                       gnu_readline::history_search_backward,
-                       octave_rl_meta ('P'));
-
-  octave_rl_add_defun ("history-search-forward",
-                       gnu_readline::history_search_forward,
-                       octave_rl_meta ('N'));
-}
-
-void
-gnu_readline::do_set_name (const std::string& nm)
-{
-  ::octave_rl_set_name (nm.c_str ());
-}
+  std::string
+  gnu_readline::do_get_line_buffer (void) const
+  {
+    return ::octave_rl_line_buffer ();
+  }
 
-std::string
-gnu_readline::do_readline (const std::string& prompt, bool& eof)
-{
-  std::string retval;
-
-  eof = false;
-
-  const char *p = prompt.c_str ();
-
-  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-  char *line = ::octave_rl_readline (p);
-
-  if (line)
-    {
-      retval = line;
-
-      free (line);
-    }
-  else
-    eof = true;
+  std::string
+  gnu_readline::do_get_current_line (void) const
+  {
+    std::string retval;
+    char *buf = ::octave_rl_copy_line ();
+    retval = buf;
+    free (buf);
+    return retval;
+  }
 
-  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-  return retval;
-}
-
-void
-gnu_readline::do_set_input_stream (FILE *f)
-{
-  ::octave_rl_set_input_stream (f);
-}
+  void
+  gnu_readline::do_replace_line (const std::string& text, bool clear_undo)
+  {
+    ::octave_rl_replace_line (text.c_str (), clear_undo);
+  }
 
-FILE *
-gnu_readline::do_get_input_stream (void)
-{
-  return ::octave_rl_get_input_stream ();
-}
+  void
+  gnu_readline::do_kill_full_line (void)
+  {
+    ::octave_rl_kill_full_line ();
+  }
 
-void
-gnu_readline::do_set_output_stream (FILE *f)
-{
-  ::octave_rl_set_output_stream (f);
-}
+  void
+  gnu_readline::do_insert_text (const std::string& text)
+  {
+    ::octave_rl_insert_text (text.c_str ());
+  }
 
-FILE *
-gnu_readline::do_get_output_stream (void)
-{
-  return ::octave_rl_get_output_stream ();
-}
-
-void
-gnu_readline::do_redisplay (void)
-{
-  ::octave_rl_redisplay ();
-}
-
-// GNU readline handles SIGWINCH, so these values have a good chance
-// of being correct even if the window changes size (they may be
-// wrong if, for example, the luser changes the window size while the
-// pager is running, and the signal is handled by the pager instead of
-// us.
+  void
+  gnu_readline::do_newline (void)
+  {
+    ::octave_rl_newline (1, '\n');
+  }
 
-int
-gnu_readline::do_terminal_rows (void)
-{
-  int sh = ::octave_rl_screen_height ();
-
-  return sh > 0 ? sh : 24;
-}
+  void
+  gnu_readline::do_accept_line (void)
+  {
+    command_accept_line (1, '\n');
+  }
 
-int
-gnu_readline::do_terminal_cols (void)
-{
-  int sw = ::octave_rl_screen_width ();
-
-  return sw > 0 ? sw : 80;
-}
-
-void
-gnu_readline::do_clear_screen (bool skip_redisplay)
-{
-  ::octave_rl_clear_screen (skip_redisplay);
-}
+  bool
+  gnu_readline::do_undo (void)
+  {
+    return ::octave_rl_do_undo ();
+  }
 
-void
-gnu_readline::do_resize_terminal (void)
-{
-  ::octave_rl_resize_terminal ();
-}
-
-void
-gnu_readline::do_set_screen_size (int ht, int wd)
-{
-  ::octave_rl_set_screen_size (ht, wd);
-}
-
-std::string
-gnu_readline::newline_chars (void)
-{
-  return "\r\n";
-}
+  void
+  gnu_readline::do_clear_undo_list ()
+  {
+    ::octave_rl_clear_undo_list ();
+  }
 
-void
-gnu_readline::do_restore_terminal_state (void)
-{
-  ::octave_rl_restore_terminal_state ();
-}
-
-void
-gnu_readline::do_blink_matching_paren (bool flag)
-{
-  ::octave_rl_enable_paren_matching (flag ? 1 : 0);
-}
+  void
+  gnu_readline::set_startup_hook (startup_hook_fcn f)
+  {
+    previous_startup_hook = ::octave_rl_get_startup_hook ();
 
-bool
-gnu_readline::do_erase_empty_line (bool flag)
-{
-  return ::octave_rl_erase_empty_line (flag ? 1 : 0);
-}
+    if (f != previous_startup_hook)
+      ::octave_rl_set_startup_hook (f);
+  }
 
-void
-gnu_readline::do_set_basic_word_break_characters (const std::string& s)
-{
-  ::octave_rl_set_basic_word_break_characters (s.c_str ());
-}
+  void
+  gnu_readline::restore_startup_hook (void)
+  {
+    ::octave_rl_set_startup_hook (previous_startup_hook);
+  }
 
-void
-gnu_readline::do_set_completer_word_break_characters (const std::string& s)
-{
-  ::octave_rl_set_completer_word_break_characters (s.c_str ());
-}
+  void
+  gnu_readline::set_pre_input_hook (pre_input_hook_fcn f)
+  {
+    previous_pre_input_hook = ::octave_rl_get_pre_input_hook ();
 
-void
-gnu_readline::do_set_basic_quote_characters (const std::string& s)
-{
-  ::octave_rl_set_basic_quote_characters (s.c_str ());
-}
-
-void
-gnu_readline::do_set_filename_quote_characters (const std::string& s)
-{
-  ::octave_rl_set_filename_quote_characters (s.c_str ());
-}
+    if (f != previous_pre_input_hook)
+      ::octave_rl_set_pre_input_hook (f);
+  }
 
-void
-gnu_readline::do_set_completer_quote_characters (const std::string& s)
-{
-  ::octave_rl_set_completer_quote_characters (s.c_str ());
-}
+  void
+  gnu_readline::restore_pre_input_hook (void)
+  {
+    ::octave_rl_set_pre_input_hook (previous_pre_input_hook);
+  }
 
-void
-gnu_readline::do_set_completion_append_character (char c)
-{
-  ::octave_rl_set_completion_append_character (c);
-}
-
-void
-gnu_readline::do_set_completion_function (completion_fcn f)
-{
-  completion_function = f;
-
-  rl_attempted_completion_fcn_ptr fp
-    = f ? gnu_readline::command_completer : 0;
-
-  ::octave_rl_set_completion_function (fp);
-}
+  void
+  gnu_readline::set_event_hook (event_hook_fcn f)
+  {
+    previous_event_hook = octave_rl_get_event_hook ();
 
-void
-gnu_readline::do_set_quoting_function (quoting_fcn f)
-{
-  quoting_function = f;
-
-  rl_quoting_fcn_ptr fp
-    = f ? gnu_readline::command_quoter : 0;
-
-  ::octave_rl_set_quoting_function (fp);
-}
+    ::octave_rl_set_event_hook (f);
+  }
 
-void
-gnu_readline::do_set_dequoting_function (dequoting_fcn f)
-{
-  dequoting_function = f;
-
-  rl_dequoting_fcn_ptr fp
-    = f ? gnu_readline::command_dequoter : 0;
-
-  ::octave_rl_set_dequoting_function (fp);
-}
+  void
+  gnu_readline::restore_event_hook (void)
+  {
+    ::octave_rl_set_event_hook (previous_event_hook);
+  }
 
-void
-gnu_readline::do_set_char_is_quoted_function (char_is_quoted_fcn f)
-{
-  char_is_quoted_function = f;
-
-  rl_char_is_quoted_fcn_ptr fp
-    = f ? gnu_readline::command_char_is_quoted : 0;
-
-  ::octave_rl_set_char_is_quoted_function (fp);
-}
+  void
+  gnu_readline::do_read_init_file (const std::string& file)
+  {
+    ::octave_rl_read_init_file (file.c_str ());
+  }
 
-void
-gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
-{
-  user_accept_line_function = f;
-
-  if (f)
-    octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line,
-                         ::octave_rl_ctrl ('M'));
-  else
-    octave_rl_add_defun ("accept-line", ::octave_rl_newline,
-                         ::octave_rl_ctrl ('M'));
-}
+  void
+  gnu_readline::do_re_read_init_file (void)
+  {
+    ::octave_rl_re_read_init_file ();
+  }
 
-gnu_readline::completion_fcn
-gnu_readline::do_get_completion_function (void) const
-{
-  return completion_function;
-}
-
-gnu_readline::quoting_fcn
-gnu_readline::do_get_quoting_function (void) const
-{
-  return quoting_function;
-}
+  bool
+  gnu_readline::do_filename_completion_desired (bool arg)
+  {
+    return ::octave_rl_filename_completion_desired (arg);
+  }
 
-gnu_readline::dequoting_fcn
-gnu_readline::do_get_dequoting_function (void) const
-{
-  return dequoting_function;
-}
+  bool
+  gnu_readline::do_filename_quoting_desired (bool arg)
+  {
+    return ::octave_rl_filename_quoting_desired (arg);
+  }
 
-gnu_readline::char_is_quoted_fcn
-gnu_readline::do_get_char_is_quoted_function (void) const
-{
-  return char_is_quoted_function;
-}
-
-gnu_readline::user_accept_line_fcn
-gnu_readline::do_get_user_accept_line_function (void) const
-{
-  return user_accept_line_function;
-}
-
-string_vector
-gnu_readline::do_generate_filename_completions (const std::string& text)
-{
-  string_vector retval;
+  bool
+  gnu_readline::do_prefer_env_winsize (bool arg)
+  {
+    return ::octave_rl_prefer_env_winsize (arg);
+  }
 
-  int n = 0;
-  int count = 0;
-
-  char *fn = 0;
-
-  while (1)
-    {
-      fn = ::octave_rl_filename_completion_function (text.c_str (), count);
-
-      if (fn)
-        {
-          if (count == n)
-            {
-              // Famous last words:  Most large directories will not
-              // have more than a few hundred files, so we should not
-              // resize too many times even if the growth is linear...
+  void
+  gnu_readline::do_interrupt (bool arg)
+  {
+    ::octave_rl_done (arg);
+  }
 
-              n += 100;
-              retval.resize (n);
-            }
-
-          retval[count++] = fn;
+  int
+  gnu_readline::operate_and_get_next (int /* count */, int /* c */)
+  {
+    // Accept the current line.
 
-          free (fn);
-        }
-      else
-        break;
-    }
+    command_editor::accept_line ();
 
-  retval.resize (count);
+    // Find the current line, and find the next line to use.
 
-  return retval;
-}
+    int x_where = command_history::where ();
 
-std::string
-gnu_readline::do_get_line_buffer (void) const
-{
-  return ::octave_rl_line_buffer ();
-}
+    int x_length = command_history::length ();
 
-std::string
-gnu_readline::do_get_current_line (void) const
-{
-  std::string retval;
-  char *buf = ::octave_rl_copy_line ();
-  retval = buf;
-  free (buf);
-  return retval;
-}
+    if ((command_history::is_stifled ()
+         && (x_length >= command_history::max_input_history ()))
+        || (x_where >= x_length - 1))
+      command_history::set_mark (x_where);
+    else
+      command_history::set_mark (x_where + 1);
 
-void
-gnu_readline::do_replace_line (const std::string& text, bool clear_undo)
-{
-  ::octave_rl_replace_line (text.c_str (), clear_undo);
-}
+    command_editor::add_startup_hook (command_history::goto_mark);
 
-void
-gnu_readline::do_kill_full_line (void)
-{
-  ::octave_rl_kill_full_line ();
-}
-
-void
-gnu_readline::do_insert_text (const std::string& text)
-{
-  ::octave_rl_insert_text (text.c_str ());
-}
+    return 0;
+  }
 
-void
-gnu_readline::do_newline (void)
-{
-  ::octave_rl_newline (1, '\n');
-}
-
-void
-gnu_readline::do_accept_line (void)
-{
-  command_accept_line (1, '\n');
-}
+  int
+  gnu_readline::history_search_backward (int count, int c)
+  {
+    return octave_rl_history_search_backward (count, c);
+  }
 
-bool
-gnu_readline::do_undo (void)
-{
-  return ::octave_rl_do_undo ();
-}
-
-void
-gnu_readline::do_clear_undo_list ()
-{
-  ::octave_rl_clear_undo_list ();
-}
-
-void
-gnu_readline::set_startup_hook (startup_hook_fcn f)
-{
-  previous_startup_hook = ::octave_rl_get_startup_hook ();
-
-  if (f != previous_startup_hook)
-    ::octave_rl_set_startup_hook (f);
-}
+  int
+  gnu_readline::history_search_forward (int count, int c)
+  {
+    return octave_rl_history_search_forward (count, c);
+  }
 
-void
-gnu_readline::restore_startup_hook (void)
-{
-  ::octave_rl_set_startup_hook (previous_startup_hook);
-}
+  char *
+  gnu_readline::command_generator (const char *text, int state)
+  {
+    char *retval = 0;
 
-void
-gnu_readline::set_pre_input_hook (pre_input_hook_fcn f)
-{
-  previous_pre_input_hook = ::octave_rl_get_pre_input_hook ();
+    completion_fcn f = command_editor::get_completion_function ();
 
-  if (f != previous_pre_input_hook)
-    ::octave_rl_set_pre_input_hook (f);
-}
+    std::string tmp = f (text, state);
+
+    size_t len = tmp.length ();
 
-void
-gnu_readline::restore_pre_input_hook (void)
-{
-  ::octave_rl_set_pre_input_hook (previous_pre_input_hook);
-}
-
-void
-gnu_readline::set_event_hook (event_hook_fcn f)
-{
-  previous_event_hook = octave_rl_get_event_hook ();
-
-  ::octave_rl_set_event_hook (f);
-}
+    if (len > 0)
+      {
+        retval = static_cast<char *> (gnulib::malloc (len+1));
 
-void
-gnu_readline::restore_event_hook (void)
-{
-  ::octave_rl_set_event_hook (previous_event_hook);
-}
+        strcpy (retval, tmp.c_str ());
+      }
 
-void
-gnu_readline::do_read_init_file (const std::string& file)
-{
-  ::octave_rl_read_init_file (file.c_str ());
-}
-
-void
-gnu_readline::do_re_read_init_file (void)
-{
-  ::octave_rl_re_read_init_file ();
-}
+    return retval;
+  }
 
-bool
-gnu_readline::do_filename_completion_desired (bool arg)
-{
-  return ::octave_rl_filename_completion_desired (arg);
-}
-
-bool
-gnu_readline::do_filename_quoting_desired (bool arg)
-{
-  return ::octave_rl_filename_quoting_desired (arg);
-}
+  char *
+  gnu_readline::command_quoter (char *text, int matches, char *qcp)
+  {
+    char *retval = 0;
 
-bool
-gnu_readline::do_prefer_env_winsize (bool arg)
-{
-  return ::octave_rl_prefer_env_winsize (arg);
-}
+    quoting_fcn f = command_editor::get_quoting_function ();
 
-void
-gnu_readline::do_interrupt (bool arg)
-{
-  ::octave_rl_done (arg);
-}
+    std::string tmp = f (text, matches, *qcp);
+
+    size_t len = tmp.length ();
 
-int
-gnu_readline::operate_and_get_next (int /* count */, int /* c */)
-{
-  // Accept the current line.
-
-  command_editor::accept_line ();
-
-  // Find the current line, and find the next line to use.
-
-  int x_where = command_history::where ();
+    if (len > 0)
+      {
+        retval = static_cast<char *> (gnulib::malloc (len+1));
 
-  int x_length = command_history::length ();
+        strcpy (retval, tmp.c_str ());
+      }
 
-  if ((command_history::is_stifled ()
-       && (x_length >= command_history::max_input_history ()))
-      || (x_where >= x_length - 1))
-    command_history::set_mark (x_where);
-  else
-    command_history::set_mark (x_where + 1);
-
-  command_editor::add_startup_hook (command_history::goto_mark);
+    return retval;
+  }
 
-  return 0;
-}
-
-int
-gnu_readline::history_search_backward (int count, int c)
-{
-  return octave_rl_history_search_backward (count, c);
-}
+  char *
+  gnu_readline::command_dequoter (char *text, int quote)
+  {
+    char *retval = 0;
 
-int
-gnu_readline::history_search_forward (int count, int c)
-{
-  return octave_rl_history_search_forward (count, c);
-}
+    dequoting_fcn f = command_editor::get_dequoting_function ();
 
-char *
-gnu_readline::command_generator (const char *text, int state)
-{
-  char *retval = 0;
+    std::string tmp = f (text, quote);
 
-  completion_fcn f = command_editor::get_completion_function ();
+    size_t len = tmp.length ();
 
-  std::string tmp = f (text, state);
-
-  size_t len = tmp.length ();
-
-  if (len > 0)
-    {
-      retval = static_cast<char *> (gnulib::malloc (len+1));
+    if (len > 0)
+      {
+        retval = static_cast<char *> (gnulib::malloc (len+1));
 
-      strcpy (retval, tmp.c_str ());
-    }
-
-  return retval;
-}
-
-char *
-gnu_readline::command_quoter (char *text, int matches, char *qcp)
-{
-  char *retval = 0;
-
-  quoting_fcn f = command_editor::get_quoting_function ();
+        strcpy (retval, tmp.c_str ());
+      }
 
-  std::string tmp = f (text, matches, *qcp);
-
-  size_t len = tmp.length ();
-
-  if (len > 0)
-    {
-      retval = static_cast<char *> (gnulib::malloc (len+1));
+    return retval;
+  }
 
-      strcpy (retval, tmp.c_str ());
-    }
-
-  return retval;
-}
+  int
+  gnu_readline::command_char_is_quoted (char *text, int quote)
+  {
+    char_is_quoted_fcn f = command_editor::get_char_is_quoted_function ();
 
-char *
-gnu_readline::command_dequoter (char *text, int quote)
-{
-  char *retval = 0;
-
-  dequoting_fcn f = command_editor::get_dequoting_function ();
+    return f (text, quote);
+  }
 
-  std::string tmp = f (text, quote);
-
-  size_t len = tmp.length ();
-
-  if (len > 0)
-    {
-      retval = static_cast<char *> (gnulib::malloc (len+1));
-
-      strcpy (retval, tmp.c_str ());
-    }
+  int
+  gnu_readline::command_accept_line (int count, int key)
+  {
+    user_accept_line_fcn f = command_editor::get_user_accept_line_function ();
 
-  return retval;
-}
+    if (f)
+      f (::octave_rl_line_buffer ());
 
-int
-gnu_readline::command_char_is_quoted (char *text, int quote)
-{
-  char_is_quoted_fcn f = command_editor::get_char_is_quoted_function ();
-
-  return f (text, quote);
-}
+    ::octave_rl_redisplay ();
 
-int
-gnu_readline::command_accept_line (int count, int key)
-{
-  user_accept_line_fcn f = command_editor::get_user_accept_line_function ();
-
-  if (f)
-    f (::octave_rl_line_buffer ());
-
-  ::octave_rl_redisplay ();
+    return ::octave_rl_newline (count, key);
+  }
 
-  return ::octave_rl_newline (count, key);
-}
-
-char **
-gnu_readline::command_completer (const char *text, int, int)
-{
-  char **matches = 0;
-  matches
-    = ::octave_rl_completion_matches (text, gnu_readline::command_generator);
-  return matches;
-}
+  char **
+  gnu_readline::command_completer (const char *text, int, int)
+  {
+    char **matches = 0;
+    matches
+      = ::octave_rl_completion_matches (text, gnu_readline::command_generator);
+    return matches;
+  }
 
 #endif
 
-class
-default_command_editor : public command_editor
-{
-public:
+  class
+  default_command_editor : public command_editor
+  {
+  public:
 
-  default_command_editor (void)
-    : command_editor (), input_stream (stdin), output_stream (stdout) { }
+    default_command_editor (void)
+      : command_editor (), input_stream (stdin), output_stream (stdout) { }
 
-  ~default_command_editor (void) { }
+    ~default_command_editor (void) { }
+
+    std::string do_readline (const std::string& prompt, bool& eof);
 
-  std::string do_readline (const std::string& prompt, bool& eof);
+    void do_set_input_stream (FILE *f);
 
-  void do_set_input_stream (FILE *f);
+    FILE *do_get_input_stream (void);
 
-  FILE *do_get_input_stream (void);
+    void do_set_output_stream (FILE *f);
 
-  void do_set_output_stream (FILE *f);
+    FILE *do_get_output_stream (void);
+
+    string_vector do_generate_filename_completions (const std::string& text);
 
-  FILE *do_get_output_stream (void);
+    std::string do_get_line_buffer (void) const;
 
-  string_vector do_generate_filename_completions (const std::string& text);
+    std::string do_get_current_line (void) const;
 
-  std::string do_get_line_buffer (void) const;
+    void do_replace_line (const std::string& text, bool clear_undo);
 
-  std::string do_get_current_line (void) const;
+    void do_kill_full_line (void);
 
-  void do_replace_line (const std::string& text, bool clear_undo);
+    void do_insert_text (const std::string& text);
 
-  void do_kill_full_line (void);
+    void do_newline (void);
+
+    void do_accept_line (void);
 
-  void do_insert_text (const std::string& text);
+  private:
 
-  void do_newline (void);
+    FILE *input_stream;
 
-  void do_accept_line (void);
+    FILE *output_stream;
 
-private:
+    // No copying!
 
-  FILE *input_stream;
+    default_command_editor (const default_command_editor&);
 
-  FILE *output_stream;
+    default_command_editor& operator = (const default_command_editor&);
+  };
 
-  // No copying!
-
-  default_command_editor (const default_command_editor&);
+  std::string
+  default_command_editor::do_readline (const std::string& prompt, bool& eof)
+  {
+    gnulib::fputs (prompt.c_str (), output_stream);
+    gnulib::fflush (output_stream);
 
-  default_command_editor& operator = (const default_command_editor&);
-};
+    return octave_fgetl (input_stream, eof);
+  }
 
-std::string
-default_command_editor::do_readline (const std::string& prompt, bool& eof)
-{
-  gnulib::fputs (prompt.c_str (), output_stream);
-  gnulib::fflush (output_stream);
-
-  return octave_fgetl (input_stream, eof);
-}
+  void
+  default_command_editor::do_set_input_stream (FILE *f)
+  {
+    input_stream = f;
+  }
 
-void
-default_command_editor::do_set_input_stream (FILE *f)
-{
-  input_stream = f;
-}
+  FILE *
+  default_command_editor::do_get_input_stream (void)
+  {
+    return input_stream;
+  }
 
-FILE *
-default_command_editor::do_get_input_stream (void)
-{
-  return input_stream;
-}
+  void
+  default_command_editor::do_set_output_stream (FILE *f)
+  {
+    output_stream = f;
+  }
+
+  FILE *
+  default_command_editor::do_get_output_stream (void)
+  {
+    return output_stream;
+  }
 
-void
-default_command_editor::do_set_output_stream (FILE *f)
-{
-  output_stream = f;
-}
+  string_vector
+  default_command_editor::do_generate_filename_completions (const std::string&)
+  {
+    // FIXME
+    return string_vector ();
+  }
 
-FILE *
-default_command_editor::do_get_output_stream (void)
-{
-  return output_stream;
-}
+  std::string
+  default_command_editor::do_get_line_buffer (void) const
+  {
+    return "";
+  }
 
-string_vector
-default_command_editor::do_generate_filename_completions (const std::string&)
-{
-  // FIXME
-  return string_vector ();
-}
+  std::string
+  default_command_editor::do_get_current_line (void) const
+  {
+    // FIXME
+    return "";
+  }
 
-std::string
-default_command_editor::do_get_line_buffer (void) const
-{
-  return "";
-}
+  void
+  default_command_editor::do_replace_line (const std::string&, bool)
+  {
+    // FIXME
+  }
+
+  void
+  default_command_editor::do_kill_full_line (void)
+  {
+    // FIXME
+  }
 
-std::string
-default_command_editor::do_get_current_line (void) const
-{
-  // FIXME
-  return "";
-}
+  void
+  default_command_editor::do_insert_text (const std::string&)
+  {
+    // FIXME
+  }
+
+  void
+  default_command_editor::do_newline (void)
+  {
+    // FIXME
+  }
 
-void
-default_command_editor::do_replace_line (const std::string&, bool)
-{
-  // FIXME
-}
+  void
+  default_command_editor::do_accept_line (void)
+  {
+    // FIXME
+  }
 
-void
-default_command_editor::do_kill_full_line (void)
-{
-  // FIXME
-}
+  bool
+  command_editor::instance_ok (void)
+  {
+    bool retval = true;
+
+    if (! instance)
+      {
+        make_command_editor ();
 
-void
-default_command_editor::do_insert_text (const std::string&)
-{
-  // FIXME
-}
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
 
-void
-default_command_editor::do_newline (void)
-{
-  // FIXME
-}
+    if (! instance)
+      (*current_liboctave_error_handler)
+        ("unable to create command history object!");
+
+    return retval;
+  }
 
-void
-default_command_editor::do_accept_line (void)
-{
-  // FIXME
-}
+  void
+  command_editor::make_command_editor (void)
+  {
+#if defined (USE_READLINE)
+    instance = new gnu_readline ();
+#else
+    instance = new default_command_editor ();
+#endif
+  }
 
-bool
-command_editor::instance_ok (void)
-{
-  bool retval = true;
-
-  if (! instance)
-    {
-      make_command_editor ();
+  void
+  command_editor::force_default_editor (void)
+  {
+    delete instance;
+    instance = new default_command_editor ();
+  }
 
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
+  void
+  command_editor::set_initial_input (const std::string& text)
+  {
+    if (instance_ok ())
+      instance->initial_input = text;
+  }
 
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create command history object!");
+  int
+  command_editor::insert_initial_input (void)
+  {
+    return instance_ok () ? instance->do_insert_initial_input () : 0;
+  }
 
-  return retval;
-}
+  int
+  command_editor::startup_handler (void)
+  {
+    for (startup_hook_set_iterator p = startup_hook_set.begin ();
+         p != startup_hook_set.end (); p++)
+      {
+        startup_hook_fcn f = *p;
 
-void
-command_editor::make_command_editor (void)
-{
-#if defined (USE_READLINE)
-  instance = new gnu_readline ();
-#else
-  instance = new default_command_editor ();
-#endif
-}
+        if (f)
+          f ();
+      }
+
+    return 0;
+  }
 
-void
-command_editor::force_default_editor (void)
-{
-  delete instance;
-  instance = new default_command_editor ();
-}
+  int
+  command_editor::pre_input_handler (void)
+  {
+    for (pre_input_hook_set_iterator p = pre_input_hook_set.begin ();
+         p != pre_input_hook_set.end (); p++)
+      {
+        pre_input_hook_fcn f = *p;
 
-void
-command_editor::set_initial_input (const std::string& text)
-{
-  if (instance_ok ())
-    instance->initial_input = text;
-}
+        if (f)
+          f ();
+      }
+
+    return 0;
+  }
 
-int
-command_editor::insert_initial_input (void)
-{
-  return instance_ok () ? instance->do_insert_initial_input () : 0;
-}
+  int
+  command_editor::event_handler (void)
+  {
+    event_hook_lock.lock ();
+
+    std::set<event_hook_fcn> hook_set (event_hook_set);
+
+    event_hook_lock.unlock ();
 
-int
-command_editor::startup_handler (void)
-{
-  for (startup_hook_set_iterator p = startup_hook_set.begin ();
-       p != startup_hook_set.end (); p++)
-    {
-      startup_hook_fcn f = *p;
+    for (event_hook_set_iterator p = hook_set.begin ();
+         p != hook_set.end (); p++)
+      {
+        event_hook_fcn f = *p;
+
+        if (f)
+          f ();
+      }
+
+    return 0;
+  }
 
-      if (f)
-        f ();
-    }
+  void
+  command_editor::set_name (const std::string& n)
+  {
+    if (instance_ok ())
+      instance->do_set_name (n);
+  }
 
-  return 0;
-}
+  std::string
+  command_editor::readline (const std::string& prompt)
+  {
+    bool eof;
 
-int
-command_editor::pre_input_handler (void)
-{
-  for (pre_input_hook_set_iterator p = pre_input_hook_set.begin ();
-       p != pre_input_hook_set.end (); p++)
-    {
-      pre_input_hook_fcn f = *p;
+    return readline (prompt, eof);
+  }
 
-      if (f)
-        f ();
-    }
+  std::string
+  command_editor::readline (const std::string& prompt, bool& eof)
+  {
+    std::string retval;
+
+    if (instance_ok ())
+      {
+        if (! instance->initial_input.empty ())
+          add_pre_input_hook (command_editor::insert_initial_input);
 
-  return 0;
-}
+        retval = instance->do_readline (prompt, eof);
+      }
+
+    return retval;
+  }
 
-int
-command_editor::event_handler (void)
-{
-  event_hook_lock.lock ();
-
-  std::set<event_hook_fcn> hook_set (event_hook_set);
-
-  event_hook_lock.unlock ();
+  void
+  command_editor::set_input_stream (FILE *f)
+  {
+    if (instance_ok ())
+      instance->do_set_input_stream (f);
+  }
 
-  for (event_hook_set_iterator p = hook_set.begin ();
-       p != hook_set.end (); p++)
-    {
-      event_hook_fcn f = *p;
+  FILE *
+  command_editor::get_input_stream (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_input_stream () : 0;
+  }
 
-      if (f)
-        f ();
-    }
-
-  return 0;
-}
+  void
+  command_editor::set_output_stream (FILE *f)
+  {
+    if (instance_ok ())
+      instance->do_set_output_stream (f);
+  }
 
-void
-command_editor::set_name (const std::string& n)
-{
-  if (instance_ok ())
-    instance->do_set_name (n);
-}
+  FILE *
+  command_editor::get_output_stream (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_output_stream () : 0;
+  }
 
-std::string
-command_editor::readline (const std::string& prompt)
-{
-  bool eof;
+  void
+  command_editor::redisplay (void)
+  {
+    if (instance_ok ())
+      instance->do_redisplay ();
+  }
 
-  return readline (prompt, eof);
-}
+  int
+  command_editor::terminal_rows (void)
+  {
+    return (instance_ok ())
+           ? instance->do_terminal_rows () : -1;
+  }
 
-std::string
-command_editor::readline (const std::string& prompt, bool& eof)
-{
-  std::string retval;
-
-  if (instance_ok ())
-    {
-      if (! instance->initial_input.empty ())
-        add_pre_input_hook (command_editor::insert_initial_input);
+  int
+  command_editor::terminal_cols (void)
+  {
+    return (instance_ok ())
+           ? instance->do_terminal_cols () : -1;
+  }
 
-      retval = instance->do_readline (prompt, eof);
-    }
-
-  return retval;
-}
+  void
+  command_editor::clear_screen (bool skip_redisplay)
+  {
+    if (instance_ok ())
+      instance->do_clear_screen (skip_redisplay);
+  }
 
-void
-command_editor::set_input_stream (FILE *f)
-{
-  if (instance_ok ())
-    instance->do_set_input_stream (f);
-}
+  void
+  command_editor::resize_terminal (void)
+  {
+    if (instance_ok ())
+      instance->do_resize_terminal ();
+  }
 
-FILE *
-command_editor::get_input_stream (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_input_stream () : 0;
-}
+  void
+  command_editor::set_screen_size (int ht, int wd)
+  {
+    if (instance_ok ())
+      instance->do_set_screen_size (ht, wd);
+  }
 
-void
-command_editor::set_output_stream (FILE *f)
-{
-  if (instance_ok ())
-    instance->do_set_output_stream (f);
-}
+  std::string
+  command_editor::decode_prompt_string (const std::string& s)
+  {
+    return (instance_ok ())
+           ? instance->do_decode_prompt_string (s) : "";
+  }
+
+  int
+  command_editor::current_command_number (void)
+  {
+    return (instance_ok ())
+           ? instance->command_number : 0;
+  }
 
-FILE *
-command_editor::get_output_stream (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_output_stream () : 0;
-}
+  void
+  command_editor::reset_current_command_number (int n)
+  {
+    if (instance_ok ())
+      instance->command_number = n;
+  }
+
+  void
+  command_editor::increment_current_command_number (void)
+  {
+    if (instance_ok ())
+      instance->command_number++;
+  }
 
-void
-command_editor::redisplay (void)
-{
-  if (instance_ok ())
-    instance->do_redisplay ();
-}
+  void
+  command_editor::restore_terminal_state (void)
+  {
+    if (instance_ok ())
+      instance->do_restore_terminal_state ();
+  }
 
-int
-command_editor::terminal_rows (void)
-{
-  return (instance_ok ())
-         ? instance->do_terminal_rows () : -1;
-}
+  void
+  command_editor::blink_matching_paren (bool flag)
+  {
+    if (instance_ok ())
+      instance->do_blink_matching_paren (flag);
+  }
 
-int
-command_editor::terminal_cols (void)
-{
-  return (instance_ok ())
-         ? instance->do_terminal_cols () : -1;
-}
+  bool
+  command_editor::erase_empty_line (bool flag)
+  {
+    return instance_ok () ? instance->do_erase_empty_line (flag) : false;
+  }
+
+  void
+  command_editor::set_basic_word_break_characters (const std::string& s)
+  {
+    if (instance_ok ())
+      instance->do_set_basic_word_break_characters (s);
+  }
 
-void
-command_editor::clear_screen (bool skip_redisplay)
-{
-  if (instance_ok ())
-    instance->do_clear_screen (skip_redisplay);
-}
+  void
+  command_editor::set_completer_word_break_characters (const std::string& s)
+  {
+    if (instance_ok ())
+      instance->do_set_completer_word_break_characters (s);
+  }
 
-void
-command_editor::resize_terminal (void)
-{
-  if (instance_ok ())
-    instance->do_resize_terminal ();
-}
+  void
+  command_editor::set_basic_quote_characters (const std::string& s)
+  {
+    if (instance_ok ())
+      instance->do_set_basic_quote_characters (s);
+  }
+
+  void
+  command_editor::set_filename_quote_characters (const std::string& s)
+  {
+    if (instance_ok ())
+      instance->do_set_filename_quote_characters (s);
+  }
 
-void
-command_editor::set_screen_size (int ht, int wd)
-{
-  if (instance_ok ())
-    instance->do_set_screen_size (ht, wd);
-}
+  void
+  command_editor::set_completer_quote_characters (const std::string& s)
+  {
+    if (instance_ok ())
+      instance->do_set_completer_quote_characters (s);
+  }
+
+  void
+  command_editor::set_completion_append_character (char c)
+  {
+    if (instance_ok ())
+      instance->do_set_completion_append_character (c);
+  }
 
-std::string
-command_editor::decode_prompt_string (const std::string& s)
-{
-  return (instance_ok ())
-         ? instance->do_decode_prompt_string (s) : "";
-}
+  void
+  command_editor::set_completion_function (completion_fcn f)
+  {
+    if (instance_ok ())
+      instance->do_set_completion_function (f);
+  }
 
-int
-command_editor::current_command_number (void)
-{
-  return (instance_ok ())
-         ? instance->command_number : 0;
-}
+  void
+  command_editor::set_quoting_function (quoting_fcn f)
+  {
+    if (instance_ok ())
+      instance->do_set_quoting_function (f);
+  }
 
-void
-command_editor::reset_current_command_number (int n)
-{
-  if (instance_ok ())
-    instance->command_number = n;
-}
+  void
+  command_editor::set_dequoting_function (dequoting_fcn f)
+  {
+    if (instance_ok ())
+      instance->do_set_dequoting_function (f);
+  }
 
-void
-command_editor::increment_current_command_number (void)
-{
-  if (instance_ok ())
-    instance->command_number++;
-}
+  void
+  command_editor::set_char_is_quoted_function (char_is_quoted_fcn f)
+  {
+    if (instance_ok ())
+      instance->do_set_char_is_quoted_function (f);
+  }
 
-void
-command_editor::restore_terminal_state (void)
-{
-  if (instance_ok ())
-    instance->do_restore_terminal_state ();
-}
+  void
+  command_editor::set_user_accept_line_function (user_accept_line_fcn f)
+  {
+    if (instance_ok ())
+      instance->do_set_user_accept_line_function (f);
+  }
 
-void
-command_editor::blink_matching_paren (bool flag)
-{
-  if (instance_ok ())
-    instance->do_blink_matching_paren (flag);
-}
+  command_editor::completion_fcn
+  command_editor::get_completion_function (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_completion_function () : 0;
+  }
 
-bool
-command_editor::erase_empty_line (bool flag)
-{
-  return instance_ok () ? instance->do_erase_empty_line (flag) : false;
-}
+  command_editor::quoting_fcn
+  command_editor::get_quoting_function (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_quoting_function () : 0;
+  }
 
-void
-command_editor::set_basic_word_break_characters (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_basic_word_break_characters (s);
-}
+  command_editor::dequoting_fcn
+  command_editor::get_dequoting_function (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_dequoting_function () : 0;
+  }
 
-void
-command_editor::set_completer_word_break_characters (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_completer_word_break_characters (s);
-}
+  command_editor::char_is_quoted_fcn
+  command_editor::get_char_is_quoted_function (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_char_is_quoted_function () : 0;
+  }
 
-void
-command_editor::set_basic_quote_characters (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_basic_quote_characters (s);
-}
+  command_editor::user_accept_line_fcn
+  command_editor::get_user_accept_line_function (void)
+  {
+    return (instance_ok ())
+           ? instance->do_get_user_accept_line_function () : 0;
+  }
 
-void
-command_editor::set_filename_quote_characters (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_filename_quote_characters (s);
-}
+  string_vector
+  command_editor::generate_filename_completions (const std::string& text)
+  {
+    return (instance_ok ())
+           ? instance->do_generate_filename_completions (text) : string_vector ();
+  }
 
-void
-command_editor::set_completer_quote_characters (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_completer_quote_characters (s);
-}
+  std::string
+  command_editor::get_line_buffer (void)
+  {
+    return (instance_ok ()) ? instance->do_get_line_buffer () : "";
+  }
 
-void
-command_editor::set_completion_append_character (char c)
-{
-  if (instance_ok ())
-    instance->do_set_completion_append_character (c);
-}
+  std::string
+  command_editor::get_current_line (void)
+  {
+    return (instance_ok ()) ? instance->do_get_current_line () : "";
+  }
 
-void
-command_editor::set_completion_function (completion_fcn f)
-{
-  if (instance_ok ())
-    instance->do_set_completion_function (f);
-}
+  void
+  command_editor::replace_line (const std::string& text, bool clear_undo)
+  {
+    if (instance_ok ())
+      instance->do_replace_line (text, clear_undo);
+  }
+
+  void
+  command_editor::kill_full_line (void)
+  {
+    if (instance_ok ())
+      instance->do_kill_full_line ();
+  }
 
-void
-command_editor::set_quoting_function (quoting_fcn f)
-{
-  if (instance_ok ())
-    instance->do_set_quoting_function (f);
-}
+  void
+  command_editor::insert_text (const std::string& text)
+  {
+    if (instance_ok ())
+      instance->do_insert_text (text);
+  }
 
-void
-command_editor::set_dequoting_function (dequoting_fcn f)
-{
-  if (instance_ok ())
-    instance->do_set_dequoting_function (f);
-}
+  void
+  command_editor::newline (void)
+  {
+    if (instance_ok ())
+      instance->do_newline ();
+  }
 
-void
-command_editor::set_char_is_quoted_function (char_is_quoted_fcn f)
-{
-  if (instance_ok ())
-    instance->do_set_char_is_quoted_function (f);
-}
+  void
+  command_editor::accept_line (void)
+  {
+    if (instance_ok ())
+      instance->do_accept_line ();
+  }
+
+  bool
+  command_editor::undo (void)
+  {
+    return instance_ok () ? instance->do_undo () : false;
+  }
 
-void
-command_editor::set_user_accept_line_function (user_accept_line_fcn f)
-{
-  if (instance_ok ())
-    instance->do_set_user_accept_line_function (f);
-}
+  void
+  command_editor::clear_undo_list (void)
+  {
+    if (instance_ok ())
+      instance->do_clear_undo_list ();
+  }
 
-command_editor::completion_fcn
-command_editor::get_completion_function (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_completion_function () : 0;
-}
+  void
+  command_editor::add_startup_hook (startup_hook_fcn f)
+  {
+    if (instance_ok ())
+      {
+        startup_hook_set.insert (f);
 
-command_editor::quoting_fcn
-command_editor::get_quoting_function (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_quoting_function () : 0;
-}
+        instance->set_startup_hook (startup_handler);
+      }
+  }
 
-command_editor::dequoting_fcn
-command_editor::get_dequoting_function (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_dequoting_function () : 0;
-}
+  void
+  command_editor::remove_startup_hook (startup_hook_fcn f)
+  {
+    if (instance_ok ())
+      {
+        startup_hook_set_iterator p = startup_hook_set.find (f);
+
+        if (p != startup_hook_set.end ())
+          startup_hook_set.erase (p);
+
+        if (startup_hook_set.empty ())
+          instance->restore_startup_hook ();
+      }
+  }
 
-command_editor::char_is_quoted_fcn
-command_editor::get_char_is_quoted_function (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_char_is_quoted_function () : 0;
-}
+  void
+  command_editor::add_pre_input_hook (pre_input_hook_fcn f)
+  {
+    if (instance_ok ())
+      {
+        pre_input_hook_set.insert (f);
+
+        instance->set_pre_input_hook (pre_input_handler);
+      }
+  }
 
-command_editor::user_accept_line_fcn
-command_editor::get_user_accept_line_function (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_user_accept_line_function () : 0;
-}
+  void
+  command_editor::remove_pre_input_hook (pre_input_hook_fcn f)
+  {
+    if (instance_ok ())
+      {
+        pre_input_hook_set_iterator p = pre_input_hook_set.find (f);
 
-string_vector
-command_editor::generate_filename_completions (const std::string& text)
-{
-  return (instance_ok ())
-         ? instance->do_generate_filename_completions (text) : string_vector ();
-}
+        if (p != pre_input_hook_set.end ())
+          pre_input_hook_set.erase (p);
+
+        if (pre_input_hook_set.empty ())
+          instance->restore_pre_input_hook ();
+      }
+  }
 
-std::string
-command_editor::get_line_buffer (void)
-{
-  return (instance_ok ()) ? instance->do_get_line_buffer () : "";
-}
+  void
+  command_editor::add_event_hook (event_hook_fcn f)
+  {
+    octave_autolock guard (event_hook_lock);
 
-std::string
-command_editor::get_current_line (void)
-{
-  return (instance_ok ()) ? instance->do_get_current_line () : "";
-}
+    if (instance_ok ())
+      {
+        event_hook_set.insert (f);
+
+        instance->set_event_hook (event_handler);
+      }
+  }
 
-void
-command_editor::replace_line (const std::string& text, bool clear_undo)
-{
-  if (instance_ok ())
-    instance->do_replace_line (text, clear_undo);
-}
+  void
+  command_editor::remove_event_hook (event_hook_fcn f)
+  {
+    octave_autolock guard (event_hook_lock);
 
-void
-command_editor::kill_full_line (void)
-{
-  if (instance_ok ())
-    instance->do_kill_full_line ();
-}
+    if (instance_ok ())
+      {
+        event_hook_set_iterator p = event_hook_set.find (f);
+
+        if (p != event_hook_set.end ())
+          event_hook_set.erase (p);
+
+        if (event_hook_set.empty ())
+          instance->restore_event_hook ();
+      }
+  }
 
-void
-command_editor::insert_text (const std::string& text)
-{
-  if (instance_ok ())
-    instance->do_insert_text (text);
-}
+  void
+  command_editor::run_event_hooks (void)
+  {
+    event_handler ();
+  }
+
+  void
+  command_editor::read_init_file (const std::string& file_arg)
+  {
+    if (instance_ok ())
+      {
+        std::string file = octave::sys::file_ops::tilde_expand (file_arg);
 
-void
-command_editor::newline (void)
-{
-  if (instance_ok ())
-    instance->do_newline ();
-}
+        instance->do_read_init_file (file);
+      }
+  }
 
-void
-command_editor::accept_line (void)
-{
-  if (instance_ok ())
-    instance->do_accept_line ();
-}
+  void
+  command_editor::re_read_init_file (void)
+  {
+    if (instance_ok ())
+      instance->do_re_read_init_file ();
+  }
+
+  bool
+  command_editor::filename_completion_desired (bool arg)
+  {
+    return (instance_ok ())
+           ? instance->do_filename_completion_desired (arg) : false;
+  }
 
-bool
-command_editor::undo (void)
-{
-  return instance_ok () ? instance->do_undo () : false;
-}
+  bool
+  command_editor::filename_quoting_desired (bool arg)
+  {
+    return (instance_ok ())
+           ? instance->do_filename_quoting_desired (arg) : false;
+  }
 
-void
-command_editor::clear_undo_list (void)
-{
-  if (instance_ok ())
-    instance->do_clear_undo_list ();
-}
+  bool
+  command_editor::prefer_env_winsize (bool arg)
+  {
+    return (instance_ok ())
+           ? instance->do_prefer_env_winsize (arg) : false;
+  }
 
-void
-command_editor::add_startup_hook (startup_hook_fcn f)
-{
-  if (instance_ok ())
-    {
-      startup_hook_set.insert (f);
+  bool
+  command_editor::interrupt (bool arg)
+  {
+    bool retval;
+
+    if (instance_ok ())
+      {
+        // Return the current interrupt state.
+        retval = instance->interrupted;
 
-      instance->set_startup_hook (startup_handler);
-    }
-}
+        instance->do_interrupt (arg);
 
-void
-command_editor::remove_startup_hook (startup_hook_fcn f)
-{
-  if (instance_ok ())
-    {
-      startup_hook_set_iterator p = startup_hook_set.find (f);
+        instance->interrupted = arg;
+      }
+    else
+      retval = false;
+
+    return retval;
+  }
 
-      if (p != startup_hook_set.end ())
-        startup_hook_set.erase (p);
-
-      if (startup_hook_set.empty ())
-        instance->restore_startup_hook ();
-    }
-}
-
-void
-command_editor::add_pre_input_hook (pre_input_hook_fcn f)
-{
-  if (instance_ok ())
-    {
-      pre_input_hook_set.insert (f);
-
-      instance->set_pre_input_hook (pre_input_handler);
-    }
-}
+  // Return a string which will be printed as a prompt.  The string may
+  // contain special characters which are decoded as follows:
+  //
+  //      \a      bell (ascii 07)
+  //      \d      the date
+  //      \e      escape (ascii 033)
+  //      \h      the hostname up to the first '.'
+  //      \H      the hostname
+  //      \n      CRLF
+  //      \r      CR
+  //      \s      the name of the shell (program)
+  //      \t      the time
+  //      \T      the time in 12-hour hh:mm:ss format
+  //      \@      the time in 12-hour hh:mm am/pm format
+  //      \A      the time in 24-hour hh:mm format
+  //      \u      your username
+  //      \w      the current working directory
+  //      \W      the last element of PWD
+  //      \!      the history number of this command
+  //      \#      the command number of this command
+  //      \$      a $ or a # if you are root
+  //      \nnn    character code nnn in octal
+  //      \\      a backslash
+  //      \[      begin a sequence of non-printing chars
+  //      \]      end a sequence of non-printing chars
 
-void
-command_editor::remove_pre_input_hook (pre_input_hook_fcn f)
-{
-  if (instance_ok ())
-    {
-      pre_input_hook_set_iterator p = pre_input_hook_set.find (f);
+  std::string
+  command_editor::do_decode_prompt_string (const std::string& s)
+  {
+    std::string retval;
+    std::string tmpstr;
+    size_t i = 0;
+    size_t slen = s.length ();
+    int c;
 
-      if (p != pre_input_hook_set.end ())
-        pre_input_hook_set.erase (p);
+    while (i < slen)
+      {
+        c = s[i];
+
+        i++;
 
-      if (pre_input_hook_set.empty ())
-        instance->restore_pre_input_hook ();
-    }
-}
+        if (c == '\\')
+          {
+            c = s[i];
 
-void
-command_editor::add_event_hook (event_hook_fcn f)
-{
-  octave_autolock guard (event_hook_lock);
+            switch (c)
+              {
+              case '0':
+              case '1':
+              case '2':
+              case '3':
+              case '4':
+              case '5':
+              case '6':
+              case '7':
+                // Maybe convert an octal number.
+                {
+                  int n = read_octal (s.substr (i, 3));
 
-  if (instance_ok ())
-    {
-      event_hook_set.insert (f);
-
-      instance->set_event_hook (event_handler);
-    }
-}
+                  tmpstr = "\\";
 
-void
-command_editor::remove_event_hook (event_hook_fcn f)
-{
-  octave_autolock guard (event_hook_lock);
+                  if (n != -1)
+                    {
+                      tmpstr[0] = n;
+                      i += 2;   // i++ makes this += 3 later
+                    }
 
-  if (instance_ok ())
-    {
-      event_hook_set_iterator p = event_hook_set.find (f);
+                  break;
+                }
 
-      if (p != event_hook_set.end ())
-        event_hook_set.erase (p);
+              case 'a':
+                {
+                  tmpstr = '\a';
+
+                  break;
+                }
 
-      if (event_hook_set.empty ())
-        instance->restore_event_hook ();
-    }
-}
-
-void
-command_editor::run_event_hooks (void)
-{
-  event_handler ();
-}
+              case 'd':
+              case 't':
+              case 'T':
+              case '@':
+              case 'A':
+                // Make the current time/date into a string.
+                {
+                  octave::sys::localtime now;
 
-void
-command_editor::read_init_file (const std::string& file_arg)
-{
-  if (instance_ok ())
-    {
-      std::string file = octave::sys::file_ops::tilde_expand (file_arg);
+                  if (c == 'd')
+                    tmpstr = now.strftime ("%a %b %d");
+                  else if (c == 't')
+                    tmpstr = now.strftime ("%H:%M:%S");
+                  else if (c == 'T')
+                    tmpstr = now.strftime ("%I:%M:%S");
+                  else if (c == '@')
+                    tmpstr = now.strftime ("%I:%M %p");
+                  else if (c == 'A')
+                    tmpstr = now.strftime ("%H:%M");
 
-      instance->do_read_init_file (file);
-    }
-}
+                  break;
+                }
+
+              case 'e':
+                {
+                  tmpstr = '\033';
 
-void
-command_editor::re_read_init_file (void)
-{
-  if (instance_ok ())
-    instance->do_re_read_init_file ();
-}
+                  break;
+                }
+
+              case 'h':
+                {
+                  tmpstr = octave::sys::env::get_host_name ();
+
+                  size_t pos = tmpstr.find ('.');
 
-bool
-command_editor::filename_completion_desired (bool arg)
-{
-  return (instance_ok ())
-         ? instance->do_filename_completion_desired (arg) : false;
-}
+                  if (pos != std::string::npos)
+                    tmpstr.resize (pos);
+
+                  break;
+                }
+
+              case 'H':
+                {
+                  tmpstr = octave::sys::env::get_host_name ();
 
-bool
-command_editor::filename_quoting_desired (bool arg)
-{
-  return (instance_ok ())
-         ? instance->do_filename_quoting_desired (arg) : false;
-}
+                  break;
+                }
+
+              case 'n':
+                {
+                  tmpstr = newline_chars ();
+
+                  break;
+                }
+
+              case 'r':
+                {
+                  tmpstr = '\r';
 
-bool
-command_editor::prefer_env_winsize (bool arg)
-{
-  return (instance_ok ())
-         ? instance->do_prefer_env_winsize (arg) : false;
-}
+                  break;
+                }
+
+              case 's':
+                {
+                  tmpstr = octave::sys::env::get_program_name ();
+                  tmpstr = octave::sys::env::base_pathname (tmpstr);
+
+                  break;
+                }
+
+              case 'u':
+                {
+                  tmpstr = octave::sys::env::get_user_name ();
 
-bool
-command_editor::interrupt (bool arg)
-{
-  bool retval;
+                  break;
+                }
 
-  if (instance_ok ())
-    {
-      // Return the current interrupt state.
-      retval = instance->interrupted;
+              case 'w':
+              case 'W':
+                {
+                  try
+                    {
+                      tmpstr = octave::sys::env::get_current_directory ();
+                    }
+                  catch (const octave_execution_exception&)
+                    {
+                      tmpstr = "";
+                    }
 
-      instance->do_interrupt (arg);
+                  std::string home_dir = octave::sys::env::get_home_directory ();
+
+                  if (c == 'W' && (home_dir.empty () || tmpstr != home_dir))
+                    {
+                      if (tmpstr != "/" && tmpstr != "//")
+                        {
+                          size_t pos = tmpstr.rfind ('/');
 
-      instance->interrupted = arg;
-    }
-  else
-    retval = false;
+                          if (pos != std::string::npos && pos != 0)
+                            tmpstr = tmpstr.substr (pos + 1);
+                        }
+                    }
+                  else
+                    tmpstr = octave::sys::env::polite_directory_format (tmpstr);
 
-  return retval;
-}
+                  break;
+                }
 
-// Return a string which will be printed as a prompt.  The string may
-// contain special characters which are decoded as follows:
-//
-//      \a      bell (ascii 07)
-//      \d      the date
-//      \e      escape (ascii 033)
-//      \h      the hostname up to the first '.'
-//      \H      the hostname
-//      \n      CRLF
-//      \r      CR
-//      \s      the name of the shell (program)
-//      \t      the time
-//      \T      the time in 12-hour hh:mm:ss format
-//      \@      the time in 12-hour hh:mm am/pm format
-//      \A      the time in 24-hour hh:mm format
-//      \u      your username
-//      \w      the current working directory
-//      \W      the last element of PWD
-//      \!      the history number of this command
-//      \#      the command number of this command
-//      \$      a $ or a # if you are root
-//      \nnn    character code nnn in octal
-//      \\      a backslash
-//      \[      begin a sequence of non-printing chars
-//      \]      end a sequence of non-printing chars
+              case '!':
+                {
+                  char number_buffer[32];
+                  int num = command_history::current_number ();
+                  if (num > 0)
+                    sprintf (number_buffer, "%d", num);
+                  else
+                    strcpy (number_buffer, "!");
+                  tmpstr = number_buffer;
+
+                  break;
+                }
+
+              case '#':
+                {
+                  char number_buffer[32];
+                  sprintf (number_buffer, "%d", command_number);
+                  tmpstr = number_buffer;
+
+                  break;
+                }
+
+              case '$':
+                {
+#if defined (HAVE_GETEUID)
+                  tmpstr = (::geteuid () == 0 ? '#' : '$');
+#else
+                  tmpstr = '$';
+#endif
 
-std::string
-command_editor::do_decode_prompt_string (const std::string& s)
-{
-  std::string retval;
-  std::string tmpstr;
-  size_t i = 0;
-  size_t slen = s.length ();
-  int c;
+                  break;
+                }
 
-  while (i < slen)
-    {
-      c = s[i];
+#if defined (USE_READLINE)
+              case '[':
+              case ']':
+                {
+                  tmpstr.resize (1);
 
-      i++;
-
-      if (c == '\\')
-        {
-          c = s[i];
+                  tmpstr[0] = ((c == '[')
+                               ? ::octave_rl_prompt_start_ignore ()
+                               : ::octave_rl_prompt_end_ignore ());
 
-          switch (c)
-            {
-            case '0':
-            case '1':
-            case '2':
-            case '3':
-            case '4':
-            case '5':
-            case '6':
-            case '7':
-              // Maybe convert an octal number.
-              {
-                int n = read_octal (s.substr (i, 3));
+                  break;
+                }
+#endif
+
+              case '\\':
+                {
+                  tmpstr = "\\";
 
-                tmpstr = "\\";
+                  break;
+                }
 
-                if (n != -1)
-                  {
-                    tmpstr[0] = n;
-                    i += 2;   // i++ makes this += 3 later
-                  }
+              default:
+                {
+                  tmpstr = "\\ ";
+                  tmpstr[1] = c;
 
-                break;
+                  break;
+                }
               }
 
-            case 'a':
-              {
-                tmpstr = '\a';
-
-                break;
-              }
-
-            case 'd':
-            case 't':
-            case 'T':
-            case '@':
-            case 'A':
-              // Make the current time/date into a string.
-              {
-                octave::sys::localtime now;
-
-                if (c == 'd')
-                  tmpstr = now.strftime ("%a %b %d");
-                else if (c == 't')
-                  tmpstr = now.strftime ("%H:%M:%S");
-                else if (c == 'T')
-                  tmpstr = now.strftime ("%I:%M:%S");
-                else if (c == '@')
-                  tmpstr = now.strftime ("%I:%M %p");
-                else if (c == 'A')
-                  tmpstr = now.strftime ("%H:%M");
+            retval.append (tmpstr);
+            i++;   // Move past processed escape character
+          }
+        else
+          retval += c;
+      }
 
-                break;
-              }
-
-            case 'e':
-              {
-                tmpstr = '\033';
-
-                break;
-              }
-
-            case 'h':
-              {
-                tmpstr = octave::sys::env::get_host_name ();
-
-                size_t pos = tmpstr.find ('.');
-
-                if (pos != std::string::npos)
-                  tmpstr.resize (pos);
-
-                break;
-              }
-
-            case 'H':
-              {
-                tmpstr = octave::sys::env::get_host_name ();
-
-                break;
-              }
+    return retval;
+  }
 
-            case 'n':
-              {
-                tmpstr = newline_chars ();
-
-                break;
-              }
-
-            case 'r':
-              {
-                tmpstr = '\r';
-
-                break;
-              }
+  int
+  command_editor::do_insert_initial_input (void)
+  {
+    std::string input = initial_input;
 
-            case 's':
-              {
-                tmpstr = octave::sys::env::get_program_name ();
-                tmpstr = octave::sys::env::base_pathname (tmpstr);
+    initial_input = "";
 
-                break;
-              }
-
-            case 'u':
-              {
-                tmpstr = octave::sys::env::get_user_name ();
-
-                break;
-              }
+    do_insert_text (input);
 
-            case 'w':
-            case 'W':
-              {
-                try
-                  {
-                    tmpstr = octave::sys::env::get_current_directory ();
-                  }
-                catch (const octave_execution_exception&)
-                  {
-                    tmpstr = "";
-                  }
-
-                std::string home_dir = octave::sys::env::get_home_directory ();
+    // Is it really right to redisplay here?
+    do_redisplay ();
 
-                if (c == 'W' && (home_dir.empty () || tmpstr != home_dir))
-                  {
-                    if (tmpstr != "/" && tmpstr != "//")
-                      {
-                        size_t pos = tmpstr.rfind ('/');
+    return 0;
+  }
 
-                        if (pos != std::string::npos && pos != 0)
-                          tmpstr = tmpstr.substr (pos + 1);
-                      }
-                  }
-                else
-                  tmpstr = octave::sys::env::polite_directory_format (tmpstr);
-
-                break;
-              }
+  // Return the octal number parsed from STRING, or -1 to indicate that
+  // the string contained a bad number.
 
-            case '!':
-              {
-                char number_buffer[32];
-                int num = command_history::current_number ();
-                if (num > 0)
-                  sprintf (number_buffer, "%d", num);
-                else
-                  strcpy (number_buffer, "!");
-                tmpstr = number_buffer;
-
-                break;
-              }
-
-            case '#':
-              {
-                char number_buffer[32];
-                sprintf (number_buffer, "%d", command_number);
-                tmpstr = number_buffer;
-
-                break;
-              }
+  int
+  command_editor::read_octal (const std::string& s)
+  {
+    int result = 0;
+    int digits = 0;
 
-            case '$':
-              {
-#if defined (HAVE_GETEUID)
-                tmpstr = (::geteuid () == 0 ? '#' : '$');
-#else
-                tmpstr = '$';
-#endif
-
-                break;
-              }
-
-#if defined (USE_READLINE)
-            case '[':
-            case ']':
-              {
-                tmpstr.resize (1);
+    size_t i = 0;
+    size_t slen = s.length ();
 
-                tmpstr[0] = ((c == '[')
-                             ? ::octave_rl_prompt_start_ignore ()
-                             : ::octave_rl_prompt_end_ignore ());
-
-                break;
-              }
-#endif
-
-            case '\\':
-              {
-                tmpstr = "\\";
-
-                break;
-              }
-
-            default:
-              {
-                tmpstr = "\\ ";
-                tmpstr[1] = c;
+    while (i < slen && s[i] >= '0' && s[i] < '8')
+      {
+        digits++;
+        result = (result * 8) + s[i] - '0';
+        i++;
+      }
 
-                break;
-              }
-            }
-
-          retval.append (tmpstr);
-          i++;   // Move past processed escape character
-        }
-      else
-        retval += c;
-    }
-
-  return retval;
-}
+    if (! digits || result > 0777 || i < slen)
+      result = -1;
 
-int
-command_editor::do_insert_initial_input (void)
-{
-  std::string input = initial_input;
-
-  initial_input = "";
-
-  do_insert_text (input);
-
-  // Is it really right to redisplay here?
-  do_redisplay ();
-
-  return 0;
-}
-
-// Return the octal number parsed from STRING, or -1 to indicate that
-// the string contained a bad number.
+    return result;
+  }
 
-int
-command_editor::read_octal (const std::string& s)
-{
-  int result = 0;
-  int digits = 0;
-
-  size_t i = 0;
-  size_t slen = s.length ();
-
-  while (i < slen && s[i] >= '0' && s[i] < '8')
-    {
-      digits++;
-      result = (result * 8) + s[i] - '0';
-      i++;
-    }
+  void
+  command_editor::error (int err_num)
+  {
+    (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+  }
 
-  if (! digits || result > 0777 || i < slen)
-    result = -1;
-
-  return result;
+  void
+  command_editor::error (const std::string& s)
+  {
+    (*current_liboctave_error_handler) ("%s", s.c_str ());
+  }
 }
-
-void
-command_editor::error (int err_num)
-{
-  (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
-}
-
-void
-command_editor::error (const std::string& s)
-{
-  (*current_liboctave_error_handler) ("%s", s.c_str ());
-}
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -27,342 +27,352 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include <set>
 #include <string>
 
 #include "str-vec.h"
 
-class
-OCTAVE_API
-command_editor
+namespace octave
 {
-protected:
-
-  command_editor (void)
-    : command_number (0), interrupted (false), initial_input () { }
+  class
+  OCTAVE_API
+  command_editor
+  {
+  protected:
 
-public:
+    command_editor (void)
+      : command_number (0), interrupted (false), initial_input () { }
 
-  typedef int (*startup_hook_fcn) (void);
+  public:
 
-  typedef int (*pre_input_hook_fcn) (void);
+    typedef int (*startup_hook_fcn) (void);
 
-  typedef int (*event_hook_fcn) (void);
+    typedef int (*pre_input_hook_fcn) (void);
 
-  typedef std::string (*completion_fcn) (const std::string&, int);
+    typedef int (*event_hook_fcn) (void);
 
-  typedef std::string (*quoting_fcn) (const std::string&, int, char);
+    typedef std::string (*completion_fcn) (const std::string&, int);
 
-  typedef std::string (*dequoting_fcn) (const std::string&, int);
+    typedef std::string (*quoting_fcn) (const std::string&, int, char);
 
-  typedef int (*char_is_quoted_fcn) (const std::string&, int);
+    typedef std::string (*dequoting_fcn) (const std::string&, int);
 
-  typedef void (*user_accept_line_fcn) (const std::string&);
+    typedef int (*char_is_quoted_fcn) (const std::string&, int);
 
-  virtual ~command_editor (void) { }
+    typedef void (*user_accept_line_fcn) (const std::string&);
 
-  static void set_name (const std::string& n);
+    virtual ~command_editor (void) { }
 
-  static std::string readline (const std::string& prompt);
+    static void set_name (const std::string& n);
+
+    static std::string readline (const std::string& prompt);
 
-  static std::string readline (const std::string& prompt, bool& eof);
+    static std::string readline (const std::string& prompt, bool& eof);
 
-  static void set_input_stream (FILE *f);
+    static void set_input_stream (FILE *f);
 
-  static FILE *get_input_stream (void);
+    static FILE *get_input_stream (void);
 
-  static void set_output_stream (FILE *f);
+    static void set_output_stream (FILE *f);
 
-  static FILE *get_output_stream (void);
+    static FILE *get_output_stream (void);
 
-  static void redisplay (void);
+    static void redisplay (void);
 
-  static int terminal_rows (void);
+    static int terminal_rows (void);
 
-  static int terminal_cols (void);
+    static int terminal_cols (void);
 
-  static void clear_screen (bool skip_redisplay = false);
+    static void clear_screen (bool skip_redisplay = false);
 
-  static void resize_terminal (void);
+    static void resize_terminal (void);
 
-  static void set_screen_size (int ht, int wd);
+    static void set_screen_size (int ht, int wd);
 
-  static std::string decode_prompt_string (const std::string& s);
+    static std::string decode_prompt_string (const std::string& s);
 
-  static void restore_terminal_state (void);
+    static void restore_terminal_state (void);
 
-  static void blink_matching_paren (bool flag);
+    static void blink_matching_paren (bool flag);
 
-  static bool erase_empty_line (bool flag);
+    static bool erase_empty_line (bool flag);
 
-  static void set_basic_word_break_characters (const std::string& s);
+    static void set_basic_word_break_characters (const std::string& s);
 
-  static void set_completer_word_break_characters (const std::string& s);
+    static void set_completer_word_break_characters (const std::string& s);
 
-  static void set_basic_quote_characters (const std::string& s);
+    static void set_basic_quote_characters (const std::string& s);
 
-  static void set_filename_quote_characters (const std::string& s);
+    static void set_filename_quote_characters (const std::string& s);
 
-  static void set_completer_quote_characters (const std::string& s);
+    static void set_completer_quote_characters (const std::string& s);
 
-  static void set_completion_append_character (char c);
+    static void set_completion_append_character (char c);
 
-  static void set_completion_function (completion_fcn f);
+    static void set_completion_function (completion_fcn f);
 
-  static void set_quoting_function (quoting_fcn f);
+    static void set_quoting_function (quoting_fcn f);
 
-  static void set_dequoting_function (dequoting_fcn f);
+    static void set_dequoting_function (dequoting_fcn f);
 
-  static void set_char_is_quoted_function (char_is_quoted_fcn f);
+    static void set_char_is_quoted_function (char_is_quoted_fcn f);
 
-  static void set_user_accept_line_function (user_accept_line_fcn f);
+    static void set_user_accept_line_function (user_accept_line_fcn f);
 
-  static completion_fcn get_completion_function (void);
+    static completion_fcn get_completion_function (void);
 
-  static quoting_fcn get_quoting_function (void);
+    static quoting_fcn get_quoting_function (void);
 
-  static dequoting_fcn get_dequoting_function (void);
+    static dequoting_fcn get_dequoting_function (void);
 
-  static char_is_quoted_fcn get_char_is_quoted_function (void);
+    static char_is_quoted_fcn get_char_is_quoted_function (void);
 
-  static user_accept_line_fcn get_user_accept_line_function (void);
+    static user_accept_line_fcn get_user_accept_line_function (void);
 
-  static string_vector generate_filename_completions (const std::string& text);
+    static string_vector generate_filename_completions (const std::string& text);
 
-  static std::string get_line_buffer (void);
+    static std::string get_line_buffer (void);
 
-  static std::string get_current_line (void);
+    static std::string get_current_line (void);
 
-  static void replace_line (const std::string& text, bool clear_undo = true);
+    static void replace_line (const std::string& text, bool clear_undo = true);
 
-  static void kill_full_line (void);
+    static void kill_full_line (void);
 
-  static void insert_text (const std::string& text);
+    static void insert_text (const std::string& text);
 
-  static void newline (void);
+    static void newline (void);
 
-  static void accept_line (void);
+    static void accept_line (void);
 
-  static bool undo (void);
+    static bool undo (void);
 
-  static void clear_undo_list (void);
+    static void clear_undo_list (void);
 
-  static void add_startup_hook (startup_hook_fcn f);
+    static void add_startup_hook (startup_hook_fcn f);
 
-  static void remove_startup_hook (startup_hook_fcn f);
+    static void remove_startup_hook (startup_hook_fcn f);
 
-  static void add_pre_input_hook (pre_input_hook_fcn f);
+    static void add_pre_input_hook (pre_input_hook_fcn f);
 
-  static void remove_pre_input_hook (pre_input_hook_fcn f);
+    static void remove_pre_input_hook (pre_input_hook_fcn f);
 
-  static void add_event_hook (event_hook_fcn f);
+    static void add_event_hook (event_hook_fcn f);
 
-  static void remove_event_hook (event_hook_fcn f);
+    static void remove_event_hook (event_hook_fcn f);
 
-  static void run_event_hooks (void);
+    static void run_event_hooks (void);
 
-  static void read_init_file (const std::string& file = "");
+    static void read_init_file (const std::string& file = "");
 
-  static void re_read_init_file (void);
+    static void re_read_init_file (void);
 
-  static bool filename_completion_desired (bool);
+    static bool filename_completion_desired (bool);
 
-  static bool filename_quoting_desired (bool);
+    static bool filename_quoting_desired (bool);
+
+    static bool prefer_env_winsize (bool);
 
-  static bool prefer_env_winsize (bool);
+    static bool interrupt (bool = true);
 
-  static bool interrupt (bool = true);
+    static int current_command_number (void);
 
-  static int current_command_number (void);
+    static void reset_current_command_number (int n);
 
-  static void reset_current_command_number (int n);
+    static void increment_current_command_number (void);
 
-  static void increment_current_command_number (void);
+    static void force_default_editor (void);
 
-  static void force_default_editor (void);
+    static void set_initial_input (const std::string& text);
 
-  static void set_initial_input (const std::string& text);
+    static int insert_initial_input (void);
 
-  static int insert_initial_input (void);
+  private:
 
-private:
+    // No copying!
 
-  // No copying!
+    command_editor (const command_editor&);
 
-  command_editor (const command_editor&);
+    command_editor& operator = (const command_editor&);
 
-  command_editor& operator = (const command_editor&);
+    static bool instance_ok (void);
 
-  static bool instance_ok (void);
+    static void make_command_editor (void);
 
-  static void make_command_editor (void);
+    static int startup_handler (void);
 
-  static int startup_handler (void);
+    static int pre_input_handler (void);
 
-  static int pre_input_handler (void);
+    static int event_handler (void);
 
-  static int event_handler (void);
+    static std::set<startup_hook_fcn> startup_hook_set;
 
-  static std::set<startup_hook_fcn> startup_hook_set;
+    static std::set<pre_input_hook_fcn> pre_input_hook_set;
 
-  static std::set<pre_input_hook_fcn> pre_input_hook_set;
+    static std::set<event_hook_fcn> event_hook_set;
 
-  static std::set<event_hook_fcn> event_hook_set;
+    typedef std::set<startup_hook_fcn>::iterator startup_hook_set_iterator;
+    typedef std::set<startup_hook_fcn>::const_iterator startup_hook_set_const_iterator;
 
-  typedef std::set<startup_hook_fcn>::iterator startup_hook_set_iterator;
-  typedef std::set<startup_hook_fcn>::const_iterator startup_hook_set_const_iterator;
+    typedef std::set<pre_input_hook_fcn>::iterator pre_input_hook_set_iterator;
+    typedef std::set<pre_input_hook_fcn>::const_iterator pre_input_hook_set_const_iterator;
 
-  typedef std::set<pre_input_hook_fcn>::iterator pre_input_hook_set_iterator;
-  typedef std::set<pre_input_hook_fcn>::const_iterator pre_input_hook_set_const_iterator;
+    typedef std::set<event_hook_fcn>::iterator event_hook_set_iterator;
+    typedef std::set<event_hook_fcn>::const_iterator event_hook_set_const_iterator;
 
-  typedef std::set<event_hook_fcn>::iterator event_hook_set_iterator;
-  typedef std::set<event_hook_fcn>::const_iterator event_hook_set_const_iterator;
+    // The real thing.
+    static command_editor *instance;
+
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  // The real thing.
-  static command_editor *instance;
+  protected:
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
-
-protected:
+    // To use something other than the GNU readline library, derive a new
+    // class from command_editor, overload these functions as
+    // necessary, and make instance point to the new class.
 
-  // To use something other than the GNU readline library, derive a new
-  // class from command_editor, overload these functions as
-  // necessary, and make instance point to the new class.
-
-  virtual void do_set_name (const std::string&) { }
+    virtual void do_set_name (const std::string&) { }
 
-  std::string do_readline (const std::string& prompt)
-  {
-    bool eof;
+    std::string do_readline (const std::string& prompt)
+    {
+      bool eof;
 
-    return do_readline (prompt, eof);
-  }
+      return do_readline (prompt, eof);
+    }
+
+    virtual std::string do_readline (const std::string&, bool&) = 0;
 
-  virtual std::string do_readline (const std::string&, bool&) = 0;
+    virtual void do_set_input_stream (FILE *) = 0;
 
-  virtual void do_set_input_stream (FILE *) = 0;
+    virtual FILE *do_get_input_stream (void) = 0;
 
-  virtual FILE *do_get_input_stream (void) = 0;
+    virtual void do_set_output_stream (FILE *) = 0;
 
-  virtual void do_set_output_stream (FILE *) = 0;
+    virtual FILE *do_get_output_stream (void) = 0;
 
-  virtual FILE *do_get_output_stream (void) = 0;
+    virtual void do_redisplay (void) { }
 
-  virtual void do_redisplay (void) { }
+    virtual int do_terminal_rows (void) { return 24; }
 
-  virtual int do_terminal_rows (void) { return 24; }
+    virtual int do_terminal_cols (void) { return 80; }
+
+    virtual void do_clear_screen (bool) { }
 
-  virtual int do_terminal_cols (void) { return 80; }
+    virtual void do_resize_terminal (void) { }
 
-  virtual void do_clear_screen (bool) { }
+    virtual void do_set_screen_size (int, int) { }
 
-  virtual void do_resize_terminal (void) { }
+    virtual std::string do_decode_prompt_string (const std::string&);
 
-  virtual void do_set_screen_size (int, int) { }
+    virtual std::string newline_chars (void) { return "\n"; }
 
-  virtual std::string do_decode_prompt_string (const std::string&);
+    virtual void do_restore_terminal_state (void) { }
 
-  virtual std::string newline_chars (void) { return "\n"; }
+    virtual void do_blink_matching_paren (bool) { }
 
-  virtual void do_restore_terminal_state (void) { }
+    virtual bool do_erase_empty_line (bool) { return false; }
 
-  virtual void do_blink_matching_paren (bool) { }
+    virtual void do_set_basic_word_break_characters (const std::string&) { }
 
-  virtual bool do_erase_empty_line (bool) { return false; }
+    virtual void do_set_completer_word_break_characters (const std::string&) { }
 
-  virtual void do_set_basic_word_break_characters (const std::string&) { }
+    virtual void do_set_basic_quote_characters (const std::string&) { }
 
-  virtual void do_set_completer_word_break_characters (const std::string&) { }
+    virtual void do_set_filename_quote_characters (const std::string&) { }
 
-  virtual void do_set_basic_quote_characters (const std::string&) { }
+    virtual void do_set_completer_quote_characters (const std::string&) { }
 
-  virtual void do_set_filename_quote_characters (const std::string&) { }
+    virtual void do_set_completion_append_character (char) { }
 
-  virtual void do_set_completer_quote_characters (const std::string&) { }
+    virtual void do_set_completion_function (completion_fcn) { }
 
-  virtual void do_set_completion_append_character (char) { }
+    virtual void do_set_quoting_function (quoting_fcn) { }
 
-  virtual void do_set_completion_function (completion_fcn) { }
+    virtual void do_set_dequoting_function (dequoting_fcn) { }
 
-  virtual void do_set_quoting_function (quoting_fcn) { }
+    virtual void do_set_char_is_quoted_function (char_is_quoted_fcn) { }
 
-  virtual void do_set_dequoting_function (dequoting_fcn) { }
+    virtual void do_set_user_accept_line_function (user_accept_line_fcn) { }
+
+    virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
-  virtual void do_set_char_is_quoted_function (char_is_quoted_fcn) { }
+    virtual quoting_fcn do_get_quoting_function (void) const { return 0; }
 
-  virtual void do_set_user_accept_line_function (user_accept_line_fcn) { }
+    virtual dequoting_fcn do_get_dequoting_function (void) const { return 0; }
 
-  virtual completion_fcn do_get_completion_function (void) const { return 0; }
+    virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const
+    { return 0; }
 
-  virtual quoting_fcn do_get_quoting_function (void) const { return 0; }
-
-  virtual dequoting_fcn do_get_dequoting_function (void) const { return 0; }
+    virtual user_accept_line_fcn do_get_user_accept_line_function (void) const
+    { return 0; }
 
-  virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const
-  { return 0; }
+    virtual string_vector
+      do_generate_filename_completions (const std::string& text) = 0;
+
+    virtual std::string do_get_line_buffer (void) const = 0;
 
-  virtual user_accept_line_fcn do_get_user_accept_line_function (void) const
-  { return 0; }
+    virtual std::string do_get_current_line (void) const = 0;
 
-  virtual string_vector
-  do_generate_filename_completions (const std::string& text) = 0;
+    virtual void do_replace_line (const std::string& text, bool clear_undo) = 0;
 
-  virtual std::string do_get_line_buffer (void) const = 0;
+    virtual void do_kill_full_line (void) = 0;
 
-  virtual std::string do_get_current_line (void) const = 0;
+    virtual void do_insert_text (const std::string& text) = 0;
 
-  virtual void do_replace_line (const std::string& text, bool clear_undo) = 0;
+    virtual void do_newline (void) = 0;
 
-  virtual void do_kill_full_line (void) = 0;
+    virtual void do_accept_line (void) = 0;
 
-  virtual void do_insert_text (const std::string& text) = 0;
+    virtual bool do_undo (void) { return false; }
 
-  virtual void do_newline (void) = 0;
+    virtual void do_clear_undo_list (void) { }
 
-  virtual void do_accept_line (void) = 0;
+    virtual void set_startup_hook (startup_hook_fcn) { }
 
-  virtual bool do_undo (void) { return false; }
+    virtual void restore_startup_hook (void) { }
 
-  virtual void do_clear_undo_list (void) { }
+    virtual void set_pre_input_hook (pre_input_hook_fcn) { }
 
-  virtual void set_startup_hook (startup_hook_fcn) { }
+    virtual void restore_pre_input_hook (void) { }
 
-  virtual void restore_startup_hook (void) { }
+    virtual void set_event_hook (event_hook_fcn) { }
 
-  virtual void set_pre_input_hook (pre_input_hook_fcn) { }
+    virtual void restore_event_hook (void) { }
 
-  virtual void restore_pre_input_hook (void) { }
+    virtual void do_read_init_file (const std::string&) { }
 
-  virtual void set_event_hook (event_hook_fcn) { }
+    virtual void do_re_read_init_file (void) { }
 
-  virtual void restore_event_hook (void) { }
+    virtual bool do_filename_completion_desired (bool) { return false; }
 
-  virtual void do_read_init_file (const std::string&) { }
+    virtual bool do_filename_quoting_desired (bool) { return false; }
 
-  virtual void do_re_read_init_file (void) { }
+    virtual bool do_prefer_env_winsize (bool) { return false; }
 
-  virtual bool do_filename_completion_desired (bool) { return false; }
+    virtual void do_interrupt (bool) { }
 
-  virtual bool do_filename_quoting_desired (bool) { return false; }
+    int do_insert_initial_input (void);
 
-  virtual bool do_prefer_env_winsize (bool) { return false; }
+    int read_octal (const std::string& s);
 
-  virtual void do_interrupt (bool) { }
+    void error (int);
 
-  int do_insert_initial_input (void);
+    void error (const std::string&);
 
-  int read_octal (const std::string& s);
+    // The current command number.
+    int command_number;
 
-  void error (int);
-
-  void error (const std::string&);
+    bool interrupted;
 
-  // The current command number.
-  int command_number;
+    std::string initial_input;
+  };
+}
 
-  bool interrupted;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  std::string initial_input;
-};
+OCTAVE_DEPRECATED ("use octave::command_editor instead")
+typedef octave::command_editor command_editor;
 
 #endif
+
+#endif
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -32,997 +32,1002 @@ along with Octave; see the file COPYING.
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
 
-command_history *command_history::instance = 0;
-
 #if defined (USE_READLINE)
-
 #include <cstdlib>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include <fcntl.h>
 
 #include "oct-rl-hist.h"
 
 #include "file-stat.h"
+#endif
 
-class
-gnu_history : public command_history
+namespace octave
 {
-public:
+  command_history *command_history::instance = 0;
 
-  gnu_history (void)
-    : command_history (), mark (0) { }
+#if defined (USE_READLINE)
 
-  ~gnu_history (void) { }
-
-  void do_process_histcontrol (const std::string&);
+  class
+  gnu_history : public command_history
+  {
+  public:
 
-  std::string do_histcontrol (void) const;
+    gnu_history (void)
+      : command_history (), mark (0) { }
 
-  bool do_add (const std::string&);
-
-  void do_remove (int);
+    ~gnu_history (void) { }
 
-  void do_clear (void);
+    void do_process_histcontrol (const std::string&);
 
-  int do_where (void) const;
+    std::string do_histcontrol (void) const;
 
-  int do_length (void) const;
+    bool do_add (const std::string&);
 
-  int do_max_input_history (void) const;
+    void do_remove (int);
 
-  int do_base (void) const;
+    void do_clear (void);
 
-  int do_current_number (void) const;
+    int do_where (void) const;
 
-  void do_stifle (int);
+    int do_length (void) const;
 
-  int do_unstifle (void);
+    int do_max_input_history (void) const;
 
-  int do_is_stifled (void) const;
+    int do_base (void) const;
 
-  void do_set_mark (int);
+    int do_current_number (void) const;
 
-  int do_goto_mark (void);
+    void do_stifle (int);
 
-  void do_read (const std::string&, bool);
+    int do_unstifle (void);
 
-  void do_read_range (const std::string&, int, int, bool);
+    int do_is_stifled (void) const;
 
-  void do_write (const std::string&) const;
+    void do_set_mark (int);
 
-  void do_append (const std::string&);
+    int do_goto_mark (void);
 
-  void do_truncate_file (const std::string&, int) const;
+    void do_read (const std::string&, bool);
 
-  string_vector do_list (int, bool) const;
+    void do_read_range (const std::string&, int, int, bool);
 
-  std::string do_get_entry (int) const;
+    void do_write (const std::string&) const;
 
-  void do_replace_entry (int, const std::string&);
+    void do_append (const std::string&);
 
-  void do_clean_up_and_save (const std::string&, int);
+    void do_truncate_file (const std::string&, int) const;
+
+    string_vector do_list (int, bool) const;
 
-private:
+    std::string do_get_entry (int) const;
 
-  int mark;
-};
+    void do_replace_entry (int, const std::string&);
+
+    void do_clean_up_and_save (const std::string&, int);
 
-void
-gnu_history::do_process_histcontrol (const std::string& control_arg)
-{
-  history_control = 0;
+  private:
 
-  size_t len = control_arg.length ();
-  size_t beg = 0;
+    int mark;
+  };
 
-  while (beg < len)
-    {
-      if (control_arg[beg] == ':')
-        beg++;
-      else
-        {
-          size_t end = control_arg.find (":", beg);
+  void
+  gnu_history::do_process_histcontrol (const std::string& control_arg)
+  {
+    history_control = 0;
+
+    size_t len = control_arg.length ();
+    size_t beg = 0;
 
-          if (end == std::string::npos)
-            end = len;
+    while (beg < len)
+      {
+        if (control_arg[beg] == ':')
+          beg++;
+        else
+          {
+            size_t end = control_arg.find (":", beg);
 
-          std::string tmp = control_arg.substr (beg, end-beg);
+            if (end == std::string::npos)
+              end = len;
+
+            std::string tmp = control_arg.substr (beg, end-beg);
 
-          if (tmp == "erasedups")
-            history_control |= HC_ERASEDUPS;
-          else if (tmp == "ignoreboth")
-            history_control |= (HC_IGNDUPS | HC_IGNSPACE);
-          else if (tmp == "ignoredups")
-            history_control |= HC_IGNDUPS;
-          else if (tmp == "ignorespace")
-            history_control |= HC_IGNSPACE;
-          else
-            (*current_liboctave_warning_with_id_handler)
-              ("Octave:history-control",
-               "unknown histcontrol directive %s", tmp.c_str ());
+            if (tmp == "erasedups")
+              history_control |= HC_ERASEDUPS;
+            else if (tmp == "ignoreboth")
+              history_control |= (HC_IGNDUPS | HC_IGNSPACE);
+            else if (tmp == "ignoredups")
+              history_control |= HC_IGNDUPS;
+            else if (tmp == "ignorespace")
+              history_control |= HC_IGNSPACE;
+            else
+              (*current_liboctave_warning_with_id_handler)
+                ("Octave:history-control",
+                 "unknown histcontrol directive %s", tmp.c_str ());
 
-          if (end != std::string::npos)
-            beg = end + 1;
-        }
-    }
-}
-
-std::string
-gnu_history::do_histcontrol (void) const
-{
-  // FIXME: instead of reconstructing this value, should we just save
-  // the string we were given when constructing the command_history object?
+            if (end != std::string::npos)
+              beg = end + 1;
+          }
+      }
+  }
 
-  std::string retval;
-
-  if (history_control & HC_IGNSPACE)
-    retval.append ("ignorespace");
+  std::string
+  gnu_history::do_histcontrol (void) const
+  {
+    // FIXME: instead of reconstructing this value, should we just save
+    // the string we were given when constructing the command_history object?
 
-  if (history_control & HC_IGNDUPS)
-    {
-      if (retval.length () > 0)
-        retval.append (":");
+    std::string retval;
+
+    if (history_control & HC_IGNSPACE)
+      retval.append ("ignorespace");
 
-      retval.append ("ignoredups");
-    }
+    if (history_control & HC_IGNDUPS)
+      {
+        if (retval.length () > 0)
+          retval.append (":");
 
-  if (history_control & HC_ERASEDUPS)
-    {
-      if (retval.length () > 0)
-        retval.append (":");
+        retval.append ("ignoredups");
+      }
 
-      retval.append ("erasedups");
-    }
-
-  return retval;
-}
+    if (history_control & HC_ERASEDUPS)
+      {
+        if (retval.length () > 0)
+          retval.append (":");
 
-bool
-gnu_history::do_add (const std::string& s)
-{
-  if (! do_ignoring_entries ())
-    {
-      if (s.empty ()
-          || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
-        return false;
+        retval.append ("erasedups");
+      }
+
+    return retval;
+  }
 
-      // Strip newline before adding to list
-      std::string stmp = s;
-      int stmp_len = stmp.length ();
-      if (stmp[stmp_len - 1] == '\n')
-        stmp.resize (stmp_len - 1);
+  bool
+  gnu_history::do_add (const std::string& s)
+  {
+    if (! do_ignoring_entries ())
+      {
+        if (s.empty ()
+            || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
+          return false;
 
-      int added = ::octave_add_history (stmp.c_str (), history_control);
-      lines_this_session += added;
-      return (added > 0) ? true : false;
-    }
-  return false;
-}
+        // Strip newline before adding to list
+        std::string stmp = s;
+        int stmp_len = stmp.length ();
+        if (stmp[stmp_len - 1] == '\n')
+          stmp.resize (stmp_len - 1);
 
-void
-gnu_history::do_remove (int n)
-{
-  ::octave_remove_history (n);
-}
+        int added = ::octave_add_history (stmp.c_str (), history_control);
+        lines_this_session += added;
+        return (added > 0) ? true : false;
+      }
+    return false;
+  }
 
-void
-gnu_history::do_clear (void)
-{
-  ::octave_clear_history ();
-}
+  void
+  gnu_history::do_remove (int n)
+  {
+    ::octave_remove_history (n);
+  }
 
-int
-gnu_history::do_where (void) const
-{
-  return ::octave_where_history ();
-}
+  void
+  gnu_history::do_clear (void)
+  {
+    ::octave_clear_history ();
+  }
 
-int
-gnu_history::do_length (void) const
-{
-  return ::octave_history_length ();
-}
+  int
+  gnu_history::do_where (void) const
+  {
+    return ::octave_where_history ();
+  }
 
-int
-gnu_history::do_max_input_history (void) const
-{
-  return ::octave_max_input_history ();
-}
+  int
+  gnu_history::do_length (void) const
+  {
+    return ::octave_history_length ();
+  }
 
-int
-gnu_history::do_base (void) const
-{
-  return ::octave_history_base ();
-}
+  int
+  gnu_history::do_max_input_history (void) const
+  {
+    return ::octave_max_input_history ();
+  }
 
-int
-gnu_history::do_current_number (void) const
-{
-  return (xsize > 0) ? do_base () + do_where () : -1;
-}
+  int
+  gnu_history::do_base (void) const
+  {
+    return ::octave_history_base ();
+  }
 
-void
-gnu_history::do_stifle (int n)
-{
-  ::octave_stifle_history (n);
-}
+  int
+  gnu_history::do_current_number (void) const
+  {
+    return (xsize > 0) ? do_base () + do_where () : -1;
+  }
 
-int
-gnu_history::do_unstifle (void)
-{
-  return ::octave_unstifle_history ();
-}
+  void
+  gnu_history::do_stifle (int n)
+  {
+    ::octave_stifle_history (n);
+  }
 
-int
-gnu_history::do_is_stifled (void) const
-{
-  return ::octave_history_is_stifled ();
-}
+  int
+  gnu_history::do_unstifle (void)
+  {
+    return ::octave_unstifle_history ();
+  }
 
-void
-gnu_history::do_set_mark (int n)
-{
-  mark = n;
-}
+  int
+  gnu_history::do_is_stifled (void) const
+  {
+    return ::octave_history_is_stifled ();
+  }
 
-int
-gnu_history::do_goto_mark (void)
-{
-  if (mark)
-    {
-      char *line = ::octave_history_goto_mark (mark);
+  void
+  gnu_history::do_set_mark (int n)
+  {
+    mark = n;
+  }
 
-      if (line)
-        {
-          command_editor::insert_text (line);
+  int
+  gnu_history::do_goto_mark (void)
+  {
+    if (mark)
+      {
+        char *line = ::octave_history_goto_mark (mark);
 
-          command_editor::clear_undo_list ();
-        }
-    }
-
-  mark = 0;
+        if (line)
+          {
+            command_editor::insert_text (line);
 
-  // FIXME: for operate_and_get_next.
-  command_editor::remove_startup_hook (command_history::goto_mark);
+            command_editor::clear_undo_list ();
+          }
+      }
 
-  return 0;
-}
+    mark = 0;
+
+    // FIXME: for operate_and_get_next.
+    command_editor::remove_startup_hook (command_history::goto_mark);
 
-void
-gnu_history::do_read (const std::string& f, bool must_exist)
-{
-  if (! f.empty ())
-    {
-      int status = ::octave_read_history (f.c_str ());
+    return 0;
+  }
 
-      if (status != 0 && must_exist)
-        {
-          std::string msg = "reading file '" + f + "'";
+  void
+  gnu_history::do_read (const std::string& f, bool must_exist)
+  {
+    if (! f.empty ())
+      {
+        int status = ::octave_read_history (f.c_str ());
 
-          error (status, msg);
-        }
-      else
-        {
-          lines_in_file = do_where ();
+        if (status != 0 && must_exist)
+          {
+            std::string msg = "reading file '" + f + "'";
 
-          ::octave_using_history ();
-        }
-    }
-  else
-    error ("gnu_history::read: missing filename");
-}
+            error (status, msg);
+          }
+        else
+          {
+            lines_in_file = do_where ();
+
+            ::octave_using_history ();
+          }
+      }
+    else
+      error ("gnu_history::read: missing filename");
+  }
 
-void
-gnu_history::do_read_range (const std::string& f, int from, int to,
-                            bool must_exist)
-{
-  if (from < 0)
-    from = lines_in_file;
+  void
+  gnu_history::do_read_range (const std::string& f, int from, int to,
+                              bool must_exist)
+  {
+    if (from < 0)
+      from = lines_in_file;
 
-  if (! f.empty ())
-    {
-      int status = ::octave_read_history_range (f.c_str (), from, to);
+    if (! f.empty ())
+      {
+        int status = ::octave_read_history_range (f.c_str (), from, to);
 
-      if (status != 0 && must_exist)
-        {
-          std::ostringstream buf;
-          buf << "reading lines " << from << " to " << to
-              << " from file '" << f << "'";
+        if (status != 0 && must_exist)
+          {
+            std::ostringstream buf;
+            buf << "reading lines " << from << " to " << to
+                << " from file '" << f << "'";
 
-          error (status, buf.str ());
-        }
-      else
-        {
-          lines_in_file = do_where ();
+            error (status, buf.str ());
+          }
+        else
+          {
+            lines_in_file = do_where ();
 
-          ::octave_using_history ();
-        }
-    }
-  else
-    error ("gnu_history::read_range: missing filename");
-}
+            ::octave_using_history ();
+          }
+      }
+    else
+      error ("gnu_history::read_range: missing filename");
+  }
 
-void
-gnu_history::do_write (const std::string& f_arg) const
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  gnu_history::do_write (const std::string& f_arg) const
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (! f.empty ())
-        {
-          int status = ::octave_write_history (f.c_str ());
+        if (! f.empty ())
+          {
+            int status = ::octave_write_history (f.c_str ());
 
-          if (status != 0)
-            {
-              std::string msg = "writing file '" + f + "'";
+            if (status != 0)
+              {
+                std::string msg = "writing file '" + f + "'";
 
-              error (status, msg);
-            }
-        }
-      else
-        error ("gnu_history::write: missing filename");
-    }
-}
+                error (status, msg);
+              }
+          }
+        else
+          error ("gnu_history::write: missing filename");
+      }
+  }
 
-void
-gnu_history::do_append (const std::string& f_arg)
-{
-  if (initialized)
-    {
-      if (lines_this_session)
-        {
-          if (lines_this_session < do_where ())
-            {
-              // Create file if it doesn't already exist.
+  void
+  gnu_history::do_append (const std::string& f_arg)
+  {
+    if (initialized)
+      {
+        if (lines_this_session)
+          {
+            if (lines_this_session < do_where ())
+              {
+                // Create file if it doesn't already exist.
 
-              std::string f = f_arg;
+                std::string f = f_arg;
 
-              if (f.empty ())
-                f = xfile;
+                if (f.empty ())
+                  f = xfile;
 
-              if (! f.empty ())
-                {
-                  octave::sys::file_stat fs (f);
+                if (! f.empty ())
+                  {
+                    octave::sys::file_stat fs (f);
 
-                  if (! fs)
-                    {
-                      int tem;
+                    if (! fs)
+                      {
+                        int tem;
 
-                      tem = gnulib::open (f.c_str (), O_CREAT, 0666);
-                      gnulib::close (tem);
-                    }
+                        tem = gnulib::open (f.c_str (), O_CREAT, 0666);
+                        gnulib::close (tem);
+                      }
 
-                  int status
-                    = ::octave_append_history (lines_this_session, f.c_str ());
+                    int status
+                      = ::octave_append_history (lines_this_session, f.c_str ());
 
-                  if (status != 0)
-                    {
-                      std::string msg = "appending to file '" + f_arg + "'";
+                    if (status != 0)
+                      {
+                        std::string msg = "appending to file '" + f_arg + "'";
 
-                      error (status, msg);
-                    }
-                  else
-                    lines_in_file += lines_this_session;
+                        error (status, msg);
+                      }
+                    else
+                      lines_in_file += lines_this_session;
 
-                  lines_this_session = 0;
-                }
-              else
-                error ("gnu_history::append: missing filename");
-            }
-        }
-    }
-}
+                    lines_this_session = 0;
+                  }
+                else
+                  error ("gnu_history::append: missing filename");
+              }
+          }
+      }
+  }
 
-void
-gnu_history::do_truncate_file (const std::string& f_arg, int n) const
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  gnu_history::do_truncate_file (const std::string& f_arg, int n) const
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (! f.empty ())
-        ::octave_history_truncate_file (f.c_str (), n);
-      else
-        error ("gnu_history::truncate_file: missing filename");
-    }
-}
+        if (! f.empty ())
+          ::octave_history_truncate_file (f.c_str (), n);
+        else
+          error ("gnu_history::truncate_file: missing filename");
+      }
+  }
 
-string_vector
-gnu_history::do_list (int limit, bool number_lines) const
-{
-  string_vector retval;
+  string_vector
+  gnu_history::do_list (int limit, bool number_lines) const
+  {
+    string_vector retval;
 
-  if (limit)
-    retval = ::octave_history_list (limit, number_lines);
+    if (limit)
+      retval = ::octave_history_list (limit, number_lines);
 
-  return retval;
-}
+    return retval;
+  }
 
-std::string
-gnu_history::do_get_entry (int n) const
-{
-  std::string retval;
+  std::string
+  gnu_history::do_get_entry (int n) const
+  {
+    std::string retval;
 
-  char *line = ::octave_history_get (do_base () + n);
+    char *line = ::octave_history_get (do_base () + n);
 
-  if (line)
-    retval = line;
+    if (line)
+      retval = line;
 
-  return retval;
-}
+    return retval;
+  }
 
-void
-gnu_history::do_replace_entry (int which, const std::string& line)
-{
-  ::octave_replace_history_entry (which, line.c_str ());
-}
+  void
+  gnu_history::do_replace_entry (int which, const std::string& line)
+  {
+    ::octave_replace_history_entry (which, line.c_str ());
+  }
 
-void
-gnu_history::do_clean_up_and_save (const std::string& f_arg, int n)
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  gnu_history::do_clean_up_and_save (const std::string& f_arg, int n)
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (! f.empty ())
-        {
-          if (n < 0)
-            n = xsize;
+        if (! f.empty ())
+          {
+            if (n < 0)
+              n = xsize;
 
-          stifle (n);
+            stifle (n);
 
-          do_write (f.c_str ());
-        }
-      else
-        error ("gnu_history::clean_up_and_save: missing filename");
-    }
-}
+            do_write (f.c_str ());
+          }
+        else
+          error ("gnu_history::clean_up_and_save: missing filename");
+      }
+  }
 
 #endif
 
-bool
-command_history::instance_ok (void)
-{
-  bool retval = true;
+  bool
+  command_history::instance_ok (void)
+  {
+    bool retval = true;
 
-  if (! instance)
-    {
-      make_command_history ();
+    if (! instance)
+      {
+        make_command_history ();
 
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
 
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create command history object!");
+    if (! instance)
+      (*current_liboctave_error_handler)
+        ("unable to create command history object!");
 
-  return retval;
-}
+    return retval;
+  }
 
-void
-command_history::make_command_history (void)
-{
+  void
+  command_history::make_command_history (void)
+  {
 #if defined (USE_READLINE)
-  instance = new gnu_history ();
+    instance = new gnu_history ();
 #else
-  instance = new command_history ();
+    instance = new command_history ();
 #endif
-}
+  }
 
-void
-command_history::initialize (bool read_history_file,
-                             const std::string& f_arg, int sz,
-                             const std::string & control_arg)
-{
-  if (instance_ok ())
-    instance->do_initialize (read_history_file, f_arg, sz, control_arg);
-}
+  void
+  command_history::initialize (bool read_history_file,
+                               const std::string& f_arg, int sz,
+                               const std::string & control_arg)
+  {
+    if (instance_ok ())
+      instance->do_initialize (read_history_file, f_arg, sz, control_arg);
+  }
 
-bool
-command_history::is_initialized (void)
-{
-  // We just want to check the status of an existing instance, not
-  // create one.
-  return instance && instance->do_is_initialized ();
-}
+  bool
+  command_history::is_initialized (void)
+  {
+    // We just want to check the status of an existing instance, not
+    // create one.
+    return instance && instance->do_is_initialized ();
+  }
 
-void
-command_history::set_file (const std::string& f_arg)
-{
-  if (instance_ok ())
-    {
-      std::string f = octave::sys::file_ops::tilde_expand (f_arg);
+  void
+  command_history::set_file (const std::string& f_arg)
+  {
+    if (instance_ok ())
+      {
+        std::string f = octave::sys::file_ops::tilde_expand (f_arg);
 
-      instance->do_set_file (f);
-    }
-}
+        instance->do_set_file (f);
+      }
+  }
 
-std::string
-command_history::file (void)
-{
-  return (instance_ok ())
-         ? instance->do_file () : "";
-}
+  std::string
+  command_history::file (void)
+  {
+    return (instance_ok ())
+      ? instance->do_file () : "";
+  }
 
-void
-command_history::process_histcontrol (const std::string& control_arg)
-{
-  if (instance_ok ())
-    instance->do_process_histcontrol (control_arg);
-}
+  void
+  command_history::process_histcontrol (const std::string& control_arg)
+  {
+    if (instance_ok ())
+      instance->do_process_histcontrol (control_arg);
+  }
 
-std::string
-command_history::histcontrol (void)
-{
-  return (instance_ok ())
-         ? instance->do_histcontrol () : "";
-}
+  std::string
+  command_history::histcontrol (void)
+  {
+    return (instance_ok ())
+      ? instance->do_histcontrol () : "";
+  }
 
-void
-command_history::set_size (int n)
-{
-  if (instance_ok ())
-    instance->do_set_size (n);
-}
+  void
+  command_history::set_size (int n)
+  {
+    if (instance_ok ())
+      instance->do_set_size (n);
+  }
 
-int
-command_history::size (void)
-{
-  return (instance_ok ())
-         ? instance->do_size () : 0;
-}
+  int
+  command_history::size (void)
+  {
+    return (instance_ok ())
+      ? instance->do_size () : 0;
+  }
 
-void
-command_history::ignore_entries (bool flag)
-{
-  if (instance_ok ())
-    instance->do_ignore_entries (flag);
-}
+  void
+  command_history::ignore_entries (bool flag)
+  {
+    if (instance_ok ())
+      instance->do_ignore_entries (flag);
+  }
 
-bool
-command_history::ignoring_entries (void)
-{
-  return (instance_ok ())
-         ? instance->do_ignoring_entries () : false;
-}
+  bool
+  command_history::ignoring_entries (void)
+  {
+    return (instance_ok ())
+      ? instance->do_ignoring_entries () : false;
+  }
 
-bool
-command_history::add (const std::string& s)
-{
-  if (instance_ok ())
-    return instance->do_add (s);
-  return false;
-}
+  bool
+  command_history::add (const std::string& s)
+  {
+    if (instance_ok ())
+      return instance->do_add (s);
+    return false;
+  }
 
-void
-command_history::remove (int n)
-{
-  if (instance_ok ())
-    instance->do_remove (n);
-}
+  void
+  command_history::remove (int n)
+  {
+    if (instance_ok ())
+      instance->do_remove (n);
+  }
 
-void
-command_history::clear (void)
-{
-  if (instance_ok ())
-    instance->do_clear ();
-}
+  void
+  command_history::clear (void)
+  {
+    if (instance_ok ())
+      instance->do_clear ();
+  }
 
-int
-command_history::where (void)
-{
-  return (instance_ok ())
-         ? instance->do_where () : 0;
-}
+  int
+  command_history::where (void)
+  {
+    return (instance_ok ())
+      ? instance->do_where () : 0;
+  }
 
-int
-command_history::length (void)
-{
-  return (instance_ok ())
-         ? instance->do_length () : 0;
-}
+  int
+  command_history::length (void)
+  {
+    return (instance_ok ())
+      ? instance->do_length () : 0;
+  }
 
-int
-command_history::max_input_history (void)
-{
-  return (instance_ok ())
-         ? instance->do_max_input_history () : 0;
-}
+  int
+  command_history::max_input_history (void)
+  {
+    return (instance_ok ())
+      ? instance->do_max_input_history () : 0;
+  }
 
-int
-command_history::base (void)
-{
-  return (instance_ok ())
-         ? instance->do_base () : 0;
-}
+  int
+  command_history::base (void)
+  {
+    return (instance_ok ())
+      ? instance->do_base () : 0;
+  }
 
-int
-command_history::current_number (void)
-{
-  return (instance_ok ())
-         ? instance->do_current_number () : 0;
-}
+  int
+  command_history::current_number (void)
+  {
+    return (instance_ok ())
+      ? instance->do_current_number () : 0;
+  }
 
-void
-command_history::stifle (int n)
-{
-  if (instance_ok ())
-    instance->do_stifle (n);
-}
+  void
+  command_history::stifle (int n)
+  {
+    if (instance_ok ())
+      instance->do_stifle (n);
+  }
 
-int
-command_history::unstifle (void)
-{
-  return (instance_ok ())
-         ? instance->do_unstifle () : 0;
-}
+  int
+  command_history::unstifle (void)
+  {
+    return (instance_ok ())
+      ? instance->do_unstifle () : 0;
+  }
 
-int
-command_history::is_stifled (void)
-{
-  return (instance_ok ())
-         ? instance->do_is_stifled () : 0;
-}
+  int
+  command_history::is_stifled (void)
+  {
+    return (instance_ok ())
+      ? instance->do_is_stifled () : 0;
+  }
 
-void
-command_history::set_mark (int n)
-{
-  if (instance_ok ())
-    instance->do_set_mark (n);
-}
+  void
+  command_history::set_mark (int n)
+  {
+    if (instance_ok ())
+      instance->do_set_mark (n);
+  }
 
-int
-command_history::goto_mark (void)
-{
-  return (instance_ok ())
-         ? instance->do_goto_mark () : 0;
-}
+  int
+  command_history::goto_mark (void)
+  {
+    return (instance_ok ())
+      ? instance->do_goto_mark () : 0;
+  }
 
-void
-command_history::read (bool must_exist)
-{
-  read (file (), must_exist);
-}
+  void
+  command_history::read (bool must_exist)
+  {
+    read (file (), must_exist);
+  }
 
-void
-command_history::read (const std::string& f, bool must_exist)
-{
-  if (instance_ok ())
-    instance->do_read (f, must_exist);
-}
+  void
+  command_history::read (const std::string& f, bool must_exist)
+  {
+    if (instance_ok ())
+      instance->do_read (f, must_exist);
+  }
 
-void
-command_history::read_range (int from, int to, bool must_exist)
-{
-  read_range (file (), from, to, must_exist);
-}
+  void
+  command_history::read_range (int from, int to, bool must_exist)
+  {
+    read_range (file (), from, to, must_exist);
+  }
 
-void
-command_history::read_range (const std::string& f, int from, int to,
-                             bool must_exist)
-{
-  if (instance_ok ())
-    instance->do_read_range (f, from, to, must_exist);
-}
+  void
+  command_history::read_range (const std::string& f, int from, int to,
+                               bool must_exist)
+  {
+    if (instance_ok ())
+      instance->do_read_range (f, from, to, must_exist);
+  }
 
-void
-command_history::write (const std::string& f)
-{
-  if (instance_ok ())
-    instance->do_write (f);
-}
+  void
+  command_history::write (const std::string& f)
+  {
+    if (instance_ok ())
+      instance->do_write (f);
+  }
 
-void
-command_history::append (const std::string& f)
-{
-  if (instance_ok ())
-    instance->do_append (f);
-}
+  void
+  command_history::append (const std::string& f)
+  {
+    if (instance_ok ())
+      instance->do_append (f);
+  }
 
-void
-command_history::truncate_file (const std::string& f, int n)
-{
-  if (instance_ok ())
-    instance->do_truncate_file (f, n);
-}
+  void
+  command_history::truncate_file (const std::string& f, int n)
+  {
+    if (instance_ok ())
+      instance->do_truncate_file (f, n);
+  }
 
-string_vector
-command_history::list (int limit, bool number_lines)
-{
-  return (instance_ok ())
-         ? instance->do_list (limit, number_lines) : string_vector ();
-}
+  string_vector
+  command_history::list (int limit, bool number_lines)
+  {
+    return (instance_ok ())
+      ? instance->do_list (limit, number_lines) : string_vector ();
+  }
 
-std::string
-command_history::get_entry (int n)
-{
-  return (instance_ok ())
-         ? instance->do_get_entry (n) : "";
-}
+  std::string
+  command_history::get_entry (int n)
+  {
+    return (instance_ok ())
+      ? instance->do_get_entry (n) : "";
+  }
 
-void
-command_history::replace_entry (int which, const std::string& line)
-{
-  if (instance_ok ())
-    instance->do_replace_entry (which, line);
-}
+  void
+  command_history::replace_entry (int which, const std::string& line)
+  {
+    if (instance_ok ())
+      instance->do_replace_entry (which, line);
+  }
 
-void
-command_history::clean_up_and_save (const std::string& f, int n)
-{
-  if (instance_ok ())
-    instance->do_clean_up_and_save (f, n);
-}
+  void
+  command_history::clean_up_and_save (const std::string& f, int n)
+  {
+    if (instance_ok ())
+      instance->do_clean_up_and_save (f, n);
+  }
 
-void
-command_history::do_process_histcontrol (const std::string&)
-{
-  (*current_liboctave_warning_with_id_handler)
-    ("Octave:history-control",
-     "readline is not linked, so history control is not available");
-}
+  void
+  command_history::do_process_histcontrol (const std::string&)
+  {
+    (*current_liboctave_warning_with_id_handler)
+      ("Octave:history-control",
+       "readline is not linked, so history control is not available");
+  }
 
-void
-command_history::do_initialize (bool read_history_file,
-                                const std::string& f_arg, int sz,
-                                const std::string & control_arg)
-{
-  command_history::set_file (f_arg);
-  command_history::set_size (sz);
-  command_history::process_histcontrol (control_arg);
+  void
+  command_history::do_initialize (bool read_history_file,
+                                  const std::string& f_arg, int sz,
+                                  const std::string & control_arg)
+  {
+    command_history::set_file (f_arg);
+    command_history::set_size (sz);
+    command_history::process_histcontrol (control_arg);
 
-  if (read_history_file)
-    command_history::read (false);
+    if (read_history_file)
+      command_history::read (false);
 
-  initialized = true;
-}
+    initialized = true;
+  }
 
-bool
-command_history::do_is_initialized (void) const
-{
-  return initialized;
-}
+  bool
+  command_history::do_is_initialized (void) const
+  {
+    return initialized;
+  }
 
-void
-command_history::do_set_file (const std::string& f)
-{
-  xfile = f;
-}
+  void
+  command_history::do_set_file (const std::string& f)
+  {
+    xfile = f;
+  }
 
-std::string
-command_history::do_file (void)
-{
-  return xfile;
-}
+  std::string
+  command_history::do_file (void)
+  {
+    return xfile;
+  }
 
-void
-command_history::do_set_size (int n)
-{
-  xsize = n;
-}
+  void
+  command_history::do_set_size (int n)
+  {
+    xsize = n;
+  }
 
-int
-command_history::do_size (void) const
-{
-  return xsize;
-}
+  int
+  command_history::do_size (void) const
+  {
+    return xsize;
+  }
 
-void
-command_history::do_ignore_entries (bool flag)
-{
-  ignoring_additions = flag;
-}
+  void
+  command_history::do_ignore_entries (bool flag)
+  {
+    ignoring_additions = flag;
+  }
 
-bool
-command_history::do_ignoring_entries (void) const
-{
-  return ignoring_additions;
-}
+  bool
+  command_history::do_ignoring_entries (void) const
+  {
+    return ignoring_additions;
+  }
 
-bool
-command_history::do_add (const std::string&)
-{
-  return false;
-}
+  bool
+  command_history::do_add (const std::string&)
+  {
+    return false;
+  }
 
-void
-command_history::do_remove (int)
-{
-}
+  void
+  command_history::do_remove (int)
+  {
+  }
 
-void
-command_history::do_clear (void)
-{
-}
+  void
+  command_history::do_clear (void)
+  {
+  }
 
-int
-command_history::do_where (void) const
-{
-  return 0;
-}
+  int
+  command_history::do_where (void) const
+  {
+    return 0;
+  }
 
-int
-command_history::do_length (void) const
-{
-  return 0;
-}
+  int
+  command_history::do_length (void) const
+  {
+    return 0;
+  }
 
-int
-command_history::do_max_input_history (void) const
-{
-  return 0;
-}
+  int
+  command_history::do_max_input_history (void) const
+  {
+    return 0;
+  }
 
-int
-command_history::do_base (void) const
-{
-  return 0;
-}
+  int
+  command_history::do_base (void) const
+  {
+    return 0;
+  }
 
-int
-command_history::do_current_number (void) const
-{
-  return (xsize > 0) ? do_base () + do_where () : -1;
-}
+  int
+  command_history::do_current_number (void) const
+  {
+    return (xsize > 0) ? do_base () + do_where () : -1;
+  }
 
-void
-command_history::do_stifle (int)
-{
-}
+  void
+  command_history::do_stifle (int)
+  {
+  }
 
-int
-command_history::do_unstifle (void)
-{
-  return -1;
-}
+  int
+  command_history::do_unstifle (void)
+  {
+    return -1;
+  }
 
-int
-command_history::do_is_stifled (void) const
-{
-  return 0;
-}
+  int
+  command_history::do_is_stifled (void) const
+  {
+    return 0;
+  }
 
-void
-command_history::do_set_mark (int)
-{
-}
+  void
+  command_history::do_set_mark (int)
+  {
+  }
 
-int
-command_history::do_goto_mark (void)
-{
-  return 0;
-}
+  int
+  command_history::do_goto_mark (void)
+  {
+    return 0;
+  }
 
-void
-command_history::do_read (const std::string& f, bool)
-{
-  if (f.empty ())
-    error ("command_history::read: missing filename");
-}
+  void
+  command_history::do_read (const std::string& f, bool)
+  {
+    if (f.empty ())
+      error ("command_history::read: missing filename");
+  }
 
-void
-command_history::do_read_range (const std::string& f, int, int, bool)
-{
-  if (f.empty ())
-    error ("command_history::read_range: missing filename");
-}
+  void
+  command_history::do_read_range (const std::string& f, int, int, bool)
+  {
+    if (f.empty ())
+      error ("command_history::read_range: missing filename");
+  }
 
-void
-command_history::do_write (const std::string& f_arg) const
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  command_history::do_write (const std::string& f_arg) const
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (f.empty ())
-        error ("command_history::write: missing filename");
-    }
-}
+        if (f.empty ())
+          error ("command_history::write: missing filename");
+      }
+  }
 
-void
-command_history::do_append (const std::string& f_arg)
-{
-  if (initialized)
-    {
-      if (lines_this_session)
-        {
-          if (lines_this_session < do_where ())
-            {
-              // Create file if it doesn't already exist.
+  void
+  command_history::do_append (const std::string& f_arg)
+  {
+    if (initialized)
+      {
+        if (lines_this_session)
+          {
+            if (lines_this_session < do_where ())
+              {
+                // Create file if it doesn't already exist.
 
-              std::string f = f_arg;
+                std::string f = f_arg;
 
-              if (f.empty ())
-                f = xfile;
+                if (f.empty ())
+                  f = xfile;
 
-              if (f.empty ())
-                error ("command_history::append: missing filename");
-            }
-        }
-    }
-}
+                if (f.empty ())
+                  error ("command_history::append: missing filename");
+              }
+          }
+      }
+  }
 
-void
-command_history::do_truncate_file (const std::string& f_arg, int) const
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  command_history::do_truncate_file (const std::string& f_arg, int) const
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (f.empty ())
-        error ("command_history::truncate_file: missing filename");
-    }
-}
+        if (f.empty ())
+          error ("command_history::truncate_file: missing filename");
+      }
+  }
 
-string_vector
-command_history::do_list (int, bool) const
-{
-  return string_vector ();
-}
+  string_vector
+  command_history::do_list (int, bool) const
+  {
+    return string_vector ();
+  }
 
-std::string
-command_history::do_get_entry (int) const
-{
-  return "";
-}
+  std::string
+  command_history::do_get_entry (int) const
+  {
+    return "";
+  }
 
-void
-command_history::do_replace_entry (int, const std::string&)
-{
-}
+  void
+  command_history::do_replace_entry (int, const std::string&)
+  {
+  }
 
-void
-command_history::do_clean_up_and_save (const std::string& f_arg, int)
-{
-  if (initialized)
-    {
-      std::string f = f_arg;
+  void
+  command_history::do_clean_up_and_save (const std::string& f_arg, int)
+  {
+    if (initialized)
+      {
+        std::string f = f_arg;
 
-      if (f.empty ())
-        f = xfile;
+        if (f.empty ())
+          f = xfile;
 
-      if (f.empty ())
-        error ("command_history::clean_up_and_save: missing filename");
-    }
-}
+        if (f.empty ())
+          error ("command_history::clean_up_and_save: missing filename");
+      }
+  }
 
-void
-command_history::error (int err_num, const std::string& msg) const
-{
-  if (msg.empty ())
-    (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
-  else
-    (*current_liboctave_error_handler) ("%s: %s", msg.c_str (),
-                                        gnulib::strerror (err_num));
+  void
+  command_history::error (int err_num, const std::string& msg) const
+  {
+    if (msg.empty ())
+      (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+    else
+      (*current_liboctave_error_handler) ("%s: %s", msg.c_str (),
+                                          gnulib::strerror (err_num));
+  }
+
+  void
+  command_history::error (const std::string& s) const
+  {
+    (*current_liboctave_error_handler) ("%s", s.c_str ());
+  }
 }
-
-void
-command_history::error (const std::string& s) const
-{
-  (*current_liboctave_error_handler) ("%s", s.c_str ());
-}
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -24,210 +24,220 @@ along with Octave; see the file COPYING.
 #define octave_cmd_hist_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "str-vec.h"
 
-class
-OCTAVE_API
-command_history
+namespace octave
 {
-protected:
+  class
+  OCTAVE_API
+  command_history
+  {
+  protected:
 
-  command_history (void)
-    : initialized (false), ignoring_additions (false), history_control (0),
+    command_history (void)
+      : initialized (false), ignoring_additions (false), history_control (0),
       lines_in_file (0), lines_this_session (0), xfile (), xsize (-1) { }
 
-public:
+  public:
 
-  virtual ~command_history (void) { }
+    virtual ~command_history (void) { }
 
-  static void initialize (bool, const std::string&, int, const std::string&);
+    static void initialize (bool, const std::string&, int, const std::string&);
 
-  static bool is_initialized (void);
+    static bool is_initialized (void);
 
-  static void set_file (const std::string&);
+    static void set_file (const std::string&);
 
-  static std::string file (void);
+    static std::string file (void);
 
-  static void process_histcontrol (const std::string&);
+    static void process_histcontrol (const std::string&);
 
-  static std::string histcontrol (void);
+    static std::string histcontrol (void);
 
-  static void set_size (int);
+    static void set_size (int);
 
-  static int size (void);
+    static int size (void);
 
-  static void ignore_entries (bool = true);
+    static void ignore_entries (bool = true);
 
-  static bool ignoring_entries (void);
+    static bool ignoring_entries (void);
 
-  static bool add (const std::string&);
+    static bool add (const std::string&);
 
-  static void remove (int);
+    static void remove (int);
 
-  static void clear (void);
+    static void clear (void);
 
-  static int where (void);
+    static int where (void);
 
-  static int length (void);
+    static int length (void);
 
-  static int max_input_history (void);
+    static int max_input_history (void);
 
-  static int base (void);
+    static int base (void);
 
-  static int current_number (void);
+    static int current_number (void);
 
-  static void stifle (int);
+    static void stifle (int);
 
-  static int unstifle (void);
+    static int unstifle (void);
 
-  static int is_stifled (void);
+    static int is_stifled (void);
 
-  static void set_mark (int n);
+    static void set_mark (int n);
 
-  // Gag.  This declaration has to match the Function typedef in
-  // readline.h.
+    // Gag.  This declaration has to match the Function typedef in
+    // readline.h.
 
-  static int goto_mark (void);
+    static int goto_mark (void);
 
-  static void read (bool = true);
+    static void read (bool = true);
 
-  static void read (const std::string&, bool = true);
+    static void read (const std::string&, bool = true);
 
-  static void read_range (int = -1, int = -1, bool = true);
+    static void read_range (int = -1, int = -1, bool = true);
 
-  static void read_range (const std::string&, int = -1, int = -1,
-                          bool = true);
+    static void read_range (const std::string&, int = -1, int = -1,
+                            bool = true);
 
-  static void write (const std::string& = "");
+    static void write (const std::string& = "");
 
-  static void append (const std::string& = "");
+    static void append (const std::string& = "");
 
-  static void truncate_file (const std::string& = "", int = -1);
+    static void truncate_file (const std::string& = "", int = -1);
 
-  static string_vector list (int = -1, bool = false);
+    static string_vector list (int = -1, bool = false);
 
-  static std::string get_entry (int);
+    static std::string get_entry (int);
 
-  static void replace_entry (int, const std::string&);
+    static void replace_entry (int, const std::string&);
 
-  static void clean_up_and_save (const std::string& = "", int = -1);
+    static void clean_up_and_save (const std::string& = "", int = -1);
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  command_history (const command_history&);
+    command_history (const command_history&);
 
-  command_history& operator = (const command_history&);
+    command_history& operator = (const command_history&);
 
-  static bool instance_ok (void);
+    static bool instance_ok (void);
 
-  static void make_command_history (void);
+    static void make_command_history (void);
 
-  // The real thing.
-  static command_history *instance;
+    // The real thing.
+    static command_history *instance;
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-protected:
+  protected:
 
-  // To use something other than the GNU history library, derive a new
-  // class from command_history, overload these functions as
-  // necessary, and make instance point to the new class.
+    // To use something other than the GNU history library, derive a new
+    // class from command_history, overload these functions as
+    // necessary, and make instance point to the new class.
+
+    virtual void do_set_file (const std::string&);
 
-  virtual void do_set_file (const std::string&);
+    virtual std::string do_file (void);
 
-  virtual std::string do_file (void);
+    virtual void do_process_histcontrol (const std::string&);
 
-  virtual void do_process_histcontrol (const std::string&);
+    virtual std::string do_histcontrol (void) const { return ""; }
 
-  virtual std::string do_histcontrol (void) const { return ""; }
+    virtual void do_initialize (bool, const std::string&, int,
+                                const std::string&);
 
-  virtual void do_initialize (bool, const std::string&, int,
-                              const std::string&);
+    virtual bool do_is_initialized (void) const;
 
-  virtual bool do_is_initialized (void) const;
+    virtual void do_set_size (int);
 
-  virtual void do_set_size (int);
+    virtual int do_size (void) const;
 
-  virtual int do_size (void) const;
+    virtual void do_ignore_entries (bool);
 
-  virtual void do_ignore_entries (bool);
+    virtual bool do_ignoring_entries (void) const;
 
-  virtual bool do_ignoring_entries (void) const;
+    virtual bool do_add (const std::string&);
 
-  virtual bool do_add (const std::string&);
+    virtual void do_remove (int);
 
-  virtual void do_remove (int);
+    virtual void do_clear (void);
 
-  virtual void do_clear (void);
+    virtual int do_where (void) const;
 
-  virtual int do_where (void) const;
+    virtual int do_length (void) const;
 
-  virtual int do_length (void) const;
+    virtual int do_max_input_history (void) const;
 
-  virtual int do_max_input_history (void) const;
+    virtual int do_base (void) const;
 
-  virtual int do_base (void) const;
+    virtual int do_current_number (void) const;
 
-  virtual int do_current_number (void) const;
+    virtual void do_stifle (int);
 
-  virtual void do_stifle (int);
+    virtual int do_unstifle (void);
+
+    virtual int do_is_stifled (void) const;
 
-  virtual int do_unstifle (void);
+    virtual void do_set_mark (int);
 
-  virtual int do_is_stifled (void) const;
+    virtual int do_goto_mark (void);
 
-  virtual void do_set_mark (int);
+    virtual void do_read (const std::string&, bool);
 
-  virtual int do_goto_mark (void);
-
-  virtual void do_read (const std::string&, bool);
+    virtual void do_read_range (const std::string&, int, int, bool);
 
-  virtual void do_read_range (const std::string&, int, int, bool);
+    virtual void do_write (const std::string&) const;
 
-  virtual void do_write (const std::string&) const;
+    virtual void do_append (const std::string&);
 
-  virtual void do_append (const std::string&);
+    virtual void do_truncate_file (const std::string&, int) const;
 
-  virtual void do_truncate_file (const std::string&, int) const;
+    virtual string_vector do_list (int, bool) const;
 
-  virtual string_vector do_list (int, bool) const;
+    virtual std::string do_get_entry (int) const;
 
-  virtual std::string do_get_entry (int) const;
+    virtual void do_replace_entry (int, const std::string&);
 
-  virtual void do_replace_entry (int, const std::string&);
+    virtual void do_clean_up_and_save (const std::string&, int);
 
-  virtual void do_clean_up_and_save (const std::string&, int);
+    void error (int, const std::string& msg = "") const;
 
-  void error (int, const std::string& msg = "") const;
+    void error (const std::string&) const;
 
-  void error (const std::string&) const;
-
-  // TRUE means we have initialized the history filename and number of
-  // lines to save.
-  bool initialized;
+    // TRUE means we have initialized the history filename and number of
+    // lines to save.
+    bool initialized;
 
-  // TRUE means we are ignoring new additions.
-  bool ignoring_additions;
+    // TRUE means we are ignoring new additions.
+    bool ignoring_additions;
 
-  // Bitmask for history control options.  See oct-rl-hist.h.
-  int history_control;
+    // Bitmask for history control options.  See oct-rl-hist.h.
+    int history_control;
+
+    // The number of history lines we read from the history file.
+    int lines_in_file;
 
-  // The number of history lines we read from the history file.
-  int lines_in_file;
+    // The number of history lines we've saved so far.
+    int lines_this_session;
 
-  // The number of history lines we've saved so far.
-  int lines_this_session;
+    // The default history file.
+    std::string xfile;
 
-  // The default history file.
-  std::string xfile;
+    // The number of lines of history to save.
+    int xsize;
+  };
+}
 
-  // The number of lines of history to save.
-  int xsize;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use octave::command_history instead")
+typedef octave::command_history command_history;
 
 #endif
+
+#endif
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -237,17 +237,17 @@ string_vector::list_in_columns (std::ost
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
   // Calculate the maximum number of columns that will fit.
 
   octave_idx_type line_length
-    = ((width <= 0 ? command_editor::terminal_cols () : width)
+    = ((width <= 0 ? octave::command_editor::terminal_cols () : width)
        - prefix.length ());
 
   octave_idx_type nc = line_length / max_name_length;
   if (nc == 0)
     nc = 1;
 
   // Calculate the number of rows that will be in each column except
   // possibly for a short column on the right.
diff --git a/oct-conf-post.in.h b/oct-conf-post.in.h
--- a/oct-conf-post.in.h
+++ b/oct-conf-post.in.h
@@ -49,17 +49,17 @@ along with Octave; see the file COPYING.
 #  define OCTAVE_UNUSED __attribute__ ((__unused__))
 #  define HAVE_OCTAVE_UNUSED_ATTR 1
 #else
 #  define OCTAVE_DEPRECATED(msg)
 #  define OCTAVE_NORETURN
 #  define OCTAVE_UNUSED
 #endif
 
-#define OCTAVE_USE_DEPRECATED_FUNCTIONS 1
+// #define OCTAVE_USE_DEPRECATED_FUNCTIONS 1
 
 #if defined (__cplusplus)
 template <typename T>
 static inline void
 octave_unused_parameter (const T&)
 { }
 #else
 #  define octave_unused_parameter(param) (void) param;
