# HG changeset patch
# User Rik <rik@octave.org>
# Date 1522788760 25200
#      Tue Apr 03 13:52:40 2018 -0700
# Node ID 1fdd1b211ed4981f2f37a223291ae3d62b9526f1
# Parent  b8ffceb0635450aa75ef6866dc2e7f15e90e6afa
# Parent  078b795c52191c929a960da45ed0ecaccf2ee898
maint: merge stable to default.

diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -484,13 +484,13 @@ namespace QtHandles
         octave_scalar_map eventData;
         eventData.setfield ("OldValue", oldValue.as_octave_value ());
         eventData.setfield ("NewValue", newValue.as_octave_value ());
         eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
         eventData.setfield ("EventName", "SelectionChanged");
         octave_value selectionChangedEventObject = octave_value (new octave_struct (
               eventData));
         gh_manager::post_callback (m_handle, "selectionchangedfcn",
-                                  selectionChangedEventObject);
+                                   selectionChangedEventObject);
       }
   }
 
 };
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -991,17 +991,17 @@ namespace QtHandles
                   axes::properties& ap = Utils::properties<axes> (axesObj);
 
                   double factor = (event->delta () > 0 ? 0.1 : -0.1);
 
                   if (event->modifiers () == Qt::NoModifier
                       && mode != "horizontal")
                     ap.pan ("vertical", factor);
                   else if (event->modifiers () == Qt::ShiftModifier
-                      && mode != "vertical")
+                           && mode != "vertical")
                     ap.pan ("horizontal", factor);
                 }
                 break;
 
               default:
                 redrawFigure = false;
                 break;
               }
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -909,17 +909,17 @@ namespace QtHandles
         QFileInfo finfo (file);
 
         file = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
                                              tr ("Save Figure As"),
                                              finfo.absoluteFilePath (),
                                              tr ("Octave Figure File (*.ofig);;Vector Image Formats (*.eps *.epsc *.pdf *.svg *.ps *.tikz);;Bitmap Image Formats (*.gif *.jpg *.png *.tiff)"),
                                              nullptr,
                                              QFileDialog::DontUseNativeDialog);
-    }
+      }
 
     if (! file.isEmpty ())
       {
         QFileInfo finfo (file);
 
         setFileName (finfo.absoluteFilePath ());
 
         octave_link::post_event (this, &Figure::save_figure_callback,
diff --git a/libgui/graphics/GLCanvas.cc b/libgui/graphics/GLCanvas.cc
--- a/libgui/graphics/GLCanvas.cc
+++ b/libgui/graphics/GLCanvas.cc
@@ -73,73 +73,73 @@ namespace QtHandles
       }
   }
 
   uint8NDArray
   GLCanvas::do_getPixels (const graphics_handle& gh)
   {
     uint8NDArray retval;
     graphics_object go = gh_manager::get_object (gh);
-    
+
     if (go && go.isa ("figure"))
       {
         Matrix pos = go.get ("position").matrix_value ();
 
         // Make sure we have a valid current context
         if (! begin_rendering ())
           return retval;
 
         // When the figure is not visible or its size is frozen for printing,
         // we use a framebuffer object to make sure we are rendering on a
         // suitably large frame.
         if (go.get ("visible").string_value () == "off"
             || go.get ("__printing__").string_value () == "on")
           {
             OCTAVE_QT_OPENGL_FBO
-              fbo (pos(2), pos(3),OCTAVE_QT_OPENGL_FBO::Attachment::Depth);
-            
+            fbo (pos(2), pos(3),OCTAVE_QT_OPENGL_FBO::Attachment::Depth);
+
             fbo.bind ();
-            
+
             octave::opengl_renderer r;
             r.set_viewport (pos(2), pos(3));
             r.draw (go);
             retval = r.get_pixels (pos(2), pos(3));
-            
+
             fbo.release ();
           }
         else
           {
             octave::opengl_renderer r;
             r.set_viewport (pos(2), pos(3));
             r.draw (go);
-            retval = r.get_pixels (pos(2), pos(3));            
+            retval = r.get_pixels (pos(2), pos(3));
           }
 
         end_rendering ();
       }
 
     return retval;
   }
-  
+
   void
   GLCanvas::do_print (const QString& file_cmd, const QString& term,
                       const graphics_handle& handle)
   {
     gh_manager::auto_lock lock;
     graphics_object obj = gh_manager::get_object (handle);
 
     if (obj.valid_object ())
       {
         graphics_object figObj (obj.get_ancestor ("figure"));
         try
           {
             // Make sure we have a valid current context
             if (! begin_rendering ())
               error ("print: no valid OpenGL offscreen context");
-            
+
             octave::gl2ps_print (figObj, file_cmd.toStdString (),
                                  term.toStdString ());
           }
         catch (octave::execution_exception& e)
           {
             octave_link::post_exception (std::current_exception ());
             end_rendering ();
           }
@@ -275,41 +275,41 @@ namespace QtHandles
     if (! canvasKeyReleaseEvent (xevent))
       OCTAVE_QT_OPENGL_WIDGET::keyReleaseEvent (xevent);
   }
 
   bool
   GLCanvas::begin_rendering (void)
   {
     bool retval = true;
-    
+
     if (! isValid ())
       {
 #  if defined (HAVE_QT_OFFSCREEN)
         static bool os_ctx_ok = true;
         if (os_ctx_ok && ! m_os_context.isValid ())
           {
             // Try to initialize offscreen context
             m_os_surface.create ();
             if (! m_os_context.create ())
               {
                 os_ctx_ok = false;
                 return false;
               }
           }
-       
+
         retval = m_os_context.makeCurrent (&m_os_surface);
-#  else   
+#  else
         retval = false;
 #  endif
       }
     else
       makeCurrent ();
-    
+
     return retval;
   }
-  
+
   void
   GLCanvas::end_rendering (void)
-  {        
+  {
     doneCurrent ();
   }
 }
diff --git a/libgui/graphics/GLCanvas.h b/libgui/graphics/GLCanvas.h
--- a/libgui/graphics/GLCanvas.h
+++ b/libgui/graphics/GLCanvas.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_QOPENGLWIDGET)
 #  include <QOpenGLWidget>
 #  define OCTAVE_QT_OPENGL_WIDGET QOpenGLWidget
 #  include <QOpenGLFramebufferObject>
 #  define OCTAVE_QT_OPENGL_FBO QOpenGLFramebufferObject
 #  if defined (HAVE_QT_OFFSCREEN)
 #    include <QOpenGLContext>
 #    include <QOffscreenSurface>
-#  endif  
+#  endif
 #elif defined (HAVE_QGLWIDGET)
 #  include <QGLWidget>
 #  define OCTAVE_QT_OPENGL_WIDGET QGLWidget
 #  include <QGLFramebufferObject>
 #  define OCTAVE_QT_OPENGL_FBO QGLFramebufferObject
 #else
 #  error "configuration error: must have <QOpenGLWidget> or <QGLWidget>."
 #endif
@@ -69,23 +69,23 @@ namespace QtHandles
     void paintGL (void);
     void mouseDoubleClickEvent (QMouseEvent *event);
     void mouseMoveEvent (QMouseEvent *event);
     void mousePressEvent (QMouseEvent *event);
     void mouseReleaseEvent (QMouseEvent *event);
     void wheelEvent (QWheelEvent *event);
     void keyPressEvent (QKeyEvent *event);
     void keyReleaseEvent (QKeyEvent *event);
-    
+
   private:
-    
+
     bool begin_rendering (void);
     void end_rendering (void);
 
 # if defined (HAVE_QT_OFFSCREEN)
-    QOpenGLContext m_os_context;    
+    QOpenGLContext m_os_context;
     QOffscreenSurface m_os_surface;
 # endif
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -113,17 +113,17 @@ namespace QtHandles
 
     list->viewport ()->installEventFilter (this);
 
     connect (list, SIGNAL (itemSelectionChanged (void)),
              SLOT (itemSelectionChanged (void)));
     connect (list, SIGNAL (activated (const QModelIndex &)),
              SLOT (itemActivated (const QModelIndex &)));
     connect (list, SIGNAL (itemPressed (QListWidgetItem*)),
-           SLOT (itemPressed (QListWidgetItem*)));
+             SLOT (itemPressed (QListWidgetItem*)));
   }
 
   ListBoxControl::~ListBoxControl (void)
   { }
 
   void
   ListBoxControl::update (int pId)
   {
@@ -174,17 +174,17 @@ namespace QtHandles
 
         foreach (const QModelIndex& idx, l)
           value(i++) = idx.row () + 1;
 
         gh_manager::post_set (m_handle, "value", octave_value (value), false);
         gh_manager::post_callback (m_handle, "callback");
       }
 
-      m_selectionChanged = false;
+    m_selectionChanged = false;
   }
 
   void
   ListBoxControl::itemSelectionChanged (void)
   {
     if (! m_blockCallback)
       m_selectionChanged = true;
   }
@@ -203,69 +203,69 @@ namespace QtHandles
   bool
   ListBoxControl::eventFilter (QObject *watched, QEvent *e)
   {
     // listbox change
     if (watched == m_qobject)
       {
         switch (e->type ())
           {
-            case QEvent::KeyRelease:
-              if (m_selectionChanged)
-                sendSelectionChange ();
-              m_selectionChanged = false;
-              break;
+          case QEvent::KeyRelease:
+            if (m_selectionChanged)
+              sendSelectionChange ();
+            m_selectionChanged = false;
+            break;
 
-            default:
-              break;
+          default:
+            break;
           }
 
         return Object::eventFilter (watched, e);
       }
     // listbox viewport
     else
       {
         bool override_return = false;
         QListWidget *list = qWidget<QListWidget> ();
 
         switch (e->type ())
           {
-            case QEvent::MouseButtonPress:
-              {
-                QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
+          case QEvent::MouseButtonPress:
+            {
+              QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
 
-                if (m->button () & Qt::RightButton)
-                  override_return = true;
-                else
-                  {
-                    if (! list->indexAt (m->pos ()).isValid ())
-                      override_return = true;
-                    m_selectionChanged = true;
-                  }
-                break;
-              }
-            case QEvent::MouseButtonRelease:
-              {
-                QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
+              if (m->button () & Qt::RightButton)
+                override_return = true;
+              else
+                {
+                  if (! list->indexAt (m->pos ()).isValid ())
+                    override_return = true;
+                  m_selectionChanged = true;
+                }
+              break;
+            }
+          case QEvent::MouseButtonRelease:
+            {
+              QMouseEvent *m = dynamic_cast<QMouseEvent *> (e);
 
-                if (m->button () & Qt::RightButton)
-                  override_return = true;
+              if (m->button () & Qt::RightButton)
+                override_return = true;
 
-                else if (! list->indexAt (m->pos ()).isValid ())
-                  {
-                    list->setCurrentRow (list->count () - 1);
-                    override_return = true;
-                  }
+              else if (! list->indexAt (m->pos ()).isValid ())
+                {
+                  list->setCurrentRow (list->count () - 1);
+                  override_return = true;
+                }
 
-                if (m_selectionChanged)
-                  sendSelectionChange ();
-                m_selectionChanged = false;
+              if (m_selectionChanged)
+                sendSelectionChange ();
+              m_selectionChanged = false;
 
-                break;
-              }
-            default:
               break;
+            }
+          default:
+            break;
 
           }
         return BaseControl::eventFilter (watched, e) || override_return;
       }
   }
 }
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -140,13 +140,13 @@ namespace QtHandles
                                          Q_RETURN_ARG (uint8NDArray, retval)))
           {
             octave_sleep (0.2);
             if (! QMetaObject::invokeMethod (m_object, "slotGetPixels", t,
                                              Q_RETURN_ARG (uint8NDArray, retval)))
               error ("getframe: unable to retrieve figure pixels");
           }
       }
-    
-     return retval;
-   }
+
+    return retval;
+  }
 
 };
diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
--- a/libgui/qterminal/libqterminal/QTerminal.h
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -57,17 +57,17 @@ public:
 
   virtual void sendText (const QString& text) = 0;
 
   virtual QString selectedText () = 0;
 
   virtual void has_extra_interrupt (bool extra) = 0;
 
   virtual QList<QAction*> get_hotspot_actions (const QPoint&)
-      { return QList<QAction*> (); }
+  { return QList<QAction*> (); }
 
   enum CursorType
   {
     UnderlineCursor,
     BlockCursor,
     IBeamCursor
   };
 
@@ -130,26 +130,26 @@ protected:
 
     _contextMenu = new QMenu (this);
 
     _copy_action = _contextMenu->addAction (
                      resource_manager::icon ("edit-copy"),
                      tr ("Copy"), this, SLOT (copyClipboard ()));
 
     _paste_action = _contextMenu->addAction (
-                     resource_manager::icon ("edit-paste"),
+                      resource_manager::icon ("edit-paste"),
                       tr ("Paste"), this, SLOT (pasteClipboard ()));
 
     _contextMenu->addSeparator ();
 
     _selectall_action = _contextMenu->addAction (
-                      tr ("Select All"), this, SLOT (selectAll ()));
+                          tr ("Select All"), this, SLOT (selectAll ()));
 
     _edit_action = _contextMenu->addAction (
-                      tr (""), this, SLOT (edit_file ()));
+                     tr (""), this, SLOT (edit_file ()));
 
     _contextMenu->addSeparator ();
 
     _contextMenu->addAction (tr ("Clear Window"), parent (),
                              SLOT (handle_clear_command_window_request ()));
 
     connect (this, SIGNAL (customContextMenuRequested (QPoint)),
              this, SLOT (handleCustomContextMenuRequested (QPoint)));
@@ -175,27 +175,27 @@ protected:
     connect (xparent, SIGNAL (selectAll_signal ()),
              this, SLOT (selectAll ()));
 
     // extra interrupt action
     _interrupt_action = new QAction (this);
     addAction (_interrupt_action);
 
     _interrupt_action->setShortcut (
-            QKeySequence (Qt::ControlModifier + Qt::Key_C));
+      QKeySequence (Qt::ControlModifier + Qt::Key_C));
 
     connect (_interrupt_action, SIGNAL (triggered ()),
-            this, SLOT (terminal_interrupt ()));
+             this, SLOT (terminal_interrupt ()));
 
     // dummy (nop) action catching Ctrl-D in terminal, no connection
     _nop_action = new QAction (this);
     addAction (_nop_action);
 
     _nop_action->setShortcut (
-            QKeySequence (Qt::ControlModifier + Qt::Key_D));
+      QKeySequence (Qt::ControlModifier + Qt::Key_D));
   }
 
 private:
 
   QMenu *_contextMenu;
   QAction * _copy_action;
   QAction * _paste_action;
   QAction * _selectall_action;
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -256,17 +256,17 @@ namespace octave
         for (int j = 0; j < prompt.length (); j++)
           {
             if (j > 0)
               // FIXME: Why define and then immediately test value?
 #define RICH_TEXT 1
 #if RICH_TEXT
               prompt_string.append ("<br>");
 #else
-            prompt_string.append ("\n");
+              prompt_string.append ("\n");
 #endif
             prompt_string.append (prompt.at (j));
           }
         QLabel *plabel = new QLabel (prompt_string);
 #if RICH_TEXT
         plabel->setTextFormat (Qt::RichText);
 #endif
 #undef RICH_TEXT
diff --git a/libgui/src/documentation.cc b/libgui/src/documentation.cc
--- a/libgui/src/documentation.cc
+++ b/libgui/src/documentation.cc
@@ -52,26 +52,27 @@ namespace octave
   // of the doc dock widget
   documentation::documentation (QWidget *p)
     : QSplitter (Qt::Horizontal, p)
   {
     // Get original collection
     QString collection = getenv ("OCTAVE_QTHELP_COLLECTION");
     if (collection.isEmpty ())
       collection = QString::fromStdString (octave::config::oct_doc_dir ()
-                                         + octave::sys::file_ops::dir_sep_str ()
-                                         + "octave_interpreter.qhc");
+                                           + octave::sys::file_ops::dir_sep_str ()
+                                           + "octave_interpreter.qhc");
 
     // Setup the help engine with the original collection, use a writable copy
     // of the original collection and load the help data
     m_help_engine = new QHelpEngine (collection, this);
 
-    std::string tmpdir (octave::sys::env::getenv ("TMPDIR"));
+    QString tmpdir = QDir::tempPath();
     m_collection
-      = QString::fromStdString (octave::sys::tempnam (tmpdir, "oct-qhelp-"));
+      = QString::fromStdString (octave::sys::tempnam (tmpdir.toStdString (),
+                                                      "oct-qhelp-"));
 
     if (m_help_engine->copyCollectionFile (m_collection))
       m_help_engine->setCollectionFile (m_collection);
     else
       QMessageBox::warning (this, tr ("Octave Documentation"),
                             tr ("Could not copy help collection to temporary\n"
                                 "file. Search capabilities may be affected.\n"
                                 "%1").arg (m_help_engine->error ()));
@@ -81,20 +82,19 @@ namespace octave
 
     if (! m_help_engine->setupData())
       {
         QMessageBox::warning (this, tr ("Octave Documentation"),
                               tr ("Could not setup the data required for the\n"
                                   "documentation viewer. Only help texts in\n"
                                   "the Console Widget will be available."));
         if (m_help_engine)
-          {
-            delete m_help_engine;
-            m_help_engine = 0;
-          }
+          delete m_help_engine;
+        m_help_engine = 0;
+        return;
       }
 
     // The browser
     m_doc_browser = new documentation_browser (m_help_engine, this);
 
     // Layout contents, index and search
     QTabWidget *navi = new QTabWidget (this);
     navi->setTabsClosable (false);
@@ -137,17 +137,17 @@ namespace octave
     v_box_index->addWidget (index);
     index_all->setLayout (v_box_index);
 
     navi->addTab (index_all, tr ("Index"));
 
     connect(m_help_engine->indexWidget (),
             SIGNAL (linkActivated (const QUrl&, const QString&)),
             m_doc_browser, SLOT(handle_index_clicked (const QUrl&,
-                                                       const QString&)));
+                                                      const QString&)));
 
     connect (m_filter, SIGNAL (editTextChanged (const QString&)),
              this, SLOT(filter_update (const QString&)));
 
     connect (m_filter->lineEdit (), SIGNAL (editingFinished (void)),
              this, SLOT(filter_update_history (void)));
 
     // Search
@@ -182,21 +182,22 @@ namespace octave
     // Initial view: Contents
     m_doc_browser->setSource (QUrl (
         "qthelp://org.octave.interpreter-1.0/doc/octave.html/index.html"));
   }
 
   documentation::~documentation (void)
   {
     if (m_help_engine)
-      {
-        delete m_help_engine;
+      delete m_help_engine;
 
-        // Cleanup temporary file and directory
-        QFile file (m_collection);
+    // Cleanup temporary file and directory
+    QFile file (m_collection);
+    if (file.exists ())
+      {
         QFileInfo finfo (file);
         QString bname = finfo.fileName ();
         QDir dir = finfo.absoluteDir ();
         dir.setFilter (QDir::Dirs | QDir::NoDotAndDotDot | QDir::Hidden);
         QStringList namefilter;
         namefilter.append ("*" + bname + "*");
         foreach (QFileInfo fi, dir.entryInfoList (namefilter))
           {
@@ -251,17 +252,17 @@ namespace octave
   }
 
   void documentation::filter_update (const QString& expression)
   {
     if (! m_help_engine)
       return;
 
     QString wildcard;
-    if (expression.contains(QLatin1Char('*')))
+    if (expression.contains (QLatin1Char('*')))
       wildcard = expression;
 
     m_help_engine->indexWidget ()->filterIndices(expression, wildcard);
   }
 
   void documentation::filter_update_history (void)
   {
     QString text = m_filter->currentText ();   // get current text
@@ -329,18 +330,17 @@ namespace octave
                                                     const QString&)
   {
     setSource (url);
   }
 
   void documentation_browser::notice_settings (const QSettings *)
   { }
 
-  QVariant documentation_browser::loadResource (int type,
-                                                const QUrl &url)
-    {
-        if (url.scheme () == "qthelp")
-          return QVariant (m_help_engine->fileData(url));
-        else
-          return QTextBrowser::loadResource(type, url);
-    }
+  QVariant documentation_browser::loadResource (int type, const QUrl &url)
+  {
+    if (url.scheme () == "qthelp")
+      return QVariant (m_help_engine->fileData(url));
+    else
+      return QTextBrowser::loadResource(type, url);
+  }
 
 }
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -92,17 +92,18 @@ namespace octave
     QWidget *container = new QWidget (this);
 
     setWidget (container);
 
     connect (this, SIGNAL (open_file (const QString&)),
              main_win (), SLOT (open_file (const QString&)));
 
     connect (this, SIGNAL (displayed_directory_changed (const QString&)),
-             main_win (), SLOT (set_current_working_directory (const QString&)));
+             main_win (),
+             SLOT (set_current_working_directory (const QString&)));
 
     // Create a toolbar
     m_navigation_tool_bar = new QToolBar ("", container);
     m_navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
     m_navigation_tool_bar->setMovable (false);
 
     m_current_directory = new QComboBox (m_navigation_tool_bar);
     m_current_directory->setToolTip (tr ("Enter the path or filename"));
@@ -828,21 +829,21 @@ namespace octave
     if (dir.isEmpty ())
       dir = QDir::homePath ();
 
     set_current_directory (dir);
   }
 
   void files_dock_widget::popdownmenu_search_dir (bool)
   {
-    QString dir = QFileDialog::getExistingDirectory
-      (this, tr ("Set directory of file browser"),
-       m_file_system_model->rootPath (),
-       QFileDialog::ShowDirsOnly
-       | QFileDialog::DontUseNativeDialog);
+    QString dir = QFileDialog::getExistingDirectory (this,
+                     tr ("Set directory of file browser"),
+                     m_file_system_model->rootPath (),
+                     QFileDialog::ShowDirsOnly
+                     | QFileDialog::DontUseNativeDialog);
     set_current_directory (dir);
   }
 
   void files_dock_widget::popdownmenu_findfiles (bool)
   {
     process_find_files (m_file_system_model->rootPath ());
   }
 
@@ -857,34 +858,36 @@ namespace octave
   }
 
   void files_dock_widget::process_new_file (const QString& parent_dir)
   {
     bool ok;
 
     QString name = QInputDialog::getText (this, tr ("Create File"),
                                           tr ("Create file in\n","String ends with \\n!") + parent_dir,
-                                          QLineEdit::Normal, tr ("New File.txt"), &ok);
+                                          QLineEdit::Normal,
+                                          tr ("New File.txt"), &ok);
     if (ok && name.length () > 0)
       {
         name = parent_dir + '/' + name;
 
         QFile file (name);
         file.open (QIODevice::WriteOnly);
         m_file_system_model->revert ();
       }
   }
 
   void files_dock_widget::process_new_dir (const QString& parent_dir)
   {
     bool ok;
 
     QString name = QInputDialog::getText (this, tr ("Create Directory"),
                                           tr ("Create folder in\n","String ends with \\n!") + parent_dir,
-                                          QLineEdit::Normal, tr ("New Directory"), &ok);
+                                          QLineEdit::Normal,
+                                          tr ("New Directory"), &ok);
     if (ok && name.length () > 0)
       {
         QDir dir (parent_dir);
         dir.mkdir (name);
         m_file_system_model->revert ();
       }
   }
 
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -268,30 +268,30 @@ namespace octave
   {
     m_history_model = new QStringListModel ();
     m_sort_filter_proxy_model.setSourceModel (m_history_model);
     m_history_list_view = new QListView (this);
     m_history_list_view->setModel (&m_sort_filter_proxy_model);
     m_history_list_view->setAlternatingRowColors (true);
     m_history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
     m_history_list_view->setStatusTip (
-                                       tr ("Double-click a command to transfer it to the terminal."));
+      tr ("Double-click a command to transfer it to the terminal."));
     m_history_list_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
     m_history_list_view->setContextMenuPolicy (Qt::CustomContextMenu);
     connect (m_history_list_view,
              SIGNAL (customContextMenuRequested (const QPoint &)), this,
              SLOT (ctxMenu (const QPoint &)));
 
     m_filter = new QComboBox (this);
     m_filter->setToolTip (tr ("Enter text to filter the command history"));
     m_filter->setEditable (true);
     m_filter->setMaxCount (MaxFilterHistory);
     m_filter->setInsertPolicy (QComboBox::NoInsert);
     m_filter->setSizeAdjustPolicy (
-                                   QComboBox::AdjustToMinimumContentsLengthWithIcon);
+      QComboBox::AdjustToMinimumContentsLengthWithIcon);
     QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
     m_filter->setSizePolicy (sizePol);
     m_filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
 
     QLabel *filter_label = new QLabel (tr ("Filter"));
 
     m_filter_checkbox = new QCheckBox ();
 
@@ -316,17 +316,18 @@ namespace octave
 
     // Init state of the filter
     QSettings *settings = resource_manager::get_settings ();
 
     m_filter_shown
       = settings->value ("history_dock_widget/filter_shown",true).toBool ();
     m_filter_widget->setVisible (m_filter_shown);
 
-    m_filter->addItems (settings->value ("history_dock_widget/mru_list").toStringList ());
+    m_filter->addItems (
+      settings->value ("history_dock_widget/mru_list").toStringList ());
 
     bool filter_state
       = settings->value ("history_dock_widget/filter_active", false).toBool ();
     m_filter_checkbox->setChecked (filter_state);
     filter_activate (filter_state);
 
     // Connect signals and slots
     connect (m_filter, SIGNAL (editTextChanged (const QString&)),
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -225,20 +225,20 @@ namespace octave
     if (settings)
       notice_settings (settings, true);
 
     setFocusProxy (_edit_area);
 
     // encoding, not updated with the settings
 #if defined (Q_OS_WIN32)
     _encoding = settings->value ("editor/default_encoding", "SYSTEM")
-      .toString ();
+                .toString ();
 #else
     _encoding = settings->value ("editor/default_encoding", "UTF-8")
-      .toString ();
+                .toString ();
 #endif
     _enc_indicator->setText (_encoding);
     // no changes in encoding yet
     _new_encoding = _encoding;
   }
 
   file_editor_tab::~file_editor_tab (void)
   {
@@ -634,28 +634,28 @@ namespace octave
         _lexer_apis->cancelPreparation ();  // stop preparing if apis exists
 
         bool update_apis = false;  // flag, whether update of apis files
 
         // get path to prepared api info
 #if defined (HAVE_QSTANDARDPATHS)
         QString prep_apis_path
           = QStandardPaths::writableLocation (QStandardPaths::HomeLocation)
-          + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
+            + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #else
         QString prep_apis_path
           = QDesktopServices::storageLocation (QDesktopServices::HomeLocation)
-          + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
+            + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #endif
 
         // get settings which infos are used for octave
         bool octave_builtins = settings->value (
-                                                "editor/codeCompletion_octave_builtins", true).toBool ();
+                                 "editor/codeCompletion_octave_builtins", true).toBool ();
         bool octave_functions = settings->value (
-                                                 "editor/codeCompletion_octave_functions", true).toBool ();
+                                  "editor/codeCompletion_octave_functions", true).toBool ();
 
         if (_is_octave_file)
           {
             // Keywords and Builtins do not change, these informations can be
             // stored in prepared form in a file. Information on function are
             // changing frequently, then if functions should also be auto-
             // completed, the date of any existing file is checked.
 
@@ -709,17 +709,17 @@ namespace octave
                 // octave: get keywords from internal informations depending on
                 //         user preferences
 
                 // keywords are always used
                 add_octave_apis (Fiskeyword ());            // add new entries
 
                 interpreter& interp
                   = __get_interpreter__ (
-                                                 "file_editor_tab::update_lexer_settings");
+                      "file_editor_tab::update_lexer_settings");
 
                 if (octave_builtins)
                   add_octave_apis (F__builtins__ (interp));       // add new entries
 
                 if (octave_functions)
                   add_octave_apis (F__list_functions__ (interp)); // add new entries
 
               }
@@ -794,17 +794,17 @@ namespace octave
       {
         // Line numbers width
         auto_margin_width ();
 
         // Line numbers font
         QFont line_numbers_font = lexer->defaultFont ();
         int font_size = line_numbers_font.pointSize ();
         font_size = font_size
-          + settings->value ("editor/line_numbers_size", 0).toInt ();
+                    + settings->value ("editor/line_numbers_size", 0).toInt ();
         if (font_size < 4)
           font_size = 4;
         line_numbers_font.setPointSize (font_size);
 
         _edit_area->setMarginsFont (line_numbers_font);
       }
     else
       _edit_area->setMarginWidth (2,0);
@@ -1436,20 +1436,20 @@ namespace octave
     if (comment)
       {
         if (input_str)
           {
             bool ok;
             QSettings *settings = resource_manager::get_settings ();
 
             used_comment_str = QInputDialog::getText (
-                                                      this, tr ("Comment selected text"),
-                                                      tr ("Comment string to use:\n"), QLineEdit::Normal,
-                                                      settings->value (oct_last_comment_str, comment_str.at (0)).toString (),
-                                                      &ok);
+                                 this, tr ("Comment selected text"),
+                                 tr ("Comment string to use:\n"), QLineEdit::Normal,
+                                 settings->value (oct_last_comment_str, comment_str.at (0)).toString (),
+                                 &ok);
 
             if ((! ok) || used_comment_str.isEmpty ())
               return;  // No input, do nothing
             else
               settings->setValue (oct_last_comment_str, used_comment_str);  // Store last
           }
       }
     else
@@ -1619,18 +1619,18 @@ namespace octave
   {
     int decision = QMessageBox::Yes;
     if (_edit_area->isModified ())
       {
         // File is modified but not saved, ask user what to do.  The file
         // editor tab can't be made parent because it may be deleted depending
         // upon the response.  Instead, change the _edit_area to read only.
         QMessageBox::StandardButtons buttons = QMessageBox::Save |
-          QMessageBox::Discard |
-          QMessageBox::Cancel;
+                                               QMessageBox::Discard |
+                                               QMessageBox::Cancel;
 
         // For now, just a warning message about closing a tab that has been
         // modified seems sufficient.  Exit-condition-specific messages could
         // be achieved by making 'available_actions' a function input string.
         QString available_actions =
           tr ("Do you want to cancel closing, save or discard the changes?");
 
         QString file;
@@ -1795,17 +1795,17 @@ namespace octave
     int os_eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
     int os_eol_mode = QsciScintilla::EolMac;
 #else
     int os_eol_mode = QsciScintilla::EolUnix;
 #endif
     QSettings *settings = resource_manager::get_settings ();
     QsciScintilla::EolMode eol_mode = static_cast<QsciScintilla::EolMode> (
-                                                                           settings->value ("editor/default_eol_mode",os_eol_mode).toInt ());
+                                        settings->value ("editor/default_eol_mode",os_eol_mode).toInt ());
 
     int count_max = 0;
 
     if (count_crlf > count_max)
       {
         eol_mode = QsciScintilla::EolWindows;
         count_max = count_crlf;
       }
@@ -1877,18 +1877,18 @@ namespace octave
 #if defined (Q_OS_WIN32)
     int eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
     int eol_mode = QsciScintilla::EolMac;
 #else
     int eol_mode = QsciScintilla::EolUnix;
 #endif
     _edit_area->setEolMode (
-                            static_cast<QsciScintilla::EolMode> (
-                                                                 settings->value ("editor/default_eol_mode",eol_mode).toInt ()));
+      static_cast<QsciScintilla::EolMode> (
+        settings->value ("editor/default_eol_mode",eol_mode).toInt ()));
 
     update_eol_indicator ();
 
     update_lexer ();
 
     _edit_area->setText (commands);
     _edit_area->setModified (false); // new file is not modified yet
   }
@@ -2146,17 +2146,18 @@ namespace octave
     fileDialog->setNameFilters (filters);
     fileDialog->setDefaultSuffix ("m");
 
     if (valid_file_name ())
       {
         fileDialog->selectFile (_file_name);
         QFileInfo file_info (_file_name);
         if (file_info.suffix () != "m")
-          { // it is not an octave file
+          {
+            // it is not an octave file
             fileDialog->selectNameFilter (filters.at (1));  // "All Files"
             fileDialog->setDefaultSuffix ("");              // no default suffix
           }
       }
     else
       {
         fileDialog->selectFile ("");
         fileDialog->setDirectory (_ced);
@@ -2419,19 +2420,19 @@ namespace octave
     QVariant default_var = QColor (240, 240, 240);
     QColor setting_color = settings->value ("editor/highlight_current_line_color",
                                             default_var).value<QColor> ();
     _edit_area->setCaretLineBackgroundColor (setting_color);
     _edit_area->setCaretLineVisible
       (settings->value ("editor/highlightCurrentLine", true).toBool ());
 
     bool match_keywords = settings->value
-      ("editor/codeCompletion_keywords",true).toBool ();
+                          ("editor/codeCompletion_keywords",true).toBool ();
     bool match_document = settings->value
-      ("editor/codeCompletion_document",true).toBool ();
+                          ("editor/codeCompletion_document",true).toBool ();
 
     QsciScintilla::AutoCompletionSource source = QsciScintilla::AcsNone;
     if (match_keywords)
       if (match_document)
         source = QsciScintilla::AcsAll;
       else
         source = QsciScintilla::AcsAPIs;
     else if (match_document)
@@ -2734,17 +2735,18 @@ namespace octave
             marker *bp = nullptr;
 
             // If comes back indicating a non-zero breakpoint marker,
             // reuse it if possible
             emit find_translated_line_number (line, editor_linenr, bp);
             if (bp != nullptr)
               {
                 if ((cond == "") != (bp->get_cond () == ""))
-                  {       // can only reuse conditional bp as conditional
+                  {
+                    // can only reuse conditional bp as conditional
                     emit remove_breakpoint_via_debugger_linenr (line);
                     bp = nullptr;
                   }
                 else
                   bp->set_cond (cond);
               }
 
             if (bp == nullptr)
@@ -2944,17 +2946,17 @@ namespace octave
                                            true,    // whole words only
                                            false,   // do not wrap
                                            true,    // forward
                                            0,0,     // from the beginning
                                            false
 #if defined (HAVE_QSCI_VERSION_2_6_0)
                                            , true
 #endif
-                                           );
+                                          );
 
                 // loop over all occurrences and set the related indicator
                 int oline, ocol;
                 int wlen = word.length ();
 
                 while (find_result_available)
                   {
                     // get cursor position after having found an occurrence
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -95,26 +95,26 @@ namespace octave
 
     QMenu * debug_menu (void) { return m_debug_menu; }
 
     QToolBar * toolbar (void) { return m_tool_bar; }
 
     void insert_global_actions (QList<QAction*>);
 
     enum shared_actions_idx
-      {
-        NEW_SCRIPT_ACTION = 0,
-        NEW_FUNCTION_ACTION,
-        OPEN_ACTION,
-        FIND_FILES_ACTION,
-        UNDO_ACTION,
-        COPY_ACTION,
-        PASTE_ACTION,
-        SELECTALL_ACTION
-      };
+    {
+      NEW_SCRIPT_ACTION = 0,
+      NEW_FUNCTION_ACTION,
+      OPEN_ACTION,
+      FIND_FILES_ACTION,
+      UNDO_ACTION,
+      COPY_ACTION,
+      PASTE_ACTION,
+      SELECTALL_ACTION
+    };
 
     void handle_enter_debug_mode (void);
     void handle_exit_debug_mode (void);
 
     void check_actions (void);
     void empty_script (bool startup, bool visible);
     void restore_session (QSettings *settings);
 
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -341,34 +341,34 @@ namespace octave
                                                     _regex_check_box->isChecked (),
                                                     _case_check_box->isChecked (),
                                                     _whole_words_check_box->isChecked (),
                                                     do_forward,
                                                     true
 #if defined (HAVE_QSCI_VERSION_2_6_0)
                                                     , true
 #endif
-                                                    );
+                                                   );
 #endif
           }
         else
           {
             _find_result_available
               = _edit_area->findFirst (_search_line_edit->text (),
                                        _regex_check_box->isChecked (),
                                        _case_check_box->isChecked (),
                                        _whole_words_check_box->isChecked (),
                                        do_wrap,
                                        do_forward,
                                        line,col,
                                        true
 #if defined (HAVE_QSCI_VERSION_2_6_0)
                                        , true
 #endif
-                                       );
+                                      );
           }
       }
 
     if (_find_result_available)
       _from_start_check_box->setChecked (0);
     else if (! _rep_all)
       no_matches_message ();
   }
diff --git a/libgui/src/m-editor/marker.h b/libgui/src/m-editor/marker.h
--- a/libgui/src/m-editor/marker.h
+++ b/libgui/src/m-editor/marker.h
@@ -42,25 +42,25 @@ namespace octave
     Q_OBJECT
 
   public:
 
     // List of all marker types
     // If multiple markers are on the same line, the first one listed
     // is drawn at the back, so big ones should be first.
     enum editor_markers
-      {
-        breakpoint,
-        cond_break,
-        unsure_breakpoint,
-        bookmark,
-        debugger_position,
-        unsure_debugger_position,
-        selection
-      };
+    {
+      breakpoint,
+      cond_break,
+      unsure_breakpoint,
+      bookmark,
+      debugger_position,
+      unsure_debugger_position,
+      selection
+    };
 
     marker (QsciScintilla *edit_area, int original_linenr,
             editor_markers marker_type, const QString& condition = "");
 
     marker (QsciScintilla *edit_area, int original_linenr,
             editor_markers marker_type, int editor_linenr,
             const QString& condition = "");
 
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -327,20 +327,18 @@ namespace octave
     if (hasSelectedText ())
       contextmenu_run (true);
   }
 
   void octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
                                                      QPoint *local_pos)
   {
     long position = SendScintilla (SCI_GETCURRENTPOS);
-    long point_x  = SendScintilla
-      (SCI_POINTXFROMPOSITION,0,position);
-    long point_y  = SendScintilla
-      (SCI_POINTYFROMPOSITION,0,position);
+    long point_x  = SendScintilla (SCI_POINTXFROMPOSITION,0,position);
+    long point_y  = SendScintilla (SCI_POINTYFROMPOSITION,0,position);
     *local_pos = QPoint (point_x,point_y);  // local cursor position
     *global_pos = mapToGlobal (*local_pos); // global position of cursor
   }
 
   // determine the actual word and whether we are in an octave or matlab script
   bool octave_qscintilla::get_actual_word (void)
   {
     QPoint global_pos, local_pos;
@@ -386,20 +384,22 @@ namespace octave
 #endif
         {
           QSettings *settings = resource_manager::get_settings ();
           int comment_string;
 
           if (comment)
             {
               // The commenting string is requested
-              if (settings->contains (oct_comment_str))   // new version (radio buttons)
+              if (settings->contains (oct_comment_str))
+                // new version (radio buttons)
                 comment_string = settings->value (oct_comment_str,
                                                   oct_comment_str_d).toInt ();
-              else                                         // old version (combo box)
+              else
+                // old version (combo box)
                 comment_string = settings->value (oct_comment_str_old,
                                                   oct_comment_str_d).toInt ();
 
               return (QStringList (oct_comment_strings.at (comment_string)));
             }
           else
             {
               QStringList c_str;
@@ -802,17 +802,17 @@ namespace octave
                            true,    // whole words only
                            false,   // do not wrap
                            true,    // forward
                            0, 0,    // from the beginning
                            false
 #if defined (HAVE_QSCI_VERSION_2_6_0)
                            , true
 #endif
-                           );
+                          );
 
             while (find_result_available)
               {
                 replace (m_selection_replacement);
 
                 // FIXME: is this the right thing to do?  findNext doesn't
                 // work properly if the length of the replacement text is
                 // different from the original.
@@ -827,17 +827,17 @@ namespace octave
                                true,    // whole words only
                                false,   // do not wrap
                                true,    // forward
                                new_line, new_col,    // from new pos
                                false
 #if defined (HAVE_QSCI_VERSION_2_6_0)
                                , true
 #endif
-                               );
+                              );
               }
 
             // restore the visible area of the file, the cursor position,
             // and the selection
             setFirstVisibleLine (first_line);
             setCursorPosition (line, col);
 
             // Clear the selection.
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -40,21 +40,21 @@ namespace octave
 
   public:
 
     octave_qscintilla (QWidget *p);
 
     ~octave_qscintilla (void) = default;
 
     enum
-      {
-        ST_NONE = 0,
-        ST_LINE_COMMENT,
-        ST_BLOCK_COMMENT
-      };
+    {
+      ST_NONE = 0,
+      ST_LINE_COMMENT,
+      ST_BLOCK_COMMENT
+    };
 
     virtual void contextMenuEvent (QContextMenuEvent *e);
 
     void context_help_doc (bool);
     void context_edit (void);
     void context_run (void);
     void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
     bool get_actual_word (void);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -979,17 +979,17 @@ namespace octave
   //
   void main_window::request_open_file (void)
   {
     // Open file isn't a file_editor_tab or editor function since the file
     // might be opened in an external editor. Hence, functionality is here.
 
     QSettings *settings = resource_manager::get_settings ();
     bool is_internal = m_editor_window
-      && ! settings->value ("useCustomFileEditor",false).toBool ();
+                       && ! settings->value ("useCustomFileEditor",false).toBool ();
 
     // Create a NonModal message.
     QWidget *p = this;
     if (is_internal)
       p = m_editor_window;
     QFileDialog *fileDialog = new QFileDialog (p);
     fileDialog->setNameFilter (tr ("Octave Files (*.m);;All Files (*)"));
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -77,17 +77,17 @@ namespace octave
     vbox_layout->addWidget (_stacked_widget);
 
     hbox_layout = new QHBoxLayout ();
     vbox_layout->addLayout (hbox_layout);
 
     _search_line_edit = new QLineEdit (this);
 #if defined (HAVE_QLINEEDIT_SETPLACEHOLDERTEXT)
     _search_line_edit->setPlaceholderText (
-                                           tr ("Type here and press \'Return\' to search"));
+      tr ("Type here and press \'Return\' to search"));
 #endif
     hbox_layout->addWidget (_search_line_edit);
 
     _search_check_box = new QCheckBox (tr ("Global search"));
     hbox_layout->addWidget (_search_check_box);
 
     _close_action = add_action (_tab_bar->get_context_menu (),
           resource_manager::icon ("window-close",false), tr ("&Close"),
@@ -96,17 +96,17 @@ namespace octave
           resource_manager::icon ("window-close",false), tr ("Close &Other Tabs"),
           this, SLOT (request_close_other_tabs (bool)));
     _close_action->setEnabled (false);
     _close_others_action->setEnabled (false);
 
     connect (_tab_bar, SIGNAL (close_current_tab_signal (bool)),
              this, SLOT (request_close_tab (bool)));
     connect (_tab_bar, SIGNAL (tabCloseRequested (int)),
-              this, SLOT (close_tab (int)));
+             this, SLOT (close_tab (int)));
     connect (_tab_bar, SIGNAL (currentChanged (int)), this,
              SLOT (current_tab_changed (int)));
     connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
     connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
     connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
     // Actions for tab navigation
     m_switch_left_tab_action
@@ -135,21 +135,21 @@ namespace octave
     if (menu)
       a = menu->addAction (icon, text, receiver, member);
     else
       {
         a = new QAction (this);
         connect (a, SIGNAL (triggered ()), receiver, member);
       }
 
-      addAction (a);  // important for shortcut context
-      a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+    addAction (a);  // important for shortcut context
+    a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
 
-      return a;
-    }
+    return a;
+  }
 
   // Slot for the close tab action
   void webinfo::request_close_tab (bool)
   {
     close_tab (_tab_bar->currentIndex ());
   }
 
   // Slot for the close other tabs action
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   class resource_manager : public QObject
   {
     Q_OBJECT
 
   protected:
 
-    public:
+  public:
 
     resource_manager (void);
 
     // No copying!
 
     resource_manager (const resource_manager&) = delete;
 
     resource_manager& operator = (const resource_manager&) = delete;
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -77,17 +77,18 @@ get_valid_lexer_styles (QsciLexer *lexer
       if ((lexer->description (actual_style)) != "")  // valid style
         styles[max_style++] = actual_style;
       actual_style++;
     }
   return max_style;
 }
 
 static void
-read_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer, QSettings *settings)
+read_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
+                     QSettings *settings)
 {
   lexer->readSettings (*settings);
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (max_style);
   QVector<QFontComboBox*> select_font (max_style);
@@ -170,20 +171,21 @@ read_lexer_settings (Ui::settings_dialog
   scroll_area_contents->setLayout (style_grid);
   scroll_area->setWidget (scroll_area_contents);
   ui->tabs_editor_lexers->addTab (scroll_area, lexer->language ());
 
   ui->tabs_editor_lexers->setCurrentIndex (settings->value ("settings/last_editor_styles_tab", 0).toInt ());
 }
 
 static void
-write_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer, QSettings *settings)
+write_lexer_settings (Ui::settings_dialog *ui, QsciLexer *lexer,
+                      QSettings *settings)
 {
   QWidget *tab = ui->tabs_editor_lexers->
-    findChild <QWidget *> (QString (lexer->language ()) + "_styles");
+                 findChild <QWidget *> (QString (lexer->language ()) + "_styles");
   int styles[MaxLexerStyles];  // array for saving valid styles
                                // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QFontComboBox *select_font;
   QSpinBox *font_size;
   QCheckBox *attrib_font[3];
   color_picker *color;
   color_picker *bg_color;
@@ -247,17 +249,18 @@ write_lexer_settings (Ui::settings_dialo
               else
                 lexer->setPaper (bg_color->color (), styles[i]);
             }
         }
     }
 
   lexer->writeSettings (*settings);
 
-  settings->setValue ("settings/last_editor_styles_tab", ui->tabs_editor_lexers->currentIndex ());
+  settings->setValue ("settings/last_editor_styles_tab",
+                      ui->tabs_editor_lexers->currentIndex ());
   settings->sync ();
 }
 
 #endif
 
 settings_dialog::settings_dialog (QWidget *p, const QString& desired_tab):
   QDialog (p), ui (new Ui::settings_dialog)
 {
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -639,17 +639,17 @@ namespace octave
         if (file.isEmpty ())
           return false;
 
         QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
 
         if (! osc_settings)
           {
             qWarning () << tr ("Failed to open %1 as octave shortcut file")
-              .arg (file);
+                        .arg (file);
             return false;
           }
         else
           {
             if (action == OSC_IMPORT)
               import_shortcuts (osc_settings);   // import (special action)
             else if (action == OSC_EXPORT)
               do_write_shortcuts (osc_settings, false); // export, (save settings)
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -56,21 +56,21 @@ namespace octave
 
   class shortcut_manager : public QWidget
   {
     Q_OBJECT
 
   public:
 
     enum
-      {
-        OSC_IMPORT  = 0,
-        OSC_EXPORT  = 1,
-        OSC_DEFAULT = 2
-      };
+    {
+      OSC_IMPORT  = 0,
+      OSC_EXPORT  = 1,
+      OSC_DEFAULT = 2
+    };
 
     shortcut_manager (void);
 
     // No copying!
 
     shortcut_manager (const shortcut_manager&) = delete;
 
     shortcut_manager& operator = (const shortcut_manager&) = delete;
diff --git a/libgui/src/variable-editor.cc b/libgui/src/variable-editor.cc
--- a/libgui/src/variable-editor.cc
+++ b/libgui/src/variable-editor.cc
@@ -475,17 +475,18 @@ namespace octave
       return;
 
     QString selarg = selected_to_octave ();
     if (! selarg.isEmpty ())
       emit command_signal (cmd.arg (selarg));
   }
 
   void
-  variable_editor_view::add_edit_actions (QMenu *menu, const QString& qualifier_string)
+  variable_editor_view::add_edit_actions (QMenu *menu,
+                                          const QString& qualifier_string)
   {
     menu->addAction (resource_manager::icon ("edit-cut"),
                      tr ("Cut") + qualifier_string,
                      this, SLOT (cutClipboard ()));
 
     menu->addAction (resource_manager::icon ("edit-copy"),
                      tr ("Copy") + qualifier_string,
                      this, SLOT (copyClipboard ()));
@@ -1031,17 +1032,18 @@ namespace octave
 
     connect (this, SIGNAL (command_signal (const QString&)),
              p, SLOT (execute_command_in_terminal (const QString&)));
   }
 
   // Add an action to a menu or the widget itself.
 
   QAction*
-  variable_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
+  variable_editor::add_action (QMenu *menu, const QIcon& icon,
+                               const QString& text,
                                const char *member)
   {
     QAction *a;
 
     if (menu)
       a = menu->addAction (icon, text, this, member);
     else
       {
@@ -1398,29 +1400,29 @@ namespace octave
   // Also updates the font.
 
   void variable_editor::update_colors (void)
   {
     m_stylesheet = "";
 
     if (m_table_colors.length () > 0)
       m_stylesheet += "QTableView::item{ foreground-color: "
-        + m_table_colors[0].name () +" }";
+                      + m_table_colors[0].name () +" }";
 
     if (m_table_colors.length () > 1)
       m_stylesheet += "QTableView::item{ background-color: "
-        + m_table_colors[1].name () +" }";
+                      + m_table_colors[1].name () +" }";
 
     if (m_table_colors.length () > 2)
       m_stylesheet += "QTableView::item{ selection-color: "
-        + m_table_colors[2].name () +" }";
+                      + m_table_colors[2].name () +" }";
 
     if (m_table_colors.length () > 3)
       m_stylesheet += "QTableView::item:selected{ background-color: "
-        + m_table_colors[3].name () +" }";
+                      + m_table_colors[3].name () +" }";
 
     if (m_table_colors.length () > 4 && m_alternate_rows)
       {
         m_stylesheet
           += "QTableView::item:alternate{ background-color: "
           + m_table_colors[4].name () +" }";
 
         m_stylesheet
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -105,17 +105,18 @@ namespace octave
         // Set the empty widget to have our layout.
         widget ()->setLayout (ws_layout);
 
         // Initialize collapse/expand state of the workspace subcategories.
 
         //enable sorting (setting column and order after model was set)
         m_view->setSortingEnabled (true);
         // Initialize column order and width of the workspace
-        m_view->horizontalHeader ()->restoreState (settings->value ("workspaceview/column_state").toByteArray ());
+        m_view->horizontalHeader ()->restoreState (
+          settings->value ("workspaceview/column_state").toByteArray ());
 
         // Set header properties for sorting
 #if defined (HAVE_QHEADERVIEW_SETSECTIONSCLICKABLE)
         m_view->horizontalHeader ()->setSectionsClickable (true);
 #else
         m_view->horizontalHeader ()->setClickable (true);
 #endif
 #if defined (HAVE_QHEADERVIEW_SETSECTIONSMOVABLE)
diff --git a/libinterp/build-env.in.cc b/libinterp/build-env.in.cc
--- a/libinterp/build-env.in.cc
+++ b/libinterp/build-env.in.cc
@@ -284,19 +284,21 @@ namespace octave
     const char *SUITESPARSECONFIG_LIBS = %OCTAVE_CONF_SUITESPARSECONFIG_LIBS%;
 
     const char *SUNDIALS_IDA_CPPFLAGS = %OCTAVE_CONF_SUNDIALS_IDA_CPPFLAGS%;
 
     const char *SUNDIALS_IDA_LDFLAGS = %OCTAVE_CONF_SUNDIALS_IDA_LDFLAGS%;
 
     const char *SUNDIALS_IDA_LIBS = %OCTAVE_CONF_SUNDIALS_IDA_LIBS%;
 
-    const char *SUNDIALS_NVECSERIAL_CPPFLAGS = %OCTAVE_CONF_SUNDIALS_NVECSERIAL_CPPFLAGS%;
+    const char *SUNDIALS_NVECSERIAL_CPPFLAGS =
+      %OCTAVE_CONF_SUNDIALS_NVECSERIAL_CPPFLAGS%;
 
-    const char *SUNDIALS_NVECSERIAL_LDFLAGS = %OCTAVE_CONF_SUNDIALS_NVECSERIAL_LDFLAGS%;
+    const char *SUNDIALS_NVECSERIAL_LDFLAGS =
+      %OCTAVE_CONF_SUNDIALS_NVECSERIAL_LDFLAGS%;
 
     const char *SUNDIALS_NVECSERIAL_LIBS = %OCTAVE_CONF_SUNDIALS_NVECSERIAL_LIBS%;
 
     const char *TERM_LIBS = %OCTAVE_CONF_TERM_LIBS%;
 
     const char *UMFPACK_CPPFLAGS = %OCTAVE_CONF_UMFPACK_CPPFLAGS%;
 
     const char *UMFPACK_LDFLAGS = %OCTAVE_CONF_UMFPACK_LDFLAGS%;
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -166,17 +166,17 @@ Undocumented internal function.
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       SparseMatrix speye (DiagMatrix (sm.cols (), sm.cols (), 1.0));
 
       ilu_0 <SparseComplexMatrix, Complex> (sm, milu);
 
       retval(0) = speye +
-        Ftril (ovl (sm, -1))(0).sparse_complex_matrix_value ();
+                  Ftril (ovl (sm, -1))(0).sparse_complex_matrix_value ();
       retval(1) = Ftriu (ovl (sm))(0).sparse_complex_matrix_value ();
     }
 
   return retval;
 }
 
 template <typename octave_matrix_t, typename T>
 void ilu_crout (octave_matrix_t& sm_l, octave_matrix_t& sm_u,
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -214,17 +214,18 @@ try_cellfun_internal_ops (const octave_v
 
       retval(0) = result;
     }
 
   return retval;
 }
 
 static void
-get_mapper_fun_options (octave::symbol_table& symtab, const octave_value_list& args,
+get_mapper_fun_options (octave::symbol_table& symtab,
+                        const octave_value_list& args,
                         int& nargin, bool& uniform_output,
                         octave_value& error_handler)
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
       std::string arg = args(nargin-2).string_value ();
 
       size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
@@ -494,17 +495,17 @@ v = cellfun (@@det, a); # faster
           }
 
         // Okay, we tried, doesn't work, let's do the best we can instead
         // and avoid polymorphic calls for each element of the array.
         func = f;
       }
   }
 
- nevermind:
+nevermind:
 
   // Extract cell arguments.
 
   octave_value_list inputlist (nargin, octave_value ());
 
   OCTAVE_LOCAL_BUFFER (Cell, inputs, nargin);
   OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
@@ -2199,18 +2200,18 @@ static Cell
 do_cellslices_nda (const NDA& array,
                    const Array<octave_idx_type>& lb,
                    const Array<octave_idx_type>& ub,
                    int dim = -1)
 {
   octave_idx_type n = lb.numel ();
   Cell retval (1, n);
   if (array.isvector () && (dim == -1
-                             || (dim == 0 && array.columns () == 1)
-                             || (dim == 1 && array.rows () == 1)))
+                            || (dim == 0 && array.columns () == 1)
+                            || (dim == 1 && array.rows () == 1)))
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval(i) = array.index (idx_vector (lb(i) - 1, ub(i)));
     }
   else
     {
       const dim_vector dv = array.dims ();
       int ndims = dv.ndims ();
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1620,17 +1620,18 @@ attempt_type_conversion (const octave_va
   octave_value retval;
 
   // First try to find function in the class of OV that can convert to
   // the dispatch type dtype.  It will have the name of the dispatch
   // type.
 
   std::string cname = ov.class_name ();
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("attempt_type_conversion");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("attempt_type_conversion");
 
   octave_value fcn = symtab.find_method (dtype, cname);
 
   if (fcn.is_defined ())
     {
       octave_value_list result;
 
       try
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -78,17 +78,18 @@ octave_change_to_directory (const std::s
   if (! cd_ok)
     error ("%s: %s", newdir.c_str (), std::strerror (errno));
 
   Vlast_chdir_time.stamp ();
 
   // FIXME: should these actions be handled as a list of functions
   // to call so users can add their own chdir handlers?
 
-  octave::load_path& lp = octave::__get_load_path__ ("octave_change_to_directory");
+  octave::load_path& lp =
+    octave::__get_load_path__ ("octave_change_to_directory");
 
   lp.update ();
 
   octave_link::change_directory (octave::sys::env::get_current_directory ());
 
   return cd_ok;
 }
 
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -94,20 +94,20 @@ namespace octave
               bool relative = false);
 
     octave_function *
     load_mex (const std::string& fcn_name,
               const std::string& file_name = "",
               bool relative = false);
 
     bool remove_oct (const std::string& fcn_name,
-                            dynamic_library& shl);
+                     dynamic_library& shl);
 
     bool remove_mex (const std::string& fcn_name,
-                            dynamic_library& shl);
+                     dynamic_library& shl);
 
   private:
 
     void clear_function (const std::string& fcn_name);
 
     void clear (dynamic_library& oct_file);
 
     interpreter& m_interpreter;
diff --git a/libinterp/corefcn/environment.cc b/libinterp/corefcn/environment.cc
--- a/libinterp/corefcn/environment.cc
+++ b/libinterp/corefcn/environment.cc
@@ -53,19 +53,19 @@ static void append_to_shell_path (const 
   if (shell_path.empty ())
     octave::sys::env::putenv ("PATH", exec_path);
   else
     {
       // If PATH doesn't already have exec_path, append it.
       // FIXME: should we search for the elements individually, and
       // only append those that are missing?
 
-    std::string path_sep = octave::directory_path::path_sep_str ();
+      std::string path_sep = octave::directory_path::path_sep_str ();
 
-    if (shell_path.find (exec_path) == std::string::npos)
+      if (shell_path.find (exec_path) == std::string::npos)
         octave::sys::env::putenv ("PATH", shell_path + path_sep + exec_path);
     }
 }
 
 namespace octave
 {
   octave_value
   environment::editor (const octave_value_list& args, int nargout)
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -329,17 +329,17 @@ pr_where (std::ostream& os, const char *
 
       frame.name = frm.fcn_name ();
       frame.line = frm.line ();
       frame.column = frm.column ();
 
       frames.push_back (frame);
     }
 
-    pr_where (os, who, frames);
+  pr_where (os, who, frames);
 }
 
 octave::execution_exception
 make_execution_exception (const char *who)
 {
   std::ostringstream buf;
 
   pr_where (buf, who);
diff --git a/libinterp/corefcn/fcn-info.cc b/libinterp/corefcn/fcn-info.cc
--- a/libinterp/corefcn/fcn-info.cc
+++ b/libinterp/corefcn/fcn-info.cc
@@ -93,17 +93,17 @@ namespace octave
       = __get_load_path__ ("fcn_info::fcn_info_rep::load_class_constructor");
 
     std::string file_name = lp.find_method (name, name, dir_name, package_name);
 
     if (! file_name.empty ())
       {
         octave_value ov_fcn
           = load_fcn_from_file (file_name, dir_name, name,
-                                        package_name);
+                                package_name);
 
         if (ov_fcn.is_defined ())
           {
             // Note: ov_fcn may be an octave_classdef_meta object instead
             // of the actual constructor function.
 
             retval = ov_fcn;
 
@@ -166,17 +166,17 @@ namespace octave
 
             std::string file_name = lp.find_method (dispatch_type, name,
                                                     dir_name);
 
             if (! file_name.empty ())
               {
                 octave_value ov_fcn
                   = load_fcn_from_file (file_name, dir_name,
-                                                dispatch_type);
+                                        dispatch_type);
 
                 if (ov_fcn.is_defined ())
                   {
                     octave_function *tmpfcn = ov_fcn.function_value ();
 
                     if (tmpfcn && tmpfcn->is_class_method (dispatch_type))
                       {
                         retval = ov_fcn;
@@ -587,17 +587,18 @@ namespace octave
     if (cmdline_function.is_defined ())
       return cmdline_function;
 
     // Private function.
 
     symbol_scope curr_scope
       = __get_current_scope__ ("fcn_info::fcn_info_rep::x_builtin_find");
 
-    octave_user_function *current_fcn = curr_scope ? curr_scope.function () : nullptr;
+    octave_user_function *current_fcn = curr_scope ? curr_scope.function ()
+                                                   : nullptr;
 
     if (current_fcn)
       {
         std::string dir_name = current_fcn->dir_name ();
 
         if (! dir_name.empty ())
           {
             str_val_iterator q = private_functions.find (dir_name);
@@ -714,18 +715,17 @@ namespace octave
 
         if (! file_name.empty ())
           {
             size_t pos = file_name.find_last_of (sys::file_ops::dir_sep_chars ());
 
             std::string dir_name = file_name.substr (0, pos);
 
             octave_value ov_fcn
-              = load_fcn_from_file (file_name, dir_name, "", "",
-                                            name, true);
+              = load_fcn_from_file (file_name, dir_name, "", "", name, true);
 
             if (ov_fcn.is_defined ())
               autoload_function = octave_value (ov_fcn);
           }
       }
 
     return autoload_function;
   }
@@ -737,26 +737,26 @@ namespace octave
 
     if (function_on_path.is_defined ())
       out_of_date_check (function_on_path);
 
     if (function_on_path.is_undefined ())
       {
         std::string dir_name;
 
-        load_path& lp = __get_load_path__ ("fcn_info::fcn_info_rep::find_user_function");
+        load_path& lp =
+          __get_load_path__ ("fcn_info::fcn_info_rep::find_user_function");
 
 
         std::string file_name = lp.find_fcn (name, dir_name, package_name);
 
         if (! file_name.empty ())
           {
-            octave_value ov_fcn
-              = load_fcn_from_file (file_name, dir_name, "",
-                                            package_name);
+            octave_value ov_fcn =
+              load_fcn_from_file (file_name, dir_name, "", package_name);
 
             if (ov_fcn.is_defined ())
               function_on_path = ov_fcn;
           }
       }
 
     return function_on_path;
   }
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1061,18 +1061,18 @@ namespace octave
     idx(0) = idx_vector::make_range (height - 1, -1, height);
     idx(1) = idx_vector::colon;
     idx(2) = idx_vector::colon;
 
     return pix.permute (perm).index (idx);
 
 #else
 
-  // This shouldn't happen because construction of opengl_renderer
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of opengl_renderer
+    // objects is supposed to be impossible if OpenGL is not available.
 
     octave_unused_parameter (width);
     octave_unused_parameter (height);
 
     panic_impossible ();
 
 #endif
   }
@@ -1212,19 +1212,19 @@ namespace octave
 
     if (! props.is_visible ())
       return;
 
     bool xySym = props.get_xySym ();
     bool layer2Dtop = props.get_layer2Dtop ();
     bool is2d = props.get_is2D ();
     bool isXOrigin = props.xaxislocation_is ("origin")
-                       && ! props.yscale_is ("log");
+                     && ! props.yscale_is ("log");
     bool isYOrigin = props.yaxislocation_is ("origin")
-                       && ! props.xscale_is ("log");
+                     && ! props.xscale_is ("log");
     bool boxFull = (props.get_boxstyle () == "full");
     double linewidth = props.get_linewidth ();
     double xPlane = props.get_xPlane ();
     double yPlane = props.get_yPlane ();
     double zPlane = props.get_zPlane ();
     double xPlaneN = props.get_xPlaneN ();
     double yPlaneN = props.get_yPlaneN ();
     double zPlaneN = props.get_zPlaneN ();
@@ -1443,18 +1443,17 @@ namespace octave
                        0, (zstate != AXE_DEPTH_DIR));
 
         set_color (props.get_xcolor_rgb ());
 
         // axis line
         double y_axis_pos = 0.;
         if (is_origin)
           {
-            y_axis_pos = math::max (math::min (0., y_max),
-                                            y_min);
+            y_axis_pos = math::max (math::min (0., y_max), y_min);
             glBegin (GL_LINES);
             set_color (props.get_ycolor_rgb ());
             glVertex3d (x_min, y_axis_pos, zpTick);
             glVertex3d (x_max, y_axis_pos, zpTick);
             glEnd ();
           }
 
         // minor tick marks
@@ -1627,18 +1626,17 @@ namespace octave
                        1, (zstate != AXE_DEPTH_DIR));
 
         set_color (props.get_ycolor_rgb ());
 
         // axis line
         double x_axis_pos = 0.;
         if (is_origin)
           {
-            x_axis_pos = math::max (math::min (0., x_max),
-                                            x_min);
+            x_axis_pos = math::max (math::min (0., x_max), x_min);
             glBegin (GL_LINES);
             set_color (props.get_ycolor_rgb ());
             glVertex3d (x_axis_pos, y_min, zpTick);
             glVertex3d (x_axis_pos, y_max, zpTick);
             glEnd ();
           }
 
         // minor tick marks
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -203,28 +203,28 @@ namespace octave
 
       if (s == "-" && ! use_stipple)
         gl2psDisable (GL2PS_LINE_STIPPLE);
       else
         gl2psEnable (GL2PS_LINE_STIPPLE);
     }
 
     void set_linecap (const std::string& s)
-      {
-        opengl_renderer::set_linejoin (s);
+    {
+      opengl_renderer::set_linejoin (s);
 
 #if defined (HAVE_GL2PSLINEJOIN)
-        if (s == "butt")
-          gl2psLineCap (GL2PS_LINE_CAP_BUTT);
-        else if (s == "square")
-          gl2psLineCap (GL2PS_LINE_CAP_SQUARE);
-        else if (s == "round")
-          gl2psLineCap (GL2PS_LINE_CAP_ROUND);
+      if (s == "butt")
+        gl2psLineCap (GL2PS_LINE_CAP_BUTT);
+      else if (s == "square")
+        gl2psLineCap (GL2PS_LINE_CAP_SQUARE);
+      else if (s == "round")
+        gl2psLineCap (GL2PS_LINE_CAP_ROUND);
 #endif
-      }
+    }
 
     void set_linejoin (const std::string& s)
     {
       opengl_renderer::set_linejoin (s);
 
 #if defined (HAVE_GL2PSLINEJOIN)
       if (s == "round")
         gl2psLineJoin (GL2PS_LINE_JOIN_ROUND);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2773,27 +2773,27 @@ reparent (const octave_value& ov, const 
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
   octave_value val = xget (0, "currentfigure");
 
   return val.isempty () ? octave::numeric_limits<double>::NaN ()
-                         : val.double_value ();
+                        : val.double_value ();
 }
 
 // This function is NOT equivalent to the scripting language function gca.
 graphics_handle
 gca (void)
 {
   octave_value val = xget (gcf (), "currentaxes");
 
   return val.isempty () ? octave::numeric_limits<double>::NaN ()
-                         : val.double_value ();
+                        : val.double_value ();
 }
 
 static void
 delete_graphics_object (const graphics_handle& h)
 {
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
@@ -4831,17 +4831,17 @@ axes::properties::init (void)
   xset (title.handle_value (), "clipping", "off");
 
   xset (xlabel.handle_value (), "__autopos_tag__", "xlabel");
   xset (ylabel.handle_value (), "__autopos_tag__", "ylabel");
   xset (zlabel.handle_value (), "__autopos_tag__", "zlabel");
   xset (title.handle_value (), "__autopos_tag__", "title");
 
   double fs = labelfontsizemultiplier.double_value () *
-    fontsize.double_value ();
+              fontsize.double_value ();
   xset (xlabel.handle_value (), "fontsize", octave_value (fs));
   xset (ylabel.handle_value (), "fontsize", octave_value (fs));
   xset (zlabel.handle_value (), "fontsize", octave_value (fs));
   fs = titlefontsizemultiplier.double_value () * fontsize.double_value ();
   xset (title.handle_value (), "fontsize", octave_value (fs));
   xset (title.handle_value (), "fontweight", titlefontweight.get ());
 
   adopt (xlabel.handle_value ());
@@ -6866,27 +6866,27 @@ axes::properties::update_units (const ca
   Matrix parent_bb
     = parent_go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
   caseless_str new_units = get_units ();
   position.set (octave_value (convert_position (get_position ().matrix_value (),
                                                 old_units, new_units,
                                                 parent_bb)),
                                                 false);
   outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (),
-                                                old_units, new_units,
-                                                parent_bb)),
-                                                false);
+                                                     old_units, new_units,
+                                                     parent_bb)),
+                                                     false);
   tightinset.set (octave_value (convert_position (get_tightinset ().matrix_value (),
-                                                old_units, new_units,
-                                                parent_bb)),
-                                                false);
+                                                  old_units, new_units,
+                                                  parent_bb)),
+                                                  false);
   looseinset.set (octave_value (convert_position (get_looseinset ().matrix_value (),
-                                                old_units, new_units,
-                                                parent_bb)),
-                                                false);
+                                                  old_units, new_units,
+                                                  parent_bb)),
+                                                  false);
 }
 
 void
 axes::properties::set_fontunits (const octave_value& val)
 {
   caseless_str old_fontunits = get_fontunits ();
 
   if (fontunits.set (val, true))
@@ -7450,17 +7450,17 @@ axes::properties::calc_ticks_and_lims (a
           if (is_logscale)
             {
               tmp_lims(0) = std::pow (10., tmp_lims(0));
               tmp_lims(1) = std::pow (10., tmp_lims(1));
               if (tmp_lims(0) <= 0)
                 tmp_lims(0) = std::pow (10., lo);
               if (is_negative)
                 {
-              double tmp = tmp_lims(0);
+                  double tmp = tmp_lims(0);
                   tmp_lims(0) = -tmp_lims(1);
                   tmp_lims(1) = -tmp;
                 }
             }
           lims = tmp_lims;
         }
       else
         {
@@ -9513,17 +9513,17 @@ uicontrol::properties::set_style (const 
     error ("set: cannot change the style of a uicontrol object after creation.");
 
   style = st;
 
   // if we know know what we are, can override value for listbox and popupmenu
   if (style_is ("listbox") || style_is ("popupmenu"))
     {
       Matrix v = value.get ().matrix_value ();
-      if(v.numel () == 1 && v (0) == 0)
+      if (v.numel () == 1 && v (0) == 0)
         value.set (octave_value (1));
     }
 }
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
 {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1233,32 +1233,32 @@ protected:
         if (maxval.second && maxval.first < new_val)
           error (R"(set: "%s" must be less than or equal to %g)",
                  get_name ().c_str (), maxval.first);
         else if (! maxval.second && maxval.first <= new_val)
           error (R"(set: "%s" must be less than %g)",
                  get_name ().c_str (), maxval.first);
       }
 
-      if (finite_constraint == NO_CHECK) { /* do nothing */ }
-      else if (finite_constraint == FINITE)
-        {
-          if (! octave::math::isfinite (new_val))
-            error (R"(set: "%s" must be finite)", get_name ().c_str ());
-        }
-      else if (finite_constraint == NOT_NAN)
-        {
-          if (octave::math::isnan (new_val))
-            error (R"(set: "%s" must not be nan)", get_name ().c_str ());
-        }
-      else if (finite_constraint == NOT_INF)
-        {
-          if (octave::math::isinf (new_val))
-            error (R"(set: "%s" must not be infinite)", get_name ().c_str ());
-        }
+    if (finite_constraint == NO_CHECK) { /* do nothing */ }
+    else if (finite_constraint == FINITE)
+      {
+        if (! octave::math::isfinite (new_val))
+          error (R"(set: "%s" must be finite)", get_name ().c_str ());
+      }
+    else if (finite_constraint == NOT_NAN)
+      {
+        if (octave::math::isnan (new_val))
+          error (R"(set: "%s" must not be nan)", get_name ().c_str ());
+      }
+    else if (finite_constraint == NOT_INF)
+      {
+        if (octave::math::isinf (new_val))
+          error (R"(set: "%s" must not be infinite)", get_name ().c_str ());
+      }
 
     if (new_val != current_val)
       {
         current_val = new_val;
         return true;
       }
 
     return false;
@@ -2376,17 +2376,17 @@ protected:
     any_property userdata , Matrix ()
     bool_property visible , "on"
 
     // Octave-specific properties
     bool_property __modified__ hs , "on"
     graphics_handle __myhandle__ fhrs , mh
   END_PROPERTIES
 
-    virtual void update_handlevisibility (void);
+  virtual void update_handlevisibility (void);
 
 protected:
   struct cmp_caseless_str
   {
     bool operator () (const caseless_str& a, const caseless_str& b) const
     {
       std::string a1 = a;
       std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
@@ -4312,20 +4312,20 @@ public:
       row_vector_property zlim hlr , Matrix ()
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "off"
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        linewidth.add_constraint ("min", 0, false);
-        markersize.add_constraint ("min", 0, false);
-      }
+    {
+      linewidth.add_constraint ("min", 0, false);
+      markersize.add_constraint ("min", 0, false);
+    }
 
   private:
     Matrix compute_xlim (void) const;
     Matrix compute_ylim (void) const;
 
     void update_xdata (void) { set_xlim (compute_xlim ()); }
 
     void update_ydata (void) { set_ylim (compute_ylim ()); }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -532,18 +532,18 @@ namespace octave
 
             h = fcn->doc_string ();
 
             retval = true;
 
             w = fcn->fcn_file_name ();
 
             if (w.empty ())
-              w = fcn->is_user_function ()
-                ? "command-line function" : "built-in function";
+              w = fcn->is_user_function () ? "command-line function"
+                                           : "built-in function";
           }
       }
 
     return retval;
   }
 
   bool help_system::raw_help_from_file (const std::string& nm,
                                         std::string& h, std::string& file,
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -941,19 +941,18 @@ namespace octave
     octave_bad_alloc_hook = nullptr;
 
     catch_interrupts ();
 
     octave_initialized = true;
 
     // The big loop.
 
-    lexer *lxr = (application::interactive ()
-                          ? new lexer ()
-                          : new lexer (stdin));
+    lexer *lxr = (application::interactive () ? new lexer ()
+                                              : new lexer (stdin));
 
     parser parser (*lxr);
 
     int retval = 0;
     do
       {
         try
           {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -703,17 +703,17 @@ namespace octave
         octave_idx_type len = all_files.numel ();
 
         for (octave_idx_type i = 0; i < len; i++)
           {
             for (octave_idx_type j = 0; j < rel_flen; j++)
               {
                 if (all_files[i] == rel_flist[j])
                   retlist.push_back (sys::file_ops::concat (di.dir_name,
-                                                                    rel_flist[j]));
+                                                            rel_flist[j]));
               }
           }
       }
 
     return retlist;
   }
 
   string_vector
@@ -1853,17 +1853,18 @@ namespace octave
                     break;
                   }
               }
           }
       }
   }
 
   void
-  load_path::package_info::move_method_map (const std::string& dir_name, bool at_end)
+  load_path::package_info::move_method_map (const std::string& dir_name,
+                                            bool at_end)
   {
     for (auto& cls_fnmap : method_map)
       {
         std::string class_name = cls_fnmap.first;
 
         fcn_map_type& fn_map = cls_fnmap.second;
 
         std::string full_dir_name
@@ -2261,17 +2262,17 @@ Restore Octave's path to its initial sta
 }
 
 // Return Octave's original default list of directories in which to
 // search for function files.  This corresponds to the path that
 // exists prior to running the system's octaverc file or the user's
 // ~/.octaverc file
 
 DEFMETHOD (__pathorig__, interp, , ,
-          doc: /* -*- texinfo -*-
+           doc: /* -*- texinfo -*-
 @deftypefn {} {@var{val} =} __pathorig__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
   octave::load_path& lp = interp.get_load_path ();
 
   return ovl (lp.system_path ());
 }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1328,17 +1328,18 @@ save_vars (const string_vector& argv, in
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("dump_octave_core");
 
   octave::symbol_scope top_scope = symtab.top_scope ();
 
   octave::symbol_record::context_id context = top_scope.current_context ();
 
   std::list<octave::symbol_record> vars = top_scope.all_variables ();
 
   double save_mem_size = 0;
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1108,16 +1108,17 @@ read_mat5_binary_element (std::istream& 
                         (READ_PAD (is_small_data_element, len)));
             }
 
           name[len] = '\0';
           classname = name;
         }
       }
       // Fall-through
+
     case MAT_FILE_STRUCT_CLASS:
       {
         octave_map m (dims);
         int32_t fn_type;
         int32_t fn_len;
         int32_t field_name_length;
 
         // field name length subelement -- actually the maximum length
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -1128,18 +1128,18 @@ public:
     mxLogical *lpr = static_cast<mxLogical *> (pr);
     lpr[0] = val;
   }
 
   mxArray_number (const char *str)
     : mxArray_matlab (mxCHAR_CLASS,
                       str ? (strlen (str) ? 1 : 0) : 0,
                       str ? strlen (str) : 0),
-    pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-    pi (nullptr)
+      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
+      pi (nullptr)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
     mwSize nel = get_number_of_elements ();
     for (mwIndex i = 0; i < nel; i++)
       cpr[i] = str[i];
   }
 
   // FIXME: ???
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -220,21 +220,21 @@ namespace octave
   }
 
   class
   scanf_format_elt
   {
   public:
 
     enum special_conversion
-      {
-        whitespace_conversion = 1,
-        literal_conversion = 2,
-        null = 3
-      };
+    {
+      whitespace_conversion = 1,
+      literal_conversion = 2,
+      null = 3
+    };
 
     scanf_format_elt (const std::string& txt = "", int w = 0, bool d = false,
                       char typ = '\0', char mod = '\0',
                       const std::string& ch_class = "")
       : text (txt), width (w), discard (d), type (typ),
         modifier (mod), char_class (ch_class)
     { }
 
@@ -1339,17 +1339,17 @@ namespace octave
     progress_marker = idx;
     refresh_buf ();               // load the first batch of data
   }
 
   // Used to create a stream from a strstream from data read from a dstr.
   delimited_stream::delimited_stream (std::istream& is,
                                       const delimited_stream& ds)
     : delimited_stream (is, ds.delims, ds.longest, ds.bufsize)
-  {}
+  { }
 
   delimited_stream::~delimited_stream (void)
   {
     // Seek to the correct position in i_stream.
     if (! eof ())
       {
         i_stream.clear ();
         i_stream.seekg (buf_in_file);
@@ -1578,20 +1578,20 @@ namespace octave
   // A single conversion specifier, such as %f or %c.
 
   class
   textscan_format_elt
   {
   public:
 
     enum special_conversion
-      {
-        whitespace_conversion = 1,
-        literal_conversion = 2
-      };
+    {
+      whitespace_conversion = 1,
+      literal_conversion = 2
+    };
 
     textscan_format_elt (const std::string& txt, int w = 0, int p = -1,
                          int bw = 0, bool dis = false, char typ = '\0',
                          const std::string& ch_class = std::string ())
       : text (txt), width (w), prec (p), bitwidth (bw),
         char_class (ch_class), type (typ), discard (dis),
         numeric (typ == 'd' || typ == 'u' || type == 'f' || type == 'n')
     { }
@@ -3069,17 +3069,17 @@ namespace octave
         retval = retval + next;   // FIXME: could use repeated doubling of size
 
         int last = (! is.eof ()
                     ? is.get_undelim () : std::istream::traits_type::eof ());
 
         if (last != std::istream::traits_type::eof ())
           {
             if (last == eol1 || last == eol2)
-                break;
+              break;
 
             retval = retval + static_cast<char> (last);
             for (int i = 0; i < delimiters.numel (); i++)
               {
                 std::string delim = delimiters(i).string_value ();
                 size_t start = (retval.length () > delim.length ()
                                 ? retval.length () - delim.length ()
                                 : 0);
@@ -6583,20 +6583,20 @@ namespace octave
           input_buf_elts = 1024 * 1024;
         else
           input_buf_elts = elts_to_read;
       }
     else
       input_buf_elts = block_size;
 
     octave_idx_type input_elt_size
-                                      = oct_data_conv::data_type_size (input_type);
-
-    ptrdiff_t input_buf_size
-                                      = static_cast<ptrdiff_t> (input_buf_elts) * input_elt_size;
+      = oct_data_conv::data_type_size (input_type);
+
+    ptrdiff_t input_buf_size =
+      static_cast<ptrdiff_t> (input_buf_elts) * input_elt_size;
 
     assert (input_buf_size >= 0);
 
     // Must also work and return correct type object
     // for 0 elements to read.
     std::istream *isp = input_stream ();
 
     if (! isp)
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -64,17 +64,17 @@ namespace octave
   {
     friend class stream;
 
   public:
 
     base_stream (std::ios::openmode arg_md = std::ios::in | std::ios::out,
                  mach_info::float_format ff = mach_info::native_float_format ())
       : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
-      errmsg ()
+        errmsg ()
     { }
 
     // No copying!
 
     base_stream (const base_stream&) = delete;
 
     base_stream& operator = (const base_stream&) = delete;
 
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -444,17 +444,17 @@ Note: @code{qz} performs permutation bal
                  nn, QQ.fortran_vec (), nn, info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
 #if defined (DEBUG)
       if (comp_q == 'V')
         std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
 #endif
-  }
+    }
 
   // then right
   if (comp_z == 'V')
     {
       F77_XFCN (dggbak, DGGBAK,
                 (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                  F77_CONST_CHAR_ARG2 ("R", 1),
                  nn, ilo, ihi, lscale.data (), rscale.data (),
@@ -502,17 +502,17 @@ Note: @code{qz} performs permutation bal
                  nn, ilo, ihi,
                  F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn,
                  F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()), nn,
                  F77_DBLE_CMPLX_ARG (xalpha.fortran_vec ()),
                  F77_DBLE_CMPLX_ARG (xbeta.fortran_vec ()),
                  F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn,
                  F77_DBLE_CMPLX_ARG (CZ.fortran_vec ()), nn,
                  F77_DBLE_CMPLX_ARG (cwork.fortran_vec ()), nn,
-                                     rwork.fortran_vec (), info
+                 rwork.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
       if (comp_q == 'V')
         {
           // Left eigenvector.
           F77_XFCN (zggbak, ZGGBAK,
@@ -1076,17 +1076,17 @@ Note: @code{qz} performs permutation bal
       std::cout << "qz: retval(0) = gev = " << gev << std::endl;
 #endif
       retval(0) = gev;
       break;
 
     default:
       error ("qz: too many return arguments");
       break;
-  }
+    }
 
 #if defined (DEBUG)
   std::cout << "qz: exiting (at long last)" << std::endl;
 #endif
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -111,17 +111,17 @@ namespace octave
     // Interrupt signals are currently handled separately.
 
     static int sigint;
     static const bool have_sigint
       = octave_get_sig_number ("SIGINT", &sigint);
 
     static int sigbreak;
     static const bool have_sigbreak
-    = octave_get_sig_number ("SIGBREAK", &sigbreak);
+      = octave_get_sig_number ("SIGBREAK", &sigbreak);
 
     // Termination signals.
 
     static int sighup;
     static const bool have_sighup
       = octave_get_sig_number ("SIGHUP", &sighup);
 
     static int sigquit;
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -665,17 +665,17 @@ elem_xpow (const SparseComplexMatrix& a,
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           double btmp = b(a.ridx (i), j);
 
           if (xisint (btmp))
             result.xelem (a.ridx (i), j) = std::pow (a.data (i),
-                                              static_cast<int> (btmp));
+                                                     static_cast<int> (btmp));
           else
             result.xelem (a.ridx (i), j) = std::pow (a.data (i), btmp);
         }
     }
 
   result.maybe_compress (true);
 
   return result;
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -39,26 +39,25 @@ static std::string Vsvd_driver = "gesdd"
 template <typename T>
 static typename octave::math::svd<T>::Type
 svd_type (int nargin, int nargout, const octave_value_list & args, const T & A)
 {
   if (nargout == 0 || nargout == 1)
     return octave::math::svd<T>::Type::sigma_only;
   else if (nargin == 1)
     return octave::math::svd<T>::Type::std;
+  else if (! args(1).is_real_scalar ())
+    return octave::math::svd<T>::Type::economy;
   else
-    if (! args(1).is_real_scalar ())
-      return octave::math::svd<T>::Type::economy;
-    else
-      {
-        if (A.rows () > A.columns ())
-          return octave::math::svd<T>::Type::economy;
-        else
-          return octave::math::svd<T>::Type::std;
-      }
+    {
+      if (A.rows () > A.columns ())
+        return octave::math::svd<T>::Type::economy;
+      else
+        return octave::math::svd<T>::Type::std;
+    }
 }
 
 template <typename T>
 static typename octave::math::svd<T>::Driver
 svd_driver (void)
 {
   return (Vsvd_driver == "gesvd"
           ? octave::math::svd<T>::Driver::GESVD
diff --git a/libinterp/corefcn/symscope.h b/libinterp/corefcn/symscope.h
--- a/libinterp/corefcn/symscope.h
+++ b/libinterp/corefcn/symscope.h
@@ -584,17 +584,17 @@ namespace octave
 
     std::vector<symbol_scope> m_children;
 
     //! If true, then this scope belongs to a nested function.
 
     bool m_is_nested;
 
     //! If true then no variables can be added.
-    
+
     bool m_is_static;
 
     symbol_record::context_id m_context;
   };
 
   class symbol_scope
   {
   public:
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -382,17 +382,17 @@ namespace octave
         return fcn;
       }
 
     return octave_value ();
   }
 
   octave_value
   symbol_table::fcn_table_find (const std::string& name,
-                               const octave_value_list& args, bool local_funcs)
+                                const octave_value_list& args, bool local_funcs)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
 
     if (p != m_fcn_table.end ())
       return p->second.find (args, local_funcs);
     else
       {
         fcn_info finfo (name);
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -54,19 +54,19 @@ namespace octave
     typedef octave::symbol_record symbol_record;
     typedef octave::symbol_scope scope;
     typedef octave::fcn_info fcn_info;
 
     symbol_table (void)
       : m_fcn_table (), m_class_precedence_table (),
         m_parent_map (), m_global_scope ("global scope"),
         m_top_scope ("top scope"), m_current_scope (m_top_scope)
-      {
-        install_builtins ();
-      }
+    {
+      install_builtins ();
+    }
 
     // No copying!
 
     symbol_table (const symbol_table&) = delete;
 
     symbol_table& operator = (const symbol_table&) = delete;
 
     ~symbol_table (void) = default;
@@ -136,20 +136,20 @@ namespace octave
     {
       inherit (recipient_scope, m_current_scope);
     }
 
     bool at_top_level (void) { return m_current_scope == m_top_scope; }
 
     // Find a value corresponding to the given name in the table.
     octave_value
-      find (const std::string& name,
-            const octave_value_list& args = octave_value_list (),
-            bool skip_variables = false,
-            bool local_funcs = true);
+    find (const std::string& name,
+          const octave_value_list& args = octave_value_list (),
+          bool skip_variables = false,
+          bool local_funcs = true);
 
     void assign (const std::string& name, const octave_value& value, bool force_add)
     {
       if (m_current_scope)
         m_current_scope.assign (name, value, force_add);
     }
 
     void assign (const std::string& name,
@@ -172,37 +172,37 @@ namespace octave
     }
 
     octave_value global_varval (const std::string& name) const
     {
       return m_global_scope.varval (name);
     }
 
     void
-      top_level_assign (const std::string& name,
-                        const octave_value& value = octave_value ())
+    top_level_assign (const std::string& name,
+                      const octave_value& value = octave_value ())
     {
       m_top_scope.assign (name, value);
     }
 
     octave_value top_level_varval (const std::string& name) const
     {
       return m_top_scope.varval (name);
     }
 
     bool
-      is_built_in_function_name (const std::string& name)
+    is_built_in_function_name (const std::string& name)
     {
       octave_value val = find_built_in_function (name);
 
       return val.is_defined ();
     }
 
     octave_value
-      find_method (const std::string& name, const std::string& dispatch_type)
+    find_method (const std::string& name, const std::string& dispatch_type)
     {
       fcn_table_const_iterator p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           octave_value fcn = p->second.find_method (dispatch_type);
 
           if (! fcn.is_defined ())
@@ -222,47 +222,47 @@ namespace octave
           if (fcn.is_defined ())
             m_fcn_table[name] = finfo;
 
           return fcn;
         }
     }
 
     octave_value
-      find_submethod (const std::string& name, const std::string& dispatch_type);
+    find_submethod (const std::string& name, const std::string& dispatch_type);
 
     octave_value
-      find_built_in_function (const std::string& name)
+    find_built_in_function (const std::string& name)
     {
       fcn_table_const_iterator p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_built_in_function () : octave_value ());
     }
 
     octave_value
-      find_autoload (const std::string& name)
+    find_autoload (const std::string& name)
     {
       fcn_table_iterator p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_autoload () : octave_value ());
     }
 
     octave_value builtin_find (const std::string& name);
 
     octave_value
     fcn_table_find (const std::string& name,
                     const octave_value_list& args = octave_value_list (),
                     bool local_funcs = true);
 
     octave_value
-      find_function (const std::string& name,
-                     const octave_value_list& args = octave_value_list (),
-                     bool local_funcs = true);
+    find_function (const std::string& name,
+                   const octave_value_list& args = octave_value_list (),
+                   bool local_funcs = true);
 
     octave_value find_user_function (const std::string& name)
     {
       fcn_table_iterator p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_user_function () : octave_value ());
     }
@@ -631,17 +631,17 @@ namespace octave
 
     void add_to_parent_map (const std::string& classname,
                             const std::list<std::string>& parent_list)
     {
       m_parent_map[classname] = parent_list;
     }
 
     std::list<std::string>
-      parent_classes (const std::string& dispatch_type)
+    parent_classes (const std::string& dispatch_type)
     {
       std::list<std::string> retval;
 
       const_parent_map_iterator it = m_parent_map.find (dispatch_type);
 
       if (it != m_parent_map.end ())
         retval = it->second;
 
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -733,24 +733,24 @@ get_regkey_value (HKEY h_rootkey, const 
     return result;
 
   octave::unwind_protect frame;
 
   frame.add_fcn (reg_close_key_wrapper, h_subkey);
 
   DWORD length = 0;
   result = RegQueryValueExA (h_subkey, name.c_str (), nullptr, nullptr, nullptr,
-                            &length);
+                             &length);
   if (result != ERROR_SUCCESS)
     return result;
 
   DWORD type = 0;
   OCTAVE_LOCAL_BUFFER (BYTE, data, length);
   result = RegQueryValueExA (h_subkey, name.c_str (), nullptr, &type, data,
-                            &length);
+                             &length);
   if (result != ERROR_SUCCESS)
     return result;
 
   if (type == REG_DWORD)
     value = octave_int32 (*data);
   else if (type == REG_SZ || type == REG_EXPAND_SZ)
     value = string_vector (reinterpret_cast<char *> (data));
 
@@ -875,17 +875,17 @@ On non-Windows platforms this function f
                            "or a valid ROOTKEY identifier");
   std::string subkey_name = "";
   std::string value_name = "";
   bool get_names = false;
   if (rootkey_name.compare ("name") == 0)
     {
       if (args.length () < 3)
         error ("winqueryreg: if the first argument is 'name', "
-                            "ROOTKEY and SUBKEY must be given");
+               "ROOTKEY and SUBKEY must be given");
       get_names = true;
       rootkey_name =
         args(1).xstring_value ("winqueryreg: ROOTKEY must be a string");
       subkey_name =
         args(2).xstring_value ("winqueryreg: SUBKEY must be a string");
     }
   else
     {
diff --git a/libinterp/corefcn/url-handle-manager.h b/libinterp/corefcn/url-handle-manager.h
--- a/libinterp/corefcn/url-handle-manager.h
+++ b/libinterp/corefcn/url-handle-manager.h
@@ -56,25 +56,26 @@ namespace octave
     ~url_handle_manager (void) = default;
 
     url_handle get_handle (void);
 
     void free (const url_handle& h);
 
     url_handle lookup (double val)
     {
-      iterator p = (math::isnan (val) ? handle_map.end () : handle_map.find (val));
+      iterator p = (math::isnan (val) ? handle_map.end ()
+                                      : handle_map.find (val));
 
       return (p != handle_map.end ()) ? p->first : url_handle ();
     }
 
     url_handle lookup (const octave_value& val)
     {
       return val.is_real_scalar () ? lookup (val.double_value ())
-        : url_handle ();
+                                   : url_handle ();
     }
 
     url_transfer get_object (double val)
     {
       return get_object (lookup (val));
     }
 
     url_transfer get_object (const octave_value& val)
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -450,17 +450,18 @@ find_data_file_in_load_path  (const std:
       // so do an explicit check for that.
       octave::sys::file_stat fs (fname);
 
       bool local_file_ok
         = fs.exists () && (fs.is_reg () || ! require_regular_file);
 
       if (! local_file_ok)
         {
-          octave::load_path& lp = octave::__get_load_path__ ("find_data_file_in_load_path");
+          octave::load_path& lp =
+            octave::__get_load_path__ ("find_data_file_in_load_path");
 
           // Not directly found; search load path.
           std::string tmp
             = octave::sys::env::make_absolute (lp.find_file (fname));
 
           if (! tmp.empty ())
             {
               warn_data_file_in_path (fcn, tmp);
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -243,17 +243,17 @@ generate_struct_completions (const std::
       pos = base_name.find_first_of ("{(. ");
 
       if (pos != std::string::npos)
         base_name = base_name.substr (0, pos);
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("generate_struct_completions");
 
-        if (is_variable (symtab, base_name))
+      if (is_variable (symtab, base_name))
         {
           int parse_status;
 
           octave::unwind_protect frame;
 
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
@@ -2703,17 +2703,18 @@ bind_ans (const octave_value& val, bool 
   octave::tree_evaluator& tw = octave::__get_evaluator__ ("bind_ans");
 
   tw.bind_ans (val, print);
 }
 
 void
 clear_mex_functions (void)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_mex_functions");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("clear_mex_functions");
 
   symtab.clear_mex_functions ();
 }
 
 void
 clear_function (const std::string& nm)
 {
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
@@ -2748,46 +2749,50 @@ lookup_function_handle (const std::strin
   octave_value val = scope ? scope.varval (nm) : octave_value ();
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("get_global_value");
 
   octave_value val = symtab.global_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("set_global_value");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("set_global_value");
 
   symtab.global_assign (nm, val);
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_top_level_value");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("get_top_level_value");
 
   octave_value val = symtab.top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("set_top_level_value");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("set_top_level_value");
 
   symtab.top_level_assign (nm, val);
 }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -815,17 +815,17 @@ public:
     m_canvas = new OpenGL_fltk (0, m_menu_h, ww, hh, number ());
 
     // The bottom toolbar is a composite of "autoscale", "togglegrid",
     // "panzoom", "rotate", "help", and "status".
     // Only "status" should be resized.
 
     int toolbar_y = m_menu_h + hh + 1;
     m_status = new Fl_Output (5 * m_status_h, toolbar_y,
-                            ww - 5 * m_status_h, m_status_h, "");
+                              ww - 5 * m_status_h, m_status_h, "");
 
     m_status->textcolor (FL_BLACK);
     m_status->color (FL_GRAY);
     m_status->textfont (FL_COURIER);
     m_status->textsize (10);
     m_status->box (FL_ENGRAVED_BOX);
 
     m_autoscale = new Fl_Button (0, toolbar_y, m_status_h, m_status_h, "A");
@@ -1027,17 +1027,17 @@ public:
 
     int toolbar_y = m_canvas->h () + menu_dy () + 1;
     m_autoscale->position (0, toolbar_y);
     m_togglegrid->position (m_status_h, toolbar_y);
     m_panzoom->position (2 * m_status_h, toolbar_y);
     m_rotate->position (3 * m_status_h, toolbar_y);
     m_help->position (4 * m_status_h, toolbar_y);
     m_status->resize (5 * m_status_h, toolbar_y,
-                    w () - 5 * m_status_h, m_status_h);
+                      w () - 5 * m_status_h, m_status_h);
     init_sizes ();
     redraw ();
   }
 
   Matrix outerposition2position (const Matrix& outerpos)
   {
     Matrix pos = outerpos;
     pos(1) += menu_dy ();
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -561,17 +561,17 @@ namespace octave
 
         for (octave_idx_type i = 0; i < num; i++)
           output.elem (0, i) = y.elem (i);
 
         bool posdirection = (tend > tsol);
 
         //main loop
         while (((posdirection == 1 && tsol < tend)
-               || (posdirection == 0 && tsol > tend))
+                || (posdirection == 0 && tsol > tend))
                && status == 0)
           {
             if (IDASolve (mem, tend, &tsol, yy, yyp, IDA_ONE_STEP) != 0)
               error ("IDASolve failed");
 
             if (haverefine)
               status = IDA::interpolate (cont, output, tout, refine, tend,
                                          haveoutputfcn, haveoutputsel,
@@ -686,17 +686,17 @@ namespace octave
             temp = 1; // register only the first event
             te.resize (1);
             ye.resize (1, num);
             ie.resize (1);
 
             // Linear interpolation
             ie(0) = index(0);
             te(0) = tsol - val (index(0)) * (tsol - told)
-              / (val (index(0)) - oldval (index(0)));
+                    / (val (index(0)) - oldval (index(0)));
 
             ColumnVector ytemp
               = y - ((tsol - te(0)) * (y - yold) / (tsol - told));
 
             for (octave_idx_type i = 0; i < num; i++)
               ye.elem (0, i) = ytemp.elem (i);
 
           }
@@ -711,17 +711,17 @@ namespace octave
               {
 
                 if (isterminal (index(i)) == 1)
                   status = 1; // Stop integration
 
                 // Linear interpolation
                 ie(temp+i) = index(i);
                 te(temp+i) = tsol - val(index(i)) * (tsol - told)
-                  / (val(index(i)) - oldval(index(i)));
+                             / (val(index(i)) - oldval(index(i)));
 
                 ColumnVector ytemp
                   = y - (tsol - te (temp + i)) * (y - yold) / (tsol - told);
 
                 for (octave_idx_type j = 0; j < num; j++)
                   ye.elem (temp + i, j) = ytemp.elem (j);
 
               }
@@ -841,17 +841,18 @@ namespace octave
       }
     else if (flag == "")
       {
         output(0) = tsol;
         octave_value_list val = feval (output_fcn, output, 1);
         status = val(0).bool_value ();
       }
     else
-      {  // Cleanup plotter
+      {
+        // Cleanup plotter
         output(0) = tend;
         feval (output_fcn, output, 0);
       }
 
     return status;
   }
 
   void
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -437,18 +437,18 @@ namespace octave
               }
             while (m_strm->avail_out == 0);
 
             if (m_strm->avail_in != 0)
               throw std::runtime_error ("failed to write file");
 
           } while (flush != Z_FINISH);
 
-          if (status != Z_STREAM_END)
-            throw std::runtime_error ("failed to write file");
+        if (status != Z_STREAM_END)
+          throw std::runtime_error ("failed to write file");
       }
 
       void close (void)
       {
         if (deflateEnd (m_strm) != Z_OK)
           throw std::runtime_error ("failed to close zlib stream");
         m_strm = nullptr;
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1476,17 +1476,18 @@ called_from_builtin (void)
   return (fcn && fcn->name () == "builtin");
 }
 
 void
 install_base_type_conversions (octave::type_info& ti)
 {
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_scalar, octave_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_matrix, octave_matrix);
-  INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_complex, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_complex,
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_complex_matrix,
                          octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_range, octave_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_char_matrix_str,
                          octave_char_matrix_str);
   INSTALL_ASSIGNCONV_TI (ti, octave_base_value, octave_cell, octave_cell);
 
   INSTALL_WIDENOP_TI (ti, octave_base_value, octave_matrix, matrix_conv);
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -45,38 +45,44 @@ namespace octave
 // Builtin functions.
 
 class
 OCTINTERP_API
 octave_builtin : public octave_function
 {
 public:
 
-  octave_builtin (void) : octave_function (), f (nullptr), file (), jtype (nullptr) { }
+  octave_builtin (void) : octave_function (), f (nullptr), file (),
+                          jtype (nullptr)
+  { }
 
   typedef octave_value_list (*meth) (octave::interpreter&,
                                      const octave_value_list&, int);
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (ff), m (nullptr), file (), jtype (nullptr) { }
+    : octave_function (nm, ds), f (ff), m (nullptr), file (), jtype (nullptr)
+  { }
 
   octave_builtin (meth mm, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (nullptr), m (mm), file (), jtype (nullptr) { }
+    : octave_function (nm, ds), f (nullptr), m (mm), file (), jtype (nullptr)
+  { }
 
   octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (ff), m (nullptr), file (fnm), jtype (nullptr) { }
+    : octave_function (nm, ds), f (ff), m (nullptr), file (fnm), jtype (nullptr)
+  { }
 
   octave_builtin (meth mm, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (nullptr), m (mm), file (fnm), jtype (nullptr) { }
+    : octave_function (nm, ds), f (nullptr), m (mm), file (fnm), jtype (nullptr)
+  { }
 
   // No copying!
 
   octave_builtin (const octave_builtin& ob) = delete;
 
   octave_builtin& operator = (const octave_builtin& ob) = delete;
 
   ~octave_builtin (void) = default;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1312,17 +1312,17 @@ To convert back from a cellstr to a char
 
   if (tmp(0).is_true ())
     return ovl (args(0));
   else
     {
       string_vector s = args(0).xstring_vector_value ("cellstr: argument STRING must be a 2-D character array");
 
       return ovl (s.isempty () ? Cell (octave_value (""))
-                                : Cell (s, true));
+                               : Cell (s, true));
     }
 }
 
 DEFUN (struct2cell, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{c} =} struct2cell (@var{s})
 Create a new cell array from the objects stored in the struct object.
 
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -293,17 +293,18 @@ octave_class::dotref (const octave_value
 Matrix
 octave_class::size (void)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::size ();
 
   Matrix retval (1, 2, 1.0);
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::size");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("octave_class::size");
 
   octave_value meth = symtab.find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
@@ -333,17 +334,18 @@ octave_idx_type
 octave_class::numel (const octave_value_list& idx)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::numel (idx);
 
   octave_idx_type retval = -1;
   const std::string cn = class_name ();
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::numel");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("octave_class::numel");
 
   octave_value meth = symtab.find_method ("numel", cn);
 
   if (meth.is_defined ())
     {
       octave_value_list args (idx.length () + 1, octave_value ());
 
       count++;
@@ -428,17 +430,18 @@ octave_class::subsref (const std::string
       // octave_value_list::next_subsref member function?  See also
       // octave_user_function::subsref.
 
       if (idx.size () > 1)
         retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
   else
     {
-      octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::subsref");
+      octave::symbol_table& symtab =
+        octave::__get_symbol_table__ ("octave_class::subsref");
 
       octave_value meth = symtab.find_method ("subsref", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsref");
@@ -806,17 +809,18 @@ octave_class::subsasgn_common (const oct
     }
 
   return retval;
 }
 
 idx_vector
 octave_class::index_vector (bool require_integers) const
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::index_vector");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("octave_class::index_vector");
 
   octave_value meth = symtab.find_method ("subsindex", class_name ());
 
   if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   octave_value_list args;
@@ -854,17 +858,18 @@ octave_class::byte_size (void) const
   return retval;
 }
 
 bool
 octave_class::is_true (void) const
 {
   bool retval = false;
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::is_true");
+  octave::symbol_table& symtab =
+    octave::__get_symbol_table__ ("octave_class::is_true");
 
   octave_value meth = symtab.find_method ("logical", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value in = new octave_class (*this);
 
       octave_value_list tmp = octave::feval (meth.function_value (), in, 1);
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -43,21 +43,23 @@ OCTINTERP_API
 octave_dld_function : public octave_builtin
 {
 public:
 
   octave_dld_function (void)
     : sh_lib (), t_checked (), system_fcn_file ()
   { }
 
-  octave_dld_function (octave_builtin::fcn ff, const octave::dynamic_library& shl,
+  octave_dld_function (octave_builtin::fcn ff,
+                       const octave::dynamic_library& shl,
                        const std::string& nm = "",
                        const std::string& ds = "");
 
-  octave_dld_function (octave_builtin::meth mm, const octave::dynamic_library& shl,
+  octave_dld_function (octave_builtin::meth mm,
+                       const octave::dynamic_library& shl,
                        const std::string& nm = "",
                        const std::string& ds = "");
 
   // No copying!
 
   octave_dld_function (const octave_dld_function& fn) = delete;
 
   octave_dld_function& operator = (const octave_dld_function& fn) = delete;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -279,17 +279,18 @@ octave_fcn_handle::set_fcn (const std::s
       else
         {
           // Next just search for it anywhere in the system path
           std::list<std::string> names;
           names.push_back (nm + ".oct");
           names.push_back (nm + ".mex");
           names.push_back (nm + ".m");
 
-          octave::load_path& lp = octave::__get_load_path__ ("octave_fcn_handle::set_fcn");
+          octave::load_path& lp =
+            octave::__get_load_path__ ("octave_fcn_handle::set_fcn");
 
           octave::directory_path p (lp.system_path ());
 
           str = octave::sys::env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -540,17 +540,17 @@ initialize_jvm (void)
 
   // Check whether the Java VM library is already loaded or linked in.
   JNI_CreateJavaVM_t create_vm = reinterpret_cast<JNI_CreateJavaVM_t>
                                  (lib.search ("JNI_CreateJavaVM"));
   JNI_GetCreatedJavaVMs_t get_vm = reinterpret_cast<JNI_GetCreatedJavaVMs_t>
                                    (lib.search ("JNI_GetCreatedJavaVMs"));
 
   if (! create_vm || ! get_vm)
-   {
+    {
 #if defined (OCTAVE_USE_WINDOWS_API)
       // In windows, find the location of the JRE from the registry
       // and load the symbol from the dll.
       std::string key, value;
 
       key = R"(software\javasoft\java runtime environment)";
 
       value = octave::sys::env::getenv ("JAVA_VERSION");
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -226,17 +226,18 @@ octave_diag_matrix::map (unary_mapper_t 
       return matrix.abs ();
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
-        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (octave::math::rc_sqrt);
+        ComplexColumnVector tmp;
+        tmp = matrix.extract_diag ().map<Complex> (octave::math::rc_sqrt);
         ComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
diff --git a/libinterp/operators/op-b-sbm.cc b/libinterp/operators/op-b-sbm.cc
--- a/libinterp/operators/op-b-sbm.cc
+++ b/libinterp/operators/op-b-sbm.cc
@@ -89,13 +89,13 @@ install_b_sbm_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_el_and, octave_bool, octave_sparse_bool_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_bool, octave_sparse_bool_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_bool, octave_sparse_bool_matrix, b_sbm);
   INSTALL_CATOP_TI (ti, octave_bool, octave_sparse_matrix, b_sm);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_sparse_bool_matrix, s_sbm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_bool, octave_sparse_bool_matrix,
-                      octave_bool_matrix);
+                         octave_bool_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_bool, octave_sparse_bool_matrix,
-                   sparse_bool_matrix_conv);
+                      sparse_bool_matrix_conv);
 }
diff --git a/libinterp/operators/op-bm-b.cc b/libinterp/operators/op-bm-b.cc
--- a/libinterp/operators/op-bm-b.cc
+++ b/libinterp/operators/op-bm-b.cc
@@ -93,28 +93,28 @@ install_bm_b_ops (octave::type_info& ti)
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_scalar, bm_s);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_bool, m_b);
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_float_scalar, bm_f);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_bool, fm_b);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_bool, assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int8_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int16_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int32_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int64_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint8_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint16_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint32_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint64_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
 }
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -134,67 +134,69 @@ install_bm_bm_ops (octave::type_info& ti
   INSTALL_NCUNOP_TI (ti, op_not, octave_bool_matrix, invert);
 
   INSTALL_BINOP_TI (ti, op_eq, octave_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ne, octave_bool_matrix, octave_bool_matrix, ne);
 
   INSTALL_BINOP_TI (ti, op_el_and, octave_bool_matrix, octave_bool_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_bool_matrix, octave_bool_matrix, el_or);
   INSTALL_BINOP_TI (ti, op_el_not_and, octave_bool_matrix, octave_bool_matrix,
-                 el_not_and);
+                    el_not_and);
   INSTALL_BINOP_TI (ti, op_el_not_or, octave_bool_matrix, octave_bool_matrix,
-                 el_not_or);
+                    el_not_or);
   INSTALL_BINOP_TI (ti, op_el_and_not, octave_bool_matrix, octave_bool_matrix,
-                 el_and_not);
+                    el_and_not);
   INSTALL_BINOP_TI (ti, op_el_or_not, octave_bool_matrix, octave_bool_matrix,
-                 el_or_not);
+                    el_or_not);
 
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_bool_matrix, bm_bm);
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_matrix, bm_m);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_bool_matrix, m_bm);
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_float_matrix, bm_fm);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_bool_matrix, fm_bm);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_bool_matrix, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_bool_matrix,
+                       assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_char_matrix_str,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_char_matrix_sq_str,
-                    conv_and_assign);
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix,
+                       octave_char_matrix_sq_str,
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_range,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_sparse_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int8_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int16_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int32_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_int64_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint8_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint16_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint32_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_uint64_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_null_matrix,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_null_str,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_el_and_eq, octave_bool_matrix, octave_bool_matrix,
-                    assign_and);
+                       assign_and);
   INSTALL_ASSIGNOP_TI (ti, op_el_or_eq, octave_bool_matrix, octave_bool_matrix,
-                    assign_or);
+                       assign_or);
 }
diff --git a/libinterp/operators/op-bm-sbm.cc b/libinterp/operators/op-bm-sbm.cc
--- a/libinterp/operators/op-bm-sbm.cc
+++ b/libinterp/operators/op-bm-sbm.cc
@@ -85,24 +85,25 @@ DEFNDASSIGNOP_FN (assign, bool_matrix, s
 
 void
 install_bm_sbm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_eq, octave_bool_matrix, octave_sparse_bool_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ne, octave_bool_matrix, octave_sparse_bool_matrix, ne);
 
   INSTALL_BINOP_TI (ti, op_el_and, octave_bool_matrix, octave_sparse_bool_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_bool_matrix, octave_sparse_bool_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_sparse_bool_matrix, bm_sbm);
   INSTALL_CATOP_TI (ti, octave_bool_matrix, octave_sparse_matrix, bm_sm);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_sparse_bool_matrix, m_sbm);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix, octave_sparse_bool_matrix,
-                    assign)
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_bool_matrix,
+                       octave_sparse_bool_matrix,
+                       assign)
   INSTALL_ASSIGNCONV_TI (ti, octave_bool_matrix, octave_sparse_bool_matrix,
-                      octave_bool_matrix);
+                         octave_bool_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_bool_matrix, octave_sparse_bool_matrix,
-                   sparse_bool_matrix_conv);
+                      sparse_bool_matrix_conv);
 }
diff --git a/libinterp/operators/op-cdm-cdm.cc b/libinterp/operators/op-cdm-cdm.cc
--- a/libinterp/operators/op-cdm-cdm.cc
+++ b/libinterp/operators/op-cdm-cdm.cc
@@ -93,24 +93,28 @@ CONVDECL (complex_diag_matrix_to_complex
 void
 install_cdm_cdm_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_uplus, octave_complex_diag_matrix, uplus);
   INSTALL_UNOP_TI (ti, op_uminus, octave_complex_diag_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_complex_diag_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_complex_diag_matrix, hermitian);
 
-  INSTALL_BINOP_TI (ti, op_add, octave_complex_diag_matrix, octave_complex_diag_matrix,
-                 add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_complex_diag_matrix, octave_complex_diag_matrix,
-                 sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_complex_diag_matrix, octave_complex_diag_matrix,
-                 mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_complex_diag_matrix, octave_complex_diag_matrix,
-                 div);
+  INSTALL_BINOP_TI (ti, op_add, octave_complex_diag_matrix,
+                    octave_complex_diag_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_complex_diag_matrix,
+                    octave_complex_diag_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_complex_diag_matrix,
+                    octave_complex_diag_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_complex_diag_matrix,
+                    octave_complex_diag_matrix,
+                    div);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_diag_matrix,
-                 octave_complex_diag_matrix, ldiv);
+                    octave_complex_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex_diag_matrix, octave_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
   INSTALL_WIDENOP_TI (ti, octave_complex_diag_matrix, octave_complex_matrix,
-                   complex_diag_matrix_to_complex_matrix);
+                      complex_diag_matrix_to_complex_matrix);
 }
diff --git a/libinterp/operators/op-cell.cc b/libinterp/operators/op-cell.cc
--- a/libinterp/operators/op-cell.cc
+++ b/libinterp/operators/op-cell.cc
@@ -57,12 +57,14 @@ install_cell_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_transpose, octave_cell, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_cell, transpose);
 
   INSTALL_CATOP_TI (ti, octave_cell, octave_cell, c_c);
 
   INSTALL_ASSIGNANYOP_TI (ti, op_asn_eq, octave_cell, assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_cell, octave_null_matrix, null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_cell, octave_null_matrix,
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_cell, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_cell, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_cell, octave_null_sq_str,
+                       null_assign);
 }
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -244,66 +244,82 @@ install_cm_cm_ops (octave::type_info& ti
   INSTALL_UNOP_TI (ti, op_uminus, octave_complex_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_complex_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_complex_matrix, hermitian);
 
   INSTALL_NCUNOP_TI (ti, op_incr, octave_complex_matrix, incr);
   INSTALL_NCUNOP_TI (ti, op_decr, octave_complex_matrix, decr);
   INSTALL_NCUNOP_TI (ti, op_uminus, octave_complex_matrix, changesign);
 
-  INSTALL_BINOP_TI (ti, op_add, octave_complex_matrix, octave_complex_matrix, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_complex_matrix, octave_complex_matrix, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_complex_matrix, octave_complex_matrix, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_complex_matrix, octave_complex_matrix, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_complex_matrix, octave_complex_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_matrix, octave_complex_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_trans_mul, octave_complex_matrix, octave_complex_matrix,
-                 trans_mul);
-  INSTALL_BINOP_TI (ti, op_mul_trans, octave_complex_matrix, octave_complex_matrix,
-                 mul_trans);
+  INSTALL_BINOP_TI (ti, op_add, octave_complex_matrix, octave_complex_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_complex_matrix, octave_complex_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_complex_matrix, octave_complex_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_complex_matrix, octave_complex_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_complex_matrix, octave_complex_matrix,
+                    pow);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_matrix, octave_complex_matrix,
+                    ldiv);
+  INSTALL_BINOP_TI (ti, op_trans_mul, octave_complex_matrix,
+                    octave_complex_matrix,
+                    trans_mul);
+  INSTALL_BINOP_TI (ti, op_mul_trans, octave_complex_matrix,
+                    octave_complex_matrix,
+                    mul_trans);
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_complex_matrix, octave_complex_matrix,
-                 herm_mul);
+                    herm_mul);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_complex_matrix, octave_complex_matrix,
-                 mul_herm);
-  INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_complex_matrix, octave_complex_matrix,
-                 trans_ldiv);
-  INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_complex_matrix, octave_complex_matrix,
-                 herm_ldiv);
+                    mul_herm);
+  INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_complex_matrix,
+                    octave_complex_matrix,
+                    trans_ldiv);
+  INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_complex_matrix,
+                    octave_complex_matrix,
+                    herm_ldiv);
 
   INSTALL_BINOP_TI (ti, op_lt, octave_complex_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix, octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix, octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix, octave_complex_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix, octave_complex_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix, octave_complex_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_complex_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix, octave_complex_matrix,
-                 el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_complex_matrix, el_or);
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_complex_matrix,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_complex_matrix, cm_cm);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_complex_matrix,
-                    assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
+                       octave_complex_matrix,
+                       assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_null_matrix,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_null_str,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_complex_matrix, octave_complex_matrix,
-                    assign_add);
-  INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_complex_matrix, octave_complex_matrix,
-                    assign_sub);
-  INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_complex_matrix, octave_complex_matrix,
-                    assign_el_mul);
-  INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_complex_matrix, octave_complex_matrix,
-                    assign_el_div);
+  INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_complex_matrix,
+                       octave_complex_matrix,
+                       assign_add);
+  INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_complex_matrix,
+                       octave_complex_matrix,
+                       assign_sub);
+  INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_complex_matrix,
+                       octave_complex_matrix,
+                       assign_el_mul);
+  INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_complex_matrix,
+                       octave_complex_matrix,
+                       assign_el_div);
 }
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -143,27 +143,33 @@ install_cm_cs_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix, octave_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix, octave_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix, octave_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix, octave_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix, octave_complex, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix, octave_complex, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix, octave_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix, octave_complex, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_complex, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_complex,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix, octave_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_complex, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_complex, cm_cs);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_complex, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_complex,
+                       assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix, octave_complex,
-                    sgl_assign);
+                       sgl_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_complex_matrix, octave_complex_scalar,
-                    assign_add);
-  INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_complex_matrix, octave_complex_scalar,
-                    assign_sub);
-  INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_complex_matrix, octave_complex_scalar,
-                    assign_mul);
-  INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_complex_matrix, octave_complex_scalar,
-                    assign_div);
+  INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_complex_matrix,
+                       octave_complex_scalar,
+                       assign_add);
+  INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_complex_matrix,
+                       octave_complex_scalar,
+                       assign_sub);
+  INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_complex_matrix,
+                       octave_complex_scalar,
+                       assign_mul);
+  INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_complex_matrix,
+                       octave_complex_scalar,
+                       assign_div);
 }
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -132,18 +132,22 @@ install_cm_m_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix, octave_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix, octave_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix, octave_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix, octave_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix, octave_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix, octave_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix, octave_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix, octave_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_matrix, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_matrix,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix, octave_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_matrix, el_or);
-  INSTALL_BINOP_TI (ti, op_mul_trans, octave_complex_matrix, octave_matrix, mul_trans);
-  INSTALL_BINOP_TI (ti, op_mul_herm, octave_complex_matrix, octave_matrix, mul_trans);
+  INSTALL_BINOP_TI (ti, op_mul_trans, octave_complex_matrix, octave_matrix,
+                    mul_trans);
+  INSTALL_BINOP_TI (ti, op_mul_herm, octave_complex_matrix, octave_matrix,
+                    mul_trans);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_matrix, cm_m);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_matrix, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_matrix,
+                       assign);
 }
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -133,21 +133,23 @@ install_cm_s_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix, octave_scalar, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix, octave_scalar, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix, octave_scalar, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix, octave_scalar, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix, octave_scalar, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix, octave_scalar, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix, octave_scalar, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix, octave_scalar, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_scalar, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_scalar,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix, octave_scalar, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_scalar, cm_s);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_scalar, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_scalar,
+                       assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_complex_matrix, octave_scalar,
-                    assign_mul);
+                       assign_mul);
   INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_complex_matrix, octave_scalar,
-                    assign_div);
+                       assign_div);
 }
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -154,59 +154,59 @@ DEFCONV (sparse_complex_matrix_conv, com
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix,
                   complex_array, assign)
 
 void
 install_cm_scm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_complex_matrix,
-                 octave_sparse_complex_matrix, add);
+                    octave_sparse_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_complex_matrix,
-                 octave_sparse_complex_matrix, sub);
+                    octave_sparse_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_complex_matrix,
-                 octave_sparse_complex_matrix, mul);
+                    octave_sparse_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_complex_matrix,
-                 octave_sparse_complex_matrix, div);
+                    octave_sparse_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_complex_matrix,
-                 octave_sparse_complex_matrix, pow);
+                    octave_sparse_complex_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_matrix,
-                 octave_sparse_complex_matrix, ldiv);
+                    octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_mul_trans, octave_complex_matrix,
-                 octave_sparse_complex_matrix, mul_trans);
+                    octave_sparse_complex_matrix, mul_trans);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_complex_matrix,
-                 octave_sparse_complex_matrix, mul_herm);
+                    octave_sparse_complex_matrix, mul_herm);
   INSTALL_BINOP_TI (ti, op_lt, octave_complex_matrix,
-                 octave_sparse_complex_matrix, lt);
+                    octave_sparse_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix,
-                 octave_sparse_complex_matrix, le);
+                    octave_sparse_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix,
-                 octave_sparse_complex_matrix, eq);
+                    octave_sparse_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix,
-                 octave_sparse_complex_matrix, ge);
+                    octave_sparse_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix,
-                 octave_sparse_complex_matrix, gt);
+                    octave_sparse_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix,
-                 octave_sparse_complex_matrix, ne);
+                    octave_sparse_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_mul);
+                    octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_div);
+                    octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_pow);
+                    octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_ldiv);
+                    octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_and);
+                    octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix,
-                 octave_sparse_complex_matrix, el_or);
+                    octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix,
-                 octave_sparse_complex_matrix, cm_scm);
+                    octave_sparse_complex_matrix, cm_scm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
-                    octave_sparse_complex_matrix, assign)
+                       octave_sparse_complex_matrix, assign)
   INSTALL_ASSIGNCONV_TI (ti, octave_complex_matrix, octave_sparse_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_complex_matrix, octave_sparse_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -143,36 +143,37 @@ DEFNDASSIGNOP_FN (assign, complex_matrix
 void
 install_cm_sm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_complex_matrix, octave_sparse_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_complex_matrix, octave_sparse_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_complex_matrix, octave_sparse_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_complex_matrix, octave_sparse_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_complex_matrix, octave_sparse_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_matrix, octave_sparse_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_matrix, octave_sparse_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_complex_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_complex_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex_matrix, octave_sparse_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex_matrix, octave_sparse_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex_matrix, octave_sparse_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex_matrix, octave_sparse_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex_matrix, octave_sparse_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex_matrix, octave_sparse_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex_matrix, octave_sparse_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_sparse_matrix, cm_sm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix, octave_sparse_matrix,
-                    assign);
+                       assign);
   INSTALL_ASSIGNCONV_TI (ti, octave_complex_matrix, octave_sparse_matrix,
-                      octave_complex_matrix)
+                         octave_complex_matrix)
 
 }
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -133,19 +133,21 @@ install_cs_cm_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_le, octave_complex, octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex, octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex, octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex, octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex, octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex, octave_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_complex_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_complex_matrix, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_complex_matrix,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_complex_matrix, cs_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
-  INSTALL_WIDENOP_TI (ti, octave_complex, octave_complex_matrix, complex_matrix_conv);
+  INSTALL_WIDENOP_TI (ti, octave_complex, octave_complex_matrix,
+                      complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -181,16 +181,18 @@ install_cs_cs_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_complex, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_complex, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_complex, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_complex, cs_cs);
 
-  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_complex, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_complex,
+                         octave_complex_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_null_matrix,
-                      octave_complex_matrix);
-  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_null_str, octave_complex_matrix);
+                         octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_null_str,
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_null_sq_str,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-cs-m.cc b/libinterp/operators/op-cs-m.cc
--- a/libinterp/operators/op-cs-m.cc
+++ b/libinterp/operators/op-cs-m.cc
@@ -124,10 +124,11 @@ install_cs_m_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_matrix, cs_m);
 
-  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_matrix, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_matrix,
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-cs-s.cc b/libinterp/operators/op-cs-s.cc
--- a/libinterp/operators/op-cs-s.cc
+++ b/libinterp/operators/op-cs-s.cc
@@ -143,10 +143,11 @@ install_cs_s_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_scalar, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_scalar, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_scalar, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_scalar, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_scalar, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_scalar, cs_s);
 
-  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_scalar, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_scalar,
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -140,42 +140,47 @@ DEFCONV (sparse_complex_matrix_conv, com
 
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_cs_scm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_complex, octave_sparse_complex_matrix, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_complex, octave_sparse_complex_matrix, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_complex, octave_sparse_complex_matrix, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_complex, octave_sparse_complex_matrix, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_complex, octave_sparse_complex_matrix, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_complex, octave_sparse_complex_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_complex, octave_sparse_complex_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_complex, octave_sparse_complex_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_complex, octave_sparse_complex_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_complex, octave_sparse_complex_matrix,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_complex, octave_sparse_complex_matrix,
-                 ldiv);
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_complex, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_complex, octave_sparse_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex, octave_sparse_complex_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_sparse_complex_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_sparse_complex_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_sparse_complex_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_sparse_complex_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_sparse_complex_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_sparse_complex_matrix, cs_scm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_sparse_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_complex, octave_sparse_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -153,19 +153,21 @@ install_cs_sm_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_le, octave_complex, octave_sparse_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_complex, octave_sparse_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_complex, octave_sparse_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_complex, octave_sparse_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_complex, octave_sparse_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_complex, octave_sparse_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_complex, octave_sparse_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_sparse_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_sparse_matrix, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_complex, octave_sparse_matrix,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_complex, octave_sparse_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_complex, octave_sparse_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_complex, octave_sparse_matrix, cs_sm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_sparse_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
-  INSTALL_WIDENOP_TI (ti, octave_complex, octave_sparse_matrix, sparse_matrix_conv);
+  INSTALL_WIDENOP_TI (ti, octave_complex, octave_sparse_matrix,
+                      sparse_matrix_conv);
 }
diff --git a/libinterp/operators/op-dm-dm.cc b/libinterp/operators/op-dm-dm.cc
--- a/libinterp/operators/op-dm-dm.cc
+++ b/libinterp/operators/op-dm-dm.cc
@@ -87,10 +87,11 @@ install_dm_dm_ops (octave::type_info& ti
 
   INSTALL_BINOP_TI (ti, op_add, octave_diag_matrix, octave_diag_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_diag_matrix, octave_diag_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_diag_matrix, octave_diag_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_diag_matrix, octave_diag_matrix, div);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_diag_matrix, octave_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_diag_matrix, octave_matrix, octave_matrix);
-  INSTALL_WIDENOP_TI (ti, octave_diag_matrix, octave_matrix, diag_matrix_to_matrix);
+  INSTALL_WIDENOP_TI (ti, octave_diag_matrix, octave_matrix,
+                      diag_matrix_to_matrix);
 }
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -547,60 +547,60 @@ DEFBINOP (sub_scm_cdm, sparse_complex_ma
   else
     return v1.sparse_complex_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 void
 install_dm_scm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_mul, octave_diag_matrix, octave_sparse_complex_matrix,
-                 mul_dm_scm);
+                    mul_dm_scm);
   INSTALL_BINOP_TI (ti, op_mul, octave_complex_diag_matrix, octave_sparse_matrix,
-                 mul_cdm_sm);
+                    mul_cdm_sm);
   INSTALL_BINOP_TI (ti, op_mul, octave_complex_diag_matrix,
-                 octave_sparse_complex_matrix, mul_cdm_scm);
+                    octave_sparse_complex_matrix, mul_cdm_scm);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_diag_matrix, octave_sparse_complex_matrix,
-                 ldiv_dm_scm);
+                    ldiv_dm_scm);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_diag_matrix, octave_sparse_matrix,
-                 ldiv_cdm_sm);
+                    ldiv_cdm_sm);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_complex_diag_matrix,
-                 octave_sparse_complex_matrix, ldiv_cdm_scm);
+                    octave_sparse_complex_matrix, ldiv_cdm_scm);
 
   INSTALL_BINOP_TI (ti, op_add, octave_diag_matrix, octave_sparse_complex_matrix,
-                 add_dm_scm);
+                    add_dm_scm);
   INSTALL_BINOP_TI (ti, op_add, octave_complex_diag_matrix, octave_sparse_matrix,
-                 add_cdm_sm);
+                    add_cdm_sm);
   INSTALL_BINOP_TI (ti, op_add, octave_complex_diag_matrix,
-                 octave_sparse_complex_matrix, add_cdm_scm);
+                    octave_sparse_complex_matrix, add_cdm_scm);
   INSTALL_BINOP_TI (ti, op_sub, octave_diag_matrix, octave_sparse_complex_matrix,
-                 sub_dm_scm);
+                    sub_dm_scm);
   INSTALL_BINOP_TI (ti, op_sub, octave_complex_diag_matrix, octave_sparse_matrix,
-                 sub_cdm_sm);
+                    sub_cdm_sm);
   INSTALL_BINOP_TI (ti, op_sub, octave_complex_diag_matrix,
-                 octave_sparse_complex_matrix, sub_cdm_scm);
+                    octave_sparse_complex_matrix, sub_cdm_scm);
 
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_diag_matrix,
-                 mul_scm_dm);
+                    mul_scm_dm);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_complex_diag_matrix,
-                 mul_sm_cdm);
+                    mul_sm_cdm);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix,
-                 octave_complex_diag_matrix, mul_scm_cdm);
+                    octave_complex_diag_matrix, mul_scm_cdm);
 
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_diag_matrix,
-                 div_scm_dm);
+                    div_scm_dm);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_complex_diag_matrix,
-                 div_sm_cdm);
+                    div_sm_cdm);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix,
-                 octave_complex_diag_matrix, div_scm_cdm);
+                    octave_complex_diag_matrix, div_scm_cdm);
 
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_diag_matrix,
-                 add_scm_dm);
+                    add_scm_dm);
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_complex_diag_matrix,
-                 add_sm_cdm);
+                    add_sm_cdm);
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix,
-                 octave_complex_diag_matrix, add_scm_cdm);
+                    octave_complex_diag_matrix, add_scm_cdm);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_diag_matrix,
-                 sub_scm_dm);
+                    sub_scm_dm);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_complex_diag_matrix,
-                 sub_sm_cdm);
+                    sub_sm_cdm);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix,
-                 octave_complex_diag_matrix, sub_scm_cdm);
+                    octave_complex_diag_matrix, sub_scm_cdm);
 }
diff --git a/libinterp/operators/op-dm-sm.cc b/libinterp/operators/op-dm-sm.cc
--- a/libinterp/operators/op-dm-sm.cc
+++ b/libinterp/operators/op-dm-sm.cc
@@ -184,21 +184,27 @@ DEFBINOP (sub_sm_dm, sparse_matrix, diag
   else
     return v1.sparse_matrix_value () - v2.diag_matrix_value ();
 }
 
 void
 install_dm_sm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_mul, octave_diag_matrix, octave_sparse_matrix,
-                 mul_dm_sm);
+                    mul_dm_sm);
 
-  INSTALL_BINOP_TI (ti, op_add, octave_diag_matrix, octave_sparse_matrix, add_dm_sm);
-  INSTALL_BINOP_TI (ti, op_sub, octave_diag_matrix, octave_sparse_matrix, sub_dm_sm);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_diag_matrix, octave_sparse_matrix, ldiv_dm_sm);
+  INSTALL_BINOP_TI (ti, op_add, octave_diag_matrix, octave_sparse_matrix,
+                    add_dm_sm);
+  INSTALL_BINOP_TI (ti, op_sub, octave_diag_matrix, octave_sparse_matrix,
+                    sub_dm_sm);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_diag_matrix, octave_sparse_matrix,
+                    ldiv_dm_sm);
 
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_diag_matrix,
-                 mul_sm_dm);
+                    mul_sm_dm);
 
-  INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_diag_matrix, add_sm_dm);
-  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_diag_matrix, sub_sm_dm);
-  INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_diag_matrix, div_sm_dm);
+  INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_diag_matrix,
+                    add_sm_dm);
+  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_diag_matrix,
+                    sub_sm_dm);
+  INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_diag_matrix,
+                    div_sm_dm);
 }
diff --git a/libinterp/operators/op-fcdm-fcdm.cc b/libinterp/operators/op-fcdm-fcdm.cc
--- a/libinterp/operators/op-fcdm-fcdm.cc
+++ b/libinterp/operators/op-fcdm-fcdm.cc
@@ -94,23 +94,24 @@ void
 install_fcdm_fcdm_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_uplus, octave_float_complex_diag_matrix, uplus);
   INSTALL_UNOP_TI (ti, op_uminus, octave_float_complex_diag_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_float_complex_diag_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_float_complex_diag_matrix, hermitian);
 
   INSTALL_BINOP_TI (ti, op_add, octave_float_complex_diag_matrix,
-                 octave_float_complex_diag_matrix, add);
+                    octave_float_complex_diag_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_diag_matrix,
-                 octave_float_complex_diag_matrix, sub);
+                    octave_float_complex_diag_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_diag_matrix,
-                 octave_float_complex_diag_matrix, mul);
+                    octave_float_complex_diag_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_float_complex_diag_matrix,
-                 octave_float_complex_diag_matrix, div);
+                    octave_float_complex_diag_matrix, div);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex_diag_matrix,
-                 octave_float_complex_diag_matrix, ldiv);
+                    octave_float_complex_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex_diag_matrix,
-                      octave_float_complex_matrix, octave_float_complex_matrix);
-  INSTALL_WIDENOP_TI (ti, octave_float_complex_diag_matrix, octave_complex_diag_matrix,
-                   float_complex_diag_matrix_to_complex_diag_matrix);
+                         octave_float_complex_matrix, octave_float_complex_matrix);
+  INSTALL_WIDENOP_TI (ti, octave_float_complex_diag_matrix,
+                      octave_complex_diag_matrix,
+                      float_complex_diag_matrix_to_complex_diag_matrix);
 }
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -261,89 +261,89 @@ install_fcm_fcm_ops (octave::type_info& 
   INSTALL_UNOP_TI (ti, op_transpose, octave_float_complex_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_float_complex_matrix, hermitian);
 
   INSTALL_NCUNOP_TI (ti, op_incr, octave_float_complex_matrix, incr);
   INSTALL_NCUNOP_TI (ti, op_decr, octave_float_complex_matrix, decr);
   INSTALL_NCUNOP_TI (ti, op_uminus, octave_float_complex_matrix, changesign);
 
   INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix,
-                 octave_float_complex_matrix, add);
+                    octave_float_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix,
-                 octave_float_complex_matrix, sub);
+                    octave_float_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix,
-                 octave_float_complex_matrix, mul);
+                    octave_float_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix,
-                 octave_float_complex_matrix, div);
+                    octave_float_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix,
-                 octave_float_complex_matrix, pow);
+                    octave_float_complex_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex_matrix,
-                 octave_float_complex_matrix, ldiv);
+                    octave_float_complex_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_trans_mul, octave_float_complex_matrix,
-                 octave_float_complex_matrix, trans_mul);
+                    octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP_TI (ti, op_mul_trans, octave_float_complex_matrix,
-                 octave_float_complex_matrix, mul_trans);
+                    octave_float_complex_matrix, mul_trans);
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_float_complex_matrix,
-                 octave_float_complex_matrix, herm_mul);
+                    octave_float_complex_matrix, herm_mul);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_float_complex_matrix,
-                 octave_float_complex_matrix, mul_herm);
+                    octave_float_complex_matrix, mul_herm);
   INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_float_complex_matrix,
-                 octave_float_complex_matrix, trans_ldiv);
+                    octave_float_complex_matrix, trans_ldiv);
   INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_float_complex_matrix,
-                 octave_float_complex_matrix, herm_ldiv);
+                    octave_float_complex_matrix, herm_ldiv);
 
   INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix,
-                 octave_float_complex_matrix, lt);
+                    octave_float_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix,
-                 octave_float_complex_matrix, le);
+                    octave_float_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix,
-                 octave_float_complex_matrix, eq);
+                    octave_float_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix,
-                 octave_float_complex_matrix, ge);
+                    octave_float_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix,
-                 octave_float_complex_matrix, gt);
+                    octave_float_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix,
-                 octave_float_complex_matrix, ne);
+                    octave_float_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_mul);
+                    octave_float_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_div);
+                    octave_float_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_pow);
+                    octave_float_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_ldiv);
+                    octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_and);
+                    octave_float_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex_matrix,
-                 octave_float_complex_matrix, el_or);
+                    octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix,
-                 octave_float_complex_matrix, fcm_fcm);
+                    octave_float_complex_matrix, fcm_fcm);
   INSTALL_CATOP_TI (ti, octave_complex_matrix,
-                 octave_float_complex_matrix, cm_fcm);
+                    octave_float_complex_matrix, cm_fcm);
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix,
-                 octave_complex_matrix, fcm_cm);
+                    octave_complex_matrix, fcm_cm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_float_complex_matrix, assign);
+                       octave_float_complex_matrix, assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_complex_matrix, sgl_clx_assign);
+                       octave_complex_matrix, sgl_clx_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_matrix, sgl_assign);
+                       octave_matrix, sgl_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
-                    octave_float_complex_matrix, dbl_assign);
+                       octave_float_complex_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_null_matrix, null_assign);
+                       octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_null_str, null_assign);
+                       octave_null_str, null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_null_sq_str, null_assign);
+                       octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_float_complex_matrix,
-                    octave_float_complex_matrix, assign_add);
+                       octave_float_complex_matrix, assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_float_complex_matrix,
-                    octave_float_complex_matrix, assign_sub);
+                       octave_float_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_float_complex_matrix,
-                    octave_float_complex_matrix, assign_el_mul);
+                       octave_float_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_float_complex_matrix,
-                    octave_float_complex_matrix, assign_el_div);
+                       octave_float_complex_matrix, assign_el_div);
 }
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -149,56 +149,63 @@ DEFNDASSIGNOP_OP (assign_mul, float_comp
                   float_complex, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_complex_scalar,
                   float_complex, /=)
 
 void
 install_fcm_fcs_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix,
-                 octave_float_complex, add);
+                    octave_float_complex, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix,
-                 octave_float_complex, sub);
+                    octave_float_complex, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix,
-                 octave_float_complex, mul);
+                    octave_float_complex, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix,
-                 octave_float_complex, div);
+                    octave_float_complex, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix,
-                 octave_float_complex, pow);
+                    octave_float_complex, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex_matrix,
-                 octave_float_complex, ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_complex, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_complex, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_complex, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_complex, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_complex, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_complex, ne);
+                    octave_float_complex, ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_complex,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_complex,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_complex,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_complex,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_complex,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_complex,
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex_matrix,
-                 octave_float_complex, el_mul);
+                    octave_float_complex, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex_matrix,
-                 octave_float_complex, el_div);
+                    octave_float_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex_matrix,
-                 octave_float_complex, el_pow);
+                    octave_float_complex, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex_matrix,
-                 octave_float_complex, el_ldiv);
+                    octave_float_complex, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex_matrix,
-                 octave_float_complex, el_and);
+                    octave_float_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex_matrix,
-                 octave_float_complex, el_or);
+                    octave_float_complex, el_or);
 
-  INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_float_complex, fcm_fcs);
+  INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_float_complex,
+                    fcm_fcs);
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_float_complex, cm_fcs);
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_complex, fcm_cs);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_float_complex, assign);
+                       octave_float_complex, assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
-                    octave_float_complex, dbl_assign);
+                       octave_float_complex, dbl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_float_complex_matrix,
-                    octave_float_complex_scalar, assign_add);
+                       octave_float_complex_scalar, assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_float_complex_matrix,
-                    octave_float_complex_scalar, assign_sub);
+                       octave_float_complex_scalar, assign_sub);
   INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_float_complex_matrix,
-                    octave_float_complex_scalar, assign_mul);
+                       octave_float_complex_scalar, assign_mul);
   INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_float_complex_matrix,
-                    octave_float_complex_scalar, assign_div);
+                       octave_float_complex_scalar, assign_div);
 }
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -146,47 +146,58 @@ DEFNDCATOP_FN (fcm_m, float_complex_matr
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_matrix,
                   float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_matrix,
                   complex_array, assign)
 
 void
 install_fcm_fm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix, octave_float_matrix, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix, octave_float_matrix, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix, octave_float_matrix, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix, octave_float_matrix, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix, octave_float_matrix, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix, octave_float_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix, octave_float_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix, octave_float_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix, octave_float_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix, octave_float_matrix,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex_matrix,
-                 octave_float_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_matrix, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_matrix, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_matrix, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_matrix, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_matrix, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_matrix, ne);
+                    octave_float_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_matrix,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_matrix,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_matrix,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_matrix,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_matrix,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_matrix,
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex_matrix,
-                 octave_float_matrix, el_mul);
+                    octave_float_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex_matrix,
-                 octave_float_matrix, el_div);
+                    octave_float_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex_matrix,
-                 octave_float_matrix, el_pow);
+                    octave_float_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex_matrix,
-                 octave_float_matrix, el_ldiv);
+                    octave_float_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex_matrix,
-                 octave_float_matrix, el_and);
+                    octave_float_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex_matrix,
-                 octave_float_matrix, el_or);
+                    octave_float_matrix, el_or);
   INSTALL_BINOP_TI (ti, op_mul_trans, octave_float_complex_matrix,
-                 octave_float_matrix, mul_trans);
+                    octave_float_matrix, mul_trans);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_float_complex_matrix,
-                 octave_float_matrix, mul_trans);
+                    octave_float_matrix, mul_trans);
 
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_float_matrix, fcm_fm);
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_float_matrix, cm_fm);
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_matrix, fcm_m);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_float_matrix, assign);
+                       octave_float_matrix, assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
-                    octave_float_matrix, dbl_assign);
+                       octave_float_matrix, dbl_assign);
 }
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -148,48 +148,65 @@ DEFNDASSIGNOP_FN (dbl_assign, complex_ma
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_scalar,
                   float_scalar, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_scalar,
                   float_scalar, /=)
 
 void
 install_fcm_fs_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix, octave_float_scalar, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix, octave_float_scalar, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix, octave_float_scalar, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix, octave_float_scalar, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix, octave_float_scalar, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_float_complex_matrix, octave_float_scalar,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_float_complex_matrix, octave_float_scalar,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_float_complex_matrix, octave_float_scalar,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_float_complex_matrix, octave_float_scalar,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_float_complex_matrix, octave_float_scalar,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex_matrix, octave_float_scalar,
-                 ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_scalar, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_scalar, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_scalar, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_scalar, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_scalar, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_scalar, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex_matrix, octave_float_scalar,
-                 el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex_matrix, octave_float_scalar,
-                 el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex_matrix, octave_float_scalar,
-                 el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex_matrix, octave_float_scalar,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex_matrix, octave_float_scalar,
-                 el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex_matrix, octave_float_scalar,
-                 el_or);
+                    ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex_matrix, octave_float_scalar,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_complex_matrix, octave_float_scalar,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex_matrix, octave_float_scalar,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex_matrix, octave_float_scalar,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex_matrix, octave_float_scalar,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex_matrix, octave_float_scalar,
+                    ne);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex_matrix,
+                    octave_float_scalar,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_float_scalar, fcm_fs);
   INSTALL_CATOP_TI (ti, octave_complex_matrix, octave_float_scalar, cm_fs);
   INSTALL_CATOP_TI (ti, octave_float_complex_matrix, octave_scalar, fcm_s);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix,
-                    octave_float_scalar, assign);
+                       octave_float_scalar, assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_complex_matrix,
-                    octave_float_scalar, dbl_assign);
+                       octave_float_scalar, dbl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_float_complex_matrix,
-                    octave_float_scalar, assign_mul);
+                       octave_float_scalar, assign_mul);
   INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_float_complex_matrix,
-                    octave_float_scalar, assign_div);
+                       octave_float_scalar, assign_div);
 }
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -135,51 +135,65 @@ DEFCONV (float_complex_matrix_conv, floa
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 void
 install_fcs_fcm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_float_complex, octave_float_complex_matrix,
-                 add);
+                    add);
   INSTALL_BINOP_TI (ti, op_sub, octave_float_complex, octave_float_complex_matrix,
-                 sub);
+                    sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_float_complex, octave_float_complex_matrix,
-                 mul);
+                    mul);
   INSTALL_BINOP_TI (ti, op_div, octave_float_complex, octave_float_complex_matrix,
-                 div);
+                    div);
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex, octave_float_complex_matrix,
-                 pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex, octave_float_complex_matrix,
-                 ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex, octave_float_complex_matrix, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_complex, octave_float_complex_matrix, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex, octave_float_complex_matrix, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex, octave_float_complex_matrix, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex, octave_float_complex_matrix, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex, octave_float_complex_matrix, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_complex_matrix,
-                 el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_complex_matrix,
-                 el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_complex_matrix,
-                 el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex, octave_float_complex_matrix,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_complex_matrix,
-                 el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_complex_matrix,
-                 el_or);
+                    pow);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex,
+                    octave_float_complex_matrix,
+                    ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_complex, octave_float_complex_matrix,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_complex, octave_float_complex_matrix,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_complex, octave_float_complex_matrix,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_complex, octave_float_complex_matrix,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_complex, octave_float_complex_matrix,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_complex, octave_float_complex_matrix,
+                    ne);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex,
+                    octave_float_complex_matrix,
+                    el_or);
 
-  INSTALL_CATOP_TI (ti, octave_float_complex, octave_float_complex_matrix, fcs_fcm);
+  INSTALL_CATOP_TI (ti, octave_float_complex, octave_float_complex_matrix,
+                    fcs_fcm);
   INSTALL_CATOP_TI (ti, octave_complex, octave_float_complex_matrix, cs_fcm);
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_complex_matrix, fcs_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_float_complex_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_float_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_float_complex, octave_float_complex_matrix,
-                   float_complex_matrix_conv);
+                      float_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -172,40 +172,46 @@ install_fcs_fcs_ops (octave::type_info& 
   INSTALL_NCUNOP_TI (ti, op_incr, octave_float_complex, incr);
   INSTALL_NCUNOP_TI (ti, op_decr, octave_float_complex, decr);
 
   INSTALL_BINOP_TI (ti, op_add, octave_float_complex, octave_float_complex, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_float_complex, octave_float_complex, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_float_complex, octave_float_complex, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_float_complex, octave_float_complex, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex, octave_float_complex, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex, octave_float_complex, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex, octave_float_complex,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_complex, octave_float_complex, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_complex, octave_float_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_complex, octave_float_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_complex, octave_float_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_complex, octave_float_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_complex, octave_float_complex, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_complex, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_complex, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_complex, el_pow);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_complex,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_complex,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_complex,
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex, octave_float_complex,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_complex, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_complex, el_or);
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_complex,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_complex,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_float_complex, fcs_fcs);
   INSTALL_CATOP_TI (ti, octave_complex, octave_float_complex, cs_fcs);
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_complex, fcs_cs);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_float_complex,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_float_complex,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_null_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_null_str,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_null_sq_str,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -134,25 +134,30 @@ install_fcs_fm_ops (octave::type_info& t
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex, octave_float_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex, octave_float_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_complex, octave_float_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_complex, octave_float_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_complex, octave_float_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_complex, octave_float_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_complex, octave_float_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_complex, octave_float_matrix, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_matrix, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_matrix, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_matrix, el_pow);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_matrix,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_matrix,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_matrix,
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex, octave_float_matrix,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_matrix, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_matrix, el_or);
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_matrix,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_matrix,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_float_matrix, fcs_fm);
   INSTALL_CATOP_TI (ti, octave_complex, octave_float_matrix, cs_fm);
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_matrix, fcs_m);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_float_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_float_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -144,28 +144,33 @@ install_fcs_fs_ops (octave::type_info& t
   INSTALL_BINOP_TI (ti, op_pow, octave_float_complex, octave_float_scalar, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_complex, octave_float_scalar, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_complex, octave_float_scalar, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_complex, octave_float_scalar, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_complex, octave_float_scalar, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_complex, octave_float_scalar, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_complex, octave_float_scalar, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_complex, octave_float_scalar, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_scalar, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_scalar, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_scalar, el_pow);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_complex, octave_float_scalar,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_complex, octave_float_scalar,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_complex, octave_float_scalar,
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_complex, octave_float_scalar,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_scalar, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_scalar, el_or);
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_complex, octave_float_scalar,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_complex, octave_float_scalar,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_float_scalar, fcs_fs);
   INSTALL_CATOP_TI (ti, octave_complex, octave_float_scalar, cs_fs);
   INSTALL_CATOP_TI (ti, octave_float_complex, octave_scalar, fcs_s);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_float_scalar,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_complex, octave_float_scalar,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_complex, octave_scalar,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-fdm-fdm.cc b/libinterp/operators/op-fdm-fdm.cc
--- a/libinterp/operators/op-fdm-fdm.cc
+++ b/libinterp/operators/op-fdm-fdm.cc
@@ -86,24 +86,29 @@ CONVDECL (float_diag_matrix_to_float_mat
 void
 install_fdm_fdm_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_uplus, octave_float_diag_matrix, uplus);
   INSTALL_UNOP_TI (ti, op_uminus, octave_float_diag_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_float_diag_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_float_diag_matrix, transpose);
 
-  INSTALL_BINOP_TI (ti, op_add, octave_float_diag_matrix, octave_float_diag_matrix,
-                 add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_float_diag_matrix, octave_float_diag_matrix,
-                 sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_float_diag_matrix, octave_float_diag_matrix,
-                 mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_float_diag_matrix, octave_float_diag_matrix,
-                 div);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_diag_matrix, octave_float_diag_matrix,
-                 ldiv);
+  INSTALL_BINOP_TI (ti, op_add, octave_float_diag_matrix,
+                    octave_float_diag_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_float_diag_matrix,
+                    octave_float_diag_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_float_diag_matrix,
+                    octave_float_diag_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_float_diag_matrix,
+                    octave_float_diag_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_float_diag_matrix,
+                    octave_float_diag_matrix,
+                    ldiv);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_diag_matrix, octave_float_matrix,
-                      octave_float_matrix);
+                         octave_float_matrix);
   INSTALL_WIDENOP_TI (ti, octave_float_diag_matrix, octave_float_matrix,
-                   float_diag_matrix_to_float_matrix);
+                      float_diag_matrix_to_float_matrix);
 }
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -165,54 +165,65 @@ DEFCONV (float_complex_matrix_conv, floa
 
   return new octave_float_complex_matrix (FloatComplexNDArray
                                            (v.float_array_value ()));
 }
 
 void
 install_fm_fcm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_float_matrix, octave_float_complex_matrix, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_float_matrix, octave_float_complex_matrix, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_float_matrix, octave_float_complex_matrix, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_float_matrix, octave_float_complex_matrix, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_float_matrix, octave_float_complex_matrix, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_float_matrix, octave_float_complex_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_float_matrix, octave_float_complex_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_float_matrix, octave_float_complex_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_float_matrix, octave_float_complex_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_float_matrix, octave_float_complex_matrix,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_matrix,
-                 octave_float_complex_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_matrix, octave_float_complex_matrix, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_matrix, octave_float_complex_matrix, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_matrix, octave_float_complex_matrix, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_matrix, octave_float_complex_matrix, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_matrix, octave_float_complex_matrix, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_matrix, octave_float_complex_matrix, ne);
+                    octave_float_complex_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_matrix, octave_float_complex_matrix,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_matrix, octave_float_complex_matrix,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_matrix, octave_float_complex_matrix,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_matrix, octave_float_complex_matrix,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_matrix, octave_float_complex_matrix,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_matrix, octave_float_complex_matrix,
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix,
-                 octave_float_complex_matrix, el_mul);
+                    octave_float_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix,
-                 octave_float_complex_matrix, el_div);
+                    octave_float_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix,
-                 octave_float_complex_matrix, el_pow);
+                    octave_float_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix,
-                 octave_float_complex_matrix, el_ldiv);
+                    octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix,
-                 octave_float_complex_matrix, el_and);
+                    octave_float_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix,
-                 octave_float_complex_matrix, el_or);
+                    octave_float_complex_matrix, el_or);
   INSTALL_BINOP_TI (ti, op_trans_mul, octave_float_matrix,
-                 octave_float_complex_matrix, trans_mul);
+                    octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_float_matrix,
-                 octave_float_complex_matrix, trans_mul);
+                    octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_float_matrix,
-                 octave_float_complex_matrix, trans_ldiv);
+                    octave_float_complex_matrix, trans_ldiv);
   INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_float_matrix,
-                 octave_float_complex_matrix, trans_ldiv);
+                    octave_float_complex_matrix, trans_ldiv);
 
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_float_complex_matrix, fm_fcm);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_float_complex_matrix, m_fcm);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_complex_matrix, fm_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_matrix, octave_float_complex_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_float_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_float_matrix, octave_float_complex_matrix,
-                   float_complex_matrix_conv);
+                      float_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -143,25 +143,30 @@ install_fm_fcs_ops (octave::type_info& t
   INSTALL_BINOP_TI (ti, op_pow, octave_float_matrix, octave_float_complex, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_matrix, octave_float_complex, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_matrix, octave_float_complex, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_matrix, octave_float_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_matrix, octave_float_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_matrix, octave_float_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_matrix, octave_float_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_matrix, octave_float_complex, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_complex, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_complex, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_complex, el_pow);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_complex,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_complex,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_complex,
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix, octave_float_complex,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_complex, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_complex, el_or);
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_complex,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_complex,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_float_complex, fm_fcs);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_float_complex, m_fcs);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_complex, fm_cs);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_matrix, octave_float_complex,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_float_complex,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -206,60 +206,66 @@ install_fm_fm_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_pow, octave_float_matrix, octave_float_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_matrix, octave_float_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_matrix, octave_float_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_matrix, octave_float_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_matrix, octave_float_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_matrix, octave_float_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_matrix, octave_float_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_matrix, octave_float_matrix, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_matrix, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_matrix, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix, octave_float_matrix, el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_matrix, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_matrix, el_or);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_matrix,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_matrix,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_matrix,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix, octave_float_matrix,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_matrix,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_matrix,
+                    el_or);
   INSTALL_BINOP_TI (ti, op_el_and_not, octave_float_matrix, octave_float_matrix,
-                 el_and_not);
+                    el_and_not);
   INSTALL_BINOP_TI (ti, op_el_or_not, octave_float_matrix, octave_float_matrix,
-                 el_or_not);
+                    el_or_not);
   INSTALL_BINOP_TI (ti, op_el_not_and, octave_float_matrix, octave_float_matrix,
-                 el_not_and);
+                    el_not_and);
   INSTALL_BINOP_TI (ti, op_el_not_or, octave_float_matrix, octave_float_matrix,
-                 el_not_or);
+                    el_not_or);
   INSTALL_BINOP_TI (ti, op_trans_mul, octave_float_matrix, octave_float_matrix,
-                 trans_mul);
+                    trans_mul);
   INSTALL_BINOP_TI (ti, op_mul_trans, octave_float_matrix, octave_float_matrix,
-                 mul_trans);
+                    mul_trans);
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_float_matrix, octave_float_matrix,
-                 trans_mul);
+                    trans_mul);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_float_matrix, octave_float_matrix,
-                 mul_trans);
+                    mul_trans);
   INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_float_matrix, octave_float_matrix,
-                 trans_ldiv);
+                    trans_ldiv);
   INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_float_matrix, octave_float_matrix,
-                 trans_ldiv);
+                    trans_ldiv);
 
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_float_matrix, fm_fm);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_float_matrix, m_fm);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_matrix, fm_m);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix,
-                    octave_float_matrix, assign);
+                       octave_float_matrix, assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix,
-                    octave_float_matrix, dbl_assign);
+                       octave_float_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_null_matrix,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_null_str,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_float_matrix, octave_float_matrix,
-                    assign_add);
+                       assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_float_matrix, octave_float_matrix,
-                    assign_sub);
+                       assign_sub);
   INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_float_matrix, octave_float_matrix,
-                    assign_el_mul);
+                       assign_el_mul);
   INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_float_matrix, octave_float_matrix,
-                    assign_el_div);
+                       assign_el_div);
 }
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -140,32 +140,39 @@ install_fm_fs_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_pow, octave_float_matrix, octave_float_scalar, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_matrix, octave_float_scalar, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_matrix, octave_float_scalar, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_matrix, octave_float_scalar, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_matrix, octave_float_scalar, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_matrix, octave_float_scalar, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_matrix, octave_float_scalar, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_matrix, octave_float_scalar, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_scalar, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_scalar, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_scalar, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix, octave_float_scalar, el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_scalar, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_scalar, el_or);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_matrix, octave_float_scalar,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_matrix, octave_float_scalar,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_matrix, octave_float_scalar,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_matrix, octave_float_scalar,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_matrix, octave_float_scalar,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_matrix, octave_float_scalar,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_float_scalar, fm_fs);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_float_scalar, m_fs);
   INSTALL_CATOP_TI (ti, octave_float_matrix, octave_scalar, fm_s);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_float_scalar,
-                    assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_float_scalar, dbl_assign);
+                       assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_float_scalar,
+                       dbl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_float_matrix, octave_float_scalar,
-                    assign_add);
+                       assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_float_matrix, octave_float_scalar,
-                    assign_sub);
+                       assign_sub);
   INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_float_matrix, octave_float_scalar,
-                    assign_mul);
+                       assign_mul);
   INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_float_matrix, octave_float_scalar,
-                    assign_div);
+                       assign_div);
 }
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -140,46 +140,57 @@ DEFCONV (float_complex_matrix_conv, floa
 
   return new octave_float_complex_matrix (FloatComplexMatrix
                                             (v.float_matrix_value ()));
 }
 
 void
 install_fs_fcm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_float_scalar, octave_float_complex_matrix, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_float_scalar, octave_float_complex_matrix, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_float_scalar, octave_float_complex_matrix, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_float_scalar, octave_float_complex_matrix, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_float_scalar, octave_float_complex_matrix, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_float_scalar, octave_float_complex_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_float_scalar, octave_float_complex_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_float_scalar, octave_float_complex_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_float_scalar, octave_float_complex_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_float_scalar, octave_float_complex_matrix,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_scalar,
-                 octave_float_complex_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_lt, octave_float_scalar, octave_float_complex_matrix, lt);
-  INSTALL_BINOP_TI (ti, op_le, octave_float_scalar, octave_float_complex_matrix, le);
-  INSTALL_BINOP_TI (ti, op_eq, octave_float_scalar, octave_float_complex_matrix, eq);
-  INSTALL_BINOP_TI (ti, op_ge, octave_float_scalar, octave_float_complex_matrix, ge);
-  INSTALL_BINOP_TI (ti, op_gt, octave_float_scalar, octave_float_complex_matrix, gt);
-  INSTALL_BINOP_TI (ti, op_ne, octave_float_scalar, octave_float_complex_matrix, ne);
+                    octave_float_complex_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_lt, octave_float_scalar, octave_float_complex_matrix,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_le, octave_float_scalar, octave_float_complex_matrix,
+                    le);
+  INSTALL_BINOP_TI (ti, op_eq, octave_float_scalar, octave_float_complex_matrix,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_ge, octave_float_scalar, octave_float_complex_matrix,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_gt, octave_float_scalar, octave_float_complex_matrix,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_ne, octave_float_scalar, octave_float_complex_matrix,
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar,
-                 octave_float_complex_matrix, el_mul);
+                    octave_float_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar,
-                 octave_float_complex_matrix, el_div);
+                    octave_float_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar,
-                 octave_float_complex_matrix, el_pow);
+                    octave_float_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar,
-                 octave_float_complex_matrix, el_ldiv);
+                    octave_float_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar,
-                 octave_float_complex_matrix, el_and);
+                    octave_float_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar,
-                 octave_float_complex_matrix, el_or);
+                    octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_float_complex_matrix, fs_fcm);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_float_complex_matrix, s_fcm);
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_complex_matrix, fs_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_float_complex_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_float_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_float_scalar, octave_float_complex_matrix,
-                   float_complex_matrix_conv);
+                      float_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -146,25 +146,30 @@ install_fs_fcs_ops (octave::type_info& t
   INSTALL_BINOP_TI (ti, op_pow, octave_float_scalar, octave_float_complex, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_scalar, octave_float_complex, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_scalar, octave_float_complex, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_scalar, octave_float_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_scalar, octave_float_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_scalar, octave_float_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_scalar, octave_float_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_scalar, octave_float_complex, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_complex, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_complex, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_complex, el_pow);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_complex,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_complex,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_complex,
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar, octave_float_complex,
-                 el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_complex, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_complex, el_or);
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_complex,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_complex,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_float_complex, fs_fcs);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_float_complex, s_fcs);
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_complex, fs_cs);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_float_complex,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_float_complex,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 }
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -134,25 +134,31 @@ install_fs_fm_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_pow, octave_float_scalar, octave_float_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_scalar, octave_float_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_scalar, octave_float_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_scalar, octave_float_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_scalar, octave_float_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_scalar, octave_float_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_scalar, octave_float_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_scalar, octave_float_matrix, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_matrix, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_matrix, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar, octave_float_matrix, el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_matrix, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_matrix, el_or);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_matrix,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_matrix,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_matrix,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar, octave_float_matrix,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_matrix,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_matrix,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_float_matrix, fs_fm);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_float_matrix, s_fm);
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_matrix, fs_m);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_float_matrix,
-                      octave_float_matrix);
+                         octave_float_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_float_matrix, octave_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_float_scalar, octave_float_matrix, matrix_conv);
 }
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -156,30 +156,36 @@ install_fs_fs_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_pow, octave_float_scalar, octave_float_scalar, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_float_scalar, octave_float_scalar, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_float_scalar, octave_float_scalar, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_float_scalar, octave_float_scalar, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_float_scalar, octave_float_scalar, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_float_scalar, octave_float_scalar, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_float_scalar, octave_float_scalar, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_float_scalar, octave_float_scalar, ne);
-  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_scalar, el_mul);
-  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_scalar, el_div);
-  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_scalar, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar, octave_float_scalar, el_ldiv);
-  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_scalar, el_and);
-  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_scalar, el_or);
+  INSTALL_BINOP_TI (ti, op_el_mul, octave_float_scalar, octave_float_scalar,
+                    el_mul);
+  INSTALL_BINOP_TI (ti, op_el_div, octave_float_scalar, octave_float_scalar,
+                    el_div);
+  INSTALL_BINOP_TI (ti, op_el_pow, octave_float_scalar, octave_float_scalar,
+                    el_pow);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_float_scalar, octave_float_scalar,
+                    el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_float_scalar, octave_float_scalar,
+                    el_and);
+  INSTALL_BINOP_TI (ti, op_el_or, octave_float_scalar, octave_float_scalar,
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_float_scalar, fs_fs);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_float_scalar, s_fs);
   INSTALL_CATOP_TI (ti, octave_float_scalar, octave_scalar, fs_s);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_float_scalar,
-                      octave_float_matrix);
+                         octave_float_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_float_scalar, octave_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_null_matrix,
-                      octave_float_matrix);
+                         octave_float_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_null_str,
-                      octave_float_matrix);
+                         octave_float_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_null_sq_str,
-                      octave_float_matrix);
+                         octave_float_matrix);
 }
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -153,27 +153,31 @@ install_m_cm_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_le, octave_matrix, octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_matrix, octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_matrix, octave_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_matrix, octave_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_matrix, octave_complex_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_matrix, octave_complex_matrix, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_matrix, octave_complex_matrix,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_matrix, octave_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_matrix, octave_complex_matrix, el_or);
-  INSTALL_BINOP_TI (ti, op_trans_mul, octave_matrix, octave_complex_matrix, trans_mul);
-  INSTALL_BINOP_TI (ti, op_herm_mul, octave_matrix, octave_complex_matrix, trans_mul);
+  INSTALL_BINOP_TI (ti, op_trans_mul, octave_matrix, octave_complex_matrix,
+                    trans_mul);
+  INSTALL_BINOP_TI (ti, op_herm_mul, octave_matrix, octave_complex_matrix,
+                    trans_mul);
   INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_matrix, octave_complex_matrix,
-                 trans_ldiv);
+                    trans_ldiv);
   INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_matrix, octave_complex_matrix,
-                 trans_ldiv);
+                    trans_ldiv);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_complex_matrix, m_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_matrix, octave_complex_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 
-  INSTALL_WIDENOP_TI (ti, octave_matrix, octave_complex_matrix, complex_matrix_conv);
+  INSTALL_WIDENOP_TI (ti, octave_matrix, octave_complex_matrix,
+                      complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -134,12 +134,13 @@ install_m_cs_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_div, octave_matrix, octave_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_matrix, octave_complex, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_matrix, octave_complex, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_matrix, octave_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_matrix, octave_complex, el_or);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_complex, m_cs);
 
-  INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_complex, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_complex,
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_matrix, octave_complex,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -198,19 +198,25 @@ install_m_m_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_matrix, octave_matrix, trans_mul);
   INSTALL_BINOP_TI (ti, op_mul_herm, octave_matrix, octave_matrix, mul_trans);
   INSTALL_BINOP_TI (ti, op_trans_ldiv, octave_matrix, octave_matrix, trans_ldiv);
   INSTALL_BINOP_TI (ti, op_herm_ldiv, octave_matrix, octave_matrix, trans_ldiv);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_matrix, m_m);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_matrix, assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_matrix, sgl_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_matrix,
+                       sgl_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_matrix,
+                       null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_str,
+                       null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_null_sq_str,
+                       null_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_matrix, octave_matrix, assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_matrix, octave_matrix, assign_sub);
-  INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_matrix, octave_matrix, assign_el_mul);
-  INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_matrix, octave_matrix, assign_el_div);
+  INSTALL_ASSIGNOP_TI (ti, op_el_mul_eq, octave_matrix, octave_matrix,
+                       assign_el_mul);
+  INSTALL_ASSIGNOP_TI (ti, op_el_div_eq, octave_matrix, octave_matrix,
+                       assign_el_div);
 }
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -140,17 +140,18 @@ install_m_s_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_pow, octave_matrix, octave_scalar, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_matrix, octave_scalar, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_scalar, m_s);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_scalar, assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_scalar, sgl_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_matrix, octave_scalar,
+                       sgl_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_float_complex_matrix, octave_scalar,
-                    clx_sgl_assign);
+                       clx_sgl_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_add_eq, octave_matrix, octave_scalar, assign_add);
   INSTALL_ASSIGNOP_TI (ti, op_sub_eq, octave_matrix, octave_scalar, assign_sub);
   INSTALL_ASSIGNOP_TI (ti, op_mul_eq, octave_matrix, octave_scalar, assign_mul);
   INSTALL_ASSIGNOP_TI (ti, op_div_eq, octave_matrix, octave_scalar, assign_div);
 }
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -146,36 +146,37 @@ DEFCONV (sparse_complex_matrix_conv, mat
 void
 install_m_scm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_matrix, octave_sparse_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_matrix, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_matrix, octave_sparse_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_matrix, octave_sparse_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_matrix, octave_sparse_complex_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_matrix, octave_sparse_complex_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_matrix, octave_sparse_complex_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_matrix, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_matrix, octave_sparse_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_matrix, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_matrix, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_matrix, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_matrix, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_matrix, octave_sparse_complex_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_matrix, octave_sparse_complex_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_matrix, octave_sparse_complex_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_matrix, octave_sparse_complex_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_matrix, octave_sparse_complex_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_matrix, octave_sparse_complex_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_sparse_complex_matrix, m_scm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_sparse_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_matrix, octave_sparse_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -141,18 +141,20 @@ void
 install_m_sm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_matrix, octave_sparse_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_matrix, octave_sparse_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_matrix, octave_sparse_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_matrix, octave_sparse_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_matrix, octave_sparse_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_matrix, octave_sparse_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_mul_trans, octave_matrix, octave_sparse_matrix, mul_trans);
-  INSTALL_BINOP_TI (ti, op_mul_herm, octave_matrix, octave_sparse_matrix, mul_trans);
+  INSTALL_BINOP_TI (ti, op_mul_trans, octave_matrix, octave_sparse_matrix,
+                    mul_trans);
+  INSTALL_BINOP_TI (ti, op_mul_herm, octave_matrix, octave_sparse_matrix,
+                    mul_trans);
   INSTALL_BINOP_TI (ti, op_lt, octave_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_matrix, octave_sparse_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_matrix, octave_sparse_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_matrix, octave_sparse_matrix, el_div);
@@ -162,10 +164,10 @@ install_m_sm_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_or, octave_matrix, octave_sparse_matrix,  el_or);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_sparse_matrix, m_sm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_matrix, octave_sparse_matrix, assign)
   INSTALL_ASSIGNCONV_TI (ti, octave_matrix, octave_sparse_matrix, octave_matrix)
 
   INSTALL_WIDENOP_TI (ti, octave_matrix, octave_sparse_matrix,
-                   sparse_matrix_conv);
+                      sparse_matrix_conv);
 }
diff --git a/libinterp/operators/op-pm-pm.cc b/libinterp/operators/op-pm-pm.cc
--- a/libinterp/operators/op-pm-pm.cc
+++ b/libinterp/operators/op-pm-pm.cc
@@ -80,10 +80,11 @@ install_pm_pm_ops (octave::type_info& ti
   INSTALL_UNOP_TI (ti, op_hermitian, octave_perm_matrix, transpose);
 
   INSTALL_BINOP_TI (ti, op_mul, octave_perm_matrix, octave_perm_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_perm_matrix, octave_perm_matrix, div);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_perm_matrix, octave_perm_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_pow, octave_perm_matrix, octave_scalar, pow);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_perm_matrix, octave_matrix, octave_matrix);
-  INSTALL_WIDENOP_TI (ti, octave_perm_matrix, octave_matrix, perm_matrix_to_matrix);
+  INSTALL_WIDENOP_TI (ti, octave_perm_matrix, octave_matrix,
+                      perm_matrix_to_matrix);
 }
diff --git a/libinterp/operators/op-pm-scm.cc b/libinterp/operators/op-pm-scm.cc
--- a/libinterp/operators/op-pm-scm.cc
+++ b/libinterp/operators/op-pm-scm.cc
@@ -90,16 +90,16 @@ DEFBINOP (div_scm_pm, sparse_complex_mat
 
   return v1.sparse_complex_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_scm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_mul, octave_perm_matrix, octave_sparse_complex_matrix,
-                 mul_pm_scm);
+                    mul_pm_scm);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_perm_matrix, octave_sparse_complex_matrix,
-                 ldiv_pm_scm);
+                    ldiv_pm_scm);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_perm_matrix,
-                 mul_scm_pm);
+                    mul_scm_pm);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_perm_matrix,
-                 div_scm_pm);
+                    div_scm_pm);
 }
diff --git a/libinterp/operators/op-pm-sm.cc b/libinterp/operators/op-pm-sm.cc
--- a/libinterp/operators/op-pm-sm.cc
+++ b/libinterp/operators/op-pm-sm.cc
@@ -86,16 +86,16 @@ DEFBINOP (div_sm_pm, sparse_matrix, perm
 
   return v1.sparse_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_sm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_mul, octave_perm_matrix, octave_sparse_matrix,
-                 mul_pm_sm);
+                    mul_pm_sm);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_perm_matrix, octave_sparse_matrix,
-                 ldiv_pm_sm);
+                    ldiv_pm_sm);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_perm_matrix,
-                 mul_sm_pm);
+                    mul_sm_pm);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_perm_matrix,
-                 div_sm_pm);
+                    div_sm_pm);
 }
diff --git a/libinterp/operators/op-range.cc b/libinterp/operators/op-range.cc
--- a/libinterp/operators/op-range.cc
+++ b/libinterp/operators/op-range.cc
@@ -103,17 +103,17 @@ install_range_ops (octave::type_info& ti
   INSTALL_UNOP_TI (ti, op_hermitian, octave_range, transpose);
 
   INSTALL_BINOP_TI (ti, op_add, octave_range, octave_scalar, addrs);
   INSTALL_BINOP_TI (ti, op_add, octave_scalar, octave_range, addsr);
   INSTALL_BINOP_TI (ti, op_sub, octave_range, octave_scalar, subrs);
   INSTALL_BINOP_TI (ti, op_sub, octave_scalar, octave_range, subsr);
   INSTALL_BINOP_TI (ti, op_mul, octave_range, octave_scalar, mulrs);
   INSTALL_BINOP_TI (ti, op_mul, octave_scalar, octave_range, mulsr);
-  
+
   INSTALL_BINOP_TI (ti, op_el_mul, octave_range, octave_scalar, mulrs);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_scalar, octave_range, mulsr);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_range, el_powsr);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_complex, octave_range, el_powcsr);
 
   INSTALL_CATOP_TI (ti, octave_range, octave_range, r_r);
   INSTALL_CATOP_TI (ti, octave_range, octave_scalar, r_s);
   INSTALL_CATOP_TI (ti, octave_range, octave_matrix, r_m);
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -130,21 +130,23 @@ install_s_cm_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_le, octave_scalar, octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_scalar, octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_scalar, octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_scalar, octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_scalar, octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_scalar, octave_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_scalar, octave_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_complex_matrix, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_complex_matrix, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_complex_matrix,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_complex_matrix, s_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_complex_matrix,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 
-  INSTALL_WIDENOP_TI (ti, octave_scalar, octave_complex_matrix, complex_matrix_conv);
+  INSTALL_WIDENOP_TI (ti, octave_scalar, octave_complex_matrix,
+                      complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -145,12 +145,13 @@ install_s_cs_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_div, octave_scalar, octave_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_complex, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_complex, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_complex, el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_complex, s_cs);
 
-  INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_complex, octave_complex_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_complex,
+                         octave_complex_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_complex,
-                      octave_float_complex_matrix);
+                         octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-s-m.cc b/libinterp/operators/op-s-m.cc
--- a/libinterp/operators/op-s-m.cc
+++ b/libinterp/operators/op-s-m.cc
@@ -128,12 +128,13 @@ install_s_m_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_matrix, s_m);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_matrix, octave_matrix);
-  INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_matrix, octave_float_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_matrix,
+                         octave_float_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_scalar, octave_matrix, matrix_conv);
 }
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -164,14 +164,15 @@ install_s_s_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_scalar, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_scalar, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_scalar, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_scalar, el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_scalar, s_s);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_scalar, octave_matrix);
-  INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_scalar, octave_float_matrix);
+  INSTALL_ASSIGNCONV_TI (ti, octave_float_scalar, octave_scalar,
+                         octave_float_matrix);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_null_sq_str, octave_matrix);
 }
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -150,36 +150,37 @@ DEFCONV (sparse_complex_matrix_conv, sca
 void
 install_s_scm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_scalar, octave_sparse_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_scalar, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_scalar, octave_sparse_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_scalar, octave_sparse_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_scalar, octave_sparse_complex_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_scalar, octave_sparse_complex_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_scalar, octave_sparse_complex_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_scalar, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_scalar, octave_sparse_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_scalar, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_scalar, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_scalar, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_scalar, octave_sparse_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_scalar, octave_sparse_complex_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_scalar, octave_sparse_complex_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_scalar, octave_sparse_complex_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_sparse_complex_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_sparse_complex_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_sparse_complex_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_sparse_complex_matrix, s_scm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_sparse_complex_matrix,
-                      octave_complex_matrix);
+                         octave_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_scalar, octave_sparse_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-s-sm.cc b/libinterp/operators/op-s-sm.cc
--- a/libinterp/operators/op-s-sm.cc
+++ b/libinterp/operators/op-s-sm.cc
@@ -157,10 +157,11 @@ install_s_sm_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_scalar, octave_sparse_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_scalar, octave_sparse_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_scalar, octave_sparse_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_sparse_matrix, s_sm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_scalar, octave_sparse_matrix, octave_matrix);
 
-  INSTALL_WIDENOP_TI (ti, octave_scalar, octave_sparse_matrix, sparse_matrix_conv);
+  INSTALL_WIDENOP_TI (ti, octave_scalar, octave_sparse_matrix,
+                      sparse_matrix_conv);
 }
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -107,38 +107,48 @@ oct_assignop_conv_and_assign (octave_bas
 }
 
 void
 install_sbm_b_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_bool_matrix, octave_bool, eq);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_bool_matrix, octave_bool, ne);
 
-  INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_bool_matrix, octave_bool, el_and);
+  INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_bool_matrix, octave_bool,
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_bool_matrix, octave_bool, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_bool, sbm_b);
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_scalar, sbm_s);
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_bool, sm_b);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_bool, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_bool,
+                       assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_scalar,
-                    conv_and_assign);
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int8_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int16_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int32_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int64_scalar,
-                    conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int8_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int16_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int32_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int64_scalar,
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint8_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint16_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint32_scalar,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint64_scalar,
-                    conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint8_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint16_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint32_scalar,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint64_scalar,
+                       conv_and_assign);
 }
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -114,57 +114,68 @@ oct_assignop_conv_and_assign (octave_bas
 
 void
 install_sbm_bm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_bool_matrix, octave_bool_matrix, ne);
 
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_bool_matrix, octave_bool_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_bool_matrix, octave_bool_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_bool_matrix, sbm_bm);
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_bool_matrix, sm_bm);
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_matrix, sbm_m);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
-                    octave_bool_matrix, assign);
+                       octave_bool_matrix, assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_matrix,
-                    conv_and_assign);
+                       conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
-                    octave_char_matrix_str, conv_and_assign);
+                       octave_char_matrix_str, conv_and_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
-                    octave_char_matrix_sq_str, conv_and_assign);
+                       octave_char_matrix_sq_str, conv_and_assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_range,
-                    conv_and_assign);
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_sparse_matrix,
-                    conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_sparse_matrix,
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int8_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int16_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int32_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_int64_matrix,
-                    conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int8_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int16_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int32_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_int64_matrix,
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint8_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint16_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint32_matrix,
-                    conv_and_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_uint64_matrix,
-                    conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint8_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint16_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint32_matrix,
+                       conv_and_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_uint64_matrix,
+                       conv_and_assign);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_null_matrix,
-                    null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_null_matrix,
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_null_str,
-                    null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
+                       octave_null_sq_str,
+                       null_assign);
 }
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -83,25 +83,25 @@ install_sbm_sbm_ops (octave::type_info& 
 {
   INSTALL_UNOP_TI (ti, op_not, octave_sparse_bool_matrix, not);
   INSTALL_UNOP_TI (ti, op_uplus, octave_sparse_bool_matrix, uplus);
   INSTALL_UNOP_TI (ti, op_uminus, octave_sparse_bool_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_sparse_bool_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_sparse_bool_matrix, transpose);
 
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_bool_matrix,
-                 octave_sparse_bool_matrix, eq);
+                    octave_sparse_bool_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_bool_matrix,
-                 octave_sparse_bool_matrix, ne);
+                    octave_sparse_bool_matrix, ne);
 
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_bool_matrix,
-                 octave_sparse_bool_matrix, el_and);
+                    octave_sparse_bool_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_bool_matrix,
-                 octave_sparse_bool_matrix, el_or);
+                    octave_sparse_bool_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_sparse_bool_matrix,
-                 sbm_sbm);
+                    sbm_sbm);
   INSTALL_CATOP_TI (ti, octave_sparse_bool_matrix, octave_sparse_matrix, sbm_sm);
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_sparse_bool_matrix, sm_sbm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_bool_matrix,
-                    octave_sparse_bool_matrix, assign);
+                       octave_sparse_bool_matrix, assign);
 }
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -155,54 +155,54 @@ DEFASSIGNOP (assign, sparse_complex_matr
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix,
-                 octave_complex_matrix, add);
+                    octave_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix,
-                 octave_complex_matrix, sub);
+                    octave_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix,
-                 octave_complex_matrix, mul);
+                    octave_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix,
-                 octave_complex_matrix, div);
+                    octave_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix,
-                 octave_complex_matrix, pow);
+                    octave_complex_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix,
-                 octave_complex_matrix, ldiv);
+                    octave_complex_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_trans_mul, octave_sparse_complex_matrix,
-                 octave_complex_matrix, trans_mul);
+                    octave_complex_matrix, trans_mul);
   INSTALL_BINOP_TI (ti, op_herm_mul, octave_sparse_complex_matrix,
-                 octave_complex_matrix, herm_mul);
+                    octave_complex_matrix, herm_mul);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix,
-                 octave_complex_matrix, lt);
+                    octave_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix,
-                 octave_complex_matrix, le);
+                    octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix,
-                 octave_complex_matrix, eq);
+                    octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix,
-                 octave_complex_matrix, ge);
+                    octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix,
-                 octave_complex_matrix, gt);
+                    octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix,
-                 octave_complex_matrix, ne);
+                    octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_mul);
+                    octave_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_div);
+                    octave_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_pow);
+                    octave_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_ldiv);
+                    octave_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_and);
+                    octave_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix,
-                 octave_complex_matrix, el_or);
+                    octave_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix,
-                 octave_complex_matrix, scm_cm);
+                    octave_complex_matrix, scm_cm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_complex_matrix, assign);
+                       octave_complex_matrix, assign);
 }
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -156,39 +156,45 @@ DEFASSIGNOP (assign, sparse_complex_matr
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cs_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_complex, add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_complex, sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_complex, mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_complex, div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix, octave_complex, pow);
+  INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_complex,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_complex,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_complex,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_complex,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix, octave_complex,
+                    pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_complex,
-                 ldiv);
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix, octave_complex, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix, octave_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix, octave_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix, octave_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix, octave_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix, octave_complex, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix, octave_complex,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix, octave_complex,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix, octave_complex,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix, octave_complex,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix, octave_complex,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix, octave_complex,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix, octave_complex, scm_cs);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix, octave_complex,
-                    assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
+                       octave_complex,
+                       assign);
 }
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -151,33 +151,34 @@ DEFASSIGNOP (assign, sparse_complex_matr
 void
 install_scm_m_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix, octave_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix, octave_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix, octave_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix, octave_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix, octave_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix, octave_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix, octave_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix, octave_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix, octave_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix, octave_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix, octave_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix, octave_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix, octave_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix, octave_matrix, scm_m);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix, octave_matrix,
-                    assign);
+                       assign);
 }
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -168,33 +168,34 @@ DEFASSIGNOP (assign, sparse_complex_matr
 void
 install_scm_s_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_scalar, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_scalar, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_scalar, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_scalar, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix, octave_scalar, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_scalar, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_scalar,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix, octave_scalar, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix, octave_scalar, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix, octave_scalar, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix, octave_scalar, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix, octave_scalar, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix, octave_scalar, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix, octave_scalar,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix, octave_scalar,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix, octave_scalar,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix, octave_scalar,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix, octave_scalar,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix, octave_scalar,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix, octave_scalar, scm_s);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix, octave_scalar,
-                    assign);
+                       assign);
 }
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -197,57 +197,57 @@ install_scm_scm_ops (octave::type_info& 
   INSTALL_UNOP_TI (ti, op_hermitian, octave_sparse_complex_matrix, hermitian);
 
 #if 0
   INSTALL_NCUNOP_TI (ti, op_incr, octave_sparse_complex_matrix, incr);
   INSTALL_NCUNOP_TI (ti, op_decr, octave_sparse_complex_matrix, decr);
 #endif
 
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, add);
+                    octave_sparse_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, sub);
+                    octave_sparse_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, mul);
+                    octave_sparse_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, div);
+                    octave_sparse_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, pow);
+                    octave_sparse_complex_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, ldiv);
+                    octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, lt);
+                    octave_sparse_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, le);
+                    octave_sparse_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, eq);
+                    octave_sparse_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, ge);
+                    octave_sparse_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, gt);
+                    octave_sparse_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, ne);
+                    octave_sparse_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_mul);
+                    octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_div);
+                    octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_pow);
+                    octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_ldiv);
+                    octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_and);
+                    octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, el_or);
+                    octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix,
-                 octave_sparse_complex_matrix, scm_scm);
+                    octave_sparse_complex_matrix, scm_scm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_sparse_complex_matrix, assign);
+                       octave_sparse_complex_matrix, assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_null_matrix, null_assign);
+                       octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_null_str, null_assign);
+                       octave_null_str, null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_null_sq_str, null_assign);
+                       octave_null_sq_str, null_assign);
 }
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -132,50 +132,57 @@ DEFBINOP_FN (el_or,  sparse_complex_matr
 
 DEFCATOP_FN (scm_sm, sparse_complex_matrix, sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_complex_matrix, sparse_matrix, assign)
 
 void
 install_scm_sm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 ldiv);
+  INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    pow);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_complex_matrix,
+                    octave_sparse_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 lt);
+                    lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 le);
+                    le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 eq);
+                    eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 ge);
+                    ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 gt);
+                    gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_complex_matrix, octave_sparse_matrix,
-                 ne);
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_mul);
+                    octave_sparse_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_div);
+                    octave_sparse_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_pow);
+                    octave_sparse_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_ldiv);
+                    octave_sparse_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_and);
+                    octave_sparse_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_complex_matrix,
-                 octave_sparse_matrix, el_or);
+                    octave_sparse_matrix, el_or);
 
-  INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix, octave_sparse_matrix, scm_sm);
+  INSTALL_CATOP_TI (ti, octave_sparse_complex_matrix, octave_sparse_matrix,
+                    scm_sm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_complex_matrix,
-                    octave_sparse_matrix, assign);
+                       octave_sparse_matrix, assign);
 }
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -149,36 +149,37 @@ DEFCONV (sparse_complex_matrix_conv, spa
 void
 install_sm_cm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_complex_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_matrix, octave_complex_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_complex_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_complex_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_matrix, octave_complex_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_matrix, octave_complex_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_matrix, octave_complex_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix, octave_complex_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix, octave_complex_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_complex_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix, octave_complex_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix, octave_complex_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_complex_matrix, sm_cm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_sparse_matrix, octave_complex_matrix,
-                      octave_sparse_complex_matrix);
+                         octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_sparse_matrix, octave_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-sm-cs.cc b/libinterp/operators/op-sm-cs.cc
--- a/libinterp/operators/op-sm-cs.cc
+++ b/libinterp/operators/op-sm-cs.cc
@@ -155,17 +155,18 @@ install_sm_cs_ops (octave::type_info& ti
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_matrix, octave_complex, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_matrix, octave_complex, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_matrix, octave_complex, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_matrix, octave_complex, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_matrix, octave_complex, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_matrix, octave_complex, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix, octave_complex, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix, octave_complex, el_pow);
-  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_complex, el_ldiv);
+  INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_complex,
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix, octave_complex, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix, octave_complex, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_complex, sm_cs);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_sparse_matrix, octave_complex,
-                      octave_sparse_complex_matrix);
+                         octave_sparse_complex_matrix);
 }
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -144,27 +144,30 @@ void
 install_sm_m_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_matrix, octave_matrix, pow);
   INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_matrix, ldiv);
-  INSTALL_BINOP_TI (ti, op_trans_mul, octave_sparse_matrix, octave_matrix, trans_mul);
-  INSTALL_BINOP_TI (ti, op_herm_mul, octave_sparse_matrix, octave_matrix, trans_mul);
+  INSTALL_BINOP_TI (ti, op_trans_mul, octave_sparse_matrix, octave_matrix,
+                    trans_mul);
+  INSTALL_BINOP_TI (ti, op_herm_mul, octave_sparse_matrix, octave_matrix,
+                    trans_mul);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_matrix, octave_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_matrix, octave_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_matrix, octave_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_matrix, octave_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_matrix, octave_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_matrix, octave_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_matrix, octave_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix, octave_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix, octave_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix, octave_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix, octave_matrix,  el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_matrix, sm_m);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_matrix, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_matrix,
+                       assign);
 }
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -173,10 +173,11 @@ install_sm_s_ops (octave::type_info& ti)
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix, octave_scalar, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix, octave_scalar, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix, octave_scalar, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_scalar, sm_s);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_scalar, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_scalar,
+                       assign);
 }
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -138,53 +138,60 @@ DEFCONV (sparse_complex_matrix_conv, spa
   const octave_sparse_matrix& v
     = dynamic_cast<const octave_sparse_matrix&> (a);
   return new octave_sparse_complex_matrix (v.sparse_complex_matrix_value ());
 }
 
 void
 install_sm_scm_ops (octave::type_info& ti)
 {
-  INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 add);
-  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 sub);
-  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 mul);
-  INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 div);
-  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 ldiv);
+  INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    add);
+  INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    sub);
+  INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    mul);
+  INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    div);
+  INSTALL_BINOP_TI (ti, op_pow, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    pow);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix,
+                    octave_sparse_complex_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 lt);
+                    lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 le);
+                    le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 eq);
+                    eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 ge);
+                    ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 gt);
+                    gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_matrix, octave_sparse_complex_matrix,
-                 ne);
+                    ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_mul);
+                    octave_sparse_complex_matrix, el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_div);
+                    octave_sparse_complex_matrix, el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_pow);
+                    octave_sparse_complex_matrix, el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_ldiv);
+                    octave_sparse_complex_matrix, el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_and);
+                    octave_sparse_complex_matrix, el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix,
-                 octave_sparse_complex_matrix, el_or);
+                    octave_sparse_complex_matrix, el_or);
 
-  INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_sparse_complex_matrix, sm_scm);
+  INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_sparse_complex_matrix,
+                    sm_scm);
 
   INSTALL_ASSIGNCONV_TI (ti, octave_sparse_matrix, octave_sparse_complex_matrix,
-                      octave_sparse_complex_matrix);
+                         octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP_TI (ti, octave_sparse_matrix, octave_sparse_complex_matrix,
-                   sparse_complex_matrix_conv);
+                      sparse_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -164,40 +164,41 @@ install_sm_sm_ops (octave::type_info& ti
   INSTALL_UNOP_TI (ti, op_transpose, octave_sparse_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_sparse_matrix, transpose);
 
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_matrix, octave_sparse_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_matrix, octave_sparse_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_matrix, octave_sparse_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_matrix, octave_sparse_matrix, div);
   INSTALL_BINOP_TI (ti, op_pow, octave_sparse_matrix, octave_sparse_matrix, pow);
-  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_sparse_matrix, ldiv);
+  INSTALL_BINOP_TI (ti, op_ldiv, octave_sparse_matrix, octave_sparse_matrix,
+                    ldiv);
   INSTALL_BINOP_TI (ti, op_lt, octave_sparse_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP_TI (ti, op_le, octave_sparse_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP_TI (ti, op_eq, octave_sparse_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP_TI (ti, op_ge, octave_sparse_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP_TI (ti, op_gt, octave_sparse_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP_TI (ti, op_ne, octave_sparse_matrix, octave_sparse_matrix, ne);
   INSTALL_BINOP_TI (ti, op_el_mul, octave_sparse_matrix, octave_sparse_matrix,
-                 el_mul);
+                    el_mul);
   INSTALL_BINOP_TI (ti, op_el_div, octave_sparse_matrix, octave_sparse_matrix,
-                 el_div);
+                    el_div);
   INSTALL_BINOP_TI (ti, op_el_pow, octave_sparse_matrix, octave_sparse_matrix,
-                 el_pow);
+                    el_pow);
   INSTALL_BINOP_TI (ti, op_el_ldiv, octave_sparse_matrix, octave_sparse_matrix,
-                 el_ldiv);
+                    el_ldiv);
   INSTALL_BINOP_TI (ti, op_el_and, octave_sparse_matrix, octave_sparse_matrix,
-                 el_and);
+                    el_and);
   INSTALL_BINOP_TI (ti, op_el_or, octave_sparse_matrix, octave_sparse_matrix,
-                 el_or);
+                    el_or);
 
   INSTALL_CATOP_TI (ti, octave_sparse_matrix, octave_sparse_matrix, sm_sm);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_sparse_matrix,
-                    assign);
+                       assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_null_matrix,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_null_str,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_sparse_matrix, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
 }
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -48,18 +48,19 @@ DEFASSIGNOP (assign, char_matrix_str, oc
 
 DEFNDCHARCATOP_FN (str_m, char_matrix_str, matrix, concat)
 
 DEFNDCHARCATOP_FN (m_str, matrix, char_matrix_str, concat)
 
 void
 install_str_m_ops (octave::type_info& ti)
 {
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_matrix, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_matrix,
+                       assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str, octave_matrix,
-                    assign);
+                       assign);
 
   INSTALL_CATOP_TI (ti, octave_char_matrix_str, octave_matrix, str_m);
   INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_matrix, str_m);
 
   INSTALL_CATOP_TI (ti, octave_matrix, octave_char_matrix_str, m_str);
   INSTALL_CATOP_TI (ti, octave_matrix, octave_char_matrix_sq_str, m_str);
 }
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -48,18 +48,19 @@ DEFASSIGNOP (assign, char_matrix_str, oc
 
 DEFNDCHARCATOP_FN (str_s, char_matrix_str, scalar, concat)
 
 DEFNDCHARCATOP_FN (s_str, scalar, char_matrix_str, concat)
 
 void
 install_str_s_ops (octave::type_info& ti)
 {
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_scalar, assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_scalar,
+                       assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str, octave_scalar,
-                    assign);
+                       assign);
 
   INSTALL_CATOP_TI (ti, octave_char_matrix_str, octave_scalar, str_s);
   INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_scalar, str_s);
 
   INSTALL_CATOP_TI (ti, octave_scalar, octave_char_matrix_str, s_str);
   INSTALL_CATOP_TI (ti, octave_scalar, octave_char_matrix_sq_str, s_str);
 }
diff --git a/libinterp/operators/op-str-str.cc b/libinterp/operators/op-str-str.cc
--- a/libinterp/operators/op-str-str.cc
+++ b/libinterp/operators/op-str-str.cc
@@ -113,74 +113,104 @@ void
 install_str_str_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_transpose, octave_char_matrix_str, transpose);
   INSTALL_UNOP_TI (ti, op_transpose, octave_char_matrix_sq_str, transpose);
 
   INSTALL_UNOP_TI (ti, op_hermitian, octave_char_matrix_str, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_char_matrix_sq_str, transpose);
 
-  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_str, octave_char_matrix_str, lt);
-  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_str, octave_char_matrix_sq_str, lt);
-  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_sq_str, octave_char_matrix_str, lt);
-  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 lt);
+  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_str, octave_char_matrix_str,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    lt);
+  INSTALL_BINOP_TI (ti, op_lt, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    lt);
 
-  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_str, octave_char_matrix_str, le);
-  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_str, octave_char_matrix_sq_str, le);
-  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_sq_str, octave_char_matrix_str, le);
-  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 le);
+  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_str, octave_char_matrix_str,
+                    le);
+  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    le);
+  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    le);
+  INSTALL_BINOP_TI (ti, op_le, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    le);
 
-  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_str, octave_char_matrix_str, eq);
-  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_str, octave_char_matrix_sq_str, eq);
-  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_sq_str, octave_char_matrix_str, eq);
-  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 eq);
+  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_str, octave_char_matrix_str,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    eq);
+  INSTALL_BINOP_TI (ti, op_eq, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    eq);
 
-  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_str, octave_char_matrix_str, ge);
-  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_str, octave_char_matrix_sq_str, ge);
-  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_sq_str, octave_char_matrix_str, ge);
-  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 ge);
+  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_str, octave_char_matrix_str,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    ge);
+  INSTALL_BINOP_TI (ti, op_ge, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    ge);
 
-  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_str, octave_char_matrix_str, gt);
-  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_str, octave_char_matrix_sq_str, gt);
-  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_sq_str, octave_char_matrix_str, gt);
-  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 gt);
+  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_str, octave_char_matrix_str,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    gt);
+  INSTALL_BINOP_TI (ti, op_gt, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    gt);
 
-  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_str, octave_char_matrix_str, ne);
-  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_str, octave_char_matrix_sq_str, ne);
-  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_sq_str, octave_char_matrix_str, ne);
-  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
-                 ne);
+  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_str, octave_char_matrix_str,
+                    ne);
+  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    ne);
+  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    ne);
+  INSTALL_BINOP_TI (ti, op_ne, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str,
+                    ne);
 
   INSTALL_CATOP_TI (ti, octave_char_matrix_str, octave_char_matrix_str, str_str);
-  INSTALL_CATOP_TI (ti, octave_char_matrix_str, octave_char_matrix_sq_str, str_str);
-  INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_char_matrix_str, str_str);
-  INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_char_matrix_sq_str, str_str);
+  INSTALL_CATOP_TI (ti, octave_char_matrix_str, octave_char_matrix_sq_str,
+                    str_str);
+  INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_char_matrix_str,
+                    str_str);
+  INSTALL_CATOP_TI (ti, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                    str_str);
 
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_char_matrix_str,
-                    assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str,
-                    octave_char_matrix_sq_str,
-                    assign);
+                       octave_char_matrix_str,
+                       assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str,
+                       octave_char_matrix_sq_str,
+                       assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str,
-                    octave_char_matrix_str,
-                    assign);
+                       octave_char_matrix_str,
+                       assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str,
-                    octave_char_matrix_sq_str, assign);
+                       octave_char_matrix_sq_str, assign);
 
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_null_matrix,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_null_str,
-                    null_assign);
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_str, octave_null_sq_str,
-                    null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str, octave_null_matrix,
-                    null_assign);
+                       null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str,
+                       octave_null_matrix,
+                       null_assign);
   INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str, octave_null_str,
-                    null_assign);
-  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str, octave_null_sq_str,
-                    null_assign);
+                       null_assign);
+  INSTALL_ASSIGNOP_TI (ti, op_asn_eq, octave_char_matrix_sq_str,
+                       octave_null_sq_str,
+                       null_assign);
 
 }
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -238,22 +238,22 @@ namespace octave
                   error ("dbstop: condition must be an expression");
               }
           }
       }
     return true;
   }
 
   enum dbstop_args
-    {
-      dbstop_in,
-      dbstop_at,
-      dbstop_if,
-      dbstop_none
-    };
+  {
+    dbstop_in,
+    dbstop_at,
+    dbstop_if,
+    dbstop_none
+  };
 
   // Parse parameters (args) of dbstop and dbclear commands.
   // For dbstop, who=="dbstop"; for dbclear, who=="dbclear".
   // The syntax is: dbstop [[in] symbol] [[at] line [line [...]]] [if condition]
   // where the form of condition depends on whether or not a file or line has
   // been seen.
   // Also execute "if [error|warning|interrupt|naninf]" clauses.
 
@@ -582,17 +582,17 @@ namespace octave
             intmap ret_one;
             if (dbg_fcn
                 && add_breakpoint_1 (dbg_fcn, fname, line, condition, ret_one))
               retval.insert (std::pair<int,int> (i, ret_one.find (i)->second));
           }
       }
 
     octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-      || Vdebugging;
+                                         || Vdebugging;
 
     return retval;
   }
 
   int bp_table::remove_breakpoint_1 (octave_user_code *fcn,
                                      const std::string& fname,
                                      const bp_table::intmap& line)
   {
@@ -679,17 +679,17 @@ namespace octave
                 octave_user_code *dbg_subfcn = q->second.user_code_value ();
 
                 retval += remove_breakpoint_1 (dbg_subfcn, fname, line);
               }
           }
       }
 
     octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-      || Vdebugging;
+                                         || Vdebugging;
 
     return retval;
   }
 
   // Remove all breakpoints from a file, including those in subfunctions.
 
   bp_table::intmap
   bp_table::remove_all_breakpoints_in_file (const std::string& fname,
@@ -714,34 +714,34 @@ namespace octave
               m_bp_set.erase (it);
           }
       }
     else if (! silent)
       error ("remove_all_breakpoint_in_file: "
              "unable to find function %s\n", fname.c_str ());
 
     octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-      || Vdebugging;
+                                         || Vdebugging;
 
     return retval;
   }
 
   void bp_table::remove_all_breakpoints (void)
   {
     // Odd loop structure required because delete will invalidate m_bp_set iterators
     for (const_bp_set_iterator it = m_bp_set.begin (), it_next = it;
          it != m_bp_set.end ();
          it = it_next)
       {
         ++it_next;
         remove_all_breakpoints_in_file (*it);
       }
 
     octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
-      || Vdebugging;
+                                         || Vdebugging;
   }
 
   std::string find_bkpt_list (octave_value_list slist, std::string match)
   {
     std::string retval;
 
     for (int i = 0; i < slist.length (); i++)
       {
diff --git a/libinterp/parse-tree/comment-list.h b/libinterp/parse-tree/comment-list.h
--- a/libinterp/parse-tree/comment-list.h
+++ b/libinterp/parse-tree/comment-list.h
@@ -38,24 +38,24 @@ namespace octave
   extern void save_comment_text (const std::string& text);
 
   class
   comment_elt
   {
   public:
 
     enum comment_type
-      {
-        unknown,
-        block,
-        full_line,
-        end_of_line,
-        doc_string,
-        copyright
-      };
+    {
+      unknown,
+      block,
+      full_line,
+      end_of_line,
+      doc_string,
+      copyright
+    };
 
     comment_elt (const std::string& s = "", comment_type t = unknown)
       : m_text (s), m_type (t) { }
 
     comment_elt (const comment_elt& oc)
       : m_text (oc.m_text), m_type (oc.m_type) { }
 
     comment_elt& operator = (const comment_elt& oc)
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -1181,17 +1181,17 @@ namespace octave
       if (ol.valid ())
         stash_type (ol.result ());
     }
 
     template <typename ...Args>
     jit_call (const jit_operation& aoperation,
               jit_value * arg1, Args... other_args)
       : jit_instruction (arg1, other_args...), m_operation (aoperation)
-  { }
+    { }
 
     template <typename ...Args>
     jit_call (const jit_operation& (*aoperation) (void),
               jit_value * arg1, Args... other_args)
       : jit_instruction (arg1, other_args...), m_operation (aoperation ())
     { }
 
     jit_call (const jit_operation& aoperation,
@@ -1244,20 +1244,20 @@ namespace octave
   // otherwise goto the error branch
   class
   jit_error_check : public jit_terminator
   {
   public:
 
     // Which variable is the error check for?
     enum variable
-      {
-        var_error_state,
-        var_interrupt
-      };
+    {
+      var_error_state,
+      var_interrupt
+    };
 
     static std::string variable_to_string (variable v);
 
     jit_error_check (variable var, jit_call *acheck_for, jit_block *normal,
                      jit_block *error)
       : jit_terminator (2, error, normal, acheck_for), m_variable (var) { }
 
     jit_error_check (variable var, jit_block *normal, jit_block *error)
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -298,17 +298,17 @@ namespace octave
     bool done = false;
 
     // optimize for the simple case (no resizing and no errors)
     if (*array->jit_ref_count () == 1
         && index->all_elements_are_ints ())
       {
         // this code is similar to idx_vector::fill, but we avoid allocating an
         // idx_vector and its associated rep
-        octave_idx_type start = static_cast<octave_idx_type> (index->m_base) - 1;
+        octave_idx_type start = static_cast<octave_idx_type> (index->m_base)-1;
         octave_idx_type step = static_cast<octave_idx_type> (index->m_inc);
         octave_idx_type nelem = index->m_nelem;
         octave_idx_type final = start + nelem * step;
         if (step < 0)
           {
             step = -step;
             std::swap (final, start);
           }
@@ -495,28 +495,28 @@ namespace octave
   }
 
 
   // -------------------- jit_matrix --------------------
 
   std::ostream&
   operator<< (std::ostream& os, const jit_matrix& mat)
   {
-    return os << "Matrix[" << mat.m_ref_count << ", " << mat.m_slice_data << ", "
-              << mat.m_slice_len << ", " << mat.m_dimensions << ", "
-              << mat.m_array << ']';
+    return os << "Matrix[" << mat.m_ref_count << ", "
+              << mat.m_slice_data << ", " << mat.m_slice_len << ", "
+              << mat.m_dimensions << ", " << mat.m_array << ']';
   }
 
 
   // -------------------- jit_type --------------------
 
   jit_type::jit_type (const std::string& aname, jit_type *aparent,
-                      llvm::Type *allvm_type, bool askip_paren, int aid) :
-    m_name (aname), m_parent (aparent), m_llvm_type (allvm_type), m_id (aid),
-    m_depth (aparent ? aparent->m_depth + 1 : 0), m_skip_paren (askip_paren)
+                      llvm::Type *allvm_type, bool askip_paren, int aid)
+    : m_name (aname), m_parent (aparent), m_llvm_type (allvm_type), m_id (aid),
+      m_depth (aparent ? aparent->m_depth + 1 : 0), m_skip_paren (askip_paren)
   {
     std::memset (m_sret, 0, sizeof (m_sret));
     std::memset (m_pointer_arg, 0, sizeof (m_pointer_arg));
     std::memset (m_pack, 0, sizeof (m_pack));
     std::memset (m_unpack, 0, sizeof (m_unpack));
 
     for (size_t i = 0; i < jit_convention::length; ++i)
       m_packed_type[i] = m_llvm_type;
@@ -565,18 +565,18 @@ namespace octave
     : m_module (nullptr), m_llvm_function (nullptr), m_result (nullptr),
       m_call_conv (jit_convention::length), m_can_error (false)
   { }
 
   jit_function::jit_function (const jit_module *amodule,
                               jit_convention::type acall_conv,
                               const llvm::Twine& aname, jit_type *aresult,
                               const std::vector<jit_type *>& aargs)
-    : m_module (amodule), m_result (aresult), m_args (aargs), m_call_conv (acall_conv),
-      m_can_error (false)
+    : m_module (amodule), m_result (aresult), m_args (aargs),
+      m_call_conv (acall_conv), m_can_error (false)
   {
     llvm::SmallVector<llvm::Type *, 15> llvm_args;
 
     llvm::Type *rtype = llvm::Type::getVoidTy (context);
     if (m_result)
       {
         rtype = m_result->packed_type (m_call_conv);
         if (sret ())
@@ -612,29 +612,31 @@ namespace octave
         m_llvm_function->addAttribute (1, llvm::Attribute::StructRet);
 #endif
       }
 
     if (m_call_conv == jit_convention::internal)
 #if defined (FUNCTION_ADDFNATTR_ARG_IS_ATTRIBUTES)
       m_llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
 #else
-    m_llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
+      m_llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
 #endif
   }
 
   jit_function::jit_function (const jit_function& fn, jit_type *aresult,
                               const std::vector<jit_type *>& aargs)
-    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function), m_result (aresult),
-      m_args (aargs), m_call_conv (fn.m_call_conv), m_can_error (fn.m_can_error)
+    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function),
+      m_result (aresult), m_args (aargs), m_call_conv (fn.m_call_conv),
+      m_can_error (fn.m_can_error)
   { }
 
   jit_function::jit_function (const jit_function& fn)
-    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function), m_result (fn.m_result),
-      m_args (fn.m_args), m_call_conv (fn.m_call_conv), m_can_error (fn.m_can_error)
+    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function),
+      m_result (fn.m_result), m_args (fn.m_args), m_call_conv (fn.m_call_conv),
+      m_can_error (fn.m_can_error)
   { }
 
   void
   jit_function::erase (void)
   {
     if (! m_llvm_function)
       return;
 
@@ -681,17 +683,17 @@ namespace octave
     assert (in_args.size () == m_args.size ());
     llvm::SmallVector<llvm::Value *, 10> llvm_args;
     llvm_args.reserve (in_args.size () + sret ());
 
     llvm::BasicBlock *insert_block = builder.GetInsertBlock ();
     llvm::Function *parent = insert_block->getParent ();
     assert (parent);
 
-    // we insert allocas inside the prelude block to prevent stack overflows
+    // Insert allocas inside the prelude block to prevent stack overflows
     llvm::BasicBlock& prelude = parent->getEntryBlock ();
     llvm::IRBuilder<> pre_builder (&prelude, prelude.begin ());
 
     llvm::AllocaInst *sret_mem = nullptr;
     if (sret ())
       {
         sret_mem = pre_builder.CreateAlloca (m_result->packed_type (m_call_conv));
         llvm_args.push_back (sret_mem);
@@ -874,17 +876,18 @@ namespace octave
 
   Array<octave_idx_type>
   jit_operation::to_idx (const std::vector<jit_type*>& types) const
   {
     octave_idx_type numel = types.size ();
     numel = std::max (numel, static_cast<octave_idx_type>(2));
 
     Array<octave_idx_type> idx (dim_vector (1, numel));
-    for (octave_idx_type i = 0; i < static_cast<octave_idx_type> (types.size ());
+    for (octave_idx_type i = 0;
+         i < static_cast<octave_idx_type> (types.size ());
          ++i)
       idx(i) = types[i]->type_id ();
 
     if (types.size () == 0)
       idx(0) = idx(1) = 0;
     if (types.size () == 1)
       {
         idx(1) = idx(0);
@@ -956,17 +959,18 @@ namespace octave
         return generate_matrix (types);
       }
 
     return 0;
   }
 
   llvm::Value *
   jit_index_operation::create_arg_array (llvm::IRBuilderD& builder,
-                                         const jit_function& fn, size_t start_idx,
+                                         const jit_function& fn,
+                                         size_t start_idx,
                                          size_t end_idx) const
   {
     size_t n = end_idx - start_idx;
     llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
     llvm::ArrayType *array_t = llvm::ArrayType::get (scalar_t, n);
     llvm::Value *array = llvm::UndefValue::get (array_t);
     for (size_t i = start_idx; i < end_idx; ++i)
       {
@@ -977,20 +981,18 @@ namespace octave
     llvm::Value *array_mem = builder.CreateAlloca (array_t);
     builder.CreateStore (array, array_mem);
     return builder.CreateBitCast (array_mem, scalar_t->getPointerTo ());
   }
 
   // -------------------- jit_paren_subsref --------------------
 
   jit_paren_subsref::jit_paren_subsref (const jit_typeinfo& ti)
-    : jit_index_operation (ti, "()subsref"),
-      m_paren_scalar (nullptr)
-  {
-  }
+    : jit_index_operation (ti, "()subsref"), m_paren_scalar (nullptr)
+  { }
 
   jit_paren_subsref::~jit_paren_subsref (void)
   {
     delete m_paren_scalar;
   }
 
   jit_function *
   jit_paren_subsref::generate_matrix (const signature_vec& types) const
@@ -1032,18 +1034,17 @@ namespace octave
                                    m_typeinfo.m_scalar, types));
 
     m_paren_scalar->mark_can_error ();
   }
 
   // -------------------- jit_paren_subsasgn --------------------
 
   jit_paren_subsasgn::jit_paren_subsasgn (const jit_typeinfo& ti)
-    : jit_index_operation (ti, "()subsasgn"),
-      m_paren_scalar (nullptr)
+    : jit_index_operation (ti, "()subsasgn"), m_paren_scalar (nullptr)
   { }
 
   jit_paren_subsasgn::~jit_paren_subsasgn (void)
   {
     delete m_paren_scalar;
   }
 
   jit_function *
@@ -1138,51 +1139,58 @@ namespace octave
       m_for_index_fn ("for_index"),
       m_logically_true_fn ("logically_true"),
       m_make_range_fn ("make_range"),
       m_end1_fn ("end1"),
       m_end_fn ("end"),
       m_create_undef_fn ("create_undef"),
       m_base_jit_module (new jit_module ("octaveJITBaseModule")),
       m_builder_ptr (new llvm::IRBuilderD (context)),
-      m_builder (*m_builder_ptr)  // FIXME: Use a pointer directly in the constructor, and get rid of this
+      // FIXME: Use a pointer directly in the constructor, and get rid of this
+      m_builder (*m_builder_ptr)
   {
     s_in_construction = true;
 
     // ----- Register basic JIT types -----
 
     // FIXME: It seems that our type lattice is not really a lattice
     //        since any and any_ptr have no common upper_bound (?!?)
 
     // jit_types: "any"     < (nullptr)
     //            "any_ptr" < (nullptr)
     m_any_t = llvm::StructType::create (context, "octave_base_value");
     m_any_t = m_any_t->getPointerTo ();
     m_any = do_register_new_type ("any", nullptr, m_any_t);
-    m_any_ptr = do_register_new_type ("any_ptr", nullptr, m_any_t->getPointerTo ());
+    m_any_ptr = do_register_new_type ("any_ptr", nullptr,
+                                      m_any_t->getPointerTo ());
 
     // jit_types: "scalar"     < "complex" < "any"
     //       and: "scalar_ptr" < (nullptr)
     // FIXME: what about sing-precision floats ???
     // FIXME: shouldn't we make scalar_ptr a sub_type of any_ptr ?
     m_scalar_t = llvm::Type::getDoubleTy (context);
     m_complex_t = llvm::ArrayType::get (m_scalar_t, 2);
     m_complex = do_register_new_type ("complex", m_any, m_complex_t);
     m_scalar = do_register_new_type ("scalar", m_complex, m_scalar_t);
-    m_scalar_ptr = do_register_new_type ("scalar_ptr", nullptr, m_scalar_t->getPointerTo ());
+    m_scalar_ptr = do_register_new_type ("scalar_ptr", nullptr,
+                                         m_scalar_t->getPointerTo ());
 
     // jit_type: "bool" < "any"
     m_bool_t = llvm::Type::getInt1Ty (context);
     m_boolean = do_register_new_type ("bool", m_any, m_bool_t);
 
     // jit_types: "int8", "int16", "int32", "int64" < "any"
-    m_ints[ 8] = do_register_new_type ("int8",  m_any, llvm::Type::getIntNTy (context,  8));
-    m_ints[16] = do_register_new_type ("int16", m_any, llvm::Type::getIntNTy (context, 16));
-    m_ints[32] = do_register_new_type ("int32", m_any, llvm::Type::getIntNTy (context, 32));
-    m_ints[64] = do_register_new_type ("int64", m_any, llvm::Type::getIntNTy (context, 64));
+    m_ints[ 8] = do_register_new_type ("int8",  m_any,
+                                       llvm::Type::getIntNTy (context,  8));
+    m_ints[16] = do_register_new_type ("int16", m_any,
+                                       llvm::Type::getIntNTy (context, 16));
+    m_ints[32] = do_register_new_type ("int32", m_any,
+                                       llvm::Type::getIntNTy (context, 32));
+    m_ints[64] = do_register_new_type ("int64", m_any,
+                                       llvm::Type::getIntNTy (context, 64));
 
     // jit_type: "string" < "any"
     m_string_t = llvm::Type::getInt8Ty (context);
     m_string_t = m_string_t->getPointerTo ();
     m_string = do_register_new_type ("string", m_any, m_string_t);
 
     // jit_type: "index" < "any"
     m_index_t = llvm::Type::getIntNTy (context, sizeof (octave_idx_type) * 8);
@@ -1226,54 +1234,58 @@ namespace octave
     // FIXME: We should detect architecture and do something sane
     //        based on that here we assume x86 or x86_64
     m_matrix->mark_sret (jit_convention::external);
     m_matrix->mark_pointer_arg (jit_convention::external);
 
     m_range->mark_sret (jit_convention::external);
     m_range->mark_pointer_arg (jit_convention::external);
 
-    m_complex->set_pack (jit_convention::external, &jit_typeinfo::pack_complex);
-    m_complex->set_unpack (jit_convention::external, &jit_typeinfo::unpack_complex);
+    m_complex->set_pack (jit_convention::external,
+                         &jit_typeinfo::pack_complex);
+    m_complex->set_unpack (jit_convention::external,
+                           &jit_typeinfo::unpack_complex);
     m_complex->set_packed_type (jit_convention::external, m_complex_ret);
 
     if (sizeof (void *) == 4)
       m_complex->mark_sret (jit_convention::external);
 
     paren_subsref_fn.init_paren_scalar ();
     paren_subsasgn_fn.init_paren_scalar ();
 
     // bind global variables
     m_lerror_state = m_base_jit_module->create_global_variable (m_bool_t, false,
                                                                 "error_state");
 
     m_base_jit_module->add_global_mapping (m_lerror_state, &error_state);
 
     // sig_atomic_type is going to be some sort of integer
-    m_sig_atomic_type = llvm::Type::getIntNTy (context, sizeof(sig_atomic_t) * 8);
+    m_sig_atomic_type = llvm::Type::getIntNTy (context,
+                                               sizeof(sig_atomic_t) * 8);
 
     m_loctave_interrupt_state = m_base_jit_module->create_global_variable
       (m_sig_atomic_type, false, "octave_interrupt_state");
 
     m_base_jit_module->add_global_mapping (m_loctave_interrupt_state,
                                            &octave_interrupt_state);
 
     // generic call function
     {
       jit_type *int_t = do_get_intN (sizeof (octave_builtin::fcn) * 8);
-      m_any_call = create_external (JIT_FN (octave_jit_call), m_any, int_t, int_t,
-                                    m_any_ptr, int_t);
+      m_any_call = create_external (JIT_FN (octave_jit_call), m_any, int_t,
+                                    int_t, m_any_ptr, int_t);
     }
 
     // any with anything is an any op
     jit_function fn;
     jit_type *binary_op_type = do_get_intN (sizeof (octave_value::binary_op) * 8);
     llvm::Type *llvm_bo_type = binary_op_type->to_llvm ();
     jit_function any_binary = create_external (JIT_FN (octave_jit_binary_any_any),
-                                               m_any, binary_op_type, m_any, m_any);
+                                               m_any, binary_op_type,
+                                               m_any, m_any);
     any_binary.mark_can_error ();
 
     for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
       {
         octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
         std::string op_name = octave_value::binary_op_as_string (op);
         m_binary_ops.push_back (jit_operation ("binary" + op_name));
       }
@@ -1314,17 +1326,18 @@ namespace octave
     m_grab_fn.add_overload (create_identity (m_complex));
     m_grab_fn.add_overload (create_identity (m_index));
 
     // release any
     fn = create_external (JIT_FN (octave_jit_release_any), nullptr, m_any);
     m_release_fn.add_overload (fn);
 
     // release matrix
-    fn = create_external (JIT_FN (octave_jit_release_matrix), nullptr, m_matrix);
+    fn = create_external (JIT_FN (octave_jit_release_matrix), nullptr,
+                          m_matrix);
     m_release_fn.add_overload (fn);
 
     // destroy
     m_destroy_fn = m_release_fn;
     m_destroy_fn.add_overload (create_identity(m_scalar));
     m_destroy_fn.add_overload (create_identity(m_boolean));
     m_destroy_fn.add_overload (create_identity(m_index));
     m_destroy_fn.add_overload (create_identity(m_complex));
@@ -1339,31 +1352,34 @@ namespace octave
 
     add_binary_fcmp (m_scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
     add_binary_fcmp (m_scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
     add_binary_fcmp (m_scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
     add_binary_fcmp (m_scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
     add_binary_fcmp (m_scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
     add_binary_fcmp (m_scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
-    jit_function gripe_div0 = create_external (JIT_FN (warn_divide_by_zero), nullptr);
+    jit_function gripe_div0 = create_external (JIT_FN (warn_divide_by_zero),
+                                               nullptr);
     gripe_div0.mark_can_error ();
 
     // divide is annoying because it might error
-    fn = create_internal ("octave_jit_div_scalar_scalar", m_scalar, m_scalar, m_scalar);
+    fn = create_internal ("octave_jit_div_scalar_scalar", m_scalar, m_scalar,
+                          m_scalar);
     fn.mark_can_error ();
 
     llvm::BasicBlock *body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::BasicBlock *warn_block = fn.new_block ("warn");
       llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
       llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
-      llvm::Value *check = m_builder.CreateFCmpUEQ (zero, fn.argument (m_builder, 1));
+      llvm::Value *check = m_builder.CreateFCmpUEQ (zero,
+                                                    fn.argument (m_builder, 1));
       m_builder.CreateCondBr (check, warn_block, normal_block);
 
       m_builder.SetInsertPoint (warn_block);
       gripe_div0.call (m_builder);
       m_builder.CreateBr (normal_block);
 
       m_builder.SetInsertPoint (normal_block);
       llvm::Value *ret = m_builder.CreateFDiv (fn.argument (m_builder, 0),
@@ -1376,18 +1392,18 @@ namespace octave
     // ldiv is the same as div with the operators reversed
     fn = mirror_binary (fn);
     m_binary_ops[octave_value::op_ldiv].add_overload (fn);
     m_binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
     // In general, the result of scalar ^ scalar is a complex number.  We might
     // be able to improve on this if we keep track of the range of values
     // variables can take on.
-    fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), m_complex, m_scalar,
-                          m_scalar);
+    fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), m_complex,
+                          m_scalar, m_scalar);
     m_binary_ops[octave_value::op_pow].add_overload (fn);
     m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
     // now for unary scalar operations
     // FIXME: Impelment not
     fn = create_internal ("octave_jit_++", m_scalar, m_scalar);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
@@ -1540,18 +1556,18 @@ namespace octave
     {
       llvm::Value *lhs = fn.argument (m_builder, 0);
       llvm::Value *rhs = fn.argument (m_builder, 1);
       llvm::Value *real = m_builder.CreateFSub (lhs, complex_real (rhs));
       fn.do_return (m_builder, complex_real (rhs, real));
     }
     m_binary_ops[octave_value::op_sub].add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_pow_scalar_complex), m_complex, m_scalar,
-                          m_complex);
+    fn = create_external (JIT_FN (octave_jit_pow_scalar_complex), m_complex,
+                          m_scalar, m_complex);
     m_binary_ops[octave_value::op_pow].add_overload (fn);
     m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
     fn = create_external (JIT_FN (octave_jit_pow_complex_scalar), m_complex,
                           m_complex, m_scalar);
     m_binary_ops[octave_value::op_pow].add_overload (fn);
     m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
@@ -1572,30 +1588,32 @@ namespace octave
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *zero = llvm::ConstantInt::get (m_index_t, 0);
       fn.do_return (m_builder, zero);
     }
     m_for_init_fn.add_overload (fn);
 
     // bounds check for for loop
-    fn = create_internal ("octave_jit_for_range_check", m_boolean, m_range, m_index);
+    fn = create_internal ("octave_jit_for_range_check", m_boolean, m_range,
+                          m_index);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *nelem
         = m_builder.CreateExtractValue (fn.argument (m_builder, 0), 3);
       llvm::Value *idx = fn.argument (m_builder, 1);
       llvm::Value *ret = m_builder.CreateICmpULT (idx, nelem);
       fn.do_return (m_builder, ret);
     }
     m_for_check_fn.add_overload (fn);
 
     // index variabe for for loop
-    fn = create_internal ("octave_jit_for_range_idx", m_scalar, m_range, m_index);
+    fn = create_internal ("octave_jit_for_range_idx", m_scalar, m_range,
+                          m_index);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *idx = fn.argument (m_builder, 1);
       llvm::Value *didx = m_builder.CreateSIToFP (idx, m_scalar_t);
       llvm::Value *rng = fn.argument (m_builder, 0);
       llvm::Value *base = m_builder.CreateExtractValue (rng, 0);
       llvm::Value *inc = m_builder.CreateExtractValue (rng, 2);
@@ -1603,19 +1621,21 @@ namespace octave
       llvm::Value *ret = m_builder.CreateFMul (didx, inc);
       ret = m_builder.CreateFAdd (base, ret);
       fn.do_return (m_builder, ret);
     }
     m_for_index_fn.add_overload (fn);
 
     // logically true
     jit_function gripe_nantl
-      = create_external (JIT_FN (octave_jit_err_nan_to_logical_conversion), nullptr);
+      = create_external (JIT_FN (octave_jit_err_nan_to_logical_conversion),
+                         nullptr);
     gripe_nantl.mark_can_error ();
-    fn = create_internal ("octave_jit_logically_true_scalar", m_boolean, m_scalar);
+    fn = create_internal ("octave_jit_logically_true_scalar", m_boolean,
+                          m_scalar);
     fn.mark_can_error ();
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::BasicBlock *error_block = fn.new_block ("error");
       llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
       llvm::Value *check = m_builder.CreateFCmpUNE (fn.argument (m_builder, 0),
@@ -1637,45 +1657,46 @@ namespace octave
     fn = create_identity (m_boolean);
     m_logically_true_fn.add_overload (fn);
 
     // make_range
     // FIXME: May be benificial to implement all in LLVM
     jit_function compute_nelem
       = create_external (JIT_FN (octave_jit_compute_nelem),
                          m_index, m_scalar, m_scalar, m_scalar);
-    fn = create_internal ("octave_jit_make_range", m_range, m_scalar, m_scalar, m_scalar);
+    fn = create_internal ("octave_jit_make_range", m_range, m_scalar, m_scalar,
+                          m_scalar);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *base = fn.argument (m_builder, 0);
       llvm::Value *limit = fn.argument (m_builder, 1);
       llvm::Value *inc = fn.argument (m_builder, 2);
       llvm::Value *nelem = compute_nelem.call (m_builder, base, limit, inc);
 
       llvm::Value *dzero = llvm::ConstantFP::get (m_scalar_t, 0);
       llvm::Value *izero = llvm::ConstantInt::get (m_index_t, 0);
-      llvm::Value *rng = llvm::ConstantStruct::get (m_range_t, dzero, dzero, dzero,
-                                                    izero, NULL);
+      llvm::Value *rng = llvm::ConstantStruct::get (m_range_t, dzero, dzero,
+                                                    dzero, izero, NULL);
       rng = m_builder.CreateInsertValue (rng, base, 0);
       rng = m_builder.CreateInsertValue (rng, limit, 1);
       rng = m_builder.CreateInsertValue (rng, inc, 2);
       rng = m_builder.CreateInsertValue (rng, nelem, 3);
       fn.do_return (m_builder, rng);
     }
     m_make_range_fn.add_overload (fn);
 
     // paren_subsref
     jit_type *jit_int = do_get_intN (sizeof (int) * 8);
     llvm::Type *int_t = jit_int->to_llvm ();
     jit_function ginvalid_index
       = create_external (JIT_FN (octave_jit_ginvalid_index), nullptr);
     jit_function gindex_range = create_external (JIT_FN (octave_jit_gindex_range),
-                                                 nullptr, jit_int, jit_int, m_index,
-                                                 m_index);
+                                                 nullptr, jit_int, jit_int,
+                                                 m_index, m_index);
 
     fn = create_internal ("()subsref", m_scalar, m_matrix, m_scalar);
     fn.mark_can_error ();
 
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *one_idx = llvm::ConstantInt::get (m_index_t, 1);
@@ -1729,20 +1750,20 @@ namespace octave
       merge->addIncoming (undef, bounds_error);
       merge->addIncoming (ret, success);
       fn.do_return (m_builder, merge);
     }
     paren_subsref_fn.add_overload (fn);
 
     // paren subsasgn
     jit_function resize_paren_subsasgn
-      = create_external (JIT_FN (octave_jit_paren_subsasgn_impl), m_matrix, m_matrix,
-                         m_index, m_scalar);
-    fn = create_internal ("octave_jit_paren_subsasgn", m_matrix, m_matrix, m_scalar,
-                          m_scalar);
+      = create_external (JIT_FN (octave_jit_paren_subsasgn_impl), m_matrix,
+                         m_matrix, m_index, m_scalar);
+    fn = create_internal ("octave_jit_paren_subsasgn", m_matrix, m_matrix,
+                          m_scalar, m_scalar);
     fn.mark_can_error ();
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *one_idx = llvm::ConstantInt::get (m_index_t, 1);
       llvm::Value *one_int = llvm::ConstantInt::get (int_t, 1);
 
       llvm::Value *mat = fn.argument (m_builder, 0);
@@ -1796,89 +1817,98 @@ namespace octave
       m_builder.Insert (merge);
       merge->addIncoming (mat, conv_error);
       merge->addIncoming (resize_result, bounds_error);
       merge->addIncoming (mat, success);
       fn.do_return (m_builder, merge);
     }
     paren_subsasgn_fn.add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_paren_subsasgn_matrix_range), m_matrix,
-                          m_matrix, m_range, m_scalar);
+    fn = create_external (JIT_FN (octave_jit_paren_subsasgn_matrix_range),
+                          m_matrix, m_matrix, m_range, m_scalar);
     fn.mark_can_error ();
     paren_subsasgn_fn.add_overload (fn);
 
-    fn = create_internal ("octave_jit_end1_matrix", m_scalar, m_matrix, m_index, m_index);
+    fn = create_internal ("octave_jit_end1_matrix", m_scalar, m_matrix,
+                          m_index, m_index);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *mat = fn.argument (m_builder, 0);
       llvm::Value *ret = m_builder.CreateExtractValue (mat, 2);
       fn.do_return (m_builder, m_builder.CreateSIToFP (ret, m_scalar_t));
     }
     m_end1_fn.add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_end_matrix),m_scalar, m_matrix, m_index,
-                          m_index);
+    fn = create_external (JIT_FN (octave_jit_end_matrix),m_scalar, m_matrix,
+                          m_index, m_index);
     m_end_fn.add_overload (fn);
 
     // -------------------- create_undef --------------------
     fn = create_external (JIT_FN (octave_jit_create_undef), m_any);
     m_create_undef_fn.add_overload (fn);
 
     m_casts[m_any->type_id ()].stash_name ("(any)");
     m_casts[m_scalar->type_id ()].stash_name ("(scalar)");
     m_casts[m_complex->type_id ()].stash_name ("(complex)");
     m_casts[m_matrix->type_id ()].stash_name ("(matrix)");
     m_casts[m_range->type_id ()].stash_name ("(range)");
 
     // cast m_any <- matrix
-    fn = create_external (JIT_FN (octave_jit_cast_any_matrix), m_any, m_matrix);
+    fn = create_external (JIT_FN (octave_jit_cast_any_matrix), m_any,
+                          m_matrix);
     m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast matrix <- any
-    fn = create_external (JIT_FN (octave_jit_cast_matrix_any), m_matrix, m_any);
+    fn = create_external (JIT_FN (octave_jit_cast_matrix_any), m_matrix,
+                          m_any);
     m_casts[m_matrix->type_id ()].add_overload (fn);
 
     // cast any <- range
     fn = create_external (JIT_FN (octave_jit_cast_any_range), m_any, m_range);
     m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast range <- any
     fn = create_external (JIT_FN (octave_jit_cast_range_any), m_range, m_any);
     m_casts[m_range->type_id ()].add_overload (fn);
 
     // cast any <- scalar
-    fn = create_external (JIT_FN (octave_jit_cast_any_scalar), m_any, m_scalar);
+    fn = create_external (JIT_FN (octave_jit_cast_any_scalar), m_any,
+                          m_scalar);
     m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast scalar <- any
-    fn = create_external (JIT_FN (octave_jit_cast_scalar_any), m_scalar, m_any);
+    fn = create_external (JIT_FN (octave_jit_cast_scalar_any), m_scalar,
+                          m_any);
     m_casts[m_scalar->type_id ()].add_overload (fn);
 
     // cast any <- complex
-    fn = create_external (JIT_FN (octave_jit_cast_any_complex), m_any, m_complex);
+    fn = create_external (JIT_FN (octave_jit_cast_any_complex), m_any,
+                          m_complex);
     m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast complex <- any
-    fn = create_external (JIT_FN (octave_jit_cast_complex_any), m_complex, m_any);
+    fn = create_external (JIT_FN (octave_jit_cast_complex_any), m_complex,
+                          m_any);
     m_casts[m_complex->type_id ()].add_overload (fn);
 
     // cast complex <- scalar
-    fn = create_internal ("octave_jit_cast_complex_scalar", m_complex, m_scalar);
+    fn = create_internal ("octave_jit_cast_complex_scalar", m_complex,
+                          m_scalar);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
       llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
       fn.do_return (m_builder, complex_new (fn.argument (m_builder, 0), zero));
     }
     m_casts[m_complex->type_id ()].add_overload (fn);
 
     // cast scalar <- complex
-    fn = create_internal ("octave_jit_cast_scalar_complex", m_scalar, m_complex);
+    fn = create_internal ("octave_jit_cast_scalar_complex", m_scalar,
+                          m_complex);
     body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     fn.do_return (m_builder, complex_real (fn.argument (m_builder, 0)));
     m_casts[m_scalar->type_id ()].add_overload (fn);
 
     // cast any <- any
     fn = create_identity (m_any);
     m_casts[m_any->type_id ()].add_overload (fn);
@@ -1920,17 +1950,18 @@ namespace octave
     register_generic ("norm", m_scalar, m_matrix);
 
     add_builtin ("rand");
     register_generic ("rand", m_matrix, m_scalar);
     register_generic ("rand", m_matrix, std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("magic");
     register_generic ("magic", m_matrix, m_scalar);
-    register_generic ("magic", m_matrix, std::vector<jit_type *> (2, m_scalar));
+    register_generic ("magic", m_matrix,
+                      std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("eye");
     register_generic ("eye", m_matrix, m_scalar);
     register_generic ("eye", m_matrix, std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("mod");
     register_generic ("mod", m_scalar, std::vector<jit_type *> (2, m_scalar));
 
@@ -1947,17 +1978,18 @@ namespace octave
     for (std::map<std::string, jit_type *>::iterator iter = m_builtins.begin ();
          iter != m_builtins.end (); ++iter)
       {
         jit_type *btype = iter->second;
         args[0] = btype;
 
         m_grab_fn.add_overload (jit_function (grab_any, btype, args));
         m_release_fn.add_overload (jit_function (release_any, 0, args));
-        m_casts[m_any->type_id ()].add_overload (jit_function (any_id, m_any, args));
+        m_casts[m_any->type_id ()].add_overload (jit_function (any_id, m_any,
+                                                               args));
 
         args[0] = m_any;
         m_casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
                                                                args));
       }
 
     m_base_jit_module->finalizeObject ();
 
@@ -1985,17 +2017,18 @@ namespace octave
                                       jit_type *parent,
                                       llvm::Type *llvm_type,
                                       bool skip_paren)
   {
     // FIXME: Currently our types do *not* form a lattice
     assert ((name == "any") || (name == "any_ptr") ||
             (name == "scalar_ptr") || (parent != nullptr));
 
-    jit_type *ret = new jit_type (name, parent, llvm_type, skip_paren, m_next_id++);
+    jit_type *ret = new jit_type (name, parent, llvm_type, skip_paren,
+                                  m_next_id++);
     m_id_to_type.push_back (ret);
 
     m_casts.push_back (jit_operation ("(" + name + ")"));
     m_identities.push_back (jit_function ());
 
     return ret;
   }
 
@@ -2154,18 +2187,18 @@ namespace octave
     std::stringstream fn_name;
     fn_name << "octave_jit_" << name;
 
     std::vector<jit_type *> args1 (nargs + 1);
     args1[0] = builtin_type;
     std::copy (args.begin (), args.end (), args1.begin () + 1);
 
     // The first argument will be the Octave function, but we already know that
-    // the function call is the equivalent of the intrinsic, so we ignore it and
-    // call the intrinsic with the remaining arguments.
+    // the function call is the equivalent of the intrinsic, so we ignore it
+    // and call the intrinsic with the remaining arguments.
     jit_function fn = create_internal (fn_name.str (), result, args1);
     llvm::BasicBlock *body = fn.new_block ();
     m_builder.SetInsertPoint (body);
 
     llvm::SmallVector<llvm::Value *, 5> fargs (nargs);
     for (size_t i = 0; i < nargs; ++i)
       fargs[i] = fn.argument (m_builder, i + 1);
 
@@ -2174,18 +2207,18 @@ namespace octave
     paren_subsref_fn.add_overload (fn);
   }
 
   octave_builtin *
   jit_typeinfo::find_builtin (const std::string& name)
   {
     symbol_table& symtab = __get_symbol_table__ ("jit_typeinfo::find_builtin");
 
-    // FIXME: Finalize what we want to store in octave_builtin, then add functions
-    // to access these values in octave_value
+    // FIXME: Finalize what we want to store in octave_builtin, then add
+    // functions to access these values in octave_value
     octave_value ov_builtin = symtab.find (name);
     return dynamic_cast<octave_builtin *> (ov_builtin.internal_rep ());
   }
 
   void
   jit_typeinfo::register_generic (const std::string& name, jit_type *result,
                                   const std::vector<jit_type *>& args)
   {
@@ -2204,31 +2237,33 @@ namespace octave
     llvm::Value *array = llvm::UndefValue::get (array_t);
     for (size_t i = 0; i < args.size (); ++i)
       {
         llvm::Value *arg = fn.argument (m_builder, i + 1);
         jit_function agrab = m_grab_fn.overload (args[i]);
         if (agrab.valid ())
           arg = agrab.call (m_builder, arg);
         jit_function acast = do_cast (m_any, args[i]);
-        array = m_builder.CreateInsertValue (array, acast.call (m_builder, arg), i);
+        array = m_builder.CreateInsertValue (array,
+                                             acast.call (m_builder, arg), i);
       }
 
     llvm::Value *array_mem = m_builder.CreateAlloca (array_t);
     m_builder.CreateStore (array, array_mem);
     array = m_builder.CreateBitCast (array_mem, m_any_t->getPointerTo ());
 
     jit_type *jintTy = do_get_intN (sizeof (octave_builtin::fcn) * 8);
     llvm::Type *intTy = jintTy->to_llvm ();
     size_t fcn_int = reinterpret_cast<size_t> (builtin->function ());
     llvm::Value *fcn = llvm::ConstantInt::get (intTy, fcn_int);
     llvm::Value *nargin = llvm::ConstantInt::get (intTy, args.size ());
     size_t result_int = reinterpret_cast<size_t> (result);
     llvm::Value *res_llvm = llvm::ConstantInt::get (intTy, result_int);
-    llvm::Value *ret = m_any_call.call (m_builder, fcn, nargin, array, res_llvm);
+    llvm::Value *ret = m_any_call.call (m_builder, fcn, nargin, array,
+                                        res_llvm);
 
     jit_function cast_result = do_cast (result, m_any);
     fn.do_return (m_builder, cast_result.call (m_builder, ret));
     paren_subsref_fn.add_overload (fn);
   }
 
   jit_function
   jit_typeinfo::mirror_binary (const jit_function& fn)
@@ -2311,22 +2346,22 @@ namespace octave
     return complex_imag (ret, imag);
   }
 
   jit_type *
   jit_typeinfo::do_type_of (const octave_value& ov) const
   {
     if (ov.is_function ())
       {
-        // FIXME: This is ugly, we need to finalize how we want to do this, then
-        // have octave_value fully support the needed functionality
+        // FIXME: This is ugly, we need to finalize how we want to do this,
+        // then have octave_value fully support the needed functionality
         octave_builtin *builtin
           = dynamic_cast<octave_builtin *> (ov.internal_rep ());
         return builtin && builtin->to_jit () ? builtin->to_jit ()
-          : m_unknown_function;
+                                             : m_unknown_function;
       }
 
     if (ov.is_range ())
       return m_range;
 
     if (ov.is_double_type () && ! ov.iscomplex ())
       {
         if (ov.is_real_scalar ())
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -115,25 +115,25 @@ namespace octave
 
   std::ostream& operator << (std::ostream& os, const jit_matrix& mat);
 
   // calling convention
   namespace jit_convention
   {
     enum
     type
-      {
-        // internal to jit
-        internal,
+    {
+      // internal to jit
+      internal,
 
-        // an external C call
-        external,
+      // an external C call
+      external,
 
-        length
-      };
+      length
+    };
   }
 
   // Used to keep track of estimated (infered) types during JIT.  This is a
   // hierarchical type system which includes both concrete and abstract types.
   //
   // The types form a lattice.  Currently we only allow for one parent type, but
   // eventually we may allow for multiple predecessors.
   class
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -509,17 +509,17 @@ namespace octave
 
   class
   base_lexer : public lexical_feedback
   {
   public:
 
     // Handle buffering of input for lexer.
 
-   class input_buffer
+    class input_buffer
     {
     public:
 
       input_buffer (void)
         : m_buffer (), m_pos (nullptr), m_chars_left (0), m_eof (false)
       { }
 
       void fill (const std::string& input, bool eof_arg);
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -660,17 +660,18 @@ OCTAVE_DEPRECATED (4.4, "use 'octave::fe
 static inline octave_value_list
 feval (const octave_value_list& args, int nargout = 0)
 {
   return octave::feval (args, nargout);
 }
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::eval_string' instead")
 static inline octave_value_list
-eval_string (const std::string& str, bool silent, int& parse_status, int nargout)
+eval_string (const std::string& str, bool silent, int& parse_status,
+             int nargout)
 {
   return octave::eval_string (str, silent, parse_status, nargout);
 }
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::eval_string' instead")
 static inline octave_value
 eval_string (const std::string& str, bool silent, int& parse_status)
 {
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -137,21 +137,21 @@ namespace octave
 
   // Boolean expressions.
 
   class tree_boolean_expression : public tree_binary_expression
   {
   public:
 
     enum type
-      {
-        unknown,
-        bool_and,
-        bool_or
-      };
+    {
+      unknown,
+      bool_and,
+      bool_or
+    };
 
     tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
       : tree_binary_expression (l, c), m_etype (t) { }
 
     tree_boolean_expression (tree_expression *a, tree_expression *b,
                              int l = -1, int c = -1, type t = unknown)
       : tree_binary_expression (a, b, l, c), m_etype (t) { }
 
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -44,21 +44,21 @@ namespace octave
 
   // List of expressions that make up a declaration statement.
 
   class tree_decl_elt
   {
   public:
 
     enum decl_type
-      {
-        unknown,
-        global,
-        persistent
-      };
+    {
+      unknown,
+      global,
+      persistent
+    };
 
     tree_decl_elt (tree_identifier *i = nullptr, tree_expression *e = nullptr)
       : type (unknown), m_id (i), m_expr (e) { }
 
     // No copying!
 
     tree_decl_elt (const tree_decl_elt&) = delete;
 
@@ -155,22 +155,22 @@ namespace octave
         elt->mark_persistent ();
     }
 
     std::list<std::string> variable_names (void) const
     {
       std::list<std::string> retval;
 
       for (const tree_decl_elt *elt : *this)
-      {
-        std::string nm = elt->name ();
+        {
+          std::string nm = elt->name ();
 
-        if (! nm.empty ())
-          retval.push_back (nm);
-      }
+          if (! nm.empty ())
+            retval.push_back (nm);
+        }
 
       return retval;
     }
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_init_list (*this);
     }
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -1171,17 +1171,18 @@ namespace octave
 
     if (expr->is_identifier ()
         && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
       {
         std::string var = expr->name ();
 
         e.set_var (var);
 
-        octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+        octave::symbol_table& symtab =
+          octave::__get_symbol_table__ ("final_index_error");
 
         octave_value fcn = symtab.find_function (var);
 
         if (fcn.is_function ())
           {
             octave_function *fp = fcn.function_value ();
 
             if (fp && fp->name () == var)
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -149,17 +149,18 @@ namespace octave
 
     // breaks must have been handled by the top level loop
     assert (m_breaks.empty ());
     assert (m_continues.empty ());
 
     m_block->append (m_factory.create<jit_branch> (m_final_block));
     m_blocks.push_back (m_final_block);
 
-    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
+    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end ();
+         ++iter)
       {
         jit_variable *var = iter->second;
         const std::string& name = var->name ();
         if (name.size () && name[0] != '#')
           m_final_block->append (m_factory.create<jit_store_argument> (var));
       }
 
     m_final_block->append (m_factory.create<jit_return> ());
@@ -240,25 +241,27 @@ namespace octave
     m_block = m_final_block;
 
     if (! return_value && rlist && rlist->size () == 1)
       {
         tree_decl_elt *elt = rlist->front ();
         return_value = get_variable (elt->name ());
       }
 
-    // FIXME: We should use live range analysis to delete variables where needed.
-    // For now we just delete everything at the end of the function.
-    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
+    // FIXME: We should use live range analysis to delete variables where
+    // needed.  For now we just delete everything at the end of the function.
+    for (variable_map::iterator iter = m_vmap.begin ();
+         iter != m_vmap.end ();
+         ++iter)
       {
         if (iter->second != return_value)
           {
             jit_call *call;
             call = m_factory.create<jit_call> (&jit_typeinfo::destroy,
-                                             iter->second);
+                                               iter->second);
             m_final_block->append (call);
           }
       }
 
     if (return_value)
       m_final_block->append (m_factory.create<jit_return> (return_value));
     else
       m_final_block->append (m_factory.create<jit_return> ());
@@ -363,22 +366,22 @@ namespace octave
   void
   jit_convert::visit_continue_command (tree_continue_command&)
   {
     m_continues.push_back (m_block);
     throw jit_break_exception ();
   }
 
   void
-jit_convert::visit_decl_command (tree_decl_command&)
-{
-  throw jit_fail_exception ("No visit_decl_command implementation");
-}
-
-void
+  jit_convert::visit_decl_command (tree_decl_command&)
+  {
+    throw jit_fail_exception ("No visit_decl_command implementation");
+  }
+
+  void
   jit_convert::visit_decl_elt (tree_decl_elt&)
   {
     throw jit_fail_exception ("No visit_decl_elt implementation");
   }
 
   void
   jit_convert::visit_decl_init_list (tree_decl_init_list&)
   {
@@ -394,62 +397,63 @@ void
 
     // If we are a nested for loop we need to store the previous breaks
     unwind_protect frame;
     frame.protect_var (m_breaks);
     frame.protect_var (m_continues);
     m_breaks.clear ();
     m_continues.clear ();
 
-    // we need a variable for our iterator, because it is used in multiple blocks
+    // Need a variable for our iterator, because it is used in multiple blocks
     std::string iter_name = next_iterator ();
     jit_variable *iterator = m_factory.create<jit_variable> (iter_name);
     m_factory.create<jit_variable> (iter_name);
     m_vmap[iter_name] = iterator;
 
     jit_block *body = m_factory.create<jit_block> ("for_body");
     jit_block *tail = m_factory.create<jit_block> ("for_tail");
 
-    // do control expression, iter init, and condition check in prev_block (block)
+    // Do control expression, iter init, and condition check in prev_block
+    // (block).
     // if we are the top level for loop, the bounds is an input argument.
     jit_value *control = find_variable (next_for_bounds ());
     if (! control)
       control = visit (cmd.control_expr ());
     jit_call *init_iter = m_factory.create<jit_call> (jit_typeinfo::for_init,
-                                                    control);
+                                                      control);
     m_block->append (init_iter);
     m_block->append (m_factory.create<jit_assign> (iterator, init_iter));
 
-    jit_call *check = m_factory.create<jit_call> (jit_typeinfo::for_check, control,
-                                                iterator);
+    jit_call *check = m_factory.create<jit_call> (jit_typeinfo::for_check,
+                                                  control, iterator);
     m_block->append (check);
     m_block->append (m_factory.create<jit_cond_branch> (check, body, tail));
 
     m_blocks.push_back (body);
     m_block = body;
 
     // compute the syntactical iterator
     jit_call *idx_rhs = m_factory.create<jit_call> (jit_typeinfo::for_index,
-                                                  control, iterator);
+                                                    control, iterator);
     m_block->append (idx_rhs);
     do_assign (cmd.left_hand_side (), idx_rhs);
 
     // do loop
     tree_statement_list *pt_body = cmd.body ();
     bool all_breaking = false;
     try
       {
         pt_body->accept (*this);
       }
     catch (const jit_break_exception&)
       {
         if (m_continues.empty ())
           {
-            // WTF are you doing user? Every branch was a break, why did you have
-            // a loop??? Users are silly people...
+            // WTF are you doing user?  Every branch was a break, why did you
+            // have a loop???  Users are silly people...
             finish_breaks (tail, m_breaks);
             m_blocks.push_back (tail);
             m_block = tail;
             return;
           }
 
         all_breaking = true;
       }
@@ -467,24 +471,24 @@ void
 
     m_block = check_block;
     const jit_operation& add_fn = jit_typeinfo::binary_op (octave_value::op_add);
     jit_value *one = m_factory.create<jit_const_index> (1);
     jit_call *iter_inc = m_factory.create<jit_call> (add_fn, iterator, one);
     m_block->append (iter_inc);
     m_block->append (m_factory.create<jit_assign> (iterator, iter_inc));
     check = m_block->append (m_factory.create<jit_call> (jit_typeinfo::for_check,
-                                                     control, iterator));
+                                                         control, iterator));
     m_block->append (m_factory.create<jit_cond_branch> (check, interrupt_check,
-                                                    tail));
+                                                        tail));
 
     m_block = interrupt_check;
     jit_error_check *ec
       = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                         body, m_final_block);
+                                           body, m_final_block);
     m_block->append (ec);
 
     // breaks will go to our tail
     m_blocks.push_back (tail);
     finish_breaks (tail, m_breaks);
     m_block = tail;
   }
 
@@ -563,17 +567,17 @@ void
     size_t last_else = static_cast<size_t> (last->is_else_clause ());
 
     // entry_blocks represents the block you need to enter in order to execute
     // the condition check for the ith clause.  For the else, it is simple the
     // else body.  If there is no else body, then it is padded with the tail.
     std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
     entry_blocks[0] = m_block;
 
-    // we need to construct blocks first, because they have jumps to each other.
+    // Need to construct blocks first, because they have jumps to each other.
     tree_if_command_list::iterator iter = lst.begin ();
     ++iter;
     for (size_t i = 1; iter != lst.end (); ++iter, ++i)
       {
         tree_if_clause *tic = *iter;
         if (tic->is_else_clause ())
           entry_blocks[i] = m_factory.create<jit_block> ("else");
         else
@@ -606,18 +610,19 @@ void
             tree_expression *expr = tic->condition ();
             jit_value *cond = visit (expr);
             jit_call *check = create_checked (&jit_typeinfo::logically_true,
                                               cond);
             jit_block *body = m_factory.create<jit_block> (i == 0 ? "if_body"
                                                          : "ifelse_body");
             m_blocks.push_back (body);
 
-            jit_instruction *br = m_factory.create<jit_cond_branch> (check, body,
-                                                                   entry_blocks[i + 1]);
+            jit_instruction *br = m_factory.create<jit_cond_branch> (check,
+                                                                     body,
+                                                                     entry_blocks[i + 1]);
             m_block->append (br);
             m_block = body;
           }
 
         tree_statement_list *stmt_lst = tic->commands ();
         assert (stmt_lst); // jwe: Can this be null?
 
         try
@@ -811,17 +816,18 @@ void
           do_assign ("ans", expr_result, expr->print_result ());
         else if (expr->is_identifier () && expr->print_result ())
           {
             // FIXME: ugly hack, we need to come up with a way to pass
             // nargout to visit_identifier
             const jit_operation& fn = jit_typeinfo::print_value ();
             jit_const_string *name = m_factory.create<jit_const_string>
               (expr->name ());
-            m_block->append (m_factory.create<jit_call> (fn, name, expr_result));
+            m_block->append (m_factory.create<jit_call> (fn, name,
+                                                         expr_result));
           }
       }
   }
 
   void
   jit_convert::visit_statement_list (tree_statement_list& lst)
   {
     for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
@@ -863,17 +869,17 @@ void
       return;
 
     // check for otherwise, it's interpreted as last 'else' condition
     size_t has_otherwise = 0;
     tree_switch_case *last = lst->back ();
     if (last->is_default_case ())
       has_otherwise = 1;
 
-    std::vector<jit_block *> entry_blocks (case_blocks_num + 1 - has_otherwise);
+    std::vector<jit_block *> entry_blocks (case_blocks_num+1 - has_otherwise);
 
     // the first entry point is always the actual block.  Afterward, new blocks
     // are created for every case and the otherwise branch
     entry_blocks[0] = m_block;
     for (size_t i = 1; i < case_blocks_num; ++i)
       entry_blocks[i] = m_factory.create<jit_block> ("case_cond");
 
     jit_block *tail = m_factory.create<jit_block> ("switch_tail");
@@ -930,17 +936,18 @@ void
           {
             stmt_lst->accept (*this);
             num_incoming++;
             m_block->append (m_factory.create<jit_branch> (tail));
           }
         catch (const jit_break_exception&)
           { }
 
-        // each branch in the case statement will have different breaks/continues
+        // each branch in the case statement will have different
+        // breaks/continues
         current_breaks.splice (current_breaks.end (), m_breaks);
         current_continues.splice (current_continues.end (), m_continues);
       }
 
     // each branch in the case statement will have different breaks/continues
     m_breaks.splice (m_breaks.end (), current_breaks);
     m_continues.splice (m_continues.end (), current_continues);
 
@@ -1014,17 +1021,17 @@ void
         m_blocks.push_back (interrupt_check);
         finish_breaks (interrupt_check, m_continues);
         if (! all_breaking)
           m_block->append (m_factory.create<jit_branch> (interrupt_check));
 
         m_block = interrupt_check;
         jit_error_check *ec
           = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                             cond_check, m_final_block);
+                                               cond_check, m_final_block);
         m_block->append (ec);
       }
 
     m_blocks.push_back (tail);
     m_block = tail;
   }
 
   void
@@ -1067,28 +1074,29 @@ void
         m_blocks.push_back (interrupt_check);
         finish_breaks (interrupt_check, m_continues);
         if (! all_breaking)
           m_block->append (m_factory.create<jit_branch> (interrupt_check));
 
         m_block = interrupt_check;
         jit_error_check *ec
           = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                             cond_check, m_final_block);
+                                               cond_check, m_final_block);
         m_block->append (ec);
 
         m_blocks.push_back (cond_check);
         m_block = cond_check;
 
         tree_expression *expr = duc.condition ();
         assert (expr && "Do-Until expression can not be null");
         jit_value *check = visit (expr);
         check = create_checked (&jit_typeinfo::logically_true, check);
 
-        m_block->append (m_factory.create<jit_cond_branch> (check, tail, body));
+        m_block->append (m_factory.create<jit_cond_branch> (check, tail,
+                                                            body));
       }
 
     m_blocks.push_back (tail);
     m_block = tail;
   }
 
   void
   jit_convert::initialize (const symbol_scope& s)
@@ -1108,18 +1116,18 @@ void
 
   jit_call *
   jit_convert::create_checked_impl (jit_call *ret)
   {
     m_block->append (ret);
 
     jit_block *normal = m_factory.create<jit_block> (m_block->name ());
     jit_error_check *check
-      = m_factory.create<jit_error_check> (jit_error_check::var_error_state, ret,
-                                         normal, m_final_block);
+      = m_factory.create<jit_error_check> (jit_error_check::var_error_state,
+                                           ret, normal, m_final_block);
     m_block->append (check);
     m_blocks.push_back (normal);
     m_block = normal;
 
     return ret;
   }
 
   jit_variable *
@@ -1245,17 +1253,18 @@ void
 
     const jit_operation& fres = (lhs ? jit_typeinfo::paren_subsasgn ()
                                  : jit_typeinfo::paren_subsref ());
 
     return create_checked (fres, call_args);
   }
 
   jit_value *
-  jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool artificial)
+  jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool
+                          artificial)
   {
     if (! exp)
       throw jit_fail_exception ("NULL lhs in assign");
 
     if (isa<tree_identifier> (exp))
       return do_assign (exp->name (), rhs, exp->print_result (), artificial);
     else if (tree_index_expression *idx
              = dynamic_cast<tree_index_expression *> (exp))
@@ -1270,17 +1279,18 @@ void
       throw jit_fail_exception ("Unsupported assignment");
   }
 
   jit_value *
   jit_convert::do_assign (const std::string& lhs, jit_value *rhs,
                           bool print, bool artificial)
   {
     jit_variable *var = get_variable (lhs);
-    jit_assign *assign = m_block->append (m_factory.create<jit_assign> (var, rhs));
+    jit_assign *assign = m_block->append (m_factory.create<jit_assign> (var,
+                                                                        rhs));
 
     if (artificial)
       assign->mark_artificial ();
 
     if (print)
       {
         const jit_operation& print_fn = jit_typeinfo::print_value ();
         jit_const_string *name = m_factory.create<jit_const_string> (lhs);
@@ -1315,21 +1325,22 @@ void
   llvm::Function *
   jit_convert_llvm::convert_loop (const jit_module& module,
                                   const jit_block_list& blocks,
                                   const std::list<jit_value *>& constants,
                                   const std::string& llvm_function_name)
   {
     m_converting_function = false;
 
-    // for now just init arguments from entry, later we will have to do something
-    // more interesting
+    // for now just init arguments from entry, later we will have to do
+    // something more interesting
     jit_block *m_entry_block = blocks.front ();
     for (jit_block::iterator iter = m_entry_block->begin ();
-         iter != m_entry_block->end (); ++iter)
+         iter != m_entry_block->end ();
+         ++iter)
       if (jit_extract_argument *extract
           = dynamic_cast<jit_extract_argument *> (*iter))
         m_argument_vec.push_back (std::make_pair (extract->name (), true));
 
     jit_type *any = jit_typeinfo::get_any ();
 
     // argument is an array of octave_base_value*, or octave_base_value**
     llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
@@ -1338,17 +1349,18 @@ void
                                   arg_type->getPointerTo (), false);
 
     m_function = module.create_llvm_function (ft, llvm_function_name);
     try
       {
         m_prelude = llvm::BasicBlock::Create (context, "prelude", m_function);
         builder.SetInsertPoint (m_prelude);
 
-        // The jitted function will have only one function argument, of octave_base_value** type
+        // The jitted function will have only one function argument, of
+        // octave_base_value** type
         llvm::Value *arg = &*(m_function->arg_begin ());
 
         for (size_t i = 0; i < m_argument_vec.size (); ++i)
           {
             // llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);         // LLVM <= 3.6
             llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg_type, arg, i);  // LLVM >= 3.7
 
             m_arguments[m_argument_vec[i].first] = loaded_arg;
@@ -1374,17 +1386,17 @@ void
   {
     m_converting_function = true;
 
     jit_block *m_final_block = blocks.back ();
     jit_return *ret = dynamic_cast<jit_return *> (m_final_block->back ());
     assert (ret);
 
     m_creating = jit_function (&module, jit_convention::internal,
-                             "foobar", ret->result_type (), args);
+                               "foobar", ret->result_type (), args);
     m_function = m_creating.to_llvm ();
 
     try
       {
         m_prelude = m_creating.new_block ("prelude");
         builder.SetInsertPoint (m_prelude);
 
         tree_parameter_list *plist = fcn.parameter_list ();
@@ -1657,17 +1669,18 @@ void
   { }
 
   void
   jit_convert_llvm::visit (jit_magic_end& me)
   {
     const jit_function& ol = me.overload ();
 
     jit_magic_end::context ctx = me.resolve_context ();
-    llvm::Value *ret = ol.call (builder, ctx.m_value, ctx.m_index, ctx.m_count);
+    llvm::Value *ret = ol.call (builder, ctx.m_value, ctx.m_index,
+                                ctx.m_count);
     me.stash_llvm (ret);
   }
 
   // -------------------- jit_infer --------------------
   jit_infer::jit_infer (jit_factory& afactory, jit_block_list& ablocks,
                         const variable_map& avmap)
     : m_blocks (ablocks), m_factory (afactory), m_vmap (avmap) { }
 
@@ -1739,17 +1752,18 @@ void
   jit_infer::construct_ssa (void)
   {
     m_blocks.label ();
     final_block ().compute_idom (entry_block ());
     entry_block ().compute_df ();
     entry_block ().create_dom_tree ();
 
     // insert phi nodes where needed, this is done on a per variable basis
-    for (variable_map::const_iterator iter = m_vmap.begin (); iter != m_vmap.end ();
+    for (variable_map::const_iterator iter = m_vmap.begin ();
+         iter != m_vmap.end ();
          ++iter)
       {
         jit_block::df_set visited, added_phi;
         std::list<jit_block *> ssa_worklist;
         iter->second->use_blocks (visited);
         ssa_worklist.insert (ssa_worklist.begin (), visited.begin (),
                              visited.end ());
 
@@ -1760,17 +1774,17 @@ void
 
             for (jit_block::df_iterator diter = b->df_begin ();
                  diter != b->df_end (); ++diter)
               {
                 jit_block *dblock = *diter;
                 if (! added_phi.count (dblock))
                   {
                     jit_phi *phi = m_factory.create<jit_phi> (iter->second,
-                                                            dblock->use_count ());
+                                                          dblock->use_count ());
                     dblock->prepend (phi);
                     added_phi.insert (dblock);
                   }
 
                 if (! visited.count (dblock))
                   {
                     ssa_worklist.push_back (dblock);
                     visited.insert (dblock);
@@ -1784,17 +1798,18 @@ void
 
   void
   jit_infer::do_construct_ssa (jit_block& ablock, size_t avisit_count)
   {
     if (ablock.visited (avisit_count))
       return;
 
     // replace variables with their current SSA value
-    for (jit_block::iterator iter = ablock.begin (); iter != ablock.end ();
+    for (jit_block::iterator iter = ablock.begin ();
+         iter != ablock.end ();
          ++iter)
       {
         jit_instruction *instr = *iter;
         instr->construct_ssa ();
         instr->push_variable ();
       }
 
     // finish phi nodes of successors
@@ -1808,17 +1823,18 @@ void
             jit_phi *phi = static_cast<jit_phi *> (*iter);
             jit_variable *var = phi->dest ();
             ++iter;
 
             if (var->has_top ())
               phi->add_incoming (&ablock, var->top ());
             else
               {
-                // temporaries may have extranious phi nodes which can be removed
+                // temporaries may have extraneous phi nodes which can be
+                // removed
                 assert (! phi->use_count ());
                 assert (var->name ().size () && var->name ()[0] == '#');
                 phi->remove ();
               }
           }
       }
 
     for (size_t i = 0; i < ablock.dom_successor_count (); ++i)
@@ -1826,17 +1842,18 @@ void
 
     ablock.pop_all ();
   }
 
   void
   jit_infer::place_releases (void)
   {
     std::set<jit_value *> temporaries;
-    for (jit_block_list::iterator iter = m_blocks.begin (); iter != m_blocks.end ();
+    for (jit_block_list::iterator iter = m_blocks.begin ();
+         iter != m_blocks.end ();
          ++iter)
       {
         jit_block& ablock = **iter;
         if (ablock.id () != jit_block::NO_ID)
           {
             release_temp (ablock, temporaries);
             release_dead_phi (ablock);
           }
@@ -1910,43 +1927,45 @@ void
     while (iter != ablock.end () && isa<jit_phi> (*iter))
       {
         jit_phi *phi = static_cast<jit_phi *> (*iter);
         ++iter;
 
         jit_use *use = phi->first_use ();
         if (phi->use_count () == 1 && isa<jit_assign> (use->user ()))
           {
-            // instead of releasing on assign, release on all incoming branches,
-            // this can get rid of casts inside loops
+            // instead of releasing on assign, release on all incoming
+            // branches, this can get rid of casts inside loops
             for (size_t i = 0; i < phi->argument_count (); ++i)
               {
                 jit_value *arg = phi->argument (i);
                 if (! arg->needs_release ())
                   continue;
 
                 jit_block *inc = phi->incoming (i);
-                jit_block *split = inc->maybe_split (m_factory, m_blocks, ablock);
+                jit_block *split = inc->maybe_split (m_factory, m_blocks,
+                                                     ablock);
                 jit_terminator *term = split->terminator ();
                 jit_call *release
                   = m_factory.create<jit_call> (jit_typeinfo::release, arg);
                 release->infer ();
                 split->insert_before (term, release);
               }
 
             phi->replace_with (0);
             phi->remove ();
           }
       }
   }
 
   void
   jit_infer::release_temp (jit_block& ablock, std::set<jit_value *>& temp)
   {
-    for (jit_block::iterator iter = ablock.begin (); iter != ablock.end ();
+    for (jit_block::iterator iter = ablock.begin ();
+         iter != ablock.end ();
          ++iter)
       {
         jit_instruction *instr = *iter;
 
         // check for temporaries that require release and live across
         // multiple blocks
         if (instr->needs_release ())
           {
@@ -1974,33 +1993,36 @@ void
           }
       }
 
     if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
       return;
 
     // FIXME: If we support try/catch or unwind_protect final_block
     //        may not be the destination
-    jit_block *split = ablock.maybe_split (m_factory, m_blocks, final_block ());
+    jit_block *split = ablock.maybe_split (m_factory, m_blocks,
+                                           final_block ());
     jit_terminator *term = split->terminator ();
     for (std::set<jit_value *>::const_iterator iter = temp.begin ();
-         iter != temp.end (); ++iter)
+         iter != temp.end ();
+         ++iter)
       {
         jit_value *value = *iter;
         jit_call *release
           = m_factory.create<jit_call> (&jit_typeinfo::release, value);
         split->insert_before (term, release);
         release->infer ();
       }
   }
 
   void
   jit_infer::simplify_phi (void)
   {
-    for (jit_block_list::iterator biter = m_blocks.begin (); biter != m_blocks.end ();
+    for (jit_block_list::iterator biter = m_blocks.begin ();
+         biter != m_blocks.end ();
          ++biter)
       {
         jit_block &ablock = **biter;
         for (jit_block::iterator iter = ablock.begin ();
              iter != ablock.end () && isa<jit_phi> (*iter); ++iter)
           simplify_phi (*static_cast<jit_phi *> (*iter));
       }
   }
@@ -2037,36 +2059,38 @@ void
   // A simple memory manager for our LLVM engines,
   // based on LLVM's Kaleidoscope example
 
   class jit_memory_manager : public llvm::SectionMemoryManager
   {
     jit_memory_manager (const jit_memory_manager&) = delete;
     void operator= (const jit_memory_manager&) = delete;
   public:
-    jit_memory_manager () {}
-    virtual ~jit_memory_manager () {}
+    jit_memory_manager () { }
+    virtual ~jit_memory_manager () { }
 
     // The Kaleidoscope example in LLVM 3.8 indicates that
     // getPointerToNamedFunction has to be overloaded, but actually it is
     // getSymbolAddress that must be overloaded.
     virtual uint64_t getSymbolAddress (const std::string &name);
 
     // Is it still useful to overload getPointerToNamedFunction to support
     // some older version of LLVM?  Are there others virtual functions
     // that must be overloaded?
-    virtual void* getPointerToNamedFunction (const std::string& name, bool abort_on_failure);
+    virtual void* getPointerToNamedFunction (const std::string& name, bool
+                                             abort_on_failure);
   };
 
   void*
   jit_memory_manager::getPointerToNamedFunction (const std::string& name,
                                                  bool abort_on_failure)
   {
     // Try the standard symbol resolution first, but ask it not to abort
-    void *pfn = llvm::RTDyldMemoryManager::getPointerToNamedFunction (name, false);
+    void *pfn = llvm::RTDyldMemoryManager::getPointerToNamedFunction (name,
+                                                                      false);
     if (pfn)
       return pfn;
 
     pfn = tree_jit::getPointerToNamedFunction (name);
     if ((pfn == nullptr) && abort_on_failure)
       llvm::report_fatal_error ("Program used external function '" + name +
                                 "' which could not be resolved!");
     return pfn;
@@ -2124,17 +2148,18 @@ void
   {
     std::string err;
 
     llvm::ExecutionEngine *e = llvm::EngineBuilder (std::move (module_owner))
       .setErrorStr (&err)
       .setMCJITMemoryManager(llvm::make_unique<jit_memory_manager> ())
       .create ();
 
-    // Note: in some versions of LLVM, we should call .setUseMCJIT (true) before .create () ?
+    // Note: in some versions of LLVM, we should call .setUseMCJIT (true)
+    // before .create () ?
     // FIXME: autconf this
 
     if (e == nullptr)
       {
         std::cerr << "Failed to create JIT engine" << std::endl;
         std::cerr << err << std::endl;
       }
 
@@ -2356,17 +2381,18 @@ void
   {
     // we mark all functinos as external linkage because this prevents
     // llvm from getting rid of always inline functions
 
     return llvm::Function::Create (ftype, llvm::Function::ExternalLinkage,
                                    name, m_module);
   }
 
-  // Create or insert an LLVM Function declaration for an intrinsic and return it
+  // Create or insert an LLVM Function declaration for an intrinsic and return
+  // it
   llvm::Function*
   jit_module::get_intrinsic_declaration (size_t id,
                                          std::vector<llvm::Type*> types) const
   {
     return llvm::Intrinsic::getDeclaration
       (m_module, static_cast<llvm::Intrinsic::ID> (id), types);
   }
 
@@ -2526,30 +2552,35 @@ void
         llvm::BasicBlock *wrapper_body = wrapper.new_block ();
         builder.SetInsertPoint (wrapper_body);
 
         llvm::Value *wrapper_arg = wrapper.argument (builder, 0);
         std::vector<llvm::Value *> raw_args (nargs);
         for (size_t i = 0; i < nargs; ++i)
           {
             llvm::Value *arg;
-            // arg = builder.CreateConstInBoundsGEP1_32 (wrapper_arg, i);                  // LLVM <= 3.6
-            arg = builder.CreateConstInBoundsGEP1_32 (any_t->to_llvm (), wrapper_arg, i);  // LLVM >= 3.7
+            // LLVM <= 3.6
+            // arg = builder.CreateConstInBoundsGEP1_32 (wrapper_arg, i);
+            / / LLVM >= 3.7
+            arg = builder.CreateConstInBoundsGEP1_32 (any_t->to_llvm (),
+                                                      wrapper_arg, i);
+        
             arg = builder.CreateLoad (arg);
 
             jit_type *arg_type = m_argument_types[i];
             const jit_function& cast = jit_typeinfo::cast (arg_type, any_t);
             raw_args[i] = cast.call (builder, arg);
           }
 
         llvm::Value *result = raw_fn.call (builder, raw_args);
         if (raw_fn.result ())
           {
             jit_type *raw_result_t = raw_fn.result ();
-            const jit_function& cast = jit_typeinfo::cast (any_t, raw_result_t);
+            const jit_function& cast = jit_typeinfo::cast (any_t,
+                                                           raw_result_t);
             result = cast.call (builder, result);
           }
         else
           {
             llvm::Value *zero = builder.getInt32 (0);
             result = builder.CreateBitCast (zero, any_t->to_llvm ());
           }
 
@@ -2600,17 +2631,18 @@ void
 
   bool
   jit_function_info::execute (const octave_value_list& ov_args,
                               octave_value_list& retval) const
   {
     if (! m_function)
       return false;
 
-    // FIXME: figure out a way to delete ov_args so we avoid duplicating refcount
+    // FIXME: figure out a way to delete ov_args so we avoid duplicating
+    // refcount
     size_t nargs = ov_args.length ();
     std::vector<octave_base_value *> args (nargs);
     for (size_t i = 0; i < nargs; ++i)
       {
         octave_base_value *obv = ov_args(i).internal_rep ();
         obv->grab ();
         args[i] = obv;
       }
@@ -2652,17 +2684,18 @@ void
 
   jit_info::jit_info (tree& tee, const octave_value& for_bounds)
     : m_llvm_function_name (tree_jit::generate_unique_function_name ()),
       m_function (nullptr)
   {
     compile (tee, jit_typeinfo::type_of (for_bounds));
   }
 
-  jit_info::jit_info (tree_simple_for_command& tee, const octave_value& for_bounds)
+  jit_info::jit_info (tree_simple_for_command& tee,
+                      const octave_value& for_bounds)
     : m_llvm_function_name (tree_jit::generate_unique_forloop_name ()),
       m_function (nullptr)
   {
     compile (tee, jit_typeinfo::type_of (for_bounds));
   }
 
   bool
   jit_info::execute (const vmap& extra_vars) const
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -452,28 +452,34 @@ namespace octave
 
     uint64_t do_getSymbolAddress (const std::string &name) const;
 
     // ----- Generate unique identifiers -----
 
   public:
 
     static std::string generate_unique_forloop_name (void)
-    { return std::string ("jittedForLoop")
-        + std::to_string (next_forloop_number ++); }
+    {
+      return std::string ("jittedForLoop")
+             + std::to_string (next_forloop_number ++);
+    }
     // FIXME: Check that the identifier does not exist
 
     static std::string generate_unique_function_name (void)
-    { return std::string ("jittedFunction")
-        + std::to_string (next_function_number ++); }
+    {
+      return std::string ("jittedFunction")
+             + std::to_string (next_function_number ++);
+    }
     // FIXME: Check that the identifier does not exist
 
     static std::string generate_unique_module_name (void)
-    { return std::string ("octaveJITModule")
-        + std::to_string (next_module_number ++); }
+    {
+      return std::string ("octaveJITModule")
+             + std::to_string (next_module_number ++);
+    }
     // FIXME: Check that the identifier does not exist
 
   private:
 
     static int next_forloop_number;
     static int next_function_number;
     static int next_module_number;
 
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -40,20 +40,20 @@ namespace octave
   // parameters in a function definition.  Elements are identifiers
   // only.
 
   class tree_parameter_list : public base_list<tree_decl_elt *>
   {
   public:
 
     enum in_or_out
-      {
-        in = 1,
-        out = 2
-      };
+    {
+      in = 1,
+      out = 2
+    };
 
     tree_parameter_list (void)
       : m_marked_for_varargs (0) { }
 
     tree_parameter_list (tree_decl_elt *t)
       : m_marked_for_varargs (0) { append (t); }
 
     tree_parameter_list (tree_identifier *id)
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -32,43 +32,43 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   class
   token
   {
   public:
 
     enum token_type
-      {
-        generic_token,
-        keyword_token,
-        string_token,
-        double_token,
-        ettype_token,
-        sym_rec_token,
-        scls_name_token,
-      };
+    {
+      generic_token,
+      keyword_token,
+      string_token,
+      double_token,
+      ettype_token,
+      sym_rec_token,
+      scls_name_token,
+    };
 
     enum end_tok_type
-      {
-        simple_end,
-        classdef_end,
-        enumeration_end,
-        events_end,
-        for_end,
-        function_end,
-        if_end,
-        methods_end,
-        parfor_end,
-        properties_end,
-        switch_end,
-        try_catch_end,
-        unwind_protect_end,
-        while_end,
-      };
+    {
+      simple_end,
+      classdef_end,
+      enumeration_end,
+      events_end,
+      for_end,
+      function_end,
+      if_end,
+      methods_end,
+      parfor_end,
+      properties_end,
+      switch_end,
+      try_catch_end,
+      unwind_protect_end,
+      while_end,
+    };
 
     token (int tv, int l = -1, int c = -1);
     token (int tv, bool is_keyword, int l = -1, int c = -1);
     token (int tv, const char *s, int l = -1, int c = -1);
     token (int tv, const std::string& s, int l = -1, int c = -1);
     token (int tv, double d, const std::string& s = "",
            int l = -1, int c = -1);
     token (int tv, end_tok_type t, int l = -1, int c = -1);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1457,17 +1457,17 @@ ComplexMatrix::determinant (MatrixType& 
       F77_INT tmp_info = 0;
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
         {
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                   tmp_info));
+                                     tmp_info));
 
           info = tmp_info;
         }
 
       // Throw away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
@@ -2510,19 +2510,19 @@ ComplexMatrix::lssolve (const ComplexMat
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
       double anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-                               + 3*smlsiz*nrhs
-                               + std::max ((smlsiz+1)*(smlsiz+1),
-                                           n*(1+nrhs) + 2*nrhs);
+                       + 3*smlsiz*nrhs
+                       + std::max ((smlsiz+1)*(smlsiz+1),
+                                   n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2730,17 +2730,17 @@ ComplexMatrix::lssolve (const ComplexCol
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-                               + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+                       + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -250,18 +250,19 @@ private:
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType& mattype, const Matrix& b) const;
   ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
-                       double& rcon, solve_singularity_handler sing_handler,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
+                       octave_idx_type& info, double& rcon,
+                       solve_singularity_handler sing_handler,
                        bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -173,18 +173,18 @@ SparseComplexMatrix::ishermitian (void) 
 
       return true;
     }
 
   return false;
 }
 
 static const Complex
-  Complex_NaN_result (octave::numeric_limits<double>::NaN (),
-                      octave::numeric_limits<double>::NaN ());
+Complex_NaN_result (octave::numeric_limits<double>::NaN (),
+                    octave::numeric_limits<double>::NaN ());
 
 SparseComplexMatrix
 SparseComplexMatrix::max (int dim) const
 {
   Array<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
@@ -3863,18 +3863,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DU[j-1] = data (i);
                   }
             }
 
           F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
-          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
-                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
+          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL),
+                                     F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU),
+                                     F77_DBLE_CMPLX_ARG (DU2),
+                                     pipvt, tmp_err));
 
           err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
@@ -3903,17 +3906,19 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL),
+                             F77_DBLE_CMPLX_ARG (D),
+                             F77_DBLE_CMPLX_ARG (DU),
                              F77_DBLE_CMPLX_ARG (DU2), pipvt,
                              F77_DBLE_CMPLX_ARG (work), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
 
                   // Count nonzeros in work vector and adjust
                   // space in retval if needed
@@ -4189,18 +4194,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DU[j-1] = data (i);
                   }
             }
 
           F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
-          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
-                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
+          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL),
+                                     F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU),
+                                     F77_DBLE_CMPLX_ARG (DU2),
+                                     pipvt, tmp_err));
 
           err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
@@ -4230,17 +4238,19 @@ SparseComplexMatrix::trisolve (MatrixTyp
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (F77_INT i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL),
+                             F77_DBLE_CMPLX_ARG (D),
+                             F77_DBLE_CMPLX_ARG (DU),
                              F77_DBLE_CMPLX_ARG (DU2), pipvt,
                              F77_DBLE_CMPLX_ARG (Bx), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
 
                   if (err != 0)
                     {
diff --git a/liboctave/array/CSparse.h b/liboctave/array/CSparse.h
--- a/liboctave/array/CSparse.h
+++ b/liboctave/array/CSparse.h
@@ -170,18 +170,19 @@ public:
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond,
                           bool calc_cond = true) const;
 
 private:
   // Diagonal matrix solvers
-  ComplexMatrix dsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
-                        double& rcond, solve_singularity_handler sing_handler,
+  ComplexMatrix dsolve (MatrixType& mattype, const Matrix& b,
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType& mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType& mattype, const SparseMatrix& b,
@@ -303,19 +304,20 @@ private:
                               solve_singularity_handler sing_handler,
                               bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType& mattype, const Matrix& b) const;
   ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
-                       double& rcond) const;
-  ComplexMatrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
+                       octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (MatrixType& mattype, const Matrix& b,
+                       octave_idx_type& info,
                        double& rcond, solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond) const;
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -202,17 +202,18 @@ private:
   // Full matrix solvers (lu/cholesky)
   Matrix fsolve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType& mattype, const Matrix& b) const;
-  Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (MatrixType& mattype, const Matrix& b,
+                octave_idx_type& info) const;
   Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon) const;
   Matrix solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool singular_fallback = true,
                 blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType& mattype, const ComplexMatrix& b) const;
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -877,17 +877,18 @@ FloatComplexMatrix::finverse (MatrixType
   float anorm = norm1 (retval);
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
     {
-      F77_XFCN (cgetrf, CGETRF, (nc, nc, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+      F77_XFCN (cgetrf, CGETRF, (nc, nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
+                                 tmp_info));
 
       info = tmp_info;
     }
 
   // Throw away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
@@ -1456,17 +1457,18 @@ FloatComplexMatrix::determinant (MatrixT
 
       F77_INT tmp_info = 0;
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
         {
-          F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+          F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt,
+                                     tmp_info));
 
           info = tmp_info;
         }
 
       // Throw away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
@@ -2017,17 +2019,18 @@ FloatComplexMatrix::fsolve (MatrixType& 
           F77_INT tmp_info = 0;
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
             {
-              F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+              F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt,
+                                         tmp_info));
 
               info = tmp_info;
             }
 
           // Throw away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
@@ -2531,19 +2534,19 @@ FloatComplexMatrix::lssolve (const Float
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
       float anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-                               + 3*smlsiz*nrhs
-                               + std::max ((smlsiz+1)*(smlsiz+1),
-                                           n*(1+nrhs) + 2*nrhs);
+                       + 3*smlsiz*nrhs
+                       + std::max ((smlsiz+1)*(smlsiz+1),
+                                   n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2754,17 +2757,17 @@ FloatComplexMatrix::lssolve (const Float
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-                               + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+                       + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -261,17 +261,18 @@ public:
   FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                             octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                             octave_idx_type& info,
                             float& rcon, solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
                             blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b) const;
+  FloatComplexMatrix solve (MatrixType& mattype,
+                            const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -219,17 +219,18 @@ public:
   FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info, float& rcon) const;
   FloatMatrix solve (MatrixType& mattype, const FloatMatrix& b,
                      octave_idx_type& info, float& rcon,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback = true,
                      blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b) const;
+  FloatComplexMatrix solve (MatrixType& mattype,
+                            const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType& mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback = true,
diff --git a/liboctave/external/Faddeeva/Faddeeva.cc b/liboctave/external/Faddeeva/Faddeeva.cc
--- a/liboctave/external/Faddeeva/Faddeeva.cc
+++ b/liboctave/external/Faddeeva/Faddeeva.cc
@@ -239,18 +239,18 @@ typedef double complex cmplx;
 #    define Inf INFINITY // C99 infinity
 #    if defined (NAN) // GNU libc extension
 #      define NaN NAN
 #    else
 #      define NaN (0./0.) // NaN
 #    endif
 #  else
 #    define C(a,b) ((a) + I*(b))
-#    define Inf (1./0.) 
-#    define NaN (0./0.) 
+#    define Inf (1./0.)
+#    define NaN (0./0.)
 #  endif
 
 static inline cmplx cpolar(double r, double t)
 {
   if (r == 0.0 && !isnan(t))
     return 0.0;
   else
     return C(r * cos(t), r * sin(t));
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -112,17 +112,17 @@ namespace octave
       F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("FloatGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         err_nonconformant ("FloatGEPBALANCE",
-                                   n, n, b.rows(), b.cols());
+                           n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
       OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -179,17 +179,17 @@ namespace octave
       F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("ComplexGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         err_nonconformant ("ComplexGEPBALANCE",
-                                   n, n, b.rows(), b.cols());
+                           n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (double, plscale, n);
       OCTAVE_LOCAL_BUFFER (double, prscale,  n);
       OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -250,17 +250,17 @@ namespace octave
         {
           (*current_liboctave_error_handler)
             ("FloatComplexGEPBALANCE requires square matrix");
           return -1;
         }
 
       if (a.dims () != b.dims ())
         err_nonconformant ("FloatComplexGEPBALANCE",
-                                   n, n, b.rows(), b.cols());
+                           n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
       OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 
 namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     hess<Matrix>::init (const Matrix& a)
-   {
+    {
       F77_INT a_nr = to_f77_int (a.rows ());
       F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -850,17 +850,17 @@ namespace octave
         jstart = jmax;
       }
 
     octave_quit ();
   }
 
   int
   fftw::fft (const double *in, Complex *out, size_t npts,
-                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+             size_t nsamples, octave_idx_type stride, octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = fftw_planner::create_plan (1, dv, nsamples,
                                              stride, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
 
@@ -871,17 +871,17 @@ namespace octave
 
     convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
     return 0;
   }
 
   int
   fftw::fft (const Complex *in, Complex *out, size_t npts,
-                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+             size_t nsamples, octave_idx_type stride, octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
                                              nsamples, stride,
                                              dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
@@ -890,18 +890,18 @@ namespace octave
                       reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
                       reinterpret_cast<fftw_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifft (const Complex *in, Complex *out, size_t npts,
-                     size_t nsamples, octave_idx_type stride,
-                     octave_idx_type dist)
+              size_t nsamples, octave_idx_type stride,
+              octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = fftw_planner::create_plan (FFTW_BACKWARD, 1, dv, nsamples,
                                              stride, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
 
@@ -914,17 +914,17 @@ namespace octave
       for (size_t i = 0; i < npts; i++)
         out[i*stride + j*dist] /= scale;
 
     return 0;
   }
 
   int
   fftw::fftNd (const double *in, Complex *out, const int rank,
-                      const dim_vector& dv)
+               const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     // Fool with the position of the start of the output matrix, so that
     // creating other half of the matrix won't cause cache problems.
 
@@ -941,17 +941,17 @@ namespace octave
 
     convert_packcomplex_Nd (out, dv);
 
     return 0;
   }
 
   int
   fftw::fftNd (const Complex *in, Complex *out, const int rank,
-                      const dim_vector& dv)
+               const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = fftw_planner::create_plan (FFTW_FORWARD, rank, dv,
                                              1, 1, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
@@ -960,17 +960,17 @@ namespace octave
                       reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
                       reinterpret_cast<fftw_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifftNd (const Complex *in, Complex *out, const int rank,
-                       const dim_vector& dv)
+                const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = fftw_planner::create_plan (FFTW_BACKWARD, rank, dv,
                                              1, 1, dist, in, out);
     fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
@@ -984,17 +984,17 @@ namespace octave
     for (size_t i = 0; i < npts; i++)
       out[i] /= scale;
 
     return 0;
   }
 
   int
   fftw::fft (const float *in, FloatComplex *out, size_t npts,
-                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+             size_t nsamples, octave_idx_type stride, octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = float_fftw_planner::create_plan (1, dv, nsamples, stride,
                                                    dist, in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
 
@@ -1005,17 +1005,17 @@ namespace octave
 
     convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
     return 0;
   }
 
   int
   fftw::fft (const FloatComplex *in, FloatComplex *out, size_t npts,
-                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+             size_t nsamples, octave_idx_type stride, octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = float_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
                                                    nsamples, stride, dist,
                                                    in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
@@ -1024,18 +1024,18 @@ namespace octave
                        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
                        reinterpret_cast<fftwf_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
-                     size_t nsamples, octave_idx_type stride,
-                     octave_idx_type dist)
+              size_t nsamples, octave_idx_type stride,
+              octave_idx_type dist)
   {
     dist = (dist < 0 ? npts : dist);
 
     dim_vector dv (npts, 1);
     void *vplan = float_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
                                                    nsamples, stride, dist,
                                                    in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
@@ -1049,17 +1049,17 @@ namespace octave
       for (size_t i = 0; i < npts; i++)
         out[i*stride + j*dist] /= scale;
 
     return 0;
   }
 
   int
   fftw::fftNd (const float *in, FloatComplex *out, const int rank,
-                      const dim_vector& dv)
+               const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     // Fool with the position of the start of the output matrix, so that
     // creating other half of the matrix won't cause cache problems.
 
@@ -1076,17 +1076,17 @@ namespace octave
 
     convert_packcomplex_Nd (out, dv);
 
     return 0;
   }
 
   int
   fftw::fftNd (const FloatComplex *in, FloatComplex *out, const int rank,
-                      const dim_vector& dv)
+               const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = float_fftw_planner::create_plan (FFTW_FORWARD, rank, dv,
                                                    1, 1, dist, in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
@@ -1095,17 +1095,17 @@ namespace octave
                        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
                        reinterpret_cast<fftwf_complex *> (out));
 
     return 0;
   }
 
   int
   fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank,
-                       const dim_vector& dv)
+                const dim_vector& dv)
   {
     octave_idx_type dist = 1;
     for (int i = 0; i < rank; i++)
       dist *= dv(i);
 
     void *vplan = float_fftw_planner::create_plan (FFTW_BACKWARD, rank, dv,
                                                    1, 1, dist, in, out);
     fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -60,31 +60,31 @@ namespace octave
       PATIENT,
       EXHAUSTIVE,
       HYBRID
     };
 
     static bool instance_ok (void);
 
     static void *
-      create_plan (int dir, const int rank, const dim_vector& dims,
-                   octave_idx_type howmany, octave_idx_type stride,
-                   octave_idx_type dist, const Complex *in,
-                   Complex *out)
+    create_plan (int dir, const int rank, const dim_vector& dims,
+                 octave_idx_type howmany, octave_idx_type stride,
+                 octave_idx_type dist, const Complex *in,
+                 Complex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                     dist, in, out)
         : nullptr;
     }
 
     static void *
-      create_plan (const int rank, const dim_vector& dims,
-                   octave_idx_type howmany, octave_idx_type stride,
-                   octave_idx_type dist, const double *in, Complex *out)
+    create_plan (const int rank, const dim_vector& dims,
+                 octave_idx_type howmany, octave_idx_type stride,
+                 octave_idx_type dist, const double *in, Complex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (rank, dims, howmany, stride, dist,
                                     in, out)
         : nullptr;
     }
 
     static FftwMethod method (void)
@@ -206,31 +206,31 @@ namespace octave
       PATIENT,
       EXHAUSTIVE,
       HYBRID
     };
 
     static bool instance_ok (void);
 
     static void *
-      create_plan (int dir, const int rank, const dim_vector& dims,
-                   octave_idx_type howmany, octave_idx_type stride,
-                   octave_idx_type dist, const FloatComplex *in,
-                   FloatComplex *out)
+    create_plan (int dir, const int rank, const dim_vector& dims,
+                 octave_idx_type howmany, octave_idx_type stride,
+                 octave_idx_type dist, const FloatComplex *in,
+                 FloatComplex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                     dist, in, out)
         : nullptr;
     }
 
     static void *
-      create_plan (const int rank, const dim_vector& dims,
-                   octave_idx_type howmany, octave_idx_type stride,
-                   octave_idx_type dist, const float *in, FloatComplex *out)
+    create_plan (const int rank, const dim_vector& dims,
+                 octave_idx_type howmany, octave_idx_type stride,
+                 octave_idx_type dist, const float *in, FloatComplex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (rank, dims, howmany, stride, dist,
                                     in, out)
         : nullptr;
     }
 
     static FftwMethod method (void)
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -163,21 +163,21 @@ namespace octave
       file_stat fs (file);
 
       return fs ? fs.is_newer (time) : -1;
     }
 
     // Private stuff:
 
     file_stat::file_stat (const std::string& n, bool fl)
-        : base_file_stat (), file_name (n), follow_links (fl)
-      {
-        if (! file_name.empty ())
-          update_internal ();
-      }
+      : base_file_stat (), file_name (n), follow_links (fl)
+    {
+      if (! file_name.empty ())
+        update_internal ();
+    }
 
     file_stat::~file_stat () { }
 
     void
     file_stat::update_internal (bool force)
     {
       if (! initialized || force)
         {
diff --git a/liboctave/system/lo-sysinfo.cc b/liboctave/system/lo-sysinfo.cc
--- a/liboctave/system/lo-sysinfo.cc
+++ b/liboctave/system/lo-sysinfo.cc
@@ -48,17 +48,17 @@ namespace octave
 
       std::string retval;
 
       // Check for functions that are specific to certain BLAS implementations.
 
       // FlexiBLAS
       typedef void (*flexi_f_type) (int*, int*, int*);
       flexi_f_type flexi_f_ptr = reinterpret_cast<flexi_f_type>
-        (dyn_libs.search ("flexiblas_get_version"));
+                                 (dyn_libs.search ("flexiblas_get_version"));
 
       if (flexi_f_ptr)
         {
           int v_major = 0;
           int v_minor = 0;
           int v_patch = 0;
           flexi_f_ptr (&v_major, &v_minor, &v_patch);
 
@@ -70,17 +70,17 @@ namespace octave
             retval += "\n";
 
           retval += s.str ();
         }
 
       // OpenBLAS
       typedef char * (*open_fcn_type) (void);
       open_fcn_type open_f_ptr = reinterpret_cast<open_fcn_type>
-        (dyn_libs.search ("openblas_get_config"));
+                                 (dyn_libs.search ("openblas_get_config"));
 
       if (open_f_ptr)
         {
           if (! retval.empty ())
             retval += "\n";
 
           retval += "OpenBLAS (config: " + std::string (open_f_ptr ()) + ")";
         }
@@ -103,17 +103,17 @@ namespace octave
             retval += "\n";
 
           retval += "ATLAS";
         }
 
       // ACML
       typedef void (*acml_f_type) (int*, int*, int*);
       acml_f_type acml_f_ptr = reinterpret_cast<acml_f_type>
-        (dyn_libs.search ("acmlversion"));
+                               (dyn_libs.search ("acmlversion"));
 
       if (acml_f_ptr)
         {
           int v_major = 0;
           int v_minor = 0;
           int v_patch = 0;
           acml_f_ptr (&v_major, &v_minor, &v_patch);
 
@@ -125,17 +125,17 @@ namespace octave
             retval += "\n";
 
           retval += s.str ();
         }
 
       // Intel MKL
       typedef void (*mkl_f_type) (char*, int);
       mkl_f_type mkl_f_ptr = reinterpret_cast<mkl_f_type>
-        (dyn_libs.search ("mkl_get_version_string"));
+                             (dyn_libs.search ("mkl_get_version_string"));
 
       if (mkl_f_ptr)
         {
           char buf[198];
           int len = 198;
           mkl_f_ptr (buf, len);
 
           if (! retval.empty ())
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -242,17 +242,18 @@ namespace octave
       method_arg2_elem operator = (const method_arg2_elem&);
     };
 
     /// An element for calling a member function with three arguments
     template <class T, class A, class B, class C>
     class method_arg3_elem : public elem
     {
     public:
-      method_arg3_elem (T *obj, void (T::*method) (const A&, const B&, const C&),
+      method_arg3_elem (T *obj,
+                        void (T::*method) (const A&, const B&, const C&),
                         const A& arg_a, const B& arg_b, const C& arg_c)
         : e_obj (obj), e_method (method),
           e_arg_a (arg_a), e_arg_b (arg_b), e_arg_c (arg_c)
       { }
 
       void run (void) { (e_obj->*e_method) (e_arg_a, e_arg_b, e_arg_c); }
 
     private:
@@ -270,23 +271,26 @@ namespace octave
       method_arg3_elem operator = (const method_arg3_elem&);
     };
 
     /// An element for calling a member function with three arguments
     template <class T, class A, class B, class C, class D>
     class method_arg4_elem : public elem
     {
     public:
-      method_arg4_elem (T *obj, void (T::*method) (const A&, const B&, const C&, const D&),
-                        const A& arg_a, const B& arg_b, const C& arg_c, const D& arg_d)
+      method_arg4_elem (T *obj,
+                        void (T::*method) (const A&, const B&, const C&, const D&),
+                        const A& arg_a, const B& arg_b, const C& arg_c,
+                        const D& arg_d)
         : e_obj (obj), e_method (method),
           e_arg_a (arg_a), e_arg_b (arg_b), e_arg_c (arg_c), e_arg_d (arg_d)
       { }
 
-      void run (void) {
+      void run (void)
+      {
         (e_obj->*e_method) (e_arg_a, e_arg_b, e_arg_c, e_arg_d);
       }
 
     private:
 
       T *e_obj;
       void (T::*e_method) (const A&, const B&, const C&, const D&);
       A e_arg_a;
diff --git a/liboctave/util/f77-fcn.h b/liboctave/util/f77-fcn.h
--- a/liboctave/util/f77-fcn.h
+++ b/liboctave/util/f77-fcn.h
@@ -158,17 +158,17 @@ typedef union
     unsigned off : 6;
     unsigned len : 26;
     unsigned add : 32;
   } mask;
 } octave_cray_descriptor;
 
 typedef void *octave_cray_ftn_ch_dsc;
 
- #if defined (__cplusplus)
+#if defined (__cplusplus)
 #  define OCTAVE_F77_FCN_INLINE inline
 #else
 #  define OCTAVE_F77_FCN_INLINE
 #endif
 
 static OCTAVE_F77_FCN_INLINE octave_cray_ftn_ch_dsc
 octave_make_cray_ftn_ch_dsc (char *ptr_arg, unsigned long len_arg)
 {
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -215,17 +215,17 @@ namespace octave
             buf << pattern.substr (pos, new_pos - pos) << "(?";
             pos = new_pos + 2;
           }
 
       }
 
     buf << pattern.substr (pos);
 
-    // Replace NULLs with escape sequence because conversion function c_str() 
+    // Replace NULLs with escape sequence because conversion function c_str()
     // will terminate string early at embedded NULLs.
     std::string buf_str = buf.str ();
     while ((pos = buf_str.find ('\0')) != std::string::npos)
       buf_str.replace (pos, 1, "\\000");
 
     const char *err;
     int erroffset;
 
diff --git a/liboctave/util/oct-mutex.h b/liboctave/util/oct-mutex.h
--- a/liboctave/util/oct-mutex.h
+++ b/liboctave/util/oct-mutex.h
@@ -55,39 +55,39 @@ namespace octave
   OCTAVE_API
   mutex
   {
   public:
     mutex (void);
 
     mutex (const mutex& m)
       : rep (m.rep)
-      {
-        rep->count++;
-      }
+    {
+      rep->count++;
+    }
 
     ~mutex (void)
-      {
-        if (--rep->count == 0)
-          delete rep;
-      }
+    {
+      if (--rep->count == 0)
+        delete rep;
+    }
 
     mutex& operator = (const mutex& m)
-      {
-        if (rep != m.rep)
-          {
-            if (--rep->count == 0)
-              delete rep;
+    {
+      if (rep != m.rep)
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-            rep = m.rep;
-            rep->count++;
-          }
+          rep = m.rep;
+          rep->count++;
+        }
 
-        return *this;
-      }
+      return *this;
+    }
 
     void lock (void)
     {
       rep->lock ();
     }
 
     void unlock (void)
     {
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -450,26 +450,26 @@ namespace octave
     while (((size_lib*lib_num) < bytes_all_libs) && ii++ < 3)
       {
         lib_num = bytes_all_libs / size_lib;
         h_libs = static_cast<HMODULE *> (realloc (h_libs, bytes_all_libs));
         got_libs = EnumProcessModules (proc, h_libs, bytes_all_libs,
                                        &bytes_all_libs);
       }
 
-     if (got_libs)
+    if (got_libs)
       {
         for (size_t i = 0; i < (bytes_all_libs / size_lib); i++)
           {
-              // Check for function in library.
-              function = reinterpret_cast<void *>
-                           (GetProcAddress (h_libs[i], sym_name.c_str ()));
+            // Check for function in library.
+            function = reinterpret_cast<void *>
+                       (GetProcAddress (h_libs[i], sym_name.c_str ()));
 
-              if (function)
-                break;
+            if (function)
+              break;
           }
       }
 
     // Release the handle to the process.
     CloseHandle (proc);
 
     return function;
   }
