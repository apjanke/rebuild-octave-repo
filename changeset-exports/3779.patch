# HG changeset patch
# User jwe
# Date 981521281 0
#      Wed Feb 07 04:48:01 2001 +0000
# Node ID 3001e15555e93fae93c2e4215a2ad55b8a0a872e
# Parent  594ead75454261b8ee1bc119592930cae698dd4f
[project @ 2001-02-07 04:47:51 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2001-02-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* readline: Update to new version (4.2-beta1).
+
 2001-02-05  Mumit Khan  <khan@nanotech.wisc.edu>
 
 	* configure.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): New variables.
 	* Makeconf.in (TEMPLATE_AR, TEMPLATE_ARFLAGS): Likewise.
 	
 	* configure.in (XTRA_CXXFLAGS): Use -fno-implicit templates for
 	pre-gcc3 compilers. Remove -fno-rtti and -fno-exceptions.
 	(DEPEND_FLAGS, DEPEND_EXTRA_SED_PATTERN): New macros.
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,21 @@
 2001-02-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* oct-rl-edit.c (octave_rl_newline): Call rl_newline with two args.
+	(octave_rl_set_name): call rl_re_read_init_file with two args.
+	(octave_rl_read_init_file): Ditto.
+	(octave_rl_clear_undo_list): Call rl_free_undo_list, not
+	free_undo_list.
+	(octave_rl_completion_matches): Call rl_completion_matches, not
+	completion_matches.
+	(octave_rl_enable_paren_matching): New function.
+	(octave_rl_set_blink_matching_paren_flag): Delete.
+	(octave_rl_get_blink_matching_paren_flag): Delete.
+
 	* lo-mappers.h, lo-mappers.cc (log10 (const Complex&),
 	tanh (const Complex&)): Declare and define if not 
 	CXX_ISO_COMPLIANT_LIBRARY.
 
 2001-02-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lo-mappers.h (tanh (const Complex&)): Only declare if not
 	CXX_ISO_COMPLIANT_LIBRARY.
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -261,17 +261,17 @@ void
 gnu_readline::do_restore_terminal_state (void)
 {
   ::octave_rl_restore_terminal_state ();
 }
 
 void
 gnu_readline::do_blink_matching_paren (bool flag)
 {
-  ::octave_set_rl_blink_matching_paren_flag (flag ? 1 : 0);
+  ::octave_rl_enable_paren_matching (flag ? 1 : 0);
 }
 
 void
 gnu_readline::do_set_basic_quote_characters (const std::string& s)
 {
   ::octave_rl_set_basic_quote_characters (s.c_str ());
 }
 
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -28,46 +28,36 @@ Software Foundation, 59 Temple Place - S
 
 #include <stdio.h>
 #include <stdlib.h>
 
 #include <readline/readline.h>
 
 #include "oct-rl-edit.h"
 
-/* It would be nice if readline.h declared these, I think. */
-
-extern int rl_blink_matching_paren;
-
-extern int screenheight;
-
-extern int screenwidth;
-
 int
 octave_rl_screen_height (void)
 {
-  return screenheight;
+  int rows, cols;
+  rl_get_screen_size (&rows, &cols);
+  return rows;
 }
 
 int
 octave_rl_screen_width (void)
 {
-  return screenwidth;
+  int rows, cols;
+  rl_get_screen_size (&rows, &cols);
+  return cols;
 }
 
 void
-octave_set_rl_blink_matching_paren_flag (int val)
+octave_rl_enable_paren_matching (int val)
 {
-  rl_blink_matching_paren = val;
-}
-
-int
-octave_get_rl_blink_matching_paren_flag (void)
-{
-  return rl_blink_matching_paren;
+  rl_variable_bind ("blink-matching-paren", val ? "1" : "0");
 }
 
 void
 octave_rl_clear_screen (void)
 {
   extern void _rl_clear_screen ();
 
   _rl_clear_screen ();
@@ -90,25 +80,25 @@ void
 octave_rl_insert_text (const char *s)
 {
   rl_insert_text (s);
 }
 
 void
 octave_rl_newline (void)
 {
-  rl_newline ();
+  rl_newline (1, '\n');
 }
 
 void
 octave_rl_clear_undo_list (void)
 {
   if (rl_undo_list)
     {
-      free_undo_list ();
+      rl_free_undo_list ();
 
       rl_undo_list = 0;
     }
 }
 
 void
 octave_rl_set_name (const char *n)
 {
@@ -125,17 +115,17 @@ octave_rl_set_name (const char *n)
   strcpy (nm, n);
 
   rl_readline_name = nm;
 
   /* Since we've already called rl_initialize, we need to re-read the
      init file to take advantage of the conditional parsing feature
      based on rl_readline_name; */
 
-  rl_re_read_init_file ();
+  rl_re_read_init_file (0, 0);
 }
 
 char *
 octave_rl_readline (const char *prompt)
 {
   return readline (prompt);
 }
 
@@ -164,17 +154,17 @@ octave_rl_get_output_stream (void)
 }
 
 void
 octave_rl_read_init_file (const char *f)
 {
   if (f && *f)
     rl_read_init_file (f);
   else
-    rl_re_read_init_file ();
+    rl_re_read_init_file (0, 0);
 }
 
 void
 octave_rl_set_basic_quote_characters (const char *s)
 {
   static char *ss = 0;
 
   if (ss)
@@ -226,17 +216,17 @@ rl_event_hook_fcn_ptr
 octave_rl_get_event_hook (void)
 {
   return (rl_event_hook_fcn_ptr) rl_event_hook;
 }
 
 char **
 octave_rl_completion_matches (const char *text, rl_completer_fcn_ptr f)
 {
-  return completion_matches (text, f);
+  return rl_completion_matches (text, f);
 }
 
 char
 octave_rl_prompt_start_ignore (void)
 {
   return RL_PROMPT_START_IGNORE;
 }
 
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
--- a/liboctave/oct-rl-edit.h
+++ b/liboctave/oct-rl-edit.h
@@ -37,19 +37,17 @@ typedef char * (*rl_completer_fcn_ptr) (
 extern "C"
 {
 #endif
 
 extern int octave_rl_screen_height (void);
 
 extern int octave_rl_screen_width (void);
 
-extern void octave_set_rl_blink_matching_paren_flag (int);
-
-extern int octave_get_rl_blink_matching_paren_flag (void);
+extern void octave_rl_enable_paren_matching (int);
 
 extern void octave_rl_init (void);
 
 extern void octave_rl_clear_screen (void);
 
 extern void octave_rl_resize_terminal (void);
 
 extern void octave_rl_restore_terminal_state (void);
diff --git a/readline/ChangeLog b/readline/ChangeLog
--- a/readline/ChangeLog
+++ b/readline/ChangeLog
@@ -1,8 +1,17 @@
+2001-02-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* terminal.c (rl_get_screen_size): New function.
+	* readline.h: Provide declaration.
+
+	* Makefile.in (install, uninstall): For Octave, do nothing.
+
+	* Update to readline-4.2-beta1.
+
 2000-02-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* support/config.guess: Update to latest from subversions.gnu.org.
 	* support/config.sub: Likewise.  Recognize sv1-cray as a basic_machine.
 
 2000-01-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* acconfig.h: Use #undef GWINSZ_IN_SYS_IOCTL, not
diff --git a/readline/MANIFEST b/readline/MANIFEST
--- a/readline/MANIFEST
+++ b/readline/MANIFEST
@@ -1,83 +1,116 @@
 #
 # Master distribution manifest for the standalone readline distribution
 #
 doc		d
 examples	d
 support		d
+shlib		d
 COPYING		f
 README		f
 MANIFEST	f
 INSTALL		f
+CHANGELOG	f
+CHANGES		f
+USAGE		f
 aclocal.m4	f
-acconfig.h	f
 config.h.in	f
 configure	f
 configure.in	f
 Makefile.in	f
-ChangeLog	f
 ansi_stdlib.h	f
 chardefs.h	f
 history.h	f
 histlib.h	f
 keymaps.h	f
 posixdir.h	f
 posixjmp.h	f
 posixstat.h	f
 readline.h	f
 rlconf.h	f
 rldefs.h	f
+rlprivate.h	f
+rlshell.h	f
+rlstdc.h	f
 rltty.h		f
+rltypedefs.h	f
+rlwinsize.h	f
 tcap.h		f
 tilde.h		f
+xmalloc.h	f
 bind.c		f
+compat.c	f
 complete.c	f
 display.c	f
 emacs_keymap.c	f
 funmap.c	f
 input.c		f
 isearch.c	f
 keymaps.c	f
 kill.c		f
 macro.c		f
 nls.c		f
 parens.c	f
 readline.c	f
 rltty.c		f
+savestring.c	f
 search.c	f
 shell.c		f
 signals.c	f
 terminal.c	f
 tilde.c		f
 undo.c		f
 util.c		f
 vi_keymap.c	f
 vi_mode.c	f
 callback.c	f
 xmalloc.c	f
 history.c	f
 histexpand.c	f
 histfile.c	f
 histsearch.c	f
+shlib/Makefile.in	f
 support/config.guess	f
 support/config.sub	f
 support/install.sh	f
 support/mkdirs		f
 support/mkdist		f
+support/shobj-conf	f
+support/shlib-install	f
 doc/Makefile.in		f
 doc/texinfo.tex		f
+doc/manvers.texinfo	f
 doc/rlman.texinfo	f
 doc/rltech.texinfo	f
 doc/rluser.texinfo	f
+doc/rluserman.texinfo	f
 doc/hist.texinfo	f
 doc/hstech.texinfo	f
 doc/hsuser.texinfo	f
 doc/readline.3		f
 doc/texi2dvi		f
 doc/texi2html		f
 examples/Makefile.in	f
+examples/excallback.c	f
 examples/fileman.c	f
 examples/manexamp.c	f
+examples/rlfe.c		f
 examples/rltest.c	f
 examples/rl.c		f
+examples/rlversion.c	f
 examples/histexamp.c	f
 examples/Inputrc	f
+# formatted documentation, from MANIFEST.doc
+doc/readline.ps		f
+doc/history.ps		f
+doc/rluserman.ps	f
+doc/readline.dvi	f
+doc/history.dvi		f
+doc/rluserman.dvi	f
+doc/readline.info	f
+doc/history.info	f
+doc/rluserman.info	f
+doc/readline.html	f
+doc/history.html	f
+doc/rluserman.html	f
+doc/readline.0		f
+doc/readline_3.ps	f
diff --git a/readline/Makefile.in b/readline/Makefile.in
--- a/readline/Makefile.in
+++ b/readline/Makefile.in
@@ -16,153 +16,141 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 RL_LIBRARY_VERSION = @LIBVERSION@
 RL_LIBRARY_NAME = readline
 
 srcdir = @srcdir@
 VPATH = .:@srcdir@
 top_srcdir = @top_srcdir@
-BUILD_DIR = .
+BUILD_DIR = @BUILD_DIR@
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 CC = @CC@
-LD = ld			# needed when building shared libraries
 RANLIB = @RANLIB@
-AR = ar
+AR = @AR@
+ARFLAGS = @ARFLAGS@
 RM = rm -f
 CP = cp
 MV = mv
 
+@SET_MAKE@
+SHELL = @MAKE_SHELL@
+
 prefix = @prefix@
 exec_prefix = @exec_prefix@
 
 bindir = @bindir@
 libdir = @libdir@
 mandir = @mandir@
 includedir = @includedir@
 
 infodir = @infodir@
 
 man3dir = $(mandir)/man3
 
-SHELL = /bin/sh
-
 # Programs to make tags files.
 ETAGS = etags -tw
 CTAGS = ctags -tw
 
 CFLAGS = @CFLAGS@
 LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
 CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@ @CFLAGS@
 
 DEFS = @DEFS@
 LOCAL_DEFS = @LOCAL_DEFS@
 
+TERMCAP_LIB = @TERMCAP_LIB@
+
 # For libraries which include headers from other libraries.
 INCLUDES = -I. -I$(srcdir) -I$(includedir)
 
-CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)
+XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES)
+CCFLAGS = $(XCCFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)
 
-# these two options need tweaking for compiler/OS versions other than gcc
-# and SunOS4
-PICFLAG=        -fpic    # -pic for some versions of cc
-SHLIB_OPTS=	-assert pure-text -ldl	# -Bshareable for some versions of gcc
-
-MAJOR=		3
-# shared library systems like SVR4's do not use minor versions
-MINOR=		.0
-
-.SUFFIXES:	.so
+# could add -Werror here
+GCC_LINT_FLAGS = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-qual \
+		 -Wwrite-strings -Wstrict-prototypes \
+		 -Wmissing-prototypes -Wno-implicit
+GCC_LINT_CFLAGS = $(XCCFLAGS) $(GCC_LINT_FLAGS) @CFLAGS@ @LOCAL_CFLAGS@
 
 .c.o:
+	${RM} $@
 	$(CC) -c $(CCFLAGS) $<
 
-.c.so:
-	-mv $*.o z$*.o
-	$(CC) -c $(PICFLAG) $(CCFLAGS) $< 
-	mv $*.o $@
-	-mv z$*.o $*.o
-
 # The name of the main library target.
 LIBRARY_NAME = libreadline.a
-SHARED_READLINE = libreadline.so.$(MAJOR)$(MINOR)
-SHARED_HISTORY = libhistory.so.$(MAJOR)$(MINOR)
-SHARED_LIBS = $(SHARED_READLINE) $(SHARED_HISTORY)
+STATIC_LIBS = libreadline.a libhistory.a
 
 # The C code source files for this library.
 CSOURCES = $(srcdir)/readline.c $(srcdir)/funmap.c $(srcdir)/keymaps.c \
 	   $(srcdir)/vi_mode.c $(srcdir)/parens.c $(srcdir)/rltty.c \
 	   $(srcdir)/complete.c $(srcdir)/bind.c $(srcdir)/isearch.c \
 	   $(srcdir)/display.c $(srcdir)/signals.c $(srcdir)/emacs_keymap.c \
 	   $(srcdir)/vi_keymap.c $(srcdir)/util.c $(srcdir)/kill.c \
 	   $(srcdir)/undo.c $(srcdir)/macro.c $(srcdir)/input.c \
 	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
 	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
 	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
-	   $(srcdir)/shell.c $(srcdir)/tilde.c
+	   $(srcdir)/shell.c $(srcdir)/savestring.c $(srcdir)/tilde.c \
+	   $(srcdir)/compat.c
 
 # The header files for this library.
 HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
 	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
-	   ansi_stdlib.h tcap.h
+	   ansi_stdlib.h tcap.h rlstdc.h xmalloc.h rlprivate.h rlshell.h \
+	   rltypedefs.h
 
-HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o
+HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o 
 TILDEOBJ = tilde.o
 OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
 	  rltty.o complete.o bind.o isearch.o display.o signals.o \
 	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
-	  nls.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)
-
-SHARED_HISTOBJ = history.so histexpand.so histfile.so histsearch.so shell.so
-SHARED_TILDEOBJ = tilde.so
-SHARED_OBJ = readline.so vi_mode.so funmap.so keymaps.so parens.so search.so \
-	  rltty.so complete.so bind.so isearch.so display.so signals.so \
-	  util.so kill.so undo.so macro.so input.so callback.so terminal.so \
-	  nls.so xmalloc.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ)
+	  nls.o compat.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)
 
 # The texinfo files which document this library.
 DOCSOURCE = doc/rlman.texinfo doc/rltech.texinfo doc/rluser.texinfo
 DOCOBJECT = doc/readline.dvi
 DOCSUPPORT = doc/Makefile
 DOCUMENTATION = $(DOCSOURCE) $(DOCOBJECT) $(DOCSUPPORT)
 
-CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile
+CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile shlib/Makefile
+CREATED_CONFIGURE = config.status config.h config.cache config.log \
+		    stamp-config stamp-h
+CREATED_TAGS = TAGS tags
 
-INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h
+INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \
+		    rlstdc.h rlconf.h rltypedefs.h
 
 ##########################################################################
 
-all: libreadline.a libhistory.a
-shared: $(SHARED_LIBS)
+all: static
+
+everything: static shared examples
+
+static: $(STATIC_LIBS)
 
 libreadline.a: $(OBJECTS)
 	$(RM) $@
-	$(AR) cr $@ $(OBJECTS)
+	$(AR) $(ARFLAGS) $@ $(OBJECTS)
 	-test -n "$(RANLIB)" && $(RANLIB) $@
 
 libhistory.a: $(HISTOBJ) xmalloc.o
 	$(RM) $@
-	$(AR) cr $@ $(HISTOBJ) xmalloc.o
+	$(AR) $(ARFLAGS) $@ $(HISTOBJ) xmalloc.o
 	-test -n "$(RANLIB)" && $(RANLIB) $@
 
-$(SHARED_READLINE):	$(SHARED_OBJ)
-	$(RM) $@
-	$(LD) ${SHLIB_OPTS} -o $@ $(SHARED_OBJ)
+readline: $(OBJECTS) readline.h rldefs.h chardefs.h ./libreadline.a
+	$(CC) $(CCFLAGS) -o $@ ./examples/rl.c ./libreadline.a ${TERMCAP_LIB}
 
-$(SHARED_HISTORY):	$(SHARED_HISTOBJ) xmalloc.so
-	$(RM) $@
-	$(LD) ${SHLIB_OPTS} -o $@ $(SHARED_HISTOBJ) xmalloc.so
-
-readline: $(OBJECTS) readline.h rldefs.h chardefs.h
-	$(CC) $(CCFLAGS) -o $@ ./examples/rl.c ./libreadline.a -ltermcap
+lint:	force
+	$(MAKE) $(MFLAGS) CCFLAGS='$(GCC_LINT_CFLAGS)' static
 
 Makefile makefile: config.status $(srcdir)/Makefile.in
 	CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) ./config.status
 
 Makefiles makefiles: config.status $(srcdir)/Makefile.in
 	@for mf in $(CREATED_MAKEFILES); do \
 		CONFIG_FILES=$$mf CONFIG_HEADERS= $(SHELL) ./config.status ; \
 	done
@@ -171,282 +159,310 @@ config.status: configure
 	$(SHELL) ./config.status --recheck
 
 config.h:	stamp-h
 
 stamp-h: config.status $(srcdir)/config.h.in
 	CONFIG_FILES= CONFIG_HEADERS=config.h ./config.status
 	echo > $@
 
-$(srcdir)/configure: $(srcdir)/configure.in	## Comment-me-out in distribution
-	cd $(srcdir) && autoconf	## Comment-me-out in distribution
+#$(srcdir)/configure: $(srcdir)/configure.in	## Comment-me-out in distribution
+#	cd $(srcdir) && autoconf	## Comment-me-out in distribution
+
+
+shared:	force
+	-test -d shlib || mkdir shlib
+	-( cd shlib ; ${MAKE} ${MFLAGS} all )
 
 documentation: force
 	-test -d doc || mkdir doc
 	-( cd doc && $(MAKE) $(MFLAGS) )
 
+examples: force
+	-test -d examples || mkdir examples
+	-(cd examples && ${MAKE} ${MFLAGS} all )
+
 force:
 
-install:
+install-headers: installdirs ${INSTALLED_HEADERS}
+	for f in ${INSTALLED_HEADERS}; do \
+		$(INSTALL_DATA) $(srcdir)/$$f $(includedir)/readline ; \
+	done
 
-#install: installdirs libreadline.a
-#	for f in ${INSTALLED_HEADERS}; do \
-#		$(INSTALL_DATA) $(srcdir)/$$f $(includedir)/readline ; \
-#	done
+uninstall-headers:
+	-test -n "$(includedir)" && cd $(includedir)/readline && \
+		${RM} ${INSTALLED_HEADERS}
+
+maybe-uninstall-headers: uninstall-headers
+
+# For Octave, do nothing for these.
+
+install uninstall:
+
+#install: installdirs $(STATIC_LIBS) install-headers
 #	-$(MV) $(libdir)/libreadline.a $(libdir)/libreadline.old
 #	$(INSTALL_DATA) libreadline.a $(libdir)/libreadline.a
-#	-test -n "$(RANLIB)" && -$(RANLIB) -t $(libdir)/libreadline.a
+#	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libreadline.a
+#	-$(MV) $(libdir)/libhistory.a $(libdir)/libhistory.old
+#	$(INSTALL_DATA) libhistory.a $(libdir)/libhistory.a
+#	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libhistory.a
 #	-( if test -d doc ; then \
 #		cd doc && \
-#		${MAKE} ${MFLAGS} infodir=$(infodir) INSTALL_DATA=$(INSTALL_DATA) $@; \
+#		${MAKE} ${MFLAGS} infodir=$(infodir) $@; \
 #	  fi )
 
 installdirs: $(srcdir)/support/mkdirs
 	-$(SHELL) $(srcdir)/support/mkdirs $(includedir) \
 		$(includedir)/readline $(libdir) $(infodir) $(man3dir)
 
-uninstall:
+#uninstall: uninstall-headers
+#	-test -n "$(libdir)" && cd $(libdir) && \
+#		${RM} libreadline.a libreadline.old libhistory.a libhistory.old $(SHARED_LIBS)
 
-#uninstall:
-#	-test -n "$(includedir)" && cd $(includedir)/readline && \
-#		${RM} ${INSTALLED_HEADERS}
-#	-test -n "$(libdir)" && cd $(libdir) && \
-#		${RM} libreadline.a libreadline.old $(SHARED_LIBS)
+install-shared: installdirs install-headers shared
+	-( cd shlib ; ${MAKE} ${MFLAGS} install )
+
+uninstall-shared: maybe-uninstall-headers
+	-( cd shlib; ${MAKE} ${MFLAGS} uninstall )
 
 TAGS:	force
 	$(ETAGS) $(CSOURCES) $(HSOURCES)
 
 tags:	force
 	$(CTAGS) $(CSOURCES) $(HSOURCES)
 
 clean:	force
-	$(RM) $(OBJECTS) *.a
-	$(RM) $(SHARED_OBJ) $(SHARED_LIBS)
+	$(RM) $(OBJECTS) $(STATIC_LIBS)
+	$(RM) readline readline.exe
+	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
 	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+	-( cd examples && $(MAKE) $(MFLAGS) $@ )
 
 mostlyclean: clean
+	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
 	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+	-( cd examples && $(MAKE) $(MFLAGS) $@ )
 
 distclean maintainer-clean: clean
+	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
 	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+	-( cd examples && $(MAKE) $(MFLAGS) $@ )
 	$(RM) Makefile
-	$(RM) config.status config.h config.cache config.log 
-	$(RM) stamp-config stamp-h
-	$(RM) TAGS tags
+	$(RM) $(CREATED_CONFIGURE)
+	$(RM) $(CREATED_TAGS)
 
 info dvi:
 	-( cd doc && $(MAKE) $(MFLAGS) $@ )
 
 install-info:
 check:
 installcheck:
 
 dist:   force
 	@echo Readline distributions are created using $(srcdir)/support/mkdist.
 	@echo Here is a sample of the necessary commands:
-	@echo bash $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r $(RL_LIBRARY_NAME)-$(RL_LIBRARY_VERSION)
+	@echo bash $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r $(RL_LIBRARY_NAME) $(RL_LIBRARY_VERSION)
 	@echo tar cf $(RL_LIBRARY_NAME)-${RL_LIBRARY_VERSION}.tar ${RL_LIBRARY_NAME}-$(RL_LIBRARY_VERSION)
 	@echo gzip $(RL_LIBRARY_NAME)-$(RL_LIBRARY_VERSION).tar
 
 # Tell versions [3.59,3.63) of GNU make not to export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
 
 # Dependencies
 bind.o: ansi_stdlib.h posixstat.h
 bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-bind.o: readline.h keymaps.h chardefs.h tilde.h
+bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 bind.o: history.h
 callback.o: rlconf.h
 callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-callback.o: readline.h keymaps.h chardefs.h tilde.h
+callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
+compat.o: rlstdc.h
 complete.o: ansi_stdlib.h posixdir.h posixstat.h
 complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-complete.o: readline.h keymaps.h chardefs.h tilde.h
+complete.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 display.o: ansi_stdlib.h posixstat.h
 display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 display.o: tcap.h
-display.o: readline.h keymaps.h chardefs.h tilde.h
-display.o: history.h
-funmap.o: readline.h keymaps.h chardefs.h tilde.h
-funmap.o: rlconf.h ansi_stdlib.h
+display.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+display.o: history.h rlstdc.h
+funmap.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+funmap.o: rlconf.h ansi_stdlib.h rlstdc.h
 funmap.o: ${BUILD_DIR}/config.h
 histexpand.o: ansi_stdlib.h
-histexpand.o: history.h histlib.h
+histexpand.o: history.h histlib.h rlstdc.h rltypedefs.h
 histexpand.o: ${BUILD_DIR}/config.h
 histfile.o: ansi_stdlib.h
-histfile.o: history.h histlib.h
+histfile.o: history.h histlib.h rlstdc.h rltypedefs.h
 histfile.o: ${BUILD_DIR}/config.h
 history.o: ansi_stdlib.h
-history.o: history.h histlib.h
+history.o: history.h histlib.h rlstdc.h rltypedefs.h
 history.o: ${BUILD_DIR}/config.h
 histsearch.o: ansi_stdlib.h
-histsearch.o: history.h histlib.h
+histsearch.o: history.h histlib.h rlstdc.h rltypedefs.h
 histsearch.o: ${BUILD_DIR}/config.h
 input.o: ansi_stdlib.h
 input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-input.o: readline.h keymaps.h chardefs.h tilde.h
+input.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-isearch.o: readline.h keymaps.h chardefs.h tilde.h
-isearch.o: ansi_stdlib.h history.h
+isearch.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+isearch.o: ansi_stdlib.h history.h rlstdc.h
 keymaps.o: emacs_keymap.c vi_keymap.c
-keymaps.o: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
-keymaps.o: readline.h keymaps.h chardefs.h tilde.h
-keymaps.o: ${BUILD_DIR}/config.h
+keymaps.o: keymaps.h rltypedefs.h chardefs.h rlconf.h ansi_stdlib.h
+keymaps.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+keymaps.o: ${BUILD_DIR}/config.h rlstdc.h
 kill.o: ansi_stdlib.h
 kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-kill.o: readline.h keymaps.h chardefs.h tilde.h
-kill.o: history.h
+kill.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+kill.o: history.h rlstdc.h
 macro.o: ansi_stdlib.h
 macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-macro.o: readline.h keymaps.h chardefs.h tilde.h
-macro.o: history.h
+macro.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+macro.o: history.h rlstdc.h
 nls.o: ansi_stdlib.h
 nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+nls.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h  
+nls.o: history.h rlstdc.h  
 parens.o: rlconf.h
 parens.o: ${BUILD_DIR}/config.h
-parens.o: readline.h keymaps.h chardefs.h tilde.h
-readline.o: readline.h keymaps.h chardefs.h tilde.h
+parens.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
+readline.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-readline.o: history.h
+readline.o: history.h rlstdc.h
 readline.o: posixstat.h ansi_stdlib.h posixjmp.h
 rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 rltty.o: rltty.h
-rltty.o: readline.h keymaps.h chardefs.h tilde.h
+rltty.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-search.o: readline.h keymaps.h chardefs.h tilde.h
-search.o: ansi_stdlib.h history.h
+search.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+search.o: ansi_stdlib.h history.h rlstdc.h
+shell.o: ${BUILD_DIR}/config.h
+shell.o: ansi_stdlib.h
 signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-signals.o: readline.h keymaps.h chardefs.h tilde.h
-signals.o: history.h
+signals.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+signals.o: history.h rlstdc.h
 terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 terminal.o: tcap.h
-terminal.o: readline.h keymaps.h chardefs.h tilde.h
-terminal.o: history.h
+terminal.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+terminal.o: history.h rlstdc.h
 tilde.o: ansi_stdlib.h
 tilde.o: ${BUILD_DIR}/config.h
 tilde.o: tilde.h
 undo.o: ansi_stdlib.h
 undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-undo.o: readline.h keymaps.h chardefs.h tilde.h
-undo.o: history.h
+undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+undo.o: history.h rlstdc.h
 util.o: posixjmp.h ansi_stdlib.h
 util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-util.o: readline.h keymaps.h chardefs.h tilde.h
+util.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-vi_mode.o: readline.h keymaps.h chardefs.h tilde.h
-vi_mode.o: history.h ansi_stdlib.h
+vi_mode.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
+vi_mode.o: history.h ansi_stdlib.h rlstdc.h
 xmalloc.o: ${BUILD_DIR}/config.h
 xmalloc.o: ansi_stdlib.h
 
-bind.so: ansi_stdlib.h posixstat.h
-bind.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-bind.so: readline.h keymaps.h chardefs.h tilde.h
-bind.so: history.h
-callback.so: rlconf.h
-callback.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-callback.so: readline.h keymaps.h chardefs.h tilde.h
-complete.so: ansi_stdlib.h posixdir.h posixstat.h
-complete.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-complete.so: readline.h keymaps.h chardefs.h tilde.h
-display.so: ansi_stdlib.h posixstat.h
-display.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-display.so: tcap.h
-display.so: readline.h keymaps.h chardefs.h tilde.h
-display.so: history.h
-funmap.so: readline.h keymaps.h chardefs.h tilde.h
-funmap.so: rlconf.h ansi_stdlib.h
-funmap.so: ${BUILD_DIR}/config.h
-histexpand.so: ansi_stdlib.h
-histexpand.so: history.h histlib.h
-histexpand.so: ${BUILD_DIR}/config.h
-histfile.so: ansi_stdlib.h
-histfile.so: history.h histlib.h
-histfile.so: ${BUILD_DIR}/config.h
-history.so: ansi_stdlib.h
-history.so: history.h histlib.h
-history.so: ${BUILD_DIR}/config.h
-histsearch.so: ansi_stdlib.h
-histsearch.so: history.h histlib.h
-histsearch.so: ${BUILD_DIR}/config.h
-input.so: ansi_stdlib.h
-input.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-input.so: readline.h keymaps.h chardefs.h tilde.h
-isearch.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-isearch.so: readline.h keymaps.h chardefs.h tilde.h
-isearch.so: ansi_stdlib.h history.h
-keymaps.so: emacs_keymap.c vi_keymap.c
-keymaps.so: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
-keymaps.so: readline.h keymaps.h chardefs.h tilde.h
-keymaps.so: ${BUILD_DIR}/config.h
-kill.so: ansi_stdlib.h
-kill.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-kill.so: readline.h keymaps.h chardefs.h tilde.h
-kill.so: history.h
-macro.so: ansi_stdlib.h
-macro.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-macro.so: readline.h keymaps.h chardefs.h tilde.h
-macro.so: history.h
-nls.so: ansi_stdlib.h
-nls.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-parens.so: rlconf.h
-parens.so: ${BUILD_DIR}/config.h
-parens.so: readline.h keymaps.h chardefs.h tilde.h
-readline.so: readline.h keymaps.h chardefs.h tilde.h
-readline.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-readline.so: history.h
-readline.so: posixstat.h ansi_stdlib.h posixjmp.h
-rltty.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-rltty.so: rltty.h
-rltty.so: readline.h keymaps.h chardefs.h tilde.h
-search.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-search.so: readline.h keymaps.h chardefs.h tilde.h
-search.so: ansi_stdlib.h history.h
-signals.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-signals.so: readline.h keymaps.h chardefs.h tilde.h
-signals.so: history.h
-terminal.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-terminal.so: tcap.h
-terminal.so: readline.h keymaps.h chardefs.h tilde.h
-terminal.so: history.h
-tilde.so: ansi_stdlib.h
-tilde.so: ${BUILD_DIR}/config.h
-tilde.so: tilde.h
-undo.so: ansi_stdlib.h
-undo.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-undo.so: readline.h keymaps.h chardefs.h tilde.h
-undo.so: history.h
-util.so: posixjmp.h ansi_stdlib.h
-util.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-util.so: readline.h keymaps.h chardefs.h tilde.h
-vi_mode.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-vi_mode.so: readline.h keymaps.h chardefs.h tilde.h
-vi_mode.so: history.h ansi_stdlib.h
-xmalloc.so: ${BUILD_DIR}/config.h
-xmalloc.so: ansi_stdlib.h
+bind.o: rlshell.h
+histfile.o: rlshell.h
+nls.o: rlshell.h
+readline.o: rlshell.h
+shell.o: rlshell.h
+terminal.o: rlshell.h
+histexpand.o: rlshell.h
+
+bind.o: rlprivate.h
+callback.o: rlprivate.h
+complete.o: rlprivate.h
+display.o: rlprivate.h
+input.o: rlprivate.h
+isearch.o: rlprivate.h
+kill.o: rlprivate.h
+macro.o: rlprivate.h
+nls.o: rlprivate.h   
+parens.o: rlprivate.h
+readline.o: rlprivate.h
+rltty.o: rlprivate.h 
+search.o: rlprivate.h
+signals.o: rlprivate.h
+terminal.o: rlprivate.h
+undo.o: rlprivate.h
+util.o: rlprivate.h
+vi_mode.o: rlprivate.h
+
+bind.o: xmalloc.h
+complete.o: xmalloc.h
+display.o: xmalloc.h
+funmap.o: xmalloc.h
+histexpand.o: xmalloc.h
+histfile.o: xmalloc.h
+history.o: xmalloc.h
+input.o: xmalloc.h
+isearch.o: xmalloc.h
+keymaps.o: xmalloc.h
+kill.o: xmalloc.h
+macro.o: xmalloc.h
+readline.o: xmalloc.h
+savestring.o: xmalloc.h
+search.o: xmalloc.h
+shell.o: xmalloc.h
+tilde.o: xmalloc.h
+tilde.o: xmalloc.h
+util.o: xmalloc.h
+vi_mode.o: xmalloc.h
 
-readline.so: $(srcdir)/readline.c
-vi_mode.so: $(srcdir)/vi_mode.c
-funmap.so: $(srcdir)/funmap.c
-keymaps.so: $(srcdir)/keymaps.c
-parens.so: $(srcdir)/parens.c
-search.so: $(srcdir)/search.c
-rltty.so: $(srcdir)/rltty.c
-complete.so: $(srcdir)/complete.c
-bind.so: $(srcdir)/bind.c
-isearch.so: $(srcdir)/isearch.c
-display.so: $(srcdir)/display.c
-signals.so: $(srcdir)/signals.c
-util.so: $(srcdir)/util.c
-kill.so: $(srcdir)/kill.c
-undo.so: $(srcdir)/undo.c
-macro.so: $(srcdir)/macro.c
-input.so: $(srcdir)/input.c
-callback.so: $(srcdir)/callback.c
-terminal.so: $(srcdir)/terminal.c
-nls.so: $(srcdir)/nls.c
-xmalloc.so: $(srcdir)/xmalloc.c
-history.so: $(srcdir)/history.c
-histexpand.so: $(srcdir)/histexpand.c
-histfile.so: $(srcdir)/histfile.c
-histsearch.so: $(srcdir)/histsearch.c
-shell.so: $(srcdir)/shell.c
-tilde.so: $(srcdir)/tilde.c
+readline.o: $(srcdir)/readline.c
+vi_mode.o: $(srcdir)/vi_mode.c
+funmap.o: $(srcdir)/funmap.c
+keymaps.o: $(srcdir)/keymaps.c
+parens.o: $(srcdir)/parens.c
+search.o: $(srcdir)/search.c
+rltty.o: $(srcdir)/rltty.c
+compat.o: $(srcdir)/compat.c
+complete.o: $(srcdir)/complete.c
+bind.o: $(srcdir)/bind.c
+isearch.o: $(srcdir)/isearch.c
+display.o: $(srcdir)/display.c
+signals.o: $(srcdir)/signals.c
+util.o: $(srcdir)/util.c
+kill.o: $(srcdir)/kill.c
+undo.o: $(srcdir)/undo.c
+macro.o: $(srcdir)/macro.c
+input.o: $(srcdir)/input.c
+callback.o: $(srcdir)/callback.c
+terminal.o: $(srcdir)/terminal.c
+nls.o: $(srcdir)/nls.c
+xmalloc.o: $(srcdir)/xmalloc.c
+history.o: $(srcdir)/history.c
+histexpand.o: $(srcdir)/histexpand.c
+histfile.o: $(srcdir)/histfile.c
+histsearch.o: $(srcdir)/histsearch.c
+savestring.o: $(srcdir)/savestring.c
+shell.o: $(srcdir)/shell.c
+tilde.o: $(srcdir)/tilde.c
+
+readline.o: readline.c
+vi_mode.o: vi_mode.c
+funmap.o: funmap.c
+keymaps.o: keymaps.c
+parens.o: parens.c
+search.o: search.c
+rltty.o: rltty.c
+compat.o: compat.c
+complete.o: complete.c
+bind.o: bind.c
+isearch.o: isearch.c
+display.o: display.c
+signals.o: signals.c
+util.o: util.c
+kill.o: kill.c
+undo.o: undo.c
+macro.o: macro.c
+input.o: input.c
+callback.o: callback.c
+terminal.o: terminal.c
+nls.o: nls.c
+xmalloc.o: xmalloc.c
+history.o: history.c
+histexpand.o: histexpand.c
+histfile.o: histfile.c
+histsearch.o: histsearch.c
+savestring.o: savestring.c
+shell.o: shell.c
+tilde.o: tilde.c
diff --git a/readline/README b/readline/README
--- a/readline/README
+++ b/readline/README
@@ -1,12 +1,12 @@
 Introduction
 ============
 
-This is the Gnu Readline library, version 2.1.
+This is the Gnu Readline library, version 4.2.
 
 The Readline library provides a set of functions for use by applications
 that allow users to edit command lines as they are typed in.  Both
 Emacs and vi editing modes are available.  The Readline library includes
 additional functions to maintain a list of previously-entered command
 lines, to recall and perhaps reedit those lines, and perform csh-like
 history expansion on previous commands.
 
@@ -29,57 +29,108 @@ available.  If you want to use `cc' inst
 if you are using a Bourne-style shell.  If you are not, the following
 may work:
 
         env CC=cc ./configure
 
 Read the file INSTALL in this directory for more information about how
 to customize and control the build process.
 
-The file rlconf.h contains defines that enable and disable certain
-Readline features.
+The file rlconf.h contains C preprocessor defines that enable and disable
+certain Readline features.
 
 Examples
 ========
 
 There are several example programs that use Readline features in the
 examples directory.  The `rl' program is of particular interest.  It
 is a command-line interface to Readline, suitable for use in shell
 scripts in place of `read'.
 
 Shared Libraries
 ================
 
 There is skeletal support for building shared versions of the
-Readline and History libraries.
+Readline and History libraries.  The configure script creates
+a Makefile in the `shlib' subdirectory, and typing `make shared'
+will cause shared versions of the Readline and History libraries
+to be built on supported platforms.
+
+Configure calls the script support/shobj-conf to test whether or
+not shared library creation is supported and to generate the values
+of variables that are substituted into shlib/Makefile.  If you
+try to build shared libraries on an unsupported platform, `make'
+will display a message asking you to update support/shobj-conf for
+your platform.
+
+If you need to update support/shobj-conf, you will need to create
+a `stanza' for your operating system and compiler.  The script uses
+the value of host_os and ${CC} as determined by configure.  For
+instance, FreeBSD 2.2.5 with any version of gcc is identified as
+`freebsd2.2.5-gcc*'.
 
-Typing `make shared' will cause shared versions of the Readline and
-History libraries to be built on SunOS 4.1.x.  For versions of Unix
-other than SunOS, you will have to make some changes to Makefile.in.
-The relevant variables are:
+In the stanza for your operating system-compiler pair, you will need to
+define several variables.  They are:
+
+SHOBJ_CC	The C compiler used to compile source files into shareable
+		object files.  This is normally set to the value of ${CC}
+		by configure, and should not need to be changed.
 
-PICFLAG		Options to give to the compiler to produce position-independent
-		code.  The value `-fpic' works for most versions of gcc.
-SHLIB_OPTS	Options to give to the linker to produce a shared library.
-		The value `-assert pure-text -ldl' works on SunOS 4.1.x.
-		The value `-Bshareable' works for some versions of GNU ld.
+SHOBJ_CFLAGS	Flags to pass to the C compiler ($SHOBJ_CC) to create
+		position-independent code.  If you are using gcc, this
+		should probably be set to `-fpic'.
+
+SHOBJ_LD	The link editor to be used to create the shared library from
+		the object files created by $SHOBJ_CC.  If you are using
+		gcc, a value of `gcc' will probably work.
+
+SHOBJ_LDFLAGS	Flags to pass to SHOBJ_LD to enable shared object creation.
+		If you are using gcc, `-shared' may be all that is necessary.
+		These should be the flags needed for generic shared object
+		creation.
 
-MAJOR		The major version number of the shared library.  You should
-		not need to change this.
-MINOR		The minor version number of the shared library.  Some systems,
-		such as SVR4 and its descendents (e.g., Solaris, Unixware),
-		do not use minor version numbers.  For those systems, this
-		variable should be left unset.
+SHLIB_XLDFLAGS	Additional flags to pass to SHOBJ_LD for shared library
+		creation.  Many systems use the -R option to the link
+		editor to embed a path within the library for run-time
+		library searches.  A reasonable value for such systems would
+		be `-R$(libdir)'.
+
+SHLIB_LIBS	Any additional libraries that shared libraries should be
+		linked against when they are created.
+
+SHLIB_LIBSUFF	The suffix to add to `libreadline' and `libhistory' when
+		generating the filename of the shared library.  Many systems
+		use `so'; HP-UX uses `sl'.
 
-LD		The linker.  The value of `ld' is correct for SunOS 4.1.x.
-		You may need to change it to `gcc'; make sure to change
-		SHLIB_OPTS if you do so.
+SHLIB_LIBVERSION The string to append to the filename to indicate the version
+		of the shared library.  It should begin with $(SHLIB_LIBSUFF),
+		and possibly include version information that allows the
+		run-time loader to load the version of the shared library
+		appropriate for a particular program.  Systems using shared
+		libraries similar to SunOS 4.x use major and minor library
+		version numbers; for those systems a value of
+		`$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)' is appropriate.
+		Systems based on System V Release 4 don't use minor version
+		numbers; use `$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)' on those systems.
+		Other Unix versions use different schemes.
 
-Once you have edited Makefile.in, type `make Makefile' to rebuild the
-Makefile, then `make shared' to build the shared libraries.
+SHLIB_STATUS	Set this to `supported' when you have defined the other
+		necessary variables.  Make uses this to determine whether
+		or not shared library creation should be attempted.
+
+You should look at the existing stanzas in support/shobj-conf for ideas.
+
+Once you have updated support/shobj-conf, re-run configure and type
+`make shared'.  The shared libraries will be created in the shlib
+subdirectory.
+
+Since shared libraries are not created on all platforms, `make install'
+will not automatically install the shared libraries.  To install them,
+change the current directory to shlib and type `make install'.  Running
+`make install-shared' from the top-level build directory will also work.
 
 Documentation
 =============
 
 The documentation for the Readline and History libraries appears in the
 `doc' subdirectory.  There are two texinfo files and a Unix-style manual
 page describing the programming facilities available in the Readline
 library.  The texinfo files include both user and programmer's manuals.
@@ -88,25 +139,25 @@ Reporting Bugs
 ==============
 
 Bug reports for Readline should be sent to:
 
         bug-readline@gnu.org
 
 When reporting a bug, please include the following information:
 
-        * the version number and release status of Readline (e.g., 2.1-release)
+        * the version number and release status of Readline (e.g., 4.0-release)
         * the machine and OS that it is running on
         * a list of the compilation flags or the contents of `config.h', if
           appropriate
         * a description of the bug
         * a recipe for recreating the bug reliably
         * a fix for the bug if you have one!
 
 If you would like to contact the Readline maintainer directly, send mail
 to bash-maintainers@gnu.org.
 
-Since Readline is developed along with bash, the bug-bash@gnu.org
-mailing list (mirrored to the Usenet newsgroup gnu.bash.bug) often contains
-Readline bug reports and fixes.
+Since Readline is developed along with bash, the bug-bash@gnu.org mailing
+list (mirrored to the Usenet newsgroup gnu.bash.bug) often contains
+Readline bug reports and fixes. 
 
 Chet Ramey
 chet@po.cwru.edu
diff --git a/readline/aclocal.m4 b/readline/aclocal.m4
--- a/readline/aclocal.m4
+++ b/readline/aclocal.m4
@@ -21,17 +21,18 @@ main()
   fd2 = dup2(fd1, 1);
   if (fd2 < 0)
     exit(2);
   fl = fcntl(fd2, 1, 0);
   /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
   exit(fl != 1);
 }
 ], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
-    AC_MSG_ERROR(cannot check dup2 if cross compiling))
+    [AC_MSG_WARN(cannot check dup2 if cross compiling -- defaulting to no)
+     bash_cv_dup2_broken=no])
 ])
 AC_MSG_RESULT($bash_cv_dup2_broken)
 if test $bash_cv_dup2_broken = yes; then
 AC_DEFINE(DUP2_BROKEN)
 fi
 ])
 
 dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
@@ -123,17 +124,18 @@ main()
 	close(fds[1]);
 	if (read(fds[0], &ok, 1) != 1)
 	  exit(4);
 	wait(&status);
 	wait(&status);
 	exit(ok ? 0 : 5);
 }
 ], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
-   AC_MSG_ERROR(cannot check pgrp synchronization if cross compiling))
+   [AC_MSG_WARN(cannot check pgrp synchronization if cross compiling -- defaulting to no)
+    bash_cv_pgrp_pipe=no])
 ])
 AC_MSG_RESULT($bash_cv_pgrp_pipe)
 if test $bash_cv_pgrp_pipe = yes; then
 AC_DEFINE(PGRP_PIPE)
 fi
 ])
 
 dnl
@@ -164,63 +166,84 @@ dnl
 dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
 dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
 dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
 dnl matters, this just checks for rlim_t, quad_t, or long.
 dnl
 AC_DEFUN(BASH_RLIMIT_TYPE,
 [AC_MSG_CHECKING(for size and type of struct rlimit fields)
 AC_CACHE_VAL(bash_cv_type_rlimit,
-[AC_TRY_COMPILE([#include <sys/types.h>],
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/resource.h>],
 [rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 main()
 {
 #ifdef HAVE_QUAD_T
   struct rlimit rl;
   if (sizeof(rl.rlim_cur) == sizeof(quad_t))
     exit(0);
 #endif
   exit(1);
 }], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
-        AC_MSG_ERROR(cannot check quad_t if cross compiling))])
+        [AC_MSG_WARN(cannot check quad_t if cross compiling -- defaulting to long)
+         bash_cv_type_rlimit=long])])
 ])
 AC_MSG_RESULT($bash_cv_type_rlimit)
 if test $bash_cv_type_rlimit = quad_t; then
 AC_DEFINE(RLIMTYPE, quad_t)
 elif test $bash_cv_type_rlimit = rlim_t; then
 AC_DEFINE(RLIMTYPE, rlim_t)
 fi
 ])
 
 dnl
 dnl Check for sys_siglist[] or _sys_siglist[]
 dnl
+AC_DEFUN(BASH_DECL_UNDER_SYS_SIGLIST,
+[AC_MSG_CHECKING([for _sys_siglist in signal.h or unistd.h])
+AC_CACHE_VAL(bash_cv_decl_under_sys_siglist,
+[AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif], [ char *msg = _sys_siglist[2]; ],
+  bash_cv_decl_under_sys_siglist=yes, bash_cv_decl_under_sys_siglist=no,
+  [AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)])])dnl
+AC_MSG_RESULT($bash_cv_decl_under_sys_siglist)
+if test $bash_cv_decl_under_sys_siglist = yes; then
+AC_DEFINE(UNDER_SYS_SIGLIST_DECLARED)
+fi
+])
+
 AC_DEFUN(BASH_UNDER_SYS_SIGLIST,
-[AC_MSG_CHECKING([for _sys_siglist in system C library])
+[AC_REQUIRE([BASH_DECL_UNDER_SYS_SIGLIST])
+AC_MSG_CHECKING([for _sys_siglist in system C library])
 AC_CACHE_VAL(bash_cv_under_sys_siglist,
 [AC_TRY_RUN([
 #include <sys/types.h>
 #include <signal.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#ifndef _sys_siglist
+#ifndef UNDER_SYS_SIGLIST_DECLARED
 extern char *_sys_siglist[];
 #endif
 main()
 {
-char *msg = _sys_siglist[2];
+char *msg = (char *)_sys_siglist[2];
 exit(msg == 0);
 }],
-bash_cv_under_sys_siglist=yes, bash_cv_under_sys_siglist=no,
-AC_MSG_ERROR(cannot check for _sys_siglist[] if cross compiling))])dnl
+	bash_cv_under_sys_siglist=yes, bash_cv_under_sys_siglist=no,
+	[AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)
+	 bash_cv_under_sys_siglist=no])])
 AC_MSG_RESULT($bash_cv_under_sys_siglist)
 if test $bash_cv_under_sys_siglist = yes; then
 AC_DEFINE(HAVE_UNDER_SYS_SIGLIST)
 fi
 ])
 
 AC_DEFUN(BASH_SYS_SIGLIST,
 [AC_REQUIRE([AC_DECL_SYS_SIGLIST])
@@ -235,18 +258,19 @@ AC_CACHE_VAL(bash_cv_sys_siglist,
 #ifndef SYS_SIGLIST_DECLARED
 extern char *sys_siglist[];
 #endif
 main()
 {
 char *msg = sys_siglist[2];
 exit(msg == 0);
 }],
-bash_cv_sys_siglist=yes, bash_cv_sys_siglist=no,
-AC_MSG_ERROR(cannot check for sys_siglist if cross compiling))])dnl
+	bash_cv_sys_siglist=yes, bash_cv_sys_siglist=no,
+	[AC_MSG_WARN(cannot check for sys_siglist if cross compiling -- defaulting to no)
+	 bash_cv_sys_siglist=no])])
 AC_MSG_RESULT($bash_cv_sys_siglist)
 if test $bash_cv_sys_siglist = yes; then
 AC_DEFINE(HAVE_SYS_SIGLIST)
 fi
 ])
 
 dnl Check for sys_errlist[] and sys_nerr, check for declaration
 AC_DEFUN(BASH_SYS_ERRLIST,
@@ -287,26 +311,34 @@ AC_CACHE_VAL(bash_cv_opendir_not_robust,
 # endif /* SYSDIR */
 # ifdef HAVE_NDIR_H
 #  include <ndir.h>
 # endif
 #endif /* HAVE_DIRENT_H */
 main()
 {
 DIR *dir;
-int fd;
-unlink("/tmp/not_a_directory");
-fd = open("/tmp/not_a_directory", O_WRONLY|O_CREAT, 0666);
+int fd, err;
+err = mkdir("/tmp/bash-aclocal", 0700);
+if (err < 0) {
+  perror("mkdir");
+  exit(1);
+}
+unlink("/tmp/bash-aclocal/not_a_directory");
+fd = open("/tmp/bash-aclocal/not_a_directory", O_WRONLY|O_CREAT|O_EXCL, 0666);
 write(fd, "\n", 1);
 close(fd);
-dir = opendir("/tmp/not_a_directory");
-unlink("/tmp/not_a_directory");
+dir = opendir("/tmp/bash-aclocal/not_a_directory");
+unlink("/tmp/bash-aclocal/not_a_directory");
+rmdir("/tmp/bash-aclocal");
 exit (dir == 0);
 }], bash_cv_opendir_not_robust=yes,bash_cv_opendir_not_robust=no,
-    AC_MSG_ERROR(cannot check opendir if cross compiling))])
+    [AC_MSG_WARN(cannot check opendir if cross compiling -- defaulting to no)
+     bash_cv_opendir_not_robust=no]
+)])
 AC_MSG_RESULT($bash_cv_opendir_not_robust)
 if test $bash_cv_opendir_not_robust = yes; then
 AC_DEFINE(OPENDIR_NOT_ROBUST)
 fi
 ])
 
 dnl
 AC_DEFUN(BASH_TYPE_SIGHANDLER,
@@ -323,18 +355,101 @@ extern "C"
 void (*signal ()) ();],
 [int i;], bash_cv_void_sighandler=yes, bash_cv_void_sighandler=no)])dnl
 AC_MSG_RESULT($bash_cv_void_sighandler)
 if test $bash_cv_void_sighandler = yes; then
 AC_DEFINE(VOID_SIGHANDLER)
 fi
 ])
 
+dnl
+dnl A signed 16-bit integer quantity
+dnl
+AC_DEFUN(BASH_TYPE_BITS16_T,
+[
+if test "$ac_cv_sizeof_short" = 2; then
+  AC_CHECK_TYPE(bits16_t, short)
+elif test "$ac_cv_sizeof_char" = 2; then
+  AC_CHECK_TYPE(bits16_t, char)
+else
+  AC_CHECK_TYPE(bits16_t, short)
+fi
+])
+
+dnl
+dnl An unsigned 16-bit integer quantity
+dnl
+AC_DEFUN(BASH_TYPE_U_BITS16_T,
+[
+if test "$ac_cv_sizeof_short" = 2; then
+  AC_CHECK_TYPE(u_bits16_t, unsigned short)
+elif test "$ac_cv_sizeof_char" = 2; then
+  AC_CHECK_TYPE(u_bits16_t, unsigned char)
+else
+  AC_CHECK_TYPE(u_bits16_t, unsigned short)
+fi
+])
+
+dnl
+dnl A signed 32-bit integer quantity
+dnl
+AC_DEFUN(BASH_TYPE_BITS32_T,
+[
+if test "$ac_cv_sizeof_int" = 4; then
+  AC_CHECK_TYPE(bits32_t, int)
+elif test "$ac_cv_sizeof_long" = 4; then
+  AC_CHECK_TYPE(bits32_t, long)
+else
+  AC_CHECK_TYPE(bits32_t, int)
+fi
+])
+
+dnl
+dnl An unsigned 32-bit integer quantity
+dnl
+AC_DEFUN(BASH_TYPE_U_BITS32_T,
+[
+if test "$ac_cv_sizeof_int" = 4; then
+  AC_CHECK_TYPE(u_bits32_t, unsigned int)
+elif test "$ac_cv_sizeof_long" = 4; then
+  AC_CHECK_TYPE(u_bits32_t, unsigned long)
+else
+  AC_CHECK_TYPE(u_bits32_t, unsigned int)
+fi
+])
+
+AC_DEFUN(BASH_TYPE_PTRDIFF_T,
+[
+if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
+  AC_CHECK_TYPE(ptrdiff_t, int)
+elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
+  AC_CHECK_TYPE(ptrdiff_t, long)
+else
+  AC_CHECK_TYPE(ptrdiff_t, int)
+fi
+])
+
+dnl
+dnl A signed 64-bit quantity
+dnl
+AC_DEFUN(BASH_TYPE_BITS64_T,
+[
+if test "$ac_sv_sizeof_char_p" = 8; then
+  AC_CHECK_TYPE(bits64_t, char *)
+elif test "$ac_cv_sizeof_double" = 8; then
+  AC_CHECK_TYPE(bits64_t, double)
+elif test "$ac_cv_sizeof_long" = 8; then
+  AC_CHECK_TYPE(bits64_t, long)
+else
+  AC_CHECK_TYPE(bits64_t, double)
+fi
+])
+
 AC_DEFUN(BASH_FUNC_STRSIGNAL,
-[AC_MSG_CHECKING([for the existance of strsignal])
+[AC_MSG_CHECKING([for the existence of strsignal])
 AC_CACHE_VAL(bash_cv_have_strsignal,
 [AC_TRY_LINK([#include <sys/types.h>
 #include <signal.h>],
 [char *s = (char *)strsignal(2);],
  bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
 AC_MSG_RESULT($bash_cv_have_strsignal)
 if test $bash_cv_have_strsignal = yes; then
 AC_DEFINE(HAVE_STRSIGNAL)
@@ -343,23 +458,37 @@ fi
 
 AC_DEFUN(BASH_FUNC_LSTAT,
 [dnl Cannot use AC_CHECK_FUNCS(lstat) because Linux defines lstat() as an
 dnl inline function in <sys/stat.h>.
 AC_CACHE_CHECK([for lstat], bash_cv_func_lstat,
 [AC_TRY_LINK([
 #include <sys/types.h>
 #include <sys/stat.h>
-],[ lstat("",(struct stat *)0); ],
+],[ lstat(".",(struct stat *)0); ],
 bash_cv_func_lstat=yes, bash_cv_func_lstat=no)])
 if test $bash_cv_func_lstat = yes; then
   AC_DEFINE(HAVE_LSTAT)
 fi
 ])
 
+AC_DEFUN(BASH_FUNC_INET_ATON,
+[
+AC_CACHE_CHECK([for inet_aton], bash_cv_func_inet_aton,
+[AC_TRY_LINK([
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+struct in_addr ap;], [ inet_aton("127.0.0.1", &ap); ],
+bash_cv_func_inet_aton=yes, bash_cv_func_inet_aton=no)])
+if test $bash_cv_func_inet_aton = yes; then
+  AC_DEFINE(HAVE_INET_ATON)
+fi
+])
+
 AC_DEFUN(BASH_STRUCT_TERMIOS_LDISC,
 [AC_MSG_CHECKING([for a c_line member of struct termios])
 AC_CACHE_VAL(bash_cv_termios_ldisc,
 [AC_TRY_COMPILE([#include <sys/types.h>
 #include <termios.h>],[struct termios t; int i; i = t.c_line;],
   bash_cv_termios_ldisc=yes, bash_cv_termios_ldisc=no)])dnl
 AC_MSG_RESULT($bash_cv_termios_ldisc)
 if test $bash_cv_termios_ldisc = yes; then
@@ -409,17 +538,19 @@ char *s;
    why not. */
 #if defined (NeXT)
 exit(1);
 #endif
 s = getenv("ABCDE");
 exit(s == 0);	/* force optimizer to leave getenv in */
 }
 ], bash_cv_getenv_redef=yes, bash_cv_getenv_redef=no,
-AC_MSG_ERROR(cannot check getenv redefinition if cross compiling))])
+   [AC_MSG_WARN(cannot check getenv redefinition if cross compiling -- defaulting to yes)
+    bash_cv_getenv_redef=yes]
+)])
 AC_MSG_RESULT($bash_cv_getenv_redef)
 if test $bash_cv_getenv_redef = yes; then
 AC_DEFINE(CAN_REDEFINE_GETENV)
 fi
 ])
 
 AC_DEFUN(BASH_FUNC_PRINTF,
 [AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
@@ -429,38 +560,42 @@ AC_CACHE_VAL(bash_cv_printf_declared,
 #ifdef __STDC__
 typedef int (*_bashfunc)(const char *, ...);
 #else
 typedef int (*_bashfunc)();
 #endif
 main()
 {
 _bashfunc pf;
-pf = printf;
+pf = (_bashfunc) printf;
 exit(pf == 0);
 }
-],bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
-AC_MSG_ERROR(cannot check printf declaration if cross compiling))])
+], bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
+   [AC_MSG_WARN(cannot check printf declaration if cross compiling -- defaulting to yes)
+    bash_cv_printf_declared=yes]
+)])
 AC_MSG_RESULT($bash_cv_printf_declared)
 if test $bash_cv_printf_declared = yes; then
 AC_DEFINE(PRINTF_DECLARED)
 fi
 ])
 
 AC_DEFUN(BASH_FUNC_ULIMIT_MAXFDS,
 [AC_MSG_CHECKING(whether ulimit can substitute for getdtablesize)
 AC_CACHE_VAL(bash_cv_ulimit_maxfds,
 [AC_TRY_RUN([
 main()
 {
 long maxfds = ulimit(4, 0L);
 exit (maxfds == -1L);
 }
-],bash_cv_ulimit_maxfds=yes, bash_cv_ulimit_maxfds=no,
-AC_MSG_ERROR(cannot check ulimit if cross compiling))])
+], bash_cv_ulimit_maxfds=yes, bash_cv_ulimit_maxfds=no,
+   [AC_MSG_WARN(cannot check ulimit if cross compiling -- defaulting to no)
+    bash_cv_ulimit_maxfds=no]
+)])
 AC_MSG_RESULT($bash_cv_ulimit_maxfds)
 if test $bash_cv_ulimit_maxfds = yes; then
 AC_DEFINE(ULIMIT_MAXFDS)
 fi
 ])
 
 AC_DEFUN(BASH_CHECK_LIB_TERMCAP,
 [
@@ -474,17 +609,17 @@ AC_CACHE_VAL(bash_cv_termcap_lib,
 [AC_CHECK_LIB(termcap, tgetent, bash_cv_termcap_lib=libtermcap,
     [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,
 	[AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,
 	    bash_cv_termcap_lib=gnutermcap)])])])
 if test "X$_bash_needmsg" = "Xyes"; then
 AC_MSG_CHECKING(which library has the termcap functions)
 fi
 AC_MSG_RESULT(using $bash_cv_termcap_lib)
-if test $bash_cv_termcap_lib = gnutermcap; then
+if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
 LDFLAGS="$LDFLAGS -L./lib/termcap"
 TERMCAP_LIB="./lib/termcap/libtermcap.a"
 TERMCAP_DEP="./lib/termcap/libtermcap.a"
 elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
 TERMCAP_LIB=-ltermcap
 TERMCAP_DEP=
 elif test $bash_cv_termcap_lib = libncurses; then
 TERMCAP_LIB=-lncurses
@@ -545,17 +680,19 @@ FILE *stream;
 main()
 {
 	char	lbuf[32];
 	popen_called = 0;
 	getcwd(lbuf, 32);
 	exit (popen_called);
 }
 ], bash_cv_getcwd_calls_popen=no, bash_cv_getcwd_calls_popen=yes,
-AC_MSG_ERROR(cannot check whether getcwd calls popen if cross compiling))])
+   [AC_MSG_WARN(cannot check whether getcwd calls popen if cross compiling -- defaulting to no)
+    bash_cv_getcwd_calls_popen=no]
+)])
 AC_MSG_RESULT($bash_cv_getcwd_calls_popen)
 if test $bash_cv_getcwd_calls_popen = yes; then
 AC_DEFINE(GETCWD_BROKEN)
 fi
 ])
 
 AC_DEFUN(BASH_STRUCT_DIRENT_D_INO,
 [AC_REQUIRE([AC_HEADER_DIRENT])
@@ -667,26 +804,20 @@ main()
 {
 	nsigint = 0;
 	set_signal_handler(SIGINT, sigint);
 	kill((int)getpid(), SIGINT);
 	kill((int)getpid(), SIGINT);
 	exit(nsigint != 2);
 }
 ], bash_cv_must_reinstall_sighandlers=no, bash_cv_must_reinstall_sighandlers=yes,
-if test "$bash_cv_signal_vintage" = svr3; then
-  bash_cv_must_reinstall_sighandlers=yes
-else
-  bash_cv_must_reinstall_sighandlers=no
-fi)])
-if test "$cross_compiling" = yes; then
-  AC_MSG_RESULT([$bash_cv_must_reinstall_sighandlers assumed for cross compilation])
-else
-  AC_MSG_RESULT($bash_cv_must_reinstall_sighandlers)
-fi
+   [AC_MSG_WARN(cannot check signal handling if cross compiling -- defaulting to no)
+    bash_cv_must_reinstall_sighandlers=no]
+)])
+AC_MSG_RESULT($bash_cv_must_reinstall_sighandlers)
 if test $bash_cv_must_reinstall_sighandlers = yes; then
 AC_DEFINE(MUST_REINSTALL_SIGHANDLERS)
 fi
 ])
 
 AC_DEFUN(BASH_FUNC_SBRK_DECLARED,
 [AC_MSG_CHECKING(for declaration of sbrk in <unistd.h>)
 AC_CACHE_VAL(bash_cv_sbrk_declared,
@@ -741,19 +872,20 @@ exit(1);
 #endif
 
 /* Other systems have TIOCSPGRP/TIOCGPRGP and wait3. */
 #if !defined (_POSIX_VERSION) && !defined (HAVE_WAIT3)
 exit(1);
 #endif
 
 exit(0);
-}],bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing,
-	AC_MSG_ERROR(cannot check job control if cross-compiling))
-])
+}], bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing,
+    [AC_MSG_WARN(cannot check job control if cross-compiling -- defaulting to missing)
+     bash_cv_job_control_missing=missing]
+)])
 AC_MSG_RESULT($bash_cv_job_control_missing)
 if test $bash_cv_job_control_missing = missing; then
 AC_DEFINE(JOB_CONTROL_MISSING)
 fi
 ])
 
 dnl check whether named pipes are present
 dnl this requires a previous check for mkfifo, but that is awkward to specify
@@ -765,39 +897,47 @@ AC_CACHE_VAL(bash_cv_sys_named_pipes,
 #include <sys/stat.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 /* Add more tests in here as appropriate. */
 main()
 {
-int fd;
+int fd, err;
 
 #if defined (HAVE_MKFIFO)
 exit (0);
 #endif
 
 #if !defined (S_IFIFO) && (defined (_POSIX_VERSION) && !defined (S_ISFIFO))
 exit (1);
 #endif
 
 #if defined (NeXT)
 exit (1);
 #endif
-
-fd = mknod ("/tmp/sh-np-autoconf", 0666 | S_IFIFO, 0);
-if (fd == -1)
+err = mkdir("/tmp/bash-aclocal", 0700);
+if (err < 0) {
+  perror ("mkdir");
+  exit(1);
+}
+fd = mknod ("/tmp/bash-aclocal/sh-np-autoconf", 0666 | S_IFIFO, 0);
+if (fd == -1) {
+  rmdir ("/tmp/bash-aclocal");
   exit (1);
+}
 close(fd);
-unlink ("/tmp/sh-np-autoconf");
+unlink ("/tmp/bash-aclocal/sh-np-autoconf");
+rmdir ("/tmp/bash-aclocal");
 exit(0);
-}],bash_cv_sys_named_pipes=present, bash_cv_sys_named_pipes=missing,
-	AC_MSG_ERROR(cannot check for named pipes if cross-compiling))
-])
+}], bash_cv_sys_named_pipes=present, bash_cv_sys_named_pipes=missing,
+    [AC_MSG_WARN(cannot check for named pipes if cross-compiling -- defaulting to missing)
+     bash_cv_sys_named_pipes=missing]
+)])
 AC_MSG_RESULT($bash_cv_sys_named_pipes)
 if test $bash_cv_sys_named_pipes = missing; then
 AC_DEFINE(NAMED_PIPES_MISSING)
 fi
 ])
 
 AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
 [AC_REQUIRE([BASH_SIGNAL_CHECK])
@@ -835,24 +975,21 @@ if (code)
 /* change it */
 sigaddset(&set, SIGINT);
 sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
 
 /* and siglongjmp */
 siglongjmp(xx, 10);
 exit(1);
 #endif
-}],bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
-   bash_cv_func_sigsetjmp=present)
-])
-if test "$cross_compiling" = yes; then
-  AC_MSG_RESULT([$bash_cv_func_sigsetjmp=present assumed for cross compiling])
-else
-  AC_MSG_RESULT($bash_cv_func_sigsetjmp)
-fi
+}], bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
+    [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing)
+     bash_cv_func_sigsetjmp=missing]
+)])
+AC_MSG_RESULT($bash_cv_func_sigsetjmp)
 if test $bash_cv_func_sigsetjmp = present; then
 AC_DEFINE(HAVE_POSIX_SIGSETJMP)
 fi
 ])
 
 AC_DEFUN(BASH_HAVE_TIOCGWINSZ,
 [AC_MSG_CHECKING(for TIOCGWINSZ in sys/ioctl.h)
 AC_CACHE_VAL(bash_cv_tiocgwinsz_in_ioctl,
@@ -861,24 +998,33 @@ AC_CACHE_VAL(bash_cv_tiocgwinsz_in_ioctl
   bash_cv_tiocgwinsz_in_ioctl=yes,bash_cv_tiocgwinsz_in_ioctl=no)])
 AC_MSG_RESULT($bash_cv_tiocgwinsz_in_ioctl)
 if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
 AC_DEFINE(GWINSZ_IN_SYS_IOCTL)
 fi
 ])
 
 AC_DEFUN(BASH_STRUCT_WINSIZE,
-[AC_MSG_CHECKING(for struct winsize in sys/ioctl.h)
-AC_CACHE_VAL(bash_cv_struct_winsize_in_ioctl,
+[AC_MSG_CHECKING(for struct winsize in sys/ioctl.h and termios.h)
+AC_CACHE_VAL(bash_cv_struct_winsize_header,
 [AC_TRY_COMPILE([#include <sys/types.h>
 #include <sys/ioctl.h>], [struct winsize x;],
-  bash_cv_struct_winsize_in_ioctl=yes,bash_cv_struct_winsize_in_ioctl=no)])
-AC_MSG_RESULT($bash_cv_struct_winsize_in_ioctl)
-if test $bash_cv_struct_winsize_in_ioctl = yes; then   
-AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
+  bash_cv_struct_winsize_header=ioctl_h,
+  [AC_TRY_COMPILE([#include <sys/types.h>
+#include <termios.h>], [struct winsize x;],
+  bash_cv_struct_winsize_header=termios_h, bash_cv_struct_winsize_header=other)
+])])
+if test $bash_cv_struct_winsize_header = ioctl_h; then
+  AC_MSG_RESULT(sys/ioctl.h)
+  AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
+elif test $bash_cv_struct_winsize_header = termios_h; then
+  AC_MSG_RESULT(termios.h)
+  AC_DEFINE(STRUCT_WINSIZE_IN_TERMIOS)
+else
+  AC_MSG_RESULT(not found)
 fi
 ])
 
 AC_DEFUN(BASH_HAVE_TIOCSTAT,
 [AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
 AC_CACHE_VAL(bash_cv_tiocstat_in_ioctl,
 [AC_TRY_COMPILE([#include <sys/types.h>
 #include <sys/ioctl.h>], [int x = TIOCSTAT;],
@@ -914,24 +1060,29 @@ AC_CACHE_VAL(bash_cv_speed_t_in_sys_type
   bash_cv_speed_t_in_sys_types=yes,bash_cv_speed_t_in_sys_types=no)])
 AC_MSG_RESULT($bash_cv_speed_t_in_sys_types)
 if test $bash_cv_speed_t_in_sys_types = yes; then   
 AC_DEFINE(SPEED_T_IN_SYS_TYPES)
 fi
 ])
 
 AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
-[AC_MSG_CHECKING(whether programs are able to redeclare getpw functions)
-AC_CACHE_VAL(bash_cv_can_redecl_getpw,
-[AC_TRY_COMPILE([#include <sys/types.h>
+[AC_MSG_CHECKING(whether getpw functions are declared in pwd.h)
+AC_CACHE_VAL(bash_cv_getpw_declared,
+[AC_EGREP_CPP(getpwuid,
+[
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
 #include <pwd.h>
-extern struct passwd *getpwent();], [struct passwd *z; z = getpwent();],
-  bash_cv_can_redecl_getpw=yes,bash_cv_can_redecl_getpw=no)])
-AC_MSG_RESULT($bash_cv_can_redecl_getpw)
-if test $bash_cv_can_redecl_getpw = no; then
+],
+bash_cv_getpw_declared=yes,bash_cv_getpw_declared=no)])
+AC_MSG_RESULT($bash_cv_getpw_declared)
+if test $bash_cv_getpw_declared = yes; then
 AC_DEFINE(HAVE_GETPW_DECLS)
 fi
 ])
 
 AC_DEFUN(BASH_CHECK_DEV_FD,
 [AC_MSG_CHECKING(whether /dev/fd is available)
 AC_CACHE_VAL(bash_cv_dev_fd,
 [if test -d /dev/fd  && test -r /dev/fd/0; then
@@ -947,22 +1098,42 @@ if test $bash_cv_dev_fd = "standard"; th
   AC_DEFINE(HAVE_DEV_FD)
   AC_DEFINE(DEV_FD_PREFIX, "/dev/fd/")
 elif test $bash_cv_dev_fd = "whacky"; then
   AC_DEFINE(HAVE_DEV_FD)
   AC_DEFINE(DEV_FD_PREFIX, "/proc/self/fd/")
 fi
 ])
 
+AC_DEFUN(BASH_CHECK_DEV_STDIN,
+[AC_MSG_CHECKING(whether /dev/stdin stdout stderr are available)
+AC_CACHE_VAL(bash_cv_dev_stdin,
+[if test -d /dev/fd && test -r /dev/stdin; then
+   bash_cv_dev_stdin=present
+ elif test -d /proc/self/fd && test -r /dev/stdin; then
+   bash_cv_dev_stdin=present
+ else
+   bash_cv_dev_stdin=absent
+ fi
+])
+AC_MSG_RESULT($bash_cv_dev_stdin)
+if test $bash_cv_dev_stdin = "present"; then
+  AC_DEFINE(HAVE_DEV_STDIN)
+fi
+])
+
 dnl
-dnl Check for the presence of getpeername (the only networking function
-dnl bash currently requires) in libsocket.  If libsocket is present,
-dnl check for libnsl and add it to LIBS if it's there, since most
-dnl systems with libsocket require linking with libnsl as well.
-dnl This should only be called if getpeername was not found in libc.
+dnl Check for the presence of getpeername in libsocket.
+dnl If libsocket is present, check for libnsl and add it to LIBS if
+dnl it's there, since most systems with libsocket require linking
+dnl with libnsl as well.  This should only be called if getpeername
+dnl was not found in libc.
+dnl
+dnl NOTE: IF WE FIND GETPEERNAME, WE ASSUME THAT WE HAVE BIND/CONNECT
+dnl	  AS WELL
 dnl
 AC_DEFUN(BASH_CHECK_SOCKLIB,
 [
 if test "X$bash_cv_have_socklib" = "X"; then
 _bash_needmsg=
 else
 AC_MSG_CHECKING(for socket library)
 _bash_needmsg=yes
@@ -994,27 +1165,53 @@ if test $bash_cv_have_socklib = yes; the
   else
     LIBS="-lsocket $LIBS"
   fi
   AC_DEFINE(HAVE_LIBSOCKET)
   AC_DEFINE(HAVE_GETPEERNAME)
 fi
 ])
 
+dnl
+dnl This needs BASH_CHECK_SOCKLIB, but since that's not called on every
+dnl system, we can't use AC_PREREQ
+dnl
+AC_DEFUN(BASH_FUNC_GETHOSTBYNAME,
+[if test "X$bash_cv_have_gethostbyname" = "X"; then
+_bash_needmsg=yes
+else
+AC_MSG_CHECKING(for gethostbyname in socket library)
+_bash_needmsg=
+fi
+AC_CACHE_VAL(bash_cv_have_gethostbyname,
+[AC_TRY_LINK([#include <netdb.h>],
+[ struct hostent *hp;
+  hp = gethostbyname("localhost");
+], bash_cv_have_gethostbyname=yes, bash_cv_have_gethostbyname=no)]
+)
+if test "X$_bash_needmsg" = Xyes; then
+    AC_MSG_CHECKING(for gethostbyname in socket library)
+fi
+AC_MSG_RESULT($bash_cv_have_gethostbyname)
+if test "$bash_cv_have_gethostbyname" = yes; then
+AC_DEFINE(HAVE_GETHOSTBYNAME)
+fi
+])
+
 AC_DEFUN(BASH_DEFAULT_MAIL_DIR,
 [AC_MSG_CHECKING(for default mail directory)
 AC_CACHE_VAL(bash_cv_mail_dir,
 [if test -d /var/mail; then
    bash_cv_mail_dir=/var/mail
  elif test -d /usr/mail; then
    bash_cv_mail_dir=/usr/mail
+ elif test -d /var/spool/mail; then
+   bash_cv_mail_dir=/var/spool/mail
  elif test -d /usr/spool/mail; then
    bash_cv_mail_dir=/usr/spool/mail
- elif test -d /var/spool/mail; then
-   bash_cv_mail_dir=/var/spool/mail
  else
    bash_cv_mail_dir=unknown
  fi
 ])
 AC_MSG_RESULT($bash_cv_mail_dir)
 if test $bash_cv_mail_dir = "/var/mail"; then
    AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/mail")
 elif test $bash_cv_mail_dir = "/usr/mail"; then
@@ -1037,26 +1234,26 @@ AC_CACHE_VAL(bash_cv_kernel_rlimit,
 [AC_TRY_COMPILE([
 #include <sys/types.h>
 #include <sys/resource.h>
 ],
 [
   int f;
   f = RLIMIT_DATA;
 ], bash_cv_kernel_rlimit=no,
-    [AC_TRY_COMPILE([
-     #include <sys/types.h>
-     #define _KERNEL
-     #include <sys/resource.h>
-     #undef _KERNEL
-     ],
-     [
+[AC_TRY_COMPILE([
+#include <sys/types.h>
+#define _KERNEL
+#include <sys/resource.h>
+#undef _KERNEL
+],
+[
 	int f;
         f = RLIMIT_DATA;
-     ], bash_cv_kernel_rlimit=yes, bash_cv_kernel_rlimit=no)]
+], bash_cv_kernel_rlimit=yes, bash_cv_kernel_rlimit=no)]
 )])
 AC_MSG_RESULT($bash_cv_kernel_rlimit)
 if test $bash_cv_kernel_rlimit = yes; then
 AC_DEFINE(RLIMIT_NEEDS_KERNEL)
 fi
 ])
 
 AC_DEFUN(BASH_FUNC_STRCOLL,
@@ -1094,19 +1291,173 @@ char    *v[];
 	   same. */
 
         /* Exit with 1 (failure) if these two values are both > 0, since
 	   this tests whether strcoll(3) is broken with respect to strcmp(3)
 	   in the default locale. */
 	exit (r1 > 0 && r2 > 0);
 }
 ], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
-   bash_cv_func_strcoll_broken=no)
-])
-if test "$cross_compiling" = yes; then
-  AC_MSG_RESULT([$bash_cv_func_strcoll_broken assumed for cross compiling])
-else
-  AC_MSG_RESULT($bash_cv_func_strcoll_broken)
-fi
+   [AC_MSG_WARN(cannot check strcoll if cross compiling -- defaulting to no)
+    bash_cv_func_strcoll_broken=no]
+)])
+AC_MSG_RESULT($bash_cv_func_strcoll_broken)
 if test $bash_cv_func_strcoll_broken = yes; then
 AC_DEFINE(STRCOLL_BROKEN)
 fi
 ])
+
+dnl
+dnl If available, use support for large files unless the user specified
+dnl one of the CPPFLAGS, LDFLAGS, or LIBS variables (<eggert@twinsun.com>
+dnl via GNU patch 2.5)
+dnl
+AC_DEFUN(BASH_LARGE_FILE_SUPPORT,
+[AC_MSG_CHECKING(whether large file support needs explicit enabling)
+ac_getconfs=''
+ac_result=yes
+ac_set=''
+ac_shellvars='CPPFLAGS LDFLAGS LIBS'
+for ac_shellvar in $ac_shellvars; do
+  case $ac_shellvar in
+  CPPFLAGS) ac_lfsvar=LFS_CFLAGS ac_lfs64var=LFS64_CFLAGS ;;
+  *) ac_lfsvar=LFS_$ac_shellvar ac_lfs64var=LFS64_$ac_shellvar ;;
+  esac
+  eval test '"${'$ac_shellvar'+set}"' = set && ac_set=$ac_shellvar
+  (getconf $ac_lfsvar) >/dev/null 2>&1 || { ac_result=no; break; }
+  ac_getconf=`getconf $ac_lfsvar`
+  ac_getconf64=`getconf $ac_lfs64var`
+  ac_getconfs=$ac_getconfs$ac_getconf\ $ac_getconf64
+  eval ac_test_$ac_shellvar="\$ac_getconf\ \$ac_getconf64"
+done
+case "$ac_result$ac_getconfs" in
+yes) ac_result=no ;;
+esac
+case "$ac_result$ac_set" in
+yes?*) ac_result="yes, but $ac_set is already set, so use its settings"
+esac
+AC_MSG_RESULT($ac_result)
+case $ac_result in
+yes)
+  for ac_shellvar in $ac_shellvars; do
+    eval $ac_shellvar=\$ac_test_$ac_shellvar
+  done ;;
+esac
+])
+
+dnl
+dnl AC_SYS_RESTARTABLE_SYSCALLS tests only for restarted system calls
+dnl after a signal handler has been installed with signal().  Since
+dnl Bash uses sigaction() if it is available, we need to check whether
+dnl or not a signal handler installed with sigaction and SA_RESTART
+dnl causes system calls to be restarted after the signal is caught
+dnl
+AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
+[AC_REQUIRE([BASH_SIGNAL_CHECK])
+AC_CACHE_CHECK(whether posix sigaction restarts system calls by default,
+bash_cv_sys_restartable_syscalls,
+[AC_TRY_RUN(
+[/* Exit 0 (true) if wait returns something other than -1,
+   i.e. the pid of the child, which means that wait was restarted
+   after getting the signal.  */
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+#include <sys/types.h>
+#include <signal.h>
+static int caught = 0;
+void ucatch (isig) int isig; { caught = 1; }
+main ()
+{
+#if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
+  exit (1);
+#else
+  struct sigaction act, oact;
+  int i, status;
+
+  act.sa_handler = ucatch;
+  /* Might want to add SA_RESTART here, but bash's set_signal_handler
+     does not. */
+  act.sa_flags = 0;
+  sigemptyset(&act.sa_mask);
+  sigemptyset(&oact.sa_mask);
+  i = fork ();
+  /* A possible race condition here, but in practice it never happens. */
+  if (i == 0) { sleep (3); kill (getppid (), SIGINT); sleep (3); exit (0); }
+  sigaction(SIGINT, &act, &oact);
+  status = wait(&i);
+  if (status == -1) wait(&i);
+  exit (status == -1);
+#endif
+}
+], bash_cv_sys_restartable_syscalls=yes, bash_cv_sys_restartable_syscalls=no,
+   AC_MSG_WARN(cannot check restartable syscalls if cross compiling))
+])
+if test $bash_cv_sys_restartable_syscalls = yes; then
+  AC_DEFINE(HAVE_RESTARTABLE_SYSCALLS)
+fi
+])
+dnl
+dnl Check for 64-bit off_t -- used for malloc alignment
+dnl
+dnl C does not allow duplicate case labels, so the compile will fail if
+dnl sizeof(off_t) is > 4.
+dnl
+AC_DEFUN(BASH_CHECK_OFF_T_64,
+[AC_CACHE_CHECK(for 64-bit off_t, bash_cv_off_t_64,
+AC_TRY_COMPILE([
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/types.h>
+],[
+switch (0) case 0: case (sizeof (off_t) <= 4):;
+], bash_cv_off_t_64=no, bash_cv_off_t_64=yes))
+if test $bash_cv_off_t_64 = yes; then
+        AC_DEFINE(HAVE_OFF_T_64)
+fi])
+
+AC_DEFUN(BASH_STRUCT_TIMEVAL,
+[AC_MSG_CHECKING(for struct timeval in sys/time.h and time.h)
+AC_CACHE_VAL(bash_cv_struct_timeval,
+[
+AC_EGREP_HEADER(struct timeval, sys/time.h,
+		bash_cv_struct_timeval=yes,
+		AC_EGREP_HEADER(struct timeval, time.h,
+			bash_cv_struct_timeval=yes,
+			bash_cv_struct_timeval=no))
+])
+AC_MSG_RESULT($bash_cv_struct_timeval)
+if test $bash_cv_struct_timeval = yes; then
+  AC_DEFINE(HAVE_TIMEVAL)
+fi
+])
+
+AC_DEFUN(BASH_CHECK_RTSIGS,
+[AC_MSG_CHECKING(for unusable real-time signals due to large values)
+AC_CACHE_VAL(bash_cv_unusable_rtsigs,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <signal.h>
+
+#ifndef NSIG
+#  define NSIG 64
+#endif
+
+main ()
+{
+  int n_sigs = 2 * NSIG;
+#ifdef SIGRTMIN
+  int rtmin = SIGRTMIN;
+#else
+  int rtmin = 0;
+#endif
+
+  exit(rtmin < n_sigs);
+}], bash_cv_unusable_rtsigs=yes, bash_cv_unusable_rtsigs=no,
+    [AC_MSG_WARN(cannot check real-time signals if cross compiling -- defaulting to yes)
+     bash_cv_unusable_rtsigs=yes]
+)])
+AC_MSG_RESULT($bash_cv_unusable_rtsigs)
+if test $bash_cv_unusable_rtsigs = yes; then
+AC_DEFINE(UNUSABLE_RT_SIGNALS)
+fi
+])
diff --git a/readline/ansi_stdlib.h b/readline/ansi_stdlib.h
--- a/readline/ansi_stdlib.h
+++ b/readline/ansi_stdlib.h
@@ -22,16 +22,19 @@
 
 #if !defined (_STDLIB_H_)
 #define	_STDLIB_H_ 1
 
 /* String conversion functions. */
 extern int atoi ();
 extern long int atol ();
 
+extern double atof ();
+extern double strtod ();
+
 /* Memory allocation functions. */
 extern char *malloc ();
 extern char *realloc ();
 extern void free ();
 
 /* Other miscellaneous functions. */
 extern void abort ();
 extern void exit ();
diff --git a/readline/bind.c b/readline/bind.c
--- a/readline/bind.c
+++ b/readline/bind.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -37,110 +37,77 @@
 #endif /* HAVE_UNISTD_H */
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
-#include <signal.h>
 #include <errno.h>
 
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
 #include "posixstat.h"
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+#include "rlshell.h"
+#include "xmalloc.h"
+
 #if !defined (strchr) && !defined (__STDC__)
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
 
-extern int _rl_horizontal_scroll_mode;
-extern int _rl_mark_modified_lines;
-extern int _rl_bell_preference;
-extern int _rl_meta_flag;
-extern int _rl_convert_meta_chars_to_ascii;
-extern int _rl_output_meta_chars;
-extern int _rl_complete_show_all;
-extern int _rl_complete_mark_directories;
-extern int _rl_enable_keypad;
-#if defined (PAREN_MATCHING)
-extern int rl_blink_matching_paren;
-#endif /* PAREN_MATCHING */
-#if defined (VISIBLE_STATS)
-extern int rl_visible_stats;
-#endif /* VISIBLE_STATS */
-extern int rl_complete_with_tilde_expansion;
-extern int rl_completion_query_items;
-extern int rl_inhibit_completion;
-extern char *_rl_comment_begin;
-
-extern int rl_explicit_arg;
-extern int rl_editing_mode;
-extern unsigned char _rl_parsing_conditionalized_out;
-extern Keymap _rl_keymap;
-
-extern char *possible_control_prefixes[], *possible_meta_prefixes[];
-
-/* Functions imported from funmap.c */
-extern char **rl_funmap_names ();
-extern int rl_add_funmap_entry ();
-
-/* Functions imported from util.c */
-extern char *_rl_strindex ();
-
-/* Functions imported from shell.c */
-extern char *get_env_value ();
-
 /* Variables exported by this file. */
 Keymap rl_binding_keymap;
 
-/* Forward declarations */
-void rl_set_keymap_from_edit_mode ();
+static int _rl_read_init_file __P((const char *, int));
+static int glean_key_from_name __P((char *));
+static int substring_member_of_array __P((char *, const char **));
 
-static int glean_key_from_name ();
-static int substring_member_of_array ();
+static int currently_reading_init_file;
 
-extern char *xmalloc (), *xrealloc ();
+/* used only in this file */
+static int _rl_prefer_visible_bell = 1;
 
 /* **************************************************************** */
 /*								    */
 /*			Binding keys				    */
 /*								    */
 /* **************************************************************** */
 
-/* rl_add_defun (char *name, Function *function, int key)
+/* rl_add_defun (char *name, rl_command_func_t *function, int key)
    Add NAME to the list of named functions.  Make FUNCTION be the function
    that gets called.  If KEY is not -1, then bind it. */
 int
 rl_add_defun (name, function, key)
-     char *name;
-     Function *function;
+     const char *name;
+     rl_command_func_t *function;
      int key;
 {
   if (key != -1)
     rl_bind_key (key, function);
   rl_add_funmap_entry (name, function);
   return 0;
 }
 
 /* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
 int
 rl_bind_key (key, function)
      int key;
-     Function *function;
+     rl_command_func_t *function;
 {
   if (key < 0)
     return (key);
 
   if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
     {
       if (_rl_keymap[ESC].type == ISKMAP)
 	{
@@ -161,17 +128,17 @@ rl_bind_key (key, function)
   return (0);
 }
 
 /* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
    KEY. */
 int
 rl_bind_key_in_map (key, function, map)
      int key;
-     Function *function;
+     rl_command_func_t *function;
      Keymap map;
 {
   int result;
   Keymap oldmap;
 
   oldmap = _rl_keymap;
   _rl_keymap = map;
   result = rl_bind_key (key, function);
@@ -180,47 +147,79 @@ rl_bind_key_in_map (key, function, map)
 }
 
 /* Make KEY do nothing in the currently selected keymap.
    Returns non-zero in case of error. */
 int
 rl_unbind_key (key)
      int key;
 {
-  return (rl_bind_key (key, (Function *)NULL));
+  return (rl_bind_key (key, (rl_command_func_t *)NULL));
 }
 
 /* Make KEY do nothing in MAP.
    Returns non-zero in case of error. */
 int
 rl_unbind_key_in_map (key, map)
      int key;
      Keymap map;
 {
-  return (rl_bind_key_in_map (key, (Function *)NULL, map));
+  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
+}
+
+/* Unbind all keys bound to FUNCTION in MAP. */
+int
+rl_unbind_function_in_map (func, map)
+     rl_command_func_t *func;
+     Keymap map;
+{
+  register int i, rval;
+
+  for (i = rval = 0; i < KEYMAP_SIZE; i++)
+    {
+      if (map[i].type == ISFUNC && map[i].function == func)
+	{
+	  map[i].function = (rl_command_func_t *)NULL;
+	  rval = 1;
+	}
+    }
+  return rval;
+}
+
+int
+rl_unbind_command_in_map (command, map)
+     const char *command;
+     Keymap map;
+{
+  rl_command_func_t *func;
+
+  func = rl_named_function (command);
+  if (func == 0)
+    return 0;
+  return (rl_unbind_function_in_map (func, map));
 }
 
 /* Bind the key sequence represented by the string KEYSEQ to
    FUNCTION.  This makes new keymaps as necessary.  The initial
    place to do bindings is in MAP. */
 int
 rl_set_key (keyseq, function, map)
-     char *keyseq;
-     Function *function;
+     const char *keyseq;
+     rl_command_func_t *function;
      Keymap map;
 {
   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
 }
 
 /* Bind the key sequence represented by the string KEYSEQ to
    the string of characters MACRO.  This makes new keymaps as
    necessary.  The initial place to do bindings is in MAP. */
 int
 rl_macro_bind (keyseq, macro, map)
-     char *keyseq, *macro;
+     const char *keyseq, *macro;
      Keymap map;
 {
   char *macro_keys;
   int macro_keys_len;
 
   macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);
 
   if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
@@ -235,17 +234,18 @@ rl_macro_bind (keyseq, macro, map)
 /* Bind the key sequence represented by the string KEYSEQ to
    the arbitrary pointer DATA.  TYPE says what kind of data is
    pointed to by DATA, right now this can be a function (ISFUNC),
    a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
    as necessary.  The initial place to do bindings is in MAP. */
 int
 rl_generic_bind (type, keyseq, data, map)
      int type;
-     char *keyseq, *data;
+     const char *keyseq;
+     char *data;
      Keymap map;
 {
   char *keys;
   int keys_len;
   register int i;
 
   /* If no keys to bind to, exit right away. */
   if (!keyseq || !*keyseq)
@@ -305,63 +305,117 @@ rl_generic_bind (type, keyseq, data, map
   return 0;
 }
 
 /* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
    an array of characters.  LEN gets the final length of ARRAY.  Return
    non-zero if there was an error parsing SEQ. */
 int
 rl_translate_keyseq (seq, array, len)
-     char *seq, *array;
+     const char *seq;
+     char *array;
      int *len;
 {
-  register int i, c, l;
+  register int i, c, l, temp;
 
   for (i = l = 0; c = seq[i]; i++)
     {
       if (c == '\\')
 	{
 	  c = seq[++i];
 
 	  if (c == 0)
 	    break;
 
-	  if (((c == 'C' || c == 'M') && seq[i + 1] == '-') || (c == 'e'))
+	  /* Handle \C- and \M- prefixes. */
+	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
 	    {
 	      /* Handle special case of backwards define. */
 	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
 		{
 		  array[l++] = ESC;
 		  i += 5;
 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
-		  if (!seq[i])
+		  if (seq[i] == '\0')
 		    i--;
-		  continue;
 		}
-
-	      switch (c)
+	      else if (c == 'M')
 		{
-		case 'M':
 		  i++;
 		  array[l++] = ESC;	/* XXX */
-		  break;
-
-		case 'C':
+		}
+	      else if (c == 'C')
+		{
 		  i += 2;
 		  /* Special hack for C-?... */
 		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-		  break;
+		}
+	      continue;
+	    }	      
 
-		case 'e':
-		  array[l++] = ESC;
-		}
+	  /* Translate other backslash-escaped characters.  These are the
+	     same escape sequences that bash's `echo' and `printf' builtins
+	     handle, with the addition of \d -> RUBOUT.  A backslash
+	     preceding a character that is not special is stripped. */
+	  switch (c)
+	    {
+	    case 'a':
+	      array[l++] = '\007';
+	      break;
+	    case 'b':
+	      array[l++] = '\b';
+	      break;
+	    case 'd':
+	      array[l++] = RUBOUT;	/* readline-specific */
+	      break;
+	    case 'e':
+	      array[l++] = ESC;
+	      break;
+	    case 'f':
+	      array[l++] = '\f';
+	      break;
+	    case 'n':
+	      array[l++] = NEWLINE;
+	      break;
+	    case 'r':
+	      array[l++] = RETURN;
+	      break;
+	    case 't':
+	      array[l++] = TAB;
+	      break;
+	    case 'v':
+	      array[l++] = 0x0B;
+	      break;
+	    case '\\':
+	      array[l++] = '\\';
+	      break;
+	    case '0': case '1': case '2': case '3':
+	    case '4': case '5': case '6': case '7':
+	      i++;
+	      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)
+	        c = (c * 8) + OCTVALUE (seq[i]);
+	      i--;	/* auto-increment in for loop */
+	      array[l++] = c % (largest_char + 1);
+	      break;
+	    case 'x':
+	      i++;
+	      for (temp = 3, c = 0; isxdigit (seq[i]) && temp--; i++)
+	        c = (c * 16) + HEXVALUE (seq[i]);
+	      if (temp == 3)
+	        c = 'x';
+	      i--;	/* auto-increment in for loop */
+	      array[l++] = c % (largest_char + 1);
+	      break;
+	    default:	/* backslashes before non-special chars just add the char */
+	      array[l++] = c;
+	      break;	/* the backslash is stripped */
+	    }
+	  continue;
+	}
 
-	      continue;
-	    }
-	}
       array[l++] = c;
     }
 
   *len = l;
   array[l] = '\0';
   return (0);
 }
 
@@ -456,38 +510,38 @@ static char *
     }
   *r = '\0';
   return ret;
 }
 
 /* Return a pointer to the function that STRING represents.
    If STRING doesn't have a matching function, then a NULL pointer
    is returned. */
-Function *
+rl_command_func_t *
 rl_named_function (string)
-     char *string;
+     const char *string;
 {
   register int i;
 
   rl_initialize_funmap ();
 
   for (i = 0; funmap[i]; i++)
     if (_rl_stricmp (funmap[i]->name, string) == 0)
       return (funmap[i]->function);
-  return ((Function *)NULL);
+  return ((rl_command_func_t *)NULL);
 }
 
 /* Return the function (or macro) definition which would be invoked via
    KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
    used.  TYPE, if non-NULL, is a pointer to an int which will receive the
    type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
    or ISMACR (macro). */
-Function *
+rl_command_func_t *
 rl_function_of_keyseq (keyseq, map, type)
-     char *keyseq;
+     const char *keyseq;
      Keymap map;
      int *type;
 {
   register int i;
 
   if (!map)
     map = _rl_keymap;
 
@@ -528,104 +582,170 @@ rl_function_of_keyseq (keyseq, map, type
       else
 	{
 	  if (type)
 	    *type = map[ic].type;
 
 	  return (map[ic].function);
 	}
     }
-  return ((Function *) NULL);
+  return ((rl_command_func_t *) NULL);
 }
 
 /* The last key bindings file read. */
 static char *last_readline_init_file = (char *)NULL;
 
 /* The file we're currently reading key bindings from. */
-static char *current_readline_init_file;
+static const char *current_readline_init_file;
+static int current_readline_init_include_level;
 static int current_readline_init_lineno;
 
+/* Read FILENAME into a locally-allocated buffer and return the buffer.
+   The size of the buffer is returned in *SIZEP.  Returns NULL if any
+   errors were encountered. */
+static char *
+_rl_read_file (filename, sizep)
+     char *filename;
+     size_t *sizep;
+{
+  struct stat finfo;
+  size_t file_size;
+  char *buffer;
+  int i, file;
+
+  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
+    return ((char *)NULL);
+
+  file_size = (size_t)finfo.st_size;
+
+  /* check for overflow on very large files */
+  if (file_size != finfo.st_size || file_size + 1 < file_size)
+    {
+      if (file >= 0)
+	close (file);
+#if defined (EFBIG)
+      errno = EFBIG;
+#endif
+      return ((char *)NULL);
+    }
+
+  /* Read the file into BUFFER. */
+  buffer = (char *)xmalloc (file_size + 1);
+  i = read (file, buffer, file_size);
+  close (file);
+
+#if 0
+  if (i < file_size)
+#else
+  if (i < 0)
+#endif
+    {
+      free (buffer);
+      return ((char *)NULL);
+    }
+
+#if 0
+  buffer[file_size] = '\0';
+  if (sizep)
+    *sizep = file_size;
+#else
+  buffer[i] = '\0';
+  if (sizep)
+    *sizep = i;
+#endif
+
+  return (buffer);
+}
+
 /* Re-read the current keybindings file. */
 int
 rl_re_read_init_file (count, ignore)
      int count, ignore;
 {
   int r;
-  r = rl_read_init_file ((char *)NULL);
+  r = rl_read_init_file ((const char *)NULL);
   rl_set_keymap_from_edit_mode ();
   return r;
 }
 
 /* Do key bindings from a file.  If FILENAME is NULL it defaults
    to the first non-null filename from this list:
      1. the filename used for the previous call
      2. the value of the shell variable `INPUTRC'
      3. ~/.inputrc
    If the file existed and could be opened and read, 0 is returned,
    otherwise errno is returned. */
 int
 rl_read_init_file (filename)
-     char *filename;
+     const char *filename;
 {
-  register int i;
-  char *buffer, *openname, *line, *end;
-  struct stat finfo;
-  int file;
-
   /* Default the filename. */
   if (filename == 0)
     {
       filename = last_readline_init_file;
       if (filename == 0)
-        filename = get_env_value ("INPUTRC");
+        filename = sh_get_env_value ("INPUTRC");
       if (filename == 0)
 	filename = DEFAULT_INPUTRC;
     }
 
   if (*filename == 0)
     filename = DEFAULT_INPUTRC;
 
-  current_readline_init_file = filename;
-  openname = tilde_expand (filename);
+#if defined (__MSDOS__)
+  if (_rl_read_init_file (filename, 0) == 0)
+    return 0;
+  filename = "~/_inputrc";
+#endif
+  return (_rl_read_init_file (filename, 0));
+}
 
-  if ((stat (openname, &finfo) < 0) ||
-      (file = open (openname, O_RDONLY, 0666)) < 0)
+static int
+_rl_read_init_file (filename, include_level)
+     const char *filename;
+     int include_level;
+{
+  register int i;
+  char *buffer, *openname, *line, *end;
+  size_t file_size;
+
+  current_readline_init_file = filename;
+  current_readline_init_include_level = include_level;
+
+  openname = tilde_expand (filename);
+  buffer = _rl_read_file (openname, &file_size);
+  free (openname);
+
+  if (buffer == 0)
+    return (errno);
+  
+  if (include_level == 0 && filename != last_readline_init_file)
     {
-      free (openname);
-      return (errno);
-    }
-  else
-    free (openname);
-
-  if (filename != last_readline_init_file)
-    {
-      if (last_readline_init_file)
-	free (last_readline_init_file);
-
+      FREE (last_readline_init_file);
       last_readline_init_file = savestring (filename);
     }
 
-  /* Read the file into BUFFER. */
-  buffer = (char *)xmalloc ((int)finfo.st_size + 1);
-  i = read (file, buffer, finfo.st_size);
-  close (file);
-
-  if (i != finfo.st_size)
-    return (errno);
+  currently_reading_init_file = 1;
 
   /* Loop over the lines in the file.  Lines that start with `#' are
      comments; all other lines are commands for readline initialization. */
   current_readline_init_lineno = 1;
   line = buffer;
-  end = buffer + finfo.st_size;
+  end = buffer + file_size;
   while (line < end)
     {
       /* Find the end of this line. */
       for (i = 0; line + i != end && line[i] != '\n'; i++);
 
+#if defined (__CYGWIN__)
+      /* ``Be liberal in what you accept.'' */
+      if (line[i] == '\n' && line[i-1] == '\r')
+	line[i - 1] = '\0';
+#endif
+
       /* Mark end of line. */
       line[i] = '\0';
 
       /* Skip leading whitespace. */
       while (*line && whitespace (*line))
         {
 	  line++;
 	  i--;
@@ -634,39 +754,54 @@ rl_read_init_file (filename)
       /* If the line is not a comment, then parse it. */
       if (*line && *line != '#')
 	rl_parse_and_bind (line);
 
       /* Move to the next line. */
       line += i + 1;
       current_readline_init_lineno++;
     }
+
   free (buffer);
+  currently_reading_init_file = 0;
   return (0);
 }
 
 static void
 _rl_init_file_error (msg)
      char *msg;
 {
-  fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
- 		   current_readline_init_lineno,
- 		   msg);
+  if (currently_reading_init_file)
+    fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
+		     current_readline_init_lineno, msg);
+  else
+    fprintf (stderr, "readline: %s\n", msg);
 }
 
 /* **************************************************************** */
 /*								    */
 /*			Parser Directives       		    */
 /*								    */
 /* **************************************************************** */
 
+typedef int _rl_parser_func_t __P((char *));
+
+/* Things that mean `Control'. */
+const char *_rl_possible_control_prefixes[] = {
+  "Control-", "C-", "CTRL-", (const char *)NULL
+};
+
+const char *_rl_possible_meta_prefixes[] = {
+  "Meta", "M-", (const char *)NULL
+};
+
 /* Conditionals. */
 
 /* Calling programs set this to have their argv[0]. */
-char *rl_readline_name = "other";
+const char *rl_readline_name = "other";
 
 /* Stack of previous values of parsing_conditionalized_out. */
 static unsigned char *if_stack = (unsigned char *)NULL;
 static int if_stack_depth;
 static int if_stack_size;
 
 /* Push _rl_parsing_conditionalized_out, and set parser state based
    on ARGS. */
@@ -692,17 +827,17 @@ parser_if (args)
     return 0;
 
   /* Isolate first argument. */
   for (i = 0; args[i] && !whitespace (args[i]); i++);
 
   if (args[i])
     args[i++] = '\0';
 
-  /* Handle "if term=foo" and "if mode=emacs" constructs.  If this
+  /* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this
      isn't term=foo, or mode=emacs, then check to see if the first
      word in ARGS is the same as the value stored in rl_readline_name. */
   if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
     {
       char *tem, *tname;
 
       /* Terminals like "aaa-60" are equivalent to "aaa". */
       tname = savestring (rl_terminal_name);
@@ -744,19 +879,19 @@ parser_if (args)
 
 /* Invert the current parser state if there is anything on the stack. */
 static int
 parser_else (args)
      char *args;
 {
   register int i;
 
-  if (!if_stack_depth)
+  if (if_stack_depth == 0)
     {
-      /* Error message? */
+      _rl_init_file_error ("$else found without matching $if");
       return 0;
     }
 
   /* Check the previous (n - 1) levels of the stack to make sure that
      we haven't previously turned off parsing. */
   for (i = 0; i < if_stack_depth - 1; i++)
     if (if_stack[i] == 1)
       return 0;
@@ -770,31 +905,57 @@ parser_else (args)
    _rl_parsing_conditionalized_out from the stack. */
 static int
 parser_endif (args)
      char *args;
 {
   if (if_stack_depth)
     _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
   else
-    {
-      /* *** What, no error message? *** */
-    }
+    _rl_init_file_error ("$endif without matching $if");
   return 0;
 }
 
+static int
+parser_include (args)
+     char *args;
+{
+  const char *old_init_file;
+  char *e;
+  int old_line_number, old_include_level, r;
+
+  if (_rl_parsing_conditionalized_out)
+    return (0);
+
+  old_init_file = current_readline_init_file;
+  old_line_number = current_readline_init_lineno;
+  old_include_level = current_readline_init_include_level;
+
+  e = strchr (args, '\n');
+  if (e)
+    *e = '\0';
+  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
+
+  current_readline_init_file = old_init_file;
+  current_readline_init_lineno = old_line_number;
+  current_readline_init_include_level = old_include_level;
+
+  return r;
+}
+  
 /* Associate textual names with actual functions. */
 static struct {
-  char *name;
-  Function *function;
+  const char *name;
+  _rl_parser_func_t *function;
 } parser_directives [] = {
   { "if", parser_if },
   { "endif", parser_endif },
   { "else", parser_else },
-  { (char *)0x0, (Function *)0x0 }
+  { "include", parser_include },
+  { (char *)0x0, (_rl_parser_func_t *)0x0 }
 };
 
 /* Handle a parser directive.  STATEMENT is the line of the directive
    without any leading `$'. */
 static int
 handle_parser_directive (statement)
      char *statement;
 {
@@ -820,17 +981,18 @@ handle_parser_directive (statement)
   /* Lookup the command, and act on it. */
   for (i = 0; parser_directives[i].name; i++)
     if (_rl_stricmp (directive, parser_directives[i].name) == 0)
       {
 	(*parser_directives[i].function) (args);
 	return (0);
       }
 
-  /* *** Should an error message be output? */
+  /* display an error message about the unknown parser directive */
+  _rl_init_file_error ("unknown parser directive");
   return (1);
 }
 
 /* Read the binding command from STRING and perform it.
    A key binding command looks like: Keyname: function-name\0,
    a variable binding command looks like: set variable value.
    A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
 int
@@ -935,20 +1097,19 @@ rl_parse_and_bind (string)
      to the matching delimiter.  We allow the backslash to quote the
      delimiter characters in the macro body. */
   /* This code exists to allow whitespace in macro expansions, which
      would otherwise be gobbled up by the next `for' loop.*/
   /* XXX - it may be desirable to allow backslash quoting only if " is
      the quoted string delimiter, like the shell. */
   if (*funname == '\'' || *funname == '"')
     {
-      int delimiter = string[i++];
-      int passc = 0;
+      int delimiter = string[i++], passc;
 
-      for (; c = string[i]; i++)
+      for (passc = 0; c = string[i]; i++)
 	{
 	  if (passc)
 	    {
 	      passc = 0;
 	      continue;
 	    }
 
 	  if (c == '\\')
@@ -976,21 +1137,21 @@ rl_parse_and_bind (string)
     {
       return 0;
     }
 
   /* If this is a new-style key-binding, then do the binding with
      rl_set_key ().  Otherwise, let the older code deal with it. */
   if (*string == '"')
     {
-      char *seq = xmalloc (1 + strlen (string));
-      register int j, k = 0;
-      int passc = 0;
+      char *seq;
+      register int j, k, passc;
 
-      for (j = 1; string[j]; j++)
+      seq = xmalloc (1 + strlen (string));
+      for (j = 1, k = passc = 0; string[j]; j++)
 	{
 	  /* Allow backslash to quote characters, but leave them in place.
 	     This allows a string to end with a backslash quoting another
 	     backslash, or with a backslash quoting a double quote.  The
 	     backslashes are left in place for rl_translate_keyseq (). */
 	  if (passc || (string[j] == '\\'))
 	    {
 	      seq[k++] = string[j];
@@ -1028,20 +1189,20 @@ rl_parse_and_bind (string)
   if (!kname)
     kname = string;
   else
     kname++;
 
   key = glean_key_from_name (kname);
 
   /* Add in control and meta bits. */
-  if (substring_member_of_array (string, possible_control_prefixes))
+  if (substring_member_of_array (string, _rl_possible_control_prefixes))
     key = CTRL (_rl_to_upper (key));
 
-  if (substring_member_of_array (string, possible_meta_prefixes))
+  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
     key = META (key);
 
   /* Temporary.  Handle old-style keyname with macro-binding. */
   if (*funname == '\'' || *funname == '"')
     {
       unsigned char useq[2];
       int fl = strlen (funname);
 
@@ -1066,139 +1227,290 @@ rl_parse_and_bind (string)
     rl_bind_key (key, rl_named_function (funname));
   return 0;
 }
 
 /* Simple structure for boolean readline variables (i.e., those that can
    have one of two values; either "On" or 1 for truth, or "Off" or 0 for
    false. */
 
+#define V_SPECIAL	0x1
+
 static struct {
-  char *name;
+  const char *name;
   int *value;
+  int flags;
 } boolean_varlist [] = {
-#if defined (PAREN_MATCHING)
-  { "blink-matching-paren",	&rl_blink_matching_paren },
-#endif
-  { "convert-meta",		&_rl_convert_meta_chars_to_ascii },
-  { "disable-completion",	&rl_inhibit_completion },
-  { "enable-keypad",		&_rl_enable_keypad },
-  { "expand-tilde",		&rl_complete_with_tilde_expansion },
-  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode },
-  { "input-meta",		&_rl_meta_flag },
-  { "mark-directories",		&_rl_complete_mark_directories },
-  { "mark-modified-lines",	&_rl_mark_modified_lines },
-  { "meta-flag",		&_rl_meta_flag },
-  { "output-meta",		&_rl_output_meta_chars },
-  { "show-all-if-ambiguous",	&_rl_complete_show_all },
+  { "blink-matching-paren",	&rl_blink_matching_paren,	V_SPECIAL },
+  { "completion-ignore-case",	&_rl_completion_case_fold,	0 },
+  { "convert-meta",		&_rl_convert_meta_chars_to_ascii, 0 },
+  { "disable-completion",	&rl_inhibit_completion,		0 },
+  { "enable-keypad",		&_rl_enable_keypad,		0 },
+  { "expand-tilde",		&rl_complete_with_tilde_expansion, 0 },
+  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode,	0 },
+  { "input-meta",		&_rl_meta_flag,			0 },
+  { "mark-directories",		&_rl_complete_mark_directories,	0 },
+  { "mark-modified-lines",	&_rl_mark_modified_lines,	0 },
+  { "meta-flag",		&_rl_meta_flag,			0 },
+  { "output-meta",		&_rl_output_meta_chars,		0 },
+  { "prefer-visible-bell",	&_rl_prefer_visible_bell,	V_SPECIAL },
+  { "print-completions-horizontally", &_rl_print_completions_horizontally, 0 },
+  { "show-all-if-ambiguous",	&_rl_complete_show_all,		0 },
 #if defined (VISIBLE_STATS)
-  { "visible-stats",		&rl_visible_stats },
+  { "visible-stats",		&rl_visible_stats,		0 },
 #endif /* VISIBLE_STATS */
   { (char *)NULL, (int *)NULL }
 };
 
-int
-rl_variable_bind (name, value)
-     char *name, *value;
+static int
+find_boolean_var (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; boolean_varlist[i].name; i++)
+    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
+      return i;
+  return -1;
+}
+
+/* Hooks for handling special boolean variables, where a
+   function needs to be called or another variable needs
+   to be changed when they're changed. */
+static void
+hack_special_boolean_var (i)
+     int i;
+{
+  const char *name;
+
+  name = boolean_varlist[i].name;
+
+  if (_rl_stricmp (name, "blink-matching-paren") == 0)
+    _rl_enable_paren_matching (rl_blink_matching_paren);
+  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
+    {
+      if (_rl_prefer_visible_bell)
+	_rl_bell_preference = VISIBLE_BELL;
+      else
+	_rl_bell_preference = AUDIBLE_BELL;
+    }
+}
+
+typedef int _rl_sv_func_t __P((const char *));
+
+/* These *must* correspond to the array indices for the appropriate
+   string variable.  (Though they're not used right now.) */
+#define V_BELLSTYLE	0
+#define V_COMBEGIN	1
+#define V_EDITMODE	2
+#define V_ISRCHTERM	3
+#define V_KEYMAP	4
+
+#define	V_STRING	1
+#define V_INT		2
+
+/* Forward declarations */
+static int sv_bell_style __P((const char *));
+static int sv_combegin __P((const char *));
+static int sv_compquery __P((const char *));
+static int sv_editmode __P((const char *));
+static int sv_isrchterm __P((const char *));
+static int sv_keymap __P((const char *));
+
+static struct {
+  const char *name;
+  int flags;
+  _rl_sv_func_t *set_func;
+} string_varlist[] = {
+  { "bell-style",	V_STRING,	sv_bell_style },
+  { "comment-begin",	V_STRING,	sv_combegin },
+  { "completion-query-items", V_INT,	sv_compquery },
+  { "editing-mode",	V_STRING,	sv_editmode },
+  { "isearch-terminators", V_STRING,	sv_isrchterm },
+  { "keymap",		V_STRING,	sv_keymap },
+  { (char *)NULL,	0 }
+};
+
+static int
+find_string_var (name)
+     char *name;
 {
   register int i;
 
-  /* Check for simple variables first. */
-  for (i = 0; boolean_varlist[i].name; i++)
-    {
-      if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
-	{
-	  /* A variable is TRUE if the "value" is "on", "1" or "". */
-	  *boolean_varlist[i].value = *value == 0 ||
-	  			      _rl_stricmp (value, "on") == 0 ||
-				      (value[0] == '1' && value[1] == '\0');
-	  return 0;
-	}
-    }
-
-  /* Not a boolean variable, so check for specials. */
+  for (i = 0; string_varlist[i].name; i++)
+    if (_rl_stricmp (name, string_varlist[i].name) == 0)
+      return i;
+  return -1;
+}
 
-  /* Editing mode change? */
-  if (_rl_stricmp (name, "editing-mode") == 0)
+/* A boolean value that can appear in a `set variable' command is true if
+   the value is null or empty, `on' (case-insenstive), or "1".  Any other
+   values result in 0 (false). */
+static int
+bool_to_int (value)
+     char *value;
+{
+  return (value == 0 || *value == '\0' ||
+		(_rl_stricmp (value, "on") == 0) ||
+		(value[0] == '1' && value[1] == '\0'));
+}
+
+int
+rl_variable_bind (name, value)
+     const char *name, *value;
+{
+  register int i;
+  int	v;
+
+  /* Check for simple variables first. */
+  i = find_boolean_var (name);
+  if (i >= 0)
     {
-      if (_rl_strnicmp (value, "vi", 2) == 0)
-	{
-#if defined (VI_MODE)
-	  _rl_keymap = vi_insertion_keymap;
-	  rl_editing_mode = vi_mode;
-#endif /* VI_MODE */
-	}
-      else if (_rl_strnicmp (value, "emacs", 5) == 0)
-	{
-	  _rl_keymap = emacs_standard_keymap;
-	  rl_editing_mode = emacs_mode;
-	}
+      *boolean_varlist[i].value = bool_to_int (value);
+      if (boolean_varlist[i].flags & V_SPECIAL)
+	hack_special_boolean_var (i);
+      return 0;
     }
 
-  /* Comment string change? */
-  else if (_rl_stricmp (name, "comment-begin") == 0)
+  i = find_string_var (name);
+
+  /* For the time being, unknown variable names or string names without a
+     handler function are simply ignored. */
+  if (i < 0 || string_varlist[i].set_func == 0)
+    return 0;
+
+  v = (*string_varlist[i].set_func) (value);
+  return v;
+}
+
+static int
+sv_editmode (value)
+     const char *value;
+{
+  if (_rl_strnicmp (value, "vi", 2) == 0)
     {
-      if (*value)
-	{
-	  if (_rl_comment_begin)
-	    free (_rl_comment_begin);
-
-	  _rl_comment_begin = savestring (value);
-	}
+#if defined (VI_MODE)
+      _rl_keymap = vi_insertion_keymap;
+      rl_editing_mode = vi_mode;
+#endif /* VI_MODE */
+      return 0;
     }
-  else if (_rl_stricmp (name, "completion-query-items") == 0)
-    {
-      int nval = 100;
-      if (*value)
-	{
-	  nval = atoi (value);
-	  if (nval < 0)
-	    nval = 0;
-	}
-      rl_completion_query_items = nval;
-    }
-  else if (_rl_stricmp (name, "keymap") == 0)
+  else if (_rl_strnicmp (value, "emacs", 5) == 0)
     {
-      Keymap kmap;
-      kmap = rl_get_keymap_by_name (value);
-      if (kmap)
-        rl_set_keymap (kmap);
+      _rl_keymap = emacs_standard_keymap;
+      rl_editing_mode = emacs_mode;
+      return 0;
     }
-  else if (_rl_stricmp (name, "bell-style") == 0)
+  return 1;
+}
+
+static int
+sv_combegin (value)
+     const char *value;
+{
+  if (value && *value)
     {
-      if (!*value)
-        _rl_bell_preference = AUDIBLE_BELL;
-      else
-        {
-          if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
-            _rl_bell_preference = NO_BELL;
-          else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
-            _rl_bell_preference = AUDIBLE_BELL;
-          else if (_rl_stricmp (value, "visible") == 0)
-            _rl_bell_preference = VISIBLE_BELL;
-        }
+      FREE (_rl_comment_begin);
+      _rl_comment_begin = savestring (value);
+      return 0;
     }
-  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
+  return 1;
+}
+
+static int
+sv_compquery (value)
+     const char *value;
+{
+  int nval = 100;
+
+  if (value && *value)
     {
-      /* Backwards compatibility. */
-      if (*value && (_rl_stricmp (value, "on") == 0 ||
-		     (*value == '1' && !value[1])))
-        _rl_bell_preference = VISIBLE_BELL;
-      else
-        _rl_bell_preference = AUDIBLE_BELL;
+      nval = atoi (value);
+      if (nval < 0)
+	nval = 0;
     }
-
+  rl_completion_query_items = nval;
   return 0;
 }
 
+static int
+sv_keymap (value)
+     const char *value;
+{
+  Keymap kmap;
+
+  kmap = rl_get_keymap_by_name (value);
+  if (kmap)
+    {
+      rl_set_keymap (kmap);
+      return 0;
+    }
+  return 1;
+}
+
+#define _SET_BELL(v)	do { _rl_bell_preference = v; return 0; } while (0)
+
+static int
+sv_bell_style (value)
+     const char *value;
+{
+  if (value == 0 || *value == '\0')
+    _SET_BELL (AUDIBLE_BELL);
+  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
+    _SET_BELL (NO_BELL);
+  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
+    _SET_BELL (AUDIBLE_BELL);
+  else if (_rl_stricmp (value, "visible") == 0)
+    _SET_BELL (VISIBLE_BELL);
+  else
+    return 1;
+}
+#undef _SET_BELL
+
+static int
+sv_isrchterm (value)
+     const char *value;
+{
+  int beg, end, delim;
+  char *v;
+
+  if (value == 0)
+    return 1;
+
+  /* Isolate the value and translate it into a character string. */
+  v = savestring (value);
+  FREE (_rl_isearch_terminators);
+  if (v[0] == '"' || v[0] == '\'')
+    {
+      delim = v[0];
+      for (beg = end = 1; v[end] && v[end] != delim; end++)
+	;
+    }
+  else
+    {
+      for (beg = end = 0; whitespace (v[end]) == 0; end++)
+	;
+    }
+
+  v[end] = '\0';
+
+  /* The value starts at v + beg.  Translate it into a character string. */
+  _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
+  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
+  _rl_isearch_terminators[end] = '\0';
+
+  free (v);
+  return 0;
+}
+      
 /* Return the character which matches NAME.
    For example, `Space' returns ' '. */
 
 typedef struct {
-  char *name;
+  const char *name;
   int value;
 } assoc_list;
 
 static assoc_list name_key_alist[] = {
   { "DEL", 0x7f },
   { "ESC", '\033' },
   { "Escape", '\033' },
   { "LFD", '\n' },
@@ -1222,17 +1534,17 @@ glean_key_from_name (name)
     if (_rl_stricmp (name, name_key_alist[i].name) == 0)
       return (name_key_alist[i].value);
 
   return (*(unsigned char *)name);	/* XXX was return (*name) */
 }
 
 /* Auxiliary functions to manage keymaps. */
 static struct {
-  char *name;
+  const char *name;
   Keymap map;
 } keymap_names[] = {
   { "emacs", emacs_standard_keymap },
   { "emacs-standard", emacs_standard_keymap },
   { "emacs-meta", emacs_meta_keymap },
   { "emacs-ctlx", emacs_ctlx_keymap },
 #if defined (VI_MODE)
   { "vi", vi_movement_keymap },
@@ -1240,34 +1552,34 @@ static struct {
   { "vi-command", vi_movement_keymap },
   { "vi-insert", vi_insertion_keymap },
 #endif /* VI_MODE */
   { (char *)0x0, (Keymap)0x0 }
 };
 
 Keymap
 rl_get_keymap_by_name (name)
-     char *name;
+     const char *name;
 {
   register int i;
 
   for (i = 0; keymap_names[i].name; i++)
     if (strcmp (name, keymap_names[i].name) == 0)
       return (keymap_names[i].map);
   return ((Keymap) NULL);
 }
 
 char *
 rl_get_keymap_name (map)
      Keymap map;
 {
   register int i;
   for (i = 0; keymap_names[i].name; i++)
     if (map == keymap_names[i].map)
-      return (keymap_names[i].name);
+      return ((char *)keymap_names[i].name);
   return ((char *)NULL);
 }
   
 void
 rl_set_keymap (map)
      Keymap map;
 {
   if (map)
@@ -1315,17 +1627,17 @@ rl_get_keymap_name_from_edit_mode ()
    is always printed to rl_outstream, and in such a way that it can
    be read back in (i.e., passed to rl_parse_and_bind (). */
 
 /* Print the names of functions known to Readline. */
 void
 rl_list_funmap_names ()
 {
   register int i;
-  char **funmap_names;
+  const char **funmap_names;
 
   funmap_names = rl_funmap_names ();
 
   if (!funmap_names)
     return;
 
   for (i = 0; funmap_names[i]; i++)
     fprintf (rl_outstream, "%s\n", funmap_names[i]);
@@ -1378,32 +1690,44 @@ static char *
   if (CTRL_CHAR (c))
     {
       keyname[i++] = '\\';
       keyname[i++] = 'C';
       keyname[i++] = '-';
       c = _rl_to_lower (UNCTRL (c));
     }
 
+  /* XXX experimental code.  Turn the characters that are not ASCII or
+     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
+     This changes C. */
+  if (c >= 128 && c <= 159)
+    {
+      keyname[i++] = '\\';
+      keyname[i++] = '2';
+      c -= 128;
+      keyname[i++] = (c / 8) + '0';
+      c = (c % 8) + '0';
+    }
+
   /* Now, if the character needs to be quoted with a backslash, do that. */
   if (c == '\\' || c == '"')
     keyname[i++] = '\\';
 
   /* Now add the key, terminate the string, and return it. */
   keyname[i++] = (char) c;
   keyname[i] = '\0';
 
   return keyname;
 }
 
 /* Return a NULL terminated array of strings which represent the key
    sequences that are used to invoke FUNCTION in MAP. */
 char **
 rl_invoking_keyseqs_in_map (function, map)
-     Function *function;
+     rl_command_func_t *function;
      Keymap map;
 {
   register int key;
   char **result;
   int result_index, result_size;
 
   result = (char **)NULL;
   result_index = result_size = 0;
@@ -1493,39 +1817,39 @@ rl_invoking_keyseqs_in_map (function, ma
     }
   return (result);
 }
 
 /* Return a NULL terminated array of strings which represent the key
    sequences that can be used to invoke FUNCTION using the current keymap. */
 char **
 rl_invoking_keyseqs (function)
-     Function *function;
+     rl_command_func_t *function;
 {
   return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
 }
 
 /* Print all of the functions and their bindings to rl_outstream.  If
    PRINT_READABLY is non-zero, then print the output in such a way
    that it can be read back in. */
 void
 rl_function_dumper (print_readably)
      int print_readably;
 {
   register int i;
-  char **names;
-  char *name;
+  const char **names;
+  const char *name;
 
   names = rl_funmap_names ();
 
   fprintf (rl_outstream, "\n");
 
   for (i = 0; name = names[i]; i++)
     {
-      Function *function;
+      rl_command_func_t *function;
       char **invokers;
 
       function = rl_named_function (name);
       invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);
 
       if (print_readably)
 	{
 	  if (!invokers)
@@ -1672,35 +1996,38 @@ rl_dump_macros (count, key)
   return (0);
 }
 
 void
 rl_variable_dumper (print_readably)
      int print_readably;
 {
   int i;
-  char *kname;
+  const char *kname;
 
   for (i = 0; boolean_varlist[i].name; i++)
     {
       if (print_readably)
         fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
 			       *boolean_varlist[i].value ? "on" : "off");
       else
         fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
 			       *boolean_varlist[i].value ? "on" : "off");
     }
 
   /* bell-style */
   switch (_rl_bell_preference)
     {
-    case NO_BELL: kname = "none"; break;
-    case VISIBLE_BELL: kname = "visible"; break;
+    case NO_BELL:
+      kname = "none"; break;
+    case VISIBLE_BELL:
+      kname = "visible"; break;
     case AUDIBLE_BELL:
-    default: kname = "audible"; break;
+    default:
+      kname = "audible"; break;
     }
   if (print_readably)
     fprintf (rl_outstream, "set bell-style %s\n", kname);
   else
     fprintf (rl_outstream, "bell-style is set to `%s'\n", kname);
 
   /* comment-begin */
   if (print_readably)
@@ -1723,16 +2050,31 @@ rl_variable_dumper (print_readably)
   /* keymap */
   kname = rl_get_keymap_name (_rl_keymap);
   if (kname == 0)
     kname = rl_get_keymap_name_from_edit_mode ();
   if (print_readably)
     fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
   else
     fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
+
+  /* isearch-terminators */
+  if (_rl_isearch_terminators)
+    {
+      char *disp;
+
+      disp = _rl_untranslate_macro_value (_rl_isearch_terminators);
+
+      if (print_readably)
+	fprintf (rl_outstream, "set isearch-terminators \"%s\"\n", disp);
+      else
+	fprintf (rl_outstream, "isearch-terminators is set to \"%s\"\n", disp);
+
+      free (disp);
+    }
 }
 
 /* Print all of the current variables and their values to
    rl_outstream.  If an explicit argument is given, then print
    the output in such a way that it can be read back in. */
 int
 rl_dump_variables (count, key)
      int count, key;
@@ -1742,33 +2084,34 @@ rl_dump_variables (count, key)
   rl_variable_dumper (rl_explicit_arg);
   rl_on_new_line ();
   return (0);
 }
 
 /* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
 void
 _rl_bind_if_unbound (keyseq, default_func)
-     char *keyseq;
-     Function *default_func;
+     const char *keyseq;
+     rl_command_func_t *default_func;
 {
-  Function *func;
+  rl_command_func_t *func;
 
   if (keyseq)
     {
       func = rl_function_of_keyseq (keyseq, _rl_keymap, (int *)NULL);
       if (!func || func == rl_do_lowercase_version)
 	rl_set_key (keyseq, default_func, _rl_keymap);
     }
 }
 
 /* Return non-zero if any members of ARRAY are a substring in STRING. */
 static int
 substring_member_of_array (string, array)
-     char *string, **array;
+     char *string;
+     const char **array;
 {
   while (*array)
     {
       if (_rl_strindex (string, *array))
 	return (1);
       array++;
     }
   return (0);
diff --git a/readline/callback.c b/readline/callback.c
--- a/readline/callback.c
+++ b/readline/callback.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -30,42 +30,34 @@
 #if defined (READLINE_CALLBACKS)
 
 #include <sys/types.h>
 #include <stdio.h>
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 #include "readline.h"
-
-extern void readline_internal_startup ();
-extern char *readline_internal_teardown ();
-extern int readline_internal_char ();
-extern void _rl_init_line_state ();
-
-extern int _rl_meta_flag;
-extern char *rl_prompt;
-extern int rl_visible_prompt_length;
+#include "rlprivate.h"
 
 /* **************************************************************** */
 /*								    */
 /*			Callback Readline Functions                 */
 /*								    */
 /* **************************************************************** */
 
 /* Allow using readline in situations where a program may have multiple
    things to handle at once, and dispatches them via select().  Call
    rl_callback_handler_install() with the prompt and a function to call
    whenever a complete line of input is ready.  The user must then
-   call readline_char() every time some input is available, and 
-   readline_char() will call the user's function with the complete text
-   read in at each end of line.  The terminal is kept prepped and signals
-   handled all the time, except during calls to the user's function. */
+   call rl_callback_read_char() every time some input is available, and 
+   rl_callback_read_char() will call the user's function with the complete
+   text read in at each end of line.  The terminal is kept prepped and
+   signals handled all the time, except during calls to the user's function. */
 
-VFunction *rl_linefunc;		/* user callback function */
+rl_vcpfunc_t *rl_linefunc;		/* user callback function */
 static int in_handler;		/* terminal_prepped and signals set? */
 
 /* Make sure the terminal is set up, initialize readline, and prompt. */
 static void
 _rl_callback_newline ()
 {
   rl_initialize ();
 
@@ -81,21 +73,20 @@ static void
     }
 
   readline_internal_setup ();
 }
 
 /* Install a readline handler, set up the terminal, and issue the prompt. */
 void
 rl_callback_handler_install (prompt, linefunc)
-     char *prompt;
-     VFunction *linefunc;
+     const char *prompt;
+     rl_vcpfunc_t *linefunc;
 {
-  rl_prompt = prompt;
-  rl_visible_prompt_length = rl_prompt ? rl_expand_prompt (rl_prompt) : 0;
+  rl_set_prompt (prompt);
   rl_linefunc = linefunc;
   _rl_callback_newline ();
 }
 
 /* Read one character, and dispatch to the handler if it ends the line. */
 void
 rl_callback_read_char ()
 {
@@ -105,34 +96,43 @@ rl_callback_read_char ()
   if (rl_linefunc == NULL)
     {
       fprintf (stderr, "readline: readline_callback_read_char() called with no handler!\r\n");
       abort ();
     }
 
   eof = readline_internal_char ();
 
-  if (rl_done)
+  /* We loop in case some function has pushed input back with rl_execute_next. */
+  for (;;)
     {
-      line = readline_internal_teardown (eof);
+      if (rl_done)
+	{
+	  line = readline_internal_teardown (eof);
 
-      (*rl_deprep_term_function) ();
+	  (*rl_deprep_term_function) ();
 #if defined (HANDLE_SIGNALS)
-      rl_clear_signals ();
+	  rl_clear_signals ();
 #endif
-      in_handler = 0;
-      (*rl_linefunc) (line);
+	  in_handler = 0;
+	  (*rl_linefunc) (line);
+
+	  /* If the user did not clear out the line, do it for him. */
+	  if (rl_line_buffer[0])
+	    _rl_init_line_state ();
 
-    /* If the user did not clear out the line, do it for him. */
-    if (rl_line_buffer[0])
-      _rl_init_line_state ();
-
-    /* Redisplay the prompt if readline_handler_{install,remove} not called. */
-      if (in_handler == 0 && rl_linefunc)
-	_rl_callback_newline ();
+	  /* Redisplay the prompt if readline_handler_{install,remove}
+	     not called. */
+	  if (in_handler == 0 && rl_linefunc)
+	    _rl_callback_newline ();
+	}
+      if (rl_pending_input)
+	eof = readline_internal_char ();
+      else
+        break;
     }
 }
 
 /* Remove the handler, and make sure the terminal is in its normal state. */
 void
 rl_callback_handler_remove ()
 {
   rl_linefunc = NULL;
diff --git a/readline/chardefs.h b/readline/chardefs.h
--- a/readline/chardefs.h
+++ b/readline/chardefs.h
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1994 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -46,17 +46,17 @@
 /* Some character stuff. */
 #define control_character_threshold 0x020   /* Smaller than this is control. */
 #define control_character_mask 0x1f	    /* 0x20 - 1 */
 #define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
 #define control_character_bit 0x40	    /* 0x000000, must be off. */
 #define meta_character_bit 0x080	    /* x0000000, must be on. */
 #define largest_char 255		    /* Largest character value. */
 
-#define CTRL_CHAR(c) ((c) < control_character_threshold && (c) >= 0)
+#define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))
 #define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
 
 #define CTRL(c) ((c) & control_character_mask)
 #define META(c) ((c) | meta_character_bit)
 
 #define UNMETA(c) ((c) & (~meta_character_bit))
 #define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
 
@@ -116,12 +116,25 @@
 #ifdef SPACE
 #undef SPACE
 #endif
 #define SPACE ' '	/* XXX - was 0x20 */
 
 #ifdef ESC
 #undef ESC
 #endif
-
 #define ESC CTRL('[')
 
+#ifndef ISOCTAL
+#define ISOCTAL(c)      ((c) >= '0' && (c) <= '7')
+#endif
+#define OCTVALUE(c)     ((c) - '0')
+
+#ifndef isxdigit
+#  define isxdigit(c)   (isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#endif
+
+#define HEXVALUE(c) \
+  (((c) >= 'a' && (c) <= 'f') \
+  	? (c)-'a'+10 \
+  	: (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+
 #endif  /* _CHARDEFS_H_ */
diff --git a/readline/complete.c b/readline/complete.c
--- a/readline/complete.c
+++ b/readline/complete.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -44,117 +44,123 @@
 #include <stdio.h>
 
 #include <errno.h>
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
 #include <pwd.h>
-#if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwent ();
-#endif /* USG && !HAVE_GETPW_DECLS */
-
-/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
-#if defined (isc386) && defined (_POSIX_SOURCE)
-#  if defined (__STDC__)
-extern struct passwd *getpwent (void);
-#  else
-extern struct passwd *getpwent ();
-#  endif /* !__STDC__ */
-#endif /* isc386 && _POSIX_SOURCE */
 
 #include "posixdir.h"
 #include "posixstat.h"
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
-
-extern char *tilde_expand ();
-extern char *rl_copy_text ();
-extern void _rl_abort_internal ();
-extern int _rl_qsort_string_compare ();
-
-extern Function *rl_last_func;
-extern int rl_editing_mode;
-extern int screenwidth;
-
-extern void _rl_move_vert ();
-extern int _rl_vis_botlin;
-extern int rl_display_fixed;
+#include "xmalloc.h"
+#include "rlprivate.h"
 
-/* Forward declarations for functions defined and used in this file. */
-char *filename_completion_function ();
-char **completion_matches ();
-
-static char *rl_quote_filename ();
-static char *rl_strpbrk ();
+#ifdef __STDC__
+typedef int QSFUNC (const void *, const void *);
+#else
+typedef int QSFUNC ();
+#endif
 
-static char **remove_duplicate_matches ();
-static void insert_text ();
-static void insert_match ();
-static void append_to_match ();
-static void insert_all_matches ();
-static void display_matches ();
-static int compute_lcd_of_matches ();
-
-extern char *xmalloc (), *xrealloc ();
+/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
+   defined. */
+#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
+extern struct passwd *getpwent __P((void));
+#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
 
 /* If non-zero, then this is the address of a function to call when
-   completing on a directory name.  The function is called with
-   the address of a string (the current directory name) as an arg. */
-Function *rl_directory_completion_hook = (Function *)NULL;
+   completing a word would normally display the list of possible matches.
+   This function is called instead of actually doing the display.
+   It takes three arguments: (char **matches, int num_matches, int max_length)
+   where MATCHES is the array of strings that matched, NUM_MATCHES is the
+   number of strings in that array, and MAX_LENGTH is the length of the
+   longest string in that array. */
+rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
+
+#if defined (VISIBLE_STATS)
+#  if !defined (X_OK)
+#    define X_OK 1
+#  endif
+static int stat_char __P((char *));
+#endif
 
-/* Non-zero means readline completion functions perform tilde expansion. */
-int rl_complete_with_tilde_expansion = 0;
+static char *rl_quote_filename __P((char *, int, char *));
+static char *rl_strpbrk __P((const char *, const char *));
+
+static char **remove_duplicate_matches __P((char **));
+static void insert_match __P((char *, int, int, char *));
+static int append_to_match __P((char *, int, int));
+static void insert_all_matches __P((char **, int, char *));
+static void display_matches __P((char **));
+static int compute_lcd_of_matches __P((char **, int, const char *));
+
+/* **************************************************************** */
+/*								    */
+/*	Completion matching, from readline's point of view.	    */
+/*								    */
+/* **************************************************************** */
+
+/* Variables known only to the readline library. */
 
 /* If non-zero, non-unique completions always show the list of matches. */
 int _rl_complete_show_all = 0;
 
 /* If non-zero, completed directory names have a slash appended. */
 int _rl_complete_mark_directories = 1;
 
+/* If non-zero, completions are printed horizontally in alphabetical order,
+   like `ls -x'. */
+int _rl_print_completions_horizontally;
+
+/* Non-zero means that case is not significant in filename completion. */
+#if defined (__MSDOS__) && !defined (__DJGPP__)
+int _rl_completion_case_fold = 1;
+#else
+int _rl_completion_case_fold;
+#endif
+
+/* Global variables available to applications using readline. */
+
 #if defined (VISIBLE_STATS)
-#  if !defined (X_OK)
-#    define X_OK 1
-#  endif
-
-static int stat_char ();
-
 /* Non-zero means add an additional character to each filename displayed
    during listing completion iff rl_filename_completion_desired which helps
    to indicate the type of file being listed. */
 int rl_visible_stats = 0;
 #endif /* VISIBLE_STATS */
 
-/* **************************************************************** */
-/*								    */
-/*	Completion matching, from readline's point of view.	    */
-/*								    */
-/* **************************************************************** */
+/* If non-zero, then this is the address of a function to call when
+   completing on a directory name.  The function is called with
+   the address of a string (the current directory name) as an arg. */
+rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
 
-/* Local variable states what happened during the last completion attempt. */
-static int completion_changed_buffer;
+rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
+
+/* Non-zero means readline completion functions perform tilde expansion. */
+int rl_complete_with_tilde_expansion = 0;
 
 /* Pointer to the generator function for completion_matches ().
-   NULL means to use filename_completion_function (), the default filename
+   NULL means to use rl_filename_completion_function (), the default filename
    completer. */
-Function *rl_completion_entry_function = (Function *)NULL;
+rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
 
 /* Pointer to alternative function to create matches.
    Function is called with TEXT, START, and END.
    START and END are indices in RL_LINE_BUFFER saying what the boundaries
    of TEXT are.
    If this function exists and returns NULL then call the value of
    rl_completion_entry_function to try to match, otherwise use the
    array of strings returned. */
-CPPFunction *rl_attempted_completion_function = (CPPFunction *)NULL;
+rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
 
 /* Non-zero means to suppress normal filename completion after the
    user-specified completion function has been called. */
 int rl_attempted_completion_over = 0;
 
 /* Set to a character indicating the type of completion being performed
    by rl_complete_internal, available for use by application completion
    functions. */
@@ -163,39 +169,39 @@ int rl_completion_type = 0;
 /* Up to this many items will be displayed in response to a
    possible-completions call.  After that, we ask the user if
    she is sure she wants to see them all. */
 int rl_completion_query_items = 100;
 
 /* The basic list of characters that signal a break between words for the
    completer routine.  The contents of this variable is what breaks words
    in the shell, i.e. " \t\n\"\\'`@$><=" */
-char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
+const char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
 
 /* List of basic quoting characters. */
-char *rl_basic_quote_characters = "\"'";
+const char *rl_basic_quote_characters = "\"'";
 
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-char *rl_completer_word_break_characters = (char *)NULL;
+const char *rl_completer_word_break_characters = (const char *)NULL;
 
 /* List of characters which can be used to quote a substring of the line.
    Completion occurs on the entire substring, and within the substring
    rl_completer_word_break_characters are treated as any other character,
    unless they also appear within this list. */
-char *rl_completer_quote_characters = (char *)NULL;
+const char *rl_completer_quote_characters = (const char *)NULL;
 
 /* List of characters that should be quoted in filenames by the completer. */
-char *rl_filename_quote_characters = (char *)NULL;
+const char *rl_filename_quote_characters = (const char *)NULL;
 
 /* List of characters that are word break characters, but should be left
    in TEXT when it is passed to the completion function.  The shell uses
    this to help determine what kind of completing to do. */
-char *rl_special_prefixes = (char *)NULL;
+const char *rl_special_prefixes = (const char *)NULL;
 
 /* If non-zero, then disallow duplicates in the matches. */
 int rl_ignore_completion_duplicates = 1;
 
 /* Non-zero means that the results of the matches are to be treated
    as filenames.  This is ALWAYS zero on entry, and can only be changed
    within a completion entry finder function. */
 int rl_filename_completion_desired = 0;
@@ -211,45 +217,56 @@ int rl_filename_quoting_desired = 1;
    filename completion is done, after all the matching names have been
    generated. It is passed a (char**) known as matches in the code below.
    It consists of a NULL-terminated array of pointers to potential
    matching strings.  The 1st element (matches[0]) is the maximal
    substring that is common to all matches. This function can re-arrange
    the list of matches as required, but all elements of the array must be
    free()'d if they are deleted. The main intent of this function is
    to implement FIGNORE a la SunOS csh. */
-Function *rl_ignore_some_completions_function = (Function *)NULL;
+rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
 
 /* Set to a function to quote a filename in an application-specific fashion.
    Called with the text to quote, the type of match found (single or multiple)
    and a pointer to the quoting character to be used, which the function can
    reset if desired. */
-CPFunction *rl_filename_quoting_function = rl_quote_filename;
+rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
          
 /* Function to call to remove quoting characters from a filename.  Called
    before completion is attempted, so the embedded quotes do not interfere
    with matching names in the file system.  Readline doesn't do anything
    with this; it's set only by applications. */
-CPFunction *rl_filename_dequoting_function = (CPFunction *)NULL;
+rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
 
 /* Function to call to decide whether or not a word break character is
    quoted.  If a character is quoted, it does not break words for the
    completer. */
-Function *rl_char_is_quoted_p = (Function *)NULL;
+rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;
 
 /* Character appended to completed words when at the end of the line.  The
    default is a space. */
 int rl_completion_append_character = ' ';
 
 /* If non-zero, inhibit completion (temporarily). */
 int rl_inhibit_completion;
 
+/* Variables local to this file. */
+
+/* Local variable states what happened during the last completion attempt. */
+static int completion_changed_buffer;
+
+/*************************************/
+/*				     */
+/*    Bindable completion functions  */
+/*				     */
+/*************************************/
+
 /* Complete the word at or before point.  You have supplied the function
    that does the initial simple matching selection algorithm (see
-   completion_matches ()).  The default is to do filename completion. */
+   rl_completion_matches ()).  The default is to do filename completion. */
 int
 rl_complete (ignore, invoking_key)
      int ignore, invoking_key;
 {
   if (rl_inhibit_completion)
     return (rl_insert (ignore, invoking_key));
   else if (rl_last_func == rl_complete && !completion_changed_buffer)
     return (rl_complete_internal ('?'));
@@ -269,79 +286,175 @@ rl_possible_completions (ignore, invokin
 
 int
 rl_insert_completions (ignore, invoking_key)
      int ignore, invoking_key;
 {
   return (rl_complete_internal ('*'));
 }
 
+/************************************/
+/*				    */
+/*    Completion utility functions  */
+/*				    */
+/************************************/
+
+/* Find the first occurrence in STRING1 of any character from STRING2.
+   Return a pointer to the character in STRING1. */
+static char *
+rl_strpbrk (string1, string2)
+     const char *string1, *string2;
+{
+  register const char *scan;
+
+  for (; *string1; string1++)
+    {
+      for (scan = string2; *scan; scan++)
+	{
+	  if (*string1 == *scan)
+	    return ((char *)string1);
+	}
+    }
+  return ((char *)NULL);
+}
+
 /* The user must press "y" or "n". Non-zero return means "y" pressed. */
 static int
 get_y_or_n ()
 {
   int c;
 
   for (;;)
     {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
       if (c == 'y' || c == 'Y' || c == ' ')
 	return (1);
       if (c == 'n' || c == 'N' || c == RUBOUT)
 	return (0);
       if (c == ABORT_CHAR)
 	_rl_abort_internal ();
-      ding ();
+      rl_ding ();
     }
 }
 
+#if defined (VISIBLE_STATS)
+/* Return the character which best describes FILENAME.
+     `@' for symbolic links
+     `/' for directories
+     `*' for executables
+     `=' for sockets
+     `|' for FIFOs
+     `%' for character special devices
+     `#' for block special devices */
+static int
+stat_char (filename)
+     char *filename;
+{
+  struct stat finfo;
+  int character, r;
+
+#if defined (HAVE_LSTAT) && defined (S_ISLNK)
+  r = lstat (filename, &finfo);
+#else
+  r = stat (filename, &finfo);
+#endif
+
+  if (r == -1)
+    return (0);
+
+  character = 0;
+  if (S_ISDIR (finfo.st_mode))
+    character = '/';
+#if defined (S_ISCHR)
+  else if (S_ISCHR (finfo.st_mode))
+    character = '%';
+#endif /* S_ISCHR */
+#if defined (S_ISBLK)
+  else if (S_ISBLK (finfo.st_mode))
+    character = '#';
+#endif /* S_ISBLK */
+#if defined (S_ISLNK)
+  else if (S_ISLNK (finfo.st_mode))
+    character = '@';
+#endif /* S_ISLNK */
+#if defined (S_ISSOCK)
+  else if (S_ISSOCK (finfo.st_mode))
+    character = '=';
+#endif /* S_ISSOCK */
+#if defined (S_ISFIFO)
+  else if (S_ISFIFO (finfo.st_mode))
+    character = '|';
+#endif
+  else if (S_ISREG (finfo.st_mode))
+    {
+      if (access (filename, X_OK) == 0)
+	character = '*';
+    }
+  return (character);
+}
+#endif /* VISIBLE_STATS */
+
 /* Return the portion of PATHNAME that should be output when listing
    possible completions.  If we are hacking filename completion, we
    are only interested in the basename, the portion following the
    final slash.  Otherwise, we return what we were passed. */
 static char *
 printable_part (pathname)
       char *pathname;
 {
   char *temp;
 
   temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
+#if defined (__MSDOS__)
+  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
+    temp = pathname + 1;
+#endif
   return (temp ? ++temp : pathname);
 }
 
 /* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
    are using it, check for and output a single character for `special'
-   filenames.  Return 1 if we printed an extension character, 0 if not. */
+   filenames.  Return the number of characters we output. */
 
 #define PUTX(c) \
+    do { \
       if (CTRL_CHAR (c)) \
         { \
           putc ('^', rl_outstream); \
           putc (UNCTRL (c), rl_outstream); \
+          printed_len += 2; \
         } \
       else if (c == RUBOUT) \
 	{ \
 	  putc ('^', rl_outstream); \
 	  putc ('?', rl_outstream); \
+	  printed_len += 2; \
 	} \
       else \
-	putc (c, rl_outstream)
+	{ \
+	  putc (c, rl_outstream); \
+	  printed_len++; \
+	} \
+    } while (0)
 
 static int
 print_filename (to_print, full_pathname)
      char *to_print, *full_pathname;
 {
+  int printed_len = 0;
 #if !defined (VISIBLE_STATS)
   char *s;
 
   for (s = to_print; *s; s++)
     {
       PUTX (*s);
     }
-  return 0;
 #else  
   char *s, c, *new_full_pathname;
   int extension_char, slen, tlen;
 
   for (s = to_print; *s; s++)
     {
       PUTX (*s);
     }
@@ -352,17 +465,22 @@ print_filename (to_print, full_pathname)
 	 path passed.  In this case, we try to expand the directory
 	 name before checking for the stat character. */
       if (to_print != full_pathname)
 	{
 	  /* Terminate the directory name. */
 	  c = to_print[-1];
 	  to_print[-1] = '\0';
 
-	  s = tilde_expand (full_pathname);
+	  /* If setting the last slash in full_pathname to a NUL results in
+	     full_pathname being the empty string, we are trying to complete
+	     files in the root directory.  If we pass a null string to the
+	     bash directory completion hook, for example, it will expand it
+	     to the current directory.  We just want the `/'. */
+	  s = tilde_expand (full_pathname && *full_pathname ? full_pathname : "/");
 	  if (rl_directory_completion_hook)
 	    (*rl_directory_completion_hook) (&s);
 
 	  slen = strlen (s);
 	  tlen = strlen (to_print);
 	  new_full_pathname = xmalloc (slen + tlen + 2);
 	  strcpy (new_full_pathname, s);
 	  new_full_pathname[slen] = '/';
@@ -376,22 +494,23 @@ print_filename (to_print, full_pathname)
       else
 	{
 	  s = tilde_expand (full_pathname);
 	  extension_char = stat_char (s);
 	}
 
       free (s);
       if (extension_char)
-	putc (extension_char, rl_outstream);
-      return (extension_char != 0);
+	{
+	  putc (extension_char, rl_outstream);
+	  printed_len++;
+	}
     }
-  else
-    return 0;
 #endif /* VISIBLE_STATS */
+  return printed_len;
 }
 
 static char *
 rl_quote_filename (s, rtype, qcp)
      char *s;
      int rtype;
      char *qcp;
 {
@@ -440,17 +559,21 @@ find_completion_word (fp, dp)
       for (scan = pass_next = 0; scan < end; scan++)
 	{
 	  if (pass_next)
 	    {
 	      pass_next = 0;
 	      continue;
 	    }
 
-	  if (rl_line_buffer[scan] == '\\')
+	  /* Shell-like semantics for single quotes -- don't allow backslash
+	     to quote anything in single quotes, especially not the closing
+	     quote.  If you don't like this, take out the check on the value
+	     of quote_char. */
+	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
 	    {
 	      pass_next = 1;
 	      found_quote |= RL_QF_BACKSLASH;
 	      continue;
 	    }
 
 	  if (quote_char != '\0')
 	    {
@@ -501,50 +624,56 @@ find_completion_word (fp, dp)
     }
 
   /* If we are at an unquoted word break, then advance past it. */
   scan = rl_line_buffer[rl_point];
 
   /* If there is an application-specific function to say whether or not
      a character is quoted and we found a quote character, let that
      function decide whether or not a character is a word break, even
-     if it is found in rl_completer_word_break_characters. */
-  if (rl_char_is_quoted_p)
-    isbrk = (found_quote == 0 ||
- 		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
-	      strchr (rl_completer_word_break_characters, scan) != 0;
-  else
-    isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
-
-  if (isbrk)
+     if it is found in rl_completer_word_break_characters.  Don't bother
+     if we're at the end of the line, though. */
+  if (scan)
     {
-      /* If the character that caused the word break was a quoting
-	 character, then remember it as the delimiter. */
-      if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, scan) && (end - rl_point) > 1)
-	delimiter = scan;
+      if (rl_char_is_quoted_p)
+	isbrk = (found_quote == 0 ||
+		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
+		strchr (rl_completer_word_break_characters, scan) != 0;
+      else
+	isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
 
-      /* If the character isn't needed to determine something special
-	 about what kind of completion to perform, then advance past it. */
-      if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
-	rl_point++;
+      if (isbrk)
+	{
+	  /* If the character that caused the word break was a quoting
+	     character, then remember it as the delimiter. */
+	  if (rl_basic_quote_characters &&
+	      strchr (rl_basic_quote_characters, scan) &&
+	      (end - rl_point) > 1)
+	    delimiter = scan;
+
+	  /* If the character isn't needed to determine something special
+	     about what kind of completion to perform, then advance past it. */
+	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
+	    rl_point++;
+	}
     }
 
   if (fp)
     *fp = found_quote;
   if (dp)
     *dp = delimiter;
 
   return (quote_char);
 }
 
 static char **
 gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
      char *text;
      int start, end;
-     Function *our_func;
+     rl_compentry_func_t *our_func;
      int found_quote, quote_char;
 {
   char **matches, *temp;
 
   /* If the user wants to TRY to complete, but then wants to give
      up and use the default completion function, they set the
      variable rl_attempted_completion_function. */
   if (rl_attempted_completion_function)
@@ -557,25 +686,26 @@ gen_completion_matches (text, start, end
 	  return (matches);
 	}
     }
 
   /* Beware -- we're stripping the quotes here.  Do this only if we know
      we are doing filename completion and the application has defined a
      filename dequoting function. */
   temp = (char *)NULL;
-  if (found_quote && our_func == (Function *)filename_completion_function &&
+
+  if (found_quote && our_func == rl_filename_completion_function &&
       rl_filename_dequoting_function)
     {
       /* delete single and double quotes */
       temp = (*rl_filename_dequoting_function) (text, quote_char);
       text = temp;	/* not freeing text is not a memory leak */
     }
 
-  matches = completion_matches (text, our_func);
+  matches = rl_completion_matches (text, our_func);
   FREE (temp);
   return matches;  
 }
 
 /* Filter out duplicates in MATCHES.  This frees up the strings in
    MATCHES. */
 static char **
 remove_duplicate_matches (matches)
@@ -588,17 +718,17 @@ remove_duplicate_matches (matches)
 
   /* Sort the items. */
   for (i = 0; matches[i]; i++)
     ;
 
   /* Sort the array without matches[0], since we need it to
      stay in place no matter what. */
   if (i)
-    qsort (matches+1, i-1, sizeof (char *), _rl_qsort_string_compare);
+    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
 
   /* Remember the lowest common denominator for it may be unique. */
   lowest_common = savestring (matches[0]);
 
   for (i = newlen = 0; matches[i + 1]; i++)
     {
       if (strcmp (matches[i], matches[i + 1]) == 0)
 	{
@@ -631,139 +761,291 @@ remove_duplicate_matches (matches)
   if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
     {
       free (temp_array[1]);
       temp_array[1] = (char *)NULL;
     }
   return (temp_array);
 }
 
+/* Find the common prefix of the list of matches, and put it into
+   matches[0]. */
+static int
+compute_lcd_of_matches (match_list, matches, text)
+     char **match_list;
+     int matches;
+     const char *text;
+{
+  register int i, c1, c2, si;
+  int low;		/* Count of max-matched characters. */
+
+  /* If only one match, just use that.  Otherwise, compare each
+     member of the list with the next, finding out where they
+     stop matching. */
+  if (matches == 1)
+    {
+      match_list[0] = match_list[1];
+      match_list[1] = (char *)NULL;
+      return 1;
+    }
+
+  for (i = 1, low = 100000; i < matches; i++)
+    {
+      if (_rl_completion_case_fold)
+	{
+	  for (si = 0;
+	       (c1 = _rl_to_lower(match_list[i][si])) &&
+	       (c2 = _rl_to_lower(match_list[i + 1][si]));
+	       si++)
+	    if (c1 != c2)
+	      break;
+	}
+      else
+	{
+	  for (si = 0;
+	       (c1 = match_list[i][si]) &&
+	       (c2 = match_list[i + 1][si]);
+	       si++)
+	    if (c1 != c2)
+	      break;
+	}
+
+      if (low > si)
+	low = si;
+    }
+
+  /* If there were multiple matches, but none matched up to even the
+     first character, and the user typed something, use that as the
+     value of matches[0]. */
+  if (low == 0 && text && *text)
+    {
+      match_list[0] = xmalloc (strlen (text) + 1);
+      strcpy (match_list[0], text);
+    }
+  else
+    {
+      match_list[0] = xmalloc (low + 1);
+      strncpy (match_list[0], match_list[1], low);
+      match_list[0][low] = '\0';
+    }
+
+  return matches;
+}
+
+static int
+postprocess_matches (matchesp, matching_filenames)
+     char ***matchesp;
+     int matching_filenames;
+{
+  char *t, **matches, **temp_matches;
+  int nmatch, i;
+
+  matches = *matchesp;
+
+  /* It seems to me that in all the cases we handle we would like
+     to ignore duplicate possiblilities.  Scan for the text to
+     insert being identical to the other completions. */
+  if (rl_ignore_completion_duplicates)
+    {
+      temp_matches = remove_duplicate_matches (matches);
+      free (matches);
+      matches = temp_matches;
+    }
+
+  /* If we are matching filenames, then here is our chance to
+     do clever processing by re-examining the list.  Call the
+     ignore function with the array as a parameter.  It can
+     munge the array, deleting matches as it desires. */
+  if (rl_ignore_some_completions_function && matching_filenames)
+    {
+      for (nmatch = 1; matches[nmatch]; nmatch++)
+	;
+      (void)(*rl_ignore_some_completions_function) (matches);
+      if (matches == 0 || matches[0] == 0)
+	{
+	  FREE (matches);
+	  *matchesp = (char **)0;
+	  return 0;
+        }
+      else
+	{
+	  /* If we removed some matches, recompute the common prefix. */
+	  for (i = 1; matches[i]; i++)
+	    ;
+	  if (i > 1 && i < nmatch)
+	    {
+	      t = matches[0];
+	      compute_lcd_of_matches (matches, i - 1, t);
+	      FREE (t);
+	    }
+	}
+    }
+
+  *matchesp = matches;
+  return (1);
+}
+
+/* A convenience function for displaying a list of strings in
+   columnar format on readline's output stream.  MATCHES is the list
+   of strings, in argv format, LEN is the number of strings in MATCHES,
+   and MAX is the length of the longest string in MATCHES. */
+void
+rl_display_match_list (matches, len, max)
+     char **matches;
+     int len, max;
+{
+  int count, limit, printed_len;
+  int i, j, k, l;
+  char *temp;
+
+  /* How many items of MAX length can we fit in the screen window? */
+  max += 2;
+  limit = _rl_screenwidth / max;
+  if (limit != 1 && (limit * max == _rl_screenwidth))
+    limit--;
+
+  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
+     limit will be 0 and a divide-by-zero fault will result. */
+  if (limit == 0)
+    limit = 1;
+
+  /* How many iterations of the printing loop? */
+  count = (len + (limit - 1)) / limit;
+
+  /* Watch out for special case.  If LEN is less than LIMIT, then
+     just do the inner printing loop.
+	   0 < len <= limit  implies  count = 1. */
+
+  /* Sort the items if they are not already sorted. */
+  if (rl_ignore_completion_duplicates == 0)
+    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
+
+  rl_crlf ();
+
+  if (_rl_print_completions_horizontally == 0)
+    {
+      /* Print the sorted items, up-and-down alphabetically, like ls. */
+      for (i = 1; i <= count; i++)
+	{
+	  for (j = 0, l = i; j < limit; j++)
+	    {
+	      if (l > len || matches[l] == 0)
+		break;
+	      else
+		{
+		  temp = printable_part (matches[l]);
+		  printed_len = print_filename (temp, matches[l]);
+
+		  if (j + 1 < limit)
+		    for (k = 0; k < max - printed_len; k++)
+		      putc (' ', rl_outstream);
+		}
+	      l += count;
+	    }
+	  rl_crlf ();
+	}
+    }
+  else
+    {
+      /* Print the sorted items, across alphabetically, like ls -x. */
+      for (i = 1; matches[i]; i++)
+	{
+	  temp = printable_part (matches[i]);
+	  printed_len = print_filename (temp, matches[i]);
+	  /* Have we reached the end of this line? */
+	  if (matches[i+1])
+	    {
+	      if (i && (limit > 1) && (i % limit) == 0)
+		rl_crlf ();
+	      else
+		for (k = 0; k < max - printed_len; k++)
+		  putc (' ', rl_outstream);
+	    }
+	}
+      rl_crlf ();
+    }
+}
+
+/* Display MATCHES, a list of matching filenames in argv format.  This
+   handles the simple case -- a single match -- first.  If there is more
+   than one match, we compute the number of strings in the list and the
+   length of the longest string, which will be needed by the display
+   function.  If the application wants to handle displaying the list of
+   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
+   address of a function, and we just call it.  If we're handling the
+   display ourselves, we just call rl_display_match_list.  We also check
+   that the list of matches doesn't exceed the user-settable threshold,
+   and ask the user if he wants to see the list if there are more matches
+   than RL_COMPLETION_QUERY_ITEMS. */
 static void
 display_matches (matches)
      char **matches;
 {
-  int len, count, limit, max, printed_len;
-  int i, j, k, l;
+  int len, max, i;
   char *temp;
 
   /* Move to the last visible line of a possibly-multiple-line command. */
   _rl_move_vert (_rl_vis_botlin);
 
   /* Handle simple case first.  What if there is only one answer? */
   if (matches[1] == 0)
     {
       temp = printable_part (matches[0]);
-      crlf ();
+      rl_crlf ();
       print_filename (temp, matches[0]);
-      crlf ();
-#if 0
-      rl_on_new_line ();
-#else
+      rl_crlf ();
+
       rl_forced_update_display ();
       rl_display_fixed = 1;
-#endif
+
       return;
     }
 
   /* There is more than one answer.  Find out how many there are,
      and find the maximum printed length of a single entry. */
   for (max = 0, i = 1; matches[i]; i++)
     {
       temp = printable_part (matches[i]);
       len = strlen (temp);
 
       if (len > max)
 	max = len;
     }
 
   len = i - 1;
 
+  /* If the caller has defined a display hook, then call that now. */
+  if (rl_completion_display_matches_hook)
+    {
+      (*rl_completion_display_matches_hook) (matches, len, max);
+      return;
+    }
+	
   /* If there are many items, then ask the user if she really wants to
      see them all. */
   if (len >= rl_completion_query_items)
     {
-      crlf ();
+      rl_crlf ();
       fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
       fflush (rl_outstream);
       if (get_y_or_n () == 0)
 	{
-	  crlf ();
-#if 0
-	  rl_on_new_line ();
-#else
+	  rl_crlf ();
+
 	  rl_forced_update_display ();
 	  rl_display_fixed = 1;
-#endif
+
 	  return;
 	}
     }
 
-  /* How many items of MAX length can we fit in the screen window? */
-  max += 2;
-  limit = screenwidth / max;
-  if (limit != 1 && (limit * max == screenwidth))
-    limit--;
-
-  /* Avoid a possible floating exception.  If max > screenwidth,
-     limit will be 0 and a divide-by-zero fault will result. */
-  if (limit == 0)
-    limit = 1;
-
-  /* How many iterations of the printing loop? */
-  count = (len + (limit - 1)) / limit;
-
-  /* Watch out for special case.  If LEN is less than LIMIT, then
-     just do the inner printing loop.
-	   0 < len <= limit  implies  count = 1. */
-
-  /* Sort the items if they are not already sorted. */
-  if (rl_ignore_completion_duplicates == 0)
-    qsort (matches + 1, len, sizeof (char *), _rl_qsort_string_compare);
+  rl_display_match_list (matches, len, max);
 
-  /* Print the sorted items, up-and-down alphabetically, like ls. */
-  crlf ();
-
-  for (i = 1; i <= count; i++)
-    {
-      for (j = 0, l = i; j < limit; j++)
-	{
-	  if (l > len || matches[l] == 0)
-	    break;
-	  else
-	    {
-	      temp = printable_part (matches[l]);
-	      printed_len = strlen (temp) + print_filename (temp, matches[l]);
-
-	      if (j + 1 < limit)
-		for (k = 0; k < max - printed_len; k++)
-		  putc (' ', rl_outstream);
-	    }
-	  l += count;
-	}
-      crlf ();
-    }
-
-#if 0
-  rl_on_new_line ();
-#else
   rl_forced_update_display ();
   rl_display_fixed = 1;
-#endif
-}
-
-static void
-insert_text (text, start, end)
-     char *text;
-     int start, end;
-{
-  rl_begin_undo_group ();
-  rl_delete_text (start, end + 1);
-  rl_point = start;
-  rl_insert_text (text);
-  rl_end_undo_group ();
 }
 
 static char *
 make_quoted_replacement (match, mtype, qc)
      char *match;
      int mtype;
      char *qc;	/* Pointer to quoting character, if any */
 {
@@ -780,28 +1062,27 @@ make_quoted_replacement (match, mtype, q
      matches don't require a quoted substring. */
   replacement = match;
 
   should_quote = match && rl_completer_quote_characters &&
 			rl_filename_completion_desired &&
 			rl_filename_quoting_desired;
 
   if (should_quote)
-#if defined (SHELL)
-    should_quote = should_quote && (!qc || !*qc || *qc == '"' || *qc == '\'');
-#else /* !SHELL */
-    should_quote = should_quote && (!qc || !*qc);
-#endif /* !SHELL */
+    should_quote = should_quote && (!qc || !*qc ||
+		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));
 
   if (should_quote)
     {
       /* If there is a single match, see if we need to quote it.
          This also checks whether the common prefix of several
 	 matches needs to be quoted. */
-      should_quote = rl_strpbrk (match, rl_filename_quote_characters) != 0;
+      should_quote = rl_filename_quote_characters
+			? (rl_strpbrk (match, rl_filename_quote_characters) != 0)
+			: 0;
 
       do_replace = should_quote ? mtype : NO_MATCH;
       /* Quote the replacement, since we found an embedded
 	 word break character in a potential match. */
       if (do_replace != NO_MATCH && rl_filename_quoting_function)
 	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
     }
   return (replacement);
@@ -826,27 +1107,28 @@ insert_match (match, start, mtype, qc)
       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
 	    replacement[0] == *qc)
 	start--;
       /* If make_quoted_replacement changed the quoting character, remove
 	 the opening quote and insert the (fully-quoted) replacement. */
       else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
 	    replacement[0] != oqc)
 	start--;
-      insert_text (replacement, start, rl_point - 1);
+      _rl_replace_text (replacement, start, rl_point - 1);
       if (replacement != match)
         free (replacement);
     }
 }
 
 /* Append any necessary closing quote and a separator character to the
    just-inserted match.  If the user has specified that directories
    should be marked by a trailing `/', append one of those instead.  The
-   default trailing character  */
-static void
+   default trailing character is a space.  Returns the number of characters
+   appended. */
+static int
 append_to_match (text, delimiter, quote_char)
      char *text;
      int delimiter, quote_char;
 {
   char temp_string[4], *filename;
   int temp_string_index;
   struct stat finfo;
 
@@ -876,16 +1158,18 @@ append_to_match (text, delimiter, quote_
 	}
       free (filename);
     }
   else
     {
       if (rl_point == rl_end)
 	rl_insert_text (temp_string);
     }
+
+  return (temp_string_index);
 }
 
 static void
 insert_all_matches (matches, point, qc)
      char **matches;
      int point;
      char *qc;
 {
@@ -917,112 +1201,93 @@ insert_all_matches (matches, point, qc)
       rl_insert_text (rp);
       rl_insert_text (" ");
       if (rp != matches[0])
 	free (rp);
     }
   rl_end_undo_group ();
 }
 
+static void
+free_match_list (matches)
+     char **matches;
+{
+  register int i;
+
+  for (i = 0; matches[i]; i++)
+    free (matches[i]);
+  free (matches);
+}
+
 /* Complete the word at or before point.
    WHAT_TO_DO says what to do with the completion.
    `?' means list the possible completions.
    TAB means do standard completion.
    `*' means insert all of the possible completions.
    `!' means to do standard completion, and list all possible completions if
    there is more than one. */
 int
 rl_complete_internal (what_to_do)
      int what_to_do;
 {
-  char **matches, **temp_matches;
-  Function *our_func;
-  int start, end, delimiter, found_quote, nmatch, i;
-  char *text, *saved_line_buffer, *t;
+  char **matches;
+  rl_compentry_func_t *our_func;
+  int start, end, delimiter, found_quote, i;
+  char *text, *saved_line_buffer;
   char quote_char;
 
-  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
-
-  our_func = rl_completion_entry_function
-		? rl_completion_entry_function
-		: (Function *)filename_completion_function;
-
+  RL_SETSTATE(RL_STATE_COMPLETING);
   /* Only the completion entry function can change these. */
   rl_filename_completion_desired = 0;
   rl_filename_quoting_desired = 1;
+  rl_completion_type = what_to_do;
 
-  rl_completion_type = what_to_do;
+  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
+  our_func = rl_completion_entry_function
+		? rl_completion_entry_function
+		: rl_filename_completion_function;
 
   /* We now look backwards for the start of a filename/variable word. */
   end = rl_point;
-
   found_quote = delimiter = 0;
   quote_char = '\0';
 
   if (rl_point)
     /* This (possibly) changes rl_point.  If it returns a non-zero char,
        we know we have an open quote. */
     quote_char = find_completion_word (&found_quote, &delimiter);
 
   start = rl_point;
   rl_point = end;
 
   text = rl_copy_text (start, end);
   matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
+  free (text);
 
   if (matches == 0)
     {
-      ding ();
+      rl_ding ();
       FREE (saved_line_buffer);
-      free (text);
-      return 0;
-    }
-    
-  /* It seems to me that in all the cases we handle we would like
-     to ignore duplicate possiblilities.  Scan for the text to
-     insert being identical to the other completions. */
-  if (rl_ignore_completion_duplicates)
-    {
-      temp_matches = remove_duplicate_matches (matches);
-      free (matches);
-      matches = temp_matches;
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
+      return (0);
     }
 
-  /* If we are matching filenames, then here is our chance to
-     do clever processing by re-examining the list.  Call the
-     ignore function with the array as a parameter.  It can
-     munge the array, deleting matches as it desires. */
-  if (rl_ignore_some_completions_function &&
-      our_func == (Function *)filename_completion_function)
+  /* If we are matching filenames, the attempted completion function will
+     have set rl_filename_completion_desired to a non-zero value.  The basic
+     rl_filename_completion_function does this. */
+  i = rl_filename_completion_desired;
+
+  if (postprocess_matches (&matches, i) == 0)
     {
-      for (nmatch = 1; matches[nmatch]; nmatch++)
-	;
-      (void)(*rl_ignore_some_completions_function) (matches);
-      if (matches == 0 || matches[0] == 0)
-	{
-	  FREE (matches);
-	  ding ();
-	  FREE (saved_line_buffer);
-	  FREE (text);
-	  return 0;
-        }
-      else
-	{
-	  /* If we removed some matches, recompute the common prefix. */
-	  for (i = 1; matches[i]; i++)
-	    ;
-	  if (i > 1 && i < nmatch)
-	    {
-	      t = matches[0];
-	      compute_lcd_of_matches (matches, i - 1, text);
-	      FREE (t);
-	    }
-	}
+      rl_ding ();
+      FREE (saved_line_buffer);
+      completion_changed_buffer = 0;
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
+      return (0);
     }
-  free (text);
 
   switch (what_to_do)
     {
     case TAB:
     case '!':
       /* Insert the first match with proper quoting. */
       if (*matches[0])
 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
@@ -1038,120 +1303,125 @@ rl_complete_internal (what_to_do)
       if (matches[1])
 	{
 	  if (what_to_do == '!')
 	    {
 	      display_matches (matches);
 	      break;
 	    }
 	  else if (rl_editing_mode != vi_mode)
-	    ding ();	/* There are other matches remaining. */
+	    rl_ding ();	/* There are other matches remaining. */
 	}
       else
 	append_to_match (matches[0], delimiter, quote_char);
 
       break;
 
     case '*':
       insert_all_matches (matches, start, &quote_char);
       break;
 
     case '?':
       display_matches (matches);
       break;
 
     default:
       fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
-      ding ();
+      rl_ding ();
       FREE (saved_line_buffer);
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
       return 1;
     }
 
-  for (i = 0; matches[i]; i++)
-    free (matches[i]);
-  free (matches);
+  free_match_list (matches);
 
   /* Check to see if the line has changed through all of this manipulation. */
   if (saved_line_buffer)
     {
       completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
       free (saved_line_buffer);
     }
 
+  RL_UNSETSTATE(RL_STATE_COMPLETING);
   return 0;
 }
 
-#if defined (VISIBLE_STATS)
-/* Return the character which best describes FILENAME.
-     `@' for symbolic links
-     `/' for directories
-     `*' for executables
-     `=' for sockets
-     `|' for FIFOs
-     `%' for character special devices
-     `#' for block special devices */
-static int
-stat_char (filename)
-     char *filename;
+/***************************************************************/
+/*							       */
+/*  Application-callable completion match generator functions  */
+/*							       */
+/***************************************************************/
+
+/* Return an array of (char *) which is a list of completions for TEXT.
+   If there are no completions, return a NULL pointer.
+   The first entry in the returned array is the substitution for TEXT.
+   The remaining entries are the possible completions.
+   The array is terminated with a NULL pointer.
+
+   ENTRY_FUNCTION is a function of two args, and returns a (char *).
+     The first argument is TEXT.
+     The second is a state argument; it should be zero on the first call, and
+     non-zero on subsequent calls.  It returns a NULL pointer to the caller
+     when there are no more matches.
+ */
+char **
+rl_completion_matches (text, entry_function)
+     const char *text;
+     rl_compentry_func_t *entry_function;
 {
-  struct stat finfo;
-  int character, r;
+  /* Number of slots in match_list. */
+  int match_list_size;
 
-#if defined (HAVE_LSTAT) && defined (S_ISLNK)
-  r = lstat (filename, &finfo);
-#else
-  r = stat (filename, &finfo);
-#endif
-
-  if (r == -1)
-    return (0);
+  /* The list of matches. */
+  char **match_list;
 
-  character = 0;
-  if (S_ISDIR (finfo.st_mode))
-    character = '/';
-#if defined (S_ISCHR)
-  else if (S_ISCHR (finfo.st_mode))
-    character = '%';
-#endif /* S_ISCHR */
-#if defined (S_ISBLK)
-  else if (S_ISBLK (finfo.st_mode))
-    character = '#';
-#endif /* S_ISBLK */
-#if defined (S_ISLNK)
-  else if (S_ISLNK (finfo.st_mode))
-    character = '@';
-#endif /* S_ISLNK */
-#if defined (S_ISSOCK)
-  else if (S_ISSOCK (finfo.st_mode))
-    character = '=';
-#endif /* S_ISSOCK */
-#if defined (S_ISFIFO)
-  else if (S_ISFIFO (finfo.st_mode))
-    character = '|';
-#endif
-  else if (S_ISREG (finfo.st_mode))
+  /* Number of matches actually found. */
+  int matches;
+
+  /* Temporary string binder. */
+  char *string;
+
+  matches = 0;
+  match_list_size = 10;
+  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
+  match_list[1] = (char *)NULL;
+
+  while (string = (*entry_function) (text, matches))
     {
-      if (access (filename, X_OK) == 0)
-	character = '*';
+      if (matches + 1 == match_list_size)
+	match_list = (char **)xrealloc
+	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
+
+      match_list[++matches] = string;
+      match_list[matches + 1] = (char *)NULL;
     }
-  return (character);
+
+  /* If there were any matches, then look through them finding out the
+     lowest common denominator.  That then becomes match_list[0]. */
+  if (matches)
+    compute_lcd_of_matches (match_list, matches, text);
+  else				/* There were no matches. */
+    {
+      free (match_list);
+      match_list = (char **)NULL;
+    }
+  return (match_list);
 }
-#endif /* VISIBLE_STATS */
 
 /* A completion function for usernames.
    TEXT contains a partial username preceded by a random
    character (usually `~').  */
 char *
-username_completion_function (text, state)
+rl_username_completion_function (text, state)
+     const char *text;
      int state;
-     char *text;
 {
-#if defined (__GO32__) || defined (__WIN32__)
+#if defined (__WIN32__) || defined (__OPENNT)
   return (char *)NULL;
-#else /* !__GO32__ */
+#else /* !__WIN32__ && !__OPENNT) */
   static char *username = (char *)NULL;
   static struct passwd *entry;
   static int namelen, first_char, first_char_loc;
   char *value;
 
   if (state == 0)
     {
       FREE (username);
@@ -1184,156 +1454,27 @@ username_completion_function (text, stat
 
       strcpy (value + first_char_loc, entry->pw_name);
 
       if (first_char == '~')
 	rl_filename_completion_desired = 1;
 
       return (value);
     }
-#endif /* !__GO32__ */
-}
-
-/* **************************************************************** */
-/*								    */
-/*			     Completion				    */
-/*								    */
-/* **************************************************************** */
-
-/* Non-zero means that case is not significant in completion. */
-int completion_case_fold = 0;
-
-/* Find the common prefix of the list of matches, and put it into
-   matches[0]. */
-static int
-compute_lcd_of_matches (match_list, matches, text)
-     char **match_list;
-     int matches;
-     char *text;
-{
-  register int i, c1, c2, si;
-  int low;		/* Count of max-matched characters. */
-
-  /* If only one match, just use that.  Otherwise, compare each
-     member of the list with the next, finding out where they
-     stop matching. */
-  if (matches == 1)
-    {
-      match_list[0] = match_list[1];
-      match_list[1] = (char *)NULL;
-      return 1;
-    }
-
-  for (i = 1, low = 100000; i < matches; i++)
-    {
-      if (completion_case_fold)
-	{
-	  for (si = 0;
-	       (c1 = _rl_to_lower(match_list[i][si])) &&
-	       (c2 = _rl_to_lower(match_list[i + 1][si]));
-	       si++)
-	    if (c1 != c2)
-	      break;
-	}
-      else
-	{
-	  for (si = 0;
-	       (c1 = match_list[i][si]) &&
-	       (c2 = match_list[i + 1][si]);
-	       si++)
-	    if (c1 != c2)
-	      break;
-	}
-
-      if (low > si)
-	low = si;
-    }
-
-  /* If there were multiple matches, but none matched up to even the
-     first character, and the user typed something, use that as the
-     value of matches[0]. */
-  if (low == 0 && text && *text)
-    {
-      match_list[0] = xmalloc (strlen (text) + 1);
-      strcpy (match_list[0], text);
-    }
-  else
-    {
-      match_list[0] = xmalloc (low + 1);
-      strncpy (match_list[0], match_list[1], low);
-      match_list[0][low] = '\0';
-    }
-
-  return matches;
-}
-
-/* Return an array of (char *) which is a list of completions for TEXT.
-   If there are no completions, return a NULL pointer.
-   The first entry in the returned array is the substitution for TEXT.
-   The remaining entries are the possible completions.
-   The array is terminated with a NULL pointer.
-
-   ENTRY_FUNCTION is a function of two args, and returns a (char *).
-     The first argument is TEXT.
-     The second is a state argument; it should be zero on the first call, and
-     non-zero on subsequent calls.  It returns a NULL pointer to the caller
-     when there are no more matches.
- */
-char **
-completion_matches (text, entry_function)
-     char *text;
-     CPFunction *entry_function;
-{
-  /* Number of slots in match_list. */
-  int match_list_size;
-
-  /* The list of matches. */
-  char **match_list;
-
-  /* Number of matches actually found. */
-  int matches;
-
-  /* Temporary string binder. */
-  char *string;
-
-  matches = 0;
-  match_list_size = 10;
-  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
-  match_list[1] = (char *)NULL;
-
-  while (string = (*entry_function) (text, matches))
-    {
-      if (matches + 1 == match_list_size)
-	match_list = (char **)xrealloc
-	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
-
-      match_list[++matches] = string;
-      match_list[matches + 1] = (char *)NULL;
-    }
-
-  /* If there were any matches, then look through them finding out the
-     lowest common denominator.  That then becomes match_list[0]. */
-  if (matches)
-    compute_lcd_of_matches (match_list, matches, text);
-  else				/* There were no matches. */
-    {
-      free (match_list);
-      match_list = (char **)NULL;
-    }
-  return (match_list);
+#endif /* !__WIN32__ && !__OPENNT */
 }
 
 /* Okay, now we write the entry_function for filename completion.  In the
    general case.  Note that completion in the shell is a little different
    because of all the pathnames that must be followed when looking up the
    completion for a command. */
 char *
-filename_completion_function (text, state)
+rl_filename_completion_function (text, state)
+     const char *text;
      int state;
-     char *text;
 {
   static DIR *directory = (DIR *)NULL;
   static char *filename = (char *)NULL;
   static char *dirname = (char *)NULL;
   static char *users_dirname = (char *)NULL;
   static int filename_len;
   char *temp;
   int dirlen;
@@ -1355,21 +1496,35 @@ filename_completion_function (text, stat
 
       filename = savestring (text);
       if (*text == 0)
 	text = ".";
       dirname = savestring (text);
 
       temp = strrchr (dirname, '/');
 
+#if defined (__MSDOS__)
+      /* special hack for //X/... */
+      if (dirname[0] == '/' && dirname[1] == '/' && isalpha (dirname[2]) && dirname[3] == '/')
+        temp = strrchr (dirname + 3, '/');
+#endif
+
       if (temp)
 	{
 	  strcpy (filename, ++temp);
 	  *temp = '\0';
 	}
+#if defined (__MSDOS__)
+      /* searches from current directory on the drive */
+      else if (isalpha (dirname[0]) && dirname[1] == ':')
+        {
+          strcpy (filename, dirname + 2);
+          dirname[2] = '\0';
+        }
+#endif
       else
 	{
 	  dirname[0] = '.';
 	  dirname[1] = '\0';
 	}
 
       /* We aren't done yet.  We also support the "~user" syntax. */
 
@@ -1378,16 +1533,19 @@ filename_completion_function (text, stat
 
       if (*dirname == '~')
 	{
 	  temp = tilde_expand (dirname);
 	  free (dirname);
 	  dirname = temp;
 	}
 
+      if (rl_directory_rewrite_hook)
+	(*rl_directory_rewrite_hook) (&dirname);
+
       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
 	{
 	  free (users_dirname);
 	  users_dirname = savestring (dirname);
 	}
 
       directory = opendir (dirname);
       filename_len = strlen (filename);
@@ -1414,20 +1572,30 @@ filename_completion_function (text, stat
 	       (entry->d_name[1] &&
 		 (entry->d_name[1] != '.' || entry->d_name[2])))
 	    break;
 	}
       else
 	{
 	  /* Otherwise, if these match up to the length of filename, then
 	     it is a match. */
-	    if ((entry->d_name[0] == filename[0]) &&
-		(((int)D_NAMLEN (entry)) >= filename_len) &&
-		(strncmp (filename, entry->d_name, filename_len) == 0))
-	      break;
+	  if (_rl_completion_case_fold)
+	    {
+	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
+		  (((int)D_NAMLEN (entry)) >= filename_len) &&
+		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
+		break;
+	    }
+	  else
+	    {
+	      if ((entry->d_name[0] == filename[0]) &&
+		  (((int)D_NAMLEN (entry)) >= filename_len) &&
+		  (strncmp (filename, entry->d_name, filename_len) == 0))
+		break;
+	    }
 	}
     }
 
   if (entry == 0)
     {
       if (directory)
 	{
 	  closedir (directory);
@@ -1467,92 +1635,139 @@ filename_completion_function (text, stat
 	        {
 	          temp[dirlen++] = '/';
 	          temp[dirlen] = '\0';
 	        }
 	    }
 	  else
 	    {
 	      dirlen = strlen (users_dirname);
-	      temp = xmalloc (1 + dirlen + D_NAMLEN (entry));
+	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
 	      strcpy (temp, users_dirname);
+	      /* Make sure that temp has a trailing slash here. */
+	      if (users_dirname[dirlen - 1] != '/')
+		temp[dirlen++] = '/';
 	    }
 
-	  strcpy (temp + dirlen, entry->d_name); /* strcat (temp, entry->d_name); */
+	  strcpy (temp + dirlen, entry->d_name);
 	}
       else
 	temp = savestring (entry->d_name);
 
       return (temp);
     }
 }
 
-/* A function for simple tilde expansion. */
+/* An initial implementation of a menu completion function a la tcsh.  The
+   first time (if the last readline command was not rl_menu_complete), we
+   generate the list of matches.  This code is very similar to the code in
+   rl_complete_internal -- there should be a way to combine the two.  Then,
+   for each item in the list of matches, we insert the match in an undoable
+   fashion, with the appropriate character appended (this happens on the
+   second and subsequent consecutive calls to rl_menu_complete).  When we
+   hit the end of the match list, we restore the original unmatched text,
+   ring the bell, and reset the counter to zero. */
 int
-rl_tilde_expand (ignore, key)
-     int ignore, key;
+rl_menu_complete (count, ignore)
+     int count, ignore;
 {
-  register int start, end;
-  char *homedir, *temp;
-  int len;
+  rl_compentry_func_t *our_func;
+  int matching_filenames, found_quote;
+
+  static char *orig_text;
+  static char **matches = (char **)0;
+  static int match_list_index = 0;
+  static int match_list_size = 0;
+  static int orig_start, orig_end;
+  static char quote_char;
+  static int delimiter;
 
-  end = rl_point;
-  start = end - 1;
+  /* The first time through, we generate the list of matches and set things
+     up to insert them. */
+  if (rl_last_func != rl_menu_complete)
+    {
+      /* Clean up from previous call, if any. */
+      FREE (orig_text);
+      if (matches)
+	free_match_list (matches);
+
+      match_list_index = match_list_size = 0;
+      matches = (char **)NULL;
+
+      /* Only the completion entry function can change these. */
+      rl_filename_completion_desired = 0;
+      rl_filename_quoting_desired = 1;
+      rl_completion_type = '%';
 
-  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
-    {
-      homedir = tilde_expand ("~");
-      insert_text (homedir, start, end);
-      return (0);
-    }
-  else if (rl_line_buffer[start] != '~')
-    {
-      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
+      our_func = rl_completion_entry_function
+			? rl_completion_entry_function
+			: rl_filename_completion_function;
+
+      /* We now look backwards for the start of a filename/variable word. */
+      orig_end = rl_point;
+      found_quote = delimiter = 0;
+      quote_char = '\0';
+
+      if (rl_point)
+	/* This (possibly) changes rl_point.  If it returns a non-zero char,
+	   we know we have an open quote. */
+	quote_char = find_completion_word (&found_quote, &delimiter);
+
+      orig_start = rl_point;
+      rl_point = orig_end;
+
+      orig_text = rl_copy_text (orig_start, orig_end);
+      matches = gen_completion_matches (orig_text, orig_start, orig_end,
+					our_func, found_quote, quote_char);
+
+      /* If we are matching filenames, the attempted completion function will
+	 have set rl_filename_completion_desired to a non-zero value.  The basic
+	 rl_filename_completion_function does this. */
+      matching_filenames = rl_filename_completion_desired;
+
+      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
+	{
+    	  rl_ding ();
+	  FREE (matches);
+	  matches = (char **)0;
+	  FREE (orig_text);
+	  orig_text = (char *)0;
+    	  completion_changed_buffer = 0;
+          return (0);
+	}
+
+      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
         ;
-      start++;
+      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
+	 code below should take care of it. */
     }
 
-  end = start;
-  do
-    end++;
-  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);
-
-  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
-    end--;
+  /* Now we have the list of matches.  Replace the text between
+     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
+     matches[match_list_index], and add any necessary closing char. */
 
-  /* If the first character of the current word is a tilde, perform
-     tilde expansion and insert the result.  If not a tilde, do
-     nothing. */
-  if (rl_line_buffer[start] == '~')
+  if (matches == 0 || match_list_size == 0) 
     {
-      len = end - start + 1;
-      temp = xmalloc (len + 1);
-      strncpy (temp, rl_line_buffer + start, len);
-      temp[len] = '\0';
-      homedir = tilde_expand (temp);
-      free (temp);
-
-      insert_text (homedir, start, end);
+      rl_ding ();
+      FREE (matches);
+      matches = (char **)0;
+      completion_changed_buffer = 0;
+      return (0);
     }
 
+  match_list_index = (match_list_index + count) % match_list_size;
+  if (match_list_index < 0)
+    match_list_index += match_list_size;
+
+  if (match_list_index == 0 && match_list_size > 1)
+    {
+      rl_ding ();
+      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
+    }
+  else
+    {
+      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
+      append_to_match (matches[match_list_index], delimiter, quote_char);
+    }
+
+  completion_changed_buffer = 1;
   return (0);
 }
-
-/* Find the first occurrence in STRING1 of any character from STRING2.
-   Return a pointer to the character in STRING1. */
-static char *
-rl_strpbrk (string1, string2)
-     char *string1, *string2;
-{
-  register char *scan;
-
-  for (; *string1; string1++)
-    {
-      for (scan = string2; *scan; scan++)
-	{
-	  if (*string1 == *scan)
-	    {
-	      return (string1);
-	    }
-	}
-    }
-  return ((char *)NULL);
-}
diff --git a/readline/configure.in b/readline/configure.in
--- a/readline/configure.in
+++ b/readline/configure.in
@@ -1,45 +1,67 @@
 dnl
 dnl Configure script for readline library
 dnl
 dnl report bugs to chet@po.cwru.edu
 dnl
 dnl Process this file with autoconf to produce a configure script.
-AC_REVISION([for Readline 2.1, version 2.04, from autoconf version] AC_ACVERSION)
-LIBVERSION=2.1
+AC_REVISION([for Readline 4.2, version 2.25, from autoconf version] AC_ACVERSION)
+LIBVERSION=4.2-beta
 
 AC_INIT(readline.h)
 AC_CONFIG_HEADER(config.h)
 
 dnl make sure we are using a recent autoconf version
 AC_PREREQ(2.10)
 
 AC_CONFIG_AUX_DIR(./support)
 
 AC_CANONICAL_HOST
 
+dnl configure defaults
+opt_curses=no
+opt_shared=no
+
+dnl arguments to configure
+AC_ARG_WITH(curses, --with-curses               use the curses library instead of the termcap library,opt_curses=$withval)
+
+if test "$opt_curses" = "yes"; then
+	prefer_curses=yes
+fi
+
 # We want these before the checks, so the checks can modify their values.
 test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
 
+AC_PROG_MAKE_SET
 AC_PROG_CC
+dnl AC_AIX
+AC_MINIX
 
 # If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
 test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
 
 AC_PROG_GCC_TRADITIONAL
 AC_PROG_INSTALL
+AC_CHECK_PROG(AR, ar, ar)
+dnl Set default for ARFLAGS, since autoconf does not have a macro for it.
+dnl This allows people to set it when running configure or make
+test -n "$ARFLAGS" || ARFLAGS="cr"
 AC_PROG_RANLIB
 
+MAKE_SHELL=/bin/sh
+AC_SUBST(MAKE_SHELL)
+
 AC_RETSIGTYPE
 
 AC_HEADER_STAT
 AC_HEADER_DIRENT
 
-AC_CHECK_FUNCS(strcasecmp select setenv putenv tcgetattr setlocale lstat)
+AC_CHECK_FUNCS(lstat memmove putenv select setenv setlocale \
+		strcasecmp tcgetattr)
 
 AC_FUNC_STRCOLL
 
 AC_CHECK_HEADERS(unistd.h stdlib.h varargs.h stdarg.h string.h \
 		sys/ptem.h sys/pte.h sys/stream.h sys/select.h \
 		termcap.h termios.h termio.h sys/file.h locale.h)
 
 BASH_SIGNAL_CHECK
@@ -50,33 +72,87 @@ BASH_FUNC_LSTAT
 BASH_CHECK_GETPW_FUNCS
 BASH_FUNC_STRCOLL
 
 BASH_TYPE_SIGHANDLER
 BASH_HAVE_TIOCGWINSZ
 BASH_HAVE_TIOCSTAT
 BASH_HAVE_FIONREAD
 BASH_MISC_SPEED_T
+BASH_STRUCT_WINSIZE
 BASH_STRUCT_DIRENT_D_INO
 BASH_STRUCT_DIRENT_D_FILENO
 
+dnl yuck
+case "$host_os" in
+aix*)   prefer_curses=yes ;;
+esac
+BASH_CHECK_LIB_TERMCAP
+if test "$TERMCAP_LIB" = "./lib/termcap/libtermcap.a"; then
+	TERMCAP_LIB=-ltermcap	#default
+fi
+
 case "$host_cpu" in
 *cray*)	LOCAL_CFLAGS=-DCRAY ;;
+*s390*) LOCAL_CFLAGS=-fsigned-char ;;
 esac
 
 case "$host_os" in
 isc*)	LOCAL_CFLAGS=-Disc386 ;;
 esac
 
+# shared library configuration section
+#
+# Shared object configuration section.  These values are generated by
+# ${srcdir}/support/shobj-conf
+#
+if test -f ${srcdir}/support/shobj-conf; then
+        AC_MSG_CHECKING(configuration for building shared libraries)
+        eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
+        AC_SUBST(SHOBJ_CC)
+        AC_SUBST(SHOBJ_CFLAGS)
+        AC_SUBST(SHOBJ_LD)
+        AC_SUBST(SHOBJ_LDFLAGS)
+	AC_SUBST(SHOBJ_XLDFLAGS)
+        AC_SUBST(SHOBJ_LIBS)
+        AC_SUBST(SHOBJ_STATUS)
+	AC_SUBST(SHLIB_STATUS)
+	AC_SUBST(SHLIB_XLDFLAGS)
+	AC_SUBST(SHLIB_LIBSUFF)
+	AC_SUBST(SHLIB_LIBVERSION)
+	AC_SUBST(SHLIB_LIBS)
+        AC_MSG_RESULT($SHLIB_STATUS)
+
+	# shared library versioning
+	# quoted for m4 so I can use character classes
+	SHLIB_MAJOR=[`expr "$LIBVERSION" : '\([0-9]\)\..*'`]
+	SHLIB_MINOR=[`expr "$LIBVERSION" : '[0-9]\.\([0-9]\).*'`]
+	AC_SUBST(SHLIB_MAJOR)
+	AC_SUBST(SHLIB_MINOR)
+fi
+
+case "$host_os" in
+msdosdjgpp*)	BUILD_DIR=`pwd.exe` ;;	# to prevent //d/path/file
+*)		BUILD_DIR=`pwd` ;;
+esac
+
+AC_SUBST(BUILD_DIR)
+
 AC_SUBST(CFLAGS)
 AC_SUBST(LOCAL_CFLAGS)
+AC_SUBST(LOCAL_LDFLAGS)
 AC_SUBST(LOCAL_DEFS)
 
+AC_SUBST(AR)
+AC_SUBST(ARFLAGS)
+
 AC_SUBST(host_cpu)
 AC_SUBST(host_os)
 
 AC_SUBST(LIBVERSION)
 
-AC_OUTPUT([Makefile doc/Makefile examples/Makefile],
+AC_SUBST(TERMCAP_LIB)
+
+AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile],
 [
 # Makefile uses this timestamp file to record whether config.h is up to date.
 echo > stamp-h
 ])
diff --git a/readline/display.c b/readline/display.c
--- a/readline/display.c
+++ b/readline/display.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -36,69 +36,45 @@
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #include <stdio.h>
 
-#if defined (__GO32__)
-#  include <go32.h>
-#  include <pc.h>
-#endif /* __GO32__ */
-
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Termcap library stuff. */
 #include "tcap.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+#include "xmalloc.h"
+
 #if !defined (strchr) && !defined (__STDC__)
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
 
-/* Global and pseudo-global variables and functions
-   imported from readline.c. */
-extern char *rl_prompt;
-extern int readline_echoing_p;
-
-extern int _rl_output_meta_chars;
-extern int _rl_horizontal_scroll_mode;
-extern int _rl_mark_modified_lines;
-extern int _rl_prefer_visible_bell;
-
-/* Variables and functions imported from terminal.c */
-extern void _rl_output_some_chars ();
-extern int _rl_output_character_function ();
-extern int _rl_backspace ();
+#if defined (HACK_TERMCAP_MOTION)
+extern char *_rl_term_forward_char;
+#endif
 
-extern char *term_clreol, *term_clrpag;
-extern char *term_im, *term_ic,  *term_ei, *term_DC;
-extern char *term_up, *term_dc, *term_cr, *term_IC;
-extern int screenheight, screenwidth, screenchars;
-extern int terminal_can_insert, _rl_term_autowrap;
-
-/* Pseudo-global functions (local to the readline library) exported
-   by this file. */
-void _rl_move_cursor_relative (), _rl_output_some_chars ();
-void _rl_move_vert ();
-void _rl_clear_to_eol (), _rl_clear_screen ();
-
-static void update_line (), space_to_eol ();
-static void delete_chars (), insert_some_chars ();
-static void cr ();
+static void update_line __P((char *, char *, int, int, int, int));
+static void space_to_eol __P((int));
+static void delete_chars __P((int));
+static void insert_some_chars __P((char *, int));
+static void cr __P((void));
 
 static int *inv_lbreaks, *vis_lbreaks;
-
-extern char *xmalloc (), *xrealloc ();
+static int inv_lbsize, vis_lbsize;
 
 /* Heuristic used to decide whether it is faster to move from CUR to NEW
    by backing up or outputting a carriage return and moving forward. */
 #define CR_FASTER(new, cur) (((new) + 1) < ((cur) - (new)))
 
 /* **************************************************************** */
 /*								    */
 /*			Display stuff				    */
@@ -122,17 +98,17 @@ extern char *xmalloc (), *xrealloc ();
    just drew into be the one which reflects the current contents of the
    screen, and place the cursor where it belongs.
 
    Commands that want to can fix the display themselves, and then let
    this function know that the display has been fixed by setting the
    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
 
 /* Application-specific redisplay function. */
-VFunction *rl_redisplay_function = rl_redisplay;
+rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
 
 /* Global variables declared here. */
 /* What YOU turn on when you have handled all redisplay yourself. */
 int rl_display_fixed = 0;
 
 int _rl_suppress_redisplay = 0;
 
 /* The stuff that gets printed out before the actual text of the line.
@@ -161,66 +137,81 @@ static char *invisible_line = (char *)NU
 static char msg_buf[128];
 
 /* Non-zero forces the redisplay even if we thought it was unnecessary. */
 static int forced_display;
 
 /* Default and initial buffer size.  Can grow. */
 static int line_size = 1024;
 
+/* Variables to keep track of the expanded prompt string, which may
+   include invisible characters. */
+
 static char *local_prompt, *local_prompt_prefix;
-static int visible_length, prefix_length;
+static int prompt_visible_length, prompt_prefix_length;
 
 /* The number of invisible characters in the line currently being
    displayed on the screen. */
 static int visible_wrap_offset;
 
-/* static so it can be shared between rl_redisplay and update_line */
+/* The number of invisible characters in the prompt string.  Static so it
+   can be shared between rl_redisplay and update_line */
 static int wrap_offset;
 
-/* The index of the last invisible_character in the prompt string. */
-static int last_invisible;
+/* The index of the last invisible character in the prompt string. */
+static int prompt_last_invisible;
 
 /* The length (buffer offset) of the first line of the last (possibly
    multi-line) buffer displayed on the screen. */
 static int visible_first_line_len;
 
+/* Number of invisible characters on the first physical line of the prompt.
+   Only valid when the number of physical characters in the prompt exceeds
+   (or is equal to) _rl_screenwidth. */
+static int prompt_invis_chars_first_line;
+
+static int prompt_last_screen_line;
+
 /* Expand the prompt string S and return the number of visible
    characters in *LP, if LP is not null.  This is currently more-or-less
    a placeholder for expansion.  LIP, if non-null is a place to store the
-   index of the last invisible character in ther eturned string. */
+   index of the last invisible character in the returned string. NIFLP,
+   if non-zero, is a place to store the number of invisible characters in
+   the first prompt line. */
 
 /* Current implementation:
 	\001 (^A) start non-visible characters
 	\002 (^B) end non-visible characters
    all characters except \001 and \002 (following a \001) are copied to
    the returned string; all characters except those between \001 and
    \002 are assumed to be `visible'. */	
 
 static char *
-expand_prompt (pmt, lp, lip)
+expand_prompt (pmt, lp, lip, niflp)
      char *pmt;
-     int *lp, *lip;
+     int *lp, *lip, *niflp;
 {
   char *r, *ret, *p;
-  int l, rl, last, ignoring;
+  int l, rl, last, ignoring, ninvis, invfl;
 
   /* Short-circuit if we can. */
   if (strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
     {
       r = savestring (pmt);
       if (lp)
 	*lp = strlen (r);
       return r;
     }
 
   l = strlen (pmt);
   r = ret = xmalloc (l + 1);
-  
-  for (rl = ignoring = last = 0, p = pmt; p && *p; p++)
+
+  invfl = 0;	/* invisible chars in first line of prompt */
+
+  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
     {
       /* This code strips the invisible character string markers
 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
       if (*p == RL_PROMPT_START_IGNORE)
 	{
 	  ignoring++;
 	  continue;
 	}
@@ -230,84 +221,153 @@ expand_prompt (pmt, lp, lip)
 	  last = r - ret - 1;
 	  continue;
 	}
       else
 	{
 	  *r++ = *p;
 	  if (!ignoring)
 	    rl++;
+	  else
+	    ninvis++;
+	  if (rl == _rl_screenwidth)
+	    invfl = ninvis;
 	}
     }
 
+  if (rl < _rl_screenwidth)
+    invfl = ninvis;
+
   *r = '\0';
   if (lp)
     *lp = rl;
   if (lip)
     *lip = last;
+  if (niflp)
+    *niflp = invfl;
+  return ret;
+}
+
+/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from
+   PMT and return the rest of PMT. */
+char *
+_rl_strip_prompt (pmt)
+     char *pmt;
+{
+  char *ret;
+
+  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
   return ret;
 }
 
 /*
  * Expand the prompt string into the various display components, if
  * necessary.
  *
  * local_prompt = expanded last line of string in rl_display_prompt
  *		  (portion after the final newline)
  * local_prompt_prefix = portion before last newline of rl_display_prompt,
  *			 expanded via expand_prompt
- * visible_length = number of visible characters in local_prompt
- * prefix_length = number of visible characters in local_prompt_prefix
+ * prompt_visible_length = number of visible characters in local_prompt
+ * prompt_prefix_length = number of visible characters in local_prompt_prefix
  *
  * This function is called once per call to readline().  It may also be
  * called arbitrarily to expand the primary prompt.
  *
  * The return value is the number of visible characters on the last line
  * of the (possibly multi-line) prompt.
  */
 int
 rl_expand_prompt (prompt)
      char *prompt;
 {
   char *p, *t;
   int c;
 
   /* Clear out any saved values. */
-  if (local_prompt)
-    free (local_prompt);
-  if (local_prompt_prefix)
-    free (local_prompt_prefix);
+  FREE (local_prompt);
+  FREE (local_prompt_prefix);
+
   local_prompt = local_prompt_prefix = (char *)0;
-  last_invisible = 0;
+  prompt_last_invisible = prompt_visible_length = 0;
 
   if (prompt == 0 || *prompt == 0)
     return (0);
 
   p = strrchr (prompt, '\n');
   if (!p)
     {
-      /* The prompt is only one line. */
-      local_prompt = expand_prompt (prompt, &visible_length, &last_invisible);
+      /* The prompt is only one logical line, though it might wrap. */
+      local_prompt = expand_prompt (prompt, &prompt_visible_length,
+					    &prompt_last_invisible,
+					    &prompt_invis_chars_first_line);
       local_prompt_prefix = (char *)0;
-      return (visible_length);
+      return (prompt_visible_length);
     }
   else
     {
       /* The prompt spans multiple lines. */
       t = ++p;
-      local_prompt = expand_prompt (p, &visible_length, &last_invisible);
+      local_prompt = expand_prompt (p, &prompt_visible_length,
+				       &prompt_last_invisible,
+				       &prompt_invis_chars_first_line);
       c = *t; *t = '\0';
       /* The portion of the prompt string up to and including the
 	 final newline is now null-terminated. */
-      local_prompt_prefix = expand_prompt (prompt, &prefix_length, (int *)NULL);
+      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
+						   (int *)NULL,
+						   &prompt_invis_chars_first_line);
       *t = c;
-      return (prefix_length);
+      return (prompt_prefix_length);
     }
 }
 
+/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
+   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
+   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
+   increased.  If the lines have already been allocated, this ensures that
+   they can hold at least MINSIZE characters. */
+static void
+init_line_structures (minsize)
+      int minsize;
+{
+  register int n;
+
+  if (invisible_line == 0)	/* initialize it */
+    {
+      if (line_size < minsize)
+	line_size = minsize;
+      visible_line = xmalloc (line_size);
+      invisible_line = xmalloc (line_size);
+    }
+  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
+    {
+      line_size *= 2;
+      if (line_size < minsize)
+	line_size = minsize;
+      visible_line = xrealloc (visible_line, line_size);
+      invisible_line = xrealloc (invisible_line, line_size);
+    }
+
+  for (n = minsize; n < line_size; n++)
+    {
+      visible_line[n] = 0;
+      invisible_line[n] = 1;
+    }
+
+  if (vis_lbreaks == 0)
+    {
+      /* should be enough. */
+      inv_lbsize = vis_lbsize = 256;
+      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
+      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
+      inv_lbreaks[0] = vis_lbreaks[0] = 0;
+    }
+}
+  
 /* Basic redisplay algorithm. */
 void
 rl_redisplay ()
 {
   register int in, out, c, linenum, cursor_linenum;
   register char *line;
   int c_pos, inv_botlin, lb_botlin, lb_linenum;
   int newlines, lpos, temp;
@@ -316,29 +376,17 @@ rl_redisplay ()
   if (!readline_echoing_p)
     return;
 
   if (!rl_display_prompt)
     rl_display_prompt = "";
 
   if (invisible_line == 0)
     {
-      visible_line = xmalloc (line_size);
-      invisible_line = xmalloc (line_size);
-      for (in = 0; in < line_size; in++)
-	{
-	  visible_line[in] = 0;
-	  invisible_line[in] = 1;
-	}
-
-      /* should be enough, but then again, this is just for testing. */
-      inv_lbreaks = (int *)malloc (256 * sizeof (int));
-      vis_lbreaks = (int *)malloc (256 * sizeof (int));
-      inv_lbreaks[0] = vis_lbreaks[0] = 0;
-
+      init_line_structures (0);
       rl_on_new_line ();
     }
 
   /* Draw the line into the buffer. */
   c_pos = -1;
 
   line = invisible_line;
   out = inv_botlin = 0;
@@ -364,71 +412,121 @@ rl_redisplay ()
   if (rl_display_prompt == rl_prompt || local_prompt)
     {
       int local_len = local_prompt ? strlen (local_prompt) : 0;
       if (local_prompt_prefix && forced_display)
 	_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));
 
       if (local_len > 0)
 	{
+	  temp = local_len + out + 2;
+	  if (temp >= line_size)
+	    {
+	      line_size = (temp + 1024) - (temp % 1024);
+	      visible_line = xrealloc (visible_line, line_size);
+	      line = invisible_line = xrealloc (invisible_line, line_size);
+	    }
 	  strncpy (line + out, local_prompt, local_len);
 	  out += local_len;
 	}
       line[out] = '\0';
-      wrap_offset = local_len - visible_length;
+      wrap_offset = local_len - prompt_visible_length;
     }
   else
     {
       int pmtlen;
       prompt_this_line = strrchr (rl_display_prompt, '\n');
       if (!prompt_this_line)
 	prompt_this_line = rl_display_prompt;
       else
 	{
 	  prompt_this_line++;
+	  pmtlen = prompt_this_line - rl_display_prompt;	/* temp var */
 	  if (forced_display)
 	    {
-	      _rl_output_some_chars (rl_display_prompt, prompt_this_line - rl_display_prompt);
+	      _rl_output_some_chars (rl_display_prompt, pmtlen);
 	      /* Make sure we are at column zero even after a newline,
 		 regardless of the state of terminal output processing. */
-	      if (prompt_this_line[-2] != '\r')
+	      if (pmtlen < 2 || prompt_this_line[-2] != '\r')
 		cr ();
 	    }
 	}
 
       pmtlen = strlen (prompt_this_line);
+      temp = pmtlen + out + 2;
+      if (temp >= line_size)
+	{
+	  line_size = (temp + 1024) - (temp % 1024);
+	  visible_line = xrealloc (visible_line, line_size);
+	  line = invisible_line = xrealloc (invisible_line, line_size);
+	}
       strncpy (line + out,  prompt_this_line, pmtlen);
       out += pmtlen;
       line[out] = '\0';
-      wrap_offset = 0;
+      wrap_offset = prompt_invis_chars_first_line = 0;
     }
 
+#define CHECK_INV_LBREAKS() \
+      do { \
+	if (newlines >= (inv_lbsize - 2)) \
+	  { \
+	    inv_lbsize *= 2; \
+	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
+	  } \
+      } while (0)
+	  
 #define CHECK_LPOS() \
       do { \
-        lpos++; \
-        if (lpos >= screenwidth) \
-          { \
-            inv_lbreaks[++newlines] = out; \
-            lpos = 0; \
-          } \
+	lpos++; \
+	if (lpos >= _rl_screenwidth) \
+	  { \
+	    if (newlines >= (inv_lbsize - 2)) \
+	      { \
+		inv_lbsize *= 2; \
+		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
+	      } \
+	    inv_lbreaks[++newlines] = out; \
+	    lpos = 0; \
+	  } \
       } while (0)
 
   /* inv_lbreaks[i] is where line i starts in the buffer. */
   inv_lbreaks[newlines = 0] = 0;
   lpos = out - wrap_offset;
 
-  /* XXX - what if lpos is already >= screenwidth before we start drawing the
+  /* prompt_invis_chars_first_line is the number of invisible characters in
+     the first physical line of the prompt.
+     wrap_offset - prompt_invis_chars_first_line is the number of invis
+     chars on the second line. */
+
+  /* what if lpos is already >= _rl_screenwidth before we start drawing the
      contents of the command line? */
-  while (lpos >= screenwidth)
+  while (lpos >= _rl_screenwidth)
     {
-      temp = ((newlines + 1) * screenwidth) - ((newlines == 0) ? wrap_offset : 0);
+      /* fix from Darin Johnson <darin@acuson.com> for prompt string with
+         invisible characters that is longer than the screen width.  The
+         prompt_invis_chars_first_line variable could be made into an array
+         saying how many invisible characters there are per line, but that's
+         probably too much work for the benefit gained.  How many people have
+         prompts that exceed two physical lines? */
+      temp = ((newlines + 1) * _rl_screenwidth) +
+             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
+             ((newlines == 1) ? wrap_offset : 0);
+
       inv_lbreaks[++newlines] = temp;
-      lpos -= screenwidth;
+      lpos -= _rl_screenwidth;
     }
 
+  prompt_last_screen_line = newlines;
+
+  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
+     track of where the cursor is (c_pos), the number of the line containing
+     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
+     It maintains an array of line breaks for display (inv_lbreaks).
+     This handles expanding tabs for display and displaying meta characters. */
   lb_linenum = 0;
   for (in = 0; in < rl_end; in++)
     {
       c = (unsigned char)rl_line_buffer[in];
 
       if (out + 8 >= line_size)		/* XXX - 8 for \t */
 	{
 	  line_size *= 2;
@@ -444,19 +542,20 @@ rl_redisplay ()
 	}
 
       if (META_CHAR (c))
 	{
 	  if (_rl_output_meta_chars == 0)
 	    {
 	      sprintf (line + out, "\\%o", c);
 
-	      if (lpos + 4 >= screenwidth)
+	      if (lpos + 4 >= _rl_screenwidth)
 		{
-		  temp = screenwidth - lpos;
+		  temp = _rl_screenwidth - lpos;
+		  CHECK_INV_LBREAKS ();
 		  inv_lbreaks[++newlines] = out + temp;
 		  lpos = 4 - temp;
 		}
 	      else
 		lpos += 4;
 
 	      out += 4;
 	    }
@@ -464,42 +563,49 @@ rl_redisplay ()
 	    {
 	      line[out++] = c;
 	      CHECK_LPOS();
 	    }
 	}
 #if defined (DISPLAY_TABS)
       else if (c == '\t')
 	{
-	  register int temp, newout;
+	  register int newout;
+
+#if 0
 	  newout = (out | (int)7) + 1;
+#else
+	  newout = out + 8 - lpos % 8;
+#endif
 	  temp = newout - out;
-	  if (lpos + temp >= screenwidth)
+	  if (lpos + temp >= _rl_screenwidth)
 	    {
 	      register int temp2;
-	      temp2 = screenwidth - lpos;
+	      temp2 = _rl_screenwidth - lpos;
+	      CHECK_INV_LBREAKS ();
 	      inv_lbreaks[++newlines] = out + temp2;
 	      lpos = temp - temp2;
 	      while (out < newout)
 		line[out++] = ' ';
 	    }
 	  else
 	    {
 	      while (out < newout)
 		line[out++] = ' ';
 	      lpos += temp;
 	    }
 	}
 #endif
-      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && term_up && *term_up)
-        {
-          line[out++] = '\0';	/* XXX - sentinel */
-          inv_lbreaks[++newlines] = out;
-          lpos = 0;
-        }
+      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
+	{
+	  line[out++] = '\0';	/* XXX - sentinel */
+	  CHECK_INV_LBREAKS ();
+	  inv_lbreaks[++newlines] = out;
+	  lpos = 0;
+	}
       else if (CTRL_CHAR (c) || c == RUBOUT)
 	{
 	  line[out++] = '^';
 	  CHECK_LPOS();
 	  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
 	  CHECK_LPOS();
 	}
       else
@@ -511,43 +617,45 @@ rl_redisplay ()
   line[out] = '\0';
   if (c_pos < 0)
     {
       c_pos = out;
       lb_linenum = newlines;
     }
 
   inv_botlin = lb_botlin = newlines;
+  CHECK_INV_LBREAKS ();
   inv_lbreaks[newlines+1] = out;
   cursor_linenum = lb_linenum;
 
-  /* C_POS == position in buffer where cursor should be placed. */
+  /* C_POS == position in buffer where cursor should be placed.
+     CURSOR_LINENUM == line number where the cursor should be placed. */
 
   /* PWP: now is when things get a bit hairy.  The visible and invisible
      line buffers are really multiple lines, which would wrap every
      (screenwidth - 1) characters.  Go through each in turn, finding
      the changed region and updating it.  The line order is top to bottom. */
 
   /* If we can move the cursor up and down, then use multiple lines,
      otherwise, let long lines display in a single terminal line, and
      horizontally scroll it. */
 
-  if (_rl_horizontal_scroll_mode == 0 && term_up && *term_up)
+  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
     {
       int nleft, pos, changed_screen_line;
 
       if (!rl_display_fixed || forced_display)
 	{
 	  forced_display = 0;
 
 	  /* If we have more than a screenful of material to display, then
 	     only display a screenful.  We should display the last screen,
 	     not the first.  */
-	  if (out >= screenchars)
-	    out = screenchars - 1;
+	  if (out >= _rl_screenchars)
+	    out = _rl_screenchars - 1;
 
 	  /* The first line is at character position 0 in the buffer.  The
 	     second and subsequent lines start at inv_lbreaks[N], offset by
 	     OFFSET (which has already been calculated above).  */
 
 #define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
 #define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
 #define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
@@ -567,17 +675,17 @@ rl_redisplay ()
 		 implies that we completely overwrite the old visible line)
 		 and the new line is shorter than the old.  Make sure we are
 		 at the end of the new line before clearing. */
 	      if (linenum == 0 &&
 		  inv_botlin == 0 && _rl_last_c_pos == out &&
 		  (wrap_offset > visible_wrap_offset) &&
 		  (_rl_last_c_pos < visible_first_line_len))
 		{
-		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
+		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
 		  if (nleft)
 		    _rl_clear_to_eol (nleft);
 		}
 
 	      /* Since the new first line is now visible, save its length. */
 	      if (linenum == 0)
 		visible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;
 	    }
@@ -588,46 +696,50 @@ rl_redisplay ()
 	    {
 	      char *tt;
 	      for (; linenum <= _rl_vis_botlin; linenum++)
 		{
 		  tt = VIS_CHARS (linenum);
 		  _rl_move_vert (linenum);
 		  _rl_move_cursor_relative (0, tt);
 		  _rl_clear_to_eol
-		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
+		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
 		}
 	    }
 	  _rl_vis_botlin = inv_botlin;
 
 	  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a
 	     different screen line during this redisplay. */
 	  changed_screen_line = _rl_last_v_pos != cursor_linenum;
 	  if (changed_screen_line)
 	    {
 	      _rl_move_vert (cursor_linenum);
-	      /* If we moved up to the line with the prompt using term_up,
-	         the physical cursor position on the screen stays the same,
-	         but the buffer position needs to be adjusted to account
-	         for invisible characters. */
+	      /* If we moved up to the line with the prompt using _rl_term_up,
+		 the physical cursor position on the screen stays the same,
+		 but the buffer position needs to be adjusted to account
+		 for invisible characters. */
 	      if (cursor_linenum == 0 && wrap_offset)
-	        _rl_last_c_pos += wrap_offset;
+		_rl_last_c_pos += wrap_offset;
 	    }
 
 	  /* We have to reprint the prompt if it contains invisible
 	     characters, since it's not generally OK to just reprint
 	     the characters from the current cursor position.  But we
 	     only need to reprint it if the cursor is before the last
 	     invisible character in the prompt string. */
-	  nleft = visible_length + wrap_offset;
+	  nleft = prompt_visible_length + wrap_offset;
 	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
-	      _rl_last_c_pos <= last_invisible && local_prompt)
+	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
 	    {
-	      if (term_cr)
-		tputs (term_cr, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+	      putc ('\r', rl_outstream);
+#else
+	      if (_rl_term_cr)
+		tputs (_rl_term_cr, 1, _rl_output_character_function);
+#endif
 	      _rl_output_some_chars (local_prompt, nleft);
 	      _rl_last_c_pos = nleft;
 	    }
 
 	  /* Where on that line?  And where does that line start
 	     in the buffer? */
 	  pos = inv_lbreaks[cursor_linenum];
 	  /* nleft == number of characters in the line buffer between the
@@ -655,103 +767,109 @@ rl_redisplay ()
       /* Always at top line. */
       _rl_last_v_pos = 0;
 
       /* Compute where in the buffer the displayed line should start.  This
 	 will be LMARGIN. */
 
       /* The number of characters that will be displayed before the cursor. */
       ndisp = c_pos - wrap_offset;
-      nleft  = visible_length + wrap_offset;
+      nleft  = prompt_visible_length + wrap_offset;
       /* Where the new cursor position will be on the screen.  This can be
-         longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
+	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
       phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
-      t = screenwidth / 3;
+      t = _rl_screenwidth / 3;
 
       /* If the number of characters had already exceeded the screenwidth,
-         last_lmargin will be > 0. */
+	 last_lmargin will be > 0. */
 
       /* If the number of characters to be displayed is more than the screen
-         width, compute the starting offset so that the cursor is about
-         two-thirds of the way across the screen. */
-      if (phys_c_pos > screenwidth - 2)
+	 width, compute the starting offset so that the cursor is about
+	 two-thirds of the way across the screen. */
+      if (phys_c_pos > _rl_screenwidth - 2)
 	{
 	  lmargin = c_pos - (2 * t);
 	  if (lmargin < 0)
 	    lmargin = 0;
 	  /* If the left margin would be in the middle of a prompt with
 	     invisible characters, don't display the prompt at all. */
 	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
 	    lmargin = nleft;
 	}
-      else if (ndisp < screenwidth - 2)		/* XXX - was -1 */
-        lmargin = 0;
+      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
+	lmargin = 0;
       else if (phys_c_pos < 1)
 	{
 	  /* If we are moving back towards the beginning of the line and
 	     the last margin is no longer correct, compute a new one. */
 	  lmargin = ((c_pos - 1) / t) * t;	/* XXX */
 	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
 	    lmargin = nleft;
 	}
       else
-        lmargin = last_lmargin;
+	lmargin = last_lmargin;
 
       /* If the first character on the screen isn't the first character
 	 in the display line, indicate this with a special character. */
       if (lmargin > 0)
 	line[lmargin] = '<';
 
       /* If SCREENWIDTH characters starting at LMARGIN do not encompass
-         the whole line, indicate that with a special characters at the
-         right edge of the screen.  If LMARGIN is 0, we need to take the
-         wrap offset into account. */
-      t = lmargin + M_OFFSET (lmargin, wrap_offset) + screenwidth;
+	 the whole line, indicate that with a special character at the
+	 right edge of the screen.  If LMARGIN is 0, we need to take the
+	 wrap offset into account. */
+      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
       if (t < out)
-        line[t - 1] = '>';
+	line[t - 1] = '>';
 
       if (!rl_display_fixed || forced_display || lmargin != last_lmargin)
 	{
 	  forced_display = 0;
 	  update_line (&visible_line[last_lmargin],
 		       &invisible_line[lmargin],
 		       0,
-		       screenwidth + visible_wrap_offset,
-		       screenwidth + (lmargin ? 0 : wrap_offset),
+		       _rl_screenwidth + visible_wrap_offset,
+		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
 		       0);
 
 	  /* If the visible new line is shorter than the old, but the number
 	     of invisible characters is greater, and we are at the end of
 	     the new line, we need to clear to eol. */
 	  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);
 	  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&
 	      (_rl_last_c_pos == out) &&
 	      t < visible_first_line_len)
 	    {
-	      nleft = screenwidth - t;
+	      nleft = _rl_screenwidth - t;
 	      _rl_clear_to_eol (nleft);
 	    }
 	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
-	  if (visible_first_line_len > screenwidth)
-	    visible_first_line_len = screenwidth;
+	  if (visible_first_line_len > _rl_screenwidth)
+	    visible_first_line_len = _rl_screenwidth;
 
 	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
 	  last_lmargin = lmargin;
 	}
     }
   fflush (rl_outstream);
 
   /* Swap visible and non-visible lines. */
   {
-    char *temp = visible_line;
-    int *itemp = vis_lbreaks;
+    char *vtemp = visible_line;
+    int *itemp = vis_lbreaks, ntemp = vis_lbsize;
+
     visible_line = invisible_line;
-    invisible_line = temp;
+    invisible_line = vtemp;
+
     vis_lbreaks = inv_lbreaks;
     inv_lbreaks = itemp;
+
+    vis_lbsize = inv_lbsize;
+    inv_lbsize = ntemp;
+
     rl_display_fixed = 0;
     /* If we are displaying on a single line, and last_lmargin is > 0, we
        are not displaying any invisible characters, so set visible_wrap_offset
        to 0. */
     if (_rl_horizontal_scroll_mode && last_lmargin)
       visible_wrap_offset = 0;
     else
       visible_wrap_offset = wrap_offset;
@@ -766,17 +884,17 @@ rl_redisplay ()
 	v		     v	      v		    v
 old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
 new:	eddie> Oh, my little buggy says to me, as lurgid as
 	^		     ^	^			   ^
 	\beginning of line   |	\new last same	   \new end of line
 			     \new first difference
 
    All are character pointers for the sake of speed.  Special cases for
-   no differences, as well as for end of line additions must be handeled.
+   no differences, as well as for end of line additions must be handled.
 
    Could be made even smarter, but this works well enough */
 static void
 update_line (old, new, current_line, omax, nmax, inv_botlin)
      register char *old, *new;
      int current_line, omax, nmax, inv_botlin;
 {
   register char *ofd, *ols, *oe, *nfd, *nls, *ne;
@@ -784,27 +902,27 @@ update_line (old, new, current_line, oma
   int current_invis_chars;
 
   /* If we're at the right edge of a terminal that supports xn, we're
      ready to wrap around, so do so.  This fixes problems with knowing
      the exact cursor position and cut-and-paste with certain terminal
      emulators.  In this calculation, TEMP is the physical screen
      position of the cursor. */
   temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
-  if (temp == screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
+  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
       && _rl_last_v_pos == current_line - 1)
     {
       if (new[0])
 	putc (new[0], rl_outstream);
       else
 	putc (' ', rl_outstream);
       _rl_last_c_pos = 1;		/* XXX */
       _rl_last_v_pos++;
       if (old[0] && new[0])
-        old[0] = new[0];
+	old[0] = new[0];
     }
       
   /* Find first difference. */
   for (ofd = old, nfd = new;
        (ofd - old < omax) && *ofd && (*ofd == *nfd);
        ofd++, nfd++)
     ;
 
@@ -861,67 +979,68 @@ update_line (old, new, current_line, oma
      This is not an efficiency hack -- there is a problem with redrawing
      portions of the prompt string if they contain terminal escape
      sequences (like drawing the `unbold' sequence without a corresponding
      `bold') that manifests itself on certain terminals. */
 
   lendiff = local_prompt ? strlen (local_prompt) : 0;
   od = ofd - old;	/* index of first difference in visible line */
   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
-      term_cr && lendiff > visible_length && _rl_last_c_pos > 0 &&
-      od > lendiff && _rl_last_c_pos < last_invisible)
+      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
+      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
     {
-      tputs (term_cr, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+      putc ('\r', rl_outstream);
+#else
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
+#endif
       _rl_output_some_chars (local_prompt, lendiff);
       _rl_last_c_pos = lendiff;
     }
 
   _rl_move_cursor_relative (od, old);
 
   /* if (len (new) > len (old)) */
   lendiff = (nls - nfd) - (ols - ofd);
 
   /* If we are changing the number of invisible characters in a line, and
      the spot of first difference is before the end of the invisible chars,
      lendiff needs to be adjusted. */
   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
       current_invis_chars != visible_wrap_offset)
-    {
-      temp = visible_wrap_offset - current_invis_chars;
-      lendiff += temp;
-    }
+    lendiff += visible_wrap_offset - current_invis_chars;
 
   /* Insert (diff (len (old), len (new)) ch. */
   temp = ne - nfd;
   if (lendiff > 0)
     {
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
       /* Sometimes it is cheaper to print the characters rather than
 	 use the terminal's capabilities.  If we're growing the number
 	 of lines, make sure we actually cause the new line to wrap
 	 around on auto-wrapping terminals. */
-      if (terminal_can_insert && ((2 * temp) >= lendiff || term_IC) && (!_rl_term_autowrap || !gl))
+      if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
 	{
-	  /* If lendiff > visible_length and _rl_last_c_pos == 0 and
+	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
 	     _rl_horizontal_scroll_mode == 1, inserting the characters with
-	     term_IC or term_ic will screw up the screen because of the
+	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
 	     invisible characters.  We need to just draw them. */
 	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
-			lendiff <= visible_length || !current_invis_chars))
+			lendiff <= prompt_visible_length || !current_invis_chars))
 	    {
 	      insert_some_chars (nfd, lendiff);
 	      _rl_last_c_pos += lendiff;
 	    }
 	  else if (*ols == 0)
 	    {
 	      /* At the end of a line the characters do not have to
 		 be "inserted".  They can just be placed on the screen. */
 	      /* However, this screws up the rest of this block, which
-	         assumes you've done the insert because you can. */
+		 assumes you've done the insert because you can. */
 	      _rl_output_some_chars (nfd, lendiff);
 	      _rl_last_c_pos += lendiff;
 	    }
 	  else
 	    {
 	      /* We have horizontal scrolling and we are not inserting at
 		 the end.  We have invisible characters in this line.  This
 		 is a dumb update. */
@@ -942,17 +1061,17 @@ update_line (old, new, current_line, oma
 	  /* cannot insert chars, write to EOL */
 	  _rl_output_some_chars (nfd, temp);
 	  _rl_last_c_pos += temp;
 	}
     }
   else				/* Delete characters from line. */
     {
       /* If possible and inexpensive to use terminal deletion, then do so. */
-      if (term_dc && (2 * temp) >= -lendiff)
+      if (_rl_term_dc && (2 * temp) >= -lendiff)
 	{
 	  /* If all we're doing is erasing the invisible characters in the
 	     prompt string, don't bother.  It screws up the assumptions
 	     about what's on the screen. */
 	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
 	      -lendiff == visible_wrap_offset)
 	    lendiff = 0;
 
@@ -971,20 +1090,23 @@ update_line (old, new, current_line, oma
       else
 	{
 	  if (temp > 0)
 	    {
 	      _rl_output_some_chars (nfd, temp);
 	      _rl_last_c_pos += temp;
 	    }
 	  lendiff = (oe - old) - (ne - new);
-	  if (_rl_term_autowrap && current_line < inv_botlin)
-	    space_to_eol (lendiff);
-	  else
-	    _rl_clear_to_eol (lendiff);
+	  if (lendiff)
+	    {	  
+	      if (_rl_term_autowrap && current_line < inv_botlin)
+		space_to_eol (lendiff);
+	      else
+		_rl_clear_to_eol (lendiff);
+	    }
 	}
     }
 }
 
 /* Tell the update routines that we have moved onto a new (empty) line. */
 int
 rl_on_new_line ()
 {
@@ -994,124 +1116,169 @@ rl_on_new_line ()
   _rl_last_c_pos = _rl_last_v_pos = 0;
   _rl_vis_botlin = last_lmargin = 0;
   if (vis_lbreaks)
     vis_lbreaks[0] = vis_lbreaks[1] = 0;
   visible_wrap_offset = 0;
   return 0;
 }
 
+/* Tell the update routines that we have moved onto a new line with the
+   prompt already displayed.  Code originally from the version of readline
+   distributed with CLISP. */
+int
+rl_on_new_line_with_prompt ()
+{
+  int prompt_size, i, l, real_screenwidth, newlines;
+  char *prompt_last_line;
+
+  /* Initialize visible_line and invisible_line to ensure that they can hold
+     the already-displayed prompt. */
+  prompt_size = strlen (rl_prompt) + 1;
+  init_line_structures (prompt_size);
+
+  /* Make sure the line structures hold the already-displayed prompt for
+     redisplay. */
+  strcpy (visible_line, rl_prompt);
+  strcpy (invisible_line, rl_prompt);
+
+  /* If the prompt contains newlines, take the last tail. */
+  prompt_last_line = strrchr (rl_prompt, '\n');
+  if (!prompt_last_line)
+    prompt_last_line = rl_prompt;
+
+  l = strlen (prompt_last_line);
+  _rl_last_c_pos = l;
+
+  /* Dissect prompt_last_line into screen lines. Note that here we have
+     to use the real screenwidth. Readline's notion of screenwidth might be
+     one less, see terminal.c. */
+  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
+  _rl_last_v_pos = l / real_screenwidth;
+  /* If the prompt length is a multiple of real_screenwidth, we don't know
+     whether the cursor is at the end of the last line, or already at the
+     beginning of the next line. Output a newline just to be safe. */
+  if (l > 0 && (l % real_screenwidth) == 0)
+    _rl_output_some_chars ("\n", 1);
+  last_lmargin = 0;
+
+  newlines = 0; i = 0;
+  while (i <= l)
+    {
+      _rl_vis_botlin = newlines;
+      vis_lbreaks[newlines++] = i;
+      i += real_screenwidth;
+    }
+  vis_lbreaks[newlines] = l;
+  visible_wrap_offset = 0;
+
+  return 0;
+}
+
 /* Actually update the display, period. */
 int
 rl_forced_update_display ()
 {
   if (visible_line)
     {
       register char *temp = visible_line;
 
       while (*temp)
-        *temp++ = '\0';
+	*temp++ = '\0';
     }
   rl_on_new_line ();
   forced_display++;
   (*rl_redisplay_function) ();
   return 0;
 }
 
 /* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
    DATA is the contents of the screen line of interest; i.e., where
    the movement is being done. */
 void
 _rl_move_cursor_relative (new, data)
      int new;
-     char *data;
+     const char *data;
 {
   register int i;
 
   /* If we don't have to do anything, then return. */
   if (_rl_last_c_pos == new) return;
 
   /* It may be faster to output a CR, and then move forwards instead
      of moving backwards. */
   /* i == current physical cursor position. */
   i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
   if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
-      (_rl_term_autowrap && i == screenwidth))
+      (_rl_term_autowrap && i == _rl_screenwidth))
     {
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif /* !__MSDOS__ */
       _rl_last_c_pos = 0;
     }
 
   if (_rl_last_c_pos < new)
     {
       /* Move the cursor forward.  We do it by printing the command
 	 to move the cursor forward if there is one, else print that
 	 portion of the output buffer again.  Which is cheaper? */
 
       /* The above comment is left here for posterity.  It is faster
 	 to print one character (non-control) than to print a control
 	 sequence telling the terminal to move forward one character.
 	 That kind of control is for people who don't know what the
 	 data is underneath the cursor. */
 #if defined (HACK_TERMCAP_MOTION)
-      extern char *term_forward_char;
-
-      if (term_forward_char)
+      if (_rl_term_forward_char)
 	for (i = _rl_last_c_pos; i < new; i++)
-	  tputs (term_forward_char, 1, _rl_output_character_function);
+	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
       else
 	for (i = _rl_last_c_pos; i < new; i++)
 	  putc (data[i], rl_outstream);
 #else
       for (i = _rl_last_c_pos; i < new; i++)
 	putc (data[i], rl_outstream);
 #endif /* HACK_TERMCAP_MOTION */
     }
-  else if (_rl_last_c_pos != new)
+  else if (_rl_last_c_pos > new)
     _rl_backspace (_rl_last_c_pos - new);
   _rl_last_c_pos = new;
 }
 
 /* PWP: move the cursor up or down. */
 void
 _rl_move_vert (to)
      int to;
 {
   register int delta, i;
 
-  if (_rl_last_v_pos == to || to > screenheight)
+  if (_rl_last_v_pos == to || to > _rl_screenheight)
     return;
 
-#if defined (__GO32__)
-  {
-    int row, col;
-
-    ScreenGetCursor (&row, &col);
-    ScreenSetCursor ((row + to - _rl_last_v_pos), col);
-  }
-#else /* !__GO32__ */
-
   if ((delta = to - _rl_last_v_pos) > 0)
     {
       for (i = 0; i < delta; i++)
 	putc ('\n', rl_outstream);
-      tputs (term_cr, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+      putc ('\r', rl_outstream);
+#else
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
+#endif
       _rl_last_c_pos = 0;
     }
   else
     {			/* delta < 0 */
-      if (term_up && *term_up)
+      if (_rl_term_up && *_rl_term_up)
 	for (i = 0; i < -delta; i++)
-	  tputs (term_up, 1, _rl_output_character_function);
+	  tputs (_rl_term_up, 1, _rl_output_character_function);
     }
-#endif /* !__GO32__ */
+
   _rl_last_v_pos = to;		/* Now TO is here */
 }
 
 /* Physically print C on rl_outstream.  This is for functions which know
    how to optimize the display.  Return the number of characters output. */
 int
 rl_show_char (c)
      int c;
@@ -1229,70 +1396,68 @@ rl_reset_line_state ()
 }
 
 static char *saved_local_prompt;
 static char *saved_local_prefix;
 static int saved_last_invisible;
 static int saved_visible_length;
 
 void
-_rl_save_prompt ()
+rl_save_prompt ()
 {
   saved_local_prompt = local_prompt;
   saved_local_prefix = local_prompt_prefix;
-  saved_last_invisible = last_invisible;
-  saved_visible_length = visible_length;
+  saved_last_invisible = prompt_last_invisible;
+  saved_visible_length = prompt_visible_length;
 
   local_prompt = local_prompt_prefix = (char *)0;
-  last_invisible = visible_length = 0;
+  prompt_last_invisible = prompt_visible_length = 0;
 }
 
 void
-_rl_restore_prompt ()
+rl_restore_prompt ()
 {
-  if (local_prompt)
-    free (local_prompt);
-  if (local_prompt_prefix)
-    free (local_prompt_prefix);
+  FREE (local_prompt);
+  FREE (local_prompt_prefix);
 
   local_prompt = saved_local_prompt;
   local_prompt_prefix = saved_local_prefix;
-  last_invisible = saved_last_invisible;
-  visible_length = saved_visible_length;
+  prompt_last_invisible = saved_last_invisible;
+  prompt_visible_length = saved_visible_length;
 }
 
 char *
 _rl_make_prompt_for_search (pchar)
      int pchar;
 {
   int len;
   char *pmt;
 
-  _rl_save_prompt ();
+  rl_save_prompt ();
 
   if (saved_local_prompt == 0)
     {
       len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
       pmt = xmalloc (len + 2);
       if (len)
-        strcpy (pmt, rl_prompt);
+	strcpy (pmt, rl_prompt);
       pmt[len] = pchar;
       pmt[len+1] = '\0';
     }
   else
     {
       len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
       pmt = xmalloc (len + 2);
       if (len)
-        strcpy (pmt, saved_local_prompt);
+	strcpy (pmt, saved_local_prompt);
       pmt[len] = pchar;
       pmt[len+1] = '\0';
       local_prompt = savestring (pmt);
-      last_invisible = saved_last_invisible;
-      visible_length = saved_visible_length + 1;
+      prompt_last_invisible = saved_last_invisible;
+      prompt_visible_length = saved_visible_length + 1;
     }
   return pmt;
 }
 
 /* Quick redisplay hack when erasing characters at the end of the line. */
 void
 _rl_erase_at_end_of_line (l)
      int l;
@@ -1309,21 +1474,19 @@ void
 }
 
 /* Clear to the end of the line.  COUNT is the minimum
    number of character spaces to clear, */
 void
 _rl_clear_to_eol (count)
      int count;
 {
-#if !defined (__GO32__)
-  if (term_clreol)
-    tputs (term_clreol, 1, _rl_output_character_function);
+  if (_rl_term_clreol)
+    tputs (_rl_term_clreol, 1, _rl_output_character_function);
   else if (count)
-#endif /* !__GO32__ */
     space_to_eol (count);
 }
 
 /* Clear to the end of the line using spaces.  COUNT is the minimum
    number of character spaces to clear, */
 static void
 space_to_eol (count)
      int count;
@@ -1334,112 +1497,82 @@ space_to_eol (count)
    putc (' ', rl_outstream);
 
   _rl_last_c_pos += count;
 }
 
 void
 _rl_clear_screen ()
 {
-#if !defined (__GO32__)
-  if (term_clrpag)
-    tputs (term_clrpag, 1, _rl_output_character_function);
+  if (_rl_term_clrpag)
+    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
   else
-#endif /* !__GO32__ */
-    crlf ();
+    rl_crlf ();
 }
 
 /* Insert COUNT characters from STRING to the output stream. */
 static void
 insert_some_chars (string, count)
      char *string;
      int count;
 {
-#if defined (__GO32__)
-  int row, col, width;
-  char *row_start;
-
-  ScreenGetCursor (&row, &col);
-  width = ScreenCols ();
-  row_start = ScreenPrimary + (row * width);
-
-  memcpy (row_start + col + count, row_start + col, width - col - count);
-
-  /* Place the text on the screen. */
-  _rl_output_some_chars (string, count);
-#else /* !_GO32 */
-
   /* If IC is defined, then we do not have to "enter" insert mode. */
-  if (term_IC)
+  if (_rl_term_IC)
     {
       char *buffer;
-      buffer = tgoto (term_IC, 0, count);
+      buffer = tgoto (_rl_term_IC, 0, count);
       tputs (buffer, 1, _rl_output_character_function);
       _rl_output_some_chars (string, count);
     }
   else
     {
       register int i;
 
       /* If we have to turn on insert-mode, then do so. */
-      if (term_im && *term_im)
-	tputs (term_im, 1, _rl_output_character_function);
+      if (_rl_term_im && *_rl_term_im)
+	tputs (_rl_term_im, 1, _rl_output_character_function);
 
       /* If there is a special command for inserting characters, then
 	 use that first to open up the space. */
-      if (term_ic && *term_ic)
+      if (_rl_term_ic && *_rl_term_ic)
 	{
 	  for (i = count; i--; )
-	    tputs (term_ic, 1, _rl_output_character_function);
+	    tputs (_rl_term_ic, 1, _rl_output_character_function);
 	}
 
       /* Print the text. */
       _rl_output_some_chars (string, count);
 
       /* If there is a string to turn off insert mode, we had best use
 	 it now. */
-      if (term_ei && *term_ei)
-	tputs (term_ei, 1, _rl_output_character_function);
+      if (_rl_term_ei && *_rl_term_ei)
+	tputs (_rl_term_ei, 1, _rl_output_character_function);
     }
-#endif /* !__GO32__ */
 }
 
 /* Delete COUNT characters from the display line. */
 static void
 delete_chars (count)
      int count;
 {
-#if defined (__GO32__)
-  int row, col, width;
-  char *row_start;
-
-  ScreenGetCursor (&row, &col);
-  width = ScreenCols ();
-  row_start = ScreenPrimary + (row * width);
-
-  memcpy (row_start + col, row_start + col + count, width - col - count);
-  memset (row_start + width - count, 0, count * 2);
-#else /* !_GO32 */
-
-  if (count > screenwidth)	/* XXX */
+  if (count > _rl_screenwidth)	/* XXX */
     return;
 
-  if (term_DC && *term_DC)
+  if (_rl_term_DC && *_rl_term_DC)
     {
       char *buffer;
-      buffer = tgoto (term_DC, count, count);
+      buffer = tgoto (_rl_term_DC, count, count);
       tputs (buffer, count, _rl_output_character_function);
     }
   else
     {
-      if (term_dc && *term_dc)
+      if (_rl_term_dc && *_rl_term_dc)
 	while (count--)
-	  tputs (term_dc, 1, _rl_output_character_function);
+	  tputs (_rl_term_dc, 1, _rl_output_character_function);
     }
-#endif /* !__GO32__ */
 }
 
 void
 _rl_update_final ()
 {
   int full_lines;
 
   full_lines = 0;
@@ -1448,82 +1581,160 @@ void
   if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
 	visible_line[vis_lbreaks[_rl_vis_botlin]] == 0)
     {
       _rl_vis_botlin--;
       full_lines = 1;
     }
   _rl_move_vert (_rl_vis_botlin);
   /* If we've wrapped lines, remove the final xterm line-wrap flag. */
-  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == screenwidth))
+  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
     {
       char *last_line;
+#if 0
       last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
-      _rl_move_cursor_relative (screenwidth - 1, last_line);
+#else
+      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
+#endif
+      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
       _rl_clear_to_eol (0);
-      putc (last_line[screenwidth - 1], rl_outstream);
+      putc (last_line[_rl_screenwidth - 1], rl_outstream);
     }
   _rl_vis_botlin = 0;
-  crlf ();
+  rl_crlf ();
   fflush (rl_outstream);
   rl_display_fixed++;
 }
 
 /* Move to the start of the current line. */
 static void
 cr ()
 {
-  if (term_cr)
+  if (_rl_term_cr)
     {
-      tputs (term_cr, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+      putc ('\r', rl_outstream);
+#else
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
+#endif
       _rl_last_c_pos = 0;
     }
 }
 
+/* Redraw the last line of a multi-line prompt that may possibly contain
+   terminal escape sequences.  Called with the cursor at column 0 of the
+   line to draw the prompt on. */
+static void
+redraw_prompt (t)
+     char *t;
+{
+  char *oldp, *oldl, *oldlprefix;
+  int oldlen, oldlast, oldplen, oldninvis;
+
+  /* Geez, I should make this a struct. */
+  oldp = rl_display_prompt;
+  oldl = local_prompt;
+  oldlprefix = local_prompt_prefix;
+  oldlen = prompt_visible_length;
+  oldplen = prompt_prefix_length;
+  oldlast = prompt_last_invisible;
+  oldninvis = prompt_invis_chars_first_line;
+
+  rl_display_prompt = t;
+  local_prompt = expand_prompt (t, &prompt_visible_length,
+				   &prompt_last_invisible,
+				   &prompt_invis_chars_first_line);
+  local_prompt_prefix = (char *)NULL;
+  rl_forced_update_display ();
+
+  rl_display_prompt = oldp;
+  local_prompt = oldl;
+  local_prompt_prefix = oldlprefix;
+  prompt_visible_length = oldlen;
+  prompt_prefix_length = oldplen;
+  prompt_last_invisible = oldlast;
+  prompt_invis_chars_first_line = oldninvis;
+}
+      
 /* Redisplay the current line after a SIGWINCH is received. */
 void
 _rl_redisplay_after_sigwinch ()
 {
-  char *t, *oldp;
+  char *t;
 
   /* Clear the current line and put the cursor at column 0.  Make sure
      the right thing happens if we have wrapped to a new screen line. */
-  if (term_cr)
+  if (_rl_term_cr)
     {
-      tputs (term_cr, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+      putc ('\r', rl_outstream);
+#else
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
+#endif
       _rl_last_c_pos = 0;
-      if (term_clreol)
-	tputs (term_clreol, 1, _rl_output_character_function);
+#if defined (__MSDOS__)
+      space_to_eol (_rl_screenwidth);
+      putc ('\r', rl_outstream);
+#else
+      if (_rl_term_clreol)
+	tputs (_rl_term_clreol, 1, _rl_output_character_function);
       else
 	{
-	  space_to_eol (screenwidth);
-	  tputs (term_cr, 1, _rl_output_character_function);
+	  space_to_eol (_rl_screenwidth);
+	  tputs (_rl_term_cr, 1, _rl_output_character_function);
 	}
+#endif
       if (_rl_last_v_pos > 0)
 	_rl_move_vert (0);
     }
   else
-    crlf ();
+    rl_crlf ();
 
   /* Redraw only the last line of a multi-line prompt. */
   t = strrchr (rl_display_prompt, '\n');
   if (t)
-    {
-      oldp = rl_display_prompt;
-      rl_display_prompt = ++t;
-      rl_forced_update_display ();
-      rl_display_prompt = oldp;
-    }
+    redraw_prompt (++t);
   else
     rl_forced_update_display ();
 }
 
 void
 _rl_clean_up_for_exit ()
 {
   if (readline_echoing_p)
     {
       _rl_move_vert (_rl_vis_botlin);
       _rl_vis_botlin = 0;
       fflush (rl_outstream);
-      rl_restart_output ();
+      rl_restart_output (1, 0);
     }
 }
+
+void
+_rl_erase_entire_line ()
+{
+  cr ();
+  _rl_clear_to_eol (0);
+  cr ();
+  fflush (rl_outstream);
+}
+
+/* return the `current display line' of the cursor -- the number of lines to
+   move up to get to the first screen line of the current readline line. */
+int
+_rl_current_display_line ()
+{
+  int ret, nleft;
+
+  /* Find out whether or not there might be invisible characters in the
+     editing buffer. */
+  if (rl_display_prompt == rl_prompt)
+    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
+  else
+    nleft = _rl_last_c_pos - _rl_screenwidth;
+
+  if (nleft > 0)
+    ret = 1 + nleft / _rl_screenwidth;
+  else
+    ret = 0;
+
+  return ret;
+}
diff --git a/readline/doc/Makefile.in b/readline/doc/Makefile.in
--- a/readline/doc/Makefile.in
+++ b/readline/doc/Makefile.in
@@ -1,51 +1,80 @@
 # This makefile for Readline library documentation is in -*- text -*- mode.
 # Emacs likes it that way.
-top_srcdir = @top_srcdir@
+
+# Copyright (C) 1996 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
+topdir = @top_srcdir@
 srcdir = @srcdir@
+VPATH = .:@srcdir@
 
 prefix = @prefix@
 infodir = @infodir@
 
 mandir = @mandir@
-man3dir = $(mandir)/man3
+manpfx = man
 
+man1ext = 1
+man1dir = $(mandir)/$(manpfx)$(man1ext)
+man3ext = 3
+man3dir = $(mandir)/$(manpfx)$(man3ext)
+
+SHELL = @MAKE_SHELL@
 RM = rm -f
 
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+
+BUILD_DIR = @BUILD_DIR@
 TEXINPUTDIR = $(srcdir)
 
-MAKEINFO    = makeinfo
+MAKEINFO    = LANGUAGE= makeinfo
 TEXI2DVI    = $(srcdir)/texi2dvi
 TEXI2HTML   = $(srcdir)/texi2html
 QUIETPS     = #set this to -q to shut up dvips
-DVIPS       = dvips -D 300 $(QUIETPS) -o $@     # tricky
-
-INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
+PAPERSIZE   = letter
+PSDPI       = 300	# I don't have any 600-dpi printers
+DVIPS       = dvips -D ${PSDPI} $(QUIETPS) -t ${PAPERSIZE} -o $@     # tricky
 
 RLSRC = $(srcdir)/rlman.texinfo $(srcdir)/rluser.texinfo \
-	$(srcdir)/rltech.texinfo
+	$(srcdir)/rltech.texinfo $(srcdir)/manvers.texinfo \
+	$(srcdir)/rluserman.texinfo
 HISTSRC = $(srcdir)/hist.texinfo $(srcdir)/hsuser.texinfo \
-	  $(srcdir)/hstech.texinfo
+	  $(srcdir)/hstech.texinfo $(srcdir)/manvers.texinfo
 
 # This should be a program that converts troff to an ascii-readable format
 NROFF       = groff -Tascii
 
 # This should be a program that converts troff to postscript
 GROFF       = groff
 
-DVIOBJ = readline.dvi history.dvi
-INFOOBJ = readline.info history.info
-PSOBJ = readline.ps history.ps
-HTMLOBJ = readline.html history.html
+DVIOBJ = readline.dvi history.dvi rluserman.dvi
+INFOOBJ = readline.info history.info rluserman.info
+PSOBJ = readline.ps history.ps rluserman.ps readline_3.ps
+HTMLOBJ = readline.html history.html rluserman.html
 TEXTOBJ = readline.0
 
-CREATED_DOCS = $(DVIOBJ) $(INFOOBJ) $(PSOBJ) $(HTMLOBJ) $(TEXTOBJ)
+INTERMEDIATE_OBJ = rlman.dvi hist.dvi rluserman.dvi
+
+DIST_DOCS = $(DVIOBJ) $(PSOBJ) $(HTMLOBJ) $(INFOOBJ) $(TEXTOBJ)
 
 .SUFFIXES:      .0 .3 .ps .txt .dvi
 
 .3.0:
 	$(RM) $@
 	-${NROFF} -man $< > $@
 
 all: info dvi html ps text
@@ -53,71 +82,103 @@ nodvi: info html text
 
 readline.dvi: $(RLSRC)
 	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/rlman.texinfo
 	mv rlman.dvi readline.dvi
 
 readline.info: $(RLSRC)
 	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/rlman.texinfo
 
+rluserman.dvi: $(RLSRC)
+	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/rluserman.texinfo
+
+rluserman.info: $(RLSRC)
+	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/rluserman.texinfo
+
 history.dvi: ${HISTSRC}
 	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/hist.texinfo
 	mv hist.dvi history.dvi
 
 history.info: ${HISTSRC}
 	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/hist.texinfo
 
 readline.ps:	readline.dvi
 	$(RM) $@
 	$(DVIPS) readline.dvi
 
+rluserman.ps:	rluserman.dvi
+	$(RM) $@
+	$(DVIPS) rluserman.dvi
+
 history.ps:	history.dvi
 	$(RM) $@
 	$(DVIPS) history.dvi
 
 readline.html:	${RLSRC}
-	$(TEXI2HTML) -I $(TEXINPUTDIR) $(srcdir)/rlman.texinfo
-	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman.html > readline.html
-	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman_toc.html > readline_toc.html
-	$(RM) rlman.html rlman_toc.html
+	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rlman.texinfo
+	sed -e 's:rlman.html:readline.html:g' rlman.html > readline.html
+	$(RM) rlman.html
+
+rluserman.html:	${RLSRC}
+	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rluserman.texinfo
 
 history.html:	${HISTSRC}
-	$(TEXI2HTML) -I $(TEXINPUTDIR) $(srcdir)/hist.texinfo
-	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist.html > history.html
-	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist_toc.html > history_toc.html
-	$(RM) hist.html hist_toc.html
+	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/hist.texinfo
+	sed -e 's:hist.html:history.html:g' hist.html > history.html
+	$(RM) hist.html
 
 info:	$(INFOOBJ)
 dvi:	$(DVIOBJ)
 ps:	$(PSOBJ)
 html:	$(HTMLOBJ)
 text:	$(TEXTOBJ)
 
-readline.0: $(srcdir)/readline.3
+readline.0: readline.3
+
+readline_3.ps: readline.3
+	${RM} $@
+	${GROFF} -man < readline.3 > $@ 
 
 clean:
 	$(RM) *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps *.pgs \
-	      *.fns *.kys *.tps *.vrs *.o core
+	      *.fns *.kys *.tps *.vrs *.bt *.bts *.o core
 
 distclean: clean
-	$(RM) $(CREATED_DOCS)
+	$(RM) $(INTERMEDIATE_OBJ)
+	$(RM) Makefile
 
 mostlyclean: clean
 
 maintainer-clean: clean
-	$(RM) $(CREATED_DOCS)
+	$(RM) $(DIST_DOCS)
+	$(RM) $(INTERMEDIATE_OBJ)
+	$(RM) Makefile
 
-installdirs:	$(top_srcdir)/support/mkdirs
-	-$(SHELL) $(top_srcdir)/support/mkdirs $(infodir) $(man3dir)
+installdirs:	$(topdir)/support/mkdirs
+	-$(SHELL) $(topdir)/support/mkdirs $(infodir) $(man3dir)
 
-install:	installdirs info
-	${INSTALL_DATA} readline.info $(infodir)/readline.info
-	${INSTALL_DATA} history.info $(infodir)/history.info
-	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+install:	installdirs
+	if test -f readline.info; then \
+		${INSTALL_DATA} readline.info $(infodir)/readline.info; \
+	else \
+		${INSTALL_DATA} $(srcdir)/readline.info $(infodir)/readline.info; \
+	fi
+	if test -f rluserman.info; then \
+		${INSTALL_DATA} rluserman.info $(infodir)/rluserman.info; \
+	else \
+		${INSTALL_DATA} $(srcdir)/rluserman.info $(infodir)/rluserman.info; \
+	fi
+	if test -f history.info; then \
+		${INSTALL_DATA} history.info $(infodir)/history.info; \
+	else \
+		${INSTALL_DATA} $(srcdir)/history.info $(infodir)/history.info; \
+	fi
+	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
 		install-info --dir-file=$(infodir)/dir $(infodir)/readline.info ; \
 		install-info --dir-file=$(infodir)/dir $(infodir)/history.info ; \
 	else true; fi
 	-${INSTALL_DATA} $(srcdir)/readline.3 $(man3dir)/readline.3
 
 uninstall:
 	$(RM) $(infodir)/readline.info
+	$(RM) $(infodir)/rluserman.info
 	$(RM) $(infodir)/history.info
 	$(RM) $(man3dir)/readline.3
diff --git a/readline/doc/hist.texinfo b/readline/doc/hist.texinfo
--- a/readline/doc/hist.texinfo
+++ b/readline/doc/hist.texinfo
@@ -1,31 +1,29 @@
 \input texinfo    @c -*-texinfo-*-
 @c %**start of header (This is for running Texinfo on a region.)
 @setfilename history.info
 @settitle GNU History Library
 @c %**end of header (This is for running Texinfo on a region.)
 
 @setchapternewpage odd
 
-@ignore
-last change: Thu Mar 21 16:07:29 EST 1996
-@end ignore
-
-@set EDITION 2.1
-@set VERSION 2.1
-@set UPDATED 21 March 1996
-@set UPDATE-MONTH March 1996
+@include manvers.texinfo
 
 @ifinfo
+@dircategory Libraries
+@direntry
+* History: (history).       The GNU history library API
+@end direntry
+
 This document describes the GNU History library, a programming tool that
 provides a consistent user interface for recalling lines of previously
 typed input.
 
-Copyright (C) 1988, 1991, 1993, 1995, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
 pare preserved on all copies.
 
 @ignore
 Permission is granted to process this file through TeX and print the
 results, provided the printed document carries copying permission
@@ -36,17 +34,17 @@ notice identical to this one except for 
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided that the entire
 resulting derived work is distributed under the terms of a permission
 notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
-by the Foundation.
+by the Free Software Foundation.
 @end ifinfo
 
 @titlepage
 @title GNU History Library
 @subtitle Edition @value{EDITION}, for @code{History Library} Version @value{VERSION}.
 @subtitle @value{UPDATE-MONTH}
 @author Brian Fox, Free Software Foundation
 @author Chet Ramey, Case Western Reserve University
@@ -67,20 +65,20 @@ are preserved on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided that the entire
 resulting derived work is distributed under the terms of a permission
 notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
-by the Foundation.
+by the Free Software Foundation.
 
 @vskip 0pt plus 1filll
-Copyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
+Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
 @end titlepage
 
 @ifinfo
 @node Top
 @top GNU History Library
 
 This document describes the GNU History library, a programming tool that
 provides a consistent user interface for recalling lines of previously
diff --git a/readline/doc/hstech.texinfo b/readline/doc/hstech.texinfo
--- a/readline/doc/hstech.texinfo
+++ b/readline/doc/hstech.texinfo
@@ -1,12 +1,12 @@
 @ignore
 This file documents the user interface to the GNU History library.
 
-Copyright (C) 1988, 1991, 1994, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved on
 all copies.
 
 Permission is granted to process this file through Tex and print the
 results, provided the printed document carries copying permission notice
@@ -22,36 +22,36 @@ permission notice identical to this one.
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions.
 @end ignore
 
 @node Programming with GNU History
 @chapter Programming with GNU History
 
 This chapter describes how to interface programs that you write
-with the GNU History Library.
+with the @sc{gnu} History Library.
 It should be considered a technical guide.
-For information on the interactive use of GNU History, @pxref{Using
+For information on the interactive use of @sc{gnu} History, @pxref{Using
 History Interactively}.
 
 @menu
 * Introduction to History::	What is the GNU History library for?
 * History Storage::		How information is stored.
 * History Functions::		Functions that you can use.
 * History Variables::		Variables that control behaviour.
 * History Programming Example::	Example of using the GNU History Library.
 @end menu
 
 @node Introduction to History
 @section Introduction to History
 
-Many programs read input from the user a line at a time.  The GNU History
-library is able to keep track of those lines, associate arbitrary data with
-each line, and utilize information from previous lines in composing new
-ones.
+Many programs read input from the user a line at a time.  The @sc{gnu}
+History library is able to keep track of those lines, associate arbitrary
+data with each line, and utilize information from previous lines in
+composing new ones. 
 
 The programmer using the History library has available functions
 for remembering lines on a history list, associating arbitrary data
 with a line, removing lines from the list, searching through the list
 for a line containing an arbitrary text string, and referencing any line
 in the list directly.  In addition, a history @dfn{expansion} function
 is available which provides for a consistent user interface across
 different programs.
@@ -61,44 +61,53 @@ benefit of a consistent user interface w
 commands for manipulating the text of previous lines and using that text
 in new commands.  The basic history manipulation commands are similar to
 the history substitution provided by @code{csh}.
 
 If the programmer desires, he can use the Readline library, which
 includes some history manipulation by default, and has the added
 advantage of command line editing.
 
+Before declaring any functions using any functionality the History
+library provides in other code, an application writer should include
+the file @code{<readline/history.h>} in any file that uses the
+History library's features.  It supplies extern declarations for all
+of the library's public functions and variables, and declares all of
+the public data structures.
+
 @node History Storage
 @section History Storage
 
 The history list is an array of history entries.  A history entry is
 declared as follows:
 
 @example
+typedef void *histdata_t;
+
 typedef struct _hist_entry @{
   char *line;
-  char *data;
+  histdata_t data;
 @} HIST_ENTRY;
 @end example
 
 The history list itself might therefore be declared as
 
 @example
 HIST_ENTRY **the_history_list;
 @end example
 
 The state of the History library is encapsulated into a single structure:
 
 @example
-/* A structure used to pass the current state of the history stuff around. */
+/* A structure used to pass around the current state of the history. */
 typedef struct _hist_state @{
-  HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
-  int offset;                   /* The location pointer within this array. */
-  int length;                   /* Number of elements within this array. */
-  int size;                     /* Number of slots allocated to this array. */
+  HIST_ENTRY **entries; /* Pointer to the entries themselves. */
+  int offset;           /* The location pointer within this array. */
+  int length;           /* Number of elements within this array. */
+  int size;             /* Number of slots allocated to this array. */
   int flags;
 @} HISTORY_STATE;
 @end example
 
 If the flags member includes @code{HS_STIFLED}, the history has been
 stifled.
 
 @node History Functions
@@ -127,264 +136,268 @@ present in GNU History.
 
 @node Initializing History and State Management
 @subsection Initializing History and State Management
 
 This section describes functions used to initialize and manage
 the state of the History library when you want to use the history
 functions in your program.
 
-@deftypefun void using_history ()
+@deftypefun void using_history (void)
 Begin a session in which the history functions might be used.  This
 initializes the interactive variables.
 @end deftypefun
 
-@deftypefun {HISTORY_STATE *} history_get_history_state ()
+@deftypefun {HISTORY_STATE *} history_get_history_state (void)
 Return a structure describing the current state of the input history.
 @end deftypefun
 
 @deftypefun void history_set_history_state (HISTORY_STATE *state)
 Set the state of the history list according to @var{state}.
 @end deftypefun
 
 @node History List Management
 @subsection History List Management
 
 These functions manage individual entries on the history list, or set
 parameters managing the list itself.
 
-@deftypefun void add_history (char *string)
+@deftypefun void add_history (const char *string)
 Place @var{string} at the end of the history list.  The associated data
 field (if any) is set to @code{NULL}.
 @end deftypefun
 
 @deftypefun {HIST_ENTRY *} remove_history (int which)
 Remove history entry at offset @var{which} from the history.  The
 removed element is returned so you can free the line, data,
 and containing structure.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} replace_history_entry (int which, char *line, char *data)
+@deftypefun {HIST_ENTRY *} replace_history_entry (int which, const char *line, histdata_t data)
 Make the history entry at offset @var{which} have @var{line} and @var{data}.
 This returns the old entry so you can dispose of the data.  In the case
 of an invalid @var{which}, a @code{NULL} pointer is returned.
 @end deftypefun
 
-@deftypefun void clear_history ()
+@deftypefun void clear_history (void)
 Clear the history list by deleting all the entries.
 @end deftypefun
 
 @deftypefun void stifle_history (int max)
 Stifle the history list, remembering only the last @var{max} entries.
 @end deftypefun
 
-@deftypefun int unstifle_history ()
+@deftypefun int unstifle_history (void)
 Stop stifling the history.  This returns the previous amount the
 history was stifled.  The value is positive if the history was
 stifled, negative if it wasn't.
 @end deftypefun
 
-@deftypefun int history_is_stifled ()
+@deftypefun int history_is_stifled (void)
 Returns non-zero if the history is stifled, zero if it is not.
 @end deftypefun
 
 @node Information About the History List
 @subsection Information About the History List
 
 These functions return information about the entire history list or
 individual list entries.
 
-@deftypefun {HIST_ENTRY **} history_list ()
-Return a @code{NULL} terminated array of @code{HIST_ENTRY} which is the
+@deftypefun {HIST_ENTRY **} history_list (void)
+Return a @code{NULL} terminated array of @code{HIST_ENTRY *} which is the
 current input history.  Element 0 of this list is the beginning of time.
 If there is no history, return @code{NULL}.
 @end deftypefun
 
-@deftypefun int where_history ()
+@deftypefun int where_history (void)
 Returns the offset of the current history element.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} current_history ()
+@deftypefun {HIST_ENTRY *} current_history (void)
 Return the history entry at the current position, as determined by
-@code{where_history ()}.  If there is no entry there, return a @code{NULL}
+@code{where_history()}.  If there is no entry there, return a @code{NULL}
 pointer.
 @end deftypefun
 
 @deftypefun {HIST_ENTRY *} history_get (int offset)
 Return the history entry at position @var{offset}, starting from
-@code{history_base}.  If there is no entry there, or if @var{offset}
+@code{history_base} (@pxref{History Variables}).
+If there is no entry there, or if @var{offset}
 is greater than the history length, return a @code{NULL} pointer.
 @end deftypefun
 
-@deftypefun int history_total_bytes ()
+@deftypefun int history_total_bytes (void)
 Return the number of bytes that the primary history entries are using.
 This function returns the sum of the lengths of all the lines in the
 history.
 @end deftypefun
 
 @node Moving Around the History List
 @subsection Moving Around the History List
 
 These functions allow the current index into the history list to be
 set or changed.
 
 @deftypefun int history_set_pos (int pos)
-Set the position in the history list to @var{pos}, an absolute index
+Set the current history offset to @var{pos}, an absolute index
 into the list.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} previous_history ()
+@deftypefun {HIST_ENTRY *} previous_history (void)
 Back up the current history offset to the previous history entry, and
 return a pointer to that entry.  If there is no previous entry, return
 a @code{NULL} pointer.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} next_history ()
+@deftypefun {HIST_ENTRY *} next_history (void)
 Move the current history offset forward to the next history entry, and
 return the a pointer to that entry.  If there is no next entry, return
 a @code{NULL} pointer.
 @end deftypefun
 
 @node Searching the History List
 @subsection Searching the History List
 @cindex History Searching
 
 These functions allow searching of the history list for entries containing
 a specific string.  Searching may be performed both forward and backward
 from the current history position.  The search may be @dfn{anchored},
 meaning that the string must match at the beginning of the history entry.
 @cindex anchored search
 
-@deftypefun int history_search (char *string, int direction)
-Search the history for @var{string}, starting at the current history
-offset.  If @var{direction} < 0, then the search is through previous entries,
-else through subsequent.  If @var{string} is found, then
+@deftypefun int history_search (const char *string, int direction)
+Search the history for @var{string}, starting at the current history offset.
+If @var{direction} is less than 0, then the search is through
+previous entries, otherwise through subsequent entries.
+If @var{string} is found, then
 the current history index is set to that history entry, and the value
 returned is the offset in the line of the entry where
 @var{string} was found.  Otherwise, nothing is changed, and a -1 is
 returned.
 @end deftypefun
 
-@deftypefun int history_search_prefix (char *string, int direction)
+@deftypefun int history_search_prefix (const char *string, int direction)
 Search the history for @var{string}, starting at the current history
 offset.  The search is anchored: matching lines must begin with
-@var{string}.  If @var{direction} < 0, then the search is through previous
-entries, else through subsequent.  If @var{string} is found, then the
+@var{string}.  If @var{direction} is less than 0, then the search is
+through previous entries, otherwise through subsequent entries.
+If @var{string} is found, then the
 current history index is set to that entry, and the return value is 0. 
 Otherwise, nothing is changed, and a -1 is returned. 
 @end deftypefun
 
-@deftypefun int history_search_pos (char *string, int direction, int pos)
+@deftypefun int history_search_pos (const char *string, int direction, int pos)
 Search for @var{string} in the history list, starting at @var{pos}, an
 absolute index into the list.  If @var{direction} is negative, the search
 proceeds backward from @var{pos}, otherwise forward.  Returns the absolute
 index of the history element where @var{string} was found, or -1 otherwise.
 @end deftypefun
 
 @node Managing the History File
 @subsection Managing the History File
 
 The History library can read the history from and write it to a file.
 This section documents the functions for managing a history file.
 
-@deftypefun int read_history (char *filename)
-Add the contents of @var{filename} to the history list, a line at a
-time.  If @var{filename} is @code{NULL}, then read from
-@file{~/.history}.  Returns 0 if successful, or errno if not.
+@deftypefun int read_history (const char *filename)
+Add the contents of @var{filename} to the history list, a line at a time.
+If @var{filename} is @code{NULL}, then read from @file{~/.history}.
+Returns 0 if successful, or @code{errno} if not.
 @end deftypefun
 
-@deftypefun int read_history_range (char *filename, int from, int to)
+@deftypefun int read_history_range (const char *filename, int from, int to)
 Read a range of lines from @var{filename}, adding them to the history list.
-Start reading at line @var{from} and end at @var{to}.  If
-@var{from} is zero, start at the beginning.  If @var{to} is less than
+Start reading at line @var{from} and end at @var{to}.
+If @var{from} is zero, start at the beginning.  If @var{to} is less than
 @var{from}, then read until the end of the file.  If @var{filename} is
 @code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
 or @code{errno} if not.
 @end deftypefun
 
-@deftypefun int write_history (char *filename)
+@deftypefun int write_history (const char *filename)
 Write the current history to @var{filename}, overwriting @var{filename}
-if necessary.  If @var{filename} is
-@code{NULL}, then write the history list to @file{~/.history}.  Values
-returned are as in @code{read_history ()}.
+if necessary.
+If @var{filename} is @code{NULL}, then write the history list to @file{~/.history}.
+Values returned are as in @code{read_history()}.
 @end deftypefun
 
-@deftypefun int append_history (int nelements, char *filename)
+@deftypefun int append_history (int nelements, const char *filename)
 Append the last @var{nelements} of the history list to @var{filename}.
+If @var{filename} is @code{NULL}, then append to @file{~/.history}.
 @end deftypefun
 
-@deftypefun int history_truncate_file (char *filename, int nlines)
+@deftypefun int history_truncate_file (const char *filename, int nlines)
 Truncate the history file @var{filename}, leaving only the last
 @var{nlines} lines.
+If @var{filename} is @code{NULL}, then @file{~/.history} is truncated.
 @end deftypefun
 
 @node History Expansion
 @subsection History Expansion
 
 These functions implement @code{csh}-like history expansion.
 
 @deftypefun int history_expand (char *string, char **output)
 Expand @var{string}, placing the result into @var{output}, a pointer
 to a string (@pxref{History Interaction}).  Returns:
 @table @code
 @item 0
 If no expansions took place (or, if the only change in
-the text was the de-slashifying of the history expansion
+the text was the removal of escape characters preceding the history expansion
 character);
 @item 1
 if expansions did take place;
 @item -1
 if there was an error in expansion;
 @item 2
-if the returned line should only be displayed, but not executed,
+if the returned line should be displayed, but not executed,
 as with the @code{:p} modifier (@pxref{Modifiers}).
 @end table
 
 If an error ocurred in expansion, then @var{output} contains a descriptive
 error message.
 @end deftypefun
 
-@deftypefun {char *} history_arg_extract (int first, int last, char *string)
+@deftypefun {char *} history_arg_extract (int first, int last, const char *string)
 Extract a string segment consisting of the @var{first} through @var{last}
-arguments present in @var{string}.  Arguments are broken up as in Bash.
+arguments present in @var{string}.  Arguments are split as in Bash.
 @end deftypefun
 
-@deftypefun {char *} get_history_event (char *string, int *cindex, int qchar)
+@deftypefun {char *} get_history_event (const char *string, int *cindex, int qchar)
 Returns the text of the history event beginning at @var{string} +
 @var{*cindex}.  @var{*cindex} is modified to point to after the event
 specifier.  At function entry, @var{cindex} points to the index into
 @var{string} where the history event specification begins.  @var{qchar}
 is a character that is allowed to end the event specification in addition
 to the ``normal'' terminating characters.
 @end deftypefun
 
-@deftypefun {char **} history_tokenize (char *string)
+@deftypefun {char **} history_tokenize (const char *string)
 Return an array of tokens parsed out of @var{string}, much as the
-shell might.  The tokens are split on white space and on the
-characters @code{()<>;&|$}, and shell quoting conventions are
-obeyed.
+shell might.  The tokens are split on the characters @code{" \t\n()<>;&|$"},
+and shell quoting conventions are obeyed.
 @end deftypefun
 
 @node History Variables
 @section History Variables
 
-This section describes the externally visible variables exported by
+This section describes the externally-visible variables exported by
 the GNU History Library.
 
 @deftypevar int history_base
 The logical offset of the first entry in the history list.
 @end deftypevar
 
 @deftypevar int history_length
 The number of entries currently stored in the history list.
 @end deftypevar
 
 @deftypevar int max_input_history
 The maximum number of history entries.  This must be changed using
-@code{stifle_history ()}.
+@code{stifle_history()}.
 @end deftypevar
 
 @deftypevar char history_expansion_char
 The character that starts a history event.  The default is @samp{!}.
 @end deftypevar
 
 @deftypevar char history_subst_char
 The character that invokes word substitution if found at the start of
@@ -395,49 +408,55 @@ a line.  The default is @samp{^}.
 During tokenization, if this character is seen as the first character
 of a word, then it and all subsequent characters up to a newline are
 ignored, suppressing history expansion for the remainder of the line.
 This is disabled by default.
 @end deftypevar
 
 @deftypevar {char *} history_no_expand_chars
 The list of characters which inhibit history expansion if found immediately
-following @var{history_expansion_char}.  The default is whitespace and
+following @var{history_expansion_char}.  The default is space, TAB, and
 @samp{=}.
 @end deftypevar
 
 @deftypevar {char *} history_search_delimiter_chars
 The list of additional characters which can delimit a history search
-string, in addition to whitespace, @samp{:} and @samp{?} in the case of
+string, in addition to space, TAB, @samp{:} and @samp{?} in the case of
 a substring search.  The default is empty.
 @end deftypevar
 
 @deftypevar int history_quotes_inhibit_expansion
 If non-zero, single-quoted words are not scanned for the history expansion
 character.  The default value is 0.
 @end deftypevar
 
-@deftypevar {Function *} history_inhibit_expansion_function
+@deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function
 This should be set to the address of a function that takes two arguments:
-a @code{char *} (@var{string}) and an integer index into that string (@var{i}).
+a @code{char *} (@var{string})
+and an @code{int} index into that string (@var{i}).
 It should return a non-zero value if the history expansion starting at
 @var{string[i]} should not be performed; zero if the expansion should
 be done.
 It is intended for use by applications like Bash that use the history
 expansion character for additional purposes.
-By default, this variable is set to NULL.
+By default, this variable is set to @code{NULL}.
 @end deftypevar
 
 @node History Programming Example
 @section History Programming Example
 
 The following program demonstrates simple use of the GNU History Library.
 
 @smallexample
-main ()
+#include <stdio.h>
+#include <readline/history.h>
+
+main (argc, argv)
+     int argc;
+     char **argv;
 @{
   char line[1024], *t;
   int len, done = 0;
 
   line[0] = 0;
 
   using_history ();
   while (!done)
diff --git a/readline/doc/hsuser.texinfo b/readline/doc/hsuser.texinfo
--- a/readline/doc/hsuser.texinfo
+++ b/readline/doc/hsuser.texinfo
@@ -1,12 +1,12 @@
 @ignore
 This file documents the user interface to the GNU History library.
 
-Copyright (C) 1988, 1991, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-1999 Free Software Foundation, Inc.
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to make and distribute verbatim copies of this manual
 provided the copyright notice and this permission notice are preserved on
 all copies.
 
 Permission is granted to process this file through Tex and print the
 results, provided the printed document carries copying permission notice
@@ -21,119 +21,231 @@ permission notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions.
 @end ignore
 
 @node Using History Interactively
 @chapter Using History Interactively
 
+@ifclear BashFeatures
+@defcodeindex bt
+@end ifclear
+
 @ifset BashFeatures
-This chapter describes how to use the GNU History Library interactively,
-from a user's standpoint.  It should be considered a user's guide.  For
-information on using the GNU History Library in your own programs,
-see the GNU Readline Library Manual.
+This chapter describes how to use the @sc{gnu} History Library
+interactively, from a user's standpoint.
+It should be considered a user's guide.
+For information on using the @sc{gnu} History Library in other programs,
+see the @sc{gnu} Readline Library Manual.
 @end ifset
 @ifclear BashFeatures
-This chapter describes how to use the GNU History Library interactively,
+This chapter describes how to use the @sc{gnu} History Library interactively,
 from a user's standpoint.  It should be considered a user's guide.  For
-information on using the GNU History Library in your own programs,
+information on using the @sc{gnu} History Library in your own programs,
 @pxref{Programming with GNU History}.
 @end ifclear
 
 @ifset BashFeatures
 @menu
 * Bash History Facilities::	How Bash lets you manipulate your command
 				history.
+* Bash History Builtins::	The Bash builtin commands that manipulate
+				the command history.
 * History Interaction::		What it feels like using History as a user.
 @end menu
 @end ifset
 @ifclear BashFeatures
 @menu
 * History Interaction::		What it feels like using History as a user.
 @end menu
 @end ifclear
 
 @ifset BashFeatures
 @node Bash History Facilities
 @section Bash History Facilities
 @cindex command history
 @cindex history list
 
-When the @samp{-o history} option to the @code{set} builtin
+When the @option{-o history} option to the @code{set} builtin
 is enabled (@pxref{The Set Builtin}),
-the shell provides access to the @var{command history},
-the list of commands previously typed.  The text of the last
-@code{HISTSIZE}
-commands (default 500) is saved in a history list.  The shell
-stores each command in the history list prior to parameter and
-variable expansion
+the shell provides access to the @dfn{command history},
+the list of commands previously typed.
+The value of the @env{HISTSIZE} shell variable is used as the
+number of commands to save in a history list.
+The text of the last @env{$HISTSIZE}
+commands (default 500) is saved.
+The shell stores each command in the history list prior to
+parameter and variable expansion
 but after history expansion is performed, subject to the
 values of the shell variables
-@code{HISTIGNORE} and @code{HISTCONTROL}.
+@env{HISTIGNORE} and @env{HISTCONTROL}.
+
 When the shell starts up, the history is initialized from the
-file named by the @code{HISTFILE} variable (default @file{~/.bash_history}).
-@code{HISTFILE} is truncated, if necessary, to contain no more than
-the number of lines specified by the value of the @code{HISTFILESIZE}
-variable.  When an interactive shell exits, the last
-@code{HISTSIZE} lines are copied from the history list to @code{HISTFILE}.
+file named by the @env{HISTFILE} variable (default @file{~/.bash_history}).
+The file named by the value of @env{HISTFILE} is truncated, if
+necessary, to contain no more than the number of lines specified by
+the value of the @env{HISTFILESIZE} variable.
+When an interactive shell exits, the last
+@env{$HISTSIZE} lines are copied from the history list to the file
+named by @env{$HISTFILE}.
 If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
 the lines are appended to the history file,
 otherwise the history file is overwritten.
-If @code{HISTFILE}
+If @env{HISTFILE}
 is unset, or if the history file is unwritable, the history is
 not saved.  After saving the history, the history file is truncated
-to contain no more than @code{$HISTFILESIZE}
-lines.  If @code{HISTFILESIZE} is not set, no truncation is performed.
+to contain no more than @env{$HISTFILESIZE}
+lines.  If @env{HISTFILESIZE} is not set, no truncation is performed.
 
-The builtin command @code{fc} (@pxref{Korn Shell Builtins})
-may be used to list or edit and re-execute a portion of
-the history list.  The @code{history} builtin (@pxref{C Shell Builtins})
-can be used to display or modify the history list and
-manipulate the history file.
-When using the command-line editing, search commands
+The builtin command @code{fc} may be used to list or edit and re-execute
+a portion of the history list.
+The @code{history} builtin may be used to display or modify the history
+list and manipulate the history file.
+When using command-line editing, search commands
 are available in each editing mode that provide access to the
-history list.
+history list (@pxref{Commands For History}).
 
 The shell allows control over which commands are saved on the history
-list.  The @code{HISTCONTROL} and @code{HISTIGNORE}
+list.  The @env{HISTCONTROL} and @env{HISTIGNORE}
 variables may be set to cause the shell to save only a subset of the
 commands entered.
 The @code{cmdhist}
 shell option, if enabled, causes the shell to attempt to save each
 line of a multi-line command in the same history entry, adding
 semicolons where necessary to preserve syntactic correctness.
 The @code{lithist}
 shell option causes the shell to save the command with embedded newlines
 instead of semicolons.
-@xref{Bash Builtins} for a description of @code{shopt}.
+The @code{shopt} builtin is used to set these options.
+@xref{Bash Builtins}, for a description of @code{shopt}.
+
+@node Bash History Builtins
+@section Bash History Builtins
+@cindex history builtins
+
+Bash provides two builtin commands which manipulate the
+history list and history file.
+
+@table @code
+
+@item fc
+@btindex fc
+@example
+@code{fc [-e @var{ename}] [-nlr] [@var{first}] [@var{last}]}
+@code{fc -s [@var{pat}=@var{rep}] [@var{command}]}
+@end example
+
+Fix Command.  In the first form, a range of commands from @var{first} to
+@var{last} is selected from the history list.  Both @var{first} and
+@var{last} may be specified as a string (to locate the most recent
+command beginning with that string) or as a number (an index into the
+history list, where a negative number is used as an offset from the
+current command number).  If @var{last} is not specified it is set to
+@var{first}.  If @var{first} is not specified it is set to the previous
+command for editing and @minus{}16 for listing.  If the @option{-l} flag is
+given, the commands are listed on standard output.  The @option{-n} flag
+suppresses the command numbers when listing.  The @option{-r} flag
+reverses the order of the listing.  Otherwise, the editor given by
+@var{ename} is invoked on a file containing those commands.  If
+@var{ename} is not given, the value of the following variable expansion
+is used: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  This says to use the
+value of the @env{FCEDIT} variable if set, or the value of the
+@env{EDITOR} variable if that is set, or @code{vi} if neither is set.
+When editing is complete, the edited commands are echoed and executed.
+
+In the second form, @var{command} is re-executed after each instance
+of @var{pat} in the selected command is replaced by @var{rep}.
+
+A useful alias to use with the @code{fc} command is @code{r='fc -s'}, so
+that typing @samp{r cc} runs the last command beginning with @code{cc}
+and typing @samp{r} re-executes the last command (@pxref{Aliases}).
+
+@item history
+@btindex history
+@example
+history [@var{n}]
+history -c
+history -d @var{offset}
+history [-anrw] [@var{filename}]
+history -ps @var{arg}
+@end example
+
+With no options, display the history list with line numbers.
+Lines prefixed with a @samp{*} have been modified.
+An argument of @var{n} lists only the last @var{n} lines.
+Options, if supplied, have the following meanings:
+
+@table @code
+@item -c
+Clear the history list.  This may be combined
+with the other options to replace the history list completely.
+
+@item -d @var{offset}
+Delete the history entry at position @var{offset}.
+@var{offset} should be specified as it appears when the history is
+displayed.
+
+@item -a
+Append the new
+history lines (history lines entered since the beginning of the
+current Bash session) to the history file.
+
+@item -n
+Append the history lines not already read from the history file
+to the current history list.  These are lines appended to the history
+file since the beginning of the current Bash session.
+
+@item -r
+Read the current history file and append its contents to
+the history list.
+
+@item -w
+Write out the current history to the history file.
+
+@item -p
+Perform history substitution on the @var{arg}s and display the result
+on the standard output, without storing the results in the history list.
+
+@item -s
+The @var{arg}s are added to the end of
+the history list as a single entry.
+
+@end table
+
+When any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options is
+used, if @var{filename}
+is given, then it is used as the history file.  If not, then
+the value of the @env{HISTFILE} variable is used.
+
+@end table
 @end ifset
 
 @node History Interaction
-@section Interactive History Expansion
+@section History Expansion
 @cindex history expansion
 
 The History library provides a history expansion feature that is similar
 to the history expansion provided by @code{csh}.  This section
 describes the syntax used to manipulate the history information.
 
 History expansions introduce words from the history list into
 the input stream, making it easy to repeat commands, insert the
 arguments to a previous command into the current input line, or
 fix errors in previous commands quickly.
 
 History expansion takes place in two parts.  The first is to determine
-which line from the previous history should be used during substitution.
+which line from the history list should be used during substitution.
 The second is to select portions of that line for inclusion into the
-current one.  The line selected from the previous history is called the
+current one.  The line selected from the history is called the
 @dfn{event}, and the portions of that line that are acted upon are
 called @dfn{words}.  Various @dfn{modifiers} are available to manipulate
 the selected words.  The line is broken into words in the same fashion
-that Bash does, so that several English (or Unix) words
-surrounded by quotes are considered as one word.
+that Bash does, so that several words
+surrounded by quotes are considered one word.
 History expansions are introduced by the appearance of the
 history expansion character, which is @samp{!} by default.
 @ifset BashFeatures
 Only @samp{\} and @samp{'} may be used to escape the history expansion
 character.
 @end ifset
 
 @ifset BashFeatures
@@ -143,21 +255,22 @@ the behavior of history expansion.  If t
 @code{histverify} shell option is enabled, and Readline
 is being used, history substitutions are not immediately passed to
 the shell parser.
 Instead, the expanded line is reloaded into the Readline
 editing buffer for further modification.
 If Readline is being used, and the @code{histreedit}
 shell option is enabled, a failed history expansion will be
 reloaded into the Readline editing buffer for correction.
-The @samp{-p} option to the @code{history} builtin command
+The @option{-p} option to the @code{history} builtin command
 may be used to see what a history expansion will do before using it.
-The @samp{-s} option to the @code{history} builtin may be used to
+The @option{-s} option to the @code{history} builtin may be used to
 add commands to the end of the history list without actually executing
 them, so that they are available for subsequent recall.
+This is most useful in conjunction with Readline.
 
 The shell allows control of the various characters used by the
 history expansion mechanism with the @code{histchars} variable.
 @end ifset
 
 @menu
 * Event Designators::	How to specify which history line to use.
 * Word Designators::	Specifying which words are of interest.
@@ -171,17 +284,17 @@ history expansion mechanism with the @co
 An event designator is a reference to a command line entry in the
 history list.
 @cindex history events
 
 @table @asis
 
 @item @code{!}
 Start a history substitution, except when followed by a space, tab,
-the end of the line, @key{=} or @key{(}.
+the end of the line, @samp{=} or @samp{(}.
 
 @item @code{!@var{n}}
 Refer to command line @var{n}.
 
 @item @code{!-@var{n}}
 Refer to the command @var{n} lines back.
 
 @item @code{!!}
@@ -205,21 +318,41 @@ The entire command line typed so far.
 
 @end table
 
 @node Word Designators
 @subsection Word Designators
 
 Word designators are used to select desired words from the event.
 A @samp{:} separates the event specification from the word designator.  It
-can be omitted if the word designator begins with a @samp{^}, @samp{$},
+may be omitted if the word designator begins with a @samp{^}, @samp{$},
 @samp{*}, @samp{-}, or @samp{%}.  Words are numbered from the beginning
 of the line, with the first word being denoted by 0 (zero).  Words are
 inserted into the current line separated by single spaces.
 
+@need 0.75
+For example,
+
+@table @code
+@item !!
+designates the preceding command.  When you type this, the preceding
+command is repeated in toto.
+
+@item !!:$
+designates the last argument of the preceding command.  This may be
+shortened to @code{!$}.
+
+@item !fi:2
+designates the second argument of the most recent command starting with
+the letters @code{fi}.
+@end table
+
+@need 0.75
+Here are the word designators:
+ 
 @table @code
 
 @item 0 (zero)
 The @code{0}th word.  For many applications, this is the command word.
 
 @item @var{n}
 The @var{n}th word.
 
diff --git a/readline/doc/readline.3 b/readline/doc/readline.3
--- a/readline/doc/readline.3
+++ b/readline/doc/readline.3
@@ -1,66 +1,72 @@
 .\"
 .\" MAN PAGE COMMENTS to
 .\"
 .\"	Chet Ramey
 .\"	Information Network Services
 .\"	Case Western Reserve University
 .\"	chet@ins.CWRU.Edu
 .\"
-.\"	Last Change: Wed Feb  5 14:13:22 EST 1997
+.\"	Last Change: Mon Feb  5 08:51:52 EST 2001
 .\"
-.TH READLINE 3 "1997 Feb 5" GNU
+.TH READLINE 3 "2001 Feb 5" "GNU Readline 4.2"
 .\"
 .\" File Name macro.  This used to be `.PN', for Path Name,
 .\" but Sun doesn't seem to like that very much.
 .\"
 .de FN
 \fI\|\\$1\|\fP
 ..
 .SH NAME
 readline \- get a line from a user with editing
 .SH SYNOPSIS
 .LP
 .nf
 .ft B
-#include <readline.h>
-#include <history.h>
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
 .ft
 .fi
 .LP
 .nf
-.ft B
-char *readline (prompt)
-char *prompt;
-.ft
+\fIchar *\fP
+.br
+\fBreadline\fP (\fIconst char *prompt\fP);
 .fi
 .SH COPYRIGHT
-.if n Readline is Copyright (C) 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
-.if t Readline is Copyright \(co 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
+.if n Readline is Copyright (C) 1989\-2001 by the Free Software Foundation, Inc.
+.if t Readline is Copyright \(co 1989\-2001 by the Free Software Foundation, Inc.
 .SH DESCRIPTION
 .LP
 .B readline
 will read a line from the terminal
 and return it, using
 .B prompt
 as a prompt.  If 
 .B prompt
-is null, no prompt is issued.  The line returned is allocated with
-.IR malloc (3),
-so the caller must free it when finished.  The line returned
+is \fBNULL\fP or the empty string, no prompt is issued.
+The line returned is allocated with
+.IR malloc (3);
+the caller must free it when finished.  The line returned
 has the final newline removed, so only the text of the line
 remains.
 .LP
 .B readline
 offers editing capabilities while the user is entering the
 line.
 By default, the line editing commands
 are similar to those of emacs.
 A vi\-style line editing interface is also available.
+.LP
+This manual page describes only the most basic use of \fBreadline\fP.
+Much more functionality is available; see
+\fIThe GNU Readline Library\fP and \fIThe GNU History Library\fP
+for additional information.
 .SH RETURN VALUE
 .LP
 .B readline
 returns the text of the line read.  A blank line
 returns the empty string.  If
 .B EOF
 is encountered while reading a line, and the line is empty,
 .B NULL
@@ -124,73 +130,77 @@ For example, placing
 .RS
 .PP
 M\-Control\-u: universal\-argument
 .RE
 or
 .RS
 C\-Meta\-u: universal\-argument
 .RE
+.sp
 into the 
 .I inputrc
 would make M\-C\-u execute the readline command
 .IR universal\-argument .
 .PP
 The following symbolic character names are recognized while
 processing key bindings:
-.IR RUBOUT ,
 .IR DEL ,
 .IR ESC ,
+.IR ESCAPE ,
 .IR LFD ,
 .IR NEWLINE ,
 .IR RET ,
 .IR RETURN ,
+.IR RUBOUT ,
+.IR SPACE ,
 .IR SPC ,
-.IR SPACE ,
 and
 .IR TAB .
+.PP
 In addition to command names, readline allows keys to be bound
 to a string that is inserted when the key is pressed (a \fImacro\fP).
 .PP
 .SS Key Bindings
 .PP
 The syntax for controlling key bindings in the
 .I inputrc
 file is simple.  All that is required is the name of the
 command or the text of a macro and a key sequence to which
 it should be bound. The name may be specified in one of two ways:
 as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
 prefixes, or as a key sequence.
-When using the form \fBkeyname\fP:\fIfunction-name\fP or \fImacro\fP,
+When using the form \fBkeyname\fP:\^\fIfunction-name\fP or \fImacro\fP,
 .I keyname
 is the name of a key spelled out in English.  For example:
 .sp
 .RS
 Control\-u: universal\-argument
 .br
 Meta\-Rubout: backward\-kill\-word
 .br
-Control\-o: ">&output"
+Control\-o: "> output"
 .RE
 .LP
 In the above example,
 .I C\-u
 is bound to the function
 .BR universal\-argument ,
 .I M-DEL
 is bound to the function
 .BR backward\-kill\-word ,
 and
 .I C\-o
 is bound to run the macro
 expressed on the right hand side (that is, to insert the text
-.I >&output
+.if t \f(CW> output\fP
+.if n ``> output''
 into the line).
 .PP
-In the second form, \fB"keyseq"\fP:\fIfunction\-name\fP or \fImacro\fP,
+In the second form, \fB"keyseq"\fP:\^\fIfunction\-name\fP or \fImacro\fP,
 .B keyseq
 differs from
 .B keyname
 above in that strings denoting
 an entire key sequence may be specified by placing the sequence
 within double quotes.  Some GNU Emacs style key escapes can be
 used, as in the following example.
 .sp
@@ -207,43 +217,87 @@ In this example,
 is again bound to the function
 .BR universal\-argument .
 .I "C-x C-r"
 is bound to the function
 .BR re\-read\-init\-file ,
 and 
 .I "ESC [ 1 1 ~"
 is bound to insert the text
-.BR "Function Key 1" .
-The full set of escape sequences is
+.if t \f(CWFunction Key 1\fP.
+.if n ``Function Key 1''.
+The full set of GNU Emacs style escape sequences is
 .RS
+.PD 0
 .TP
 .B \eC\-
 control prefix
 .TP
 .B \eM\-
 meta prefix
 .TP
 .B \ee
 an escape character
 .TP
 .B \e\e
 backslash
 .TP
 .B \e"
-literal "
+literal ", a double quote
 .TP
 .B \e'
-literal '
+literal ', a single quote
 .RE
+.PD
+.PP
+In addition to the GNU Emacs style escape sequences, a second
+set of backslash escapes is available:
+.RS
+.PD 0
+.TP
+.B \ea
+alert (bell)
+.TP
+.B \eb
+backspace
+.TP
+.B \ed
+delete
+.TP
+.B \ef
+form feed
+.TP
+.B \en
+newline
+.TP
+.B \er
+carriage return
+.TP
+.B \et
+horizontal tab
+.TP
+.B \ev
+vertical tab
+.TP
+.B \e\fInnn\fP
+the character whose ASCII code is the octal value \fInnn\fP
+(one to three digits)
+.TP
+.B \ex\fInnn\fP
+the character whose ASCII code is the hexadecimal value \fInnn\fP
+(one to three digits)
+.RE
+.PD
 .PP
 When entering the text of a macro, single or double quotes should
 be used to indicate a macro definition.  Unquoted text
-is assumed to be a function name.  Backslash
-will quote any character in the macro text, including " and '.
+is assumed to be a function name.
+In the macro body, the backslash escapes described above are expanded.
+Backslash will quote any other character in the macro text,
+including " and '.
 .PP
 .B Bash
 allows the current readline key bindings to be displayed or modified
 with the
 .B bind
 builtin command.  The editing mode may be switched during interactive
 use by using the
 .B \-o
@@ -263,17 +317,18 @@ file with a statement of the form
 .RS
 .PP
 \fBset\fP \fIvariable\-name\fP \fIvalue\fP
 .RE
 .PP
 Except where noted, readline variables can take the values
 .B On
 or
-.BR Off .
+.B Off
+(without regard to case).
 The variables and their default values are:
 .PP
 .PD 0
 .TP
 .B bell\-style (audible)
 Controls what happens when readline wants to ring the terminal bell.
 If set to \fBnone\fP, readline never rings the bell.  If set to
 \fBvisible\fP, readline uses a visible bell if one is available.
@@ -283,41 +338,45 @@ If set to \fBaudible\fP, readline attemp
 The string that is inserted in \fBvi\fP mode when the
 .B insert\-comment
 command is executed.
 This command is bound to
 .B M\-#
 in emacs mode and to
 .B #
 in vi command mode.
+.TP 
+.B completion\-ignore\-case (Off)
+If set to \fBOn\fP, readline performs filename matching and completion
+in a case\-insensitive fashion.
 .TP
 .B completion\-query\-items (100)
 This determines when the user is queried about viewing
 the number of possible completions
 generated by the \fBpossible\-completions\fP command.
 It may be set to any integer value greater than or equal to
 zero.  If the number of possible completions is greater than
 or equal to the value of this variable, the user is asked whether
 or not he wishes to view them; otherwise they are simply listed
 on the terminal.
 .TP
 .B convert\-meta (On)
 If set to \fBOn\fP, readline will convert characters with the
 eighth bit set to an ASCII key sequence
-by stripping the eighth bit and prepending an
+by stripping the eighth bit and prefixing it with an
 escape character (in effect, using escape as the \fImeta prefix\fP).
 .TP
 .B disable\-completion (Off)
 If set to \fBOn\fP, readline will inhibit word completion.  Completion 
 characters will be inserted into the line as if they had been
 mapped to \fBself-insert\fP.
 .TP
 .B editing\-mode (emacs)
 Controls whether readline begins with a set of key bindings similar
-to \fIemacs\fP or \fIvi\fP.
+to emacs or vi.
 .B editing\-mode
 can be set to either
 .B emacs
 or
 .BR vi .
 .TP
 .B enable\-keypad (Off)
 When set to \fBOn\fP, readline will try to enable the application
@@ -328,64 +387,76 @@ arrow keys.
 If set to \fBon\fP, tilde expansion is performed when readline
 attempts word completion.
 .TP
 .B horizontal\-scroll\-mode (Off)
 When set to \fBOn\fP, makes readline use a single line for display,
 scrolling the input horizontally on a single screen line when it
 becomes longer than the screen width rather than wrapping to a new line.
 .TP
+.B input\-meta (Off)
+If set to \fBOn\fP, readline will enable eight-bit input (that is,
+it will not clear the eighth bit in the characters it reads),
+regardless of what the terminal claims it can support.  The name
+.B meta\-flag
+is a synonym for this variable.
+.TP
+.B isearch\-terminators (``C\-[ C\-J'')
+The string of characters that should terminate an incremental
+search without subsequently executing the character as a command.
+If this variable has not been given a value, the characters
+\fIESC\fP and \fIC\-J\fP will terminate an incremental search.
+.TP
 .B keymap (emacs)
 Set the current readline keymap.  The set of legal keymap names is
 \fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,
 vi-command\fP, and
 .IR vi-insert .
 \fIvi\fP is equivalent to \fIvi-command\fP; \fIemacs\fP is
 equivalent to \fIemacs-standard\fP.  The default value is
-.IR emacs ;
-the value of
+.IR emacs .
+The value of
 .B editing\-mode
 also affects the default keymap.
 .TP
 .B mark\-directories (On)
 If set to \fBOn\fP, completed directory names have a slash
 appended.
 .TP
 .B mark\-modified\-lines (Off)
 If set to \fBOn\fP, history lines that have been modified are displayed
 with a preceding asterisk (\fB*\fP).
 .TP
-.B meta\-flag (Off)
-If set to \fBOn\fP, readline will enable eight-bit input (that is,
-it will not strip the high bit from the characters it reads),
-regardless of what the terminal claims it can support.
-.TP
 .B output\-meta (Off)
 If set to \fBOn\fP, readline will display characters with the
 eighth bit set directly rather than as a meta-prefixed escape
 sequence.
 .TP
+.B print\-completions\-horizontally (Off)
+If set to \fBOn\fP, readline will display completions with matches
+sorted horizontally in alphabetical order, rather than down the screen.
+.TP
 .B show\-all\-if\-ambiguous (Off)
 This alters the default behavior of the completion functions.  If
 set to
 .BR on ,
 words which have more than one possible completion cause the
 matches to be listed immediately instead of ringing the bell.
 .TP
 .B visible\-stats (Off)
 If set to \fBOn\fP, a character denoting a file's type as reported  
-by \fBstat\fP(2) is appended to the filename when listing possible
+by \fIstat\fP(2) is appended to the filename when listing possible
 completions.
 .PD
 .SS Conditional Constructs
 .PP
 Readline implements a facility similar in spirit to the conditional
 compilation features of the C preprocessor which allows key
 bindings and variable settings to be performed as the result
-of tests.  There are three parser directives used.
+of tests.  There are four parser directives used.
 .IP \fB$if\fP
 The 
 .B $if
 construct allows bindings to be made based on the
 editing mode, the terminal being used, or the application using
 readline.  The text of the test extends to the end of the line;
 no characters are required to isolate it.
 .RS
@@ -412,69 +483,92 @@ for instance.
 .IP \fBapplication\fP
 The \fBapplication\fP construct is used to include
 application-specific settings.  Each program using the readline
 library sets the \fIapplication name\fP, and an initialization
 file can test for a particular value.
 This could be used to bind key sequences to functions useful for
 a specific program.  For instance, the following command adds a
 key sequence that quotes the current or previous word in Bash:
+.sp 1
 .RS
 .nf
-\fB$if\fP bash
+\fB$if\fP Bash
 # Quote the current or previous word
 "\eC-xq": "\eeb\e"\eef\e""
 \fB$endif\fP
 .fi
 .RE
 .RE
 .IP \fB$endif\fP
-This command, as you saw in the previous example, terminates an
+This command, as seen in the previous example, terminates an
 \fB$if\fP command.
 .IP \fB$else\fP
 Commands in this branch of the \fB$if\fP directive are executed if
 the test fails.
+.IP \fB$include\fP
+This directive takes a single filename as an argument and reads commands
+and bindings from that file.  For example, the following directive
+would read \fI/etc/inputrc\fP:
+.sp 1
+.RS
+.nf
+\fB$include\fP \^ \fI/etc/inputrc\fP
+.fi 
+.RE
 .SH SEARCHING
 .PP
 Readline provides commands for searching through the command history
 for lines containing a specified string.
 There are two search modes:
 .I incremental
 and
 .IR non-incremental .
 .PP
 Incremental searches begin before the user has finished typing the
 search string.
 As each character of the search string is typed, readline displays
 the next entry from the history matching the string typed so far.
 An incremental search requires only as many characters as needed to
 find the desired history entry.
-The Escape character is used to terminate an incremental search.
-Control-J will also terminate the search.
-Control-G will abort an incremental search and restore the original
+To search backward in the history for a particular string, type
+\fBC\-r\fP.  Typing \fBC\-s\fP searches forward through the history.
+The characters present in the value of the \fBisearch-terminators\fP
+variable are used to terminate an incremental search.
+If that variable has not been assigned a value the \fIEscape\fP and
+\fBC\-J\fP characters will terminate an incremental search.
+\fBC\-G\fP will abort an incremental search and restore the original
 line.
 When the search is terminated, the history entry containing the
 search string becomes the current line.
-To find other matching entries in the history list, type Control-S or
-Control-R as appropriate.
+.PP
+To find other matching entries in the history list, type \fBC\-s\fP or
+\fBC\-r\fP as appropriate.
 This will search backward or forward in the history for the next
 line matching the search string typed so far.
 Any other key sequence bound to a readline command will terminate
 the search and execute that command.
-For instance, a \fInewline\fP will terminate the search and accept
+For instance, a newline will terminate the search and accept
 the line, thereby executing the command from the history list.
+A movement command will terminate the search, make the last line found
+the current line, and begin editing.
 .PP
 Non-incremental searches read the entire search string before starting
 to search for matching history lines.  The search string may be
-typed by the user or part of the contents of the current line.
+typed by the user or be part of the contents of the current line.
 .SH EDITING COMMANDS
 .PP
 The following is a list of the names of the commands and the default
 key sequences to which they are bound.
 Command names without an accompanying key sequence are unbound by default.
+.PP
+In the following descriptions, \fIpoint\fP refers to the current cursor
+position, and \fImark\fP refers to a cursor position saved by the
+\fBset\-mark\fP command.
+The text between the point and mark is referred to as the \fIregion\fP.
 .SS Commands for Moving
 .PP
 .PD 0
 .TP
 .B beginning\-of\-line (C\-a)
 Move to the start of the current line.
 .TP
 .B end\-of\-line (C\-e)
@@ -486,35 +580,37 @@ Move forward a character.
 .B backward\-char (C\-b)
 Move back a character.
 .TP
 .B forward\-word (M\-f)
 Move forward to the end of the next word.  Words are composed of
 alphanumeric characters (letters and digits).
 .TP
 .B backward\-word (M\-b)
-Move back to the start of this, or the previous, word.  Words are
+Move back to the start of the current or previous word.  Words are
 composed of alphanumeric characters (letters and digits).
 .TP
 .B clear\-screen (C\-l)
 Clear the screen leaving the current line at the top of the screen.
 With an argument, refresh the current line without clearing the
 screen.
 .TP
 .B redraw\-current\-line
 Refresh the current line.
 .PD
 .SS Commands for Manipulating the History
 .PP
 .PD 0
 .TP
 .B accept\-line (Newline, Return)
-Accept the line regardless of where the cursor is.  If this line is
-non-empty, add it to the history list. If the line is a modified
-history line, then restore the history line to its original state.
+Accept the line regardless of where the cursor is.
+If this line is
+non-empty, it may be added to the history list for future recall with
+\fBadd_history()\fP.
+If the line is a modified history line, the history line is restored to its original state.
 .TP
 .B previous\-history (C\-p)
 Fetch the previous command from the history list, moving back in
 the list.
 .TP
 .B next\-history (C\-n)
 Fetch the next command from the history list, moving forward in the
 list.
@@ -562,77 +658,83 @@ insert the \fIn\fPth word from the previ
 in the previous command begin with word 0).  A negative argument
 inserts the \fIn\fPth word from the end of the previous command.
 .TP
 .B
 yank\-last\-arg (M\-.\^, M\-_\^)
 Insert the last argument to the previous command (the last word of
 the previous history entry).  With an argument,
 behave exactly like \fByank\-nth\-arg\fP.
+Successive calls to \fByank\-last\-arg\fP move back through the history
+list, inserting the last argument of each line in turn.
 .PD
 .SS Commands for Changing Text
 .PP
 .PD 0
 .TP
 .B delete\-char (C\-d)
 Delete the character under the cursor.  If point is at the
 beginning of the line, there are no characters in the line, and
-the last character typed was not
-.BR C\-d ,
-then return
+the last character typed was not bound to \fBdelete\-char\fP, then return
 .SM
 .BR EOF .
 .TP
 .B backward\-delete\-char (Rubout)
 Delete the character behind the cursor.  When given a numeric argument,
 save the deleted text on the kill ring.
 .TP
+.B forward\-backward\-delete\-char   
+Delete the character under the cursor, unless the cursor is at the
+end of the line, in which case the character behind the cursor is
+deleted.
+.TP
 .B quoted\-insert (C\-q, C\-v)
 Add the next character that you type to the line verbatim.  This is
 how to insert characters like \fBC\-q\fP, for example.
 .TP
 .B tab\-insert (M-TAB)
 Insert a tab character.
 .TP
 .B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
 Insert the character typed.
 .TP
 .B transpose\-chars (C\-t)
-Drag the character before point forward over the character at point.
-Point moves forward as well.  If point is at the end of the line, then
+Drag the character before point forward over the character at point,
+moving point forward as well.  If point is at the end of the line, then
 transpose the two characters before point.  Negative arguments don't work.
 .TP
 .B transpose\-words (M\-t)
-Drag the word behind the cursor past the word in front of the cursor
+Drag the word behind the cursor past the word in front of the cursor,
 moving the cursor over that word as well.
 .TP
 .B upcase\-word (M\-u)
 Uppercase the current (or following) word.  With a negative argument,
-do the previous word, but do not move point.
+uppercase the previous word, but do not move point.
 .TP
 .B downcase\-word (M\-l)
 Lowercase the current (or following) word.  With a negative argument,
-do the previous word, but do not move point.
+lowercase the previous word, but do not move point.
 .TP
 .B capitalize\-word (M\-c)
 Capitalize the current (or following) word.  With a negative argument,
-do the previous word, but do not move point.
+capitalize the previous word, but do not move point.
 .PD
 .SS Killing and Yanking
 .PP
 .PD 0
 .TP
 .B kill\-line (C\-k)
 Kill the text from the current cursor position to the end of the line.
 .TP
 .B backward\-kill\-line (C\-x Rubout)
 Kill backward to the beginning of the line.
 .TP
 .B unix\-line\-discard (C\-u)
 Kill backward from point to the beginning of the line.
+The killed text is saved on the kill-ring.
 .\" There is no real difference between this and backward-kill-line
 .TP
 .B kill\-whole\-line
 Kill all characters on the current line, no matter where the
 cursor is.
 .TP
 .B kill\-word  (M\-d)
 Kill from the cursor to the end of the current word, or if between
@@ -655,19 +757,21 @@ Delete all spaces and tabs around point.
 Kill the text between the point and \fImark\fP (saved cursor position).
 This text is referred to as the \fIregion\fP.
 .TP
 .B copy\-region\-as\-kill
 Copy the text in the region to the kill buffer.
 .TP
 .B copy\-backward\-word
 Copy the word before point to the kill buffer.
+The word boundaries are the same as \fBbackward\-word\fP.
 .TP
 .B copy\-forward\-word
 Copy the word following point to the kill buffer.
+The word boundaries are the same as \fBforward\-word\fP.
 .TP
 .B yank (C\-y)
 Yank the top of the kill ring into the buffer at the cursor.
 .TP
 .B yank\-pop (M\-y)
 Rotate the kill ring, and yank the new top.  Only works following
 .B yank
 or
@@ -715,16 +819,35 @@ only attempts filename completion under 
 .TP
 .B possible\-completions (M\-?)
 List the possible completions of the text before point.
 .TP
 .B insert\-completions (M\-*)
 Insert all completions of the text before point
 that would have been generated by
 \fBpossible\-completions\fP.
+.TP
+.B menu\-complete
+Similar to \fBcomplete\fP, but replaces the word to be completed
+with a single match from the list of possible completions.
+Repeated execution of \fBmenu\-complete\fP steps through the list
+of possible completions, inserting each match in turn.
+At the end of the list of completions, the bell is rung and the
+original text is restored.
+An argument of \fIn\fP moves \fIn\fP positions forward in the list
+of matches; a negative argument may be used to move backward 
+through the list.
+This command is intended to be bound to \fBTAB\fP, but is unbound
+by default.
+.TP
+.B delete\-char\-or\-list
+Deletes the character under the cursor if not at the beginning or
+end of the line (like \fBdelete-char\fP).
+If at the end of the line, behaves identically to
+\fBpossible-completions\fP.
 .PD
 .SS Keyboard Macros
 .PP
 .PD 0
 .TP
 .B start\-kbd\-macro (C\-x (\^)
 Begin saving the characters typed into the current keyboard macro.
 .TP
@@ -760,24 +883,24 @@ Metafy the next character typed.
 .B f
 is equivalent to
 .BR Meta\-f .
 .TP
 .B undo (C\-_, C\-x C\-u)
 Incremental undo, separately remembered for each line.
 .TP
 .B revert\-line (M\-r)
-Undo all changes made to this line.  This is like typing the
+Undo all changes made to this line.  This is like executing the
 .B undo
 command enough times to return the line to its initial state.
 .TP
-.B tilde\-expand (M\-~)
+.B tilde\-expand (M\-&)
 Perform tilde expansion on the current word.
 .TP
-.B set\-mark (C\-@, M-<space>)
+.B set\-mark (C\-@, M\-<space>)
 Set the mark to the current point.  If a
 numeric argument is supplied, the mark is set to that position.
 .TP
 .B exchange\-point\-and\-mark (C\-x C\-x)
 Swap the point with the mark.  The current cursor position is set to
 the saved position, and the old cursor position is saved as the mark.
 .TP
 .B character\-search (C\-])
@@ -787,27 +910,19 @@ character.  A negative count searches fo
 .B character\-search\-backward (M\-C\-])
 A character is read and point is moved to the previous occurrence of that
 character.  A negative count searches for subsequent occurrences.
 .TP
 .B insert\-comment (M\-#)
 The value of the readline
 .B comment\-begin
 variable is inserted at the beginning of the current line, and the line
-is accepted as if a newline had been typed.  This makes the current line
-a shell comment.
-.TP
-.B glob\-expand\-word (C\-x *)
-The word before point is treated as a pattern for pathname expansion,
-and the list of matching file names is inserted, replacing the word.
-.TP
-.B glob\-list\-expansions (C\-x g)
-The list of expansions that would have been generated by
-.B glob\-expand\-word
-is inserted into the line, replacing the word before point.
+is accepted as if a newline had been typed.  The default value of
+.B comment\-begin
+makes the current line a shell comment.
 .TP
 .B dump\-functions
 Print all of the functions and their key bindings to the
 readline output stream.  If a numeric argument is supplied,
 the output is formatted in such a way that it can be made part
 of an \fIinputrc\fP file.
 .TP
 .B dump\-variables
@@ -834,35 +949,33 @@ When in
 .B emacs
 editing mode, this causes a switch to
 .B vi
 editing mode.
 .PD
 .SH DEFAULT KEY BINDINGS
 .LP
 The following is a list of the default emacs and vi bindings.
-Characters with the 8th bit set are written as M\-<character>, and
+Characters with the eighth bit set are written as M\-<character>, and
 are referred to as
 .I metafied
 characters.
 The printable ASCII characters not mentioned in the list of emacs
 standard bindings are bound to the
-.I self\-insert
+.B self\-insert
 function, which just inserts the given character into the input line.
 In vi insertion mode, all characters not specifically mentioned are
 bound to
-.IR self\-insert .
+.BR self\-insert .
 Characters assigned to signal generation by
 .IR stty (1)
 or the terminal driver, such as C-Z or C-C,
 retain that function.
-Upper and lower case
-.I metafied
-characters are bound to the same function in the emacs mode
-meta keymap.
+Upper and lower case metafied characters are bound to the same function in
+the emacs mode meta keymap.
 The remaining characters are unbound, which causes readline
 to ring the bell (subject to the setting of the
 .B bell\-style
 variable).
 .SS Emacs Mode
 .RS +.6i
 .nf
 .ta 2.5i
@@ -1075,37 +1188,37 @@ VI Command Mode functions
 .PD
 .SH FILES
 .PD 0
 .TP
 .FN ~/.inputrc
 Individual \fBreadline\fP initialization file
 .PD
 .SH AUTHORS
-Brian Fox, Free Software Foundation (primary author)
+Brian Fox, Free Software Foundation
 .br
-bfox@ai.MIT.Edu
+bfox@gnu.org
 .PP
 Chet Ramey, Case Western Reserve University
 .br
 chet@ins.CWRU.Edu
 .SH BUG REPORTS
 If you find a bug in
 .B readline,
 you should report it.  But first, you should
 make sure that it really is a bug, and that it appears in the latest
 version of the
 .B readline
 library that you have.
 .PP
 Once you have determined that a bug actually exists, mail a
-bug report to \fIbug\-readline\fP@\fIprep.ai.MIT.Edu\fP.
+bug report to \fIbug\-readline\fP@\fIgnu.org\fP.
 If you have a fix, you are welcome to mail that
 as well!  Suggestions and `philosophical' bug reports may be mailed
-to \fPbug-readline\fP@\fIprep.ai.MIT.Edu\fP or posted to the Usenet
+to \fPbug-readline\fP@\fIgnu.org\fP or posted to the Usenet
 newsgroup
 .BR gnu.bash.bug .
 .PP
 Comments and bug reports concerning
 this manual page should be directed to
 .IR chet@ins.CWRU.Edu .
 .SH BUGS
 .PP
diff --git a/readline/doc/rlman.texinfo b/readline/doc/rlman.texinfo
--- a/readline/doc/rlman.texinfo
+++ b/readline/doc/rlman.texinfo
@@ -1,31 +1,29 @@
 \input texinfo    @c -*-texinfo-*-
 @comment %**start of header (This is for running Texinfo on a region.)
 @setfilename readline.info
 @settitle GNU Readline Library
 @comment %**end of header (This is for running Texinfo on a region.)
 @synindex vr fn
 @setchapternewpage odd
 
-@ignore
-last change: Thu Mar 21 16:06:39 EST 1996
-@end ignore
-
-@set EDITION 2.1
-@set VERSION 2.1
-@set UPDATED 21 March 1996
-@set UPDATE-MONTH March 1996
+@include manvers.texinfo
 
 @ifinfo
+@dircategory Libraries
+@direntry
+* Readline: (readline).       The GNU readline library API
+@end direntry
+
 This document describes the GNU Readline Library, a utility which aids
 in the consistency of user interface across discrete programs that need
 to provide a command line interface.
 
-Copyright (C) 1988, 1991 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
 pare preserved on all copies.
 
 @ignore
 Permission is granted to process this file through TeX and print the
 results, provided the printed document carries copying permission
@@ -36,17 +34,17 @@ notice identical to this one except for 
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided that the entire
 resulting derived work is distributed under the terms of a permission
 notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
-by the Foundation.
+by the Free Software Foundation.
 @end ifinfo
 
 @titlepage  
 @title GNU Readline Library
 @subtitle Edition @value{EDITION}, for @code{Readline Library} Version @value{VERSION}.
 @subtitle @value{UPDATE-MONTH}
 @author Brian Fox, Free Software Foundation
 @author Chet Ramey, Case Western Reserve University
@@ -67,20 +65,20 @@ are preserved on all copies.
 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided that the entire
 resulting derived work is distributed under the terms of a permission
 notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions,
 except that this permission notice may be stated in a translation approved
-by the Foundation.
+by the Free Software Foundation.
 
 @vskip 0pt plus 1filll
-Copyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
+Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
 @end titlepage
 
 @ifinfo
 @node Top
 @top GNU Readline Library
 
 This document describes the GNU Readline Library, a utility which aids
 in the consistency of user interface across discrete programs that need
diff --git a/readline/doc/rltech.texinfo b/readline/doc/rltech.texinfo
--- a/readline/doc/rltech.texinfo
+++ b/readline/doc/rltech.texinfo
@@ -3,17 +3,17 @@
 @comment %**end of header (This is for running Texinfo on a region.)
 @setchapternewpage odd
 
 @ifinfo
 This document describes the GNU Readline Library, a utility for aiding
 in the consitency of user interface across discrete programs that need
 to provide a command line interface.
 
-Copyright (C) 1988, 1994, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
 pare preserved on all copies.
 
 @ignore
 Permission is granted to process this file through TeX and print the
 results, provided the printed document carries copying permission
@@ -42,70 +42,74 @@ such as completion, line editing, and in
 in your own programs, this section is for you.
 
 @menu
 * Basic Behavior::	Using the default behavior of Readline.
 * Custom Functions::	Adding your own functions to Readline.
 * Readline Variables::			Variables accessible to custom
 					functions.
 * Readline Convenience Functions::	Functions which Readline supplies to
-					aid in writing your own
+					aid in writing your own custom
+					functions.
+* Readline Signal Handling::	How Readline behaves when it receives signals.
 * Custom Completers::	Supplanting or supplementing Readline's
 			completion functions.
 @end menu
 
 @node Basic Behavior
 @section Basic Behavior
 
 Many programs provide a command line interface, such as @code{mail},
 @code{ftp}, and @code{sh}.  For such programs, the default behaviour of
 Readline is sufficient.  This section describes how to use Readline in
 the simplest way possible, perhaps to replace calls in your code to
-@code{gets()} or @code{fgets ()}.
+@code{gets()} or @code{fgets()}.
 
 @findex readline
 @cindex readline, function
-The function @code{readline ()} prints a prompt and then reads and returns
-a single line of text from the user.  The line @code{readline}
-returns is allocated with @code{malloc ()}; you should @code{free ()}
-the line when you are done with it.  The declaration for @code{readline}
-in ANSI C is
 
 @example
-@code{char *readline (char *@var{prompt});}
+@code{char *readline (const char *@var{prompt});}
 @end example
 
+The function @code{readline()} prints a prompt @var{prompt}
+and then reads and returns a single line of text from the user.
+If @var{prompt} is @code{NULL} or the empty string, no prompt is displayed.
+The line @code{readline} returns is allocated with @code{malloc()};
+the caller should @code{free()} the line when it has finished with it.
+The declaration for @code{readline} in ANSI C is
+
 @noindent
 So, one might say
 @example
 @code{char *line = readline ("Enter a line: ");}
 @end example
 @noindent
 in order to read a line of text from the user.
 The line returned has the final newline removed, so only the
 text remains.
 
 If @code{readline} encounters an @code{EOF} while reading the line, and the
 line is empty at that point, then @code{(char *)NULL} is returned.
 Otherwise, the line is ended just as if a newline had been typed.
 
 If you want the user to be able to get at the line later, (with
-@key{C-p} for example), you must call @code{add_history ()} to save the
+@key{C-p} for example), you must call @code{add_history()} to save the
 line away in a @dfn{history} list of such lines.
 
 @example
 @code{add_history (line)};
 @end example
 
 @noindent
 For full details on the GNU History Library, see the associated manual.
 
 It is preferable to avoid saving empty lines on the history list, since
 users rarely have a burning need to reuse a blank line.  Here is
-a function which usefully replaces the standard @code{gets ()} library
+a function which usefully replaces the standard @code{gets()} library
 function, and has the advantage of no static buffer to overflow:
 
 @example
 /* A static variable for holding the line. */
 static char *line_read = (char *)NULL;
 
 /* Read a string, and return a pointer to it.  Returns NULL on EOF. */
 char *
@@ -128,87 +132,121 @@ rl_gets ()
 
   return (line_read);
 @}
 @end example
 
 This function gives the user the default behaviour of @key{TAB}
 completion: completion on file names.  If you do not want Readline to
 complete on filenames, you can change the binding of the @key{TAB} key
-with @code{rl_bind_key ()}.
+with @code{rl_bind_key()}.
 
 @example
-@code{int rl_bind_key (int @var{key}, int (*@var{function})());}
+@code{int rl_bind_key (int @var{key}, rl_command_func_t *@var{function});}
 @end example
 
-@code{rl_bind_key ()} takes two arguments: @var{key} is the character that
+@code{rl_bind_key()} takes two arguments: @var{key} is the character that
 you want to bind, and @var{function} is the address of the function to
-call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert ()}
+call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert()}
 makes @key{TAB} insert itself.
-@code{rl_bind_key ()} returns non-zero if @var{key} is not a valid
+@code{rl_bind_key()} returns non-zero if @var{key} is not a valid
 ASCII character code (between 0 and 255).
 
 Thus, to disable the default @key{TAB} behavior, the following suffices:
 @example
 @code{rl_bind_key ('\t', rl_insert);}
 @end example
 
 This code should be executed once at the start of your program; you
-might write a function called @code{initialize_readline ()} which
+might write a function called @code{initialize_readline()} which
 performs this and other desired initializations, such as installing
 custom completers (@pxref{Custom Completers}).
 
 @node Custom Functions
 @section Custom Functions
 
 Readline provides many functions for manipulating the text of
 the line, but it isn't possible to anticipate the needs of all
 programs.  This section describes the various functions and variables
 defined within the Readline library which allow a user program to add
 customized functionality to Readline.
 
+Before declaring any functions that customize Readline's behavior, or
+using any functionality Readline provides in other code, an
+application writer should include the file @code{<readline/readline.h>}
+in any file that uses Readline's features.  Since some of the definitions
+in @code{readline.h} use the @code{stdio} library, the file
+@code{<stdio.h>} should be included before @code{readline.h}.
+
 @menu
-* The Function Type::	C declarations to make code readable.
+* Readline Typedefs::	C declarations to make code readable.
 * Function Writing::	Variables and calling conventions.
 @end menu
 
-@node The Function Type
-@subsection The Function Type
+@node Readline Typedefs
+@subsection Readline Typedefs
+
+For readabilty, we declare a number of new object types, all pointers
+to functions.
 
-For readabilty, we declare a new type of object, called
-@dfn{Function}.  A @code{Function} is a C function which
-returns an @code{int}.  The type declaration for @code{Function} is:
+The reason for declaring these new types is to make it easier to write
+code describing pointers to C functions with appropriately prototyped
+arguments and return values.
+
+For instance, say we want to declare a variable @var{func} as a pointer
+to a function which takes two @code{int} arguments and returns an
+@code{int} (this is the type of all of the Readline bindable functions).
+Instead of the classic C declaration
+
+@code{int (*func)();}
 
 @noindent
-@code{typedef int Function ();}
+or the ANSI-C style declaration
 
-The reason for declaring this new type is to make it easier to write
-code describing pointers to C functions.  Let us say we had a variable
-called @var{func} which was a pointer to a function.  Instead of the
-classic C declaration
-
-@code{int (*)()func;}
+@code{int (*func)(int, int);}
 
 @noindent
 we may write
 
-@code{Function *func;}
+@code{rl_command_func_t *func;}
+
+The full list of function pointer types available is
+
+@table @code
+@item typedef int rl_command_func_t (int, int);
 
-@noindent
-Similarly, there are
+@item typedef char *rl_compentry_func_t (const char *, int);
+
+@item typedef char **rl_completion_func_t (const char *, int, int);
+
+@item typedef char *rl_quote_func_t (char *, int, char *);
+
+@item typedef char *rl_dequote_func_t (char *, int);
+
+@item typedef int rl_compignore_func_t (char **);
 
-@example
-typedef void VFunction ();
-typedef char *CPFunction (); @r{and}
-typedef char **CPPFunction ();
-@end example
+@item typedef void rl_compdisp_func_t (char **, int, int);
+
+@item typedef int rl_hook_func_t (void);
+
+@item typedef int rl_getc_func_t (FILE *);
+
+@item typedef int rl_linebuf_func_t (char *, int);
 
-@noindent
-for functions returning no value, @code{pointer to char}, and
-@code{pointer to pointer to char}, respectively.
+@item typedef int rl_intfunc_t (int);
+@item #define rl_ivoidfunc_t rl_hook_func_t
+@item typedef int rl_icpfunc_t (char *);
+@item typedef int rl_icppfunc_t (char **);
+
+@item typedef void rl_voidfunc_t (void);
+@item typedef void rl_vintfunc_t (int);
+@item typedef void rl_vcpfunc_t (char *);
+@item typedef void rl_vcppfunc_t (char **);
+
+@end table
 
 @node Function Writing
 @subsection Writing a New Function
 
 In order to write new functions for Readline, you need to know the
 calling conventions for keyboard-invoked functions, and the names of the
 variables that describe the current state of the line read so far.
 
@@ -234,118 +272,259 @@ negative argument.
 
 @node Readline Variables
 @section Readline Variables
 
 These variables are available to function writers.
 
 @deftypevar {char *} rl_line_buffer
 This is the line gathered so far.  You are welcome to modify the
-contents of the line, but see @ref{Allowing Undoing}.
+contents of the line, but see @ref{Allowing Undoing}.  The
+function @code{rl_extend_line_buffer} is available to increase
+the memory allocated to @code{rl_line_buffer}.
 @end deftypevar
 
 @deftypevar int rl_point
 The offset of the current cursor position in @code{rl_line_buffer}
 (the @emph{point}).
 @end deftypevar
 
 @deftypevar int rl_end
 The number of characters present in @code{rl_line_buffer}.  When
 @code{rl_point} is at the end of the line, @code{rl_point} and
 @code{rl_end} are equal.
 @end deftypevar
 
 @deftypevar int rl_mark
-The mark (saved position) in the current line.  If set, the mark
+The @var{mark} (saved position) in the current line.  If set, the mark
 and point define a @emph{region}.
 @end deftypevar
 
 @deftypevar int rl_done
 Setting this to a non-zero value causes Readline to return the current
 line immediately.
 @end deftypevar
 
+@deftypevar int rl_num_chars_to_read
+Setting this to a positive value before calling @code{readline()} causes
+Readline to return after accepting that many characters, rather
+than reading up to a character bound to @code{accept-line}.
+@end deftypevar
+
 @deftypevar int rl_pending_input
 Setting this to a value makes it the next keystroke read.  This is a
 way to stuff a single character into the input stream.
 @end deftypevar
 
+@deftypevar int rl_dispatching
+Set to a non-zero value if a function is being called from a key binding;
+zero otherwise.  Application functions can test this to discover whether
+they were called directly or by Readline's dispatching mechanism.
+@end deftypevar
+
+@deftypevar int rl_erase_empty_line
+Setting this to a non-zero value causes Readline to completely erase
+the current line, including any prompt, any time a newline is typed as
+the only character on an otherwise-empty line.  The cursor is moved to
+the beginning of the newly-blank line.
+@end deftypevar
+
 @deftypevar {char *} rl_prompt
 The prompt Readline uses.  This is set from the argument to
-@code{readline ()}, and should not be assigned to directly.
+@code{readline()}, and should not be assigned to directly.
 @end deftypevar
 
-@deftypevar {char *} rl_library_version
+@deftypevar int rl_already_prompted
+If an application wishes to display the prompt itself, rather than have
+Readline do it the first time @code{readline()} is called, it should set
+this variable to a non-zero value after displaying the prompt.
+The prompt must also be passed as the argument to @code{readline()} so
+the redisplay functions can update the display properly.
+The calling application is responsible for managing the value; Readline
+never sets it.
+@end deftypevar
+
+@deftypevar {const char *} rl_library_version
 The version number of this revision of the library.
 @end deftypevar
 
-@deftypevar {char *} rl_terminal_name
-The terminal type, used for initialization.
+@deftypevar {int} rl_gnu_readline_p
+Always set to 1, denoting that this is @sc{gnu} readline rather than some
+emulation.
 @end deftypevar
 
-@deftypevar {char *} rl_readline_name
+@deftypevar {const char *} rl_terminal_name
+The terminal type, used for initialization.  If not set by the application,
+Readline sets this to the value of the @env{TERM} environment variable
+the first time it is called.
+@end deftypevar
+
+@deftypevar {const char *} rl_readline_name
 This variable is set to a unique name by each application using Readline.
 The value allows conditional parsing of the inputrc file
 (@pxref{Conditional Init Constructs}).
 @end deftypevar
 
 @deftypevar {FILE *} rl_instream
 The stdio stream from which Readline reads input.
 @end deftypevar
 
 @deftypevar {FILE *} rl_outstream
 The stdio stream to which Readline performs output.
 @end deftypevar
 
-@deftypevar {Function *} rl_startup_hook
+@deftypevar {rl_command_func_t *} rl_last_func
+The address of the last command function Readline executed.  May be used to
+test whether or not a function is being executed twice in succession, for
+example.
+@end deftypevar
+
+@deftypevar {rl_hook_func_t *} rl_startup_hook
 If non-zero, this is the address of a function to call just
 before @code{readline} prints the first prompt.
 @end deftypevar
 
-@deftypevar {Function *} rl_event_hook
+@deftypevar {rl_hook_func_t *} rl_pre_input_hook
+If non-zero, this is the address of a function to call after
+the first prompt has been printed and just before @code{readline}
+starts reading input characters.
+@end deftypevar
+
+@deftypevar {rl_hook_func_t *} rl_event_hook
 If non-zero, this is the address of a function to call periodically
 when readline is waiting for terminal input.
 @end deftypevar
 
-@deftypevar {Function *} rl_getc_function
+@deftypevar {rl_getc_func_t *} rl_getc_function
 If non-zero, @code{readline} will call indirectly through this pointer
 to get a character from the input stream.  By default, it is set to
 @code{rl_getc}, the default @code{readline} character input function
-(@pxref{Utility Functions}).
+(@pxref{Character Input}).
 @end deftypevar
 
-@deftypevar {VFunction *} rl_redisplay_function
+@deftypevar {rl_voidfunc_t *} rl_redisplay_function
 If non-zero, @code{readline} will call indirectly through this pointer
 to update the display with the current contents of the editing buffer.
 By default, it is set to @code{rl_redisplay}, the default @code{readline}
 redisplay function (@pxref{Redisplay}).
 @end deftypevar
 
+@deftypevar {rl_vintfunc_t *} rl_prep_term_function
+If non-zero, @code{readline} will call indirectly through this pointer
+to initialize the terminal.  The function takes a single argument, an
+@code{int} flag that says whether or not to use eight-bit characters.
+By default, this is set to @code{rl_prep_terminal}
+(@pxref{Terminal Management}).
+@end deftypevar
+
+@deftypevar {rl_voidfunc_t *} rl_deprep_term_function
+If non-zero, @code{readline} will call indirectly through this pointer
+to reset the terminal.  This function should undo the effects of
+@code{rl_prep_term_function}.
+By default, this is set to @code{rl_deprep_terminal}
+(@pxref{Terminal Management}).
+@end deftypevar
+
 @deftypevar {Keymap} rl_executing_keymap
 This variable is set to the keymap (@pxref{Keymaps}) in which the
 currently executing readline function was found.
 @end deftypevar 
 
 @deftypevar {Keymap} rl_binding_keymap
 This variable is set to the keymap (@pxref{Keymaps}) in which the
 last key binding occurred.
 @end deftypevar 
 
+@deftypevar {char *} rl_executing_macro
+This variable is set to the text of any currently-executing macro.
+@end deftypevar
+
+@deftypevar {int} rl_readline_state
+A variable with bit values that encapsulate the current Readline state.
+A bit is set with the @code{RL_SETSTATE} macro, and unset with the
+@code{RL_UNSETSTATE} macro.  Use the @code{RL_ISSTATE} macro to test
+whether a particular state bit is set.  Current state bits include:
+
+@table @code
+@item RL_STATE_NONE
+Readline has not yet been called, nor has it begun to intialize.
+@item RL_STATE_INITIALIZING
+Readline is initializing its internal data structures.
+@item RL_STATE_INITIALIZED
+Readline has completed its initialization.
+@item RL_STATE_TERMPREPPED
+Readline has modified the terminal modes to do its own input and redisplay.
+@item RL_STATE_READCMD
+Readline is reading a command from the keyboard.
+@item RL_STATE_METANEXT
+Readline is reading more input after reading the meta-prefix character.
+@item RL_STATE_DISPATCHING
+Readline is dispatching to a command.
+@item RL_STATE_MOREINPUT
+Readline is reading more input while executing an editing command.
+@item RL_STATE_ISEARCH
+Readline is performing an incremental history search.
+@item RL_STATE_NSEARCH
+Readline is performing a non-incremental history search.
+@item RL_STATE_SEARCH
+Readline is searching backward or forward through the history for a string.
+@item RL_STATE_NUMERICARG
+Readline is reading a numeric argument.
+@item RL_STATE_MACROINPUT
+Readline is currently getting its input from a previously-defined keyboard
+macro.
+@item RL_STATE_MACRODEF
+Readline is currently reading characters defining a keyboard macro.
+@item RL_STATE_OVERWRITE
+Readline is in overwrite mode.
+@item RL_STATE_COMPLETING
+Readline is performing word completion.
+@item RL_STATE_SIGHANDLER
+Readline is currently executing the readline signal handler.
+@item RL_STATE_UNDOING
+Readline is performing an undo.
+@item RL_STATE_DONE
+Readline has read a key sequence bound to @code{accept-line}
+and is about to return the line to the caller.
+@end table
+
+@end deftypevar
+
+@deftypevar {int} rl_explicit_arg
+Set to a non-zero value if an explicit numeric argument was specified by
+the user.  Only valid in a bindable command function.
+@end deftypevar
+
+@deftypevar {int} rl_numeric_arg
+Set to the value of any numeric argument explicitly specified by the user
+before executing the current Readline function.  Only valid in a bindable
+command function.
+@end deftypevar
+
+@deftypevar {int} rl_editing_mode
+Set to a value denoting Readline's current editing mode.  A value of
+@var{emacs_mode} means Readline is currently in emacs mode; @var{vi_mode}
+means that vi mode is active.
+@end deftypevar
+
+
 @node Readline Convenience Functions
 @section Readline Convenience Functions
 
 @menu
 * Function Naming::	How to give a function you write a name.
 * Keymaps::		Making keymaps.
 * Binding Keys::	Changing Keymaps.
 * Associating Function Names and Bindings::	Translate function names to
 						key sequences.
 * Allowing Undoing::	How to make your functions undoable.
 * Redisplay::		Functions to control line display.
 * Modifying Text::	Functions to modify @code{rl_line_buffer}.
+* Character Input::	Functions to read keyboard input.
+* Terminal Management::	Functions to manage terminal settings.
 * Utility Functions::	Generally useful functions and hooks.
 * Alternate Interface::	Using Readline in a `callback' fashion.
 @end menu
 
 @node Function Naming
 @subsection Naming a Function
 
 The user can dynamically change the bindings of keys while using
@@ -357,269 +536,336 @@ the function.  Thus, in an init file, on
 Meta-Rubout:	backward-kill-word
 @end example
 
 This binds the keystroke @key{Meta-Rubout} to the function
 @emph{descriptively} named @code{backward-kill-word}.  You, as the
 programmer, should bind the functions you write to descriptive names as
 well.  Readline provides a function for doing that:
 
-@deftypefun int rl_add_defun (char *name, Function *function, int key)
+@deftypefun int rl_add_defun (const char *name, rl_command_func_t *function, int key)
 Add @var{name} to the list of named functions.  Make @var{function} be
 the function that gets called.  If @var{key} is not -1, then bind it to
-@var{function} using @code{rl_bind_key ()}.
+@var{function} using @code{rl_bind_key()}.
 @end deftypefun
 
 Using this function alone is sufficient for most applications.  It is
 the recommended way to add a few functions to the default functions that
 Readline has built in.  If you need to do something other
 than adding a function to Readline, you may need to use the
 underlying functions described below.
 
 @node Keymaps
 @subsection Selecting a Keymap
 
 Key bindings take place on a @dfn{keymap}.  The keymap is the
 association between the keys that the user types and the functions that
 get run.  You can make your own keymaps, copy existing keymaps, and tell
 Readline which keymap to use.
 
-@deftypefun Keymap rl_make_bare_keymap ()
+@deftypefun Keymap rl_make_bare_keymap (void)
 Returns a new, empty keymap.  The space for the keymap is allocated with
-@code{malloc ()}; you should @code{free ()} it when you are done.
+@code{malloc()}; the caller should free it by calling
+@code{rl_discard_keymap()} when done.
 @end deftypefun
 
 @deftypefun Keymap rl_copy_keymap (Keymap map)
 Return a new keymap which is a copy of @var{map}.
 @end deftypefun
 
-@deftypefun Keymap rl_make_keymap ()
+@deftypefun Keymap rl_make_keymap (void)
 Return a new keymap with the printing characters bound to rl_insert,
 the lowercase Meta characters bound to run their equivalents, and
 the Meta digits bound to produce numeric arguments.
 @end deftypefun
 
 @deftypefun void rl_discard_keymap (Keymap keymap)
 Free the storage associated with @var{keymap}.
 @end deftypefun
 
 Readline has several internal keymaps.  These functions allow you to
 change which keymap is active.
 
-@deftypefun Keymap rl_get_keymap ()
+@deftypefun Keymap rl_get_keymap (void)
 Returns the currently active keymap.
 @end deftypefun
 
 @deftypefun void rl_set_keymap (Keymap keymap)
 Makes @var{keymap} the currently active keymap.
 @end deftypefun
 
-@deftypefun Keymap rl_get_keymap_by_name (char *name)
+@deftypefun Keymap rl_get_keymap_by_name (const char *name)
 Return the keymap matching @var{name}.  @var{name} is one which would
 be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
 @end deftypefun
 
 @deftypefun {char *} rl_get_keymap_name (Keymap keymap)
 Return the name matching @var{keymap}.  @var{name} is one which would
 be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
 @end deftypefun
 
 @node Binding Keys
 @subsection Binding Keys
 
-You associate keys with functions through the keymap.  Readline has
-several internal keymaps: @code{emacs_standard_keymap},
+Key sequences are associate with functions through the keymap.
+Readline has several internal keymaps: @code{emacs_standard_keymap},
 @code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
 @code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
 @code{emacs_standard_keymap} is the default, and the examples in
 this manual assume that.
 
+Since @code{readline()} installs a set of default key bindings the first
+time it is called, there is always the danger that a custom binding
+installed before the first call to @code{readline()} will be overridden.
+An alternate mechanism is to install custom key bindings in an
+initialization function assigned to the @code{rl_startup_hook} variable
+(@pxref{Readline Variables}).
+
 These functions manage key bindings.
 
-@deftypefun int rl_bind_key (int key, Function *function)
+@deftypefun int rl_bind_key (int key, rl_command_func_t *function)
 Binds @var{key} to @var{function} in the currently active keymap.
 Returns non-zero in the case of an invalid @var{key}.
 @end deftypefun
 
-@deftypefun int rl_bind_key_in_map (int key, Function *function, Keymap map)
+@deftypefun int rl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)
 Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
 of an invalid @var{key}.
 @end deftypefun
 
 @deftypefun int rl_unbind_key (int key)
 Bind @var{key} to the null function in the currently active keymap.
 Returns non-zero in case of error.
 @end deftypefun
 
 @deftypefun int rl_unbind_key_in_map (int key, Keymap map)
 Bind @var{key} to the null function in @var{map}.
 Returns non-zero in case of error.
 @end deftypefun
 
-@deftypefun int rl_generic_bind (int type, char *keyseq, char *data, Keymap map)
+@deftypefun int rl_unbind_function_in_map (rl_command_func_t *function, Keymap map)
+Unbind all keys that execute @var{function} in @var{map}.
+@end deftypefun
+
+@deftypefun int rl_unbind_command_in_map (const char *command, Keymap map)
+Unbind all keys that are bound to @var{command} in @var{map}.
+@end deftypefun
+
+@deftypefun int rl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)
+Bind the key sequence represented by the string @var{keyseq} to the function
+@var{function}.  This makes new keymaps as
+necessary.  The initial keymap in which to do bindings is @var{map}.
+@end deftypefun
+
+@deftypefun int rl_generic_bind (int type, const char *keyseq, char *data, Keymap map)
 Bind the key sequence represented by the string @var{keyseq} to the arbitrary
 pointer @var{data}.  @var{type} says what kind of data is pointed to by
 @var{data}; this can be a function (@code{ISFUNC}), a macro
 (@code{ISMACR}), or a keymap (@code{ISKMAP}).  This makes new keymaps as
 necessary.  The initial keymap in which to do bindings is @var{map}.
 @end deftypefun
 
 @deftypefun int rl_parse_and_bind (char *line)
 Parse @var{line} as if it had been read from the @code{inputrc} file and
 perform any key bindings and variable assignments found
 (@pxref{Readline Init File}).
 @end deftypefun
 
-@deftypefun int rl_read_init_file (char *filename)
+@deftypefun int rl_read_init_file (const char *filename)
 Read keybindings and variable assignments from @var{filename}
 (@pxref{Readline Init File}).
 @end deftypefun
 
 @node Associating Function Names and Bindings
 @subsection Associating Function Names and Bindings
 
 These functions allow you to find out what keys invoke named functions
-and the functions invoked by a particular key sequence.
+and the functions invoked by a particular key sequence.  You may also
+associate a new function name with an arbitrary function.
 
-@deftypefun {Function *} rl_named_function (char *name)
+@deftypefun {rl_command_func_t *} rl_named_function (const char *name)
 Return the function with name @var{name}.
 @end deftypefun
 
-@deftypefun {Function *} rl_function_of_keyseq (char *keyseq, Keymap map, int *type)
+@deftypefun {rl_command_func_t *} rl_function_of_keyseq (const char *keyseq, Keymap map, int *type)
 Return the function invoked by @var{keyseq} in keymap @var{map}.
-If @var{map} is NULL, the current keymap is used.  If @var{type} is
-not NULL, the type of the object is returned in it (one of @code{ISFUNC},
-@code{ISKMAP}, or @code{ISMACR}).
+If @var{map} is @code{NULL}, the current keymap is used.  If @var{type} is
+not @code{NULL}, the type of the object is returned in the @code{int} variable
+it points to (one of @code{ISFUNC}, @code{ISKMAP}, or @code{ISMACR}).
 @end deftypefun
 
-@deftypefun {char **} rl_invoking_keyseqs (Function *function)
+@deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)
 Return an array of strings representing the key sequences used to
 invoke @var{function} in the current keymap.
 @end deftypefun
 
-@deftypefun {char **} rl_invoking_keyseqs_in_map (Function *function, Keymap map)
+@deftypefun {char **} rl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)
 Return an array of strings representing the key sequences used to
 invoke @var{function} in the keymap @var{map}.
 @end deftypefun
 
 @deftypefun void rl_function_dumper (int readable)
 Print the readline function names and the key sequences currently
 bound to them to @code{rl_outstream}.  If @var{readable} is non-zero,
 the list is formatted in such a way that it can be made part of an
 @code{inputrc} file and re-read.
 @end deftypefun
 
-@deftypefun void rl_list_funmap_names ()
+@deftypefun void rl_list_funmap_names (void)
 Print the names of all bindable Readline functions to @code{rl_outstream}.
 @end deftypefun
 
+@deftypefun {const char **} rl_funmap_names (void)
+Return a NULL terminated array of known function names.  The array is
+sorted.  The array itself is allocated, but not the strings inside.  You
+should @code{free()} the array when you are done, but not the pointers.
+@end deftypefun
+
+@deftypefun int rl_add_funmap_entry (const char *name, rl_command_func_t *function)
+Add @var{name} to the list of bindable Readline command names, and make
+@var{function} the function to be called when @var{name} is invoked.
+@end deftypefun
+
 @node Allowing Undoing
 @subsection Allowing Undoing
 
 Supporting the undo command is a painless thing, and makes your
 functions much more useful.  It is certainly easy to try
-something if you know you can undo it.  I could use an undo function for
-the stock market.
+something if you know you can undo it.
 
 If your function simply inserts text once, or deletes text once, and
-uses @code{rl_insert_text ()} or @code{rl_delete_text ()} to do it, then
+uses @code{rl_insert_text()} or @code{rl_delete_text()} to do it, then
 undoing is already done for you automatically.
 
 If you do multiple insertions or multiple deletions, or any combination
 of these operations, you should group them together into one operation.
-This is done with @code{rl_begin_undo_group ()} and
-@code{rl_end_undo_group ()}.
+This is done with @code{rl_begin_undo_group()} and
+@code{rl_end_undo_group()}.
 
 The types of events that can be undone are:
 
 @example
 enum undo_code @{ UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END @}; 
 @end example
 
 Notice that @code{UNDO_DELETE} means to insert some text, and
 @code{UNDO_INSERT} means to delete some text.  That is, the undo code
-tells undo what to undo, not how to undo it.  @code{UNDO_BEGIN} and
-@code{UNDO_END} are tags added by @code{rl_begin_undo_group ()} and
-@code{rl_end_undo_group ()}.
+tells what to undo, not how to undo it.  @code{UNDO_BEGIN} and
+@code{UNDO_END} are tags added by @code{rl_begin_undo_group()} and
+@code{rl_end_undo_group()}.
 
-@deftypefun int rl_begin_undo_group ()
+@deftypefun int rl_begin_undo_group (void)
 Begins saving undo information in a group construct.  The undo
-information usually comes from calls to @code{rl_insert_text ()} and
-@code{rl_delete_text ()}, but could be the result of calls to
-@code{rl_add_undo ()}.
+information usually comes from calls to @code{rl_insert_text()} and
+@code{rl_delete_text()}, but could be the result of calls to
+@code{rl_add_undo()}.
 @end deftypefun
 
-@deftypefun int rl_end_undo_group ()
+@deftypefun int rl_end_undo_group (void)
 Closes the current undo group started with @code{rl_begin_undo_group
-()}.  There should be one call to @code{rl_end_undo_group ()}
-for each call to @code{rl_begin_undo_group ()}.
+()}.  There should be one call to @code{rl_end_undo_group()}
+for each call to @code{rl_begin_undo_group()}.
 @end deftypefun
 
 @deftypefun void rl_add_undo (enum undo_code what, int start, int end, char *text)
 Remember how to undo an event (according to @var{what}).  The affected
 text runs from @var{start} to @var{end}, and encompasses @var{text}.
 @end deftypefun
 
-@deftypefun void free_undo_list ()
+@deftypefun void rl_free_undo_list (void)
 Free the existing undo list.
 @end deftypefun
 
-@deftypefun int rl_do_undo ()
+@deftypefun int rl_do_undo (void)
 Undo the first thing on the undo list.  Returns @code{0} if there was
 nothing to undo, non-zero if something was undone.
 @end deftypefun
 
 Finally, if you neither insert nor delete text, but directly modify the
-existing text (e.g., change its case), call @code{rl_modifying ()}
+existing text (e.g., change its case), call @code{rl_modifying()}
 once, just before you modify the text.  You must supply the indices of
 the text range that you are going to modify.
 
 @deftypefun int rl_modifying (int start, int end)
 Tell Readline to save the text between @var{start} and @var{end} as a
 single undo unit.  It is assumed that you will subsequently modify
 that text.
 @end deftypefun
 
 @node Redisplay
 @subsection Redisplay
 
-@deftypefun void rl_redisplay ()
+@deftypefun void rl_redisplay (void)
 Change what's displayed on the screen to reflect the current contents
 of @code{rl_line_buffer}.
 @end deftypefun
 
-@deftypefun int rl_forced_update_display ()
+@deftypefun int rl_forced_update_display (void)
 Force the line to be updated and redisplayed, whether or not
 Readline thinks the screen display is correct.
 @end deftypefun
 
-@deftypefun int rl_on_new_line ()
-Tell the update routines that we have moved onto a new (empty) line,
+@deftypefun int rl_on_new_line (void)
+Tell the update functions that we have moved onto a new (empty) line,
 usually after ouputting a newline.
 @end deftypefun
 
-@deftypefun int rl_reset_line_state ()
+@deftypefun int rl_on_new_line_with_prompt (void)
+Tell the update functions that we have moved onto a new line, with
+@var{rl_prompt} already displayed.
+This could be used by applications that want to output the prompt string
+themselves, but still need Readline to know the prompt string length for
+redisplay.
+It should be used after setting @var{rl_already_prompted}.
+@end deftypefun
+
+@deftypefun int rl_reset_line_state (void)
 Reset the display state to a clean state and redisplay the current line
 starting on a new line.
 @end deftypefun
 
-@deftypefun int rl_message (va_alist)
-The arguments are a string as would be supplied to @code{printf}.  The
-resulting string is displayed in the @dfn{echo area}.  The echo area
+@deftypefun int rl_crlf (void)
+Move the cursor to the start of the next screen line.
+@end deftypefun
+
+@deftypefun int rl_message (const char *, @dots{})
+The arguments are a format string as would be supplied to @code{printf},
+possibly containing conversion specifications such as @samp{%d}, and
+any additional arguments necessary to satisfy the conversion specifications.
+The resulting string is displayed in the @dfn{echo area}.  The echo area
 is also used to display numeric arguments and search strings.
 @end deftypefun
 
-@deftypefun int rl_clear_message ()
+@deftypefun int rl_clear_message (void)
 Clear the message in the echo area.
 @end deftypefun
 
+@deftypefun void rl_save_prompt (void)
+Save the local Readline prompt display state in preparation for
+displaying a new message in the message area with @code{rl_message()}.
+@end deftypefun
+
+@deftypefun void rl_restore_prompt (void)
+Restore the local Readline prompt display state saved by the most
+recent call to @code{rl_save_prompt}.
+@end deftypefun
+
+@deftypefun int rl_expand_prompt (char *prompt)
+Expand any special character sequences in @var{prompt} and set up the
+local Readline prompt redisplay variables.
+This function is called by @code{readline()}.  It may also be called to
+expand the primary prompt if the @code{rl_on_new_line_with_prompt()}
+function or @code{rl_already_prompted} variable is used.
+It returns the number of visible characters on the last line of the
+(possibly multi-line) prompt.
+@end deftypefun
 @node Modifying Text
 @subsection Modifying Text
 
-@deftypefun int rl_insert_text (char *text)
+@deftypefun int rl_insert_text (const char *text)
 Insert @var{text} into the line at the current cursor position.
 @end deftypefun
 
 @deftypefun int rl_delete_text (int start, int end)
 Delete the text between @var{start} and @var{end} in the current line.
 @end deftypefun
 
 @deftypefun {char *} rl_copy_text (int start, int end)
@@ -631,116 +877,166 @@ the current line.
 Copy the text between @var{start} and @var{end} in the current line
 to the kill ring, appending or prepending to the last kill if the
 last command was a kill command.  The text is deleted.
 If @var{start} is less than @var{end},
 the text is appended, otherwise prepended.  If the last command was
 not a kill, a new kill ring slot is used.
 @end deftypefun
 
-@node Utility Functions
-@subsection Utility Functions
+@node Character Input
+@subsection Character Input
 
-@deftypefun int rl_read_key ()
-Return the next character available.  This handles input inserted into
-the input stream via @var{pending input} (@pxref{Readline Variables})
-and @code{rl_stuff_char ()}, macros, and characters read from the keyboard.
+@deftypefun int rl_read_key (void)
+Return the next character available from Readline's current input stream.
+This handles input inserted into
+the input stream via @var{rl_pending_input} (@pxref{Readline Variables})
+and @code{rl_stuff_char()}, macros, and characters read from the keyboard.
 @end deftypefun
 
-@deftypefun int rl_getc (FILE *)
-Return the next character available from the keyboard.
+@deftypefun int rl_getc (FILE *stream)
+Return the next character available from @var{stream}, which is assumed to
+be the keyboard.
 @end deftypefun
 
 @deftypefun int rl_stuff_char (int c)
 Insert @var{c} into the Readline input stream.  It will be "read"
 before Readline attempts to read characters from the terminal with
-@code{rl_read_key ()}.
+@code{rl_read_key()}.
+@end deftypefun
+
+@deftypefun int rl_execute_next (int c)
+Make @var{c} be the next command to be executed when @code{rl_read_key()}
+is called.  This sets @var{rl_pending_input}.
+@end deftypefun
+
+@deftypefun int rl_clear_pending_input (void)
+Unet @var{rl_pending_input}, effectively negating the effect of any
+previous call to @code{rl_execute_next()}.  This works only if the
+pending input has not already been read with @code{rl_read_key()}.
+@end deftypefun
+
+@node Terminal Management
+@subsection Terminal Management
+
+@deftypefun int rl_prep_terminal (int meta_flag)
+Modify the terminal settings for Readline's use, so @code{readline()}
+can read a single character at a time from the keyboard.
+The @var{meta_flag} argument should be non-zero if Readline should
+read eight-bit input.
 @end deftypefun
 
-@deftypefun rl_extend_line_buffer (int len)
+@deftypefun in rl_deprep_terminal (void)
+Undo the effects of @code{rl_prep_terminal()}, leaving the terminal in
+the state in which it was before the most recent call to
+@code{rl_prep_terminal()}.
+@end deftypefun
+
+@deftypefun void rl_tty_set_default_bindings (Keymap kmap)
+Read the operating system's terminal editing characters (as would be displayed
+by @code{stty} to their readline equivalents.  The bindings are performed
+in @var{kmap}.
+@end deftypefun
+
+@deftypefun int rl_reset_terminal (const char *terminal_name)
+Reinitialize Readline's idea of the terminal settings using
+@var{terminal_name} as the terminal type (e.g., @code{vt100}).
+If @var{terminal_name} is NULL, the value of the @code{TERM}
+environment variable is used.
+@end deftypefun
+
+@node Utility Functions
+@subsection Utility Functions
+
+@deftypefun int rl_extend_line_buffer (int len)
 Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
 characters, possibly reallocating it if necessary.
 @end deftypefun
 
-@deftypefun int rl_initialize ()
+@deftypefun int rl_initialize (void)
 Initialize or re-initialize Readline's internal state.
+It's not strictly necessary to call this; @code{readline()} calls it before
+reading any input.
 @end deftypefun
 
-@deftypefun int rl_reset_terminal (char *terminal_name)
-Reinitialize Readline's idea of the terminal settings using
-@var{terminal_name} as the terminal type (e.g., @code{vt100}).
+@deftypefun int rl_ding (void)
+Ring the terminal bell, obeying the setting of @code{bell-style}.
 @end deftypefun
 
-@deftypefun int alphabetic (int c)
+@deftypefun int rl_alphabetic (int c)
 Return 1 if @var{c} is an alphabetic character.
 @end deftypefun
 
-@deftypefun int numeric (int c)
+@deftypefun void rl_display_match_list (char **matches, int len, int max)
+A convenience function for displaying a list of strings in
+columnar format on Readline's output stream.  @code{matches} is the list
+of strings, in argv format, such as a list of completion matches.
+@code{len} is the number of strings in @code{matches}, and @code{max}
+is the length of the longest string in @code{matches}.  This function uses
+the setting of @code{print-completions-horizontally} to select how the
+matches are displayed (@pxref{Readline Init File Syntax}).
+@end deftypefun
+
+The following are implemented as macros, defined in @code{chardefs.h}.
+Applications should refrain from using them.
+
+@deftypefun int _rl_uppercase_p (int c)
+Return 1 if @var{c} is an uppercase alphabetic character.
+@end deftypefun
+
+@deftypefun int _rl_lowercase_p (int c)
+Return 1 if @var{c} is a lowercase alphabetic character.
+@end deftypefun
+
+@deftypefun int _rl_digit_p (int c)
 Return 1 if @var{c} is a numeric character.
 @end deftypefun
 
-@deftypefun int ding ()
-Ring the terminal bell, obeying the setting of @code{bell-style}.
-@end deftypefun
-
-The following are implemented as macros, defined in @code{chartypes.h}.
-
-@deftypefun int uppercase_p (int c)
-Return 1 if @var{c} is an uppercase alphabetic character.
-@end deftypefun
-
-@deftypefun int lowercase_p (int c)
-Return 1 if @var{c} is a lowercase alphabetic character.
-@end deftypefun
-
-@deftypefun int digit_p (int c)
-Return 1 if @var{c} is a numeric character.
-@end deftypefun
-
-@deftypefun int to_upper (int c)
+@deftypefun int _rl_to_upper (int c)
 If @var{c} is a lowercase alphabetic character, return the corresponding
 uppercase character.
 @end deftypefun
 
-@deftypefun int to_lower (int c)
+@deftypefun int _rl_to_lower (int c)
 If @var{c} is an uppercase alphabetic character, return the corresponding
 lowercase character.
 @end deftypefun
 
-@deftypefun int digit_value (int c)
+@deftypefun int _rl_digit_value (int c)
 If @var{c} is a number, return the value it represents.
 @end deftypefun
 
 @node Alternate Interface
 @subsection Alternate Interface
 
 An alternate interface is available to plain @code{readline()}.  Some
 applications need to interleave keyboard I/O with file, device, or
 window system I/O, typically by using a main loop to @code{select()}
 on various file descriptors.  To accomodate this need, readline can
 also be invoked as a `callback' function from an event loop.  There
 are functions available to make this easy.
 
-@deftypefun void rl_callback_handler_install (char *prompt, Vfunction *lhandler)
+@deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)
 Set up the terminal for readline I/O and display the initial
 expanded value of @var{prompt}.  Save the value of @var{lhandler} to
-use as a callback when a complete line of input has been entered.
+use as a function to call when a complete line of input has been entered.
+The function takes the text of the line as an argument.
 @end deftypefun
 
-@deftypefun void rl_callback_read_char ()
+@deftypefun void rl_callback_read_char (void)
 Whenever an application determines that keyboard input is available, it
 should call @code{rl_callback_read_char()}, which will read the next
 character from the current input source.  If that character completes the
 line, @code{rl_callback_read_char} will invoke the @var{lhandler}
 function saved by @code{rl_callback_handler_install} to process the
 line.  @code{EOF} is  indicated by calling @var{lhandler} with a
 @code{NULL} line.
 @end deftypefun
 
-@deftypefun void rl_callback_handler_remove ()
+@deftypefun void rl_callback_handler_remove (void)
 Restore the terminal to its initial state and remove the line handler.
 This may be called from within a callback as well as independently.
 @end deftypefun
 
 @subsection An Example
 
 Here is a function which changes lowercase characters to their uppercase
 equivalents, and uppercase characters to lowercase.  If
@@ -790,27 +1086,143 @@ invert_case_line (count, key)
     @}
 
   /* Tell readline that we are modifying the line, so it will save
      the undo information. */
   rl_modifying (start, end);
 
   for (i = start; i != end; i++)
     @{
-      if (uppercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
-      else if (lowercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
+      if (_rl_uppercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
+      else if (_rl_lowercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
     @}
   /* Move point to on top of the last character changed. */
   rl_point = (direction == 1) ? end - 1 : start;
   return (0);
 @}
 @end example
 
+@node Readline Signal Handling
+@section Readline Signal Handling
+
+Signals are asynchronous events sent to a process by the Unix kernel,
+sometimes on behalf of another process.  They are intended to indicate
+exceptional events, like a user pressing the interrupt key on his
+terminal, or a network connection being broken.  There is a class of
+signals that can be sent to the process currently reading input from
+the keyboard.  Since Readline changes the terminal attributes when it
+is called, it needs to perform special processing when a signal is
+received to restore the terminal to a sane state, or provide application
+writers with functions to do so manually.
+
+Readline contains an internal signal handler that is installed for a
+number of signals (@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM},
+@code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}).
+When one of these signals is received, the signal handler
+will reset the terminal attributes to those that were in effect before
+@code{readline()} was called, reset the signal handling to what it was
+before @code{readline()} was called, and resend the signal to the calling
+application.
+If and when the calling application's signal handler returns, Readline
+will reinitialize the terminal and continue to accept input.
+When a @code{SIGINT} is received, the Readline signal handler performs
+some additional work, which will cause any partially-entered line to be
+aborted (see the description of @code{rl_free_line_state()} below).
+
+There is an additional Readline signal handler, for @code{SIGWINCH}, which
+the kernel sends to a process whenever the terminal's size changes (for
+example, if a user resizes an @code{xterm}).  The Readline @code{SIGWINCH}
+handler updates Readline's internal screen size information, and then calls
+any @code{SIGWINCH} signal handler the calling application has installed. 
+Readline calls the application's @code{SIGWINCH} signal handler without
+resetting the terminal to its original state.  If the application's signal
+handler does more than update its idea of the terminal size and return (for
+example, a @code{longjmp} back to a main processing loop), it @emph{must}
+call @code{rl_cleanup_after_signal()} (described below), to restore the
+terminal state. 
+
+Readline provides two variables that allow application writers to
+control whether or not it will catch certain signals and act on them
+when they are received.  It is important that applications change the
+values of these variables only when calling @code{readline()}, not in
+a signal handler, so Readline's internal signal state is not corrupted.
+
+@deftypevar int rl_catch_signals
+If this variable is non-zero, Readline will install signal handlers for
+@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM}, @code{SIGALRM},
+@code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}.
+
+The default value of @code{rl_catch_signals} is 1.
+@end deftypevar
+
+@deftypevar int rl_catch_sigwinch
+If this variable is non-zero, Readline will install a signal handler for
+@code{SIGWINCH}.
+
+The default value of @code{rl_catch_sigwinch} is 1.
+@end deftypevar
+
+If an application does not wish to have Readline catch any signals, or
+to handle signals other than those Readline catches (@code{SIGHUP},
+for example), 
+Readline provides convenience functions to do the necessary terminal
+and internal state cleanup upon receipt of a signal.
+
+@deftypefun void rl_cleanup_after_signal (void)
+This function will reset the state of the terminal to what it was before
+@code{readline()} was called, and remove the Readline signal handlers for
+all signals, depending on the values of @code{rl_catch_signals} and
+@code{rl_catch_sigwinch}.
+@end deftypefun
+
+@deftypefun void rl_free_line_state (void)
+This will free any partial state associated with the current input line
+(undo information, any partial history entry, any partially-entered
+keyboard macro, and any partially-entered numeric argument).  This
+should be called before @code{rl_cleanup_after_signal()}.  The
+Readline signal handler for @code{SIGINT} calls this to abort the
+current input line.
+@end deftypefun
+
+@deftypefun void rl_reset_after_signal (void)
+This will reinitialize the terminal and reinstall any Readline signal
+handlers, depending on the values of @code{rl_catch_signals} and
+@code{rl_catch_sigwinch}.
+@end deftypefun
+
+If an application does not wish Readline to catch @code{SIGWINCH}, it may
+call @code{rl_resize_terminal()} or @code{rl_set_screen_size()} to force
+Readline to update its idea of the terminal size when a @code{SIGWINCH}
+is received.
+
+@deftypefun void rl_resize_terminal (void)
+Update Readline's internal screen size by reading values from the kernel.
+@end deftypefun
+
+@deftypefun void rl_set_screen_size (int rows, int cols)
+Set Readline's idea of the terminal size to @var{rows} rows and
+@var{cols} columns.
+@end deftypefun
+
+The following functions install and remove Readline's signal handlers.
+
+@deftypefun int rl_set_signals (void)
+Install Readline's signal handler for @code{SIGINT}, @code{SIGQUIT},
+@code{SIGTERM}, @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN},
+@code{SIGTTOU}, and @code{SIGWINCH}, depending on the values of
+@code{rl_catch_signals} and @code{rl_catch_sigwinch}.
+@end deftypefun
+
+@deftypefun int rl_clear_signals (void)
+Remove all of the Readline signal handlers installed by
+@code{rl_set_signals()}.
+@end deftypefun
+
 @node Custom Completers
 @section Custom Completers
 
 Typically, a program that reads commands from the user has a way of
 disambiguating commands and data.  If your program is one of these, then
 it can provide completion for commands, data, or both.
 The following sections describe how your program and Readline
 cooperate to provide this service.
@@ -833,59 +1245,61 @@ the user interface to completion, and tw
 completion functions:  filename and username.  For completing other types
 of text, you must write your own completion function.  This section
 describes exactly what such functions must do, and provides an example.
 
 There are three major functions used to perform completion:
 
 @enumerate
 @item
-The user-interface function @code{rl_complete ()}.  This function is
-called with the same arguments as other Readline
-functions intended for interactive use:  @var{count} and
-@var{invoking_key}.  It isolates the word to be completed and calls
-@code{completion_matches ()} to generate a list of possible completions.
+The user-interface function @code{rl_complete()}.  This function is
+called with the same arguments as other bindable Readline functions:
+@var{count} and @var{invoking_key}.
+It isolates the word to be completed and calls
+@code{rl_completion_matches()} to generate a list of possible completions.
 It then either lists the possible completions, inserts the possible
 completions, or actually performs the
 completion, depending on which behavior is desired.
 
 @item
-The internal function @code{completion_matches ()} uses your
-@dfn{generator} function to generate the list of possible matches, and
-then returns the array of these matches.  You should place the address
-of your generator function in @code{rl_completion_entry_function}.
+The internal function @code{rl_completion_matches()} uses an
+application-supplied @dfn{generator} function to generate the list of
+possible matches, and then returns the array of these matches.
+The caller should place the address of its generator function in
+@code{rl_completion_entry_function}.
 
 @item
 The generator function is called repeatedly from
-@code{completion_matches ()}, returning a string each time.  The
+@code{rl_completion_matches()}, returning a string each time.  The
 arguments to the generator function are @var{text} and @var{state}.
 @var{text} is the partial word to be completed.  @var{state} is zero the
 first time the function is called, allowing the generator to perform
 any necessary initialization, and a positive non-zero integer for
-each subsequent call.  When the generator function returns
-@code{(char *)NULL} this signals @code{completion_matches ()} that there are
+each subsequent call.  The generator function returns
+@code{(char *)NULL} to inform @code{rl_completion_matches()} that there are
 no more possibilities left.  Usually the generator function computes the
 list of possible completions when @var{state} is zero, and returns them
 one at a time on subsequent calls.  Each string the generator function
 returns as a match must be allocated with @code{malloc()}; Readline
 frees the strings when it has finished with them.
 
 @end enumerate
 
 @deftypefun int rl_complete (int ignore, int invoking_key)
 Complete the word at or before point.  You have supplied the function
 that does the initial simple matching selection algorithm (see
-@code{completion_matches ()}).  The default is to do filename completion.
+@code{rl_completion_matches()}).  The default is to do filename completion.
 @end deftypefun
 
-@deftypevar {Function *} rl_completion_entry_function
-This is a pointer to the generator function for @code{completion_matches
-()}.  If the value of @code{rl_completion_entry_function} is
-@code{(Function *)NULL} then the default filename generator function,
-@code{filename_completion_function ()}, is used.
+@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
+This is a pointer to the generator function for
+@code{rl_completion_matches()}.
+If the value of @code{rl_completion_entry_function} is
+@code{NULL} then the default filename generator
+function, @code{rl_filename_completion_function()}, is used.
 @end deftypevar
 
 @node Completion Functions
 @subsection Completion Functions
 
 Here is the complete list of callable completion functions present in
 Readline.
 
@@ -896,153 +1310,156 @@ completions.  @samp{TAB} means do standa
 insert all of the possible completions.  @samp{!} means to display
 all of the possible completions, if there is more than one, as well as
 performing partial completion.
 @end deftypefun
 
 @deftypefun int rl_complete (int ignore, int invoking_key)
 Complete the word at or before point.  You have supplied the function
 that does the initial simple matching selection algorithm (see
-@code{completion_matches ()} and @code{rl_completion_entry_function}).
+@code{rl_completion_matches()} and @code{rl_completion_entry_function}).
 The default is to do filename
-completion.  This calls @code{rl_complete_internal ()} with an
+completion.  This calls @code{rl_complete_internal()} with an
 argument depending on @var{invoking_key}.
 @end deftypefun
 
-@deftypefun int rl_possible_completions (int count, int invoking_key))
+@deftypefun int rl_possible_completions (int count, int invoking_key)
 List the possible completions.  See description of @code{rl_complete
-()}.  This calls @code{rl_complete_internal ()} with an argument of
+()}.  This calls @code{rl_complete_internal()} with an argument of
 @samp{?}.
 @end deftypefun
 
-@deftypefun int rl_insert_completions (int count, int invoking_key))
+@deftypefun int rl_insert_completions (int count, int invoking_key)
 Insert the list of possible completions into the line, deleting the
-partially-completed word.  See description of @code{rl_complete ()}.
-This calls @code{rl_complete_internal ()} with an argument of @samp{*}.
+partially-completed word.  See description of @code{rl_complete()}.
+This calls @code{rl_complete_internal()} with an argument of @samp{*}.
 @end deftypefun
 
-@deftypefun {char **} completion_matches (char *text, CPFunction *entry_func)
+@deftypefun {char **} rl_completion_matches (const char *text, rl_compentry_func_t *entry_func)
 Returns an array of @code{(char *)} which is a list of completions for
-@var{text}.  If there are no completions, returns @code{(char **)NULL}.
+@var{text}.  If there are no completions, returns @code{NULL}.
 The first entry in the returned array is the substitution for @var{text}.
 The remaining entries are the possible completions.  The array is
 terminated with a @code{NULL} pointer.
 
 @var{entry_func} is a function of two args, and returns a
 @code{(char *)}.  The first argument is @var{text}.  The second is a
 state argument; it is zero on the first call, and non-zero on subsequent
 calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
 when there are no more matches.
 @end deftypefun
 
-@deftypefun {char *} filename_completion_function (char *text, int state)
+@deftypefun {char *} rl_filename_completion_function (const char *text, int state)
 A generator function for filename completion in the general case.  Note
 that completion in Bash is a little different because of all
 the pathnames that must be followed when looking up completions for a
 command.  The Bash source is a useful reference for writing custom
 completion functions.
 @end deftypefun
 
-@deftypefun {char *} username_completion_function (char *text, int state)
+@deftypefun {char *} rl_username_completion_function (const char *text, int state)
 A completion generator for usernames.  @var{text} contains a partial
 username preceded by a random character (usually @samp{~}).  As with all
 completion generators, @var{state} is zero on the first call and non-zero
 for subsequent calls.
 @end deftypefun
 
 @node Completion Variables
 @subsection Completion Variables
 
-@deftypevar {Function *} rl_completion_entry_function
-A pointer to the generator function for @code{completion_matches ()}.
-@code{NULL} means to use @code{filename_entry_function ()}, the default
+@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
+A pointer to the generator function for @code{rl_completion_matches()}.
+@code{NULL} means to use @code{rl_filename_completion_function()}, the default
 filename completer.
 @end deftypevar
 
-@deftypevar {CPPFunction *} rl_attempted_completion_function
+@deftypevar {rl_completion_func_t *} rl_attempted_completion_function
 A pointer to an alternative function to create matches.
 The function is called with @var{text}, @var{start}, and @var{end}.
-@var{start} and @var{end} are indices in @code{rl_line_buffer} saying
-what the boundaries of @var{text} are.  If this function exists and
-returns @code{NULL}, or if this variable is set to @code{NULL}, then
-@code{rl_complete ()} will call the value of
+@var{start} and @var{end} are indices in @code{rl_line_buffer} defining
+the boundaries of @var{text}, which is a character string.
+If this function exists and returns @code{NULL}, or if this variable is
+set to @code{NULL}, then @code{rl_complete()} will call the value of
 @code{rl_completion_entry_function} to generate matches, otherwise the
 array of strings returned will be used.
+If this function sets the @code{rl_attempted_completion_over}
+variable to a non-zero value, Readline will not perform its default
+completion if this function returns no matches.
 @end deftypevar
 
-@deftypevar {CPFunction *} rl_filename_quoting_function
-A pointer to a function that will quote a filename in an application-
-specific fashion.  This is called if filename completion is being
+@deftypevar {rl_quote_func_t *} rl_filename_quoting_function
+A pointer to a function that will quote a filename in an
+application-specific fashion.  This is called if filename completion is being
 attempted and one of the characters in @code{rl_filename_quote_characters}
 appears in a completed filename.  The function is called with
 @var{text}, @var{match_type}, and @var{quote_pointer}.  The @var{text}
 is the filename to be quoted.  The @var{match_type} is either
 @code{SINGLE_MATCH}, if there is only one completion match, or
 @code{MULT_MATCH}.  Some functions use this to decide whether or not to
 insert a closing quote character.  The @var{quote_pointer} is a pointer
 to any opening quote character the user typed.  Some functions choose
 to reset this character.
 @end deftypevar
 
-@deftypevar {CPFunction *} rl_filename_dequoting_function
+@deftypevar {rl_dequote_func_t *} rl_filename_dequoting_function
 A pointer to a function that will remove application-specific quoting
 characters from a filename before completion is attempted, so those
 characters do not interfere with matching the text against names in
 the filesystem.  It is called with @var{text}, the text of the word
 to be dequoted, and @var{quote_char}, which is the quoting character 
 that delimits the filename (usually @samp{'} or @samp{"}).  If
 @var{quote_char} is zero, the filename was not in an embedded string.
 @end deftypevar
 
-@deftypevar {Function *} rl_char_is_quoted_p
+@deftypevar {rl_linebuf_func_t *} rl_char_is_quoted_p
 A pointer to a function to call that determines whether or not a specific
 character in the line buffer is quoted, according to whatever quoting
 mechanism the program calling readline uses.  The function is called with
 two arguments: @var{text}, the text of the line, and @var{index}, the
 index of the character in the line.  It is used to decide whether a
 character found in @code{rl_completer_word_break_characters} should be
 used to break words for the completer.
 @end deftypevar
 
 @deftypevar int rl_completion_query_items
 Up to this many items will be displayed in response to a
 possible-completions call.  After that, we ask the user if she is sure
 she wants to see them all.  The default value is 100.
 @end deftypevar
 
-@deftypevar {char *} rl_basic_word_break_characters
+@deftypevar {const char *} rl_basic_word_break_characters
 The basic list of characters that signal a break between words for the
 completer routine.  The default value of this variable is the characters
 which break words for completion in Bash, i.e.,
 @code{" \t\n\"\\'`@@$><=;|&@{("}.
 @end deftypevar
 
-@deftypevar {char *} rl_basic_quote_characters
+@deftypevar {const char *} rl_basic_quote_characters
 List of quote characters which can cause a word break.
 @end deftypevar
 
-@deftypevar {char *} rl_completer_word_break_characters
+@deftypevar {const char *} rl_completer_word_break_characters
 The list of characters that signal a break between words for
-@code{rl_complete_internal ()}.  The default list is the value of
+@code{rl_complete_internal()}.  The default list is the value of
 @code{rl_basic_word_break_characters}.
 @end deftypevar
 
-@deftypevar {char *} rl_completer_quote_characters
+@deftypevar {const char *} rl_completer_quote_characters
 List of characters which can be used to quote a substring of the line.
 Completion occurs on the entire substring, and within the substring
 @code{rl_completer_word_break_characters} are treated as any other character,
 unless they also appear within this list.
 @end deftypevar
 
-@deftypevar {char *} rl_filename_quote_characters
+@deftypevar {const char *} rl_filename_quote_characters
 A list of characters that cause a filename to be quoted by the completer
-when they appear in a completed filename.  The default is empty.
+when they appear in a completed filename.  The default is the null string.
 @end deftypevar
 
-@deftypevar {char *} rl_special_prefixes
+@deftypevar {const char *} rl_special_prefixes
 The list of characters that are word break characters, but should be
 left in @var{text} when it is passed to the completion function.
 Programs can use this to help determine what kind of completing to do.
 For instance, Bash sets this variable to "$@@" so that it can complete
 shell variables and hostnames.
 @end deftypevar
 
 @deftypevar {int} rl_completion_append_character
@@ -1059,50 +1476,85 @@ an application-specific command line syn
 If non-zero, then disallow duplicates in the matches.  Default is 1.
 @end deftypevar
 
 @deftypevar int rl_filename_completion_desired
 Non-zero means that the results of the matches are to be treated as
 filenames.  This is @emph{always} zero on entry, and can only be changed
 within a completion entry generator function.  If it is set to a non-zero
 value, directory names have a slash appended and Readline attempts to
-quote completed filenames if they contain any embedded word break
-characters.
+quote completed filenames if they contain any characters in
+@code{rl_filename_quote_characters} and @code{rl_filename_quoting_desired}
+is set to a non-zero value.
 @end deftypevar
 
 @deftypevar int rl_filename_quoting_desired
 Non-zero means that the results of the matches are to be quoted using
 double quotes (or an application-specific quoting mechanism) if the
 completed filename contains any characters in
 @code{rl_filename_quote_chars}.  This is @emph{always} non-zero
 on entry, and can only be changed within a completion entry generator
 function.  The quoting is effected via a call to the function pointed to
 by @code{rl_filename_quoting_function}.
 @end deftypevar
 
+@deftypevar int rl_attempted_completion_over
+If an application-specific completion function assigned to
+@code{rl_attempted_completion_function} sets this variable to a non-zero
+value, Readline will not perform its default filename completion if the
+application's completion function returns no matches.
+It should be set only by an application's completion function.
+@end deftypevar
+
+@deftypevar int rl_completion_type
+Set to a character describing the type of completion Readline is currently
+attempting; see the description of @code{rl_complete_internal()}
+(@pxref{Completion Functions}) for the list of characters.
+@end deftypevar
+
 @deftypevar int rl_inhibit_completion
-If this variable is non-zero, completion is inhibit<ed.  The completion
+If this variable is non-zero, completion is inhibited.  The completion
 character will be inserted as any other bound to @code{self-insert}.
 @end deftypevar
 
-@deftypevar {Function *} rl_ignore_some_completions_function
+@deftypevar {rl_compignore_func_t *} rl_ignore_some_completions_function
 This function, if defined, is called by the completer when real filename
 completion is done, after all the matching names have been generated.
 It is passed a @code{NULL} terminated array of matches.
 The first element (@code{matches[0]}) is the
 maximal substring common to all matches. This function can
 re-arrange the list of matches as required, but each element deleted
 from the array must be freed.
 @end deftypevar
 
-@deftypevar {Function *} rl_directory_completion_hook
+@deftypevar {rl_icppfunc_t *} rl_directory_completion_hook
 This function, if defined, is allowed to modify the directory portion
 of filenames Readline completes.  It is called with the address of a
-string (the current directory name) as an argument.  It could be used
-to expand symbolic links or shell variables in pathnames.
+string (the current directory name) as an argument, and may modify that string.
+If the string is replaced with a new string, the old value should be freed.
+Any modified directory name should have a trailing slash.
+The modified value will be displayed as part of the completion, replacing
+the directory portion of the pathname the user typed.
+It returns an integer that should be non-zero if the function modifies
+its directory argument.
+It could be used to expand symbolic links or shell variables in pathnames.
+@end deftypevar
+
+@deftypevar {rl_compdisp_func_t *} rl_completion_display_matches_hook
+If non-zero, then this is the address of a function to call when
+completing a word would normally display the list of possible matches.
+This function is called in lieu of Readline displaying the list.
+It takes three arguments:
+(@code{char **}@var{matches}, @code{int} @var{num_matches}, @code{int} @var{max_length})
+where @var{matches} is the array of matching strings,
+@var{num_matches} is the number of strings in that array, and
+@var{max_length} is the length of the longest string in that array.
+Readline provides a convenience function, @code{rl_display_match_list},
+that takes care of doing the display to Readline's output stream.  That
+function may be called from this hook.
 @end deftypevar
 
 @node A Short Completion Example
 @subsection A Short Completion Example
 
 Here is a small application demonstrating the use of the GNU Readline
 library.  It is called @code{fileman}, and the source code resides in
 @file{examples/fileman.c}.  This sample application provides
@@ -1119,55 +1571,61 @@ history list.
 #include <sys/types.h>
 #include <sys/file.h>
 #include <sys/stat.h>
 #include <sys/errno.h>
 
 #include <readline/readline.h>
 #include <readline/history.h>
 
-extern char *getwd ();
 extern char *xmalloc ();
 
 /* The names of functions that actually do the manipulation. */
-int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
-int com_delete (), com_help (), com_cd (), com_quit ();
+int com_list __P((char *));
+int com_view __P((char *));
+int com_rename __P((char *));
+int com_stat __P((char *));
+int com_pwd __P((char *));
+int com_delete __P((char *));
+int com_help __P((char *));
+int com_cd __P((char *));
+int com_quit __P((char *));
 
 /* A structure which contains information on the commands this program
    can understand. */
 
 typedef struct @{
   char *name;			/* User printable name of the function. */
-  Function *func;		/* Function to call to do the job. */
+  rl_icpfunc_t *func;		/* Function to call to do the job. */
   char *doc;			/* Documentation for this function.  */
 @} COMMAND;
 
 COMMAND commands[] = @{
   @{ "cd", com_cd, "Change to directory DIR" @},
   @{ "delete", com_delete, "Delete FILE" @},
   @{ "help", com_help, "Display this text" @},
   @{ "?", com_help, "Synonym for `help'" @},
   @{ "list", com_list, "List files in DIR" @},
   @{ "ls", com_list, "Synonym for `list'" @},
   @{ "pwd", com_pwd, "Print the current working directory" @},
   @{ "quit", com_quit, "Quit using Fileman" @},
   @{ "rename", com_rename, "Rename FILE to NEWNAME" @},
   @{ "stat", com_stat, "Print out statistics on FILE" @},
   @{ "view", com_view, "View the contents of FILE" @},
-  @{ (char *)NULL, (Function *)NULL, (char *)NULL @}
+  @{ (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL @}
 @};
 
 /* Forward declarations. */
 char *stripwhite ();
 COMMAND *find_command ();
 
 /* The name of this program, as taken from argv[0]. */
 char *progname;
 
-/* When non-zero, this global means the user is done using this program. */
+/* When non-zero, this means the user is done using this program. */
 int done;
 
 char *
 dupstr (s)
      int s;
 @{
   char *r;
 
@@ -1287,75 +1745,76 @@ stripwhite (string)
 @}
 
 /* **************************************************************** */
 /*                                                                  */
 /*                  Interface to Readline Completion                */
 /*                                                                  */
 /* **************************************************************** */
 
-char *command_generator ();
-char **fileman_completion ();
+char *command_generator __P((const char *, int));
+char **fileman_completion __P((const char *, int, int));
 
-/* Tell the GNU Readline library how to complete.  We want to try to complete
-   on command names if this is the first word in the line, or on filenames
-   if not. */
+/* Tell the GNU Readline library how to complete.  We want to try to
+   complete on command names if this is the first word in the line, or
+   on filenames if not. */
 initialize_readline ()
 @{
   /* Allow conditional parsing of the ~/.inputrc file. */
   rl_readline_name = "FileMan";
 
   /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+  rl_attempted_completion_function = fileman_completion;
 @}
 
-/* Attempt to complete on the contents of TEXT.  START and END bound the
-   region of rl_line_buffer that contains the word to complete.  TEXT is
-   the word to complete.  We can use the entire contents of rl_line_buffer
-   in case we want to do some simple parsing.  Return the array of matches,
-   or NULL if there aren't any. */
+/* Attempt to complete on the contents of TEXT.  START and END
+   bound the region of rl_line_buffer that contains the word to
+   complete.  TEXT is the word to complete.  We can use the entire
+   contents of rl_line_buffer in case we want to do some simple
+   parsing.  Returnthe array of matches, or NULL if there aren't any. */
 char **
 fileman_completion (text, start, end)
-     char *text;
+     const char *text;
      int start, end;
 @{
   char **matches;
 
   matches = (char **)NULL;
 
   /* If this word is at the start of the line, then it is a command
      to complete.  Otherwise it is the name of a file in the current
      directory. */
   if (start == 0)
-    matches = completion_matches (text, command_generator);
+    matches = rl_completion_matches (text, command_generator);
 
   return (matches);
 @}
 
-/* Generator function for command completion.  STATE lets us know whether
-   to start from scratch; without any state (i.e. STATE == 0), then we
-   start at the top of the list. */
+/* Generator function for command completion.  STATE lets us
+   know whether to start from scratch; without any state
+   (i.e. STATE == 0), then we start at the top of the list. */
 char *
 command_generator (text, state)
-     char *text;
+     const char *text;
      int state;
 @{
   static int list_index, len;
   char *name;
 
-  /* If this is a new word to complete, initialize now.  This includes
-     saving the length of TEXT for efficiency, and initializing the index
-     variable to 0. */
+  /* If this is a new word to complete, initialize now.  This
+     includes saving the length of TEXT for efficiency, and
+     initializing the index variable to 0. */
   if (!state)
     @{
       list_index = 0;
       len = strlen (text);
     @}
 
-  /* Return the next name which partially matches from the command list. */
+  /* Return the next name which partially matches from the
+     command list. */
   while (name = commands[list_index].name)
     @{
       list_index++;
 
       if (strncmp (name, text, len) == 0)
         return (dupstr(name));
     @}
 
@@ -1490,28 +1949,29 @@ com_cd (arg)
 @}
 
 /* Print out the current working directory. */
 com_pwd (ignore)
      char *ignore;
 @{
   char dir[1024], *s;
 
-  s = getwd (dir);
+  s = getcwd (dir, sizeof(dir) - 1);
   if (s == 0)
     @{
       printf ("Error getting pwd: %s\n", dir);
       return 1;
     @}
 
   printf ("Current directory is %s\n", dir);
   return 0;
 @}
 
-/* The user wishes to quit using this program.  Just set DONE non-zero. */
+/* The user wishes to quit using this program.  Just set DONE
+   non-zero. */
 com_quit (arg)
      char *arg;
 @{
   done = 1;
   return (0);
 @}
 
 /* Function which tells you that you can't do this. */
diff --git a/readline/doc/rluser.texinfo b/readline/doc/rluser.texinfo
--- a/readline/doc/rluser.texinfo
+++ b/readline/doc/rluser.texinfo
@@ -2,20 +2,20 @@
 @setfilename rluser.info
 @comment %**end of header (This is for running Texinfo on a region.)
 @setchapternewpage odd
 
 @ignore
 This file documents the end user interface to the GNU command line
 editing features.  It is to be an appendix to manuals for programs which
 use these features.  There is a document entitled "readline.texinfo"
-which contains both end-user and programmer documentation for the GNU
-Readline Library.
+which contains both end-user and programmer documentation for the
+GNU Readline Library.
 
-Copyright (C) 1988, 1991, 1993, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-2000 Free Software Foundation, Inc.
 
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to process this file through Tex and print the
 results, provided the printed document carries copying permission notice
 identical to this one except for the removal of this paragraph (this
 paragraph not being relevant to the printed manual).
 
@@ -31,265 +31,311 @@ permission notice identical to this one.
 
 Permission is granted to copy and distribute translations of this manual
 into another language, under the above conditions for modified versions.
 @end ignore
 
 @comment If you are including this manual as an appendix, then set the
 @comment variable readline-appendix.
 
+@ifclear BashFeatures
+@defcodeindex bt
+@end ifclear
+
 @node Command Line Editing
 @chapter Command Line Editing
 
-This chapter describes the basic features of the @sc{GNU}
+This chapter describes the basic features of the @sc{gnu}
 command line editing interface.
+@ifset BashFeatures
+Command line editing is provided by the Readline library, which is
+used by several different programs, including Bash.
+@end ifset
 
 @menu
 * Introduction and Notation::	Notation used in this text.
 * Readline Interaction::	The minimum set of commands for editing a line.
 * Readline Init File::		Customizing Readline from a user's view.
 * Bindable Readline Commands::	A description of most of the Readline commands
 				available for binding
 * Readline vi Mode::		A short description of how to make Readline
 				behave like the vi editor.
+@ifset BashFeatures
+* Programmable Completion::	How to specify the possible completions for
+				a specific command.
+* Programmable Completion Builtins::	Builtin commands to specify how to
+				complete arguments for a particular command.
+@end ifset
 @end menu
 
 @node Introduction and Notation
 @section Introduction to Line Editing
 
 The following paragraphs describe the notation used to represent
 keystrokes.
 
-The text @key{C-k} is read as `Control-K' and describes the character
+The text @kbd{C-k} is read as `Control-K' and describes the character
 produced when the @key{k} key is pressed while the Control key
 is depressed.
 
-The text @key{M-k} is read as `Meta-K' and describes the character
-produced when the meta key (if you have one) is depressed, and the @key{k}
-key is pressed.  If you do not have a meta key, the identical keystroke
-can be generated by typing @key{ESC} @i{first}, and then typing @key{k}.
+The text @kbd{M-k} is read as `Meta-K' and describes the character
+produced when the Meta key (if you have one) is depressed, and the @key{k}
+key is pressed.
+The Meta key is labeled @key{ALT} on many keyboards.
+On keyboards with two keys labeled @key{ALT} (usually to either side of
+the space bar), the @key{ALT} on the left side is generally set to
+work as a Meta key.
+The @key{ALT} key on the right may also be configured to work as a
+Meta key or may be configured as some other modifier, such as a
+Compose key for typing accented characters.
+
+If you do not have a Meta or @key{ALT} key, or another key working as
+a Meta key, the identical keystroke can be generated by typing @key{ESC}
+@emph{first}, and then typing @key{k}.
 Either process is known as @dfn{metafying} the @key{k} key.
 
-The text @key{M-C-k} is read as `Meta-Control-k' and describes the
-character produced by @dfn{metafying} @key{C-k}.
+The text @kbd{M-C-k} is read as `Meta-Control-k' and describes the
+character produced by @dfn{metafying} @kbd{C-k}.
 
 In addition, several keys have their own names.  Specifically,
 @key{DEL}, @key{ESC}, @key{LFD}, @key{SPC}, @key{RET}, and @key{TAB} all
 stand for themselves when seen in this text, or in an init file
 (@pxref{Readline Init File}).
+If your keyboard lacks a @key{LFD} key, typing @key{C-j} will
+produce the desired character.
+The @key{RET} key may be labeled @key{Return} or @key{Enter} on
+some keyboards.
 
 @node Readline Interaction
 @section Readline Interaction
 @cindex interaction, readline
 
 Often during an interactive session you type in a long line of text,
 only to notice that the first word on the line is misspelled.  The
 Readline library gives you a set of commands for manipulating the text
 as you type it in, allowing you to just fix your typo, and not forcing
 you to retype the majority of the line.  Using these editing commands,
 you move the cursor to the place that needs correction, and delete or
 insert the text of the corrections.  Then, when you are satisfied with
-the line, you simply press @key{RETURN}.  You do not have to be at the
-end of the line to press @key{RETURN}; the entire line is accepted
+the line, you simply press @key{RET}.  You do not have to be at the
+end of the line to press @key{RET}; the entire line is accepted
 regardless of the location of the cursor within the line.
 
 @menu
 * Readline Bare Essentials::	The least you need to know about Readline.
 * Readline Movement Commands::	Moving about the input line.
 * Readline Killing Commands::	How to delete text, and how to get it back!
 * Readline Arguments::		Giving numeric arguments to commands.
 * Searching::			Searching through previous lines.
- @end menu
+@end menu
 
 @node Readline Bare Essentials
 @subsection Readline Bare Essentials
 @cindex notation, readline
 @cindex command editing
 @cindex editing command lines
 
 In order to enter characters into the line, simply type them.  The typed
 character appears where the cursor was, and then the cursor moves one
 space to the right.  If you mistype a character, you can use your
 erase character to back up and delete the mistyped character.
 
-Sometimes you may miss typing a character that you wanted to type, and
-not notice your error until you have typed several other characters.  In
-that case, you can type @key{C-b} to move the cursor to the left, and then
+Sometimes you may mistype a character, and
+not notice the error until you have typed several other characters.  In
+that case, you can type @kbd{C-b} to move the cursor to the left, and then
 correct your mistake.  Afterwards, you can move the cursor to the right
-with @key{C-f}.
+with @kbd{C-f}.
 
 When you add text in the middle of a line, you will notice that characters
 to the right of the cursor are `pushed over' to make room for the text
 that you have inserted.  Likewise, when you delete text behind the cursor,
 characters to the right of the cursor are `pulled back' to fill in the
-blank space created by the removal of the text.  A list of the basic bare
+blank space created by the removal of the text.  A list of the bare
 essentials for editing the text of an input line follows.
 
 @table @asis
-@item @key{C-b}
+@item @kbd{C-b}
 Move back one character.
-@item @key{C-f}
+@item @kbd{C-f}
 Move forward one character.
-@item @key{DEL}
+@item @key{DEL} or @key{Backspace}
 Delete the character to the left of the cursor.
-@item @key{C-d}
+@item @kbd{C-d}
 Delete the character underneath the cursor.
 @item @w{Printing characters}
 Insert the character into the line at the cursor.
-@item @key{C-_}
-Undo the last thing that you did.  You can undo all the way back to an
+@item @kbd{C-_} or @kbd{C-x C-u}
+Undo the last editing command.  You can undo all the way back to an
 empty line.
 @end table
 
+@noindent
+(Depending on your configuration, the @key{Backspace} key be set to
+delete the character to the left of the cursor and the @key{DEL} key set
+to delete the character underneath the cursor, like @kbd{C-d}, rather
+than the character to the left of the cursor.)
+
 @node Readline Movement Commands
 @subsection Readline Movement Commands
 
 
-The above table describes the most basic possible keystrokes that you need
+The above table describes the most basic keystrokes that you need
 in order to do editing of the input line.  For your convenience, many
-other commands have been added in addition to @key{C-b}, @key{C-f},
-@key{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
+other commands have been added in addition to @kbd{C-b}, @kbd{C-f},
+@kbd{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
 about the line.
 
-@table @key
+@table @kbd
 @item C-a
 Move to the start of the line.
 @item C-e
 Move to the end of the line.
 @item M-f
-Move forward a word.
+Move forward a word, where a word is composed of letters and digits.
 @item M-b
 Move backward a word.
 @item C-l
 Clear the screen, reprinting the current line at the top.
 @end table
 
-Notice how @key{C-f} moves forward a character, while @key{M-f} moves
+Notice how @kbd{C-f} moves forward a character, while @kbd{M-f} moves
 forward a word.  It is a loose convention that control keystrokes
 operate on characters while meta keystrokes operate on words.
 
 @node Readline Killing Commands
 @subsection Readline Killing Commands
 
 @cindex killing text
 @cindex yanking text
 
 @dfn{Killing} text means to delete the text from the line, but to save
 it away for later use, usually by @dfn{yanking} (re-inserting)
 it back into the line.
+(`Cut' and `paste' are more recent jargon for `kill' and `yank'.)
+
 If the description for a command says that it `kills' text, then you can
 be sure that you can get the text back in a different (or the same)
 place later.
 
 When you use a kill command, the text is saved in a @dfn{kill-ring}.
 Any number of consecutive kills save all of the killed text together, so
 that when you yank it back, you get it all.  The kill
 ring is not line specific; the text that you killed on a previously
 typed line is available to be yanked back later, when you are typing
 another line.
 @cindex kill ring
 
 Here is the list of commands for killing text.
 
-@table @key
+@table @kbd
 @item C-k
 Kill the text from the current cursor position to the end of the line.
 
 @item M-d
-Kill from the cursor to the end of the current word, or if between
+Kill from the cursor to the end of the current word, or, if between
 words, to the end of the next word.
+Word boundaries are the same as those used by @kbd{M-f}.
 
-@item M-DEL
-Kill from the cursor the start of the previous word, or if between
+@item M-@key{DEL}
+Kill from the cursor the start of the previous word, or, if between
 words, to the start of the previous word.
+Word boundaries are the same as those used by @kbd{M-b}.
 
 @item C-w
 Kill from the cursor to the previous whitespace.  This is different than
-@key{M-DEL} because the word boundaries differ.
+@kbd{M-@key{DEL}} because the word boundaries differ.
 
 @end table
 
-And, here is how to @dfn{yank} the text back into the line.  Yanking
+Here is how to @dfn{yank} the text back into the line.  Yanking
 means to copy the most-recently-killed text from the kill buffer.
 
-@table @key
+@table @kbd
 @item C-y
 Yank the most recently killed text back into the buffer at the cursor.
 
 @item M-y
 Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is @key{C-y} or @key{M-y}.
+the prior command is @kbd{C-y} or @kbd{M-y}.
 @end table
 
 @node Readline Arguments
 @subsection Readline Arguments
 
 You can pass numeric arguments to Readline commands.  Sometimes the
 argument acts as a repeat count, other times it is the @i{sign} of the
 argument that is significant.  If you pass a negative argument to a
 command which normally acts in a forward direction, that command will
 act in a backward direction.  For example, to kill text back to the
-start of the line, you might type @w{@kbd{M-- C-k}}.
+start of the line, you might type @samp{M-- C-k}.
 
 The general way to pass numeric arguments to a command is to type meta
-digits before the command.  If the first `digit' you type is a minus
-sign (@key{-}), then the sign of the argument will be negative.  Once
+digits before the command.  If the first `digit' typed is a minus
+sign (@samp{-}), then the sign of the argument will be negative.  Once
 you have typed one meta digit to get the argument started, you can type
 the remainder of the digits, and then the command.  For example, to give
-the @key{C-d} command an argument of 10, you could type @samp{M-1 0 C-d}.
+the @kbd{C-d} command an argument of 10, you could type @samp{M-1 0 C-d},
+which will delete the next ten characters on the input line.
 
 @node Searching
 @subsection Searching for Commands in the History
 
 Readline provides commands for searching through the command history
 @ifset BashFeatures
 (@pxref{Bash History Facilities})
 @end ifset
 for lines containing a specified string.
-There are two search modes:  @var{incremental} and @var{non-incremental}.
+There are two search modes:  @dfn{incremental} and @dfn{non-incremental}.
 
 Incremental searches begin before the user has finished typing the
 search string.
-As each character of the search string is typed, readline displays
+As each character of the search string is typed, Readline displays
 the next entry from the history matching the string typed so far.
 An incremental search requires only as many characters as needed to
 find the desired history entry.
-The Escape character is used to terminate an incremental search.
-Control-J will also terminate the search.
-Control-G will abort an incremental search and restore the original
-line.
+To search backward in the history for a particular string, type
+@kbd{C-r}.  Typing @kbd{C-s} searches forward through the history.
+The characters present in the value of the @code{isearch-terminators} variable
+are used to terminate an incremental search.
+If that variable has not been assigned a value, the @key{ESC} and
+@kbd{C-J} characters will terminate an incremental search.
+@kbd{C-g} will abort an incremental search and restore the original line.
 When the search is terminated, the history entry containing the
 search string becomes the current line.
-To find other matching entries in the history list, type Control-S or
-Control-R as appropriate.
+
+To find other matching entries in the history list, type @kbd{C-r} or
+@kbd{C-s} as appropriate.
 This will search backward or forward in the history for the next
 entry matching the search string typed so far.
-Any other key sequence bound to a readline command will terminate
+Any other key sequence bound to a Readline command will terminate
 the search and execute that command.
-For instance, a @code{newline} will terminate the search and accept
+For instance, a @key{RET} will terminate the search and accept
 the line, thereby executing the command from the history list.
+A movement command will terminate the search, make the last line found
+the current line, and begin editing.
 
 Non-incremental searches read the entire search string before starting
 to search for matching history lines.  The search string may be
-typed by the user or part of the contents of the current line.
+typed by the user or be part of the contents of the current line.
 
 @node Readline Init File
 @section Readline Init File
 @cindex initialization file, readline
 
-Although the Readline library comes with a set of @code{emacs}-like
-keybindings installed by default,
-it is possible that you would like to use a different set
-of keybindings.  You can customize programs that use Readline by putting
-commands in an @dfn{inputrc} file in your home directory.  The name of this
+Although the Readline library comes with a set of Emacs-like
+keybindings installed by default, it is possible to use a different set
+of keybindings.
+Any user can customize programs that use Readline by putting
+commands in an @dfn{inputrc} file, conventionally in his home directory.
+The name of this
 @ifset BashFeatures
-file is taken from the value of the shell variable @code{INPUTRC}.  If
+file is taken from the value of the shell variable @env{INPUTRC}.  If
 @end ifset
 @ifclear BashFeatures
-file is taken from the value of the environment variable @code{INPUTRC}.  If
+file is taken from the value of the environment variable @env{INPUTRC}.  If
 @end ifclear
 that variable is unset, the default is @file{~/.inputrc}.
 
 When a program which uses the Readline library starts up, the
 init file is read, and the key bindings are set.
 
 In addition, the @code{C-x C-r} command re-reads this init file, thus
 incorporating any changes that you might have made to it.
@@ -309,26 +355,33 @@ There are only a few basic constructs al
 Readline init file.  Blank lines are ignored.
 Lines beginning with a @samp{#} are comments.
 Lines beginning with a @samp{$} indicate conditional
 constructs (@pxref{Conditional Init Constructs}).  Other lines
 denote variable settings and key bindings.
 
 @table @asis
 @item Variable Settings
-You can change the state of a few variables in Readline by
-using the @code{set} command within the init file.  Here is how you
-would specify that you wish to use @code{vi} line editing commands:
+You can modify the run-time behavior of Readline by
+altering the values of variables in Readline
+using the @code{set} command within the init file.  Here is how to
+change from the default Emacs-like key binding to use
+@code{vi} line editing commands:
 
 @example
 set editing-mode vi
 @end example
 
-Right now, there are only a few variables which can be set;
-so few, in fact, that we just list them here:
+@ifset BashFeatures
+The @w{@code{bind -V}} command lists the current Readline variable names
+and values.  @xref{Bash Builtins}.
+@end ifset
+
+A great deal of run-time behavior is changeable with the following
+variables.
 
 @table @code
 
 @item bell-style
 @vindex bell-style
 Controls what happens when Readline wants to ring the terminal bell.
 If set to @samp{none}, Readline never rings the bell.  If set to
 @samp{visible}, Readline uses a visible bell if one is available.
@@ -336,105 +389,124 @@ If set to @samp{audible} (the default), 
 the terminal's bell.
 
 @item comment-begin
 @vindex comment-begin
 The string to insert at the beginning of the line when the
 @code{insert-comment} command is executed.  The default value
 is @code{"#"}.
 
+@item completion-ignore-case
+If set to @samp{on}, Readline performs filename matching and completion
+in a case-insensitive fashion.
+The default value is @samp{off}.
+
 @item completion-query-items
 @vindex completion-query-items
 The number of possible completions that determines when the user is
 asked whether he wants to see the list of possibilities.  If the
 number of possible completions is greater than this value,
 Readline will ask the user whether or not he wishes to view
-them; otherwise, they are simply listed.  The default limit is
-@code{100}.
+them; otherwise, they are simply listed.
+This variable must be set to an integer value greater than or equal to 0.
+The default limit is @code{100}.
 
 @item convert-meta
 @vindex convert-meta
 If set to @samp{on}, Readline will convert characters with the
-eigth bit set to an ASCII key sequence by stripping the eigth
-bit and prepending an @key{ESC} character, converting them to a
+eighth bit set to an @sc{ascii} key sequence by stripping the eighth
+bit and prefixing an @key{ESC} character, converting them to a
 meta-prefixed key sequence.  The default value is @samp{on}.
 
 @item disable-completion
 @vindex disable-completion
-If set to @samp{On}, readline will inhibit word completion.
+If set to @samp{On}, Readline will inhibit word completion.
 Completion  characters will be inserted into the line as if they had
 been mapped to @code{self-insert}.  The default is @samp{off}.
 
 @item editing-mode
 @vindex editing-mode
-The @code{editing-mode} variable controls which editing mode you are
-using.  By default, Readline starts up in Emacs editing mode, where
-the keystrokes are most similar to Emacs.  This variable can be
+The @code{editing-mode} variable controls which default set of
+key bindings is used.  By default, Readline starts up in Emacs editing
+mode, where the keystrokes are most similar to Emacs.  This variable can be
 set to either @samp{emacs} or @samp{vi}.
 
 @item enable-keypad
 @vindex enable-keypad
-When set to @samp{on}, readline will try to enable the application
+When set to @samp{on}, Readline will try to enable the application
 keypad when it is called.  Some systems need this to enable the
 arrow keys.  The default is @samp{off}.
 
 @item expand-tilde
 @vindex expand-tilde
 If set to @samp{on}, tilde expansion is performed when Readline
 attempts word completion.  The default is @samp{off}.
 
 @item horizontal-scroll-mode
 @vindex horizontal-scroll-mode
 This variable can be set to either @samp{on} or @samp{off}.  Setting it
-to @samp{on} means that the text of the lines that you edit will scroll
+to @samp{on} means that the text of the lines being edited will scroll
 horizontally on a single screen line when they are longer than the width
 of the screen, instead of wrapping onto a new screen line.  By default,
 this variable is set to @samp{off}.
 
+@item input-meta
+@vindex input-meta
+@vindex meta-flag
+If set to @samp{on}, Readline will enable eight-bit input (it
+will not clear the eighth bit in the characters it reads),
+regardless of what the terminal claims it can support.  The
+default value is @samp{off}.  The name @code{meta-flag} is a
+synonym for this variable.
+
+@item isearch-terminators
+@vindex isearch-terminators
+The string of characters that should terminate an incremental search without
+subsequently executing the character as a command (@pxref{Searching}).
+If this variable has not been given a value, the characters @key{ESC} and
+@kbd{C-J} will terminate an incremental search.
+
 @item keymap
 @vindex keymap
 Sets Readline's idea of the current keymap for key binding commands.
 Acceptable @code{keymap} names are
 @code{emacs},
 @code{emacs-standard},
 @code{emacs-meta},
 @code{emacs-ctlx},
 @code{vi},
+@code{vi-move},
 @code{vi-command}, and
 @code{vi-insert}.
 @code{vi} is equivalent to @code{vi-command}; @code{emacs} is
 equivalent to @code{emacs-standard}.  The default value is @code{emacs}.
 The value of the @code{editing-mode} variable also affects the
 default keymap.
 
 @item mark-directories
 If set to @samp{on}, completed directory names have a slash
 appended.  The default is @samp{on}.
 
 @item mark-modified-lines
 @vindex mark-modified-lines
-This variable, when set to @samp{on}, says to display an asterisk
-(@samp{*}) at the start of history lines which have been modified.
+This variable, when set to @samp{on}, causes Readline to display an
+asterisk (@samp{*}) at the start of history lines which have been modified.
 This variable is @samp{off} by default.
 
-@item input-meta
-@vindex input-meta
-@vindex meta-flag
-If set to @samp{on}, Readline will enable eight-bit input (it
-will not strip the eighth bit from the characters it reads),
-regardless of what the terminal claims it can support.  The
-default value is @samp{off}.  The name @code{meta-flag} is a
-synonym for this variable.
-
 @item output-meta
 @vindex output-meta
 If set to @samp{on}, Readline will display characters with the
 eighth bit set directly rather than as a meta-prefixed escape
 sequence.  The default is @samp{off}.
 
+@item print-completions-horizontally
+If set to @samp{on}, Readline will display completions with matches
+sorted horizontally in alphabetical order, rather than down the screen.
+The default is @samp{off}.
+
 @item show-all-if-ambiguous
 @vindex show-all-if-ambiguous
 This alters the default behavior of the completion functions.  If
 set to @samp{on}, 
 words which have more than one possible completion cause the
 matches to be listed immediately instead of ringing the bell.
 The default value is @samp{off}.
 
@@ -443,97 +515,153 @@ The default value is @samp{off}.
 If set to @samp{on}, a character denoting a file's type
 is appended to the filename when listing possible
 completions.  The default is @samp{off}.
 
 @end table
 
 @item Key Bindings
 The syntax for controlling key bindings in the init file is
-simple.  First you have to know the name of the command that you
-want to change.  The following pages contain tables of the command name,
-the default keybinding, and a short description of what the command
-does.
+simple.  First you need to find the name of the command that you
+want to change.  The following sections contain tables of the command
+name, the default keybinding, if any, and a short description of what
+the command does.
 
-Once you know the name of the command, simply place the name of the key
+Once you know the name of the command, simply place on a line
+in the init file the name of the key
 you wish to bind the command to, a colon, and then the name of the
-command on a line in the init file.  The name of the key
-can be expressed in different ways, depending on which is most
-comfortable for you.
+command.  The name of the key
+can be expressed in different ways, depending on what you find most
+comfortable.
+
+@ifset BashFeatures
+The @w{@code{bind -p}} command displays Readline function names and
+bindings in a format that can put directly into an initialization file.
+@xref{Bash Builtins}.
+@end ifset
 
 @table @asis
 @item @w{@var{keyname}: @var{function-name} or @var{macro}}
 @var{keyname} is the name of a key spelled out in English.  For example:
 @example
 Control-u: universal-argument
 Meta-Rubout: backward-kill-word
 Control-o: "> output"
 @end example
 
-In the above example, @samp{C-u} is bound to the function
-@code{universal-argument}, and @samp{C-o} is bound to run the macro
+In the above example, @kbd{C-u} is bound to the function
+@code{universal-argument},
+@kbd{M-DEL} is bound to the function @code{backward-kill-word}, and
+@kbd{C-o} is bound to run the macro
 expressed on the right hand side (that is, to insert the text
 @samp{> output} into the line).
 
+A number of symbolic character names are recognized while
+processing this key binding syntax:
+@var{DEL},
+@var{ESC},
+@var{ESCAPE},
+@var{LFD},
+@var{NEWLINE},
+@var{RET},
+@var{RETURN},
+@var{RUBOUT},
+@var{SPACE},
+@var{SPC},
+and
+@var{TAB}.
+
 @item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
 @var{keyseq} differs from @var{keyname} above in that strings
 denoting an entire key sequence can be specified, by placing
-the key sequence in double quotes.  Some GNU Emacs style key
+the key sequence in double quotes.  Some @sc{gnu} Emacs style key
 escapes can be used, as in the following example, but the
 special character names are not recognized.
 
 @example
 "\C-u": universal-argument
 "\C-x\C-r": re-read-init-file
 "\e[11~": "Function Key 1"
 @end example
 
-In the above example, @samp{C-u} is bound to the function
+In the above example, @kbd{C-u} is again bound to the function
 @code{universal-argument} (just as it was in the first example),
-@samp{C-x C-r} is bound to the function @code{re-read-init-file}, and
-@samp{ESC [ 1 1 ~} is bound to insert the text @samp{Function Key 1}.
-The following escape sequences are available when specifying key
-sequences:
+@samp{@kbd{C-x} @kbd{C-r}} is bound to the function @code{re-read-init-file},
+and @samp{@key{ESC} @key{[} @key{1} @key{1} @key{~}} is bound to insert
+the text @samp{Function Key 1}.
+
+@end table
+
+The following @sc{gnu} Emacs style escape sequences are available when
+specifying key sequences:
 
 @table @code
 @item @kbd{\C-}
 control prefix
 @item @kbd{\M-}
 meta prefix
 @item @kbd{\e}
 an escape character
 @item @kbd{\\}
 backslash
 @item @kbd{\"}
-@key{"}
+@key{"}, a double quotation mark
 @item @kbd{\'}
-@key{'}
+@key{'}, a single quote or apostrophe
 @end table
 
-When entering the text of a macro, single or double quotes should
-be used to indicate a macro definition.  Unquoted text
-is assumed to be a function name.  Backslash
-will quote any character in the macro text, including @samp{"}
-and @samp{'}.
-For example, the following binding will make @samp{C-x \}
+In addition to the @sc{gnu} Emacs style escape sequences, a second
+set of backslash escapes is available:
+
+@table @code
+@item \a
+alert (bell)
+@item \b
+backspace
+@item \d
+delete
+@item \f
+form feed
+@item \n
+newline
+@item \r
+carriage return
+@item \t
+horizontal tab
+@item \v
+vertical tab
+@item \@var{nnn}
+the character whose @sc{ascii} code is the octal value @var{nnn}
+(one to three digits)
+@item \x@var{nnn}
+the character whose @sc{ascii} code is the hexadecimal value @var{nnn}
+(one to three digits)
+@end table
+
+When entering the text of a macro, single or double quotes must
+be used to indicate a macro definition.
+Unquoted text is assumed to be a function name.
+In the macro body, the backslash escapes described above are expanded.
+Backslash will quote any other character in the macro text,
+including @samp{"} and @samp{'}.
+For example, the following binding will make @samp{@kbd{C-x} \}
 insert a single @samp{\} into the line:
 @example
 "\C-x\\": "\\"
 @end example
 
 @end table
-@end table
 
 @node Conditional Init Constructs
 @subsection Conditional Init Constructs
 
 Readline implements a facility similar in spirit to the conditional
 compilation features of the C preprocessor which allows key
 bindings and variable settings to be performed as the result
-of tests.  There are three parser directives used.
+of tests.  There are four parser directives used.
 
 @table @code
 @item $if
 The @code{$if} construct allows bindings to be made based on the
 editing mode, the terminal being used, or the application using
 Readline.  The text of the test extends to the end of the line;
 no characters are required to isolate it.
 
@@ -545,18 +673,18 @@ This may be used in conjunction
 with the @samp{set keymap} command, for instance, to set bindings in
 the @code{emacs-standard} and @code{emacs-ctlx} keymaps only if
 Readline is starting out in @code{emacs} mode.
 
 @item term
 The @code{term=} form may be used to include terminal-specific
 key bindings, perhaps to bind the key sequences output by the
 terminal's function keys.  The word on the right side of the
-@samp{=} is tested against the full name of the terminal and the
-portion of the terminal name before the first @samp{-}.  This
+@samp{=} is tested against both the full name of the terminal and
+the portion of the terminal name before the first @samp{-}.  This
 allows @code{sun} to match both @code{sun} and @code{sun-cmd},
 for instance.
 
 @item application
 The @var{application} construct is used to include
 application-specific settings.  Each program using the Readline
 library sets the @var{application name}, and you can test for it. 
 This could be used to bind key sequences to functions useful for
@@ -566,39 +694,51 @@ key sequence that quotes the current or 
 $if Bash
 # Quote the current or previous word
 "\C-xq": "\eb\"\ef\""
 $endif
 @end example
 @end table
 
 @item $endif
-This command, as you saw in the previous example, terminates an
+This command, as seen in the previous example, terminates an
 @code{$if} command.
 
 @item $else
 Commands in this branch of the @code{$if} directive are executed if
 the test fails.
+
+@item $include
+This directive takes a single filename as an argument and reads commands
+and bindings from that file.
+@example
+$include /etc/inputrc
+@end example
 @end table
 
 @node Sample Init File
 @subsection Sample Init File
 
-Here is an example of an inputrc file.  This illustrates key
+Here is an example of an @var{inputrc} file.  This illustrates key
 binding, variable assignment, and conditional syntax.
 
 @example
 @page
 # This file controls the behaviour of line input editing for
 # programs that use the Gnu Readline library.  Existing programs
 # include FTP, Bash, and Gdb.
 #
 # You can re-read the inputrc file with C-x C-r.
 # Lines beginning with '#' are comments.
 #
+# First, include any systemwide bindings and variable assignments from
+# /etc/Inputrc
+$include /etc/Inputrc
+
+#
 # Set various bindings for emacs mode.
 
 set editing-mode emacs 
 
 $if mode=emacs
 
 Meta-Control-h:	backward-kill-word	Text after the function name is ignored
 
@@ -692,16 +832,27 @@ set completion-query-items 150
 * Numeric Arguments::		Specifying numeric arguments, repeat counts.
 * Commands For Completion::	Getting Readline to do the typing for you.
 * Keyboard Macros::		Saving and re-executing typed characters
 * Miscellaneous Commands::	Other miscellaneous commands.
 @end menu
 
 This section describes Readline commands that may be bound to key
 sequences.
+@ifset BashFeatures
+You can list your key bindings by executing
+@w{@code{bind -P}} or, for a more terse format, suitable for an
+@var{inputrc} file, @w{@code{bind -p}}.  (@xref{Bash Builtins}.)
+@end ifset
+
+Command names without an accompanying key sequence are unbound by default.
+In the following descriptions, @dfn{point} refers to the current cursor
+position, and @dfn{mark} refers to a cursor position saved by the
+@code{set-mark} command.
+The text between the point and mark is referred to as the @dfn{region}.
 
 @node Commands For Moving
 @subsection Commands For Moving
 @ftable @code
 @item beginning-of-line (C-a)
 Move to the start of the current line.
 
 @item end-of-line (C-e)
@@ -713,56 +864,62 @@ Move forward a character.
 @item backward-char (C-b)
 Move back a character.
 
 @item forward-word (M-f)
 Move forward to the end of the next word.  Words are composed of
 letters and digits.
 
 @item backward-word (M-b)
-Move back to the start of this, or the previous, word.  Words are
+Move back to the start of the current or previous word.  Words are
 composed of letters and digits.
 
 @item clear-screen (C-l)
 Clear the screen and redraw the current line,
 leaving the current line at the top of the screen.
 
 @item redraw-current-line ()
 Refresh the current line.  By default, this is unbound.
 
 @end ftable
 
 @node Commands For History
 @subsection Commands For Manipulating The History
 
 @ftable @code
-@item accept-line (Newline, Return)
+@item accept-line (Newline or Return)
 @ifset BashFeatures
-Accept the line regardless of where the cursor is.  If this line is
+Accept the line regardless of where the cursor is.
+If this line is
 non-empty, add it to the history list according to the setting of
-the @code{HISTCONTROL} variable.  If this line was a history
-line, then restore the history line to its original state.
+the @env{HISTCONTROL} and @env{HISTIGNORE} variables.
+If this line is a modified history line, then restore the history line
+to its original state.
 @end ifset
 @ifclear BashFeatures
-Accept the line regardless of where the cursor is.  If this line is
-non-empty, add it to the history list.  If this line was a history
-line, then restore the history line to its original state.
+Accept the line regardless of where the cursor is.
+If this line is
+non-empty, it may be added to the history list for future recall with
+@code{add_history()}.
+If this line is a modified history line, then restore the history line
+to its original state.
 @end ifclear
 
 @item previous-history (C-p)
 Move `up' through the history list.
 
 @item next-history (C-n)
 Move `down' through the history list.
 
 @item beginning-of-history (M-<)
 Move to the first line in the history.
 
 @item end-of-history (M->)
-Move to the end of the input history, i.e., the line you are entering.
+Move to the end of the input history, i.e., the line currently
+being entered.
 
 @item reverse-search-history (C-r)
 Search backward starting at the current line and moving `up' through
 the history as necessary.  This is an incremental search.
 
 @item forward-search-history (C-s)
 Search forward starting at the current line and moving `down' through
 the the history as necessary.  This is an incremental search.
@@ -774,156 +931,166 @@ for a string supplied by the user.
 
 @item non-incremental-forward-search-history (M-n)
 Search forward starting at the current line and moving `down'
 through the the history as necessary using a non-incremental search
 for a string supplied by the user.
 
 @item history-search-forward ()
 Search forward through the history for the string of characters
-between the start of the current line and the current cursor
-position (the `point').  This is a non-incremental search.  By
-default, this command is unbound.
+between the start of the current line and the point.
+This is a non-incremental search.
+By default, this command is unbound.
 
 @item history-search-backward ()
 Search backward through the history for the string of characters
 between the start of the current line and the point.  This
 is a non-incremental search.  By default, this command is unbound.
 
 @item yank-nth-arg (M-C-y)
 Insert the first argument to the previous command (usually
 the second word on the previous line).  With an argument @var{n},
 insert the @var{n}th word from the previous command (the words
 in the previous command begin with word 0).  A negative argument
 inserts the @var{n}th word from the end of the previous command.
 
-@item yank-last-arg (M-., M-_)
+@item yank-last-arg (M-. or M-_)
 Insert last argument to the previous command (the last word of the
 previous history entry).  With an
 argument, behave exactly like @code{yank-nth-arg}.
+Successive calls to @code{yank-last-arg} move back through the history
+list, inserting the last argument of each line in turn.
 
 @end ftable
 
 @node Commands For Text
 @subsection Commands For Changing Text
 
 @ftable @code
 @item delete-char (C-d)
 Delete the character under the cursor.  If the cursor is at the
 beginning of the line, there are no characters in the line, and
-the last character typed was not @kbd{C-d}, then return @code{EOF}.
+the last character typed was not bound to @code{delete-char}, then
+return @sc{eof}.
 
 @item backward-delete-char (Rubout)
-Delete the character behind the cursor.  A numeric arg says to kill
-the characters instead of deleting them.
+Delete the character behind the cursor.  A numeric argument means
+to kill the characters instead of deleting them.
+
+@item forward-backward-delete-char ()
+Delete the character under the cursor, unless the cursor is at the
+end of the line, in which case the character behind the cursor is
+deleted.  By default, this is not bound to a key.
 
-@item quoted-insert (C-q, C-v)
-Add the next character that you type to the line verbatim.  This is
-how to insert key sequences like @key{C-q}, for example.
+@item quoted-insert (C-q or C-v)
+Add the next character typed to the line verbatim.  This is
+how to insert key sequences like @kbd{C-q}, for example.
 
-@item tab-insert (M-TAB)
+@ifclear BashFeatures
+@item tab-insert (M-@key{TAB})
 Insert a tab character.
+@end ifclear
 
-@item self-insert (a, b, A, 1, !, ...)
+@item self-insert (a, b, A, 1, !, @dots{})
 Insert yourself.
 
 @item transpose-chars (C-t)
 Drag the character before the cursor forward over
 the character at the cursor, moving the
 cursor forward as well.  If the insertion point
 is at the end of the line, then this
 transposes the last two characters of the line.
-Negative argumentss don't work.
+Negative arguments have no effect.
 
 @item transpose-words (M-t)
-Drag the word behind the cursor past the word in front of the cursor
-moving the cursor over that word as well.
+Drag the word before point past the word after point,
+moving point past that word as well.
 
 @item upcase-word (M-u)
 Uppercase the current (or following) word.  With a negative argument,
-do the previous word, but do not move the cursor.
+uppercase the previous word, but do not move the cursor.
 
 @item downcase-word (M-l)
 Lowercase the current (or following) word.  With a negative argument,
-do the previous word, but do not move the cursor.
+lowercase the previous word, but do not move the cursor.
 
 @item capitalize-word (M-c)
 Capitalize the current (or following) word.  With a negative argument,
-do the previous word, but do not move the cursor.
+capitalize the previous word, but do not move the cursor.
 
 @end ftable
 
 @node Commands For Killing
 @subsection Killing And Yanking
 
 @ftable @code
 
 @item kill-line (C-k)
-Kill the text from the current cursor position to the end of the line.
+Kill the text from point to the end of the line.
 
 @item backward-kill-line (C-x Rubout)
 Kill backward to the beginning of the line.
 
 @item unix-line-discard (C-u)
 Kill backward from the cursor to the beginning of the current line.
-Save the killed text on the kill-ring.
 
 @item kill-whole-line ()
-Kill all characters on the current line, no matter where the
-cursor is.  By default, this is unbound.
+Kill all characters on the current line, no matter point is.
+By default, this is unbound.
 
 @item kill-word (M-d)
-Kill from the cursor to the end of the current word, or if between
-words, to the end of the next word.  Word boundaries are the same
-as @code{forward-word}.
+Kill from point to the end of the current word, or if between
+words, to the end of the next word.
+Word boundaries are the same as @code{forward-word}.
 
-@item backward-kill-word (M-DEL)
-Kill the word behind the cursor.  Word boundaries are the same
-as @code{backward-word}.
+@item backward-kill-word (M-@key{DEL})
+Kill the word behind point.
+Word boundaries are the same as @code{backward-word}.
 
 @item unix-word-rubout (C-w)
-Kill the word behind the cursor, using white space as a word
-boundary.  The killed text is saved on the kill-ring.
+Kill the word behind point, using white space as a word boundary.
+The killed text is saved on the kill-ring.
 
 @item delete-horizontal-space ()
 Delete all spaces and tabs around point.  By default, this is unbound.
 
 @item kill-region ()
-Kill the text between the point and the @emph{mark} (saved
-cursor position.  This text is referred to as the @var{region}.
+Kill the text in the current region.
 By default, this command is unbound.
 
 @item copy-region-as-kill ()
-Copy the text in the region to the kill buffer, so you can yank it
+Copy the text in the region to the kill buffer, so it can be yanked
 right away.  By default, this command is unbound.
 
 @item copy-backward-word ()
 Copy the word before point to the kill buffer.
+The word boundaries are the same as @code{backward-word}.
 By default, this command is unbound.
 
 @item copy-forward-word ()
 Copy the word following point to the kill buffer.
+The word boundaries are the same as @code{forward-word}.
 By default, this command is unbound.
 
 @item yank (C-y)
 Yank the top of the kill ring into the buffer at the current
 cursor position.
 
 @item yank-pop (M-y)
 Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is yank or yank-pop.
+the prior command is @code{yank} or @code{yank-pop}.
 @end ftable
 
 @node Numeric Arguments
 @subsection Specifying Numeric Arguments
 @ftable @code
 
-@item digit-argument (M-0, M-1, ... M--)
+@item digit-argument (@kbd{M-0}, @kbd{M-1}, @dots{} @kbd{M--})
 Add this digit to the argument already accumulating, or start a new
-argument.  @key{M--} starts a negative argument.
+argument.  @kbd{M--} starts a negative argument.
 
 @item universal-argument ()
 This is another way to specify an argument.
 If this command is followed by one or more digits, optionally with a
 leading minus sign, those digits define the argument.
 If the command is followed by digits, executing @code{universal-argument}
 again ends the numeric argument, but is otherwise ignored.
 As a special case, if this command is immediately followed by a
@@ -934,38 +1101,57 @@ first time makes the argument count four
 argument count sixteen, and so on.
 By default, this is not bound to a key.
 @end ftable
 
 @node Commands For Completion
 @subsection Letting Readline Type For You
 
 @ftable @code
-@item complete (TAB)
-Attempt to do completion on the text before the cursor.  This is
-application-specific.  Generally, if you are typing a filename
-argument, you can do filename completion; if you are typing a command,
-you can do command completion, if you are typing in a symbol to GDB, you
-can do symbol name completion, if you are typing in a variable to Bash,
-you can do variable name completion, and so on.
+@item complete (@key{TAB})
+Attempt to perform completion on the text before point.
+The actual completion performed is application-specific.
 @ifset BashFeatures
 Bash attempts completion treating the text as a variable (if the
 text begins with @samp{$}), username (if the text begins with
 @samp{~}), hostname (if the text begins with @samp{@@}), or
 command (including aliases and functions) in turn.  If none 
 of these produces a match, filename completion is attempted.
 @end ifset
+@ifclear BashFeatures
+The default is filename completion.
+@end ifclear
 
 @item possible-completions (M-?)
 List the possible completions of the text before the cursor.
 
 @item insert-completions (M-*)
 Insert all completions of the text before point that would have
 been generated by @code{possible-completions}.
 
+@item menu-complete ()
+Similar to @code{complete}, but replaces the word to be completed
+with a single match from the list of possible completions.
+Repeated execution of @code{menu-complete} steps through the list
+of possible completions, inserting each match in turn.
+At the end of the list of completions, the bell is rung and the
+original text is restored.
+An argument of @var{n} moves @var{n} positions forward in the list
+of matches; a negative argument may be used to move backward
+through the list.
+This command is intended to be bound to @key{TAB}, but is unbound
+by default.
+
+@item delete-char-or-list ()
+Deletes the character under the cursor if not at the beginning or
+end of the line (like @code{delete-char}).
+If at the end of the line, behaves identically to
+@code{possible-completions}.
+This command is unbound by default.
+
 @ifset BashFeatures
 @item complete-filename (M-/)
 Attempt filename completion on the text before point.
 
 @item possible-filename-completions (C-x /)
 List the possible completions of the text before point,
 treating it as a filename.
 
@@ -992,30 +1178,30 @@ it as a hostname.
 @item possible-hostname-completions (C-x @@)
 List the possible completions of the text before point,
 treating it as a hostname.
 
 @item complete-command (M-!)
 Attempt completion on the text before point, treating
 it as a command name.  Command completion attempts to
 match the text against aliases, reserved words, shell
-functions, builtins, and finally executable filenames,
+functions, shell builtins, and finally executable filenames,
 in that order.
 
 @item possible-command-completions (C-x !)
 List the possible completions of the text before point,
 treating it as a command name.
 
-@item dynamic-complete-history (M-TAB)
+@item dynamic-complete-history (M-@key{TAB})
 Attempt completion on the text before point, comparing
 the text against lines from the history list for possible
 completion matches.
 
 @item complete-into-braces (M-@{)
-Perform filename completion and return the list of possible completions
+Perform filename completion and insert the list of possible completions
 enclosed within braces so the list is available to the shell
 (@pxref{Brace Expansion}).
 
 @end ifset
 @end ftable
 
 @node Keyboard Macros
 @subsection Keyboard Macros
@@ -1034,41 +1220,46 @@ in the macro appear as if typed at the k
 
 @end ftable
 
 @node Miscellaneous Commands
 @subsection Some Miscellaneous Commands
 @ftable @code
 
 @item re-read-init-file (C-x C-r)
-Read in the contents of the inputrc file, and incorporate
+Read in the contents of the @var{inputrc} file, and incorporate
 any bindings or variable assignments found there.
 
 @item abort (C-g)
 Abort the current editing command and
 ring the terminal's bell (subject to the setting of
 @code{bell-style}).
 
 @item do-uppercase-version (M-a, M-b, M-@var{x}, @dots{})
 If the metafied character @var{x} is lowercase, run the command
 that is bound to the corresponding uppercase character.
 
-@item prefix-meta (ESC)
-Make the next character that you type be metafied.  This is for people
-without a meta key.  Typing @samp{ESC f} is equivalent to typing
-@samp{M-f}.
+@item prefix-meta (@key{ESC})
+Make the next character typed be metafied.  This is for keyboards
+without a meta key.  Typing @samp{@key{ESC} f} is equivalent to typing
+@kbd{M-f}.
 
-@item undo (C-_, C-x C-u)
+@item undo (C-_ or C-x C-u)
 Incremental undo, separately remembered for each line.
 
 @item revert-line (M-r)
-Undo all changes made to this line.  This is like typing the @code{undo}
+Undo all changes made to this line.  This is like executing the @code{undo}
 command enough times to get back to the beginning.
 
+@ifset BashFeatures
+@item tilde-expand (M-&)
+@end ifset
+@ifclear BashFeatures
 @item tilde-expand (M-~)
+@end ifclear
 Perform tilde expansion on the current word.
 
 @item set-mark (C-@@)
 Set the mark to the current point.  If a
 numeric argument is supplied, the mark is set to that position.
 
 @item exchange-point-and-mark (C-x C-x)
 Swap the point with the mark.  The current cursor position is set to
@@ -1083,65 +1274,69 @@ A character is read and point is moved t
 of that character.  A negative count searches for subsequent
 occurrences.
 
 @item insert-comment (M-#)
 The value of the @code{comment-begin}
 variable is inserted at the beginning of the current line,
 and the line is accepted as if a newline had been typed.
 @ifset BashFeatures
-This makes the current line a shell comment.
+The default value of @code{comment-begin} causes this command
+to make the current line a shell comment.
 @end ifset
 
 @item dump-functions ()
 Print all of the functions and their key bindings to the
-readline output stream.  If a numeric argument is supplied,
+Readline output stream.  If a numeric argument is supplied,
 the output is formatted in such a way that it can be made part
 of an @var{inputrc} file.  This command is unbound by default.
 
 @item dump-variables ()
 Print all of the settable variables and their values to the
-readline output stream.  If a numeric argument is supplied,
+Readline output stream.  If a numeric argument is supplied,
 the output is formatted in such a way that it can be made part
 of an @var{inputrc} file.  This command is unbound by default.
 
 @item dump-macros ()
-Print all of the readline key sequences bound to macros and the
-strings they ouput.  If a numeric argument is supplied,
+Print all of the Readline key sequences bound to macros and the
+strings they output.  If a numeric argument is supplied,
 the output is formatted in such a way that it can be made part
 of an @var{inputrc} file.  This command is unbound by default.
 
 @ifset BashFeatures
 @item glob-expand-word (C-x *)
 The word before point is treated as a pattern for pathname expansion,
 and the list of matching file names is inserted, replacing the word.
 
 @item glob-list-expansions (C-x g)
 The list of expansions that would have been generated by
-@code{glob-expand-word}
-is inserted into the line, replacing the word before point.
+@code{glob-expand-word} is displayed, and the line is redrawn.
 
 @item display-shell-version (C-x C-v)
 Display version information about the current instance of Bash.
 
 @item shell-expand-line (M-C-e)
-Expand the line the way the shell does when it reads it.  This
-performs alias and history expansion as well as all of the shell
-word expansions.
+Expand the line as the shell does.
+This performs alias and history expansion as well as all of the shell
+word expansions (@pxref{Shell Expansions}).
 
 @item history-expand-line (M-^)
 Perform history expansion on the current line.
 
-@item alias-expand-line
+@item magic-space ()
+Perform history expansion on the current line and insert a space
+(@pxref{History Interaction}).
+
+@item alias-expand-line ()
 Perform alias expansion on the current line (@pxref{Aliases}).
 
-@item history-and-alias-expand-line
+@item history-and-alias-expand-line ()
 Perform history and alias expansion on the current line.
 
-@item insert-last-argument (M-., M-_)
+@item insert-last-argument (M-. or M-_)
 A synonym for @code{yank-last-arg}.
 
 @item operate-and-get-next (C-o)
 Accept the current line for execution and fetch the next line
 relative to the current line from the history for editing.  Any
 argument is ignored.
 
 @item emacs-editing-mode (C-e)
@@ -1154,27 +1349,335 @@ been executed.
 @end ftable
 
 @node Readline vi Mode
 @section Readline vi Mode
 
 While the Readline library does not have a full set of @code{vi}
 editing functions, it does contain enough to allow simple editing
 of the line.  The Readline @code{vi} mode behaves as specified in
-the @sc{POSIX} 1003.2 standard.
+the @sc{posix} 1003.2 standard.
 
 @ifset BashFeatures
 In order to switch interactively between @code{emacs} and @code{vi}
 editing modes, use the @samp{set -o emacs} and @samp{set -o vi}
 commands (@pxref{The Set Builtin}).
 @end ifset
 @ifclear BashFeatures
 In order to switch interactively between @code{emacs} and @code{vi}
-editing modes, use the command M-C-j (toggle-editing-mode).
+editing modes, use the command @kbd{M-C-j} (toggle-editing-mode).
 @end ifclear
 The Readline default is @code{emacs} mode.
 
 When you enter a line in @code{vi} mode, you are already placed in
 `insertion' mode, as if you had typed an @samp{i}.  Pressing @key{ESC}
 switches you into `command' mode, where you can edit the text of the
 line with the standard @code{vi} movement keys, move to previous
 history lines with @samp{k} and subsequent lines with @samp{j}, and
 so forth.
+
+@ifset BashFeatures
+@node Programmable Completion
+@section Programmable Completion
+@cindex programmable completion
+
+When word completion is attempted for an argument to a command for
+which a completion specification (a @var{compspec}) has been defined
+using the @code{complete} builtin (@pxref{Programmable Completion Builtins}),
+the programmable completion facilities are invoked. 
+
+First, the command name is identified.
+If a compspec has been defined for that command, the
+compspec is used to generate the list of possible completions for the word.
+If the command word is a full pathname, a compspec for the full
+pathname is searched for first.
+If no compspec is found for the full pathname, an attempt is made to
+find a compspec for the portion following the final slash.
+
+Once a compspec has been found, it is used to generate the list of
+matching words.
+If a compspec is not found, the default Bash completion
+described above (@pxref{Commands For Completion}) is performed.
+
+First, the actions specified by the compspec are used.
+Only matches which are prefixed by the word being completed are
+returned.
+When the @option{-f} or @option{-d} option is used for filename or
+directory name completion, the shell variable @env{FIGNORE} is
+used to filter the matches.
+@xref{Bash Variables}, for a description of @env{FIGNORE}.
+
+Any completions specified by a filename expansion pattern to the
+@option{-G} option are generated next.
+The words generated by the pattern need not match the word being completed.
+The @env{GLOBIGNORE} shell variable is not used to filter the matches,
+but the @env{FIGNORE} shell variable is used.
+
+Next, the string specified as the argument to the @option{-W} option
+is considered.
+The string is first split using the characters in the @env{IFS}
+special variable as delimiters.
+Shell quoting is honored.
+Each word is then expanded using
+brace expansion, tilde expansion, parameter and variable expansion,
+command substitution, arithmetic expansion, and pathname expansion,
+as described above (@pxref{Shell Expansions}).
+The results are split using the rules described above
+(@pxref{Word Splitting}).
+The results of the expansion are prefix-matched against the word being
+completed, and the matching words become the possible completions.
+
+After these matches have been generated, any shell function or command
+specified with the @option{-F} and @option{-C} options is invoked.
+When the command or function is invoked, the @env{COMP_LINE} and
+@env{COMP_POINT} variables are assigned values as described above
+(@pxref{Bash Variables}).
+If a shell function is being invoked, the @env{COMP_WORDS} and
+@env{COMP_CWORD} variables are also set.
+When the function or command is invoked, the first argument is the
+name of the command whose arguments are being completed, the
+second argument is the word being completed, and the third argument
+is the word preceding the word being completed on the current command line.
+No filtering of the generated completions against the word being completed
+is performed; the function or command has complete freedom in generating
+the matches.
+
+Any function specified with @option{-F} is invoked first.
+The function may use any of the shell facilities, including the
+@code{compgen} builtin described below
+(@pxref{Programmable Completion Builtins}), to generate the matches.
+It must put the possible completions in the @env{COMPREPLY} array
+variable.
+
+Next, any command specified with the @option{-C} option is invoked
+in an environment equivalent to command substitution.
+It should print a list of completions, one per line, to
+the standard output.
+Backslash may be used to escape a newline, if necessary.
+
+After all of the possible completions are generated, any filter
+specified with the @option{-X} option is applied to the list.
+The filter is a pattern as used for pathname expansion; a @samp{&}
+in the pattern is replaced with the text of the word being completed.
+A literal @samp{&} may be escaped with a backslash; the backslash
+is removed before attempting a match.
+Any completion that matches the pattern will be removed from the list.
+A leading @samp{!} negates the pattern; in this case any completion
+not matching the pattern will be removed.
+
+Finally, any prefix and suffix specified with the @option{-P} and @option{-S}
+options are added to each member of the completion list, and the result is
+returned to the Readline completion code as the list of possible
+completions.
+
+If the previously-applied actions do not generate any matches, and the
+@option{-o dirnames} option was supplied to @code{complete} when the
+compspec was defined, directory name completion is attempted. 
+
+By default, if a compspec is found, whatever it generates is returned to
+the completion code as the full set of possible completions.
+The default Bash completions are not attempted, and the Readline default
+of filename completion is disabled.
+If the @option{-o default} option was supplied to @code{complete} when the
+compspec was defined, Readline's default completion will be performed
+if the compspec generates no matches.
+
+@node Programmable Completion Builtins
+@section Programmable Completion Builtins
+@cindex completion builtins
+
+Two builtin commands are available to manipulate the programmable completion
+facilities.
+
+@table @code
+@item compgen
+@btindex compgen
+@example
+@code{compgen [@var{option}] [@var{word}]}
+@end example
+
+Generate possible completion matches for @var{word} according to
+the @var{option}s, which may be any option accepted by the
+@code{complete}
+builtin with the exception of @option{-p} and @option{-r}, and write
+the matches to the standard output.
+When using the @option{-F} or @option{-C} options, the various shell variables
+set by the programmable completion facilities, while available, will not
+have useful values.
+
+The matches will be generated in the same way as if the programmable
+completion code had generated them directly from a completion specification
+with the same flags.
+If @var{word} is specified, only those completions matching @var{word}
+will be displayed.
+
+The return value is true unless an invalid option is supplied, or no
+matches were generated.
+
+@item complete
+@btindex complete
+@example
+@code{complete [-abcdefjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
+[-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
+[-C @var{command}] @var{name} [@var{name} @dots{}]}
+@code{complete -pr [@var{name} @dots{}]}
+@end example
+
+Specify how arguments to each @var{name} should be completed.
+If the @option{-p} option is supplied, or if no options are supplied, existing
+completion specifications are printed in a way that allows them to be
+reused as input.
+The @option{-r} option removes a completion specification for
+each @var{name}, or, if no @var{name}s are supplied, all
+completion specifications.
+
+The process of applying these completion specifications when word completion
+is attempted is described above (@pxref{Programmable Completion}).
+
+Other options, if specified, have the following meanings.
+The arguments to the @option{-G}, @option{-W}, and @option{-X} options
+(and, if necessary, the @option{-P} and @option{-S} options)
+should be quoted to protect them from expansion before the
+@code{complete} builtin is invoked.
+
+
+@table @code
+@item -o @var{comp-option}
+The @var{comp-option} controls several aspects of the compspec's behavior
+beyond the simple generation of completions.
+@var{comp-option} may be one of: 
+
+@table @code
+
+@item default
+Use readline's default completion if the compspec generates no matches.
+
+@item dirnames
+Perform directory name completion if the compspec generates no matches.
+
+@item filenames
+Tell Readline that the compspec generates filenames, so it can perform any
+filename\-specific processing (like adding a slash to directory names or
+suppressing trailing spaces).  This option is intended to be used with
+shell functions specified with @option{-F}.
+@end table
+
+@item -A @var{action}
+The @var{action} may be one of the following to generate a list of possible
+completions:
+
+@table @code
+@item alias
+Alias names.  May also be specified as @option{-a}.
+
+@item arrayvar
+Array variable names.
+
+@item binding
+Readline key binding names (@pxref{Bindable Readline Commands}).
+
+@item builtin
+Names of shell builtin commands.  May also be specified as @option{-b}.
+
+@item command
+Command names.  May also be specified as @option{-c}.
+
+@item directory
+Directory names.  May also be specified as @option{-d}.
+
+@item disabled
+Names of disabled shell builtins.
+
+@item enabled
+Names of enabled shell builtins.
+
+@item export
+Names of exported shell variables.  May also be specified as @option{-e}.
+
+@item file
+File names.  May also be specified as @option{-f}.
+
+@item function
+Names of shell functions.
+
+@item helptopic
+Help topics as accepted by the @code{help} builtin (@pxref{Bash Builtins}).
+
+@item hostname
+Hostnames, as taken from the file specified by the
+@env{HOSTFILE} shell variable (@pxref{Bash Variables}).
+
+@item job
+Job names, if job control is active.  May also be specified as @option{-j}.
+
+@item keyword
+Shell reserved words.  May also be specified as @option{-k}.
+
+@item running
+Names of running jobs, if job control is active.
+
+@item setopt
+Valid arguments for the @option{-o} option to the @code{set} builtin
+(@pxref{The Set Builtin}).
+
+@item shopt
+Shell option names as accepted by the @code{shopt} builtin
+(@pxref{Bash Builtins}).
+
+@item signal
+Signal names.
+
+@item stopped
+Names of stopped jobs, if job control is active.
+
+@item user
+User names.  May also be specified as @option{-u}.
+
+@item variable
+Names of all shell variables.  May also be specified as @option{-v}.
+@end table
+
+@item -G @var{globpat}
+The filename expansion pattern @var{globpat} is expanded to generate
+the possible completions.
+
+@item -W @var{wordlist}
+The @var{wordlist} is split using the characters in the
+@env{IFS} special variable as delimiters, and each resultant word
+is expanded.
+The possible completions are the members of the resultant list which
+match the word being completed.
+
+@item -C @var{command}
+@var{command} is executed in a subshell environment, and its output is
+used as the possible completions.
+
+@item -F @var{function}
+The shell function @var{function} is executed in the current shell
+environment.
+When it finishes, the possible completions are retrieved from the value
+of the @env{COMPREPLY} array variable.
+
+@item -X @var{filterpat}
+@var{filterpat} is a pattern as used for filename expansion.
+It is applied to the list of possible completions generated by the
+preceding options and arguments, and each completion matching
+@var{filterpat} is removed from the list.
+A leading @samp{!} in @var{filterpat} negates the pattern; in this
+case, any completion not matching @var{filterpat} is removed.
+
+@item -P @var{prefix}
+@var{prefix} is added at the beginning of each possible completion
+after all other options have been applied.
+
+@item -S @var{suffix}
+@var{suffix} is appended to each possible completion
+after all other options have been applied.
+@end table
+
+The return value is true unless an invalid option is supplied, an option
+other than @option{-p} or @option{-r} is supplied without a @var{name}
+argument, an attempt is made to remove a completion specification for
+a @var{name} for which no specification exists, or
+an error occurs adding a completion specification.
+
+@end table
+@end ifset
diff --git a/readline/doc/texi2html b/readline/doc/texi2html
--- a/readline/doc/texi2html
+++ b/readline/doc/texi2html
@@ -4,17 +4,17 @@
 #+##############################################################################
 #                                                                              #
 # File: texi2html                                                              #
 #                                                                              #
 # Description: Program to transform most Texinfo documents to HTML             #
 #                                                                              #
 #-##############################################################################
 
-# @(#)texi2html	1.51 09/10/96	Written (mainly) by Lionel Cons, Lionel.Cons@cern.ch
+# @(#)texi2html	1.52 01/05/98	Written (mainly) by Lionel Cons, Lionel.Cons@cern.ch
 
 # The man page for this program is included at the end of this file and can be
 # viewed using the command 'nroff -man texi2html'.
 # Please read the copyright at the end of the man page.
 
 #+++############################################################################
 #                                                                              #
 # Constants                                                                    #
@@ -24,26 +24,26 @@
 $DEBUG_TOC   =  1;
 $DEBUG_INDEX =  2;
 $DEBUG_BIB   =  4;
 $DEBUG_GLOSS =  8;
 $DEBUG_DEF   = 16;
 $DEBUG_HTML  = 32;
 $DEBUG_USER  = 64;
 
-$BIBRE = '\[[\w\/]+\]';			# RE for a bibliography reference
+$BIBRE = '\[[\w\/-]+\]';		# RE for a bibliography reference
 $FILERE = '[\/\w.+-]+';			# RE for a file name
 $VARRE = '[^\s\{\}]+';			# RE for a variable name
 $NODERE = '[^@{}:\'`",]+';		# RE for a node name
 $NODESRE = '[^@{}:\'`"]+';		# RE for a list of node names
 $XREFRE = '[^@{}]+';			# RE for a xref (should use NODERE)
 
 $ERROR = "***";			        # prefix for errors and warnings
-$THISPROG = "texi2html 1.51";			# program name and version
-$HOMEPAGE = "http://wwwcn.cern.ch/dci/texi2html/"; # program home page
+$THISPROG = "texi2html 1.52";			# program name and version
+$HOMEPAGE = "http://wwwinfo.cern.ch/dis/texi2html/"; # program home page
 $TODAY = &pretty_date;			# like "20 September 1993"
 $SPLITTAG = "<!-- SPLIT HERE -->\n";	# tag to know where to split
 $PROTECTTAG = "_ThisIsProtected_";	# tag to recognize protected sections
 $html2_doctype = '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">';
 
 #
 # language dependent constants
 #
@@ -124,16 +124,17 @@
 	       " ", " ",
 	       "\n", "\n",
 	       "|", "",
 	       # spacing commands
 	       ":", "",
 	       "!", "!",
 	       "?", "?",
 	       ".", ".",
+	       "-", "",
 	       );
 
 #
 # texinfo "things" (@foo{}) to HTML ones
 #
 %things_map = (
 	       'TeX', 'TeX',
 	       'br', '<P>',		# paragraph break
@@ -154,29 +155,33 @@
 # texinfo styles (@foo{bar}) to HTML ones
 #
 %style_map = (
 	      'asis', '',
 	      'b', 'B',
 	      'cite', 'CITE',
 	      'code', 'CODE',
 	      'ctrl', '&do_ctrl',	# special case
-	      'dfn', 'STRONG',		# DFN tag is illegal in the standard
+	      'dfn', 'EM',		# DFN tag is illegal in the standard
 	      'dmn', '',		# useless
+	      'email', '&do_email',     # insert a clickable email address
 	      'emph', 'EM',
 	      'file', '"TT',		# will put quotes, cf. &apply_style
 	      'i', 'I',
 	      'kbd', 'KBD',
 	      'key', 'KBD',
+	      'math', 'EM',
 	      'r', '',			# unsupported
 	      'samp', '"SAMP',		# will put quotes, cf. &apply_style
 	      'sc', '&do_sc',		# special case
 	      'strong', 'STRONG',
 	      't', 'TT',
 	      'titlefont', '',		# useless
+	      'uref', '&do_uref',       # insert a clickable URL
+	      'url', '&do_url',         # insert a clickable URL
 	      'var', 'VAR',
 	      'w', '',			# unsupported
 	      );
 
 #
 # texinfo format (@foo/@end foo) to HTML ones
 #
 %format_map = (
@@ -265,29 +270,32 @@
 	    'everyfooting', 1,
 	    'evenheading', 1,
 	    'evenfooting', 1,
 	    'oddheading', 1,
 	    'oddfooting', 1,
 	    'smallbook', 1,
 	    'vskip', 1,
 	    'filbreak', 1,
+	    'paragraphindent', 1,
 	    # unsupported formats
 	    'cartouche', 1,
 	    'end cartouche', 1,
 	    'group', 1,
 	    'end group', 1,
 	    );
 
 #+++############################################################################
 #                                                                              #
 # Argument parsing, initialisation                                             #
 #                                                                              #
 #---############################################################################
 
+%value = ();				# hold texinfo variables, see also -D
+
 $use_bibliography = 1;
 $use_acc = 0;
 $debug = 0;
 $doctype = '';
 $check = 0;
 $expandinfo = 0;
 $use_glossary = 0;
 $invisible_mark = '';
@@ -301,37 +309,39 @@
 $verbose = 0;
 $usage = <<EOT;
 This is $THISPROG
 To convert a Texinfo file to HMTL: $0 [options] file
   where options can be:
     -expandinfo    : use \@ifinfo sections, not \@iftex
     -glossary      : handle a glossary
     -invisible name: use 'name' as an invisible anchor
+    -Dname         : define name like with \@set
     -I dir         : search also for files in 'dir'
     -menu          : handle menus
     -monolithic    : output only one file including ToC
     -number        : number sections
     -split_chapter : split on main sections
     -split_node    : split on nodes
     -usage         : print usage instructions
     -verbose       : verbose output
 To check converted files: $0 -check [-verbose] files
 EOT
 
-while ($#ARGV >= 0 && $ARGV[0] =~ /^-/) {
+while (@ARGV && $ARGV[0] =~ /^-/) {
     $_ = shift(@ARGV);
     if (/^-acc$/)            { $use_acc = 1; next; }
     if (/^-d(ebug)?(\d+)?$/) { $debug = $2 || shift(@ARGV); next; }
     if (/^-doctype$/)        { $doctype = shift(@ARGV); next; }
     if (/^-c(heck)?$/)       { $check = 1; next; }
     if (/^-e(xpandinfo)?$/)  { $expandinfo = 1; next; }
     if (/^-g(lossary)?$/)    { $use_glossary = 1; next; }
     if (/^-i(nvisible)?$/)   { $invisible_mark = shift(@ARGV); next; }
     if (/^-iso$/)            { $use_iso = 1; next; }
+    if (/^-D(.+)?$/)         { $value{$1 || shift(@ARGV)} = 1; next; }
     if (/^-I(.+)?$/)         { push(@include_dirs, $1 || shift(@ARGV)); next; }
     if (/^-m(enu)?$/)        { $show_menu = 1; next; }
     if (/^-mono(lithic)?$/)  { $monolithic = 1; next; }
     if (/^-n(umber)?$/)      { $number_sections = 1; next; }
     if (/^-s(plit)?_?(n(ode)?|c(hapter)?)?$/) {
 	if ($2 =~ /^n/) {
 	    $split_node = 1;
 	} else {
@@ -378,19 +388,18 @@ if ($monolithic) {
 } else {
     $docu_toc  = "${docu_name}_toc.html";  # document's table of contents
     $docu_foot = "${docu_name}_foot.html"; # document's footnotes
 }
 
 #
 # variables
 #
-%value = ();				# hold texinfo variables
 $value{'html'} = 1;			# predefine html (the output format)
-$value{'texi2html'} = '1.51';		# predefine texi2html (the translator)
+$value{'texi2html'} = '1.52';		# predefine texi2html (the translator)
 # _foo: internal to track @foo
 foreach ('_author', '_title', '_subtitle',
 	 '_settitle', '_setfilename') {
     $value{$_} = '';		        # prevent -w warnings
 }
 %node2sec = ();				# node to section name
 %node2href = ();			# node to HREF
 %bib2href = ();				# bibliography reference to HREF
@@ -448,17 +457,17 @@ print "# reading from $docu\n" if $verbo
 #---############################################################################
 
 @lines = ();				# whole document
 @toc_lines = ();			# table of contents
 $toplevel = 0;			        # top level seen in hierarchy
 $curlevel = 0;				# current level in TOC
 $node = '';				# current node name
 $in_table = 0;				# am I inside a table
-$table_type = '';			# type of table ('', 'f', 'v')
+$table_type = '';			# type of table ('', 'f', 'v', 'multi')
 @tables = ();			        # nested table support
 $in_bibliography = 0;			# am I inside a bibliography
 $in_glossary = 0;			# am I inside a glossary
 $in_top = 0;				# am I inside the top node
 $in_pre = 0;				# am I inside a preformatted section
 $in_list = 0;				# am I inside a list
 $in_html = 0;				# am I inside an HTML section
 $first_line = 1;		        # is it the first line
@@ -549,40 +558,37 @@ while ($_ = &next_line) {
 	}
     }
     #
     # try to remove inlined comments
     # syntax from tex-mode.el comment-start-skip
     #
     s/((^|[^\@])(\@\@)*)\@c(omment)? .*/$1/;
     # non-@ substitutions cf. texinfmt.el
-    s/``/\"/g;
-    s/''/\"/g;
-    s/([\w ])---([\w ])/$1--$2/g;
+    unless ($in_pre) {
+	s/``/\"/g;
+	s/''/\"/g;
+	s/([\w ])---([\w ])/$1--$2/g;
+    }
     #
     # analyze the tag
     #
     if ($tag) {
 	# skip lines
 	&skip_until($tag), next if $tag eq 'ignore';
 	if ($expandinfo) {
 	    &skip_until($tag), next if $tag eq 'iftex';
 	} else {
 	    &skip_until($tag), next if $tag eq 'ifinfo';
 	}
 	&skip_until($tag), next if $tag eq 'tex';
 	# handle special tables
-	if ($tag eq 'table') {
-	    $table_type = '';
-	} elsif ($tag eq 'ftable') {
+	if ($tag =~ /^(|f|v|multi)table$/) {
+	    $table_type = $1;
 	    $tag = 'table';
-	    $table_type = 'f';
-	} elsif ($tag eq 'vtable') {
-	    $tag = 'table';
-	    $table_type = 'v';
 	}
 	# special cases
 	if ($tag eq 'top' || ($tag eq 'node' && /^\@node\s+top\s*,/i)) {
 	    $in_top = 1;
 	    @lines = (); # ignore all lines before top (title page garbage)
 	    next;
 	} elsif ($tag eq 'node') {
 	    $in_top = 0;
@@ -642,21 +648,26 @@ while ($_ = &next_line) {
 	} elsif ($format_map{$tag}) {
 	    $in_pre = 1 if $format_map{$tag} eq 'PRE';
 	    &html_push_if($format_map{$tag});
 	    push(@lines, &html_debug("\n", __LINE__));
 	    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;
 	    push(@lines, &debug("<$format_map{$tag}>\n", __LINE__));
 	    next;
 	} elsif ($tag eq 'table') {
-	    if (/^\@[fv]?table\s+\@(\w+)\s*$/) {
-		$in_table = $1;
+	    if (/^\@(|f|v|multi)table\s+\@(\w+)/) {
+		$in_table = $2;
 		unshift(@tables, join($;, $table_type, $in_table));
-		push(@lines, &debug("<DL COMPACT>\n", __LINE__));
-		&html_push_if('DL');
+		if ($table_type eq "multi") {
+		    push(@lines, &debug("<TABLE BORDER>\n", __LINE__));
+		    &html_push_if('TABLE');
+		} else {
+		    push(@lines, &debug("<DL COMPACT>\n", __LINE__));
+		    &html_push_if('DL');
+		}
 		push(@lines, &html_debug("\n", __LINE__));
 	    } else {
 		warn "$ERROR Bad table line: $_";
 	    }
 	    next;
 	} elsif ($tag eq 'synindex' || $tag eq 'syncodeindex') {
 	    if (/^\@$tag\s+(\w)\w\s+(\w)\w\s*$/) {
 		eval("*${1}index = *${2}index");
@@ -771,28 +782,39 @@ while ($_ = &next_line) {
     } elsif ($end_tag) {
 	if ($format_map{$end_tag}) {
 	    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';
 	    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;
 	    &html_pop_if('LI', 'P');
 	    &html_pop_if();
 	    push(@lines, &debug("</$format_map{$end_tag}>\n", __LINE__));
 	    push(@lines, &html_debug("\n", __LINE__));
-	} elsif ($end_tag eq 'table' ||
-		 $end_tag eq 'ftable' ||
-		 $end_tag eq 'vtable') {
-	    shift(@tables);
+	} elsif ($end_tag =~ /^(|f|v|multi)table$/) {
+	    unless (@tables) {
+		warn "$ERROR \@end $end_tag without \@*table\n";
+		next;
+	    }
+	    ($table_type, $in_table) = split($;, shift(@tables));
+	    unless ($1 eq $table_type) {
+		warn "$ERROR \@end $end_tag without matching \@$end_tag\n";
+		next;
+	    }
+	    if ($table_type eq "multi") {
+		push(@lines, "</TR></TABLE>\n");
+		&html_pop_if('TR');
+	    } else {
+		push(@lines, "</DL>\n");
+		&html_pop_if('DD');
+	    }
+	    &html_pop_if();
 	    if (@tables) {
 		($table_type, $in_table) = split($;, $tables[0]);
 	    } else {
 		$in_table = 0;
 	    }
-	    push(@lines, "</DL>\n");
-	    &html_pop_if('DD');
-	    &html_pop_if();
 	} elsif (defined($def_map{$end_tag})) {
  	    push(@lines, &debug("</DL>\n", __LINE__));
 	} elsif ($end_tag eq 'menu') {
 	    &html_pop_if();
 	    push(@lines, $_); # must keep it for pass 2
 	}
 	next;
     }
@@ -981,26 +1003,35 @@ EOC
 		    } else {
 			push(@lines, &debug("<DT>\@$in_table\{$what\}\n", __LINE__));
 		    }
 		    push(@lines, "<DD>");
 		    &html_push('DD') unless $html_element eq 'DD';
 		    if ($table_type) { # add also an index
 			unshift(@input_spool, "\@${table_type}index $what\n");
 		    }
+		} elsif ($html_element eq 'TABLE') {
+		    push(@lines, &debug("<TR><TD>$what</TD>\n", __LINE__));
+		    &html_push('TR');
+		} elsif ($html_element eq 'TR') {
+		    push(@lines, &debug("</TR>\n", __LINE__));
+		    push(@lines, &debug("<TR><TD>$what</TD>\n", __LINE__));
 		} else {
 		    push(@lines, &debug("<LI>$what\n", __LINE__));
 		    &html_push('LI') unless $html_element eq 'LI';
 		}
 		push(@lines, &html_debug("\n", __LINE__));
 		if ($deferred_ref) {
 		    push(@lines, &debug("$deferred_ref\n", __LINE__));
 		    $deferred_ref = '';
 		}
 		next;
+	    } elsif (/^\@tab\s+(.*)$/) {
+		push(@lines, "<TD>$1</TD>\n");
+		next;
 	    }
 	}
     }
     # paragraph separator
     if ($_ eq "\n") {
 	next if $#lines >= 0 && $lines[$#lines] eq "\n";
 	if ($html_element eq 'P') {
 	    push(@lines, "\n");
@@ -1083,23 +1114,35 @@ while (@lines) {
 	    1 while s/<(\w+)>(.*)<\/\1>/$2/;     # remove HTML tags
 	    $_ = &unprotect_html($_);
 	    &unprotect_texi;
 	    tr/A-Z/a-z/; # lowercase
 	    $key2alpha{$key} = $_;
 	    print "# index $key sorted as $_\n"
 		if $key ne $_ && $debug & $DEBUG_INDEX;
 	}
+	push(@lines2, "Jump to:\n");
+	$last_letter = undef;
+	foreach $key (sort byalpha @keys) {
+	    $letter = substr($key2alpha{$key}, 0, 1);
+	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
+	    if (!defined($last_letter) || $letter ne $last_letter) {
+		push(@lines2, "-\n") if defined($last_letter);
+		push(@lines2, "<A HREF=\"#$index\_$letter\">" . &protect_html($letter) . "</A>\n");
+		$last_letter = $letter;
+	    }
+	}
+	push(@lines2, "<P>\n");
 	$last_letter = undef;
 	foreach $key (sort byalpha @keys) {
 	    $letter = substr($key2alpha{$key}, 0, 1);
 	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
 	    if (!defined($last_letter) || $letter ne $last_letter) {
 		push(@lines2, "</DIR>\n") if defined($last_letter);
-		push(@lines2, "<H2>" . &protect_html($letter) . "</H2>\n");
+		push(@lines2, "<H2><A NAME=\"$index\_$letter\">" . &protect_html($letter) . "</A></H2>\n");
 		push(@lines2, "<DIR>\n");
 		$last_letter = $letter;
 	    }
 	    @refs = ();
 	    foreach (split(/$;/, $ary{$key})) {
 		push(@refs, &anchor('', $_, $key, 0));
 	    }
 	    push(@lines2, "<LI>" . join(", ", @refs) . "\n");
@@ -1652,18 +1695,34 @@ sub menu_entry {
 	push(@lines2, "<LI>" . &anchor('', $href, $entry) . "$descr\n");
     } else {
 	warn "$ERROR Undefined node ($node): $_";
     }
 }
 
 sub do_ctrl { "^$_[0]" }
 
+sub do_email {
+    local($addr, $text) = split(/,\s*/, $_[0]);
+
+    $text = $addr unless $text;
+    &anchor('', "mailto:$addr", $text);
+}
+
 sub do_sc { "\U$_[0]\E" }
 
+sub do_uref {
+    local($url, $text) = split(/,\s*/, $_[0]);
+
+    $text = $url unless $text;
+    &anchor('', $url, $text);
+}
+
+sub do_url { &anchor('', $_[0], $_[0]) }
+
 sub apply_style {
     local($texi_style, $text) = @_;
     local($style);
 
     $style = $style_map{$texi_style};
     if (defined($style)) { # known style
 	if ($style =~ /^\"/) { # add quotes
 	    $style = $';
@@ -1817,17 +1876,17 @@ sub print_footer {
 EOT
 }
 
 sub print_toplevel_footer {
     &print_ruler;
     print FILE <<EOT;
 This document was generated on $TODAY using the
 <A HREF=\"$HOMEPAGE\">texi2html</A>
-translator version 1.51.</P>
+translator version 1.52.</P>
 EOT
     &print_footer;
 }
 
 sub protect_texi {
     # protect @ { } ` '
     s/\@\@/$;0/go;
     s/\@\{/$;1/go;
@@ -1874,17 +1933,17 @@ sub byalpha {
 	# These next few lines are legal in both Perl and nroff.
 
 .00 ;			# finish .ig
  
 'di			\" finish diversion--previous line must be blank
 .nr nl 0-1		\" fake up transition to first page again
 .nr % 0			\" start at page 1
 '; __END__ ############# From here on it's a standard manual page ############
-.TH TEXI2HTML 1 "09/10/96"
+.TH TEXI2HTML 1 "01/05/98"
 .AT 3
 .SH NAME
 texi2html \- a Texinfo to HTML converter
 .SH SYNOPSIS
 .B texi2html [options] file
 .PP
 .B texi2html -check [-verbose] files
 .SH DESCRIPTION
@@ -1919,18 +1978,19 @@ to find the Texinfo commands that have b
 .B \-expandinfo
 Expand @ifinfo sections, not @iftex ones.
 .TP
 .B \-glossary
 Use the section named 'Glossary' to build a list of terms and put links in the HTML
 document from each term toward its definition.
 .TP
 .B \-invisible \fIname\fP
-Use \fIname\fP to create invisible destination anchors for index links. This is a workaround
-for a known bug of many WWW browsers, including xmosaic.
+Use \fIname\fP to create invisible destination anchors for index links
+(you can for instance use the invisible.xbm file shipped with this program).
+This is a workaround for a known bug of many WWW browsers, including netscape.
 .TP
 .B \-I \fIdir\fP
 Look also in \fIdir\fP to find included files.
 .TP
 .B \-menu
 Show the Texinfo menus; by default they are ignored.
 .TP
 .B \-monolithic
@@ -1980,31 +2040,31 @@ When used with the
 .B \-monolithic
 option, it creates only one file:
 .B foo.html
 .SH VARIABLES
 .I texi2html
 predefines the following variables: \fBhtml\fP, \fBtexi2html\fP.
 .SH ADDITIONAL COMMANDS
 .I texi2html
-implements the following non-Texinfo commands:
+implements the following non-Texinfo commands (maybe they are in Texinfo now...):
 .TP 16
 .B @ifhtml
 This indicates the start of an HTML section, this section will passed through
-without any modofication.
+without any modification.
 .TP
 .B @end ifhtml
-This indcates the end of an HTML section.
+This indicates the end of an HTML section.
 .SH VERSION
-This is \fItexi2html\fP version 1.51, 09/10/96.
+This is \fItexi2html\fP version 1.52, 01/05/98.
 .PP
 The latest version of \fItexi2html\fP can be found in WWW, cf. URL
-http://wwwcn.cern.ch/dci/texi2html/
+http://wwwinfo.cern.ch/dis/texi2html/
 .SH AUTHOR
-The main author is Lionel Cons, CERN CN/DCI/UWS, Lionel.Cons@cern.ch.
+The main author is Lionel Cons, CERN IT/DIS/OSE, Lionel.Cons@cern.ch.
 Many other people around the net contributed to this program.
 .SH COPYRIGHT
 This program is the intellectual property of the European
 Laboratory for Particle Physics (known as CERN). No guarantee whatsoever is
 provided by CERN. No liability whatsoever is accepted for any loss or damage
 of any kind resulting from any defect or inaccuracy in this information or
 code.
 .PP
diff --git a/readline/doc/texinfo.tex b/readline/doc/texinfo.tex
--- a/readline/doc/texinfo.tex
+++ b/readline/doc/texinfo.tex
@@ -1,205 +1,290 @@
-%% TeX macros to handle texinfo files
-
-%   Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 1994 Free Software Foundation, Inc.
-
-%This texinfo.tex file is free software; you can redistribute it and/or
-%modify it under the terms of the GNU General Public License as
-%published by the Free Software Foundation; either version 2, or (at
-%your option) any later version.
-
-%This texinfo.tex file is distributed in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-%General Public License for more details.
-
-%You should have received a copy of the GNU General Public License
-%along with this texinfo.tex file; see the file COPYING.  If not, write
-%to the Free Software Foundation, 59 Temple Place, Suite 330, Boston,
-%MA 02111 USA.
-
-
-%In other words, you are welcome to use, share and improve this program.
-%You are forbidden to forbid anyone else to use, share and improve
-%what you give them.   Help stamp out software-hoarding!
-
-
-% Send bug reports to bug-texinfo@gnu.org.
-% Please include a *precise* test case in each bug report.
-
-
-% Make it possible to create a .fmt file just by loading this file:
-% if the underlying format is not loaded, start by loading it now.
-% Added by gildea November 1993.
+% texinfo.tex -- TeX macros to handle Texinfo files.
+%
+% Load plain if necessary, i.e., if running under initex.
 \expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
-
-% This automatically updates the version number based on RCS.
-\def\deftexinfoversion$#1: #2 ${\def\texinfoversion{#2}}
-\deftexinfoversion$Revision: 1.3 $
-\message{Loading texinfo package [Version \texinfoversion]:}
+%
+\def\texinfoversion{1999-09-25.10}
+%
+% Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99
+% Free Software Foundation, Inc.
+%
+% This texinfo.tex file is free software; you can redistribute it and/or
+% modify it under the terms of the GNU General Public License as
+% published by the Free Software Foundation; either version 2, or (at
+% your option) any later version.
+%
+% This texinfo.tex file is distributed in the hope that it will be
+% useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+% of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+% General Public License for more details.
+%
+% You should have received a copy of the GNU General Public License
+% along with this texinfo.tex file; see the file COPYING.  If not, write
+% to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+% Boston, MA 02111-1307, USA.
+%
+% In other words, you are welcome to use, share and improve this program.
+% You are forbidden to forbid anyone else to use, share and improve
+% what you give them.   Help stamp out software-hoarding!
+%
+% Please try the latest version of texinfo.tex before submitting bug
+% reports; you can get the latest version from:
+%   ftp://ftp.gnu.org/gnu/texinfo.tex
+%   (and all GNU mirrors, see http://www.gnu.org/order/ftp.html)
+%   ftp://texinfo.org/tex/texinfo.tex
+%   ftp://us.ctan.org/macros/texinfo/texinfo.tex
+%   (and all CTAN mirrors, finger ctan@us.ctan.org for a list).
+%   /home/gd/gnu/doc/texinfo.tex on the GNU machines.
+% The texinfo.tex in any given Texinfo distribution could well be out
+% of date, so if that's what you're using, please check.
+% Texinfo has a small home page at http://texinfo.org/.
+%
+% Send bug reports to bug-texinfo@gnu.org.  Please include including a
+% complete document in each bug report with which we can reproduce the
+% problem.  Patches are, of course, greatly appreciated.
+%
+% To process a Texinfo manual with TeX, it's most reliable to use the
+% texi2dvi shell script that comes with the distribution.  For a simple
+% manual foo.texi, however, you can get away with this:
+%   tex foo.texi
+%   texindex foo.??
+%   tex foo.texi
+%   tex foo.texi
+%   dvips foo.dvi -o # or whatever, to process the dvi file; this makes foo.ps.
+% The extra runs of TeX get the cross-reference information correct.
+% Sometimes one run after texindex suffices, and sometimes you need more
+% than two; texi2dvi does it as many times as necessary.
+%
+% It is possible to adapt texinfo.tex for other languages.  You can get
+% the existing language-specific files from ftp://ftp.gnu.org/gnu/texinfo/.
+
+\message{Loading texinfo [version \texinfoversion]:}
 
 % If in a .fmt file, print the version number
 % and turn on active characters that we couldn't do earlier because
 % they might have appeared in the input file name.
-\everyjob{\message{[Texinfo version \texinfoversion]}\message{}
+\everyjob{\message{[Texinfo version \texinfoversion]}%
   \catcode`+=\active \catcode`\_=\active}
 
 % Save some parts of plain tex whose names we will redefine.
-
-\let\ptextilde=\~
+\let\ptexb=\b
+\let\ptexbullet=\bullet
+\let\ptexc=\c
+\let\ptexcomma=\,
+\let\ptexdot=\.
+\let\ptexdots=\dots
+\let\ptexend=\end
+\let\ptexequiv=\equiv
+\let\ptexexclam=\!
+\let\ptexi=\i
 \let\ptexlbrace=\{
 \let\ptexrbrace=\}
-\let\ptexdots=\dots
-\let\ptexdot=\.
 \let\ptexstar=\*
-\let\ptexend=\end
-\let\ptexbullet=\bullet
-\let\ptexb=\b
-\let\ptexc=\c
-\let\ptexi=\i
 \let\ptext=\t
-\let\ptexl=\l
-\let\ptexL=\L
-
-% Be sure we're in horizontal mode when doing a tie, since we make space
-% equivalent to this in @example-like environments. Otherwise, a space
-% at the beginning of a line will start with \penalty -- and
-% since \penalty is valid in vertical mode, we'd end up putting the
-% penalty on the vertical list instead of in the new paragraph.
-{\catcode`@ = 11
- \gdef\tie{\leavevmode\penalty\@M\ }
-}
-\let\~ = \tie                  % And make it available as @~.
+
+% We never want plain's outer \+ definition in Texinfo.
+% For @tex, we can use \tabalign.
+\let\+ = \relax
 
 \message{Basics,}
 \chardef\other=12
 
 % If this character appears in an error message or help string, it
 % starts a new line in the output.
 \newlinechar = `^^J
 
-% Set up fixed words for English.
-\ifx\putwordChapter\undefined{\gdef\putwordChapter{Chapter}}\fi%
-\def\putwordInfo{Info}%
-\ifx\putwordSee\undefined{\gdef\putwordSee{See}}\fi%
-\ifx\putwordsee\undefined{\gdef\putwordsee{see}}\fi%
-\ifx\putwordfile\undefined{\gdef\putwordfile{file}}\fi%
-\ifx\putwordpage\undefined{\gdef\putwordpage{page}}\fi%
-\ifx\putwordsection\undefined{\gdef\putwordsection{section}}\fi%
-\ifx\putwordSection\undefined{\gdef\putwordSection{Section}}\fi%
-\ifx\putwordTableofContents\undefined{\gdef\putwordTableofContents{Table of Contents}}\fi%
-\ifx\putwordShortContents\undefined{\gdef\putwordShortContents{Short Contents}}\fi%
-\ifx\putwordAppendix\undefined{\gdef\putwordAppendix{Appendix}}\fi%
+% Set up fixed words for English if not already set.
+\ifx\putwordAppendix\undefined  \gdef\putwordAppendix{Appendix}\fi
+\ifx\putwordChapter\undefined   \gdef\putwordChapter{Chapter}\fi
+\ifx\putwordfile\undefined      \gdef\putwordfile{file}\fi
+\ifx\putwordin\undefined        \gdef\putwordin{in}\fi
+\ifx\putwordIndexIsEmpty\undefined     \gdef\putwordIndexIsEmpty{(Index is empty)}\fi
+\ifx\putwordIndexNonexistent\undefined \gdef\putwordIndexNonexistent{(Index is nonexistent)}\fi
+\ifx\putwordInfo\undefined      \gdef\putwordInfo{Info}\fi
+\ifx\putwordInstanceVariableof\undefined \gdef\putwordInstanceVariableof{Instance Variable of}\fi
+\ifx\putwordMethodon\undefined  \gdef\putwordMethodon{Method on}\fi
+\ifx\putwordNoTitle\undefined   \gdef\putwordNoTitle{No Title}\fi
+\ifx\putwordof\undefined        \gdef\putwordof{of}\fi
+\ifx\putwordon\undefined        \gdef\putwordon{on}\fi
+\ifx\putwordpage\undefined      \gdef\putwordpage{page}\fi
+\ifx\putwordsection\undefined   \gdef\putwordsection{section}\fi
+\ifx\putwordSection\undefined   \gdef\putwordSection{Section}\fi
+\ifx\putwordsee\undefined       \gdef\putwordsee{see}\fi
+\ifx\putwordSee\undefined       \gdef\putwordSee{See}\fi
+\ifx\putwordShortTOC\undefined  \gdef\putwordShortTOC{Short Contents}\fi
+\ifx\putwordTOC\undefined       \gdef\putwordTOC{Table of Contents}\fi
+%
+\ifx\putwordMJan\undefined \gdef\putwordMJan{January}\fi
+\ifx\putwordMFeb\undefined \gdef\putwordMFeb{February}\fi
+\ifx\putwordMMar\undefined \gdef\putwordMMar{March}\fi
+\ifx\putwordMApr\undefined \gdef\putwordMApr{April}\fi
+\ifx\putwordMMay\undefined \gdef\putwordMMay{May}\fi
+\ifx\putwordMJun\undefined \gdef\putwordMJun{June}\fi
+\ifx\putwordMJul\undefined \gdef\putwordMJul{July}\fi
+\ifx\putwordMAug\undefined \gdef\putwordMAug{August}\fi
+\ifx\putwordMSep\undefined \gdef\putwordMSep{September}\fi
+\ifx\putwordMOct\undefined \gdef\putwordMOct{October}\fi
+\ifx\putwordMNov\undefined \gdef\putwordMNov{November}\fi
+\ifx\putwordMDec\undefined \gdef\putwordMDec{December}\fi
+%
+\ifx\putwordDefmac\undefined    \gdef\putwordDefmac{Macro}\fi
+\ifx\putwordDefspec\undefined   \gdef\putwordDefspec{Special Form}\fi
+\ifx\putwordDefvar\undefined    \gdef\putwordDefvar{Variable}\fi
+\ifx\putwordDefopt\undefined    \gdef\putwordDefopt{User Option}\fi
+\ifx\putwordDeftypevar\undefined\gdef\putwordDeftypevar{Variable}\fi
+\ifx\putwordDeffunc\undefined   \gdef\putwordDeffunc{Function}\fi
+\ifx\putwordDeftypefun\undefined\gdef\putwordDeftypefun{Function}\fi
 
 % Ignore a token.
 %
 \def\gobble#1{}
 
 \hyphenation{ap-pen-dix}
 \hyphenation{mini-buf-fer mini-buf-fers}
 \hyphenation{eshell}
+\hyphenation{white-space}
 
 % Margin to add to right of even pages, to left of odd pages.
-\newdimen \bindingoffset  \bindingoffset=0pt
-\newdimen \normaloffset   \normaloffset=\hoffset
+\newdimen \bindingoffset
+\newdimen \normaloffset
 \newdimen\pagewidth \newdimen\pageheight
-\pagewidth=\hsize \pageheight=\vsize
 
 % Sometimes it is convenient to have everything in the transcript file
 % and nothing on the terminal.  We don't just call \tracingall here,
 % since that produces some useless output on the terminal.
 %
 \def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
+\ifx\eTeXversion\undefined
 \def\loggingall{\tracingcommands2 \tracingstats2
    \tracingpages1 \tracingoutput1 \tracinglostchars1
    \tracingmacros2 \tracingparagraphs1 \tracingrestores1
    \showboxbreadth\maxdimen\showboxdepth\maxdimen
 }%
-
-%---------------------Begin change-----------------------
-%
-%%%% For @cropmarks command.
-% Dimensions to add cropmarks at corners Added by P. A. MacKay, 12 Nov. 1986
+\else
+\def\loggingall{\tracingcommands3 \tracingstats2
+   \tracingpages1 \tracingoutput1 \tracinglostchars1
+   \tracingmacros2 \tracingparagraphs1 \tracingrestores1
+   \tracingscantokens1 \tracingassigns1 \tracingifs1
+   \tracinggroups1 \tracingnesting2
+   \showboxbreadth\maxdimen\showboxdepth\maxdimen
+}%
+\fi
+
+% For @cropmarks command.
+% Do @cropmarks to get crop marks.
 %
-\newdimen\cornerlong \newdimen\cornerthick
-\newdimen \topandbottommargin
-\newdimen \outerhsize \newdimen \outervsize
-\cornerlong=1pc\cornerthick=.3pt        % These set size of cropmarks
-\outerhsize=7in
-%\outervsize=9.5in
-% Alternative @smallbook page size is 9.25in
-\outervsize=9.25in
-\topandbottommargin=.75in
+\newif\ifcropmarks
+\let\cropmarks = \cropmarkstrue
+%
+% Dimensions to add cropmarks at corners.
+% Added by P. A. MacKay, 12 Nov. 1986
 %
-%---------------------End change-----------------------
+\newdimen\outerhsize \newdimen\outervsize % set by the paper size routines
+\newdimen\cornerlong  \cornerlong=1pc
+\newdimen\cornerthick \cornerthick=.3pt
+\newdimen\topandbottommargin \topandbottommargin=.75in
+
+% Main output routine.
+\chardef\PAGE = 255
+\output = {\onepageout{\pagecontents\PAGE}}
+
+\newbox\headlinebox
+\newbox\footlinebox
 
 % \onepageout takes a vbox as an argument.  Note that \pagecontents
-% does insertions itself, but you have to call it yourself.
-\chardef\PAGE=255  \output={\onepageout{\pagecontents\PAGE}}
-\def\onepageout#1{\hoffset=\normaloffset
-\ifodd\pageno  \advance\hoffset by \bindingoffset
-\else \advance\hoffset by -\bindingoffset\fi
-{\escapechar=`\\\relax % makes sure backslash is used in output files.
-\shipout\vbox{{\let\hsize=\pagewidth \makeheadline} \pagebody{#1}%
-{\let\hsize=\pagewidth \makefootline}}}%
-\advancepageno \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
-
-%%%% For @cropmarks command %%%%
-
-% Here is a modification of the main output routine for Near East Publications
-% This provides right-angle cropmarks at all four corners.
-% The contents of the page are centerlined into the cropmarks,
-% and any desired binding offset is added as an \hskip on either
-% site of the centerlined box.  (P. A. MacKay, 12 November, 1986)
-%
-\def\croppageout#1{\hoffset=0pt % make sure this doesn't mess things up
-{\escapechar=`\\\relax % makes sure backslash is used in output files.
-                 \shipout
-                 \vbox to \outervsize{\hsize=\outerhsize
-                 \vbox{\line{\ewtop\hfill\ewtop}}
-                 \nointerlineskip
-                 \line{\vbox{\moveleft\cornerthick\nstop}
-                       \hfill
-                       \vbox{\moveright\cornerthick\nstop}}
-                 \vskip \topandbottommargin
-                 \centerline{\ifodd\pageno\hskip\bindingoffset\fi
-                        \vbox{
-                        {\let\hsize=\pagewidth \makeheadline}
-                        \pagebody{#1}
-                        {\let\hsize=\pagewidth \makefootline}}
-                        \ifodd\pageno\else\hskip\bindingoffset\fi}
-                 \vskip \topandbottommargin plus1fill minus1fill
-                 \boxmaxdepth\cornerthick
-                 \line{\vbox{\moveleft\cornerthick\nsbot}
-                       \hfill
-                       \vbox{\moveright\cornerthick\nsbot}}
-                 \nointerlineskip
-                 \vbox{\line{\ewbot\hfill\ewbot}}
-        }}
+% does insertions, but you have to call it yourself.
+\def\onepageout#1{%
+  \ifcropmarks \hoffset=0pt \else \hoffset=\normaloffset \fi
+  %
+  \ifodd\pageno  \advance\hoffset by \bindingoffset
+  \else \advance\hoffset by -\bindingoffset\fi
+  %
+  % Do this outside of the \shipout so @code etc. will be expanded in
+  % the headline as they should be, not taken literally (outputting ''code).
+  \setbox\headlinebox = \vbox{\let\hsize=\pagewidth \makeheadline}%
+  \setbox\footlinebox = \vbox{\let\hsize=\pagewidth \makefootline}%
+  %
+  {%
+    % Have to do this stuff outside the \shipout because we want it to
+    % take effect in \write's, yet the group defined by the \vbox ends
+    % before the \shipout runs.
+    %
+    \escapechar = `\\     % use backslash in output files.
+    \indexdummies         % don't expand commands in the output.
+    \normalturnoffactive  % \ in index entries must not stay \, e.g., if
+                   % the page break happens to be in the middle of an example.
+    \shipout\vbox{%
+      \ifcropmarks \vbox to \outervsize\bgroup
+        \hsize = \outerhsize
+        \vskip-\topandbottommargin
+        \vtop to0pt{%
+          \line{\ewtop\hfil\ewtop}%
+          \nointerlineskip
+          \line{%
+            \vbox{\moveleft\cornerthick\nstop}%
+            \hfill
+            \vbox{\moveright\cornerthick\nstop}%
+          }%
+          \vss}%
+        \vskip\topandbottommargin
+        \line\bgroup
+          \hfil % center the page within the outer (page) hsize.
+          \ifodd\pageno\hskip\bindingoffset\fi
+          \vbox\bgroup
+      \fi
+      %
+      \unvbox\headlinebox
+      \pagebody{#1}%
+      \ifdim\ht\footlinebox > 0pt
+        % Only leave this space if the footline is nonempty.
+        % (We lessened \vsize for it in \oddfootingxxx.)
+        % The \baselineskip=24pt in plain's \makefootline has no effect.
+        \vskip 2\baselineskip
+        \unvbox\footlinebox
+      \fi
+      %
+      \ifpdfmakepagedest \pdfmkdest{\the\pageno} \fi
+      %
+      \ifcropmarks
+          \egroup % end of \vbox\bgroup
+        \hfil\egroup % end of (centering) \line\bgroup
+        \vskip\topandbottommargin plus1fill minus1fill
+        \boxmaxdepth = \cornerthick
+        \vbox to0pt{\vss
+          \line{%
+            \vbox{\moveleft\cornerthick\nsbot}%
+            \hfill
+            \vbox{\moveright\cornerthick\nsbot}%
+          }%
+          \nointerlineskip
+          \line{\ewbot\hfil\ewbot}%
+        }%
+      \egroup % \vbox from first cropmarks clause
+      \fi
+    }% end of \shipout\vbox
+  }% end of group with \turnoffactive
   \advancepageno
-  \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
-%
-% Do @cropmarks to get crop marks
-\def\cropmarks{\let\onepageout=\croppageout }
+  \ifnum\outputpenalty>-20000 \else\dosupereject\fi
+}
 
 \newinsert\margin \dimen\margin=\maxdimen
 
 \def\pagebody#1{\vbox to\pageheight{\boxmaxdepth=\maxdepth #1}}
 {\catcode`\@ =11
 \gdef\pagecontents#1{\ifvoid\topins\else\unvbox\topins\fi
 % marginal hacks, juha@viisa.uucp (Juha Takala)
 \ifvoid\margin\else % marginal info is present
   \rlap{\kern\hsize\vbox to\z@{\kern1pt\box\margin \vss}}\fi
 \dimen@=\dp#1 \unvbox#1
 \ifvoid\footins\else\vskip\skip\footins\footnoterule \unvbox\footins\fi
 \ifr@ggedbottom \kern-\dimen@ \vfil \fi}
 }
 
-%
 % Here are the rules for the cropmarks.  Note that they are
 % offset so that the space between them is truly \outerhsize or \outervsize
 % (P. A. MacKay, 12 November, 1986)
 %
 \def\ewtop{\vrule height\cornerthick depth0pt width\cornerlong}
 \def\nstop{\vbox
   {\hrule height\cornerthick depth\cornerlong width\cornerthick}}
 \def\ewbot{\vrule height0pt depth\cornerthick width\cornerlong}
@@ -284,21 +369,21 @@
 
 
 \def\flushcr{\ifx\par\lisppar \def\next##1{}\else \let\next=\relax \fi \next}
 
 %% These are used to keep @begin/@end levels from running away
 %% Call \inENV within environments (after a \begingroup)
 \newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
 \def\ENVcheck{%
-\ifENV\errmessage{Still within an environment.  Type Return to continue.}
+\ifENV\errmessage{Still within an environment; press RETURN to continue}
 \endgroup\fi} % This is not perfect, but it should reduce lossage
 
 % @begin foo  is the same as @foo, for now.
-\newhelp\EMsimple{Type <Return> to continue.}
+\newhelp\EMsimple{Press RETURN to continue.}
 
 \outer\def\begin{\parsearg\beginxxx}
 
 \def\beginxxx #1{%
 \expandafter\ifx\csname #1\endcsname\relax
 {\errhelp=\EMsimple \errmessage{Undefined command @begin #1}}\else
 \csname #1\endcsname\fi}
 
@@ -347,49 +432,90 @@
   %\kern \baselineskip}%
   \setleading \singlespaceskip
 }
 
 %% Simple single-character @ commands
 
 % @@ prints an @
 % Kludge this until the fonts are right (grr).
-\def\@{{\tt \char '100}}
+\def\@{{\tt\char64}}
 
 % This is turned off because it was never documented
 % and you can use @w{...} around a quote to suppress ligatures.
 %% Define @` and @' to be the same as ` and '
 %% but suppressing ligatures.
 %\def\`{{`}}
 %\def\'{{'}}
 
 % Used to generate quoted braces.
-
-\def\mylbrace {{\tt \char '173}}
-\def\myrbrace {{\tt \char '175}}
+\def\mylbrace {{\tt\char123}}
+\def\myrbrace {{\tt\char125}}
 \let\{=\mylbrace
 \let\}=\myrbrace
+\begingroup
+  % Definitions to produce actual \{ & \} command in an index.
+  \catcode`\{ = 12 \catcode`\} = 12
+  \catcode`\[ = 1 \catcode`\] = 2
+  \catcode`\@ = 0 \catcode`\\ = 12
+  @gdef@lbracecmd[\{]%
+  @gdef@rbracecmd[\}]%
+@endgroup
+
+% Accents: @, @dotaccent @ringaccent @ubaraccent @udotaccent
+% Others are defined by plain TeX: @` @' @" @^ @~ @= @v @H.
+\let\, = \c
+\let\dotaccent = \.
+\def\ringaccent#1{{\accent23 #1}}
+\let\tieaccent = \t
+\let\ubaraccent = \b
+\let\udotaccent = \d
+
+% Other special characters: @questiondown @exclamdown
+% Plain TeX defines: @AA @AE @O @OE @L (and lowercase versions) @ss.
+\def\questiondown{?`}
+\def\exclamdown{!`}
+
+% Dotless i and dotless j, used for accents.
+\def\imacro{i}
+\def\jmacro{j}
+\def\dotless#1{%
+  \def\temp{#1}%
+  \ifx\temp\imacro \ptexi
+  \else\ifx\temp\jmacro \j
+  \else \errmessage{@dotless can be used only with i or j}%
+  \fi\fi
+}
+
+% Be sure we're in horizontal mode when doing a tie, since we make space
+% equivalent to this in @example-like environments. Otherwise, a space
+% at the beginning of a line will start with \penalty -- and
+% since \penalty is valid in vertical mode, we'd end up putting the
+% penalty on the vertical list instead of in the new paragraph.
+{\catcode`@ = 11
+ % Avoid using \@M directly, because that causes trouble
+ % if the definition is written into an index file.
+ \global\let\tiepenalty = \@M
+ \gdef\tie{\leavevmode\penalty\tiepenalty\ }
+}
 
 % @: forces normal size whitespace following.
 \def\:{\spacefactor=1000 }
 
 % @* forces a line break.
 \def\*{\hfil\break\hbox{}\ignorespaces}
 
 % @. is an end-of-sentence period.
 \def\.{.\spacefactor=3000 }
 
-% @enddots{} is an end-of-sentence ellipsis.
-\gdef\enddots{$\mathinner{\ldotp\ldotp\ldotp\ldotp}$\spacefactor=3000}
-
 % @! is an end-of-sentence bang.
-\gdef\!{!\spacefactor=3000 }
+\def\!{!\spacefactor=3000 }
 
 % @? is an end-of-sentence query.
-\gdef\?{?\spacefactor=3000 }
+\def\?{?\spacefactor=3000 }
 
 % @w prevents a word break.  Without the \leavevmode, @w at the
 % beginning of a paragraph, when TeX is still in vertical mode, would
 % produce a whole line of output instead of starting the paragraph.
 \def\w#1{\leavevmode\hbox{#1}}
 
 % @group ... @end group forces ... to be all on one page, by enclosing
 % it in a TeX vbox.  We use \vtop instead of \vbox to construct the box
@@ -463,63 +589,91 @@ where each line of input produces a line
 
 \def\need{\parsearg\needx}
 
 % Old definition--didn't work.
 %\def\needx #1{\par %
 %% This method tries to make TeX break the page naturally
 %% if the depth of the box does not fit.
 %{\baselineskip=0pt%
-%\vtop to #1\mil{\vfil}\kern -#1\mil\penalty 10000
+%\vtop to #1\mil{\vfil}\kern -#1\mil\nobreak
 %\prevdepth=-1000pt
 %}}
 
 \def\needx#1{%
-  % Go into vertical mode, so we don't make a big box in the middle of a
+  % Ensure vertical mode, so we don't make a big box in the middle of a
   % paragraph.
   \par
   %
-  % Don't add any leading before our big empty box, but allow a page
-  % break, since the best break might be right here.
-  \allowbreak
-  \nointerlineskip
-  \vtop to #1\mil{\vfil}%
-  %
-  % TeX does not even consider page breaks if a penalty added to the
-  % main vertical list is 10000 or more.  But in order to see if the
-  % empty box we just added fits on the page, we must make it consider
-  % page breaks.  On the other hand, we don't want to actually break the
-  % page after the empty box.  So we use a penalty of 9999.
-  %
-  % There is an extremely small chance that TeX will actually break the
-  % page at this \penalty, if there are no other feasible breakpoints in
-  % sight.  (If the user is using lots of big @group commands, which
-  % almost-but-not-quite fill up a page, TeX will have a hard time doing
-  % good page breaking, for example.)  However, I could not construct an
-  % example where a page broke at this \penalty; if it happens in a real
-  % document, then we can reconsider our strategy.
-  \penalty9999
-  %
-  % Back up by the size of the box, whether we did a page break or not.
-  \kern -#1\mil
-  %
-  % Do not allow a page break right after this kern.
-  \nobreak
+  % If the @need value is less than one line space, it's useless.
+  \dimen0 = #1\mil
+  \dimen2 = \ht\strutbox
+  \advance\dimen2 by \dp\strutbox
+  \ifdim\dimen0 > \dimen2
+    %
+    % Do a \strut just to make the height of this box be normal, so the
+    % normal leading is inserted relative to the preceding line.
+    % And a page break here is fine.
+    \vtop to #1\mil{\strut\vfil}%
+    %
+    % TeX does not even consider page breaks if a penalty added to the
+    % main vertical list is 10000 or more.  But in order to see if the
+    % empty box we just added fits on the page, we must make it consider
+    % page breaks.  On the other hand, we don't want to actually break the
+    % page after the empty box.  So we use a penalty of 9999.
+    %
+    % There is an extremely small chance that TeX will actually break the
+    % page at this \penalty, if there are no other feasible breakpoints in
+    % sight.  (If the user is using lots of big @group commands, which
+    % almost-but-not-quite fill up a page, TeX will have a hard time doing
+    % good page breaking, for example.)  However, I could not construct an
+    % example where a page broke at this \penalty; if it happens in a real
+    % document, then we can reconsider our strategy.
+    \penalty9999
+    %
+    % Back up by the size of the box, whether we did a page break or not.
+    \kern -#1\mil
+    %
+    % Do not allow a page break right after this kern.
+    \nobreak
+  \fi
 }
 
 % @br   forces paragraph break
 
 \let\br = \par
 
-% @dots{}  output some dots
-
-\def\dots{$\ldots$}
+% @dots{} output an ellipsis using the current font.
+% We do .5em per period so that it has the same spacing in a typewriter
+% font as three actual period characters.
+%
+\def\dots{%
+  \leavevmode
+  \hbox to 1.5em{%
+    \hskip 0pt plus 0.25fil minus 0.25fil
+    .\hss.\hss.%
+    \hskip 0pt plus 0.5fil minus 0.5fil
+  }%
+}
+
+% @enddots{} is an end-of-sentence ellipsis.
+%
+\def\enddots{%
+  \leavevmode
+  \hbox to 2em{%
+    \hskip 0pt plus 0.25fil minus 0.25fil
+    .\hss.\hss.\hss.%
+    \hskip 0pt plus 0.5fil minus 0.5fil
+  }%
+  \spacefactor=3000
+}
+
 
 % @page    forces the start of a new page
-
+%
 \def\page{\par\vfill\supereject}
 
 % @exdent text....
 % outputs text on separate line in roman font, starting at standard page margin
 
 % This records the amount of indent in the innermost environment.
 % That's how much \exdent should take out.
 \newskip\exdentamount
@@ -528,330 +682,108 @@ where each line of input produces a line
 \def\exdent{\parsearg\exdentyyy}
 \def\exdentyyy #1{{\hfil\break\hbox{\kern -\exdentamount{\rm#1}}\hfil\break}}
 
 % This defn is used inside nofill environments such as @example.
 \def\nofillexdent{\parsearg\nofillexdentyyy}
 \def\nofillexdentyyy #1{{\advance \leftskip by -\exdentamount
 \leftline{\hskip\leftskip{\rm#1}}}}
 
+% @inmargin{TEXT} puts TEXT in the margin next to the current paragraph.
+
+\def\inmargin#1{%
+\strut\vadjust{\nobreak\kern-\strutdepth
+  \vtop to \strutdepth{\baselineskip\strutdepth\vss
+  \llap{\rightskip=\inmarginspacing \vbox{\noindent #1}}\null}}}
+\newskip\inmarginspacing \inmarginspacing=1cm
+\def\strutdepth{\dp\strutbox}
+
 %\hbox{{\rm#1}}\hfil\break}}
 
 % @include file    insert text of that file as input.
-
-\def\include{\parsearg\includezzz}
-%Use \input\thisfile to avoid blank after \input, which may be an active
-%char (in which case the blank would become the \input argument).
-%The grouping keeps the value of \thisfile correct even when @include
-%is nested.
-\def\includezzz #1{\begingroup
-\def\thisfile{#1}\input\thisfile
+% Allow normal characters that  we make active in the argument (a file name).
+\def\include{\begingroup
+  \catcode`\\=12
+  \catcode`~=12
+  \catcode`^=12
+  \catcode`_=12
+  \catcode`|=12
+  \catcode`<=12
+  \catcode`>=12
+  \catcode`+=12
+  \parsearg\includezzz}
+% Restore active chars for included file.
+\def\includezzz#1{\endgroup\begingroup
+  % Read the included file in a group so nested @include's work.
+  \def\thisfile{#1}%
+  \input\thisfile
 \endgroup}
 
 \def\thisfile{}
 
 % @center line   outputs that line, centered
 
 \def\center{\parsearg\centerzzz}
 \def\centerzzz #1{{\advance\hsize by -\leftskip
 \advance\hsize by -\rightskip
 \centerline{#1}}}
 
 % @sp n   outputs n lines of vertical space
 
 \def\sp{\parsearg\spxxx}
-\def\spxxx #1{\par \vskip #1\baselineskip}
+\def\spxxx #1{\vskip #1\baselineskip}
 
 % @comment ...line which is ignored...
 % @c is the same as @comment
 % @ignore ... @end ignore  is another way to write a comment
 
-\def\comment{\catcode 64=\other \catcode 123=\other \catcode 125=\other%
-\parsearg \commentxxx}
-
-\def\commentxxx #1{\catcode 64=0 \catcode 123=1 \catcode 125=2 }
+\def\comment{\begingroup \catcode`\^^M=\other%
+\catcode`\@=\other \catcode`\{=\other \catcode`\}=\other%
+\commentxxx}
+{\catcode`\^^M=\other \gdef\commentxxx#1^^M{\endgroup}}
 
 \let\c=\comment
 
-% Prevent errors for section commands.
-% Used in @ignore and in failing conditionals.
-\def\ignoresections{%
-\let\chapter=\relax
-\let\unnumbered=\relax
-\let\top=\relax
-\let\unnumberedsec=\relax
-\let\unnumberedsection=\relax
-\let\unnumberedsubsec=\relax
-\let\unnumberedsubsection=\relax
-\let\unnumberedsubsubsec=\relax
-\let\unnumberedsubsubsection=\relax
-\let\section=\relax
-\let\subsec=\relax
-\let\subsubsec=\relax
-\let\subsection=\relax
-\let\subsubsection=\relax
-\let\appendix=\relax
-\let\appendixsec=\relax
-\let\appendixsection=\relax
-\let\appendixsubsec=\relax
-\let\appendixsubsection=\relax
-\let\appendixsubsubsec=\relax
-\let\appendixsubsubsection=\relax
-\let\contents=\relax
-\let\smallbook=\relax
-\let\titlepage=\relax
-}
-
-% Used in nested conditionals, where we have to parse the Texinfo source
-% and so want to turn off most commands, in case they are used
-% incorrectly.
-%
-\def\ignoremorecommands{%
-  \let\defcv = \relax
-  \let\deffn = \relax
-  \let\deffnx = \relax
-  \let\defindex = \relax
-  \let\defivar = \relax
-  \let\defmac = \relax
-  \let\defmethod = \relax
-  \let\defop = \relax
-  \let\defopt = \relax
-  \let\defspec = \relax
-  \let\deftp = \relax
-  \let\deftypefn = \relax
-  \let\deftypefun = \relax
-  \let\deftypevar = \relax
-  \let\deftypevr = \relax
-  \let\defun = \relax
-  \let\defvar = \relax
-  \let\defvr = \relax
-  \let\ref = \relax
-  \let\xref = \relax
-  \let\printindex = \relax
-  \let\pxref = \relax
-  \let\settitle = \relax
-  \let\include = \relax
-  \let\lowersections = \relax
-  \let\down = \relax
-  \let\raisesections = \relax
-  \let\up = \relax
-  \let\set = \relax
-  \let\clear = \relax
-  \let\item = \relax
-  \let\message = \relax
-}
-
-% Ignore @ignore ... @end ignore.
-%
-\def\ignore{\doignore{ignore}}
-
-% Also ignore @ifinfo, @ifhtml, @html, @menu, and @direntry text.
-%
-\def\ifinfo{\doignore{ifinfo}}
-\def\ifhtml{\doignore{ifhtml}}
-\def\html{\doignore{html}}
-\def\menu{\doignore{menu}}
-\def\direntry{\doignore{direntry}}
-
-% Ignore text until a line `@end #1'.
-%
-\def\doignore#1{\begingroup
-  % Don't complain about control sequences we have declared \outer.
-  \ignoresections
-  %
-  % Define a command to swallow text until we reach `@end #1'.
-  \long\def\doignoretext##1\end #1{\enddoignore}%
-  %
-  % Make sure that spaces turn into tokens that match what \doignoretext wants.
-  \catcode32 = 10
-  %
-  % And now expand that command.
-  \doignoretext
-}
-
-% What we do to finish off ignored text.
+% @paragraphindent NCHARS
+% We'll use ems for NCHARS, close enough.
+% We cannot implement @paragraphindent asis, though.
+% 
+\def\asisword{asis} % no translation, these are keywords
+\def\noneword{none}
 %
-\def\enddoignore{\endgroup\ignorespaces}%
-
-\newif\ifwarnedobs\warnedobsfalse
-\def\obstexwarn{%
-  \ifwarnedobs\relax\else
-  % We need to warn folks that they may have trouble with TeX 3.0.
-  % This uses \immediate\write16 rather than \message to get newlines.
-    \immediate\write16{}
-    \immediate\write16{***WARNING*** for users of Unix TeX 3.0!}
-    \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
-    \immediate\write16{If you are running another version of TeX, relax.}
-    \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
-    \immediate\write16{  Then upgrade your TeX installation if you can.}
-    \immediate\write16{If you are stuck with version 3.0, run the}
-    \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
-    \immediate\write16{  to use a workaround.}
-    \immediate\write16{}
-    \warnedobstrue
+\def\paragraphindent{\parsearg\doparagraphindent}
+\def\doparagraphindent#1{%
+  \def\temp{#1}%
+  \ifx\temp\asisword
+  \else
+    \ifx\temp\noneword
+      \defaultparindent = 0pt
+    \else
+      \defaultparindent = #1em
     \fi
+  \fi
+  \parindent = \defaultparindent
 }
 
-% **In TeX 3.0, setting text in \nullfont hangs tex.  For a
-% workaround (which requires the file ``dummy.tfm'' to be installed),
-% uncomment the following line:
-%%%%%\font\nullfont=dummy\let\obstexwarn=\relax
-
-% Ignore text, except that we keep track of conditional commands for
-% purposes of nesting, up to an `@end #1' command.
-%
-\def\nestedignore#1{%
-  \obstexwarn
-  % We must actually expand the ignored text to look for the @end
-  % command, so that nested ignore constructs work.  Thus, we put the
-  % text into a \vbox and then do nothing with the result.  To minimize
-  % the change of memory overflow, we follow the approach outlined on
-  % page 401 of the TeXbook: make the current font be a dummy font.
-  %
-  \setbox0 = \vbox\bgroup
-    % Don't complain about control sequences we have declared \outer.
-    \ignoresections
-    %
-    % Define `@end #1' to end the box, which will in turn undefine the
-    % @end command again.
-    \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
-    %
-    % We are going to be parsing Texinfo commands.  Most cause no
-    % trouble when they are used incorrectly, but some commands do
-    % complicated argument parsing or otherwise get confused, so we
-    % undefine them.
-    %
-    % We can't do anything about stray @-signs, unfortunately;
-    % they'll produce `undefined control sequence' errors.
-    \ignoremorecommands
-    %
-    % Set the current font to be \nullfont, a TeX primitive, and define
-    % all the font commands to also use \nullfont.  We don't use
-    % dummy.tfm, as suggested in the TeXbook, because not all sites
-    % might have that installed.  Therefore, math mode will still
-    % produce output, but that should be an extremely small amount of
-    % stuff compared to the main input.
-    %
-    \nullfont
-    \let\tenrm = \nullfont  \let\tenit = \nullfont  \let\tensl = \nullfont
-    \let\tenbf = \nullfont  \let\tentt = \nullfont  \let\smallcaps = \nullfont
-    \let\tensf = \nullfont
-    % Similarly for index fonts (mostly for their use in
-    % smallexample)
-    \let\indrm = \nullfont  \let\indit = \nullfont  \let\indsl = \nullfont
-    \let\indbf = \nullfont  \let\indtt = \nullfont  \let\indsc = \nullfont
-    \let\indsf = \nullfont
-    %
-    % Don't complain when characters are missing from the fonts.
-    \tracinglostchars = 0
-    %
-    % Don't bother to do space factor calculations.
-    \frenchspacing
-    %
-    % Don't report underfull hboxes.
-    \hbadness = 10000
-    %
-    % Do minimal line-breaking.
-    \pretolerance = 10000
-    %
-    % Do not execute instructions in @tex
-    \def\tex{\doignore{tex}}
-}
-
-% @set VAR sets the variable VAR to an empty value.
-% @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
-%
-% Since we want to separate VAR from REST-OF-LINE (which might be
-% empty), we can't just use \parsearg; we have to insert a space of our
-% own to delimit the rest of the line, and then take it out again if we
-% didn't need it.
-%
-\def\set{\parsearg\setxxx}
-\def\setxxx#1{\setyyy#1 \endsetyyy}
-\def\setyyy#1 #2\endsetyyy{%
-  \def\temp{#2}%
-  \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
-  \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
+% @exampleindent NCHARS
+% We'll use ems for NCHARS like @paragraphindent.
+% It seems @exampleindent asis isn't necessary, but
+% I preserve it to make it similar to @paragraphindent.
+\def\exampleindent{\parsearg\doexampleindent}
+\def\doexampleindent#1{%
+  \def\temp{#1}%
+  \ifx\temp\asisword
+  \else
+    \ifx\temp\noneword
+      \lispnarrowing = 0pt
+    \else
+      \lispnarrowing = #1em
+    \fi
   \fi
 }
-% Can't use \xdef to pre-expand #2 and save some time, since \temp or
-% \next or other control sequences that we've defined might get us into
-% an infinite loop. Consider `@set foo @cite{bar}'.
-\def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
-
-% @clear VAR clears (i.e., unsets) the variable VAR.
-%
-\def\clear{\parsearg\clearxxx}
-\def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
-
-% @value{foo} gets the text saved in variable foo.
-%
-\def\value#1{\expandafter
-                \ifx\csname SET#1\endcsname\relax
-                        {\{No value for ``#1''\}}
-                \else \csname SET#1\endcsname \fi}
-
-% @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
-% with @set.
-%
-\def\ifset{\parsearg\ifsetxxx}
-\def\ifsetxxx #1{%
-  \expandafter\ifx\csname SET#1\endcsname\relax
-    \expandafter\ifsetfail
-  \else
-    \expandafter\ifsetsucceed
-  \fi
-}
-\def\ifsetsucceed{\conditionalsucceed{ifset}}
-\def\ifsetfail{\nestedignore{ifset}}
-\defineunmatchedend{ifset}
-
-% @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
-% defined with @set, or has been undefined with @clear.
-%
-\def\ifclear{\parsearg\ifclearxxx}
-\def\ifclearxxx #1{%
-  \expandafter\ifx\csname SET#1\endcsname\relax
-    \expandafter\ifclearsucceed
-  \else
-    \expandafter\ifclearfail
-  \fi
-}
-\def\ifclearsucceed{\conditionalsucceed{ifclear}}
-\def\ifclearfail{\nestedignore{ifclear}}
-\defineunmatchedend{ifclear}
-
-% @iftex always succeeds; we read the text following, through @end
-% iftex).  But `@end iftex' should be valid only after an @iftex.
-%
-\def\iftex{\conditionalsucceed{iftex}}
-\defineunmatchedend{iftex}
-
-% We can't just want to start a group at @iftex (for example) and end it
-% at @end iftex, since then @set commands inside the conditional have no
-% effect (they'd get reverted at the end of the group).  So we must
-% define \Eiftex to redefine itself to be its previous value.  (We can't
-% just define it to fail again with an ``unmatched end'' error, since
-% the @ifset might be nested.)
-%
-\def\conditionalsucceed#1{%
-  \edef\temp{%
-    % Remember the current value of \E#1.
-    \let\nece{prevE#1} = \nece{E#1}%
-    %
-    % At the `@end #1', redefine \E#1 to be its previous value.
-    \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
-  }%
-  \temp
-}
-
-% We need to expand lots of \csname's, but we don't want to expand the
-% control sequences after we've constructed them.
-%
-\def\nece#1{\expandafter\noexpand\csname#1\endcsname}
 
 % @asis just yields its argument.  Used with @table, for example.
 %
 \def\asis#1{#1}
 
 % @math means output in math mode.
 % We don't use $'s directly in the definition of \math because control
 % sequences like \math are expanded when the toc file is written.  Then,
@@ -864,261 +796,497 @@ where each line of input produces a line
 %
 \let\implicitmath = $
 \def\math#1{\implicitmath #1\implicitmath}
 
 % @bullet and @minus need the same treatment as @math, just above.
 \def\bullet{\implicitmath\ptexbullet\implicitmath}
 \def\minus{\implicitmath-\implicitmath}
 
-\def\node{\ENVcheck\parsearg\nodezzz}
-\def\nodezzz#1{\nodexxx [#1,]}
-\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
-\let\nwnode=\node
-\let\lastnode=\relax
-
-\def\donoderef{\ifx\lastnode\relax\else
-\expandafter\expandafter\expandafter\setref{\lastnode}\fi
-\global\let\lastnode=\relax}
-
-\def\unnumbnoderef{\ifx\lastnode\relax\else
-\expandafter\expandafter\expandafter\unnumbsetref{\lastnode}\fi
-\global\let\lastnode=\relax}
-
-\def\appendixnoderef{\ifx\lastnode\relax\else
-\expandafter\expandafter\expandafter\appendixsetref{\lastnode}\fi
-\global\let\lastnode=\relax}
-
+% @refill is a no-op.
 \let\refill=\relax
 
+% If working on a large document in chapters, it is convenient to
+% be able to disable indexing, cross-referencing, and contents, for test runs.
+% This is done with @novalidate (before @setfilename).
+%
+\newif\iflinks \linkstrue % by default we want the aux files.
+\let\novalidate = \linksfalse
+
 % @setfilename is done at the beginning of every texinfo file.
 % So open here the files we need to have open while reading the input.
 % This makes it possible to make a .fmt file for texinfo.
 \def\setfilename{%
-   \readauxfile
-   \opencontents
+   \iflinks
+     \readauxfile
+   \fi % \openindices needs to do some work in any case.
    \openindices
    \fixbackslash  % Turn off hack to swallow `\input texinfo'.
    \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
+   %
+   % If texinfo.cnf is present on the system, read it.
+   % Useful for site-wide @afourpaper, etc.
+   % Just to be on the safe side, close the input stream before the \input.
+   \openin 1 texinfo.cnf
+   \ifeof1 \let\temp=\relax \else \def\temp{\input texinfo.cnf }\fi
+   \closein1
+   \temp
+   %
    \comment % Ignore the actual filename.
 }
 
+% Called from \setfilename.
+%
+\def\openindices{%
+  \newindex{cp}%
+  \newcodeindex{fn}%
+  \newcodeindex{vr}%
+  \newcodeindex{tp}%
+  \newcodeindex{ky}%
+  \newcodeindex{pg}%
+}
+
+% @bye.
 \outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
 
-\def\inforef #1{\inforefzzz #1,,,,**}
-\def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
-  node \samp{\ignorespaces#1{}}}
+
+\message{pdf,}
+% adobe `portable' document format
+\newcount\tempnum
+\newcount\lnkcount
+\newtoks\filename
+\newcount\filenamelength
+\newcount\pgn
+\newtoks\toksA
+\newtoks\toksB
+\newtoks\toksC
+\newtoks\toksD
+\newbox\boxA
+\newcount\countA
+\newif\ifpdf
+\newif\ifpdfmakepagedest
+
+\ifx\pdfoutput\undefined
+  \pdffalse
+  \let\pdfmkdest = \gobble
+  \let\pdfurl = \gobble
+  \let\endlink = \relax
+  \let\linkcolor = \relax
+  \let\pdfmakeoutlines = \relax
+\else
+  \pdftrue
+  \pdfoutput = 1
+  \input pdfcolor
+  \def\dopdfimage#1#2#3{%
+    \def\imagewidth{#2}%
+    \def\imageheight{#3}%
+    \ifnum\pdftexversion < 14
+      \pdfimage
+    \else
+      \pdfximage
+    \fi
+      \ifx\empty\imagewidth\else width \imagewidth \fi
+      \ifx\empty\imageheight\else height \imageheight \fi
+      {#1.pdf}%
+    \ifnum\pdftexversion < 14 \else
+      \pdfrefximage \pdflastximage
+    \fi}
+  \def\pdfmkdest#1{\pdfdest name{#1@} xyz}
+  \def\pdfmkpgn#1{#1@}
+  \let\linkcolor = \Cyan
+  \def\endlink{\Black\pdfendlink}
+  % Adding outlines to PDF; macros for calculating structure of outlines
+  % come from Petr Olsak
+  \def\expnumber#1{\expandafter\ifx\csname#1\endcsname\relax 0%
+    \else \csname#1\endcsname \fi}
+  \def\advancenumber#1{\tempnum=\expnumber{#1}\relax
+    \advance\tempnum by1
+    \expandafter\xdef\csname#1\endcsname{\the\tempnum}}
+  \def\pdfmakeoutlines{{%
+    \openin 1 \jobname.toc
+    \ifeof 1\else\bgroup
+      \closein 1 
+      \indexnofonts
+      \def\tt{}
+      % thanh's hack / proper braces in bookmarks  
+      \edef\mylbrace{\iftrue \string{\else}\fi}\let\{=\mylbrace
+      \edef\myrbrace{\iffalse{\else\string}\fi}\let\}=\myrbrace
+      %
+      \def\chapentry ##1##2##3{}
+      \def\unnumbchapentry ##1##2{}
+      \def\secentry ##1##2##3##4{\advancenumber{chap##2}}
+      \def\unnumbsecentry ##1##2{}
+      \def\subsecentry ##1##2##3##4##5{\advancenumber{sec##2.##3}}
+      \def\unnumbsubsecentry ##1##2{}
+      \def\subsubsecentry ##1##2##3##4##5##6{\advancenumber{subsec##2.##3.##4}}
+      \def\unnumbsubsubsecentry ##1##2{}
+      \input \jobname.toc
+      \def\chapentry ##1##2##3{%
+        \pdfoutline goto name{\pdfmkpgn{##3}}count-\expnumber{chap##2}{##1}}
+      \def\unnumbchapentry ##1##2{%
+        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
+      \def\secentry ##1##2##3##4{%
+        \pdfoutline goto name{\pdfmkpgn{##4}}count-\expnumber{sec##2.##3}{##1}}
+      \def\unnumbsecentry ##1##2{%
+        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
+      \def\subsecentry ##1##2##3##4##5{%
+        \pdfoutline goto name{\pdfmkpgn{##5}}count-\expnumber{subsec##2.##3.##4}{##1}}
+      \def\unnumbsubsecentry ##1##2{%
+        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
+      \def\subsubsecentry ##1##2##3##4##5##6{%
+        \pdfoutline goto name{\pdfmkpgn{##6}}{##1}}
+      \def\unnumbsubsubsecentry ##1##2{%
+        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
+      \input \jobname.toc
+    \egroup\fi
+  }}
+  \def\makelinks #1,{%
+    \def\params{#1}\def\E{END}%
+    \ifx\params\E
+      \let\nextmakelinks=\relax
+    \else
+      \let\nextmakelinks=\makelinks
+      \ifnum\lnkcount>0,\fi
+      \picknum{#1}%
+      \startlink attr{/Border [0 0 0]} 
+        goto name{\pdfmkpgn{\the\pgn}}%
+      \linkcolor #1%
+      \advance\lnkcount by 1%
+      \endlink
+    \fi
+    \nextmakelinks
+  }
+  \def\picknum#1{\expandafter\pn#1}
+  \def\pn#1{%
+    \def\p{#1}%
+    \ifx\p\lbrace
+      \let\nextpn=\ppn
+    \else
+      \let\nextpn=\ppnn
+      \def\first{#1}
+    \fi
+    \nextpn
+  }
+  \def\ppn#1{\pgn=#1\gobble}
+  \def\ppnn{\pgn=\first}
+  \def\pdfmklnk#1{\lnkcount=0\makelinks #1,END,}
+  \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
+  \def\skipspaces#1{\def\PP{#1}\def\D{|}%
+    \ifx\PP\D\let\nextsp\relax
+    \else\let\nextsp\skipspaces
+      \ifx\p\space\else\addtokens{\filename}{\PP}%
+        \advance\filenamelength by 1
+      \fi
+    \fi
+    \nextsp}
+  \def\getfilename#1{\filenamelength=0\expandafter\skipspaces#1|\relax}
+  \ifnum\pdftexversion < 14
+    \let \startlink \pdfannotlink
+  \else
+    \let \startlink \pdfstartlink
+  \fi
+  \def\pdfurl#1{%
+    \begingroup
+      \normalturnoffactive\def\@{@}%
+      \leavevmode\Red
+      \startlink attr{/Border [0 0 0]}%
+        user{/Subtype /Link /A << /S /URI /URI (#1) >>}%
+        % #1
+    \endgroup}
+  \def\pdfgettoks#1.{\setbox\boxA=\hbox{\toksA={#1.}\toksB={}\maketoks}}
+  \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
+  \def\adn#1{\addtokens{\toksC}{#1}\global\countA=1\let\next=\maketoks}
+  \def\poptoks#1#2|ENDTOKS|{\let\first=#1\toksD={#1}\toksA={#2}}
+  \def\maketoks{%
+    \expandafter\poptoks\the\toksA|ENDTOKS|
+    \ifx\first0\adn0
+    \else\ifx\first1\adn1 \else\ifx\first2\adn2 \else\ifx\first3\adn3
+    \else\ifx\first4\adn4 \else\ifx\first5\adn5 \else\ifx\first6\adn6
+    \else\ifx\first7\adn7 \else\ifx\first8\adn8 \else\ifx\first9\adn9 
+    \else
+      \ifnum0=\countA\else\makelink\fi
+      \ifx\first.\let\next=\done\else
+        \let\next=\maketoks
+        \addtokens{\toksB}{\the\toksD}
+        \ifx\first,\addtokens{\toksB}{\space}\fi
+      \fi
+    \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
+    \next}
+  \def\makelink{\addtokens{\toksB}%
+    {\noexpand\pdflink{\the\toksC}}\toksC={}\global\countA=0}
+  \def\pdflink#1{%
+    \startlink attr{/Border [0 0 0]} goto name{\mkpgn{#1}}
+    \linkcolor #1\endlink}
+  \def\mkpgn#1{#1@} 
+  \def\done{\edef\st{\global\noexpand\toksA={\the\toksB}}\st}
+\fi % \ifx\pdfoutput
+
 
 \message{fonts,}
-
 % Font-change commands.
 
-% Texinfo supports the sans serif font style, which plain TeX does not.
+% Texinfo sort of supports the sans serif font style, which plain TeX does not.
 % So we set up a \sf analogous to plain's \rm, etc.
 \newfam\sffam
 \def\sf{\fam=\sffam \tensf}
 \let\li = \sf % Sometimes we call it \li, not \sf.
 
-%% Try out Computer Modern fonts at \magstephalf
-\let\mainmagstep=\magstephalf
+% We don't need math for this one.
+\def\ttsl{\tenttsl}
+
+% Use Computer Modern fonts at \magstephalf (11pt).
+\newcount\mainmagstep
+\mainmagstep=\magstephalf
 
 % Set the font macro #1 to the font named #2, adding on the
 % specified font prefix (normally `cm').
-\def\setfont#1#2{\font#1=\fontprefix#2}
+% #3 is the font's design size, #4 is a scale factor
+\def\setfont#1#2#3#4{\font#1=\fontprefix#2#3 scaled #4}
 
 % Use cm as the default font prefix.
 % To specify the font prefix, you must define \fontprefix
 % before you read in texinfo.tex.
 \ifx\fontprefix\undefined
 \def\fontprefix{cm}
 \fi
+% Support font families that don't use the same naming scheme as CM.
+\def\rmshape{r}
+\def\rmbshape{bx}               %where the normal face is bold
+\def\bfshape{b}
+\def\bxshape{bx}
+\def\ttshape{tt}
+\def\ttbshape{tt}
+\def\ttslshape{sltt}
+\def\itshape{ti}
+\def\itbshape{bxti}
+\def\slshape{sl}
+\def\slbshape{bxsl}
+\def\sfshape{ss}
+\def\sfbshape{ss}
+\def\scshape{csc}
+\def\scbshape{csc}
 
 \ifx\bigger\relax
 \let\mainmagstep=\magstep1
-\setfont\textrm{r12}
-\setfont\texttt{tt12}
+\setfont\textrm\rmshape{12}{1000}
+\setfont\texttt\ttshape{12}{1000}
 \else
-\setfont\textrm{r10 scaled \mainmagstep}
-\setfont\texttt{tt10 scaled \mainmagstep}
+\setfont\textrm\rmshape{10}{\mainmagstep}
+\setfont\texttt\ttshape{10}{\mainmagstep}
 \fi
 % Instead of cmb10, you many want to use cmbx10.
 % cmbx10 is a prettier font on its own, but cmb10
 % looks better when embedded in a line with cmr10.
-\setfont\textbf{b10 scaled \mainmagstep}
-\setfont\textit{ti10 scaled \mainmagstep}
-\setfont\textsl{sl10 scaled \mainmagstep}
-\setfont\textsf{ss10 scaled \mainmagstep}
-\setfont\textsc{csc10 scaled \mainmagstep}
+\setfont\textbf\bfshape{10}{\mainmagstep}
+\setfont\textit\itshape{10}{\mainmagstep}
+\setfont\textsl\slshape{10}{\mainmagstep}
+\setfont\textsf\sfshape{10}{\mainmagstep}
+\setfont\textsc\scshape{10}{\mainmagstep}
+\setfont\textttsl\ttslshape{10}{\mainmagstep}
 \font\texti=cmmi10 scaled \mainmagstep
 \font\textsy=cmsy10 scaled \mainmagstep
 
 % A few fonts for @defun, etc.
-\setfont\defbf{bx10 scaled \magstep1} %was 1314
-\setfont\deftt{tt10 scaled \magstep1}
+\setfont\defbf\bxshape{10}{\magstep1} %was 1314
+\setfont\deftt\ttshape{10}{\magstep1}
 \def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
 
-% Fonts for indices and small examples.
-% We actually use the slanted font rather than the italic,
-% because texinfo normally uses the slanted fonts for that.
-% Do not make many font distinctions in general in the index, since they
-% aren't very useful.
-\setfont\ninett{tt9}
-\setfont\indrm{r9}
-\setfont\indit{sl9}
-\let\indsl=\indit
-\let\indtt=\ninett
-\let\indsf=\indrm
-\let\indbf=\indrm
-\setfont\indsc{csc10 at 9pt}
-\font\indi=cmmi9
-\font\indsy=cmsy9
-
-% Fonts for headings
-\setfont\chaprm{bx12 scaled \magstep2}
-\setfont\chapit{ti12 scaled \magstep2}
-\setfont\chapsl{sl12 scaled \magstep2}
-\setfont\chaptt{tt12 scaled \magstep2}
-\setfont\chapsf{ss12 scaled \magstep2}
+% Fonts for indices, footnotes, small examples (9pt).
+\setfont\smallrm\rmshape{9}{1000}
+\setfont\smalltt\ttshape{9}{1000}
+\setfont\smallbf\bfshape{10}{900}
+\setfont\smallit\itshape{9}{1000}
+\setfont\smallsl\slshape{9}{1000}
+\setfont\smallsf\sfshape{9}{1000}
+\setfont\smallsc\scshape{10}{900}
+\setfont\smallttsl\ttslshape{10}{900}
+\font\smalli=cmmi9
+\font\smallsy=cmsy9
+
+% Fonts for title page:
+\setfont\titlerm\rmbshape{12}{\magstep3}
+\setfont\titleit\itbshape{10}{\magstep4}
+\setfont\titlesl\slbshape{10}{\magstep4}
+\setfont\titlett\ttbshape{12}{\magstep3}
+\setfont\titlettsl\ttslshape{10}{\magstep4}
+\setfont\titlesf\sfbshape{17}{\magstep1}
+\let\titlebf=\titlerm
+\setfont\titlesc\scbshape{10}{\magstep4}
+\font\titlei=cmmi12 scaled \magstep3
+\font\titlesy=cmsy10 scaled \magstep4
+\def\authorrm{\secrm}
+
+% Chapter (and unnumbered) fonts (17.28pt).
+\setfont\chaprm\rmbshape{12}{\magstep2}
+\setfont\chapit\itbshape{10}{\magstep3}
+\setfont\chapsl\slbshape{10}{\magstep3}
+\setfont\chaptt\ttbshape{12}{\magstep2}
+\setfont\chapttsl\ttslshape{10}{\magstep3}
+\setfont\chapsf\sfbshape{17}{1000}
 \let\chapbf=\chaprm
-\setfont\chapsc{csc10 scaled\magstep3}
+\setfont\chapsc\scbshape{10}{\magstep3}
 \font\chapi=cmmi12 scaled \magstep2
 \font\chapsy=cmsy10 scaled \magstep3
 
-\setfont\secrm{bx12 scaled \magstep1}
-\setfont\secit{ti12 scaled \magstep1}
-\setfont\secsl{sl12 scaled \magstep1}
-\setfont\sectt{tt12 scaled \magstep1}
-\setfont\secsf{ss12 scaled \magstep1}
-\setfont\secbf{bx12 scaled \magstep1}
-\setfont\secsc{csc10 scaled\magstep2}
+% Section fonts (14.4pt).
+\setfont\secrm\rmbshape{12}{\magstep1}
+\setfont\secit\itbshape{10}{\magstep2}
+\setfont\secsl\slbshape{10}{\magstep2}
+\setfont\sectt\ttbshape{12}{\magstep1}
+\setfont\secttsl\ttslshape{10}{\magstep2}
+\setfont\secsf\sfbshape{12}{\magstep1}
+\let\secbf\secrm
+\setfont\secsc\scbshape{10}{\magstep2}
 \font\seci=cmmi12 scaled \magstep1
 \font\secsy=cmsy10 scaled \magstep2
 
-% \setfont\ssecrm{bx10 scaled \magstep1}    % This size an font looked bad.
-% \setfont\ssecit{cmti10 scaled \magstep1}    % The letters were too crowded.
-% \setfont\ssecsl{sl10 scaled \magstep1}
-% \setfont\ssectt{tt10 scaled \magstep1}
-% \setfont\ssecsf{ss10 scaled \magstep1}
-
-%\setfont\ssecrm{b10 scaled 1315}       % Note the use of cmb rather than cmbx.
-%\setfont\ssecit{ti10 scaled 1315}      % Also, the size is a little larger than
-%\setfont\ssecsl{sl10 scaled 1315}      % being scaled magstep1.
-%\setfont\ssectt{tt10 scaled 1315}
-%\setfont\ssecsf{ss10 scaled 1315}
+% \setfont\ssecrm\bxshape{10}{\magstep1}    % This size an font looked bad.
+% \setfont\ssecit\itshape{10}{\magstep1}    % The letters were too crowded.
+% \setfont\ssecsl\slshape{10}{\magstep1}
+% \setfont\ssectt\ttshape{10}{\magstep1}
+% \setfont\ssecsf\sfshape{10}{\magstep1}
+
+%\setfont\ssecrm\bfshape{10}{1315}      % Note the use of cmb rather than cmbx.
+%\setfont\ssecit\itshape{10}{1315}      % Also, the size is a little larger than
+%\setfont\ssecsl\slshape{10}{1315}      % being scaled magstep1.
+%\setfont\ssectt\ttshape{10}{1315}
+%\setfont\ssecsf\sfshape{10}{1315}
 
 %\let\ssecbf=\ssecrm
 
-\setfont\ssecrm{bx12 scaled \magstephalf}
-\setfont\ssecit{ti12 scaled \magstephalf}
-\setfont\ssecsl{sl12 scaled \magstephalf}
-\setfont\ssectt{tt12 scaled \magstephalf}
-\setfont\ssecsf{ss12 scaled \magstephalf}
-\setfont\ssecbf{bx12 scaled \magstephalf}
-\setfont\ssecsc{csc10 scaled \magstep1}
+% Subsection fonts (13.15pt).
+\setfont\ssecrm\rmbshape{12}{\magstephalf}
+\setfont\ssecit\itbshape{10}{1315}
+\setfont\ssecsl\slbshape{10}{1315}
+\setfont\ssectt\ttbshape{12}{\magstephalf}
+\setfont\ssecttsl\ttslshape{10}{1315}
+\setfont\ssecsf\sfbshape{12}{\magstephalf}
+\let\ssecbf\ssecrm
+\setfont\ssecsc\scbshape{10}{\magstep1}
 \font\sseci=cmmi12 scaled \magstephalf
-\font\ssecsy=cmsy10 scaled \magstep1
+\font\ssecsy=cmsy10 scaled 1315
 % The smallcaps and symbol fonts should actually be scaled \magstep1.5,
 % but that is not a standard magnification.
 
-% Fonts for title page:
-\setfont\titlerm{bx12 scaled \magstep3}
-\let\authorrm = \secrm
-
 % In order for the font changes to affect most math symbols and letters,
 % we have to define the \textfont of the standard families.  Since
 % texinfo doesn't allow for producing subscripts and superscripts, we
 % don't bother to reset \scriptfont and \scriptscriptfont (which would
 % also require loading a lot more fonts).
 %
 \def\resetmathfonts{%
   \textfont0 = \tenrm \textfont1 = \teni \textfont2 = \tensy
   \textfont\itfam = \tenit \textfont\slfam = \tensl \textfont\bffam = \tenbf
   \textfont\ttfam = \tentt \textfont\sffam = \tensf
 }
 
 
 % The font-changing commands redefine the meanings of \tenSTYLE, instead
 % of just \STYLE.  We do this so that font changes will continue to work
 % in math mode, where it is the current \fam that is relevant in most
-% cases, not the current.  Plain TeX does, for example,
-% \def\bf{\fam=\bffam \tenbf}  By redefining \tenbf, we obviate the need
-% to redefine \bf itself.
+% cases, not the current font.  Plain TeX does \def\bf{\fam=\bffam
+% \tenbf}, for example.  By redefining \tenbf, we obviate the need to
+% redefine \bf itself.
 \def\textfonts{%
   \let\tenrm=\textrm \let\tenit=\textit \let\tensl=\textsl
   \let\tenbf=\textbf \let\tentt=\texttt \let\smallcaps=\textsc
-  \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy
+  \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy \let\tenttsl=\textttsl
   \resetmathfonts}
+\def\titlefonts{%
+  \let\tenrm=\titlerm \let\tenit=\titleit \let\tensl=\titlesl
+  \let\tenbf=\titlebf \let\tentt=\titlett \let\smallcaps=\titlesc
+  \let\tensf=\titlesf \let\teni=\titlei \let\tensy=\titlesy
+  \let\tenttsl=\titlettsl
+  \resetmathfonts \setleading{25pt}}
+\def\titlefont#1{{\titlefonts\rm #1}}
 \def\chapfonts{%
   \let\tenrm=\chaprm \let\tenit=\chapit \let\tensl=\chapsl
   \let\tenbf=\chapbf \let\tentt=\chaptt \let\smallcaps=\chapsc
-  \let\tensf=\chapsf \let\teni=\chapi \let\tensy=\chapsy
-  \resetmathfonts}
+  \let\tensf=\chapsf \let\teni=\chapi \let\tensy=\chapsy \let\tenttsl=\chapttsl
+  \resetmathfonts \setleading{19pt}}
 \def\secfonts{%
   \let\tenrm=\secrm \let\tenit=\secit \let\tensl=\secsl
   \let\tenbf=\secbf \let\tentt=\sectt \let\smallcaps=\secsc
-  \let\tensf=\secsf \let\teni=\seci \let\tensy=\secsy
-  \resetmathfonts}
+  \let\tensf=\secsf \let\teni=\seci \let\tensy=\secsy \let\tenttsl=\secttsl
+  \resetmathfonts \setleading{16pt}}
 \def\subsecfonts{%
   \let\tenrm=\ssecrm \let\tenit=\ssecit \let\tensl=\ssecsl
   \let\tenbf=\ssecbf \let\tentt=\ssectt \let\smallcaps=\ssecsc
-  \let\tensf=\ssecsf \let\teni=\sseci \let\tensy=\ssecsy
-  \resetmathfonts}
-\def\indexfonts{%
-  \let\tenrm=\indrm \let\tenit=\indit \let\tensl=\indsl
-  \let\tenbf=\indbf \let\tentt=\indtt \let\smallcaps=\indsc
-  \let\tensf=\indsf \let\teni=\indi \let\tensy=\indsy
-  \resetmathfonts}
+  \let\tensf=\ssecsf \let\teni=\sseci \let\tensy=\ssecsy \let\tenttsl=\ssecttsl
+  \resetmathfonts \setleading{15pt}}
+\let\subsubsecfonts = \subsecfonts % Maybe make sssec fonts scaled magstephalf?
+\def\smallfonts{%
+  \let\tenrm=\smallrm \let\tenit=\smallit \let\tensl=\smallsl
+  \let\tenbf=\smallbf \let\tentt=\smalltt \let\smallcaps=\smallsc
+  \let\tensf=\smallsf \let\teni=\smalli \let\tensy=\smallsy
+  \let\tenttsl=\smallttsl
+  \resetmathfonts \setleading{11pt}}
 
 % Set up the default fonts, so we can use them for creating boxes.
 %
 \textfonts
 
+% Define these so they can be easily changed for other fonts.
+\def\angleleft{$\langle$}
+\def\angleright{$\rangle$}
+
 % Count depth in font-changes, for error checks
 \newcount\fontdepth \fontdepth=0
 
 % Fonts for short table of contents.
-\setfont\shortcontrm{r12}
-\setfont\shortcontbf{bx12}
-\setfont\shortcontsl{sl12}
+\setfont\shortcontrm\rmshape{12}{1000}
+\setfont\shortcontbf\bxshape{12}{1000}
+\setfont\shortcontsl\slshape{12}{1000}
 
 %% Add scribe-like font environments, plus @l for inline lisp (usually sans
 %% serif) and @ii for TeX italic
 
 % \smartitalic{ARG} outputs arg in italics, followed by an italic correction
 % unless the following character is such as not to need one.
 \def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
-\def\smartitalic#1{{\sl #1}\futurelet\next\smartitalicx}
+\def\smartslanted#1{{\sl #1}\futurelet\next\smartitalicx}
+\def\smartitalic#1{{\it #1}\futurelet\next\smartitalicx}
 
 \let\i=\smartitalic
-\let\var=\smartitalic
-\let\dfn=\smartitalic
+\let\var=\smartslanted
+\let\dfn=\smartslanted
 \let\emph=\smartitalic
-\let\cite=\smartitalic
+\let\cite=\smartslanted
 
 \def\b#1{{\bf #1}}
 \let\strong=\b
 
 % We can't just use \exhyphenpenalty, because that only has effect at
 % the end of a paragraph.  Restore normal hyphenation at the end of the
 % group within which \nohyphenation is presumably called.
 %
 \def\nohyphenation{\hyphenchar\font = -1  \aftergroup\restorehyphenation}
 \def\restorehyphenation{\hyphenchar\font = `- }
 
 \def\t#1{%
-  {\tt \nohyphenation \rawbackslash \frenchspacing #1}%
+  {\tt \rawbackslash \frenchspacing #1}%
   \null
 }
-\let\ttfont = \t
-%\def\samp #1{`{\tt \rawbackslash \frenchspacing #1}'\null}
-\def\samp #1{`\tclose{#1}'\null}
-\def\key #1{{\tt \nohyphenation \uppercase{#1}}\null}
+\let\ttfont=\t
+\def\samp#1{`\tclose{#1}'\null}
+\setfont\keyrm\rmshape{8}{1000}
+\font\keysy=cmsy9
+\def\key#1{{\keyrm\textfont2=\keysy \leavevmode\hbox{%
+  \raise0.4pt\hbox{\angleleft}\kern-.08em\vtop{%
+    \vbox{\hrule\kern-0.4pt
+     \hbox{\raise0.4pt\hbox{\vphantom{\angleleft}}#1}}%
+    \kern-0.4pt\hrule}%
+  \kern-.06em\raise0.4pt\hbox{\angleright}}}}
+% The old definition, with no lozenge:
+%\def\key #1{{\ttsl \nohyphenation \uppercase{#1}}\null}
 \def\ctrl #1{{\tt \rawbackslash \hat}#1}
 
+% @file, @option are the same as @samp.
 \let\file=\samp
+\let\option=\samp
 
 % @code is a modification of @t,
 % which makes spaces the same size as normal in the surrounding text.
 \def\tclose#1{%
   {%
     % Change normal interword space to be same as for the current font.
     \spaceskip = \fontdimen2\font
     %
@@ -1134,96 +1302,191 @@ where each line of input produces a line
     \rawbackslash
     \frenchspacing
     #1%
   }%
   \null
 }
 
 % We *must* turn on hyphenation at `-' and `_' in \code.
-% Otherwise, it is too hard to avoid overful hboxes
+% Otherwise, it is too hard to avoid overfull hboxes
 % in the Emacs manual, the Library manual, etc.
 
 % Unfortunately, TeX uses one parameter (\hyphenchar) to control
 % both hyphenation at - and hyphenation within words.
 % We must therefore turn them both off (\tclose does that)
-% and arrange explicitly to hyphenate an a dash.
+% and arrange explicitly to hyphenate at a dash.
 %  -- rms.
 {
-\catcode`\-=\active
-\catcode`\_=\active
-\global\def\code{\begingroup \catcode`\-=\active \let-\codedash \catcode`\_=\active \let_\codeunder \codex}
-% The following is used by \doprintindex to insure that long function names
-% wrap around.  It is necessary for - and _ to be active before the index is
-% read from the file, as \entry parses the arguments long before \code is
-% ever called.  -- mycroft
-\global\def\indexbreaks{\catcode`\-=\active \let-\realdash \catcode`\_=\active \let_\realunder}
+  \catcode`\-=\active
+  \catcode`\_=\active
+  %
+  \global\def\code{\begingroup
+    \catcode`\-=\active \let-\codedash
+    \catcode`\_=\active \let_\codeunder
+    \codex
+  }
+  %
+  % If we end up with any active - characters when handling the index,
+  % just treat them as a normal -.
+  \global\def\indexbreaks{\catcode`\-=\active \let-\realdash}
 }
+
 \def\realdash{-}
-\def\realunder{_}
 \def\codedash{-\discretionary{}{}{}}
-\def\codeunder{\normalunderscore\discretionary{}{}{}}
+\def\codeunder{\ifusingtt{\normalunderscore\discretionary{}{}{}}{\_}}
 \def\codex #1{\tclose{#1}\endgroup}
 
 %\let\exp=\tclose  %Was temporary
 
 % @kbd is like @code, except that if the argument is just one @key command,
 % then @kbd has no effect.
 
+% @kbdinputstyle -- arg is `distinct' (@kbd uses slanted tty font always),
+%   `example' (@kbd uses ttsl only inside of @example and friends),
+%   or `code' (@kbd uses normal tty font always).
+\def\kbdinputstyle{\parsearg\kbdinputstylexxx}
+\def\kbdinputstylexxx#1{%
+  \def\arg{#1}%
+  \ifx\arg\worddistinct
+    \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}%
+  \else\ifx\arg\wordexample
+    \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\tt}%
+  \else\ifx\arg\wordcode
+    \gdef\kbdexamplefont{\tt}\gdef\kbdfont{\tt}%
+  \fi\fi\fi
+}
+\def\worddistinct{distinct}
+\def\wordexample{example}
+\def\wordcode{code}
+
+% Default is kbdinputdistinct.  (Too much of a hassle to call the macro,
+% the catcodes are wrong for parsearg to work.)
+\gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}
+
 \def\xkey{\key}
 \def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
 \ifx\one\xkey\ifx\threex\three \key{#2}%
-\else\tclose{\look}\fi
-\else\tclose{\look}\fi}
+\else{\tclose{\kbdfont\look}}\fi
+\else{\tclose{\kbdfont\look}}\fi}
+
+% For @url, @env, @command quotes seem unnecessary, so use \code.
+\let\url=\code
+\let\env=\code
+\let\command=\code
+
+% @uref (abbreviation for `urlref') takes an optional (comma-separated)
+% second argument specifying the text to display and an optional third
+% arg as text to display instead of (rather than in addition to) the url
+% itself.  First (mandatory) arg is the url.  Perhaps eventually put in
+% a hypertex \special here.
+%
+\def\uref#1{\douref #1,,,\finish}
+\def\douref#1,#2,#3,#4\finish{\begingroup
+  \unsepspaces
+  \pdfurl{#1}%
+  \setbox0 = \hbox{\ignorespaces #3}%
+  \ifdim\wd0 > 0pt
+    \unhbox0 % third arg given, show only that
+  \else
+    \setbox0 = \hbox{\ignorespaces #2}%
+    \ifdim\wd0 > 0pt
+      \ifpdf
+        \unhbox0             % PDF: 2nd arg given, show only it
+      \else
+        \unhbox0\ (\code{#1})% DVI: 2nd arg given, show both it and url
+      \fi
+    \else
+      \code{#1}% only url given, so show it
+    \fi
+  \fi
+  \endlink
+\endgroup}
+
+% rms does not like angle brackets --karl, 17may97.
+% So now @email is just like @uref, unless we are pdf.
+% 
+%\def\email#1{\angleleft{\tt #1}\angleright}
+\ifpdf
+  \def\email#1{\doemail#1,,\finish}
+  \def\doemail#1,#2,#3\finish{\begingroup
+    \unsepspaces
+    \pdfurl{mailto:#1}%
+    \setbox0 = \hbox{\ignorespaces #2}%
+    \ifdim\wd0>0pt\unhbox0\else\code{#1}\fi
+    \endlink
+  \endgroup}
+\else
+  \let\email=\uref
+\fi
+
+% Check if we are currently using a typewriter font.  Since all the
+% Computer Modern typewriter fonts have zero interword stretch (and
+% shrink), and it is reasonable to expect all typewriter fonts to have
+% this property, we can check that font parameter.
+%
+\def\ifmonospace{\ifdim\fontdimen3\font=0pt }
 
 % Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
-% argument is to make the input look right: @dmn{pt} instead of
-% @dmn{}pt.
+% argument is to make the input look right: @dmn{pt} instead of @dmn{}pt.
 %
 \def\dmn#1{\thinspace #1}
 
 \def\kbd#1{\def\look{#1}\expandafter\kbdfoo\look??\par}
 
-\def\l#1{{\li #1}\null}         %
-
+% @l was never documented to mean ``switch to the Lisp font'',
+% and it is not used as such in any manual I can find.  We need it for
+% Polish suppressed-l.  --karl, 22sep96.
+%\def\l#1{{\li #1}\null}
+
+% Explicit font changes: @r, @sc, undocumented @ii.
 \def\r#1{{\rm #1}}              % roman font
-% Use of \lowercase was suggested.
 \def\sc#1{{\smallcaps#1}}       % smallcaps font
 \def\ii#1{{\it #1}}             % italic font
 
+% @acronym downcases the argument and prints in smallcaps.
+\def\acronym#1{{\smallcaps \lowercase{#1}}}
+
+% @pounds{} is a sterling sign.
+\def\pounds{{\it\$}}
+
+
 \message{page headings,}
 
 \newskip\titlepagetopglue \titlepagetopglue = 1.5in
 \newskip\titlepagebottomglue \titlepagebottomglue = 2pc
 
 % First the title page.  Must do @settitle before @titlepage.
-\def\titlefont#1{{\titlerm #1}}
-
 \newif\ifseenauthor
 \newif\iffinishedtitlepage
 
+% Do an implicit @contents or @shortcontents after @end titlepage if the
+% user says @setcontentsaftertitlepage or @setshortcontentsaftertitlepage.
+%
+\newif\ifsetcontentsaftertitlepage
+ \let\setcontentsaftertitlepage = \setcontentsaftertitlepagetrue
+\newif\ifsetshortcontentsaftertitlepage
+ \let\setshortcontentsaftertitlepage = \setshortcontentsaftertitlepagetrue
+
 \def\shorttitlepage{\parsearg\shorttitlepagezzz}
 \def\shorttitlepagezzz #1{\begingroup\hbox{}\vskip 1.5in \chaprm \centerline{#1}%
         \endgroup\page\hbox{}\page}
 
 \def\titlepage{\begingroup \parindent=0pt \textfonts
    \let\subtitlerm=\tenrm
-% I deinstalled the following change because \cmr12 is undefined.
-% This change was not in the ChangeLog anyway.  --rms.
-%   \let\subtitlerm=\cmr12
    \def\subtitlefont{\subtitlerm \normalbaselineskip = 13pt \normalbaselines}%
    %
    \def\authorfont{\authorrm \normalbaselineskip = 16pt \normalbaselines}%
    %
    % Leave some space at the very top of the page.
    \vglue\titlepagetopglue
    %
    % Now you can print the title using @title.
    \def\title{\parsearg\titlezzz}%
-   \def\titlezzz##1{\leftline{\titlefont{##1}}
+   \def\titlezzz##1{\leftline{\titlefonts\rm ##1}
                     % print a rule at the page bottom also.
                     \finishedtitlepagefalse
                     \vskip4pt \hrule height 4pt width \hsize \vskip4pt}%
    % No rule at page bottom unless we print one at the top with @title.
    \finishedtitlepagetrue
    %
    % Now you can put text using @subtitle.
    \def\subtitle{\parsearg\subtitlezzz}%
@@ -1252,33 +1515,50 @@ where each line of input produces a line
       \finishtitlepage
    \fi
    % It is important to do the page break before ending the group,
    % because the headline and footline are only empty inside the group.
    % If we use the new definition of \page, we always get a blank page
    % after the title page, which we certainly don't want.
    \oldpage
    \endgroup
+   %
+   % If they want short, they certainly want long too.
+   \ifsetshortcontentsaftertitlepage
+     \shortcontents
+     \contents
+     \global\let\shortcontents = \relax
+     \global\let\contents = \relax
+   \fi
+   %
+   \ifsetcontentsaftertitlepage
+     \contents
+     \global\let\contents = \relax
+     \global\let\shortcontents = \relax
+   \fi
+   %
+   \ifpdf \pdfmakepagedesttrue \fi
+   %
    \HEADINGSon
 }
 
 \def\finishtitlepage{%
    \vskip4pt \hrule height 2pt width \hsize
    \vskip\titlepagebottomglue
    \finishedtitlepagetrue
 }
 
 %%% Set up page headings and footings.
 
 \let\thispage=\folio
 
-\newtoks \evenheadline    % Token sequence for heading line of even pages
-\newtoks \oddheadline     % Token sequence for heading line of odd pages
-\newtoks \evenfootline    % Token sequence for footing line of even pages
-\newtoks \oddfootline     % Token sequence for footing line of odd pages
+\newtoks\evenheadline    % headline on even pages
+\newtoks\oddheadline     % headline on odd pages
+\newtoks\evenfootline    % footline on even pages
+\newtoks\oddfootline     % footline on odd pages
 
 % Now make Tex use those variables
 \headline={{\textfonts\rm \ifodd\pageno \the\oddheadline
                             \else \the\evenheadline \fi}}
 \footline={{\textfonts\rm \ifodd\pageno \the\oddfootline
                             \else \the\evenfootline \fi}\HEADINGShook}
 \let\HEADINGShook=\relax
 
@@ -1302,127 +1582,117 @@ where each line of input produces a line
 \gdef\evenheadingxxx #1{\evenheadingyyy #1@|@|@|@|\finish}
 \gdef\evenheadingyyy #1@|#2@|#3@|#4\finish{%
 \global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
 
 \gdef\oddheadingxxx #1{\oddheadingyyy #1@|@|@|@|\finish}
 \gdef\oddheadingyyy #1@|#2@|#3@|#4\finish{%
 \global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
 
-\gdef\everyheadingxxx #1{\everyheadingyyy #1@|@|@|@|\finish}
-\gdef\everyheadingyyy #1@|#2@|#3@|#4\finish{%
-\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
-\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+\gdef\everyheadingxxx#1{\oddheadingxxx{#1}\evenheadingxxx{#1}}%
 
 \gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
 \gdef\evenfootingyyy #1@|#2@|#3@|#4\finish{%
 \global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
 
 \gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
 \gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
-\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
-
-\gdef\everyfootingxxx #1{\everyfootingyyy #1@|@|@|@|\finish}
-\gdef\everyfootingyyy #1@|#2@|#3@|#4\finish{%
-\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
-\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+  \global\oddfootline = {\rlap{\centerline{#2}}\line{#1\hfil#3}}%
+  %
+  % Leave some space for the footline.  Hopefully ok to assume
+  % @evenfooting will not be used by itself.
+  \global\advance\pageheight by -\baselineskip
+  \global\advance\vsize by -\baselineskip
+}
+
+\gdef\everyfootingxxx#1{\oddfootingxxx{#1}\evenfootingxxx{#1}}
 %
 }% unbind the catcode of @.
 
 % @headings double      turns headings on for double-sided printing.
 % @headings single      turns headings on for single-sided printing.
 % @headings off         turns them off.
 % @headings on          same as @headings double, retained for compatibility.
 % @headings after       turns on double-sided headings after this page.
 % @headings doubleafter turns on double-sided headings after this page.
 % @headings singleafter turns on single-sided headings after this page.
-% By default, they are off.
+% By default, they are off at the start of a document,
+% and turned `on' after @end titlepage.
 
 \def\headings #1 {\csname HEADINGS#1\endcsname}
 
 \def\HEADINGSoff{
 \global\evenheadline={\hfil} \global\evenfootline={\hfil}
 \global\oddheadline={\hfil} \global\oddfootline={\hfil}}
 \HEADINGSoff
 % When we turn headings on, set the page number to 1.
 % For double-sided printing, put current file name in lower left corner,
 % chapter name on inside top of right hand pages, document
 % title on inside top of left hand pages, and page numbers on outside top
 % edge of all pages.
 \def\HEADINGSdouble{
-%\pagealignmacro
 \global\pageno=1
 \global\evenfootline={\hfil}
 \global\oddfootline={\hfil}
 \global\evenheadline={\line{\folio\hfil\thistitle}}
 \global\oddheadline={\line{\thischapter\hfil\folio}}
+\global\let\contentsalignmacro = \chapoddpage
 }
+\let\contentsalignmacro = \chappager
+
 % For single-sided printing, chapter title goes across top left of page,
 % page number on top right.
 \def\HEADINGSsingle{
-%\pagealignmacro
 \global\pageno=1
 \global\evenfootline={\hfil}
 \global\oddfootline={\hfil}
 \global\evenheadline={\line{\thischapter\hfil\folio}}
 \global\oddheadline={\line{\thischapter\hfil\folio}}
+\global\let\contentsalignmacro = \chappager
 }
 \def\HEADINGSon{\HEADINGSdouble}
 
 \def\HEADINGSafter{\let\HEADINGShook=\HEADINGSdoublex}
 \let\HEADINGSdoubleafter=\HEADINGSafter
 \def\HEADINGSdoublex{%
 \global\evenfootline={\hfil}
 \global\oddfootline={\hfil}
 \global\evenheadline={\line{\folio\hfil\thistitle}}
 \global\oddheadline={\line{\thischapter\hfil\folio}}
+\global\let\contentsalignmacro = \chapoddpage
 }
 
 \def\HEADINGSsingleafter{\let\HEADINGShook=\HEADINGSsinglex}
 \def\HEADINGSsinglex{%
 \global\evenfootline={\hfil}
 \global\oddfootline={\hfil}
 \global\evenheadline={\line{\thischapter\hfil\folio}}
 \global\oddheadline={\line{\thischapter\hfil\folio}}
+\global\let\contentsalignmacro = \chappager
 }
 
 % Subroutines used in generating headings
 % Produces Day Month Year style of output.
-\def\today{\number\day\space
-\ifcase\month\or
-January\or February\or March\or April\or May\or June\or
-July\or August\or September\or October\or November\or December\fi
-\space\number\year}
-
-% Use this if you want the Month Day, Year style of output.
-%\def\today{\ifcase\month\or
-%January\or February\or March\or April\or May\or June\or
-%July\or August\or September\or October\or November\or December\fi
-%\space\number\day, \number\year}
-
-% @settitle line...  specifies the title of the document, for headings
-% It generates no output of its own
-
-\def\thistitle{No Title}
+\def\today{%
+  \number\day\space
+  \ifcase\month
+  \or\putwordMJan\or\putwordMFeb\or\putwordMMar\or\putwordMApr
+  \or\putwordMMay\or\putwordMJun\or\putwordMJul\or\putwordMAug
+  \or\putwordMSep\or\putwordMOct\or\putwordMNov\or\putwordMDec
+  \fi
+  \space\number\year}
+
+% @settitle line...  specifies the title of the document, for headings.
+% It generates no output of its own.
+\def\thistitle{\putwordNoTitle}
 \def\settitle{\parsearg\settitlezzz}
 \def\settitlezzz #1{\gdef\thistitle{#1}}
 
+
 \message{tables,}
-
-% @tabs -- simple alignment
-
-% These don't work.  For one thing, \+ is defined as outer.
-% So these macros cannot even be defined.
-
-%\def\tabs{\parsearg\tabszzz}
-%\def\tabszzz #1{\settabs\+#1\cr}
-%\def\tabline{\parsearg\tablinezzz}
-%\def\tablinezzz #1{\+#1\cr}
-%\def\&{&}
-
 % Tables -- @table, @ftable, @vtable, @item(x), @kitem(x), @xitem(x).
 
 % default indentation of table text
 \newdimen\tableindent \tableindent=.8in
 % default indentation of @itemize and @enumerate text
 \newdimen\itemindent  \itemindent=.3in
 % margin between end of table item and start of table text.
 \newdimen\itemmargin  \itemmargin=.1in
@@ -1432,17 +1702,17 @@ July\or August\or September\or October\o
 
 % Note @table, @vtable, and @vtable define @item, @itemx, etc., with
 % these defs.
 % They also define \itemindex
 % to index the item name in whatever manner is desired (perhaps none).
 
 \newif\ifitemxneedsnegativevskip
 
-\def\itemxpar{\par\ifitemxneedsnegativevskip\vskip-\parskip\nobreak\fi}
+\def\itemxpar{\par\ifitemxneedsnegativevskip\nobreak\vskip-\parskip\nobreak\fi}
 
 \def\internalBitem{\smallbreak \parsearg\itemzzz}
 \def\internalBitemx{\itemxpar \parsearg\itemzzz}
 
 \def\internalBxitem "#1"{\def\xitemsubtopix{#1} \smallbreak \parsearg\xitemzzz}
 \def\internalBxitemx "#1"{\def\xitemsubtopix{#1} \itemxpar \parsearg\xitemzzz}
 
 \def\internalBkitem{\smallbreak \parsearg\kitemzzz}
@@ -1456,21 +1726,16 @@ July\or August\or September\or October\o
 
 \def\itemzzz #1{\begingroup %
   \advance\hsize by -\rightskip
   \advance\hsize by -\tableindent
   \setbox0=\hbox{\itemfont{#1}}%
   \itemindex{#1}%
   \nobreak % This prevents a break before @itemx.
   %
-  % Be sure we are not still in the middle of a paragraph.
-  %{\parskip = 0in
-  %\par
-  %}%
-  %
   % If the item text does not fit in the space we have, put it on a line
   % by itself, and do not allow a page break either before or after that
   % line.  We do not start a paragraph here because then if the next
   % command is, e.g., @kindex, the whatsit would get put into the
   % horizontal list on a line by itself, resulting in extra blank space.
   \ifdim \wd0>\itemmax
     %
     % Make this a paragraph so we get the \parskip glue and wrapping,
@@ -1489,36 +1754,41 @@ July\or August\or September\or October\o
     % Stop a page break at the \parskip glue coming up.  Unfortunately
     % we can't prevent a possible page break at the following
     % \baselineskip glue.
     \nobreak
     \endgroup
     \itemxneedsnegativevskipfalse
   \else
     % The item text fits into the space.  Start a paragraph, so that the
-    % following text (if any) will end up on the same line.  Since that
-    % text will be indented by \tableindent, we make the item text be in
-    % a zero-width box.
+    % following text (if any) will end up on the same line.
     \noindent
-    \rlap{\hskip -\tableindent\box0}\ignorespaces%
-    \endgroup%
-    \itemxneedsnegativevskiptrue%
+    % Do this with kerns and \unhbox so that if there is a footnote in
+    % the item text, it can migrate to the main vertical list and
+    % eventually be printed.
+    \nobreak\kern-\tableindent
+    \dimen0 = \itemmax  \advance\dimen0 by \itemmargin \advance\dimen0 by -\wd0
+    \unhbox0
+    \nobreak\kern\dimen0
+    \endgroup
+    \itemxneedsnegativevskiptrue
   \fi
 }
 
 \def\item{\errmessage{@item while not in a table}}
 \def\itemx{\errmessage{@itemx while not in a table}}
 \def\kitem{\errmessage{@kitem while not in a table}}
 \def\kitemx{\errmessage{@kitemx while not in a table}}
 \def\xitem{\errmessage{@xitem while not in a table}}
 \def\xitemx{\errmessage{@xitemx while not in a table}}
 
-%% Contains a kludge to get @end[description] to work
+% Contains a kludge to get @end[description] to work.
 \def\description{\tablez{\dontindex}{1}{}{}{}{}}
 
+% @table, @ftable, @vtable.
 \def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
 {\obeylines\obeyspaces%
 \gdef\tablex #1^^M{%
 \tabley\dontindex#1        \endtabley}}
 
 \def\ftable{\begingroup\inENV\obeylines\obeyspaces\ftablex}
 {\obeylines\obeyspaces%
 \gdef\ftablex #1^^M{%
@@ -1539,17 +1809,17 @@ July\or August\or September\or October\o
 
 {\obeyspaces %
 \gdef\tabley#1#2 #3 #4 #5 #6 #7\endtabley{\endgroup%
 \tablez{#1}{#2}{#3}{#4}{#5}{#6}}}
 
 \def\tablez #1#2#3#4#5#6{%
 \aboveenvbreak %
 \begingroup %
-\def\Edescription{\Etable}% Neccessary kludge.
+\def\Edescription{\Etable}% Necessary kludge.
 \let\itemindex=#1%
 \ifnum 0#3>0 \advance \leftskip by #3\mil \fi %
 \ifnum 0#4>0 \tableindent=#4\mil \fi %
 \ifnum 0#5>0 \advance \rightskip by #5\mil \fi %
 \def\itemfont{#2}%
 \itemmax=\tableindent %
 \advance \itemmax by -\itemmargin %
 \advance \leftskip by \tableindent %
@@ -1568,17 +1838,17 @@ July\or August\or September\or October\o
 
 % This is the counter used by @enumerate, which is really @itemize
 
 \newcount \itemno
 
 \def\itemize{\parsearg\itemizezzz}
 
 \def\itemizezzz #1{%
-  \begingroup % ended by the @end itemsize
+  \begingroup % ended by the @end itemize
   \itemizey {#1}{\Eitemize}
 }
 
 \def\itemizey #1#2{%
 \aboveenvbreak %
 \itemmax=\itemindent %
 \advance \itemmax by -\itemmargin %
 \advance \leftskip by \itemindent %
@@ -1696,229 +1966,668 @@ July\or August\or September\or October\o
 \def\Ealphaenumerate{\Eenumerate}
 \def\Ecapsenumerate{\Eenumerate}
 
 % Definition of @item while inside @itemize.
 
 \def\itemizeitem{%
 \advance\itemno by 1
 {\let\par=\endgraf \smallbreak}%
-\ifhmode \errmessage{\in hmode at itemizeitem}\fi
+\ifhmode \errmessage{In hmode at itemizeitem}\fi
 {\parskip=0in \hskip 0pt
 \hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
 \vadjust{\penalty 1200}}%
 \flushcr}
 
 % @multitable macros
-% Amy Hendrickson, 8/18/94
+% Amy Hendrickson, 8/18/94, 3/6/96
 %
-% @multitable ... @endmultitable will make as many columns as desired.
-% Contents of each column will wrap at width given in preamble. Width
+% @multitable ... @end multitable will make as many columns as desired.
+% Contents of each column will wrap at width given in preamble.  Width
 % can be specified either with sample text given in a template line,
 % or in percent of \hsize, the current width of text on page.
 
 % Table can continue over pages but will only break between lines.
 
 % To make preamble:
 %
-% Either define widths of columns in terms of percent of \hsize: 
-%   @multitable @percentofhsize .2 .3 .5
+% Either define widths of columns in terms of percent of \hsize:
+%   @multitable @columnfractions .25 .3 .45
 %   @item ...
 %
-%   Numbers following @percentofhsize are the percent of the total
+%   Numbers following @columnfractions are the percent of the total
 %   current hsize to be used for each column. You may use as many
 %   columns as desired.
 
+
 % Or use a template:
 %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
 %   @item ...
 %   using the widest term desired in each column.
-
-
-% Each new table line starts with @item, each subsequent new column 
+%
+% For those who want to use more than one line's worth of words in
+% the preamble, break the line within one argument and it
+% will parse correctly, i.e.,
+%
+%     @multitable {Column 1 template} {Column 2 template} {Column 3
+%      template}
+% Not:
+%     @multitable {Column 1 template} {Column 2 template}
+%      {Column 3 template}
+
+% Each new table line starts with @item, each subsequent new column
 % starts with @tab. Empty columns may be produced by supplying @tab's
 % with nothing between them for as many times as empty columns are needed,
 % ie, @tab@tab@tab will produce two empty columns.
 
-% @item, @tab, @multicolumn or @endmulticolumn do not need to be on their
+% @item, @tab, @multitable or @end multitable do not need to be on their
 % own lines, but it will not hurt if they are.
 
 % Sample multitable:
 
 %   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
 %   @item first col stuff @tab second col stuff @tab third col
-%   @item 
-%   first col stuff 
-%   @tab 
-%   second col stuff 
-%   @tab 
-%   third col 
-%   @item first col stuff @tab second col stuff 
+%   @item
+%   first col stuff
+%   @tab
+%   second col stuff
+%   @tab
+%   third col
+%   @item first col stuff @tab second col stuff
 %   @tab Many paragraphs of text may be used in any column.
-%     
+%
 %         They will wrap at the width determined by the template.
 %   @item@tab@tab This will be in third column.
-%   @endmultitable
+%   @end multitable
 
 % Default dimensions may be reset by user.
-% @intableparskip will set vertical space between paragraphs in table.
-% @intableparindent will set paragraph indent in table.
-% @spacebetweencols will set horizontal space to be left between columns.
-% @spacebetweenlines will set vertical space to be left between lines.
-
-%%%%
-% Dimensions 
-
-\newdimen\intableparskip
-\newdimen\intableparindent
-\newdimen\spacebetweencols
-\newdimen\spacebetweenlines
-\intableparskip=0pt
-\intableparindent=6pt
-\spacebetweencols=12pt
-\spacebetweenlines=12pt
-
-%%%%
+% @multitableparskip is vertical space between paragraphs in table.
+% @multitableparindent is paragraph indent in table.
+% @multitablecolmargin is horizontal space to be left between columns.
+% @multitablelinespace is space to leave between table items, baseline
+%                                                            to baseline.
+%   0pt means it depends on current normal line spacing.
+%
+\newskip\multitableparskip
+\newskip\multitableparindent
+\newdimen\multitablecolspace
+\newskip\multitablelinespace
+\multitableparskip=0pt
+\multitableparindent=6pt
+\multitablecolspace=12pt
+\multitablelinespace=0pt
+
 % Macros used to set up halign preamble:
+%
 \let\endsetuptable\relax
 \def\xendsetuptable{\endsetuptable}
-\let\percentofhsize\relax
-\def\xpercentofhsize{\percentofhsize}
+\let\columnfractions\relax
+\def\xcolumnfractions{\columnfractions}
 \newif\ifsetpercent
 
+% #1 is the part of the @columnfraction before the decimal point, which
+% is presumably either 0 or the empty string (but we don't check, we
+% just throw it away).  #2 is the decimal part, which we use as the
+% percent of \hsize for this column.
+\def\pickupwholefraction#1.#2 {%
+  \global\advance\colcount by 1
+  \expandafter\xdef\csname col\the\colcount\endcsname{.#2\hsize}%
+  \setuptable
+}
+
 \newcount\colcount
-\def\setuptable#1{\def\firstarg{#1}%
-\ifx\firstarg\xendsetuptable\let\go\relax%
-\else
-  \ifx\firstarg\xpercentofhsize\global\setpercenttrue%
+\def\setuptable#1{%
+  \def\firstarg{#1}%
+  \ifx\firstarg\xendsetuptable
+    \let\go = \relax
   \else
-    \ifsetpercent
-       \if#1.\else%
-       \global\advance\colcount by1 %
-       \expandafter\xdef\csname col\the\colcount\endcsname{.#1\hsize}%
-       \fi
+    \ifx\firstarg\xcolumnfractions
+      \global\setpercenttrue
     \else
-       \global\advance\colcount by1
-       \setbox0=\hbox{#1}%
-       \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
+      \ifsetpercent
+         \let\go\pickupwholefraction
+      \else
+         \global\advance\colcount by 1
+         \setbox0=\hbox{#1\unskip }% Add a normal word space as a separator;
+                            % typically that is always in the input, anyway.
+         \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
+      \fi
+    \fi
+    \ifx\go\pickupwholefraction
+      % Put the argument back for the \pickupwholefraction call, so
+      % we'll always have a period there to be parsed.
+      \def\go{\pickupwholefraction#1}%
+    \else
+      \let\go = \setuptable
     \fi%
-  \fi%
-  \let\go\setuptable%
-\fi\go}
-%%%%
-% multitable syntax
+  \fi
+  \go
+}
+
+% This used to have \hskip1sp.  But then the space in a template line is
+% not enough.  That is bad.  So let's go back to just & until we
+% encounter the problem it was intended to solve again.
+% --karl, nathan@acm.org, 20apr99.
 \def\tab{&}
 
-%%%%
-% @multitable ... @endmultitable definitions:
-
-\def\multitable#1\item{\bgroup
-\let\item\cr
-\tolerance=9500
-\hbadness=9500
-\parskip=\intableparskip
-\parindent=\intableparindent
-\overfullrule=0pt
-\global\colcount=0\relax%
-\def\Emultitable{\global\setpercentfalse\global\everycr{}\cr\egroup\egroup}%
- % To parse everything between @multitable and @item :
-\def\one{#1}\expandafter\setuptable\one\endsetuptable
- % Need to reset this to 0 after \setuptable.
-\global\colcount=0\relax% 
- %
- % This preamble sets up a generic column definition, which will
- % be used as many times as user calls for columns.
- % \vtop will set a single line and will also let text wrap and 
- % continue for many paragraphs if desired.
-\halign\bgroup&\global\advance\colcount by 1\relax%
-\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
- % In order to keep entries from bumping into each other
- % we will add a \leftskip of \spacebetweencols to all columns after
- % the first one.
- %  If a template has been used, we will add \spacebetweencols 
- % to the width of each template entry.
- %  If user has set preamble in terms of percent of \hsize
- % we will use that dimension as the width of the column, and
- % the \leftskip will keep entries from bumping into each other.
- % Table will start at left margin and final column will justify at
- % right margin.
-\ifnum\colcount=1
+% @multitable ... @end multitable definitions:
+%
+\def\multitable{\parsearg\dotable}
+\def\dotable#1{\bgroup
+  \vskip\parskip
+  \let\item\crcr
+  \tolerance=9500
+  \hbadness=9500
+  \setmultitablespacing
+  \parskip=\multitableparskip
+  \parindent=\multitableparindent
+  \overfullrule=0pt
+  \global\colcount=0
+  \def\Emultitable{\global\setpercentfalse\cr\egroup\egroup}%
+  %
+  % To parse everything between @multitable and @item:
+  \setuptable#1 \endsetuptable
+  %
+  % \everycr will reset column counter, \colcount, at the end of
+  % each line. Every column entry will cause \colcount to advance by one.
+  % The table preamble
+  % looks at the current \colcount to find the correct column width.
+  \everycr{\noalign{%
+  %
+  % \filbreak%% keeps underfull box messages off when table breaks over pages.
+  % Maybe so, but it also creates really weird page breaks when the table
+  % breaks over pages. Wouldn't \vfil be better?  Wait until the problem
+  % manifests itself, so it can be fixed for real --karl.
+    \global\colcount=0\relax}}%
+  %
+  % This preamble sets up a generic column definition, which will
+  % be used as many times as user calls for columns.
+  % \vtop will set a single line and will also let text wrap and
+  % continue for many paragraphs if desired.
+  \halign\bgroup&\global\advance\colcount by 1\relax
+    \multistrut\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
+  %
+  % In order to keep entries from bumping into each other
+  % we will add a \leftskip of \multitablecolspace to all columns after
+  % the first one.
+  %
+  % If a template has been used, we will add \multitablecolspace
+  % to the width of each template entry.
+  %
+  % If the user has set preamble in terms of percent of \hsize we will
+  % use that dimension as the width of the column, and the \leftskip
+  % will keep entries from bumping into each other.  Table will start at
+  % left margin and final column will justify at right margin.
+  %
+  % Make sure we don't inherit \rightskip from the outer environment.
+  \rightskip=0pt
+  \ifnum\colcount=1
+    % The first column will be indented with the surrounding text.
+    \advance\hsize by\leftskip
+  \else
+    \ifsetpercent \else
+      % If user has not set preamble in terms of percent of \hsize
+      % we will advance \hsize by \multitablecolspace.
+      \advance\hsize by \multitablecolspace
+    \fi
+   % In either case we will make \leftskip=\multitablecolspace:
+  \leftskip=\multitablecolspace
+  \fi
+  % Ignoring space at the beginning and end avoids an occasional spurious
+  % blank line, when TeX decides to break the line at the space before the
+  % box from the multistrut, so the strut ends up on a line by itself.
+  % For example:
+  % @multitable @columnfractions .11 .89
+  % @item @code{#}
+  % @tab Legal holiday which is valid in major parts of the whole country.
+  % Is automatically provided with highlighting sequences respectively marking
+  % characters.
+  \noindent\ignorespaces##\unskip\multistrut}\cr
+}
+
+\def\setmultitablespacing{% test to see if user has set \multitablelinespace.
+% If so, do nothing. If not, give it an appropriate dimension based on
+% current baselineskip.
+\ifdim\multitablelinespace=0pt
+\setbox0=\vbox{X}\global\multitablelinespace=\the\baselineskip
+\global\advance\multitablelinespace by-\ht0
+%% strut to put in table in case some entry doesn't have descenders,
+%% to keep lines equally spaced
+\let\multistrut = \strut
 \else
-  \ifsetpercent
-  \else
-   % If user has <not> set preamble in terms of percent of \hsize
-   % we will advance \hsize by \spacebetweencols 
-  \advance\hsize by \spacebetweencols
+%% FIXME: what is \box0 supposed to be?
+\gdef\multistrut{\vrule height\multitablelinespace depth\dp0
+width0pt\relax} \fi
+%% Test to see if parskip is larger than space between lines of
+%% table. If not, do nothing.
+%%        If so, set to same dimension as multitablelinespace.
+\ifdim\multitableparskip>\multitablelinespace
+\global\multitableparskip=\multitablelinespace
+\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
+                                      %% than skip between lines in the table.
+\fi%
+\ifdim\multitableparskip=0pt
+\global\multitableparskip=\multitablelinespace
+\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
+                                      %% than skip between lines in the table.
+\fi}
+
+
+\message{conditionals,}
+% Prevent errors for section commands.
+% Used in @ignore and in failing conditionals.
+\def\ignoresections{%
+  \let\chapter=\relax
+  \let\unnumbered=\relax
+  \let\top=\relax
+  \let\unnumberedsec=\relax
+  \let\unnumberedsection=\relax
+  \let\unnumberedsubsec=\relax
+  \let\unnumberedsubsection=\relax
+  \let\unnumberedsubsubsec=\relax
+  \let\unnumberedsubsubsection=\relax
+  \let\section=\relax
+  \let\subsec=\relax
+  \let\subsubsec=\relax
+  \let\subsection=\relax
+  \let\subsubsection=\relax
+  \let\appendix=\relax
+  \let\appendixsec=\relax
+  \let\appendixsection=\relax
+  \let\appendixsubsec=\relax
+  \let\appendixsubsection=\relax
+  \let\appendixsubsubsec=\relax
+  \let\appendixsubsubsection=\relax
+  \let\contents=\relax
+  \let\smallbook=\relax
+  \let\titlepage=\relax
+}
+
+% Used in nested conditionals, where we have to parse the Texinfo source
+% and so want to turn off most commands, in case they are used
+% incorrectly.
+%
+\def\ignoremorecommands{%
+  \let\defcodeindex = \relax
+  \let\defcv = \relax
+  \let\deffn = \relax
+  \let\deffnx = \relax
+  \let\defindex = \relax
+  \let\defivar = \relax
+  \let\defmac = \relax
+  \let\defmethod = \relax
+  \let\defop = \relax
+  \let\defopt = \relax
+  \let\defspec = \relax
+  \let\deftp = \relax
+  \let\deftypefn = \relax
+  \let\deftypefun = \relax
+  \let\deftypeivar = \relax
+  \let\deftypeop = \relax
+  \let\deftypevar = \relax
+  \let\deftypevr = \relax
+  \let\defun = \relax
+  \let\defvar = \relax
+  \let\defvr = \relax
+  \let\ref = \relax
+  \let\xref = \relax
+  \let\printindex = \relax
+  \let\pxref = \relax
+  \let\settitle = \relax
+  \let\setchapternewpage = \relax
+  \let\setchapterstyle = \relax
+  \let\everyheading = \relax
+  \let\evenheading = \relax
+  \let\oddheading = \relax
+  \let\everyfooting = \relax
+  \let\evenfooting = \relax
+  \let\oddfooting = \relax
+  \let\headings = \relax
+  \let\include = \relax
+  \let\lowersections = \relax
+  \let\down = \relax
+  \let\raisesections = \relax
+  \let\up = \relax
+  \let\set = \relax
+  \let\clear = \relax
+  \let\item = \relax
+}
+
+% Ignore @ignore ... @end ignore.
+%
+\def\ignore{\doignore{ignore}}
+
+% Ignore @ifinfo, @ifhtml, @ifnottex, @html, @menu, and @direntry text.
+%
+\def\ifinfo{\doignore{ifinfo}}
+\def\ifhtml{\doignore{ifhtml}}
+\def\ifnottex{\doignore{ifnottex}}
+\def\html{\doignore{html}}
+\def\menu{\doignore{menu}}
+\def\direntry{\doignore{direntry}}
+
+% @dircategory CATEGORY  -- specify a category of the dir file
+% which this file should belong to.  Ignore this in TeX.
+\let\dircategory = \comment
+
+% Ignore text until a line `@end #1'.
+%
+\def\doignore#1{\begingroup
+  % Don't complain about control sequences we have declared \outer.
+  \ignoresections
+  %
+  % Define a command to swallow text until we reach `@end #1'.
+  % This @ is a catcode 12 token (that is the normal catcode of @ in
+  % this texinfo.tex file).  We change the catcode of @ below to match.
+  \long\def\doignoretext##1@end #1{\enddoignore}%
+  %
+  % Make sure that spaces turn into tokens that match what \doignoretext wants.
+  \catcode32 = 10
+  %
+  % Ignore braces, too, so mismatched braces don't cause trouble.
+  \catcode`\{ = 9
+  \catcode`\} = 9
+  %
+  % We must not have @c interpreted as a control sequence.
+  \catcode`\@ = 12
+  %
+  % Make the letter c a comment character so that the rest of the line
+  % will be ignored. This way, the document can have (for example)
+  %   @c @end ifinfo
+  % and the @end ifinfo will be properly ignored.
+  % (We've just changed @ to catcode 12.)
+  \catcode`\c = 14
+  %
+  % And now expand that command.
+  \doignoretext
+}
+
+% What we do to finish off ignored text.
+%
+\def\enddoignore{\endgroup\ignorespaces}%
+
+\newif\ifwarnedobs\warnedobsfalse
+\def\obstexwarn{%
+  \ifwarnedobs\relax\else
+  % We need to warn folks that they may have trouble with TeX 3.0.
+  % This uses \immediate\write16 rather than \message to get newlines.
+    \immediate\write16{}
+    \immediate\write16{WARNING: for users of Unix TeX 3.0!}
+    \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
+    \immediate\write16{If you are running another version of TeX, relax.}
+    \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
+    \immediate\write16{  Then upgrade your TeX installation if you can.}
+    \immediate\write16{  (See ftp://ftp.gnu.org/pub/gnu/TeX.README.)}
+    \immediate\write16{If you are stuck with version 3.0, run the}
+    \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
+    \immediate\write16{  to use a workaround.}
+    \immediate\write16{}
+    \global\warnedobstrue
+    \fi
+}
+
+% **In TeX 3.0, setting text in \nullfont hangs tex.  For a
+% workaround (which requires the file ``dummy.tfm'' to be installed),
+% uncomment the following line:
+%%%%%\font\nullfont=dummy\let\obstexwarn=\relax
+
+% Ignore text, except that we keep track of conditional commands for
+% purposes of nesting, up to an `@end #1' command.
+%
+\def\nestedignore#1{%
+  \obstexwarn
+  % We must actually expand the ignored text to look for the @end
+  % command, so that nested ignore constructs work.  Thus, we put the
+  % text into a \vbox and then do nothing with the result.  To minimize
+  % the change of memory overflow, we follow the approach outlined on
+  % page 401 of the TeXbook: make the current font be a dummy font.
+  %
+  \setbox0 = \vbox\bgroup
+    % Don't complain about control sequences we have declared \outer.
+    \ignoresections
+    %
+    % Define `@end #1' to end the box, which will in turn undefine the
+    % @end command again.
+    \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
+    %
+    % We are going to be parsing Texinfo commands.  Most cause no
+    % trouble when they are used incorrectly, but some commands do
+    % complicated argument parsing or otherwise get confused, so we
+    % undefine them.
+    %
+    % We can't do anything about stray @-signs, unfortunately;
+    % they'll produce `undefined control sequence' errors.
+    \ignoremorecommands
+    %
+    % Set the current font to be \nullfont, a TeX primitive, and define
+    % all the font commands to also use \nullfont.  We don't use
+    % dummy.tfm, as suggested in the TeXbook, because not all sites
+    % might have that installed.  Therefore, math mode will still
+    % produce output, but that should be an extremely small amount of
+    % stuff compared to the main input.
+    %
+    \nullfont
+    \let\tenrm=\nullfont \let\tenit=\nullfont \let\tensl=\nullfont
+    \let\tenbf=\nullfont \let\tentt=\nullfont \let\smallcaps=\nullfont
+    \let\tensf=\nullfont
+    % Similarly for index fonts (mostly for their use in smallexample).
+    \let\smallrm=\nullfont \let\smallit=\nullfont \let\smallsl=\nullfont
+    \let\smallbf=\nullfont \let\smalltt=\nullfont \let\smallsc=\nullfont
+    \let\smallsf=\nullfont
+    %
+    % Don't complain when characters are missing from the fonts.
+    \tracinglostchars = 0
+    %
+    % Don't bother to do space factor calculations.
+    \frenchspacing
+    %
+    % Don't report underfull hboxes.
+    \hbadness = 10000
+    %
+    % Do minimal line-breaking.
+    \pretolerance = 10000
+    %
+    % Do not execute instructions in @tex
+    \def\tex{\doignore{tex}}%
+    % Do not execute macro definitions.
+    % `c' is a comment character, so the word `macro' will get cut off.
+    \def\macro{\doignore{ma}}%
+}
+
+% @set VAR sets the variable VAR to an empty value.
+% @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
+%
+% Since we want to separate VAR from REST-OF-LINE (which might be
+% empty), we can't just use \parsearg; we have to insert a space of our
+% own to delimit the rest of the line, and then take it out again if we
+% didn't need it.  Make sure the catcode of space is correct to avoid
+% losing inside @example, for instance.
+%
+\def\set{\begingroup\catcode` =10
+  \catcode`\-=12 \catcode`\_=12 % Allow - and _ in VAR.
+  \parsearg\setxxx}
+\def\setxxx#1{\setyyy#1 \endsetyyy}
+\def\setyyy#1 #2\endsetyyy{%
+  \def\temp{#2}%
+  \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
+  \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
   \fi
- % In either case we will make \leftskip=\spacebetweencols:
-\leftskip=\spacebetweencols
-\fi
-\noindent##}\cr%
- % \everycr will reset column counter, \colcount, at the end of
- % each line. Every column  entry will cause \colcount to advance by one. 
- % The table preamble
- % looks at the current \colcount to find the correct column width.
-\global\everycr{\noalign{\nointerlineskip\vskip\spacebetweenlines
-\filbreak%% keeps underfull box messages off when table breaks over pages.
-\global\colcount=0\relax}}}
+  \endgroup
+}
+% Can't use \xdef to pre-expand #2 and save some time, since \temp or
+% \next or other control sequences that we've defined might get us into
+% an infinite loop. Consider `@set foo @cite{bar}'.
+\def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
+
+% @clear VAR clears (i.e., unsets) the variable VAR.
+%
+\def\clear{\parsearg\clearxxx}
+\def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
+
+% @value{foo} gets the text saved in variable foo.
+{
+  \catcode`\_ = \active
+  %
+  % We might end up with active _ or - characters in the argument if
+  % we're called from @code, as @code{@value{foo-bar_}}.  So \let any
+  % such active characters to their normal equivalents.
+  \gdef\value{\begingroup
+    \catcode`\-=12 \catcode`\_=12
+    \indexbreaks \let_\normalunderscore
+    \valuexxx}
+}
+\def\valuexxx#1{\expandablevalue{#1}\endgroup}
+
+% We have this subroutine so that we can handle at least some @value's
+% properly in indexes (we \let\value to this in \indexdummies).  Ones
+% whose names contain - or _ still won't work, but we can't do anything
+% about that.  The command has to be fully expandable, since the result
+% winds up in the index file.  This means that if the variable's value
+% contains other Texinfo commands, it's almost certain it will fail
+% (although perhaps we could fix that with sufficient work to do a
+% one-level expansion on the result, instead of complete).
+%
+\def\expandablevalue#1{%
+  \expandafter\ifx\csname SET#1\endcsname\relax
+    {[No value for ``#1'']}%
+  \else
+    \csname SET#1\endcsname
+  \fi
+}
+
+% @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
+% with @set.
+%
+\def\ifset{\parsearg\ifsetxxx}
+\def\ifsetxxx #1{%
+  \expandafter\ifx\csname SET#1\endcsname\relax
+    \expandafter\ifsetfail
+  \else
+    \expandafter\ifsetsucceed
+  \fi
+}
+\def\ifsetsucceed{\conditionalsucceed{ifset}}
+\def\ifsetfail{\nestedignore{ifset}}
+\defineunmatchedend{ifset}
+
+% @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
+% defined with @set, or has been undefined with @clear.
+%
+\def\ifclear{\parsearg\ifclearxxx}
+\def\ifclearxxx #1{%
+  \expandafter\ifx\csname SET#1\endcsname\relax
+    \expandafter\ifclearsucceed
+  \else
+    \expandafter\ifclearfail
+  \fi
+}
+\def\ifclearsucceed{\conditionalsucceed{ifclear}}
+\def\ifclearfail{\nestedignore{ifclear}}
+\defineunmatchedend{ifclear}
+
+% @iftex, @ifnothtml, @ifnotinfo always succeed; we read the text
+% following, through the first @end iftex (etc.).  Make `@end iftex'
+% (etc.) valid only after an @iftex.
+%
+\def\iftex{\conditionalsucceed{iftex}}
+\def\ifnothtml{\conditionalsucceed{ifnothtml}}
+\def\ifnotinfo{\conditionalsucceed{ifnotinfo}}
+\defineunmatchedend{iftex}
+\defineunmatchedend{ifnothtml}
+\defineunmatchedend{ifnotinfo}
+
+% We can't just want to start a group at @iftex (for example) and end it
+% at @end iftex, since then @set commands inside the conditional have no
+% effect (they'd get reverted at the end of the group).  So we must
+% define \Eiftex to redefine itself to be its previous value.  (We can't
+% just define it to fail again with an ``unmatched end'' error, since
+% the @ifset might be nested.)
+%
+\def\conditionalsucceed#1{%
+  \edef\temp{%
+    % Remember the current value of \E#1.
+    \let\nece{prevE#1} = \nece{E#1}%
+    %
+    % At the `@end #1', redefine \E#1 to be its previous value.
+    \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
+  }%
+  \temp
+}
+
+% We need to expand lots of \csname's, but we don't want to expand the
+% control sequences after we've constructed them.
+%
+\def\nece#1{\expandafter\noexpand\csname#1\endcsname}
+
+% @defininfoenclose.
+\let\definfoenclose=\comment
+
 
 \message{indexing,}
 % Index generation facilities
 
 % Define \newwrite to be identical to plain tex's \newwrite
 % except not \outer, so it can be used within \newindex.
 {\catcode`\@=11
 \gdef\newwrite{\alloc@7\write\chardef\sixt@@n}}
 
 % \newindex {foo} defines an index named foo.
 % It automatically defines \fooindex such that
 % \fooindex ...rest of line... puts an entry in the index foo.
 % It also defines \fooindfile to be the number of the output channel for
 % the file that accumulates this index.  The file's extension is foo.
 % The name of an index should be no more than 2 characters long
 % for the sake of vms.
-
-\def\newindex #1{
-\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
-\openout \csname#1indfile\endcsname \jobname.#1 % Open the file
-\expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
-\noexpand\doindex {#1}}
+%
+\def\newindex#1{%
+  \iflinks
+    \expandafter\newwrite \csname#1indfile\endcsname
+    \openout \csname#1indfile\endcsname \jobname.#1 % Open the file
+  \fi
+  \expandafter\xdef\csname#1index\endcsname{%     % Define @#1index
+    \noexpand\doindex{#1}}
 }
 
 % @defindex foo  ==  \newindex{foo}
 
 \def\defindex{\parsearg\newindex}
 
 % Define @defcodeindex, like @defindex except put all entries in @code.
 
-\def\newcodeindex #1{
-\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
-\openout \csname#1indfile\endcsname \jobname.#1 % Open the file
-\expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
-\noexpand\docodeindex {#1}}
+\def\newcodeindex#1{%
+  \iflinks
+    \expandafter\newwrite \csname#1indfile\endcsname
+    \openout \csname#1indfile\endcsname \jobname.#1
+  \fi
+  \expandafter\xdef\csname#1index\endcsname{%
+    \noexpand\docodeindex{#1}}
 }
 
 \def\defcodeindex{\parsearg\newcodeindex}
 
 % @synindex foo bar    makes index foo feed into index bar.
 % Do this instead of @defindex foo if you don't want it as a separate index.
-\def\synindex #1 #2 {%
-\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
-\expandafter\let\csname#1indfile\endcsname=\synindexfoo
-\expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
-\noexpand\doindex {#2}}%
+% The \closeout helps reduce unnecessary open files; the limit on the
+% Acorn RISC OS is a mere 16 files.
+\def\synindex#1 #2 {%
+  \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
+  \expandafter\closeout\csname#1indfile\endcsname
+  \expandafter\let\csname#1indfile\endcsname=\synindexfoo
+  \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
+    \noexpand\doindex{#2}}%
 }
 
 % @syncodeindex foo bar   similar, but put all entries made for index foo
 % inside @code.
-\def\syncodeindex #1 #2 {%
-\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
-\expandafter\let\csname#1indfile\endcsname=\synindexfoo
-\expandafter\xdef\csname#1index\endcsname{%     % Define \xxxindex
-\noexpand\docodeindex {#2}}%
+\def\syncodeindex#1 #2 {%
+  \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
+  \expandafter\closeout\csname#1indfile\endcsname
+  \expandafter\let\csname#1indfile\endcsname=\synindexfoo
+  \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
+    \noexpand\docodeindex{#2}}%
 }
 
 % Define \doindex, the driver for all \fooindex macros.
 % Argument #1 is generated by the calling \fooindex macro,
 %  and it is "foo", the name of the index.
 
 % \doindex just uses \parsearg; it calls \doind for the actual work.
 % This is because \doind is more useful to call from other macros.
@@ -1929,16 +2638,17 @@ July\or August\or September\or October\o
 \def\doindex#1{\edef\indexname{#1}\parsearg\singleindexer}
 \def\singleindexer #1{\doind{\indexname}{#1}}
 
 % like the previous two, but they put @code around the argument.
 \def\docodeindex#1{\edef\indexname{#1}\parsearg\singlecodeindexer}
 \def\singlecodeindexer #1{\doind{\indexname}{\code{#1}}}
 
 \def\indexdummies{%
+\def\ { }%
 % Take care of the plain tex accent commands.
 \def\"{\realbackslash "}%
 \def\`{\realbackslash `}%
 \def\'{\realbackslash '}%
 \def\^{\realbackslash ^}%
 \def\~{\realbackslash ~}%
 \def\={\realbackslash =}%
 \def\b{\realbackslash b}%
@@ -1955,66 +2665,105 @@ July\or August\or September\or October\o
 \def\AE{\realbackslash AE}%
 \def\AA{\realbackslash AA}%
 \def\o{\realbackslash o}%
 \def\O{\realbackslash O}%
 \def\l{\realbackslash l}%
 \def\L{\realbackslash L}%
 \def\ss{\realbackslash ss}%
 % Take care of texinfo commands likely to appear in an index entry.
+% (Must be a way to avoid doing expansion at all, and thus not have to
+% laboriously list every single command here.)
+\def\@{@}% will be @@ when we switch to @ as escape char.
+% Need these in case \tex is in effect and \{ is a \delimiter again.
+% But can't use \lbracecmd and \rbracecmd because texindex assumes
+% braces and backslashes are used only as delimiters.  
+\let\{ = \mylbrace
+\let\} = \myrbrace
 \def\_{{\realbackslash _}}%
 \def\w{\realbackslash w }%
 \def\bf{\realbackslash bf }%
-\def\rm{\realbackslash rm }%
+%\def\rm{\realbackslash rm }%
 \def\sl{\realbackslash sl }%
 \def\sf{\realbackslash sf}%
 \def\tt{\realbackslash tt}%
 \def\gtr{\realbackslash gtr}%
 \def\less{\realbackslash less}%
 \def\hat{\realbackslash hat}%
-\def\char{\realbackslash char}%
 \def\TeX{\realbackslash TeX}%
 \def\dots{\realbackslash dots }%
-\def\copyright{\realbackslash copyright }%
+\def\result{\realbackslash result}%
+\def\equiv{\realbackslash equiv}%
+\def\expansion{\realbackslash expansion}%
+\def\print{\realbackslash print}%
+\def\error{\realbackslash error}%
+\def\point{\realbackslash point}%
+\def\copyright{\realbackslash copyright}%
 \def\tclose##1{\realbackslash tclose {##1}}%
 \def\code##1{\realbackslash code {##1}}%
+\def\uref##1{\realbackslash uref {##1}}%
+\def\url##1{\realbackslash url {##1}}%
+\def\env##1{\realbackslash env {##1}}%
+\def\command##1{\realbackslash command {##1}}%
+\def\option##1{\realbackslash option {##1}}%
+\def\dotless##1{\realbackslash dotless {##1}}%
 \def\samp##1{\realbackslash samp {##1}}%
-\def\t##1{\realbackslash r {##1}}%
+\def\,##1{\realbackslash ,{##1}}%
+\def\t##1{\realbackslash t {##1}}%
 \def\r##1{\realbackslash r {##1}}%
 \def\i##1{\realbackslash i {##1}}%
 \def\b##1{\realbackslash b {##1}}%
+\def\sc##1{\realbackslash sc {##1}}%
 \def\cite##1{\realbackslash cite {##1}}%
 \def\key##1{\realbackslash key {##1}}%
 \def\file##1{\realbackslash file {##1}}%
 \def\var##1{\realbackslash var {##1}}%
 \def\kbd##1{\realbackslash kbd {##1}}%
 \def\dfn##1{\realbackslash dfn {##1}}%
 \def\emph##1{\realbackslash emph {##1}}%
+\def\acronym##1{\realbackslash acronym {##1}}%
+%
+% Handle some cases of @value -- where the variable name does not
+% contain - or _, and the value does not contain any
+% (non-fully-expandable) commands.
+\let\value = \expandablevalue
+%
+\unsepspaces
+% Turn off macro expansion
+\turnoffmacros
 }
 
+% If an index command is used in an @example environment, any spaces
+% therein should become regular spaces in the raw index file, not the
+% expansion of \tie (\\leavevmode \penalty \@M \ ).
+{\obeyspaces
+ \gdef\unsepspaces{\obeyspaces\let =\space}}
+
 % \indexnofonts no-ops all font-change commands.
 % This is used when outputting the strings to sort the index by.
 \def\indexdummyfont#1{#1}
 \def\indexdummytex{TeX}
 \def\indexdummydots{...}
 
 \def\indexnofonts{%
 % Just ignore accents.
+\let\,=\indexdummyfont
 \let\"=\indexdummyfont
 \let\`=\indexdummyfont
 \let\'=\indexdummyfont
 \let\^=\indexdummyfont
 \let\~=\indexdummyfont
 \let\==\indexdummyfont
 \let\b=\indexdummyfont
 \let\c=\indexdummyfont
 \let\d=\indexdummyfont
 \let\u=\indexdummyfont
 \let\v=\indexdummyfont
 \let\H=\indexdummyfont
+\let\dotless=\indexdummyfont
 % Take care of the plain tex special European modified letters.
 \def\oe{oe}%
 \def\ae{ae}%
 \def\aa{aa}%
 \def\OE{OE}%
 \def\AE{AE}%
 \def\AA{AA}%
 \def\o{o}%
@@ -2031,81 +2780,133 @@ July\or August\or September\or October\o
 \let\strong=\indexdummyfont
 \let\cite=\indexdummyfont
 \let\sc=\indexdummyfont
 %Don't no-op \tt, since it isn't a user-level command
 % and is used in the definitions of the active chars like <, >, |...
 %\let\tt=\indexdummyfont
 \let\tclose=\indexdummyfont
 \let\code=\indexdummyfont
+\let\url=\indexdummyfont
+\let\uref=\indexdummyfont
+\let\env=\indexdummyfont
+\let\acronym=\indexdummyfont
+\let\command=\indexdummyfont
+\let\option=\indexdummyfont
 \let\file=\indexdummyfont
 \let\samp=\indexdummyfont
 \let\kbd=\indexdummyfont
 \let\key=\indexdummyfont
 \let\var=\indexdummyfont
 \let\TeX=\indexdummytex
 \let\dots=\indexdummydots
+\def\@{@}%
 }
 
 % To define \realbackslash, we must make \ not be an escape.
 % We must first make another character (@) an escape
 % so we do not become unable to do a definition.
 
 {\catcode`\@=0 \catcode`\\=\other
-@gdef@realbackslash{\}}
+ @gdef@realbackslash{\}}
 
 \let\indexbackslash=0  %overridden during \printindex.
-
-\let\SETmarginindex=\relax %initialize!
-% workhorse for all \fooindexes
-% #1 is name of index, #2 is stuff to put there
-\def\doind #1#2{%
-% Put the index entry in the margin if desired.
-\ifx\SETmarginindex\relax\else%
-\insert\margin{\hbox{\vrule height8pt depth3pt width0pt #2}}%
-\fi%
-{\count10=\lastpenalty %
-{\indexdummies % Must do this here, since \bf, etc expand at this stage
-\escapechar=`\\%
-{\let\folio=0% Expand all macros now EXCEPT \folio
-\def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
-% so it will be output as is; and it will print as backslash in the indx.
+\let\SETmarginindex=\relax % put index entries in margin (undocumented)?
+
+% For \ifx comparisons.
+\def\emptymacro{\empty}
+
+% Most index entries go through here, but \dosubind is the general case.
+%
+\def\doind#1#2{\dosubind{#1}{#2}\empty}
+
+% Workhorse for all \fooindexes.
+% #1 is name of index, #2 is stuff to put there, #3 is subentry --
+% \empty if called from \doind, as we usually are.  The main exception
+% is with defuns, which call us directly.
 %
-% Now process the index-string once, with all font commands turned off,
-% to get the string to sort the index by.
-{\indexnofonts
-\xdef\temp1{#2}%
-}%
-% Now produce the complete index entry.  We process the index-string again,
-% this time with font commands expanded, to get what to print in the index.
-\edef\temp{%
-\write \csname#1indfile\endcsname{%
-\realbackslash entry {\temp1}{\folio}{#2}}}%
-\temp }%
-}\penalty\count10}}
-
-\def\dosubind #1#2#3{%
-{\count10=\lastpenalty %
-{\indexdummies % Must do this here, since \bf, etc expand at this stage
-\escapechar=`\\%
-{\let\folio=0%
-\def\rawbackslashxx{\indexbackslash}%
-%
-% Now process the index-string once, with all font commands turned off,
-% to get the string to sort the index by.
-{\indexnofonts
-\xdef\temp1{#2 #3}%
-}%
-% Now produce the complete index entry.  We process the index-string again,
-% this time with font commands expanded, to get what to print in the index.
-\edef\temp{%
-\write \csname#1indfile\endcsname{%
-\realbackslash entry {\temp1}{\folio}{#2}{#3}}}%
-\temp }%
-}\penalty\count10}}
+\def\dosubind#1#2#3{%
+  % Put the index entry in the margin if desired.
+  \ifx\SETmarginindex\relax\else
+    \insert\margin{\hbox{\vrule height8pt depth3pt width0pt #2}}%
+  \fi
+  {%
+    \count255=\lastpenalty
+    {%
+      \indexdummies % Must do this here, since \bf, etc expand at this stage
+      \escapechar=`\\
+      {%
+        \let\folio = 0% We will expand all macros now EXCEPT \folio.
+        \def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
+        % so it will be output as is; and it will print as backslash.
+        %
+        \def\thirdarg{#3}%
+        %
+        % If third arg is present, precede it with space in sort key.
+        \ifx\thirdarg\emptymacro
+          \let\subentry = \empty
+        \else
+          \def\subentry{ #3}%
+        \fi
+        %
+        % First process the index entry with all font commands turned
+        % off to get the string to sort by.
+        {\indexnofonts \xdef\indexsorttmp{#2\subentry}}%
+        %
+        % Now the real index entry with the fonts.
+        \toks0 = {#2}%
+        %
+        % If third (subentry) arg is present, add it to the index
+        % string.  And include a space.
+        \ifx\thirdarg\emptymacro \else
+          \toks0 = \expandafter{\the\toks0 \space #3}%
+        \fi
+        %
+        % Set up the complete index entry, with both the sort key
+        % and the original text, including any font commands.  We write
+        % three arguments to \entry to the .?? file, texindex reduces to
+        % two when writing the .??s sorted result.
+        \edef\temp{%
+          \write\csname#1indfile\endcsname{%
+            \realbackslash entry{\indexsorttmp}{\folio}{\the\toks0}}%
+        }%
+        %
+        % If a skip is the last thing on the list now, preserve it
+        % by backing up by \lastskip, doing the \write, then inserting
+        % the skip again.  Otherwise, the whatsit generated by the
+        % \write will make \lastskip zero.  The result is that sequences
+        % like this:
+        % @end defun
+        % @tindex whatever
+        % @defun ...
+        % will have extra space inserted, because the \medbreak in the
+        % start of the @defun won't see the skip inserted by the @end of
+        % the previous defun.
+        %
+        % But don't do any of this if we're not in vertical mode.  We
+        % don't want to do a \vskip and prematurely end a paragraph.
+        %
+        % Avoid page breaks due to these extra skips, too.
+        %
+        \iflinks
+          \ifvmode
+            \skip0 = \lastskip
+            \ifdim\lastskip = 0pt \else \nobreak\vskip-\lastskip \fi
+          \fi
+          %
+          \temp % do the write
+          %
+          %
+          \ifvmode \ifdim\skip0 = 0pt \else \nobreak\vskip\skip0 \fi \fi
+        \fi
+      }%
+    }%
+    \penalty\count255
+  }%
+}
 
 % The index entry written in the file actually looks like
 %  \entry {sortstring}{page}{topic}
 % or
 %  \entry {sortstring}{page}{topic}{subtopic}
 % The texindex program reads in these files and writes files
 % containing these kinds of lines:
 %  \initial {c}
@@ -2129,88 +2930,95 @@ July\or August\or September\or October\o
 
 \def\cindexsub {\begingroup\obeylines\cindexsub}
 {\obeylines %
 \gdef\cindexsub "#1" #2^^M{\endgroup %
 \dosubind{cp}{#2}{#1}}}
 
 % Define the macros used in formatting output of the sorted index material.
 
-% This is what you call to cause a particular index to get printed.
-% Write
-% @unnumbered Function Index
-% @printindex fn
-
+% @printindex causes a particular index (the ??s file) to get printed.
+% It does not print any chapter heading (usually an @unnumbered).
+%
 \def\printindex{\parsearg\doprintindex}
-
-\def\doprintindex#1{%
-  \tex
-  \dobreak \chapheadingskip {10000}
-  \catcode`\%=\other\catcode`\&=\other\catcode`\#=\other
-  \catcode`\$=\other
-  \catcode`\~=\other
+\def\doprintindex#1{\begingroup
+  \dobreak \chapheadingskip{10000}%
+  %
+  \smallfonts \rm
+  \tolerance = 9500
   \indexbreaks
   %
-  % The following don't help, since the chars were translated
-  % when the raw index was written, and their fonts were discarded
-  % due to \indexnofonts.
-  %\catcode`\"=\active
-  %\catcode`\^=\active
-  %\catcode`\_=\active
-  %\catcode`\|=\active
-  %\catcode`\<=\active
-  %\catcode`\>=\active
-  % %
-  \def\indexbackslash{\rawbackslashxx}
-  \indexfonts\rm \tolerance=9500 \advance\baselineskip -1pt
-  \begindoublecolumns
-  %
   % See if the index file exists and is nonempty.
+  % Change catcode of @ here so that if the index file contains
+  % \initial {@}
+  % as its first line, TeX doesn't complain about mismatched braces
+  % (because it thinks @} is a control sequence).
+  \catcode`\@ = 11
   \openin 1 \jobname.#1s
   \ifeof 1
     % \enddoublecolumns gets confused if there is no text in the index,
     % and it loses the chapter title and the aux file entries for the
     % index.  The easiest way to prevent this problem is to make sure
     % there is some text.
-    (Index is nonexistent)
-    \else
+    \putwordIndexNonexistent
+  \else
     %
     % If the index file exists but is empty, then \openin leaves \ifeof
     % false.  We have to make TeX try to read something from the file, so
     % it can discover if there is anything in it.
     \read 1 to \temp
     \ifeof 1
-      (Index is empty)
+      \putwordIndexIsEmpty
     \else
+      % Index files are almost Texinfo source, but we use \ as the escape
+      % character.  It would be better to use @, but that's too big a change
+      % to make right now.
+      \def\indexbackslash{\rawbackslashxx}%
+      \catcode`\\ = 0
+      \escapechar = `\\
+      \begindoublecolumns
       \input \jobname.#1s
+      \enddoublecolumns
     \fi
   \fi
   \closein 1
-  \enddoublecolumns
-  \Etex
-}
+\endgroup}
 
 % These macros are used by the sorted index file itself.
 % Change them to control the appearance of the index.
 
-% Same as \bigskipamount except no shrink.
-% \balancecolumns gets confused if there is any shrink.
-\newskip\initialskipamount \initialskipamount 12pt plus4pt
-
-\def\initial #1{%
-{\let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
-\ifdim\lastskip<\initialskipamount
-\removelastskip \penalty-200 \vskip \initialskipamount\fi
-\line{\secbf#1\hfill}\kern 2pt\penalty10000}}
+\def\initial#1{{%
+  % Some minor font changes for the special characters.
+  \let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
+  %
+  % Remove any glue we may have, we'll be inserting our own.
+  \removelastskip
+  %
+  % We like breaks before the index initials, so insert a bonus.
+  \penalty -300
+  %
+  % Typeset the initial.  Making this add up to a whole number of
+  % baselineskips increases the chance of the dots lining up from column
+  % to column.  It still won't often be perfect, because of the stretch
+  % we need before each entry, but it's better.
+  %
+  % No shrink because it confuses \balancecolumns.
+  \vskip 1.67\baselineskip plus .5\baselineskip
+  \leftline{\secbf #1}%
+  \vskip .33\baselineskip plus .1\baselineskip
+  %
+  % Do our best not to break after the initial.
+  \nobreak
+}}
 
 % This typesets a paragraph consisting of #1, dot leaders, and then #2
 % flush to the right margin.  It is used for index and table of contents
 % entries.  The paragraph is indented by \leftskip.
 %
-\def\entry #1#2{\begingroup
+\def\entry#1#2{\begingroup
   %
   % Start a new paragraph if necessary, so our assignments below can't
   % affect previous text.
   \par
   %
   % Do not fill out the last line with white space.
   \parfillskip = 0in
   %
@@ -2223,29 +3031,32 @@ July\or August\or September\or October\o
   % \hangindent is only relevant when the entry text and page number
   % don't both fit on one line.  In that case, bob suggests starting the
   % dots pretty far over on the line.  Unfortunately, a large
   % indentation looks wrong when the entry text itself is broken across
   % lines.  So we use a small indentation and put up with long leaders.
   %
   % \hangafter is reset to 1 (which is the value we want) at the start
   % of each paragraph, so we need not do anything with that.
-  \hangindent=2em
+  \hangindent = 2em
   %
   % When the entry text needs to be broken, just fill out the first line
   % with blank space.
   \rightskip = 0pt plus1fil
   %
+  % A bit of stretch before each entry for the benefit of balancing columns.
+  \vskip 0pt plus1pt
+  %
   % Start a ``paragraph'' for the index entry so the line breaking
   % parameters we've set above will have an effect.
   \noindent
   %
   % Insert the text of the index entry.  TeX will do line-breaking on it.
   #1%
-  % The following is kluged to not output a line of dots in the index if
+  % The following is kludged to not output a line of dots in the index if
   % there are no page numbers.  The next person who breaks this will be
   % cursed by a Unix daemon.
   \def\tempa{{\rm }}%
   \def\tempb{#2}%
   \edef\tempc{\tempa}%
   \edef\tempd{\tempb}%
   \ifx\tempc\tempd\ \else%
     %
@@ -2253,17 +3064,21 @@ July\or August\or September\or October\o
     % this line with blank space.  (The \hfil is overwhelmed with the
     % fill leaders glue in \indexdotfill if the page number does fit.)
     \hfil\penalty50
     \null\nobreak\indexdotfill % Have leaders before the page number.
     %
     % The `\ ' here is removed by the implicit \unskip that TeX does as
     % part of (the primitive) \par.  Without it, a spurious underfull
     % \hbox ensues.
-    \ #2% The page number ends the paragraph.
+    \ifpdf
+      \pdfgettoks#2.\ \the\toksA % The page number ends the paragraph.
+    \else
+      \ #2% The page number ends the paragraph.
+    \fi
   \fi%
   \par
 \endgroup}
 
 % Like \dotfill except takes at least 1 em.
 \def\indexdotfill{\cleaders
   \hbox{$\mathsurround=0pt \mkern1.5mu ${\it .}$ \mkern1.5mu$}\hskip 1em plus 1fill}
 
@@ -2272,159 +3087,207 @@ July\or August\or September\or October\o
 \newskip\secondaryindent \secondaryindent=0.5cm
 
 \def\secondary #1#2{
 {\parfillskip=0in \parskip=0in
 \hangindent =1in \hangafter=1
 \noindent\hskip\secondaryindent\hbox{#1}\indexdotfill #2\par
 }}
 
-%% Define two-column mode, which is used in indexes.
-%% Adapted from the TeXbook, page 416.
-\catcode `\@=11
+% Define two-column mode, which we use to typeset indexes.
+% Adapted from the TeXbook, page 416, which is to say,
+% the manmac.tex format used to print the TeXbook itself.
+\catcode`\@=11
 
 \newbox\partialpage
-
 \newdimen\doublecolumnhsize
 
-\def\begindoublecolumns{\begingroup
+\def\begindoublecolumns{\begingroup % ended by \enddoublecolumns
   % Grab any single-column material above us.
-  \output = {\global\setbox\partialpage
-    =\vbox{\unvbox255\kern -\topskip \kern \baselineskip}}%
-  \eject
+  \output = {%
+    %
+    % Here is a possibility not foreseen in manmac: if we accumulate a
+    % whole lot of material, we might end up calling this \output
+    % routine twice in a row (see the doublecol-lose test, which is
+    % essentially a couple of indexes with @setchapternewpage off).  In
+    % that case we just ship out what is in \partialpage with the normal
+    % output routine.  Generally, \partialpage will be empty when this
+    % runs and this will be a no-op.  See the indexspread.tex test case.
+    \ifvoid\partialpage \else
+      \onepageout{\pagecontents\partialpage}%
+    \fi
+    %
+    \global\setbox\partialpage = \vbox{%
+      % Unvbox the main output page.
+      \unvbox\PAGE
+      \kern-\topskip \kern\baselineskip
+    }%
+  }%
+  \eject % run that output routine to set \partialpage
   %
-  % Now switch to the double-column output routine.
-  \output={\doublecolumnout}%
+  % Use the double-column output routine for subsequent pages.
+  \output = {\doublecolumnout}%
   %
   % Change the page size parameters.  We could do this once outside this
   % routine, in each of @smallbook, @afourpaper, and the default 8.5x11
   % format, but then we repeat the same computation.  Repeating a couple
   % of assignments once per index is clearly meaningless for the
-  % execution time, so we may as well do it once.
+  % execution time, so we may as well do it in one place.
   %
   % First we halve the line length, less a little for the gutter between
   % the columns.  We compute the gutter based on the line length, so it
   % changes automatically with the paper format.  The magic constant
-  % below is chosen so that the gutter has the same value (well, +- <
-  % 1pt) as it did when we hard-coded it.
+  % below is chosen so that the gutter has the same value (well, +-<1pt)
+  % as it did when we hard-coded it.
   %
   % We put the result in a separate register, \doublecolumhsize, so we
   % can restore it in \pagesofar, after \hsize itself has (potentially)
   % been clobbered.
   %
   \doublecolumnhsize = \hsize
     \advance\doublecolumnhsize by -.04154\hsize
     \divide\doublecolumnhsize by 2
   \hsize = \doublecolumnhsize
   %
   % Double the \vsize as well.  (We don't need a separate register here,
   % since nobody clobbers \vsize.)
+  \advance\vsize by -\ht\partialpage
   \vsize = 2\vsize
-  \doublecolumnpagegoal
 }
 
-\def\enddoublecolumns{\eject \endgroup \pagegoal=\vsize \unvbox\partialpage}
-
-\def\doublecolumnsplit{\splittopskip=\topskip \splitmaxdepth=\maxdepth
-  \global\dimen@=\pageheight \global\advance\dimen@ by-\ht\partialpage
-  \global\setbox1=\vsplit255 to\dimen@ \global\setbox0=\vbox{\unvbox1}
-  \global\setbox3=\vsplit255 to\dimen@ \global\setbox2=\vbox{\unvbox3}
-  \ifdim\ht0>\dimen@ \setbox255=\vbox{\unvbox0\unvbox2} \global\setbox255=\copy5 \fi
-  \ifdim\ht2>\dimen@ \setbox255=\vbox{\unvbox0\unvbox2} \global\setbox255=\copy5 \fi
-}
-\def\doublecolumnpagegoal{%
-  \dimen@=\vsize \advance\dimen@ by-2\ht\partialpage \global\pagegoal=\dimen@
-}
-\def\pagesofar{\unvbox\partialpage %
-  \hsize=\doublecolumnhsize % have to restore this since output routine
-  \wd0=\hsize \wd2=\hsize \hbox to\pagewidth{\box0\hfil\box2}}
+% The double-column output routine for all double-column pages except
+% the last.
+%
 \def\doublecolumnout{%
-  \setbox5=\copy255
-  {\vbadness=10000 \doublecolumnsplit}
-  \ifvbox255
-    \setbox0=\vtop to\dimen@{\unvbox0}
-    \setbox2=\vtop to\dimen@{\unvbox2}
-    \onepageout\pagesofar \unvbox255 \penalty\outputpenalty
-  \else
-    \setbox0=\vbox{\unvbox5}
-    \ifvbox0
-      \dimen@=\ht0 \advance\dimen@ by\topskip \advance\dimen@ by-\baselineskip
-      \divide\dimen@ by2 \splittopskip=\topskip \splitmaxdepth=\maxdepth
-      {\vbadness=10000
-        \loop \global\setbox5=\copy0
-          \setbox1=\vsplit5 to\dimen@
-          \setbox3=\vsplit5 to\dimen@
-          \ifvbox5 \global\advance\dimen@ by1pt \repeat
-        \setbox0=\vbox to\dimen@{\unvbox1}
-        \setbox2=\vbox to\dimen@{\unvbox3}
-        \global\setbox\partialpage=\vbox{\pagesofar}
-        \doublecolumnpagegoal
-      }
-    \fi
-  \fi
+  \splittopskip=\topskip \splitmaxdepth=\maxdepth
+  % Get the available space for the double columns -- the normal
+  % (undoubled) page height minus any material left over from the
+  % previous page.
+  \dimen@ = \vsize
+  \divide\dimen@ by 2
+  %
+  % box0 will be the left-hand column, box2 the right.
+  \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
+  \onepageout\pagesofar
+  \unvbox255
+  \penalty\outputpenalty
+}
+\def\pagesofar{%
+  % Re-output the contents of the output page -- any previous material,
+  % followed by the two boxes we just split, in box0 and box2.
+  \unvbox\partialpage
+  %
+  \hsize = \doublecolumnhsize
+  \wd0=\hsize \wd2=\hsize
+  \hbox to\pagewidth{\box0\hfil\box2}%
 }
-
-\catcode `\@=\other
+\def\enddoublecolumns{%
+  \output = {%
+    % Split the last of the double-column material.  Leave it on the
+    % current page, no automatic page break.
+    \balancecolumns
+    %
+    % If we end up splitting too much material for the current page,
+    % though, there will be another page break right after this \output
+    % invocation ends.  Having called \balancecolumns once, we do not
+    % want to call it again.  Therefore, reset \output to its normal
+    % definition right away.  (We hope \balancecolumns will never be
+    % called on to balance too much material, but if it is, this makes
+    % the output somewhat more palatable.)
+    \global\output = {\onepageout{\pagecontents\PAGE}}%
+  }%
+  \eject
+  \endgroup % started in \begindoublecolumns
+  %
+  % \pagegoal was set to the doubled \vsize above, since we restarted
+  % the current page.  We're now back to normal single-column
+  % typesetting, so reset \pagegoal to the normal \vsize (after the
+  % \endgroup where \vsize got restored).
+  \pagegoal = \vsize
+}
+\def\balancecolumns{%
+  % Called at the end of the double column material.
+  \setbox0 = \vbox{\unvbox255}% like \box255 but more efficient, see p.120.
+  \dimen@ = \ht0
+  \advance\dimen@ by \topskip
+  \advance\dimen@ by-\baselineskip
+  \divide\dimen@ by 2 % target to split to
+  %debug\message{final 2-column material height=\the\ht0, target=\the\dimen@.}%
+  \splittopskip = \topskip
+  % Loop until we get a decent breakpoint.
+  {%
+    \vbadness = 10000
+    \loop
+      \global\setbox3 = \copy0
+      \global\setbox1 = \vsplit3 to \dimen@
+    \ifdim\ht3>\dimen@
+      \global\advance\dimen@ by 1pt
+    \repeat
+  }%
+  %debug\message{split to \the\dimen@, column heights: \the\ht1, \the\ht3.}%
+  \setbox0=\vbox to\dimen@{\unvbox1}%
+  \setbox2=\vbox to\dimen@{\unvbox3}%
+  %
+  \pagesofar
+}
+\catcode`\@ = \other
+
+
 \message{sectioning,}
-% Define chapters, sections, etc.
-
-\newcount \chapno
-\newcount \secno        \secno=0
-\newcount \subsecno     \subsecno=0
-\newcount \subsubsecno  \subsubsecno=0
+% Chapters, sections, etc.
+
+\newcount\chapno
+\newcount\secno        \secno=0
+\newcount\subsecno     \subsecno=0
+\newcount\subsubsecno  \subsubsecno=0
 
 % This counter is funny since it counts through charcodes of letters A, B, ...
-\newcount \appendixno  \appendixno = `\@
-\def\appendixletter{\char\the\appendixno}
-
-\newwrite \contentsfile
-% This is called from \setfilename.
-\def\opencontents{\openout \contentsfile = \jobname.toc}
+\newcount\appendixno  \appendixno = `\@
+% \def\appendixletter{\char\the\appendixno}
+% We do the following for the sake of pdftex, which needs the actual
+% letter in the expansion, not just typeset.
+\def\appendixletter{%
+  \ifnum\appendixno=`A A%
+  \else\ifnum\appendixno=`B B%
+  \else\ifnum\appendixno=`C C%
+  \else\ifnum\appendixno=`D D%
+  \else\ifnum\appendixno=`E E%
+  \else\ifnum\appendixno=`F F%
+  \else\ifnum\appendixno=`G G%
+  \else\ifnum\appendixno=`H H%
+  \else\ifnum\appendixno=`I I%
+  \else\ifnum\appendixno=`J J%
+  \else\ifnum\appendixno=`K K%
+  \else\ifnum\appendixno=`L L%
+  \else\ifnum\appendixno=`M M%
+  \else\ifnum\appendixno=`N N%
+  \else\ifnum\appendixno=`O O%
+  \else\ifnum\appendixno=`P P%
+  \else\ifnum\appendixno=`Q Q%
+  \else\ifnum\appendixno=`R R%
+  \else\ifnum\appendixno=`S S%
+  \else\ifnum\appendixno=`T T%
+  \else\ifnum\appendixno=`U U%
+  \else\ifnum\appendixno=`V V%
+  \else\ifnum\appendixno=`W W%
+  \else\ifnum\appendixno=`X X%
+  \else\ifnum\appendixno=`Y Y%
+  \else\ifnum\appendixno=`Z Z%
+  % The \the is necessary, despite appearances, because \appendixletter is
+  % expanded while writing the .toc file.  \char\appendixno is not
+  % expandable, thus it is written literally, thus all appendixes come out
+  % with the same letter (or @) in the toc without it.
+  \else\char\the\appendixno
+  \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
+  \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}
 
 % Each @chapter defines this as the name of the chapter.
-% page headings and footings can use it.  @section does likewise
-
-\def\thischapter{} \def\thissection{}
-\def\seccheck#1{\if \pageno<0 %
-\errmessage{@#1 not allowed after generating table of contents}\fi
-%
-}
-
-\def\chapternofonts{%
-\let\rawbackslash=\relax%
-\let\frenchspacing=\relax%
-\def\result{\realbackslash result}
-\def\equiv{\realbackslash equiv}
-\def\expansion{\realbackslash expansion}
-\def\print{\realbackslash print}
-\def\TeX{\realbackslash TeX}
-\def\dots{\realbackslash dots}
-\def\copyright{\realbackslash copyright}
-\def\tt{\realbackslash tt}
-\def\bf{\realbackslash bf }
-\def\w{\realbackslash w}
-\def\less{\realbackslash less}
-\def\gtr{\realbackslash gtr}
-\def\hat{\realbackslash hat}
-\def\char{\realbackslash char}
-\def\tclose##1{\realbackslash tclose {##1}}
-\def\code##1{\realbackslash code {##1}}
-\def\samp##1{\realbackslash samp {##1}}
-\def\r##1{\realbackslash r {##1}}
-\def\b##1{\realbackslash b {##1}}
-\def\key##1{\realbackslash key {##1}}
-\def\file##1{\realbackslash file {##1}}
-\def\kbd##1{\realbackslash kbd {##1}}
-% These are redefined because @smartitalic wouldn't work inside xdef.
-\def\i##1{\realbackslash i {##1}}
-\def\cite##1{\realbackslash cite {##1}}
-\def\var##1{\realbackslash var {##1}}
-\def\emph##1{\realbackslash emph {##1}}
-\def\dfn##1{\realbackslash dfn {##1}}
-}
+% page headings and footings can use it.  @section does likewise.
+\def\thischapter{}
+\def\thissection{}
 
 \newcount\absseclevel % used to calculate proper heading level
 \newcount\secbase\secbase=0 % @raise/lowersections modify this count
 
 % @raisesections: treat @section as chapter, @subsection as section, etc.
 \def\raisesections{\global\advance\secbase by -1}
 \let\up=\raisesections % original BFox name
 
@@ -2486,214 +3349,213 @@ July\or August\or September\or October\o
   \ifnum \absseclevel<0
     \unnumberedzzz{#2}
   \else
     \unnumberedsubsubseczzz{#2}
   \fi
 \fi
 }
 
-
+% @chapter, @appendix, @unnumbered.
 \def\thischaptername{No Chapter Title}
 \outer\def\chapter{\parsearg\chapteryyy}
 \def\chapteryyy #1{\numhead0{#1}} % normally numhead0 calls chapterzzz
-\def\chapterzzz #1{\seccheck{chapter}%
+\def\chapterzzz #1{%
 \secno=0 \subsecno=0 \subsubsecno=0
-\global\advance \chapno by 1 \message{\putwordChapter \the\chapno}%
+\global\advance \chapno by 1 \message{\putwordChapter\space \the\chapno}%
 \chapmacro {#1}{\the\chapno}%
 \gdef\thissection{#1}%
 \gdef\thischaptername{#1}%
 % We don't substitute the actual chapter name into \thischapter
 % because we don't want its macros evaluated now.
 \xdef\thischapter{\putwordChapter{} \the\chapno: \noexpand\thischaptername}%
-{\chapternofonts%
-\edef\temp{{\realbackslash chapentry {#1}{\the\chapno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp  %
-\donoderef %
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
+                                  {\the\chapno}}}%
+\temp
+\donoderef
 \global\let\section = \numberedsec
 \global\let\subsection = \numberedsubsec
 \global\let\subsubsection = \numberedsubsubsec
-}}
+}
 
 \outer\def\appendix{\parsearg\appendixyyy}
 \def\appendixyyy #1{\apphead0{#1}} % normally apphead0 calls appendixzzz
-\def\appendixzzz #1{\seccheck{appendix}%
+\def\appendixzzz #1{%
 \secno=0 \subsecno=0 \subsubsecno=0
-\global\advance \appendixno by 1 \message{Appendix \appendixletter}%
+\global\advance \appendixno by 1
+\message{\putwordAppendix\space \appendixletter}%
 \chapmacro {#1}{\putwordAppendix{} \appendixletter}%
 \gdef\thissection{#1}%
 \gdef\thischaptername{#1}%
 \xdef\thischapter{\putwordAppendix{} \appendixletter: \noexpand\thischaptername}%
-{\chapternofonts%
-\edef\temp{{\realbackslash chapentry
-  {#1}{\putwordAppendix{} \appendixletter}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp  %
-\appendixnoderef %
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
+                       {\putwordAppendix{} \appendixletter}}}%
+\temp
+\appendixnoderef
 \global\let\section = \appendixsec
 \global\let\subsection = \appendixsubsec
 \global\let\subsubsection = \appendixsubsubsec
-}}
-
+}
+
+% @centerchap is like @unnumbered, but the heading is centered.
+\outer\def\centerchap{\parsearg\centerchapyyy}
+\def\centerchapyyy #1{{\let\unnumbchapmacro=\centerchapmacro \unnumberedyyy{#1}}}
+
+% @top is like @unnumbered.
 \outer\def\top{\parsearg\unnumberedyyy}
+
 \outer\def\unnumbered{\parsearg\unnumberedyyy}
 \def\unnumberedyyy #1{\unnmhead0{#1}} % normally unnmhead0 calls unnumberedzzz
-\def\unnumberedzzz #1{\seccheck{unnumbered}%
+\def\unnumberedzzz #1{%
 \secno=0 \subsecno=0 \subsubsecno=0
 %
 % This used to be simply \message{#1}, but TeX fully expands the
 % argument to \message.  Therefore, if #1 contained @-commands, TeX
 % expanded them.  For example, in `@unnumbered The @cite{Book}', TeX
 % expanded @cite (which turns out to cause errors because \cite is meant
 % to be executed, not expanded).
 %
 % Anyway, we don't want the fully-expanded definition of @cite to appear
 % as a result of the \message, we just want `@cite' itself.  We use
 % \the<toks register> to achieve this: TeX expands \the<toks> only once,
-% simply yielding the contents of the <toks register>.
+% simply yielding the contents of <toks register>.  (We also do this for
+% the toc entries.)
 \toks0 = {#1}\message{(\the\toks0)}%
 %
 \unnumbchapmacro {#1}%
 \gdef\thischapter{#1}\gdef\thissection{#1}%
-{\chapternofonts%
-\edef\temp{{\realbackslash unnumbchapentry {#1}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp  %
-\unnumbnoderef %
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash unnumbchapentry{\the\toks0}}}%
+\temp
+\unnumbnoderef
 \global\let\section = \unnumberedsec
 \global\let\subsection = \unnumberedsubsec
 \global\let\subsubsection = \unnumberedsubsubsec
-}}
-
+}
+
+% Sections.
 \outer\def\numberedsec{\parsearg\secyyy}
 \def\secyyy #1{\numhead1{#1}} % normally calls seczzz
-\def\seczzz #1{\seccheck{section}%
+\def\seczzz #1{%
 \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
 \gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash secentry %
-{#1}{\the\chapno}{\the\secno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\donoderef %
-\penalty 10000 %
-}}
-
-\outer\def\appenixsection{\parsearg\appendixsecyyy}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
+                                  {\the\chapno}{\the\secno}}}%
+\temp
+\donoderef
+\nobreak
+}
+
+\outer\def\appendixsection{\parsearg\appendixsecyyy}
 \outer\def\appendixsec{\parsearg\appendixsecyyy}
 \def\appendixsecyyy #1{\apphead1{#1}} % normally calls appendixsectionzzz
-\def\appendixsectionzzz #1{\seccheck{appendixsection}%
+\def\appendixsectionzzz #1{%
 \subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
 \gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash secentry %
-{#1}{\appendixletter}{\the\secno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\appendixnoderef %
-\penalty 10000 %
-}}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
+                                  {\appendixletter}{\the\secno}}}%
+\temp
+\appendixnoderef
+\nobreak
+}
 
 \outer\def\unnumberedsec{\parsearg\unnumberedsecyyy}
 \def\unnumberedsecyyy #1{\unnmhead1{#1}} % normally calls unnumberedseczzz
-\def\unnumberedseczzz #1{\seccheck{unnumberedsec}%
+\def\unnumberedseczzz #1{%
 \plainsecheading {#1}\gdef\thissection{#1}%
-{\chapternofonts%
-\edef\temp{{\realbackslash unnumbsecentry{#1}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\unnumbnoderef %
-\penalty 10000 %
-}}
-
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsecentry{\the\toks0}}}%
+\temp
+\unnumbnoderef
+\nobreak
+}
+
+% Subsections.
 \outer\def\numberedsubsec{\parsearg\numberedsubsecyyy}
 \def\numberedsubsecyyy #1{\numhead2{#1}} % normally calls numberedsubseczzz
-\def\numberedsubseczzz #1{\seccheck{subsection}%
+\def\numberedsubseczzz #1{%
 \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
 \subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash subsecentry %
-{#1}{\the\chapno}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\donoderef %
-\penalty 10000 %
-}}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
+                                    {\the\chapno}{\the\secno}{\the\subsecno}}}%
+\temp
+\donoderef
+\nobreak
+}
 
 \outer\def\appendixsubsec{\parsearg\appendixsubsecyyy}
 \def\appendixsubsecyyy #1{\apphead2{#1}} % normally calls appendixsubseczzz
-\def\appendixsubseczzz #1{\seccheck{appendixsubsec}%
+\def\appendixsubseczzz #1{%
 \gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
 \subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash subsecentry %
-{#1}{\appendixletter}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\appendixnoderef %
-\penalty 10000 %
-}}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
+                                {\appendixletter}{\the\secno}{\the\subsecno}}}%
+\temp
+\appendixnoderef
+\nobreak
+}
 
 \outer\def\unnumberedsubsec{\parsearg\unnumberedsubsecyyy}
 \def\unnumberedsubsecyyy #1{\unnmhead2{#1}} %normally calls unnumberedsubseczzz
-\def\unnumberedsubseczzz #1{\seccheck{unnumberedsubsec}%
-\plainsecheading {#1}\gdef\thissection{#1}%
-{\chapternofonts%
-\edef\temp{{\realbackslash unnumbsubsecentry{#1}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\unnumbnoderef %
-\penalty 10000 %
-}}
-
+\def\unnumberedsubseczzz #1{%
+\plainsubsecheading {#1}\gdef\thissection{#1}%
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsecentry%
+                                    {\the\toks0}}}%
+\temp
+\unnumbnoderef
+\nobreak
+}
+
+% Subsubsections.
 \outer\def\numberedsubsubsec{\parsearg\numberedsubsubsecyyy}
 \def\numberedsubsubsecyyy #1{\numhead3{#1}} % normally numberedsubsubseczzz
-\def\numberedsubsubseczzz #1{\seccheck{subsubsection}%
+\def\numberedsubsubseczzz #1{%
 \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
 \subsubsecheading {#1}
   {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash subsubsecentry %
-  {#1}
-  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}
-  {\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\donoderef %
-\penalty 10000 %
-}}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
+  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
+\temp
+\donoderef
+\nobreak
+}
 
 \outer\def\appendixsubsubsec{\parsearg\appendixsubsubsecyyy}
 \def\appendixsubsubsecyyy #1{\apphead3{#1}} % normally appendixsubsubseczzz
-\def\appendixsubsubseczzz #1{\seccheck{appendixsubsubsec}%
+\def\appendixsubsubseczzz #1{%
 \gdef\thissection{#1}\global\advance \subsubsecno by 1 %
 \subsubsecheading {#1}
   {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
-{\chapternofonts%
-\edef\temp{{\realbackslash subsubsecentry{#1}%
-  {\appendixletter}
-  {\the\secno}{\the\subsecno}{\the\subsubsecno}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\appendixnoderef %
-\penalty 10000 %
-}}
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
+  {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
+\temp
+\appendixnoderef
+\nobreak
+}
 
 \outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubsecyyy}
 \def\unnumberedsubsubsecyyy #1{\unnmhead3{#1}} %normally unnumberedsubsubseczzz
-\def\unnumberedsubsubseczzz #1{\seccheck{unnumberedsubsubsec}%
-\plainsecheading {#1}\gdef\thissection{#1}%
-{\chapternofonts%
-\edef\temp{{\realbackslash unnumbsubsubsecentry{#1}{\noexpand\folio}}}%
-\escapechar=`\\%
-\write \contentsfile \temp %
-\unnumbnoderef %
-\penalty 10000 %
-}}
+\def\unnumberedsubsubseczzz #1{%
+\plainsubsubsecheading {#1}\gdef\thissection{#1}%
+\toks0 = {#1}%
+\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsubsecentry%
+                                    {\the\toks0}}}%
+\temp
+\unnumbnoderef
+\nobreak
+}
 
 % These are variants which are not "outer", so they can appear in @ifinfo.
 % Actually, they should now be obsolete; ordinary section commands should work.
 \def\infotop{\parsearg\unnumberedzzz}
 \def\infounnumbered{\parsearg\unnumberedzzz}
 \def\infounnumberedsec{\parsearg\unnumberedseczzz}
 \def\infounnumberedsubsec{\parsearg\unnumberedsubseczzz}
 \def\infounnumberedsubsubsec{\parsearg\unnumberedsubsubseczzz}
@@ -2712,18 +3574,17 @@ July\or August\or September\or October\o
 % to what kind of chapter we are in (ordinary, appendix, or unnumbered).
 % Define them by default for a numbered chapter.
 \global\let\section = \numberedsec
 \global\let\subsection = \numberedsubsec
 \global\let\subsubsection = \numberedsubsubsec
 
 % Define @majorheading, @heading and @subheading
 
-% NOTE on use of \vbox for chapter headings, section headings, and
-% such:
+% NOTE on use of \vbox for chapter headings, section headings, and such:
 %       1) We use \vbox rather than the earlier \line to permit
 %          overlong headings to fold.
 %       2) \hyphenpenalty is set to 10000 because hyphenation in a
 %          heading is obnoxious; this forbids it.
 %       3) Likewise, headings look best if no \parindent is used, and
 %          if justification is not attempted.  Hence \raggedright.
 
 
@@ -2735,330 +3596,403 @@ July\or August\or September\or October\o
                   \rm #1\hfill}}\bigskip \par\penalty 200}
 
 \def\chapheading{\parsearg\chapheadingzzz}
 \def\chapheadingzzz #1{\chapbreak %
 {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                   \parindent=0pt\raggedright
                   \rm #1\hfill}}\bigskip \par\penalty 200}
 
-\def\heading{\parsearg\secheadingi}
-
-\def\subheading{\parsearg\subsecheadingi}
-
-\def\subsubheading{\parsearg\subsubsecheadingi}
+% @heading, @subheading, @subsubheading.
+\def\heading{\parsearg\plainsecheading}
+\def\subheading{\parsearg\plainsubsecheading}
+\def\subsubheading{\parsearg\plainsubsubsecheading}
 
 % These macros generate a chapter, section, etc. heading only
 % (including whitespace, linebreaking, etc. around it),
 % given all the information in convenient, parsed form.
 
 %%% Args are the skip and penalty (usually negative)
 \def\dobreak#1#2{\par\ifdim\lastskip<#1\removelastskip\penalty#2\vskip#1\fi}
 
 \def\setchapterstyle #1 {\csname CHAPF#1\endcsname}
 
 %%% Define plain chapter starts, and page on/off switching for it
 % Parameter controlling skip before chapter headings (if needed)
 
-\newskip \chapheadingskip \chapheadingskip = 30pt plus 8pt minus 4pt
+\newskip\chapheadingskip
 
 \def\chapbreak{\dobreak \chapheadingskip {-4000}}
 \def\chappager{\par\vfill\supereject}
 \def\chapoddpage{\chappager \ifodd\pageno \else \hbox to 0pt{} \chappager\fi}
 
 \def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
 
-\def\CHAPPAGoff{
+\def\CHAPPAGoff{%
+\global\let\contentsalignmacro = \chappager
 \global\let\pchapsepmacro=\chapbreak
 \global\let\pagealignmacro=\chappager}
 
-\def\CHAPPAGon{
+\def\CHAPPAGon{%
+\global\let\contentsalignmacro = \chappager
 \global\let\pchapsepmacro=\chappager
 \global\let\pagealignmacro=\chappager
 \global\def\HEADINGSon{\HEADINGSsingle}}
 
 \def\CHAPPAGodd{
+\global\let\contentsalignmacro = \chapoddpage
 \global\let\pchapsepmacro=\chapoddpage
 \global\let\pagealignmacro=\chapoddpage
 \global\def\HEADINGSon{\HEADINGSdouble}}
 
 \CHAPPAGon
 
 \def\CHAPFplain{
 \global\let\chapmacro=\chfplain
-\global\let\unnumbchapmacro=\unnchfplain}
-
-\def\chfplain #1#2{%
+\global\let\unnumbchapmacro=\unnchfplain
+\global\let\centerchapmacro=\centerchfplain}
+
+% Plain chapter opening.
+% #1 is the text, #2 the chapter number or empty if unnumbered.
+\def\chfplain#1#2{%
   \pchapsepmacro
   {%
-    \chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                     \parindent=0pt\raggedright
-                     \rm #2\enspace #1}%
+    \chapfonts \rm
+    \def\chapnum{#2}%
+    \setbox0 = \hbox{#2\ifx\chapnum\empty\else\enspace\fi}%
+    \vbox{\hyphenpenalty=10000 \tolerance=5000 \parindent=0pt \raggedright
+          \hangindent = \wd0 \centerparametersmaybe
+          \unhbox0 #1\par}%
   }%
-  \bigskip
-  \penalty5000
+  \nobreak\bigskip % no page break after a chapter title
+  \nobreak
 }
 
-\def\unnchfplain #1{%
-\pchapsepmacro %
-{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                  \parindent=0pt\raggedright
-                  \rm #1\hfill}}\bigskip \par\penalty 10000 %
-}
+% Plain opening for unnumbered.
+\def\unnchfplain#1{\chfplain{#1}{}}
+
+% @centerchap -- centered and unnumbered.
+\let\centerparametersmaybe = \relax
+\def\centerchfplain#1{{%
+  \def\centerparametersmaybe{%
+    \advance\rightskip by 3\rightskip
+    \leftskip = \rightskip
+    \parfillskip = 0pt
+  }%
+  \chfplain{#1}{}%
+}}
+
 \CHAPFplain % The default
 
 \def\unnchfopen #1{%
 \chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
                        \parindent=0pt\raggedright
-                       \rm #1\hfill}}\bigskip \par\penalty 10000 %
+                       \rm #1\hfill}}\bigskip \par\nobreak
 }
 
 \def\chfopen #1#2{\chapoddpage {\chapfonts
 \vbox to 3in{\vfil \hbox to\hsize{\hfil #2} \hbox to\hsize{\hfil #1} \vfil}}%
 \par\penalty 5000 %
 }
 
+\def\centerchfopen #1{%
+\chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                       \parindent=0pt
+                       \hfill {\rm #1}\hfill}}\bigskip \par\nobreak
+}
+
 \def\CHAPFopen{
 \global\let\chapmacro=\chfopen
-\global\let\unnumbchapmacro=\unnchfopen}
-
-% Parameter controlling skip before section headings.
-
-\newskip \subsecheadingskip  \subsecheadingskip = 17pt plus 8pt minus 4pt
-\def\subsecheadingbreak{\dobreak \subsecheadingskip {-500}}
-
-\newskip \secheadingskip  \secheadingskip = 21pt plus 8pt minus 4pt
+\global\let\unnumbchapmacro=\unnchfopen
+\global\let\centerchapmacro=\centerchfopen}
+
+
+% Section titles.
+\newskip\secheadingskip
 \def\secheadingbreak{\dobreak \secheadingskip {-1000}}
-
-% @paragraphindent  is defined for the Info formatting commands only.
-\let\paragraphindent=\comment
-
-% Section fonts are the base font at magstep2, which produces
-% a size a bit more than 14 points in the default situation.
-
-\def\secheading #1#2#3{\secheadingi {#2.#3\enspace #1}}
-\def\plainsecheading #1{\secheadingi {#1}}
-\def\secheadingi #1{{\advance \secheadingskip by \parskip %
-\secheadingbreak}%
-{\secfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                 \parindent=0pt\raggedright
-                 \rm #1\hfill}}%
-\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
-
-
-% Subsection fonts are the base font at magstep1,
-% which produces a size of 12 points.
-
-\def\subsecheading #1#2#3#4{\subsecheadingi {#2.#3.#4\enspace #1}}
-\def\subsecheadingi #1{{\advance \subsecheadingskip by \parskip %
-\subsecheadingbreak}%
-{\subsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                     \parindent=0pt\raggedright
-                     \rm #1\hfill}}%
-\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
-
-\def\subsubsecfonts{\subsecfonts} % Maybe this should change:
-                                  % Perhaps make sssec fonts scaled
-                                  % magstep half
-\def\subsubsecheading #1#2#3#4#5{\subsubsecheadingi {#2.#3.#4.#5\enspace #1}}
-\def\subsubsecheadingi #1{{\advance \subsecheadingskip by \parskip %
-\subsecheadingbreak}%
-{\subsubsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                       \parindent=0pt\raggedright
-                       \rm #1\hfill}}%
-\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000}
-
-
-\message{toc printing,}
+\def\secheading#1#2#3{\sectionheading{sec}{#2.#3}{#1}}
+\def\plainsecheading#1{\sectionheading{sec}{}{#1}}
+
+% Subsection titles.
+\newskip \subsecheadingskip
+\def\subsecheadingbreak{\dobreak \subsecheadingskip {-500}}
+\def\subsecheading#1#2#3#4{\sectionheading{subsec}{#2.#3.#4}{#1}}
+\def\plainsubsecheading#1{\sectionheading{subsec}{}{#1}}
+
+% Subsubsection titles.
+\let\subsubsecheadingskip = \subsecheadingskip
+\let\subsubsecheadingbreak = \subsecheadingbreak
+\def\subsubsecheading#1#2#3#4#5{\sectionheading{subsubsec}{#2.#3.#4.#5}{#1}}
+\def\plainsubsubsecheading#1{\sectionheading{subsubsec}{}{#1}}
+
+
+% Print any size section title.
+%
+% #1 is the section type (sec/subsec/subsubsec), #2 is the section
+% number (maybe empty), #3 the text.
+\def\sectionheading#1#2#3{%
+  {%
+    \expandafter\advance\csname #1headingskip\endcsname by \parskip
+    \csname #1headingbreak\endcsname
+  }%
+  {%
+    % Switch to the right set of fonts.
+    \csname #1fonts\endcsname \rm
+    %
+    % Only insert the separating space if we have a section number.
+    \def\secnum{#2}%
+    \setbox0 = \hbox{#2\ifx\secnum\empty\else\enspace\fi}%
+    %
+    \vbox{\hyphenpenalty=10000 \tolerance=5000 \parindent=0pt \raggedright
+          \hangindent = \wd0 % zero if no section number
+          \unhbox0 #3}%
+  }%
+  \ifdim\parskip<10pt \nobreak\kern10pt\nobreak\kern-\parskip\fi \nobreak
+}
+
+
+\message{toc,}
+% Table of contents.
+\newwrite\tocfile
+
+% Write an entry to the toc file, opening it if necessary.
+% Called from @chapter, etc.  We supply {\folio} at the end of the
+% argument, which will end up as the last argument to the \...entry macro.
+%
+% We open the .toc file here instead of at @setfilename or any other
+% given time so that @contents can be put in the document anywhere.
+%
+\newif\iftocfileopened
+\def\writetocentry#1{%
+  \iftocfileopened\else
+    \immediate\openout\tocfile = \jobname.toc
+    \global\tocfileopenedtrue
+  \fi
+  \iflinks \write\tocfile{#1{\folio}}\fi
+}
+
+\newskip\contentsrightmargin \contentsrightmargin=1in
+\newcount\savepageno
+\newcount\lastnegativepageno \lastnegativepageno = -1
 
 % Finish up the main text and prepare to read what we've written
-% to \contentsfile.
-
-\newskip\contentsrightmargin \contentsrightmargin=1in
+% to \tocfile.
+%
 \def\startcontents#1{%
-   \pagealignmacro
-   \immediate\closeout \contentsfile
-   \ifnum \pageno>0
-      \pageno = -1              % Request roman numbered pages.
-   \fi
+   % If @setchapternewpage on, and @headings double, the contents should
+   % start on an odd page, unlike chapters.  Thus, we maintain
+   % \contentsalignmacro in parallel with \pagealignmacro.
+   % From: Torbjorn Granlund <tege@matematik.su.se>
+   \contentsalignmacro
+   \immediate\closeout\tocfile
+   %
    % Don't need to put `Contents' or `Short Contents' in the headline.
    % It is abundantly clear what they are.
    \unnumbchapmacro{#1}\def\thischapter{}%
+   \savepageno = \pageno
    \begingroup                  % Set up to handle contents files properly.
       \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
-      \catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
+      % We can't do this, because then an actual ^ in a section
+      % title fails, e.g., @chapter ^ -- exponentiation.  --karl, 9jul97.
+      %\catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
       \raggedbottom             % Worry more about breakpoints than the bottom.
       \advance\hsize by -\contentsrightmargin % Don't use the full line length.
+      %
+      % Roman numerals for page numbers.
+      \ifnum \pageno>0 \pageno = \lastnegativepageno \fi
 }
 
 
 % Normal (long) toc.
-\outer\def\contents{%
-   \startcontents{\putwordTableofContents}%
-      \input \jobname.toc
+\def\contents{%
+   \startcontents{\putwordTOC}%
+     \openin 1 \jobname.toc
+     \ifeof 1 \else
+       \closein 1
+       \input \jobname.toc
+     \fi
+     \vfill \eject
+     \contentsalignmacro % in case @setchapternewpage odd is in effect
+     \pdfmakeoutlines
    \endgroup
-   \vfill \eject
+   \lastnegativepageno = \pageno
+   \pageno = \savepageno
 }
 
 % And just the chapters.
-\outer\def\summarycontents{%
-   \startcontents{\putwordShortContents}%
+\def\summarycontents{%
+   \startcontents{\putwordShortTOC}%
       %
       \let\chapentry = \shortchapentry
       \let\unnumbchapentry = \shortunnumberedentry
       % We want a true roman here for the page numbers.
       \secfonts
       \let\rm=\shortcontrm \let\bf=\shortcontbf \let\sl=\shortcontsl
       \rm
+      \hyphenpenalty = 10000
       \advance\baselineskip by 1pt % Open it up a little.
       \def\secentry ##1##2##3##4{}
       \def\unnumbsecentry ##1##2{}
       \def\subsecentry ##1##2##3##4##5{}
       \def\unnumbsubsecentry ##1##2{}
       \def\subsubsecentry ##1##2##3##4##5##6{}
       \def\unnumbsubsubsecentry ##1##2{}
-      \input \jobname.toc
+      \openin 1 \jobname.toc
+      \ifeof 1 \else
+        \closein 1
+        \input \jobname.toc
+      \fi
+     \vfill \eject
+     \contentsalignmacro % in case @setchapternewpage odd is in effect
    \endgroup
-   \vfill \eject
+   \lastnegativepageno = \pageno
+   \pageno = \savepageno
 }
 \let\shortcontents = \summarycontents
 
+\ifpdf
+  \pdfcatalog{/PageMode /UseOutlines}%
+\fi
+
 % These macros generate individual entries in the table of contents.
 % The first argument is the chapter or section name.
 % The last argument is the page number.
 % The arguments in between are the chapter number, section number, ...
 
 % Chapter-level things, for both the long and short contents.
 \def\chapentry#1#2#3{\dochapentry{#2\labelspace#1}{#3}}
 
 % See comments in \dochapentry re vbox and related settings
 \def\shortchapentry#1#2#3{%
-  \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno{#3}}%
+  \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno\bgroup#3\egroup}%
 }
 
 % Typeset the label for a chapter or appendix for the short contents.
 % The arg is, e.g. `Appendix A' for an appendix, or `3' for a chapter.
 % We could simplify the code here by writing out an \appendixentry
 % command in the toc file for appendices, instead of using \chapentry
 % for both, but it doesn't seem worth it.
-\setbox0 = \hbox{\shortcontrm \putwordAppendix }
-\newdimen\shortappendixwidth \shortappendixwidth = \wd0
-
+%
+\newdimen\shortappendixwidth
+%
 \def\shortchaplabel#1{%
+  % Compute width of word "Appendix", may change with language.
+  \setbox0 = \hbox{\shortcontrm \putwordAppendix}%
+  \shortappendixwidth = \wd0
+  %
   % We typeset #1 in a box of constant width, regardless of the text of
   % #1, so the chapter titles will come out aligned.
   \setbox0 = \hbox{#1}%
   \dimen0 = \ifdim\wd0 > \shortappendixwidth \shortappendixwidth \else 0pt \fi
   %
   % This space should be plenty, since a single number is .5em, and the
   % widest letter (M) is 1em, at least in the Computer Modern fonts.
   % (This space doesn't include the extra space that gets added after
-  % the label; that gets put in in \shortchapentry above.)
+  % the label; that gets put in by \shortchapentry above.)
   \advance\dimen0 by 1.1em
   \hbox to \dimen0{#1\hfil}%
 }
 
 \def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
-\def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno{#2}}}
+\def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno\bgroup#2\egroup}}
 
 % Sections.
 \def\secentry#1#2#3#4{\dosecentry{#2.#3\labelspace#1}{#4}}
 \def\unnumbsecentry#1#2{\dosecentry{#1}{#2}}
 
 % Subsections.
 \def\subsecentry#1#2#3#4#5{\dosubsecentry{#2.#3.#4\labelspace#1}{#5}}
 \def\unnumbsubsecentry#1#2{\dosubsecentry{#1}{#2}}
 
 % And subsubsections.
 \def\subsubsecentry#1#2#3#4#5#6{%
   \dosubsubsecentry{#2.#3.#4.#5\labelspace#1}{#6}}
 \def\unnumbsubsubsecentry#1#2{\dosubsubsecentry{#1}{#2}}
 
-
 % This parameter controls the indentation of the various levels.
 \newdimen\tocindent \tocindent = 3pc
 
 % Now for the actual typesetting. In all these, #1 is the text and #2 is the
 % page number.
 %
-% If the toc has to be broken over pages, we would want to be at chapters
+% If the toc has to be broken over pages, we want it to be at chapters
 % if at all possible; hence the \penalty.
 \def\dochapentry#1#2{%
-   \penalty-300 \vskip\baselineskip
+   \penalty-300 \vskip1\baselineskip plus.33\baselineskip minus.25\baselineskip
    \begingroup
      \chapentryfonts
-     \tocentry{#1}{\dopageno{#2}}%
+     \tocentry{#1}{\dopageno\bgroup#2\egroup}%
    \endgroup
-   \nobreak\vskip .25\baselineskip
+   \nobreak\vskip .25\baselineskip plus.1\baselineskip
 }
 
 \def\dosecentry#1#2{\begingroup
   \secentryfonts \leftskip=\tocindent
-  \tocentry{#1}{\dopageno{#2}}%
+  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
 \endgroup}
 
 \def\dosubsecentry#1#2{\begingroup
   \subsecentryfonts \leftskip=2\tocindent
-  \tocentry{#1}{\dopageno{#2}}%
+  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
 \endgroup}
 
 \def\dosubsubsecentry#1#2{\begingroup
   \subsubsecentryfonts \leftskip=3\tocindent
-  \tocentry{#1}{\dopageno{#2}}%
+  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
 \endgroup}
 
 % Final typesetting of a toc entry; we use the same \entry macro as for
 % the index entries, but we want to suppress hyphenation here.  (We
 % can't do that in the \entry macro, since index entries might consist
 % of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)
-%
 \def\tocentry#1#2{\begingroup
-  \hyphenpenalty = 10000
+  \vskip 0pt plus1pt % allow a little stretch for the sake of nice page breaks
+  % Do not use \turnoffactive in these arguments.  Since the toc is
+  % typeset in cmr, so characters such as _ would come out wrong; we
+  % have to do the usual translation tricks.
   \entry{#1}{#2}%
 \endgroup}
 
 % Space between chapter (or whatever) number and the title.
 \def\labelspace{\hskip1em \relax}
 
 \def\dopageno#1{{\rm #1}}
 \def\doshortpageno#1{{\rm #1}}
 
 \def\chapentryfonts{\secfonts \rm}
 \def\secentryfonts{\textfonts}
 \let\subsecentryfonts = \textfonts
 \let\subsubsecentryfonts = \textfonts
 
 
 \message{environments,}
+% @foo ... @end foo.
 
 % Since these characters are used in examples, it should be an even number of
 % \tt widths. Each \tt character is 1en, so two makes it 1em.
 % Furthermore, these definitions must come after we define our fonts.
 \newbox\dblarrowbox    \newbox\longdblarrowbox
 \newbox\pushcharbox    \newbox\bullbox
 \newbox\equivbox       \newbox\errorbox
 
-\let\ptexequiv = \equiv
-
 %{\tentt
 %\global\setbox\dblarrowbox = \hbox to 1em{\hfil$\Rightarrow$\hfil}
 %\global\setbox\longdblarrowbox = \hbox to 1em{\hfil$\mapsto$\hfil}
 %\global\setbox\pushcharbox = \hbox to 1em{\hfil$\dashv$\hfil}
 %\global\setbox\equivbox = \hbox to 1em{\hfil$\ptexequiv$\hfil}
 % Adapted from the manmac format (p.420 of TeXbook)
 %\global\setbox\bullbox = \hbox to 1em{\kern.15em\vrule height .75ex width .85ex
 %                                      depth .1ex\hfil}
 %}
 
+% @point{}, @result{}, @expansion{}, @print{}, @equiv{}.
 \def\point{$\star$}
-
 \def\result{\leavevmode\raise.15ex\hbox to 1em{\hfil$\Rightarrow$\hfil}}
 \def\expansion{\leavevmode\raise.1ex\hbox to 1em{\hfil$\mapsto$\hfil}}
 \def\print{\leavevmode\lower.1ex\hbox to 1em{\hfil$\dashv$\hfil}}
-
 \def\equiv{\leavevmode\lower.1ex\hbox to 1em{\hfil$\ptexequiv$\hfil}}
 
 % Adapted from the TeXbook's \boxit.
 {\tentt \global\dimen0 = 3em}% Width of the box.
 \dimen2 = .55pt % Thickness of rules
 % The text. (`r' is open on the right, `e' somewhat less so on the left.)
 \setbox0 = \hbox{\kern-.75pt \tensf error\kern-1.5pt}
 
@@ -3076,39 +4010,46 @@ July\or August\or September\or October\o
 % The @error{} command.
 \def\error{\leavevmode\lower.7ex\copy\errorbox}
 
 % @tex ... @end tex    escapes into raw Tex temporarily.
 % One exception: @ is still an escape character, so that @end tex works.
 % But \@ or @@ will get a plain tex @ character.
 
 \def\tex{\begingroup
-\catcode `\\=0 \catcode `\{=1 \catcode `\}=2
-\catcode `\$=3 \catcode `\&=4 \catcode `\#=6
-\catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
-\catcode `\%=14
-\catcode 43=12
-\catcode`\"=12
-\catcode`\==12
-\catcode`\|=12
-\catcode`\<=12
-\catcode`\>=12
-\escapechar=`\\
-%
-\let\~=\ptextilde
-\let\{=\ptexlbrace
-\let\}=\ptexrbrace
-\let\.=\ptexdot
-\let\*=\ptexstar
-\let\dots=\ptexdots
-\def\@{@}%
-\let\bullet=\ptexbullet
-\let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext \let\l=\ptexl
-\let\L=\ptexL
-%
+  \catcode `\\=0 \catcode `\{=1 \catcode `\}=2
+  \catcode `\$=3 \catcode `\&=4 \catcode `\#=6
+  \catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
+  \catcode `\%=14
+  \catcode 43=12 % plus
+  \catcode`\"=12
+  \catcode`\==12
+  \catcode`\|=12
+  \catcode`\<=12
+  \catcode`\>=12
+  \escapechar=`\\
+  %
+  \let\b=\ptexb
+  \let\bullet=\ptexbullet
+  \let\c=\ptexc
+  \let\,=\ptexcomma
+  \let\.=\ptexdot
+  \let\dots=\ptexdots
+  \let\equiv=\ptexequiv
+  \let\!=\ptexexclam
+  \let\i=\ptexi
+  \let\{=\ptexlbrace
+  \let\+=\tabalign
+  \let\}=\ptexrbrace
+  \let\*=\ptexstar
+  \let\t=\ptext
+  %
+  \def\endldots{\mathinner{\ldots\ldots\ldots\ldots}}%
+  \def\enddots{\relax\ifmmode\endldots\else$\mathsurround=0pt \endldots\,$\fi}%
+  \def\@{@}%
 \let\Etex=\endgroup}
 
 % Define @lisp ... @endlisp.
 % @lisp does a \begingroup so it can rebind things,
 % including the definition of @endlisp (which normally is erroneous).
 
 % Amount to narrow the margins by for @lisp.
 \newskip\lispnarrowing \lispnarrowing=0.4in
@@ -3143,18 +4084,18 @@ July\or August\or September\or October\o
 \endgraf \ifdim\lastskip<\envskipamount
 \removelastskip \penalty-50 \vskip\envskipamount \fi}}
 
 \let\afterenvbreak = \aboveenvbreak
 
 % \nonarrowing is a flag.  If "set", @lisp etc don't narrow margins.
 \let\nonarrowing=\relax
 
-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-% \cartouche: draw rectangle w/rounded corners around argument
+% @cartouche ... @end cartouche: draw rectangle w/rounded corners around
+% environment contents.
 \font\circle=lcircle10
 \newdimen\circthick
 \newdimen\cartouter\newdimen\cartinner
 \newskip\normbskip\newskip\normpskip\newskip\normlskip
 \circthick=\fontdimen8\circle
 %
 \def\ctl{{\circle\char'013\hskip -6pt}}% 6pt from pl file: 1/2charwidth
 \def\ctr{{\hskip 6pt\circle\char'010}}
@@ -3171,19 +4112,19 @@ July\or August\or September\or October\o
 
 \long\def\cartouche{%
 \begingroup
         \lskip=\leftskip \rskip=\rightskip
         \leftskip=0pt\rightskip=0pt %we want these *outside*.
         \cartinner=\hsize \advance\cartinner by-\lskip
                           \advance\cartinner by-\rskip
         \cartouter=\hsize
-        \advance\cartouter by 18pt % allow for 3pt kerns on either
+        \advance\cartouter by 18.4pt % allow for 3pt kerns on either
 %                                    side, and for 6pt waste from
-%                                    each corner char
+%                                    each corner char, and rule thickness
         \normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
         % Flag to tell @lisp, etc., not to narrow margin.
         \let\nonarrowing=\comment
         \vbox\bgroup
                 \baselineskip=0pt\parskip=0pt\lineskip=0pt
                 \carttop
                 \hbox\bgroup
                         \hskip\lskip
@@ -3227,89 +4168,107 @@ July\or August\or September\or October\o
   \ifx\nonarrowing\relax
     \advance \leftskip by \lispnarrowing
     \exdentamount=\lispnarrowing
     \let\exdent=\nofillexdent
     \let\nonarrowing=\relax
   \fi
 }
 
-% To ending an @example-like environment, we first end the paragraph
-% (via \afterenvbreak's vertical glue), and then the group.  That way we
-% keep the zero \parskip that the environments set -- \parskip glue
-% will be inserted at the beginning of the next paragraph in the
-% document, after the environment.
+% Define the \E... control sequence only if we are inside the particular
+% environment, so the error checking in \end will work.
 %
-\def\nonfillfinish{\afterenvbreak\endgroup}%
-
-% This macro is
+% To end an @example-like environment, we first end the paragraph (via
+% \afterenvbreak's vertical glue), and then the group.  That way we keep
+% the zero \parskip that the environments set -- \parskip glue will be
+% inserted at the beginning of the next paragraph in the document, after
+% the environment.
+%
+\def\nonfillfinish{\afterenvbreak\endgroup}
+
+% @lisp: indented, narrowed, typewriter font.
 \def\lisp{\begingroup
   \nonfillstart
   \let\Elisp = \nonfillfinish
   \tt
-  \rawbackslash % have \ input char produce \ char from current font
-  \gobble
+  \let\kbdfont = \kbdexamplefont % Allow @kbd to do something special.
+  \gobble       % eat return
 }
 
-% Define the \E... control sequence only if we are inside the
-% environment, so the error checking in \end will work.
-%
-% We must call \lisp last in the definition, since it reads the
-% return following the @example (or whatever) command.
-%
+% @example: Same as @lisp.
 \def\example{\begingroup \def\Eexample{\nonfillfinish\endgroup}\lisp}
-\def\smallexample{\begingroup \def\Esmallexample{\nonfillfinish\endgroup}\lisp}
-\def\smalllisp{\begingroup \def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
-
-% @smallexample and @smalllisp.  This is not used unless the @smallbook
-% command is given.  Originally contributed by Pavel@xerox.
+
+% @small... is usually equivalent to the non-small (@smallbook
+% redefines).  We must call \example (or whatever) last in the
+% definition, since it reads the return following the @example (or
+% whatever) command.
 %
+% This actually allows (for example) @end display inside an
+% @smalldisplay.  Too bad, but makeinfo will catch the error anyway.
+%
+\def\smalldisplay{\begingroup\def\Esmalldisplay{\nonfillfinish\endgroup}\display}
+\def\smallexample{\begingroup\def\Esmallexample{\nonfillfinish\endgroup}\lisp}
+\def\smallformat{\begingroup\def\Esmallformat{\nonfillfinish\endgroup}\format}
+\def\smalllisp{\begingroup\def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
+
+% Real @smallexample and @smalllisp (when @smallbook): use smaller fonts.
+% Originally contributed by Pavel@xerox.
 \def\smalllispx{\begingroup
-  \nonfillstart
-  \let\Esmalllisp = \nonfillfinish
-  \let\Esmallexample = \nonfillfinish
-  %
-  % Smaller interline space and fonts for small examples.
-  \setleading{10pt}%
-  \indexfonts \tt
-  \rawbackslash % make \ output the \ character from the current font (tt)
-  \gobble
+  \def\Esmalllisp{\nonfillfinish\endgroup}%
+  \def\Esmallexample{\nonfillfinish\endgroup}%
+  \smallfonts
+  \lisp
 }
 
-% This is @display; same as @lisp except use roman font.
+% @display: same as @lisp except keep current font.
 %
 \def\display{\begingroup
   \nonfillstart
   \let\Edisplay = \nonfillfinish
   \gobble
 }
 
-% This is @format; same as @display except don't narrow margins.
+% @smalldisplay (when @smallbook): @display plus smaller fonts.
+%
+\def\smalldisplayx{\begingroup
+  \def\Esmalldisplay{\nonfillfinish\endgroup}%
+  \smallfonts \rm
+  \display
+}
+
+% @format: same as @display except don't narrow margins.
 %
 \def\format{\begingroup
   \let\nonarrowing = t
   \nonfillstart
   \let\Eformat = \nonfillfinish
   \gobble
 }
 
-% @flushleft (same as @format) and @flushright.
+% @smallformat (when @smallbook): @format plus smaller fonts.
 %
-\def\flushleft{\begingroup
-  \let\nonarrowing = t
-  \nonfillstart
-  \let\Eflushleft = \nonfillfinish
-  \gobble
+\def\smallformatx{\begingroup
+  \def\Esmallformat{\nonfillfinish\endgroup}%
+  \smallfonts \rm
+  \format
 }
+
+% @flushleft (same as @format).
+%
+\def\flushleft{\begingroup \def\Eflushleft{\nonfillfinish\endgroup}\format}
+
+% @flushright.
+%
 \def\flushright{\begingroup
   \let\nonarrowing = t
   \nonfillstart
   \let\Eflushright = \nonfillfinish
   \advance\leftskip by 0pt plus 1fill
-  \gobble}
+  \gobble
+}
 
 % @quotation does normal linebreaking (hence we can't use \nonfillstart)
 % and narrows the margins.
 %
 \def\quotation{%
   \begingroup\inENV %This group ends at the end of the @quotation body
   {\parskip=0pt \aboveenvbreak}% because \aboveenvbreak inserts \parskip
   \singlespace
@@ -3322,19 +4281,21 @@ July\or August\or September\or October\o
   \ifx\nonarrowing\relax
     \advance\leftskip by \lispnarrowing
     \advance\rightskip by \lispnarrowing
     \exdentamount = \lispnarrowing
     \let\nonarrowing = \relax
   \fi
 }
 
+
 \message{defuns,}
-% Define formatter for defuns
-% First, allow user to change definition object font (\df) internally
+% @defun etc.
+
+% Allow user to change definition object font (\df) internally
 \def\setdeffont #1 {\csname DEF#1\endcsname}
 
 \newskip\defbodyindent \defbodyindent=.4in
 \newskip\defargsindent \defargsindent=50pt
 \newskip\deftypemargin \deftypemargin=12pt
 \newskip\deflastargmargin \deflastargmargin=18pt
 
 \newcount\parencount
@@ -3358,59 +4319,67 @@ July\or August\or September\or October\o
 \gdef\functionparens{\boldbrax\let&=\amprm\parencount=0 }
 \gdef\boldbrax{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb}
 % This is used to turn on special parens
 % but make & act ordinary (given that it's active).
 \gdef\boldbraxnoamp{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb\let&=\ampnr}
 
 % Definitions of (, ) and & used in args for functions.
 % This is the definition of ( outside of all parentheses.
-\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested %
-\global\advance\parencount by 1 }
+\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested
+  \global\advance\parencount by 1
+}
 %
 % This is the definition of ( when already inside a level of parens.
 \gdef\opnested{\char`\(\global\advance\parencount by 1 }
 %
 \gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
-% also in that case restore the outer-level definition of (.
-\ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
-\global\advance \parencount by -1 }
+  % also in that case restore the outer-level definition of (.
+  \ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
+  \global\advance \parencount by -1 }
 % If we encounter &foo, then turn on ()-hacking afterwards
 \gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
 %
 \gdef\normalparens{\boldbrax\let&=\ampnr}
 } % End of definition inside \activeparens
 %% These parens (in \boldbrax) actually are a little bolder than the
 %% contained text.  This is especially needed for [ and ]
-\def\opnr{{\sf\char`\(}} \def\clnr{{\sf\char`\)}} \def\ampnr{\&}
-\def\lbrb{{\bf\char`\[}} \def\rbrb{{\bf\char`\]}}
+\def\opnr{{\sf\char`\(}\global\advance\parencount by 1 }
+\def\clnr{{\sf\char`\)}\global\advance\parencount by -1 }
+\let\ampnr = \&
+\def\lbrb{{\bf\char`\[}}
+\def\rbrb{{\bf\char`\]}}
+
+% Active &'s sneak into the index arguments, so make sure it's defined.
+{
+  \catcode`& = 13
+  \global\let& = \ampnr
+}
 
 % First, defname, which formats the header line itself.
 % #1 should be the function name.
 % #2 should be the type of definition, such as "Function".
 
 \def\defname #1#2{%
 % Get the values of \leftskip and \rightskip as they were
 % outside the @def...
 \dimen2=\leftskip
 \advance\dimen2 by -\defbodyindent
-\dimen3=\rightskip
-\advance\dimen3 by -\defbodyindent
-\noindent        %
+\noindent
 \setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
 \dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
 \dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
-\parshape 2 0in \dimen0 \defargsindent \dimen1     %
+\parshape 2 0in \dimen0 \defargsindent \dimen1
 % Now output arg 2 ("Function" or some such)
 % ending at \deftypemargin from the right margin,
 % but stuck inside a box of width 0 so it does not interfere with linebreaking
 {% Adjust \hsize to exclude the ambient margins,
 % so that \rightline will obey them.
-\advance \hsize by -\dimen2 \advance \hsize by -\dimen3
-\rlap{\rightline{{\rm #2}\hskip \deftypemargin}}}%
+\advance \hsize by -\dimen2
+\rlap{\rightline{{\rm #2}\hskip -1.25pc }}}%
 % Make all lines underfull and no complaints:
 \tolerance=10000 \hbadness=10000
 \advance\leftskip by -\defbodyindent
 \exdentamount=\defbodyindent
 {\df #1}\enskip        % Generate function name
 }
 
 % Actually process the body of a definition
@@ -3421,74 +4390,113 @@ July\or August\or September\or October\o
 
 \def\defparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
 \medbreak %
 % Define the end token that this defining construct specifies
 % so that it will exit this group.
 \def#1{\endgraf\endgroup\medbreak}%
 \def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
 \parindent=0in
-\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\advance\leftskip by \defbodyindent
 \exdentamount=\defbodyindent
 \begingroup %
 \catcode 61=\active % 61 is `='
 \obeylines\activeparens\spacesplit#3}
 
-\def\defmethparsebody #1#2#3#4 {\begingroup\inENV %
+% #1 is the \E... control sequence to end the definition (which we define).
+% #2 is the \...x control sequence for consecutive fns (which we define).
+% #3 is the control sequence to call to resume processing.
+% #4, delimited by the space, is the class name.
+%
+\def\defmethparsebody#1#2#3#4 {\begingroup\inENV %
 \medbreak %
 % Define the end token that this defining construct specifies
 % so that it will exit this group.
 \def#1{\endgraf\endgroup\medbreak}%
 \def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
 \parindent=0in
-\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\advance\leftskip by \defbodyindent
 \exdentamount=\defbodyindent
 \begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
 
+% Used for @deftypemethod and @deftypeivar.
+% #1 is the \E... control sequence to end the definition (which we define).
+% #2 is the \...x control sequence for consecutive fns (which we define).
+% #3 is the control sequence to call to resume processing.
+% #4, delimited by a space, is the class name.
+% #5 is the method's return type.
+%
+\def\deftypemethparsebody#1#2#3#4 #5 {\begingroup\inENV
+  \medbreak
+  \def#1{\endgraf\endgroup\medbreak}%
+  \def#2##1 ##2 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}{##2}}}%
+  \parindent=0in
+  \advance\leftskip by \defbodyindent
+  \exdentamount=\defbodyindent
+  \begingroup\obeylines\activeparens\spacesplit{#3{#4}{#5}}}
+
+% Used for @deftypeop.  The change from \deftypemethparsebody is an
+% extra argument at the beginning which is the `category', instead of it
+% being the hardwired string `Method' or `Instance Variable'.  We have
+% to account for this both in the \...x definition and in parsing the
+% input at hand.  Thus also need a control sequence (passed as #5) for
+% the \E... definition to assign the category name to.
+% 
+\def\deftypeopparsebody#1#2#3#4#5 #6 {\begingroup\inENV
+  \medbreak
+  \def#1{\endgraf\endgroup\medbreak}%
+  \def#2##1 ##2 ##3 {%
+    \def#4{##1}%
+    \begingroup\obeylines\activeparens\spacesplit{#3{##2}{##3}}}%
+  \parindent=0in
+  \advance\leftskip by \defbodyindent
+  \exdentamount=\defbodyindent
+  \begingroup\obeylines\activeparens\spacesplit{#3{#5}{#6}}}
+
 \def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
 \medbreak %
 % Define the end token that this defining construct specifies
 % so that it will exit this group.
 \def#1{\endgraf\endgroup\medbreak}%
 \def#2##1 ##2 {\def#4{##1}%
 \begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
 \parindent=0in
-\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\advance\leftskip by \defbodyindent
 \exdentamount=\defbodyindent
 \begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
 
 % These parsing functions are similar to the preceding ones
 % except that they do not make parens into active characters.
 % These are used for "variables" since they have no arguments.
 
 \def\defvarparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
 \medbreak %
 % Define the end token that this defining construct specifies
 % so that it will exit this group.
 \def#1{\endgraf\endgroup\medbreak}%
 \def#2{\begingroup\obeylines\spacesplit#3}%
 \parindent=0in
-\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\advance\leftskip by \defbodyindent
 \exdentamount=\defbodyindent
 \begingroup %
 \catcode 61=\active %
 \obeylines\spacesplit#3}
 
 % This is used for \def{tp,vr}parsebody.  It could probably be used for
 % some of the others, too, with some judicious conditionals.
-% 
+%
 \def\parsebodycommon#1#2#3{%
   \begingroup\inENV %
   \medbreak %
   % Define the end token that this defining construct specifies
   % so that it will exit this group.
   \def#1{\endgraf\endgroup\medbreak}%
   \def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
   \parindent=0in
-  \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+  \advance\leftskip by \defbodyindent
   \exdentamount=\defbodyindent
   \begingroup\obeylines
 }
 
 \def\defvrparsebody#1#2#3#4 {%
   \parsebodycommon{#1}{#2}{#3}%
   \spacesplit{#3{#4}}%
 }
@@ -3503,38 +4511,37 @@ July\or August\or September\or October\o
 % won't strip off the braces.
 %
 \def\deftpparsebody #1#2#3#4 {%
   \parsebodycommon{#1}{#2}{#3}%
   \spacesplit{\parsetpheaderline{#3{#4}}}\empty
 }
 
 % Fine, but then we have to eventually remove the \empty *and* the
-% braces (if any).  That's what this does, putting the result in \tptemp.
-% 
-\def\removeemptybraces\empty#1\relax{\def\tptemp{#1}}%
+% braces (if any).  That's what this does.
+%
+\def\removeemptybraces\empty#1\relax{#1}
 
 % After \spacesplit has done its work, this is called -- #1 is the final
 % thing to call, #2 the type name (which starts with \empty), and #3
 % (which might be empty) the arguments.
-% 
+%
 \def\parsetpheaderline#1#2#3{%
-  \removeemptybraces#2\relax
-  #1{\tptemp}{#3}%
+  #1{\removeemptybraces#2\relax}{#3}%
 }%
 
 \def\defopvarparsebody #1#2#3#4#5 {\begingroup\inENV %
 \medbreak %
 % Define the end token that this defining construct specifies
 % so that it will exit this group.
 \def#1{\endgraf\endgroup\medbreak}%
 \def#2##1 ##2 {\def#4{##1}%
 \begingroup\obeylines\spacesplit{#3{##2}}}%
 \parindent=0in
-\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\advance\leftskip by \defbodyindent
 \exdentamount=\defbodyindent
 \begingroup\obeylines\spacesplit{#3{#5}}}
 
 % Split up #2 at the first space token.
 % call #1 with two arguments:
 %  the first is all of #2 before the space token,
 %  the second is all of #2 after that space token.
 % If #2 contains no space token, all of it is passed as the first arg
@@ -3548,37 +4555,38 @@ July\or August\or September\or October\o
 
 % So much for the things common to all kinds of definitions.
 
 % Define @defun.
 
 % First, define the processing that is wanted for arguments of \defun
 % Use this to expand the args and terminate the paragraph they make up
 
-\def\defunargs #1{\functionparens \sl
+\def\defunargs#1{\functionparens \sl
 % Expand, preventing hyphenation at `-' chars.
 % Note that groups don't affect changes in \hyphenchar.
-\hyphenchar\tensl=0
+% Set the font temporarily and use \font in case \setfont made \tensl a macro.
+{\tensl\hyphenchar\font=0}%
 #1%
-\hyphenchar\tensl=45
-\ifnum\parencount=0 \else \errmessage{unbalanced parens in @def arguments}\fi%
+{\tensl\hyphenchar\font=45}%
+\ifnum\parencount=0 \else \errmessage{Unbalanced parentheses in @def}\fi%
 \interlinepenalty=10000
 \advance\rightskip by 0pt plus 1fil
-\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
+\endgraf\nobreak\vskip -\parskip\nobreak
 }
 
 \def\deftypefunargs #1{%
 % Expand, preventing hyphenation at `-' chars.
 % Note that groups don't affect changes in \hyphenchar.
 % Use \boldbraxnoamp, not \functionparens, so that & is not special.
 \boldbraxnoamp
 \tclose{#1}% avoid \code because of side effects on active chars
 \interlinepenalty=10000
 \advance\rightskip by 0pt plus 1fil
-\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
+\endgraf\nobreak\vskip -\parskip\nobreak
 }
 
 % Do complete processing of one @defun or @defunx line already parsed.
 
 % @deffn Command forward-char nchars
 
 \def\deffn{\defmethparsebody\Edeffn\deffnx\deffnheader}
 
@@ -3587,31 +4595,31 @@ July\or August\or September\or October\o
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
 % @defun == @deffn Function
 
 \def\defun{\defparsebody\Edefun\defunx\defunheader}
 
 \def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{Function}%
+\begingroup\defname {#1}{\putwordDeffunc}%
 \defunargs {#2}\endgroup %
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
 % @deftypefun int foobar (int @var{foo}, float @var{bar})
 
 \def\deftypefun{\defparsebody\Edeftypefun\deftypefunx\deftypefunheader}
 
 % #1 is the data type.  #2 is the name and args.
 \def\deftypefunheader #1#2{\deftypefunheaderx{#1}#2 \relax}
 % #1 is the data type, #2 the name, #3 the args.
 \def\deftypefunheaderx #1#2 #3\relax{%
 \doind {fn}{\code{#2}}% Make entry in function index
-\begingroup\defname {\defheaderxcond#1\relax$$$#2}{Function}%
+\begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypefun}%
 \deftypefunargs {#3}\endgroup %
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
 % @deftypefn {Library Function} int foobar (int @var{foo}, float @var{bar})
 
 \def\deftypefn{\defmethparsebody\Edeftypefn\deftypefnx\deftypefnheader}
 
@@ -3632,264 +4640,660 @@ July\or August\or September\or October\o
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
 % @defmac == @deffn Macro
 
 \def\defmac{\defparsebody\Edefmac\defmacx\defmacheader}
 
 \def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{Macro}%
+\begingroup\defname {#1}{\putwordDefmac}%
 \defunargs {#2}\endgroup %
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
 % @defspec == @deffn Special Form
 
 \def\defspec{\defparsebody\Edefspec\defspecx\defspecheader}
 
 \def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{Special Form}%
+\begingroup\defname {#1}{\putwordDefspec}%
 \defunargs {#2}\endgroup %
 \catcode 61=\other % Turn off change made in \defparsebody
 }
 
-% This definition is run if you use @defunx
-% anywhere other than immediately after a @defun or @defunx.
-
-\def\deffnx #1 {\errmessage{@deffnx in invalid context}}
-\def\defunx #1 {\errmessage{@defunx in invalid context}}
-\def\defmacx #1 {\errmessage{@defmacx in invalid context}}
-\def\defspecx #1 {\errmessage{@defspecx in invalid context}}
-\def\deftypefnx #1 {\errmessage{@deftypefnx in invalid context}}
-\def\deftypeunx #1 {\errmessage{@deftypeunx in invalid context}}
-
-% @defmethod, and so on
-
-% @defop {Funny Method} foo-class frobnicate argument
-
+% @defop CATEGORY CLASS OPERATION ARG...
+%
 \def\defop #1 {\def\defoptype{#1}%
 \defopparsebody\Edefop\defopx\defopheader\defoptype}
-
-\def\defopheader #1#2#3{%
-\dosubind {fn}{\code{#2}}{on #1}% Make entry in function index
-\begingroup\defname {#2}{\defoptype{} on #1}%
+%
+\def\defopheader#1#2#3{%
+\dosubind {fn}{\code{#2}}{\putwordon\ #1}% Make entry in function index
+\begingroup\defname {#2}{\defoptype\ \putwordon\ #1}%
 \defunargs {#3}\endgroup %
 }
 
+% @deftypeop CATEGORY CLASS TYPE OPERATION ARG...
+%
+\def\deftypeop #1 {\def\deftypeopcategory{#1}%
+  \deftypeopparsebody\Edeftypeop\deftypeopx\deftypeopheader
+                       \deftypeopcategory}
+%
+% #1 is the class name, #2 the data type, #3 the operation name, #4 the args.
+\def\deftypeopheader#1#2#3#4{%
+  \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
+  \begingroup
+    \defname{\defheaderxcond#2\relax$$$#3}
+            {\deftypeopcategory\ \putwordon\ \code{#1}}%
+    \deftypefunargs{#4}%
+  \endgroup
+}
+
+% @deftypemethod CLASS TYPE METHOD ARG...
+%
+\def\deftypemethod{%
+  \deftypemethparsebody\Edeftypemethod\deftypemethodx\deftypemethodheader}
+%
+% #1 is the class name, #2 the data type, #3 the method name, #4 the args.
+\def\deftypemethodheader#1#2#3#4{%
+  \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
+  \begingroup
+    \defname{\defheaderxcond#2\relax$$$#3}{\putwordMethodon\ \code{#1}}%
+    \deftypefunargs{#4}%
+  \endgroup
+}
+
+% @deftypeivar CLASS TYPE VARNAME
+%
+\def\deftypeivar{%
+  \deftypemethparsebody\Edeftypeivar\deftypeivarx\deftypeivarheader}
+%
+% #1 is the class name, #2 the data type, #3 the variable name.
+\def\deftypeivarheader#1#2#3{%
+  \dosubind{vr}{\code{#3}}{\putwordof\ \code{#1}}% entry in variable index
+  \begingroup
+    \defname{#3}{\putwordInstanceVariableof\ \code{#1}}%
+    \defvarargs{#3}%
+  \endgroup
+}
+
 % @defmethod == @defop Method
-
+%
 \def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
-
-\def\defmethodheader #1#2#3{%
-\dosubind {fn}{\code{#2}}{on #1}% entry in function index
-\begingroup\defname {#2}{Method on #1}%
-\defunargs {#3}\endgroup %
+%
+% #1 is the class name, #2 the method name, #3 the args.
+\def\defmethodheader#1#2#3{%
+  \dosubind{fn}{\code{#2}}{\putwordon\ \code{#1}}% entry in function index
+  \begingroup
+    \defname{#2}{\putwordMethodon\ \code{#1}}%
+    \defunargs{#3}%
+  \endgroup
 }
 
 % @defcv {Class Option} foo-class foo-flag
 
 \def\defcv #1 {\def\defcvtype{#1}%
 \defopvarparsebody\Edefcv\defcvx\defcvarheader\defcvtype}
 
 \def\defcvarheader #1#2#3{%
-\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
-\begingroup\defname {#2}{\defcvtype{} of #1}%
+\dosubind {vr}{\code{#2}}{\putwordof\ #1}% Make entry in var index
+\begingroup\defname {#2}{\defcvtype\ \putwordof\ #1}%
 \defvarargs {#3}\endgroup %
 }
 
-% @defivar == @defcv {Instance Variable}
-
+% @defivar CLASS VARNAME == @defcv {Instance Variable} CLASS VARNAME
+%
 \def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
-
-\def\defivarheader #1#2#3{%
-\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
-\begingroup\defname {#2}{Instance Variable of #1}%
-\defvarargs {#3}\endgroup %
+%
+\def\defivarheader#1#2#3{%
+  \dosubind {vr}{\code{#2}}{\putwordof\ #1}% entry in var index
+  \begingroup
+    \defname{#2}{\putwordInstanceVariableof\ #1}%
+    \defvarargs{#3}%
+  \endgroup
 }
 
-% These definitions are run if you use @defmethodx, etc.,
-% anywhere other than immediately after a @defmethod, etc.
-
-\def\defopx #1 {\errmessage{@defopx in invalid context}}
-\def\defmethodx #1 {\errmessage{@defmethodx in invalid context}}
-\def\defcvx #1 {\errmessage{@defcvx in invalid context}}
-\def\defivarx #1 {\errmessage{@defivarx in invalid context}}
-
-% Now @defvar
-
+% @defvar
 % First, define the processing that is wanted for arguments of @defvar.
 % This is actually simple: just print them in roman.
 % This must expand the args and terminate the paragraph they make up
 \def\defvarargs #1{\normalparens #1%
 \interlinepenalty=10000
-\endgraf\penalty 10000\vskip -\parskip\penalty 10000}
+\endgraf\nobreak\vskip -\parskip\nobreak}
 
 % @defvr Counter foo-count
 
 \def\defvr{\defvrparsebody\Edefvr\defvrx\defvrheader}
 
 \def\defvrheader #1#2#3{\doind {vr}{\code{#2}}%
 \begingroup\defname {#2}{#1}\defvarargs{#3}\endgroup}
 
 % @defvar == @defvr Variable
 
 \def\defvar{\defvarparsebody\Edefvar\defvarx\defvarheader}
 
 \def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
-\begingroup\defname {#1}{Variable}%
+\begingroup\defname {#1}{\putwordDefvar}%
 \defvarargs {#2}\endgroup %
 }
 
 % @defopt == @defvr {User Option}
 
 \def\defopt{\defvarparsebody\Edefopt\defoptx\defoptheader}
 
 \def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
-\begingroup\defname {#1}{User Option}%
+\begingroup\defname {#1}{\putwordDefopt}%
 \defvarargs {#2}\endgroup %
 }
 
 % @deftypevar int foobar
 
 \def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
 
-% #1 is the data type.  #2 is the name.
+% #1 is the data type.  #2 is the name, perhaps followed by text that
+% is actually part of the data type, which should not be put into the index.
 \def\deftypevarheader #1#2{%
-\doind {vr}{\code{#2}}% Make entry in variables index
-\begingroup\defname {\defheaderxcond#1\relax$$$#2}{Variable}%
+\dovarind#2 \relax% Make entry in variables index
+\begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypevar}%
 \interlinepenalty=10000
-\endgraf\penalty 10000\vskip -\parskip\penalty 10000
+\endgraf\nobreak\vskip -\parskip\nobreak
 \endgroup}
+\def\dovarind#1 #2\relax{\doind{vr}{\code{#1}}}
 
 % @deftypevr {Global Flag} int enable
 
 \def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
 
-\def\deftypevrheader #1#2#3{\doind {vr}{\code{#3}}%
+\def\deftypevrheader #1#2#3{\dovarind#3 \relax%
 \begingroup\defname {\defheaderxcond#2\relax$$$#3}{#1}
 \interlinepenalty=10000
-\endgraf\penalty 10000\vskip -\parskip\penalty 10000
+\endgraf\nobreak\vskip -\parskip\nobreak
 \endgroup}
 
-% This definition is run if you use @defvarx
-% anywhere other than immediately after a @defvar or @defvarx.
-
-\def\defvrx #1 {\errmessage{@defvrx in invalid context}}
-\def\defvarx #1 {\errmessage{@defvarx in invalid context}}
-\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
-\def\deftypevarx #1 {\errmessage{@deftypevarx in invalid context}}
-\def\deftypevrx #1 {\errmessage{@deftypevrx in invalid context}}
-
 % Now define @deftp
 % Args are printed in bold, a slight difference from @defvar.
 
 \def\deftpargs #1{\bf \defvarargs{#1}}
 
 % @deftp Class window height width ...
 
 \def\deftp{\deftpparsebody\Edeftp\deftpx\deftpheader}
 
 \def\deftpheader #1#2#3{\doind {tp}{\code{#2}}%
 \begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
 
-% This definition is run if you use @deftpx, etc
-% anywhere other than immediately after a @deftp, etc.
-
-\def\deftpx #1 {\errmessage{@deftpx in invalid context}}
-
-\message{cross reference,}
-% Define cross-reference macros
-\newwrite \auxfile
-
-\newif\ifhavexrefs  % True if xref values are known.
+% These definitions are used if you use @defunx (etc.)
+% anywhere other than immediately after a @defun or @defunx.
+% 
+\def\defcvx#1 {\errmessage{@defcvx in invalid context}}
+\def\deffnx#1 {\errmessage{@deffnx in invalid context}}
+\def\defivarx#1 {\errmessage{@defivarx in invalid context}}
+\def\defmacx#1 {\errmessage{@defmacx in invalid context}}
+\def\defmethodx#1 {\errmessage{@defmethodx in invalid context}}
+\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
+\def\defopx#1 {\errmessage{@defopx in invalid context}}
+\def\defspecx#1 {\errmessage{@defspecx in invalid context}}
+\def\deftpx#1 {\errmessage{@deftpx in invalid context}}
+\def\deftypefnx#1 {\errmessage{@deftypefnx in invalid context}}
+\def\deftypefunx#1 {\errmessage{@deftypefunx in invalid context}}
+\def\deftypeivarx#1 {\errmessage{@deftypeivarx in invalid context}}
+\def\deftypemethodx#1 {\errmessage{@deftypemethodx in invalid context}}
+\def\deftypeopx#1 {\errmessage{@deftypeopx in invalid context}}
+\def\deftypevarx#1 {\errmessage{@deftypevarx in invalid context}}
+\def\deftypevrx#1 {\errmessage{@deftypevrx in invalid context}}
+\def\defunx#1 {\errmessage{@defunx in invalid context}}
+\def\defvarx#1 {\errmessage{@defvarx in invalid context}}
+\def\defvrx#1 {\errmessage{@defvrx in invalid context}}
+
+
+\message{macros,}
+% @macro.
+
+% To do this right we need a feature of e-TeX, \scantokens,
+% which we arrange to emulate with a temporary file in ordinary TeX.
+\ifx\eTeXversion\undefined
+ \newwrite\macscribble
+ \def\scanmacro#1{%
+   \begingroup \newlinechar`\^^M
+   % Undo catcode changes of \startcontents and \doprintindex
+   \catcode`\@=0 \catcode`\\=12 \escapechar=`\@
+   % Append \endinput to make sure that TeX does not see the ending newline.
+   \toks0={#1\endinput}%
+   \immediate\openout\macscribble=\jobname.tmp
+   \immediate\write\macscribble{\the\toks0}%
+   \immediate\closeout\macscribble
+   \let\xeatspaces\eatspaces
+   \input \jobname.tmp
+   \endgroup
+}
+\else
+\def\scanmacro#1{%
+\begingroup \newlinechar`\^^M
+% Undo catcode changes of \startcontents and \doprintindex
+\catcode`\@=0 \catcode`\\=12 \escapechar=`\@
+\let\xeatspaces\eatspaces\scantokens{#1\endinput}\endgroup}
+\fi
+
+\newcount\paramno   % Count of parameters
+\newtoks\macname    % Macro name
+\newif\ifrecursive  % Is it recursive?
+\def\macrolist{}    % List of all defined macros in the form
+                    % \do\macro1\do\macro2...
+
+% Utility routines.
+% Thisdoes \let #1 = #2, except with \csnames.
+\def\cslet#1#2{%
+\expandafter\expandafter
+\expandafter\let
+\expandafter\expandafter
+\csname#1\endcsname
+\csname#2\endcsname}
+
+% Trim leading and trailing spaces off a string.
+% Concepts from aro-bend problem 15 (see CTAN).
+{\catcode`\@=11
+\gdef\eatspaces #1{\expandafter\trim@\expandafter{#1 }}
+\gdef\trim@ #1{\trim@@ @#1 @ #1 @ @@}
+\gdef\trim@@ #1@ #2@ #3@@{\trim@@@\empty #2 @}
+\def\unbrace#1{#1}
+\unbrace{\gdef\trim@@@ #1 } #2@{#1}
+}
+
+% Trim a single trailing ^^M off a string.
+{\catcode`\^^M=12\catcode`\Q=3%
+\gdef\eatcr #1{\eatcra #1Q^^MQ}%
+\gdef\eatcra#1^^MQ{\eatcrb#1Q}%
+\gdef\eatcrb#1Q#2Q{#1}%
+}
+
+% Macro bodies are absorbed as an argument in a context where
+% all characters are catcode 10, 11 or 12, except \ which is active
+% (as in normal texinfo). It is necessary to change the definition of \.
+
+% It's necessary to have hard CRs when the macro is executed. This is
+% done by  making ^^M (\endlinechar) catcode 12 when reading the macro
+% body, and then making it the \newlinechar in \scanmacro.
+
+\def\macrobodyctxt{%
+  \catcode`\~=12
+  \catcode`\^=12
+  \catcode`\_=12
+  \catcode`\|=12
+  \catcode`\<=12
+  \catcode`\>=12
+  \catcode`\+=12
+  \catcode`\{=12
+  \catcode`\}=12
+  \catcode`\@=12
+  \catcode`\^^M=12
+  \usembodybackslash}
+
+\def\macroargctxt{%
+  \catcode`\~=12
+  \catcode`\^=12
+  \catcode`\_=12
+  \catcode`\|=12
+  \catcode`\<=12
+  \catcode`\>=12
+  \catcode`\+=12
+  \catcode`\@=12
+  \catcode`\\=12}
+
+% \mbodybackslash is the definition of \ in @macro bodies.
+% It maps \foo\ => \csname macarg.foo\endcsname => #N
+% where N is the macro parameter number.
+% We define \csname macarg.\endcsname to be \realbackslash, so
+% \\ in macro replacement text gets you a backslash.
+
+{\catcode`@=0 @catcode`@\=@active
+ @gdef@usembodybackslash{@let\=@mbodybackslash}
+ @gdef@mbodybackslash#1\{@csname macarg.#1@endcsname}
+}
+\expandafter\def\csname macarg.\endcsname{\realbackslash}
+
+\def\macro{\recursivefalse\parsearg\macroxxx}
+\def\rmacro{\recursivetrue\parsearg\macroxxx}
+
+\def\macroxxx#1{%
+  \getargs{#1}%           now \macname is the macname and \argl the arglist
+  \ifx\argl\empty       % no arguments
+     \paramno=0%
+  \else
+     \expandafter\parsemargdef \argl;%
+  \fi
+  \if1\csname ismacro.\the\macname\endcsname
+     \message{Warning: redefining \the\macname}%
+  \else
+     \expandafter\ifx\csname \the\macname\endcsname \relax
+     \else \errmessage{The name \the\macname\space is reserved}\fi
+     \global\cslet{macsave.\the\macname}{\the\macname}%
+     \global\expandafter\let\csname ismacro.\the\macname\endcsname=1%
+     % Add the macroname to \macrolist
+     \toks0 = \expandafter{\macrolist\do}%
+     \xdef\macrolist{\the\toks0
+       \expandafter\noexpand\csname\the\macname\endcsname}%
+  \fi
+  \begingroup \macrobodyctxt
+  \ifrecursive \expandafter\parsermacbody
+  \else \expandafter\parsemacbody
+  \fi}
+
+\def\unmacro{\parsearg\unmacroxxx}
+\def\unmacroxxx#1{%
+  \if1\csname ismacro.#1\endcsname
+    \global\cslet{#1}{macsave.#1}%
+    \global\expandafter\let \csname ismacro.#1\endcsname=0%
+    % Remove the macro name from \macrolist
+    \begingroup
+      \edef\tempa{\expandafter\noexpand\csname#1\endcsname}%
+      \def\do##1{%
+        \def\tempb{##1}%
+        \ifx\tempa\tempb
+          % remove this
+        \else
+          \toks0 = \expandafter{\newmacrolist\do}%
+          \edef\newmacrolist{\the\toks0\expandafter\noexpand\tempa}%
+        \fi}%
+      \def\newmacrolist{}%
+      % Execute macro list to define \newmacrolist
+      \macrolist
+      \global\let\macrolist\newmacrolist
+    \endgroup
+  \else
+    \errmessage{Macro #1 not defined}%
+  \fi
+}
+
+% This makes use of the obscure feature that if the last token of a
+% <parameter list> is #, then the preceding argument is delimited by
+% an opening brace, and that opening brace is not consumed.
+\def\getargs#1{\getargsxxx#1{}}
+\def\getargsxxx#1#{\getmacname #1 \relax\getmacargs}
+\def\getmacname #1 #2\relax{\macname={#1}}
+\def\getmacargs#1{\def\argl{#1}}
+
+% Parse the optional {params} list.  Set up \paramno and \paramlist
+% so \defmacro knows what to do.  Define \macarg.blah for each blah
+% in the params list, to be ##N where N is the position in that list.
+% That gets used by \mbodybackslash (above).
+
+% We need to get `macro parameter char #' into several definitions.
+% The technique used is stolen from LaTeX:  let \hash be something
+% unexpandable, insert that wherever you need a #, and then redefine
+% it to # just before using the token list produced.
+%
+% The same technique is used to protect \eatspaces till just before
+% the macro is used.
+
+\def\parsemargdef#1;{\paramno=0\def\paramlist{}%
+        \let\hash\relax\let\xeatspaces\relax\parsemargdefxxx#1,;,}
+\def\parsemargdefxxx#1,{%
+  \if#1;\let\next=\relax
+  \else \let\next=\parsemargdefxxx
+    \advance\paramno by 1%
+    \expandafter\edef\csname macarg.\eatspaces{#1}\endcsname
+        {\xeatspaces{\hash\the\paramno}}%
+    \edef\paramlist{\paramlist\hash\the\paramno,}%
+  \fi\next}
+
+% These two commands read recursive and nonrecursive macro bodies.
+% (They're different since rec and nonrec macros end differently.)
+
+\long\def\parsemacbody#1@end macro%
+{\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
+\long\def\parsermacbody#1@end rmacro%
+{\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
+
+% This defines the macro itself. There are six cases: recursive and
+% nonrecursive macros of zero, one, and many arguments.
+% Much magic with \expandafter here.
+% \xdef is used so that macro definitions will survive the file
+% they're defined in; @include reads the file inside a group.
+\def\defmacro{%
+  \let\hash=##% convert placeholders to macro parameter chars
+  \ifrecursive
+    \ifcase\paramno
+    % 0
+      \expandafter\xdef\csname\the\macname\endcsname{%
+        \noexpand\scanmacro{\temp}}%
+    \or % 1
+      \expandafter\xdef\csname\the\macname\endcsname{%
+         \bgroup\noexpand\macroargctxt
+         \noexpand\braceorline
+         \expandafter\noexpand\csname\the\macname xxx\endcsname}%
+      \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
+         \egroup\noexpand\scanmacro{\temp}}%
+    \else % many
+      \expandafter\xdef\csname\the\macname\endcsname{%
+         \bgroup\noexpand\macroargctxt
+         \noexpand\csname\the\macname xx\endcsname}%
+      \expandafter\xdef\csname\the\macname xx\endcsname##1{%
+          \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
+      \expandafter\expandafter
+      \expandafter\xdef
+      \expandafter\expandafter
+        \csname\the\macname xxx\endcsname
+          \paramlist{\egroup\noexpand\scanmacro{\temp}}%
+    \fi
+  \else
+    \ifcase\paramno
+    % 0
+      \expandafter\xdef\csname\the\macname\endcsname{%
+        \noexpand\norecurse{\the\macname}%
+        \noexpand\scanmacro{\temp}\egroup}%
+    \or % 1
+      \expandafter\xdef\csname\the\macname\endcsname{%
+         \bgroup\noexpand\macroargctxt
+         \noexpand\braceorline
+         \expandafter\noexpand\csname\the\macname xxx\endcsname}%
+      \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
+        \egroup
+        \noexpand\norecurse{\the\macname}%
+        \noexpand\scanmacro{\temp}\egroup}%
+    \else % many
+      \expandafter\xdef\csname\the\macname\endcsname{%
+         \bgroup\noexpand\macroargctxt
+         \expandafter\noexpand\csname\the\macname xx\endcsname}%
+      \expandafter\xdef\csname\the\macname xx\endcsname##1{%
+          \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
+      \expandafter\expandafter
+      \expandafter\xdef
+      \expandafter\expandafter
+      \csname\the\macname xxx\endcsname
+      \paramlist{%
+          \egroup
+          \noexpand\norecurse{\the\macname}%
+          \noexpand\scanmacro{\temp}\egroup}%
+    \fi
+  \fi}
+
+\def\norecurse#1{\bgroup\cslet{#1}{macsave.#1}}
+
+% \braceorline decides whether the next nonwhitespace character is a
+% {.  If so it reads up to the closing }, if not, it reads the whole
+% line.  Whatever was read is then fed to the next control sequence
+% as an argument (by \parsebrace or \parsearg)
+\def\braceorline#1{\let\next=#1\futurelet\nchar\braceorlinexxx}
+\def\braceorlinexxx{%
+  \ifx\nchar\bgroup\else
+    \expandafter\parsearg
+  \fi \next}
+
+% We mant to disable all macros during \shipout so that they are not
+% expanded by \write.
+\def\turnoffmacros{\begingroup \def\do##1{\let\noexpand##1=\relax}%
+  \edef\next{\macrolist}\expandafter\endgroup\next}
+
+
+% @alias.
+% We need some trickery to remove the optional spaces around the equal
+% sign.  Just make them active and then expand them all to nothing.
+\def\alias{\begingroup\obeyspaces\parsearg\aliasxxx}
+\def\aliasxxx #1{\aliasyyy#1\relax}
+\def\aliasyyy #1=#2\relax{\ignoreactivespaces
+\edef\next{\global\let\expandafter\noexpand\csname#1\endcsname=%
+           \expandafter\noexpand\csname#2\endcsname}%
+\expandafter\endgroup\next}
+
+
+\message{cross references,}
+% @xref etc.
+
+\newwrite\auxfile
+
+\newif\ifhavexrefs    % True if xref values are known.
 \newif\ifwarnedxrefs  % True if we warned once that they aren't known.
 
-% \setref{foo} defines a cross-reference point named foo.
-
-\def\setref#1{%
-\dosetq{#1-title}{Ytitle}%
-\dosetq{#1-pg}{Ypagenumber}%
-\dosetq{#1-snt}{Ysectionnumberandtype}}
-
-\def\unnumbsetref#1{%
-\dosetq{#1-title}{Ytitle}%
-\dosetq{#1-pg}{Ypagenumber}%
-\dosetq{#1-snt}{Ynothing}}
-
-\def\appendixsetref#1{%
-\dosetq{#1-title}{Ytitle}%
-\dosetq{#1-pg}{Ypagenumber}%
-\dosetq{#1-snt}{Yappendixletterandtype}}
-
-% \xref, \pxref, and \ref generate cross-references to specified points.
-% For \xrefX, #1 is the node name, #2 the name of the Info
-% cross-reference, #3 the printed node name, #4 the name of the Info
-% file, #5 the name of the printed manual.  All but the node name can be
-% omitted.
+% @inforef is relatively simple.
+\def\inforef #1{\inforefzzz #1,,,,**}
+\def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
+  node \samp{\ignorespaces#1{}}}
+
+% @node's job is to define \lastnode.
+\def\node{\ENVcheck\parsearg\nodezzz}
+\def\nodezzz#1{\nodexxx [#1,]}
+\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
+\let\nwnode=\node
+\let\lastnode=\relax
+
+% The sectioning commands (@chapter, etc.) call these.
+\def\donoderef{%
+  \ifx\lastnode\relax\else
+    \expandafter\expandafter\expandafter\setref{\lastnode}%
+      {Ysectionnumberandtype}%
+    \global\let\lastnode=\relax
+  \fi
+}
+\def\unnumbnoderef{%
+  \ifx\lastnode\relax\else
+    \expandafter\expandafter\expandafter\setref{\lastnode}{Ynothing}%
+    \global\let\lastnode=\relax
+  \fi
+}
+\def\appendixnoderef{%
+  \ifx\lastnode\relax\else
+    \expandafter\expandafter\expandafter\setref{\lastnode}%
+      {Yappendixletterandtype}%
+    \global\let\lastnode=\relax
+  \fi
+}
+
+
+% @anchor{NAME} -- define xref target at arbitrary point.
+%
+\newcount\savesfregister
+\gdef\savesf{\relax \ifhmode \savesfregister=\spacefactor \fi}
+\gdef\restoresf{\relax \ifhmode \spacefactor=\savesfregister \fi}
+\gdef\anchor#1{\savesf \setref{#1}{Ynothing}\restoresf \ignorespaces}
+
+% \setref{NAME}{SNT} defines a cross-reference point NAME, namely
+% NAME-title, NAME-pg, and NAME-SNT.  Called from \foonoderef.  We have
+% to set \indexdummies so commands such as @code in a section title
+% aren't expanded.  It would be nicer not to expand the titles in the
+% first place, but there's so many layers that that is hard to do.
+%
+\def\setref#1#2{{%
+  \indexdummies
+  \pdfmkdest{#1}%
+  \dosetq{#1-title}{Ytitle}%
+  \dosetq{#1-pg}{Ypagenumber}%
+  \dosetq{#1-snt}{#2}%
+}}
+
+% @xref, @pxref, and @ref generate cross-references.  For \xrefX, #1 is
+% the node name, #2 the name of the Info cross-reference, #3 the printed
+% node name, #4 the name of the Info file, #5 the name of the printed
+% manual.  All but the node name can be omitted.
 %
 \def\pxref#1{\putwordsee{} \xrefX[#1,,,,,,,]}
 \def\xref#1{\putwordSee{} \xrefX[#1,,,,,,,]}
 \def\ref#1{\xrefX[#1,,,,,,,]}
 \def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup
+  \unsepspaces
   \def\printedmanual{\ignorespaces #5}%
   \def\printednodename{\ignorespaces #3}%
   \setbox1=\hbox{\printedmanual}%
   \setbox0=\hbox{\printednodename}%
   \ifdim \wd0 = 0pt
     % No printed node name was explicitly given.
-    \ifx\SETxref-automatic-section-title\relax %
+    \expandafter\ifx\csname SETxref-automatic-section-title\endcsname\relax
+      % Use the node name inside the square brackets.
+      \def\printednodename{\ignorespaces #1}%
+    \else
       % Use the actual chapter/section title appear inside
       % the square brackets.  Use the real section title if we have it.
-      \ifdim \wd1>0pt%
+      \ifdim \wd1 > 0pt
         % It is in another manual, so we don't have it.
         \def\printednodename{\ignorespaces #1}%
       \else
         \ifhavexrefs
           % We know the real title if we have the xref values.
-          \def\printednodename{\refx{#1-title}}%
+          \def\printednodename{\refx{#1-title}{}}%
         \else
           % Otherwise just copy the Info node name.
           \def\printednodename{\ignorespaces #1}%
         \fi%
       \fi
-      \def\printednodename{#1-title}%
-    \else
-      % Use the node name inside the square brackets.
-      \def\printednodename{\ignorespaces #1}%
     \fi
   \fi
   %
   % If we use \unhbox0 and \unhbox1 to print the node names, TeX does not
   % insert empty discretionaries after hyphens, which means that it will
   % not find a line break at a hyphen in a node names.  Since some manuals
   % are best written with fairly long node names, containing hyphens, this
   % is a loss.  Therefore, we give the text of the node name again, so it
   % is as if TeX is seeing it for the first time.
+  \ifpdf
+    \leavevmode
+    \getfilename{#4}%
+    \ifnum\filenamelength>0
+      \startlink attr{/Border [0 0 0]}%
+        goto file{\the\filename.pdf} name{#1@}%
+    \else
+      \startlink attr{/Border [0 0 0]}%
+        goto name{#1@}%
+    \fi
+    \linkcolor
+  \fi
+  %
   \ifdim \wd1 > 0pt
-    \putwordsection{} ``\printednodename'' in \cite{\printedmanual}%
+    \putwordsection{} ``\printednodename'' \putwordin{} \cite{\printedmanual}%
   \else
     % _ (for example) has to be the character _ for the purposes of the
     % control sequence corresponding to the node, but it has to expand
     % into the usual \leavevmode...\vrule stuff for purposes of
     % printing. So we \turnoffactive for the \refx-snt, back on for the
     % printing, back off for the \refx-pg.
-    {\turnoffactive \refx{#1-snt}{}}%
-    \space [\printednodename],\space
+    {\normalturnoffactive
+     % Only output a following space if the -snt ref is nonempty; for
+     % @unnumbered and @anchor, it won't be.
+     \setbox2 = \hbox{\ignorespaces \refx{#1-snt}{}}%
+     \ifdim \wd2 > 0pt \refx{#1-snt}\space\fi
+    }%
+    % [mynode],
+    [\printednodename],\space
+    % page 3
     \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
   \fi
+  \endlink
 \endgroup}
 
 % \dosetq is the interface for calls from other macros
 
-% Use \turnoffactive so that punctuation chars such as underscore
-% work in node names.
-\def\dosetq #1#2{{\let\folio=0 \turnoffactive \auxhat%
-\edef\next{\write\auxfile{\internalsetq {#1}{#2}}}%
-\next}}
+% Use \normalturnoffactive so that punctuation chars such as underscore
+% and backslash work in node names.  (\turnoffactive doesn't do \.)
+\def\dosetq#1#2{%
+  {\let\folio=0%
+   \normalturnoffactive
+   \edef\next{\write\auxfile{\internalsetq{#1}{#2}}}%
+   \iflinks
+     \next
+   \fi
+  }%
+}
 
 % \internalsetq {foo}{page} expands into
 % CHARACTERS 'xrdef {foo}{...expansion of \Ypage...}
 % When the aux file is read, ' is the escape character
 
 \def\internalsetq #1#2{'xrdef {#1}{\csname #2\endcsname}}
 
 % Things to be expanded by \internalsetq
@@ -3930,124 +5334,144 @@ July\or August\or September\or October\o
 \fi
 
 % Define \refx{NAME}{SUFFIX} to reference a cross-reference string named NAME.
 % If its value is nonempty, SUFFIX is output afterward.
 
 \def\refx#1#2{%
   \expandafter\ifx\csname X#1\endcsname\relax
     % If not defined, say something at least.
-    $\langle$un\-de\-fined$\rangle$%
-    \ifhavexrefs
-      \message{\linenumber Undefined cross reference `#1'.}%
-    \else
-      \ifwarnedxrefs\else
-        \global\warnedxrefstrue
-        \message{Cross reference values unknown; you must run TeX again.}%
+    \angleleft un\-de\-fined\angleright
+    \iflinks
+      \ifhavexrefs
+        \message{\linenumber Undefined cross reference `#1'.}%
+      \else
+        \ifwarnedxrefs\else
+          \global\warnedxrefstrue
+          \message{Cross reference values unknown; you must run TeX again.}%
+        \fi
       \fi
     \fi
   \else
     % It's defined, so just use it.
     \csname X#1\endcsname
   \fi
   #2% Output the suffix in any case.
 }
 
+% This is the macro invoked by entries in the aux file.
+%
+\def\xrdef#1{\begingroup
+  % Reenable \ as an escape while reading the second argument.
+  \catcode`\\ = 0
+  \afterassignment\endgroup
+  \expandafter\gdef\csname X#1\endcsname
+}
+
 % Read the last existing aux file, if any.  No error if none exists.
-
-% This is the macro invoked by entries in the aux file.
-\def\xrdef #1#2{
-{\catcode`\'=\other\expandafter \gdef \csname X#1\endcsname {#2}}}
-
-\def\readauxfile{%
-\begingroup
-\catcode `\^^@=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\^^C=\other
-\catcode `\^^D=\other
-\catcode `\^^E=\other
-\catcode `\^^F=\other
-\catcode `\^^G=\other
-\catcode `\^^H=\other
-\catcode `\=\other
-\catcode `\^^L=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode `\=\other
-\catcode 26=\other
-\catcode `\^^[=\other
-\catcode `\^^\=\other
-\catcode `\^^]=\other
-\catcode `\^^^=\other
-\catcode `\^^_=\other
-\catcode `\@=\other
-\catcode `\^=\other
-\catcode `\~=\other
-\catcode `\[=\other
-\catcode `\]=\other
-\catcode`\"=\other
-\catcode`\_=\other
-\catcode`\|=\other
-\catcode`\<=\other
-\catcode`\>=\other
-\catcode `\$=\other
-\catcode `\#=\other
-\catcode `\&=\other
-% `\+ does not work, so use 43.
-\catcode 43=\other
-% Make the characters 128-255 be printing characters
-{%
-  \count 1=128
-  \def\loop{%
-    \catcode\count 1=\other
-    \advance\count 1 by 1
-    \ifnum \count 1<256 \loop \fi
+\def\readauxfile{\begingroup
+  \catcode`\^^@=\other
+  \catcode`\^^A=\other
+  \catcode`\^^B=\other
+  \catcode`\^^C=\other
+  \catcode`\^^D=\other
+  \catcode`\^^E=\other
+  \catcode`\^^F=\other
+  \catcode`\^^G=\other
+  \catcode`\^^H=\other
+  \catcode`\^^K=\other
+  \catcode`\^^L=\other
+  \catcode`\^^N=\other
+  \catcode`\^^P=\other
+  \catcode`\^^Q=\other
+  \catcode`\^^R=\other
+  \catcode`\^^S=\other
+  \catcode`\^^T=\other
+  \catcode`\^^U=\other
+  \catcode`\^^V=\other
+  \catcode`\^^W=\other
+  \catcode`\^^X=\other
+  \catcode`\^^Z=\other
+  \catcode`\^^[=\other
+  \catcode`\^^\=\other
+  \catcode`\^^]=\other
+  \catcode`\^^^=\other
+  \catcode`\^^_=\other
+  \catcode`\@=\other
+  \catcode`\^=\other
+  % It was suggested to define this as 7, which would allow ^^e4 etc.
+  % in xref tags, i.e., node names.  But since ^^e4 notation isn't
+  % supported in the main text, it doesn't seem desirable.  Furthermore,
+  % that is not enough: for node names that actually contain a ^
+  % character, we would end up writing a line like this: 'xrdef {'hat
+  % b-title}{'hat b} and \xrdef does a \csname...\endcsname on the first
+  % argument, and \hat is not an expandable control sequence.  It could
+  % all be worked out, but why?  Either we support ^^ or we don't.
+  %
+  % The other change necessary for this was to define \auxhat:
+  % \def\auxhat{\def^{'hat }}% extra space so ok if followed by letter
+  % and then to call \auxhat in \setq.
+  %
+  \catcode`\~=\other
+  \catcode`\[=\other
+  \catcode`\]=\other
+  \catcode`\"=\other
+  \catcode`\_=\other
+  \catcode`\|=\other
+  \catcode`\<=\other
+  \catcode`\>=\other
+  \catcode`\$=\other
+  \catcode`\#=\other
+  \catcode`\&=\other
+  \catcode`+=\other % avoid \+ for paranoia even though we've turned it off
+  % Make the characters 128-255 be printing characters
+  {%
+    \count 1=128
+    \def\loop{%
+      \catcode\count 1=\other
+      \advance\count 1 by 1
+      \ifnum \count 1<256 \loop \fi
+    }%
   }%
-}%
-% the aux file uses ' as the escape.
-% Turn off \ as an escape so we do not lose on
-% entries which were dumped with control sequences in their names.
-% For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
-% Reference to such entries still does not work the way one would wish,
-% but at least they do not bomb out when the aux file is read in.
-\catcode `\{=1 \catcode `\}=2
-\catcode `\%=\other
-\catcode `\'=0
-\catcode`\^=7 % to make ^^e4 etc usable in xref tags 
-\catcode `\\=\other
-\openin 1 \jobname.aux
-\ifeof 1 \else \closein 1 \input \jobname.aux \global\havexrefstrue
-\global\warnedobstrue
-\fi
-% Open the new aux file.  Tex will close it automatically at exit.
-\openout \auxfile=\jobname.aux
+  % The aux file uses ' as the escape (for now).
+  % Turn off \ as an escape so we do not lose on
+  % entries which were dumped with control sequences in their names.
+  % For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
+  % Reference to such entries still does not work the way one would wish,
+  % but at least they do not bomb out when the aux file is read in.
+  \catcode`\{=1
+  \catcode`\}=2
+  \catcode`\%=\other
+  \catcode`\'=0
+  \catcode`\\=\other
+  %
+  \openin 1 \jobname.aux
+  \ifeof 1 \else
+    \closein 1
+    \input \jobname.aux
+    \global\havexrefstrue
+    \global\warnedobstrue
+  \fi
+  % Open the new aux file.  TeX will close it automatically at exit.
+  \openout\auxfile=\jobname.aux
 \endgroup}
 
 
 % Footnotes.
 
 \newcount \footnoteno
 
 % The trailing space in the following definition for supereject is
 % vital for proper filling; pages come out unaligned when you do a
 % pagealignmacro call if that space before the closing brace is
-% removed.
+% removed. (Generally, numeric constants should always be followed by a
+% space to prevent strange expansion errors.)
 \def\supereject{\par\penalty -20000\footnoteno =0 }
 
-% @footnotestyle is meaningful for info output only..
+% @footnotestyle is meaningful for info output only.
 \let\footnotestyle=\comment
 
 \let\ptexfootnote=\footnote
 
 {\catcode `\@=11
 %
 % Auto-number footnotes.  Otherwise like plain.
 \gdef\footnote{%
@@ -4063,40 +5487,51 @@ July\or August\or September\or October\o
   \unskip
   \thisfootno\@sf
   \footnotezzz
 }%
 
 % Don't bother with the trickery in plain.tex to not require the
 % footnote text as a parameter.  Our footnotes don't need to be so general.
 %
-\long\gdef\footnotezzz#1{\insert\footins{%
+% Oh yes, they do; otherwise, @ifset and anything else that uses
+% \parseargline fail inside footnotes because the tokens are fixed when
+% the footnote is read.  --karl, 16nov96.
+%
+\long\gdef\footnotezzz{\insert\footins\bgroup
   % We want to typeset this text as a normal paragraph, even if the
   % footnote reference occurs in (for example) a display environment.
   % So reset some parameters.
   \interlinepenalty\interfootnotelinepenalty
   \splittopskip\ht\strutbox % top baseline for broken footnotes
   \splitmaxdepth\dp\strutbox
   \floatingpenalty\@MM
   \leftskip\z@skip
   \rightskip\z@skip
   \spaceskip\z@skip
   \xspaceskip\z@skip
   \parindent\defaultparindent
   %
+  \smallfonts \rm
+  %
   % Hang the footnote text off the number.
   \hang
   \textindent{\thisfootno}%
   %
   % Don't crash into the line above the footnote text.  Since this
   % expands into a box, it must come within the paragraph, lest it
   % provide a place where TeX can split the footnote.
   \footstrut
-  #1\strut}%
+  \futurelet\next\fo@t
 }
+\def\fo@t{\ifcat\bgroup\noexpand\next \let\next\f@@t
+  \else\let\next\f@t\fi \next}
+\def\f@@t{\bgroup\aftergroup\@foot\let\next}
+\def\f@t#1{#1\@foot}
+\def\@foot{\strut\par\egroup}
 
 }%end \catcode `\@=11
 
 % Set the baselineskip to #1, and the lineskip and strut size
 % correspondingly.  There is no deep meaning behind these magic numbers
 % used as factors; they just match (closely enough) what Knuth defined.
 %
 \def\lineskipfactor{.08333}
@@ -4143,199 +5578,323 @@ July\or August\or September\or October\o
 }
 
 % For a final copy, take out the rectangles
 % that mark overfull boxes (in case you have decided
 % that the text looks ok even though it passes the margin).
 %
 \def\finalout{\overfullrule=0pt}
 
-
-% End of control word definitions.
-
-\message{and turning on texinfo input format.}
-
-\def\openindices{%
-   \newindex{cp}%
-   \newcodeindex{fn}%
-   \newcodeindex{vr}%
-   \newcodeindex{tp}%
-   \newcodeindex{ky}%
-   \newcodeindex{pg}%
+% @image.  We use the macros from epsf.tex to support this.
+% If epsf.tex is not installed and @image is used, we complain.
+%
+% Check for and read epsf.tex up front.  If we read it only at @image
+% time, we might be inside a group, and then its definitions would get
+% undone and the next image would fail.
+\openin 1 = epsf.tex
+\ifeof 1 \else
+  \closein 1
+  % Do not bother showing banner with post-v2.7 epsf.tex (available in
+  % doc/epsf.tex until it shows up on ctan).
+  \def\epsfannounce{\toks0 = }%
+  \input epsf.tex
+\fi
+%
+% We will only complain once about lack of epsf.tex.
+\newif\ifwarnednoepsf
+\newhelp\noepsfhelp{epsf.tex must be installed for images to
+  work.  It is also included in the Texinfo distribution, or you can get
+  it from ftp://tug.org/tex/epsf.tex.}
+%
+\def\image#1{%
+  \ifx\epsfbox\undefined
+    \ifwarnednoepsf \else
+      \errhelp = \noepsfhelp
+      \errmessage{epsf.tex not found, images will be ignored}%
+      \global\warnednoepsftrue
+    \fi
+  \else
+    \imagexxx #1,,,\finish
+  \fi
 }
-
-% Set some numeric style parameters, for 8.5 x 11 format.
-
-%\hsize = 6.5in
+%
+% Arguments to @image:
+% #1 is (mandatory) image filename; we tack on .eps extension.
+% #2 is (optional) width, #3 is (optional) height.
+% #4 is just the usual extra ignored arg for parsing this stuff.
+\def\imagexxx#1,#2,#3,#4\finish{%
+  \ifpdf
+    \centerline{\dopdfimage{#1}{#2}{#3}}%
+  \else
+    % \epsfbox itself resets \epsf?size at each figure.
+    \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \epsfxsize=#2\relax \fi
+    \setbox0 = \hbox{\ignorespaces #3}\ifdim\wd0 > 0pt \epsfysize=#3\relax \fi
+    \begingroup
+      \catcode`\^^M = 5 % in case we're inside an example
+      % If the image is by itself, center it.
+      \ifvmode
+        \nobreak\bigskip
+        % Usually we'll have text after the image which will insert
+        % \parskip glue, so insert it here too to equalize the space
+        % above and below. 
+        \nobreak\vskip\parskip
+        \nobreak
+        \centerline{\epsfbox{#1.eps}}%
+        \bigbreak
+      \else
+        % In the middle of a paragraph, no extra space.
+        \epsfbox{#1.eps}%
+      \fi
+    \endgroup
+  \fi
+}
+
+
+\message{localization,}
+% and i18n.
+
+% @documentlanguage is usually given very early, just after
+% @setfilename.  If done too late, it may not override everything
+% properly.  Single argument is the language abbreviation.
+% It would be nice if we could set up a hyphenation file here.
+%
+\def\documentlanguage{\parsearg\dodocumentlanguage}
+\def\dodocumentlanguage#1{%
+  \tex % read txi-??.tex file in plain TeX.
+  % Read the file if it exists.
+  \openin 1 txi-#1.tex
+  \ifeof1
+    \errhelp = \nolanghelp
+    \errmessage{Cannot read language file txi-#1.tex}%
+    \let\temp = \relax
+  \else
+    \def\temp{\input txi-#1.tex }%
+  \fi
+  \temp
+  \endgroup
+}
+\newhelp\nolanghelp{The given language definition file cannot be found or
+is empty.  Maybe you need to install it?  In the current directory
+should work if nowhere else does.}
+
+
+% @documentencoding should change something in TeX eventually, most
+% likely, but for now just recognize it.
+\let\documentencoding = \comment
+
+
+% Page size parameters.
+%
 \newdimen\defaultparindent \defaultparindent = 15pt
-\parindent = \defaultparindent
-\parskip 18pt plus 1pt
-\setleading{15pt}
-\advance\topskip by 1.2cm
+
+\chapheadingskip = 15pt plus 4pt minus 2pt
+\secheadingskip = 12pt plus 3pt minus 2pt
+\subsecheadingskip = 9pt plus 2pt minus 2pt
 
 % Prevent underfull vbox error messages.
-\vbadness=10000
+\vbadness = 10000
+
+% Don't be so finicky about underfull hboxes, either.
+\hbadness = 2000
 
 % Following George Bush, just get rid of widows and orphans.
 \widowpenalty=10000
 \clubpenalty=10000
 
 % Use TeX 3.0's \emergencystretch to help line breaking, but if we're
 % using an old version of TeX, don't do anything.  We want the amount of
 % stretch added to depend on the line length, hence the dependence on
-% \hsize.  This makes it come to about 9pt for the 8.5x11 format.
+% \hsize.  We call this whenever the paper size is set.
+%
+\def\setemergencystretch{%
+  \ifx\emergencystretch\thisisundefined
+    % Allow us to assign to \emergencystretch anyway.
+    \def\emergencystretch{\dimen0}%
+  \else
+    \emergencystretch = .15\hsize
+  \fi
+}
+
+% Parameters in order: 1) textheight; 2) textwidth; 3) voffset;
+% 4) hoffset; 5) binding offset; 6) topskip.  Then whoever calls us can
+% set \parskip and call \setleading for \baselineskip.
 %
-\ifx\emergencystretch\thisisundefined
-  % Allow us to assign to \emergencystretch anyway.
-  \def\emergencystretch{\dimen0}%
-\else
-  \emergencystretch = \hsize
-  \divide\emergencystretch by 45
-\fi
-
-% Use @smallbook to reset parameters for 7x9.5 format  (or else 7x9.25)
-\def\smallbook{
-
-% These values for secheadingskip and subsecheadingskip are
-% experiments.  RJC 7 Aug 1992
-\global\secheadingskip = 17pt plus 6pt minus 3pt
-\global\subsecheadingskip = 14pt plus 6pt minus 3pt
-
-\global\lispnarrowing = 0.3in
-\setleading{12pt}
-\advance\topskip by -1cm
-\global\parskip 3pt plus 1pt
-\global\hsize = 5in
-\global\vsize=7.5in
-\global\tolerance=700
-\global\hfuzz=1pt
-\global\contentsrightmargin=0pt
-\global\deftypemargin=0pt
-\global\defbodyindent=.5cm
-
-\global\pagewidth=\hsize
-\global\pageheight=\vsize
-
-\global\let\smalllisp=\smalllispx
-\global\let\smallexample=\smalllispx
-\global\def\Esmallexample{\Esmalllisp}
+\def\internalpagesizes#1#2#3#4#5#6{%
+  \voffset = #3\relax
+  \topskip = #6\relax
+  \splittopskip = \topskip
+  %
+  \vsize = #1\relax
+  \advance\vsize by \topskip
+  \outervsize = \vsize
+  \advance\outervsize by 2\topandbottommargin
+  \pageheight = \vsize
+  %
+  \hsize = #2\relax
+  \outerhsize = \hsize
+  \advance\outerhsize by 0.5in
+  \pagewidth = \hsize
+  %
+  \normaloffset = #4\relax
+  \bindingoffset = #5\relax
+  %
+  \parindent = \defaultparindent
+  \setemergencystretch
 }
 
+% @letterpaper (the default).
+\def\letterpaper{{\globaldefs = 1
+  \parskip = 3pt plus 2pt minus 1pt
+  \setleading{13.2pt}%
+  %
+  % If page is nothing but text, make it come out even.
+  \internalpagesizes{46\baselineskip}{6in}{\voffset}{.25in}{\bindingoffset}{36pt}%
+}}
+
+% Use @smallbook to reset parameters for 7x9.5 (or so) format.
+\def\smallbook{{\globaldefs = 1
+  \parskip = 2pt plus 1pt
+  \setleading{12pt}%
+  %
+  \internalpagesizes{7.5in}{5.in}{\voffset}{.25in}{\bindingoffset}{16pt}%
+  %
+  \lispnarrowing = 0.3in
+  \tolerance = 700
+  \hfuzz = 1pt
+  \contentsrightmargin = 0pt
+  \deftypemargin = 0pt
+  \defbodyindent = .5cm
+  %
+  \let\smalldisplay = \smalldisplayx
+  \let\smallexample = \smalllispx
+  \let\smallformat = \smallformatx
+  \let\smalllisp = \smalllispx
+}}
+
 % Use @afourpaper to print on European A4 paper.
-\def\afourpaper{
-\global\tolerance=700
-\global\hfuzz=1pt
-\setleading{12pt}
-\global\parskip 15pt plus 1pt
-
-\global\vsize= 53\baselineskip
-\advance\vsize by \topskip
-%\global\hsize=   5.85in     % A4 wide 10pt
-\global\hsize=  6.5in
-\global\outerhsize=\hsize
-\global\advance\outerhsize by 0.5in
-\global\outervsize=\vsize
-\global\advance\outervsize by 0.6in
-
-\global\pagewidth=\hsize
-\global\pageheight=\vsize
-}
-
-% Allow control of the text dimensions.  Parameters in order: textheight;
-% textwidth; \voffset; \hoffset (!); binding offset.  All require a dimension;
-% header is additional; added length extends the bottom of the page.
-
-\def\changepagesizes#1#2#3#4#5{
- \global\vsize= #1
- \advance\vsize by \topskip
- \global\voffset= #3
- \global\hsize= #2
- \global\outerhsize=\hsize
- \global\advance\outerhsize by 0.5in
- \global\outervsize=\vsize
- \global\advance\outervsize by 0.6in
- \global\pagewidth=\hsize
- \global\pageheight=\vsize
- \global\normaloffset= #4
- \global\bindingoffset= #5}
-
-% This layout is compatible with Latex on A4 paper.
-
-\def\afourlatex{\changepagesizes{22cm}{15cm}{7mm}{4.6mm}{5mm}}
+\def\afourpaper{{\globaldefs = 1
+  \setleading{12pt}%
+  \parskip = 3pt plus 2pt minus 1pt
+  %
+  \internalpagesizes{53\baselineskip}{160mm}{\voffset}{4mm}{\bindingoffset}{44pt}%
+  %
+  \tolerance = 700
+  \hfuzz = 1pt
+}}
+
+% A specific text layout, 24x15cm overall, intended for A4 paper.  Top margin
+% 29mm, hence bottom margin 28mm, nominal side margin 3cm.
+\def\afourlatex{{\globaldefs = 1
+  \setleading{13.6pt}%
+  %
+  \afourpaper
+  \internalpagesizes{237mm}{150mm}{3.6mm}{3.6mm}{3mm}{7mm}%
+  %
+  \globaldefs = 0
+}}
 
 % Use @afourwide to print on European A4 paper in wide format.
-\def\afourwide{\afourpaper
-\changepagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}}
+\def\afourwide{%
+  \afourpaper
+  \internalpagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}{7mm}%
+  %
+  \globaldefs = 0
+}
+
+% @pagesizes TEXTHEIGHT[,TEXTWIDTH]
+% Perhaps we should allow setting the margins, \topskip, \parskip,
+% and/or leading, also. Or perhaps we should compute them somehow.
+%
+\def\pagesizes{\parsearg\pagesizesxxx}
+\def\pagesizesxxx#1{\pagesizesyyy #1,,\finish}
+\def\pagesizesyyy#1,#2,#3\finish{{%
+  \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \hsize=#2\relax \fi
+  \globaldefs = 1
+  %
+  \parskip = 3pt plus 2pt minus 1pt
+  \setleading{13.2pt}%
+  %
+  \internalpagesizes{#1}{\hsize}{\voffset}{\normaloffset}{\bindingoffset}{44pt}%
+}}
+
+% Set default to letter.
+%
+\letterpaper
+
+
+\message{and turning on texinfo input format.}
 
 % Define macros to output various characters with catcode for normal text.
 \catcode`\"=\other
 \catcode`\~=\other
 \catcode`\^=\other
 \catcode`\_=\other
 \catcode`\|=\other
 \catcode`\<=\other
 \catcode`\>=\other
 \catcode`\+=\other
+\catcode`\$=\other
 \def\normaldoublequote{"}
 \def\normaltilde{~}
 \def\normalcaret{^}
 \def\normalunderscore{_}
 \def\normalverticalbar{|}
 \def\normalless{<}
 \def\normalgreater{>}
 \def\normalplus{+}
+\def\normaldollar{$}
 
 % This macro is used to make a character print one way in ttfont
 % where it can probably just be output, and another way in other fonts,
 % where something hairier probably needs to be done.
 %
 % #1 is what to print if we are indeed using \tt; #2 is what to print
 % otherwise.  Since all the Computer Modern typewriter fonts have zero
 % interword stretch (and shrink), and it is reasonable to expect all
 % typewriter fonts to have this, we can check that font parameter.
 %
-\def\ifusingtt#1#2{\ifdim \fontdimen3\the\font=0pt #1\else #2\fi}
+\def\ifusingtt#1#2{\ifdim \fontdimen3\font=0pt #1\else #2\fi}
+
+% Same as above, but check for italic font.  Actually this also catches
+% non-italic slanted fonts since it is impossible to distinguish them from
+% italic fonts.  But since this is only used by $ and it uses \sl anyway
+% this is not a problem.
+\def\ifusingit#1#2{\ifdim \fontdimen1\font>0pt #1\else #2\fi}
 
 % Turn off all special characters except @
 % (and those which the user can use as if they were ordinary).
 % Most of these we simply print from the \tt font, but for some, we can
 % use math or other variants that look better in normal text.
 
 \catcode`\"=\active
-\def\activedoublequote{{\tt \char '042}}
+\def\activedoublequote{{\tt\char34}}
 \let"=\activedoublequote
 \catcode`\~=\active
-\def~{{\tt \char '176}}
+\def~{{\tt\char126}}
 \chardef\hat=`\^
 \catcode`\^=\active
-\def\auxhat{\def^{'hat}}
 \def^{{\tt \hat}}
 
 \catcode`\_=\active
 \def_{\ifusingtt\normalunderscore\_}
 % Subroutine for the previous macro.
-\def\_{\lvvmode \kern.06em \vbox{\hrule width.3em height.1ex}}
-
-% \lvvmode is equivalent in function to \leavevmode.
-% Using \leavevmode runs into trouble when written out to
-% an index file due to the expansion of \leavevmode into ``\unhbox
-% \voidb@x'' ---which looks to TeX like ``\unhbox \voidb\x'' due to our
-% magic tricks with @.
-\def\lvvmode{\vbox to 0pt{}}
+\def\_{\leavevmode \kern.06em \vbox{\hrule width.3em height.1ex}}
 
 \catcode`\|=\active
-\def|{{\tt \char '174}}
+\def|{{\tt\char124}}
 \chardef \less=`\<
 \catcode`\<=\active
 \def<{{\tt \less}}
 \chardef \gtr=`\>
 \catcode`\>=\active
 \def>{{\tt \gtr}}
 \catcode`\+=\active
 \def+{{\tt \char 43}}
+\catcode`\$=\active
+\def${\ifusingit{{\sl\$}}\normaldollar}
 %\catcode 27=\active
 %\def^^[{$\diamondsuit$}
 
 % Set up an active definition for =, but don't enable it most of the time.
 {\catcode`\==\active
 \global\def={{\tt \char 61}}}
 
 \catcode`+=\active
@@ -4356,43 +5915,42 @@ July\or August\or September\or October\o
 
 % \rawbackslash redefines \ as input to do \rawbackslashxx.
 {\catcode`\\=\active
 @gdef@rawbackslash{@let\=@rawbackslashxx }}
 
 % \normalbackslash outputs one backslash in fixed width font.
 \def\normalbackslash{{\tt\rawbackslashxx}}
 
-% Say @foo, not \foo, in error messages.
-\escapechar=`\@
-
 % \catcode 17=0   % Define control-q
 \catcode`\\=\active
 
 % Used sometimes to turn off (effectively) the active characters
 % even after parsing them.
 @def@turnoffactive{@let"=@normaldoublequote
 @let\=@realbackslash
 @let~=@normaltilde
 @let^=@normalcaret
 @let_=@normalunderscore
 @let|=@normalverticalbar
 @let<=@normalless
 @let>=@normalgreater
-@let+=@normalplus}
+@let+=@normalplus
+@let$=@normaldollar}
 
 @def@normalturnoffactive{@let"=@normaldoublequote
 @let\=@normalbackslash
 @let~=@normaltilde
 @let^=@normalcaret
 @let_=@normalunderscore
 @let|=@normalverticalbar
 @let<=@normalless
 @let>=@normalgreater
-@let+=@normalplus}
+@let+=@normalplus
+@let$=@normaldollar}
 
 % Make _ and + \other characters, temporarily.
 % This is canceled by @fixbackslash.
 @otherifyactive
 
 % If a .fmt file is being used, we don't want the `\input texinfo' to show up.
 % That is what \eatinput is for; after that, the `\' should revert to printing
 % a backslash.
@@ -4401,21 +5959,34 @@ July\or August\or September\or October\o
 @global@let\ = @eatinput
 
 % On the other hand, perhaps the file did not have a `\input texinfo'. Then
 % the first `\{ in the file would cause an error. This macro tries to fix
 % that, assuming it is called before the first `\' could plausibly occur.
 % Also back turn on active characters that might appear in the input
 % file name, in case not using a pre-dumped format.
 %
-@gdef@fixbackslash{@ifx\@eatinput @let\ = @normalbackslash @fi
-  @catcode`+=@active @catcode`@_=@active}
-
-%% These look ok in all fonts, so just make them not special.  The @rm below
-%% makes sure that the current font starts out as the newly loaded cmr10
-@catcode`@$=@other @catcode`@%=@other @catcode`@&=@other @catcode`@#=@other
-
+@gdef@fixbackslash{%
+  @ifx\@eatinput @let\ = @normalbackslash @fi
+  @catcode`+=@active
+  @catcode`@_=@active
+}
+
+% Say @foo, not \foo, in error messages.
+@escapechar = `@@
+
+% These look ok in all fonts, so just make them not special.  
+@catcode`@& = @other
+@catcode`@# = @other
+@catcode`@% = @other
+
+@c Set initial fonts.
 @textfonts
 @rm
 
+
 @c Local variables:
+@c eval: (add-hook 'write-file-hooks 'time-stamp)
 @c page-delimiter: "^\\\\message"
+@c time-stamp-start: "def\\\\texinfoversion{"
+@c time-stamp-format: "%:y-%02m-%02d.%02H"
+@c time-stamp-end: "}"
 @c End:
diff --git a/readline/emacs_keymap.c b/readline/emacs_keymap.c
--- a/readline/emacs_keymap.c
+++ b/readline/emacs_keymap.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -28,207 +28,195 @@
 
 /* An array of function pointers, one for each possible key.
    If the type byte is ISKMAP, then the pointer is the address of
    a keymap. */
 
 KEYMAP_ENTRY_ARRAY emacs_standard_keymap = {
 
   /* Control keys. */
-  { ISFUNC, rl_set_mark },		/* Control-@ */
-  { ISFUNC, rl_beg_of_line },		/* Control-a */
-  { ISFUNC, rl_backward },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, rl_delete },		/* Control-d */
-  { ISFUNC, rl_end_of_line },		/* Control-e */
-  { ISFUNC, rl_forward },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, rl_rubout },		/* Control-h */
-  { ISFUNC, rl_complete },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, rl_clear_screen },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_get_next_history },	/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },	/* Control-p */
-  { ISFUNC, rl_quoted_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISKMAP, (Function *)emacs_ctlx_keymap },	/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-  { ISKMAP, (Function *)emacs_meta_keymap }, /* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, rl_char_search },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_undo_command },		/* Control-_ */
+  { ISFUNC, rl_set_mark },			/* Control-@ */
+  { ISFUNC, rl_beg_of_line },			/* Control-a */
+  { ISFUNC, rl_backward },			/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, rl_delete },			/* Control-d */
+  { ISFUNC, rl_end_of_line },			/* Control-e */
+  { ISFUNC, rl_forward },			/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, rl_rubout },			/* Control-h */
+  { ISFUNC, rl_complete },			/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, rl_clear_screen },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_get_next_history },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },		/* Control-p */
+  { ISFUNC, rl_quoted_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISKMAP, (rl_command_func_t *)emacs_ctlx_keymap },	/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+  { ISKMAP, (rl_command_func_t *)emacs_meta_keymap }, /* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, rl_char_search },			/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_undo_command },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_insert },	/* SPACE */
-  { ISFUNC, rl_insert },	/* ! */
-  { ISFUNC, rl_insert },	/* " */
-  { ISFUNC, rl_insert },	/* # */
-  { ISFUNC, rl_insert },	/* $ */
-  { ISFUNC, rl_insert },	/* % */
-  { ISFUNC, rl_insert },	/* & */
-  { ISFUNC, rl_insert },	/* ' */
-  { ISFUNC, rl_insert },	/* ( */
-#if defined (PAREN_MATCHING)
-  { ISFUNC, rl_insert_close },	/* ) */
-#else
-  { ISFUNC, rl_insert },	/* ) */
-#endif /* !PAREN_MATCHING */
-  { ISFUNC, rl_insert },	/* * */
-  { ISFUNC, rl_insert },	/* + */
-  { ISFUNC, rl_insert },	/* , */
-  { ISFUNC, rl_insert },	/* - */
-  { ISFUNC, rl_insert },	/* . */
-  { ISFUNC, rl_insert },	/* / */
-
-  /* Regular digits. */
-  { ISFUNC, rl_insert },	/* 0 */
-  { ISFUNC, rl_insert },	/* 1 */
-  { ISFUNC, rl_insert },	/* 2 */
-  { ISFUNC, rl_insert },	/* 3 */
-  { ISFUNC, rl_insert },	/* 4 */
-  { ISFUNC, rl_insert },	/* 5 */
-  { ISFUNC, rl_insert },	/* 6 */
-  { ISFUNC, rl_insert },	/* 7 */
-  { ISFUNC, rl_insert },	/* 8 */
-  { ISFUNC, rl_insert },	/* 9 */
+  { ISFUNC, rl_insert },		/* SPACE */
+  { ISFUNC, rl_insert },		/* ! */
+  { ISFUNC, rl_insert },		/* " */
+  { ISFUNC, rl_insert },		/* # */
+  { ISFUNC, rl_insert },		/* $ */
+  { ISFUNC, rl_insert },		/* % */
+  { ISFUNC, rl_insert },		/* & */
+  { ISFUNC, rl_insert },		/* ' */
+  { ISFUNC, rl_insert },		/* ( */
+  { ISFUNC, rl_insert },		/* ) */
+  { ISFUNC, rl_insert },		/* * */
+  { ISFUNC, rl_insert },		/* + */
+  { ISFUNC, rl_insert },		/* , */
+  { ISFUNC, rl_insert },		/* - */
+  { ISFUNC, rl_insert },		/* . */
+  { ISFUNC, rl_insert },		/* / */
+	
+	  /* Regular digits. */
+  { ISFUNC, rl_insert },		/* 0 */
+  { ISFUNC, rl_insert },		/* 1 */
+  { ISFUNC, rl_insert },		/* 2 */
+  { ISFUNC, rl_insert },		/* 3 */
+  { ISFUNC, rl_insert },		/* 4 */
+  { ISFUNC, rl_insert },		/* 5 */
+  { ISFUNC, rl_insert },		/* 6 */
+  { ISFUNC, rl_insert },		/* 7 */
+  { ISFUNC, rl_insert },		/* 8 */
+  { ISFUNC, rl_insert },		/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, rl_insert },	/* : */
-  { ISFUNC, rl_insert },	/* ; */
-  { ISFUNC, rl_insert },	/* < */
-  { ISFUNC, rl_insert },	/* = */
-  { ISFUNC, rl_insert },	/* > */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* @ */
+  { ISFUNC, rl_insert },		/* : */
+  { ISFUNC, rl_insert },		/* ; */
+  { ISFUNC, rl_insert },		/* < */
+  { ISFUNC, rl_insert },		/* = */
+  { ISFUNC, rl_insert },		/* > */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },	/* A */
-  { ISFUNC, rl_insert },	/* B */
-  { ISFUNC, rl_insert },	/* C */
-  { ISFUNC, rl_insert },	/* D */
-  { ISFUNC, rl_insert },	/* E */
-  { ISFUNC, rl_insert },	/* F */
-  { ISFUNC, rl_insert },	/* G */
-  { ISFUNC, rl_insert },	/* H */
-  { ISFUNC, rl_insert },	/* I */
-  { ISFUNC, rl_insert },	/* J */
-  { ISFUNC, rl_insert },	/* K */
-  { ISFUNC, rl_insert },	/* L */
-  { ISFUNC, rl_insert },	/* M */
-  { ISFUNC, rl_insert },	/* N */
-  { ISFUNC, rl_insert },	/* O */
-  { ISFUNC, rl_insert },	/* P */
-  { ISFUNC, rl_insert },	/* Q */
-  { ISFUNC, rl_insert },	/* R */
-  { ISFUNC, rl_insert },	/* S */
-  { ISFUNC, rl_insert },	/* T */
-  { ISFUNC, rl_insert },	/* U */
-  { ISFUNC, rl_insert },	/* V */
-  { ISFUNC, rl_insert },	/* W */
-  { ISFUNC, rl_insert },	/* X */
-  { ISFUNC, rl_insert },	/* Y */
-  { ISFUNC, rl_insert },	/* Z */
+  { ISFUNC, rl_insert },		/* A */
+  { ISFUNC, rl_insert },		/* B */
+  { ISFUNC, rl_insert },		/* C */
+  { ISFUNC, rl_insert },		/* D */
+  { ISFUNC, rl_insert },		/* E */
+  { ISFUNC, rl_insert },		/* F */
+  { ISFUNC, rl_insert },		/* G */
+  { ISFUNC, rl_insert },		/* H */
+  { ISFUNC, rl_insert },		/* I */
+  { ISFUNC, rl_insert },		/* J */
+  { ISFUNC, rl_insert },		/* K */
+  { ISFUNC, rl_insert },		/* L */
+  { ISFUNC, rl_insert },		/* M */
+  { ISFUNC, rl_insert },		/* N */
+  { ISFUNC, rl_insert },		/* O */
+  { ISFUNC, rl_insert },		/* P */
+  { ISFUNC, rl_insert },		/* Q */
+  { ISFUNC, rl_insert },		/* R */
+  { ISFUNC, rl_insert },		/* S */
+  { ISFUNC, rl_insert },		/* T */
+  { ISFUNC, rl_insert },		/* U */
+  { ISFUNC, rl_insert },		/* V */
+  { ISFUNC, rl_insert },		/* W */
+  { ISFUNC, rl_insert },		/* X */
+  { ISFUNC, rl_insert },		/* Y */
+  { ISFUNC, rl_insert },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_insert },	/* [ */
-  { ISFUNC, rl_insert },	/* \ */
-#if defined (PAREN_MATCHING)
-  { ISFUNC, rl_insert_close },	/* ] */
-#else
-  { ISFUNC, rl_insert },	/* ] */
-#endif /* !PAREN_MATCHING */
-  { ISFUNC, rl_insert },	/* ^ */
-  { ISFUNC, rl_insert },	/* _ */
-  { ISFUNC, rl_insert },	/* ` */
+  { ISFUNC, rl_insert },		/* [ */
+  { ISFUNC, rl_insert },		/* \ */
+  { ISFUNC, rl_insert },		/* ] */
+  { ISFUNC, rl_insert },		/* ^ */
+  { ISFUNC, rl_insert },		/* _ */
+  { ISFUNC, rl_insert },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },	/* a */
-  { ISFUNC, rl_insert },	/* b */
-  { ISFUNC, rl_insert },	/* c */
-  { ISFUNC, rl_insert },	/* d */
-  { ISFUNC, rl_insert },	/* e */
-  { ISFUNC, rl_insert },	/* f */
-  { ISFUNC, rl_insert },	/* g */
-  { ISFUNC, rl_insert },	/* h */
-  { ISFUNC, rl_insert },	/* i */
-  { ISFUNC, rl_insert },	/* j */
-  { ISFUNC, rl_insert },	/* k */
-  { ISFUNC, rl_insert },	/* l */
-  { ISFUNC, rl_insert },	/* m */
-  { ISFUNC, rl_insert },	/* n */
-  { ISFUNC, rl_insert },	/* o */
-  { ISFUNC, rl_insert },	/* p */
-  { ISFUNC, rl_insert },	/* q */
-  { ISFUNC, rl_insert },	/* r */
-  { ISFUNC, rl_insert },	/* s */
-  { ISFUNC, rl_insert },	/* t */
-  { ISFUNC, rl_insert },	/* u */
-  { ISFUNC, rl_insert },	/* v */
-  { ISFUNC, rl_insert },	/* w */
-  { ISFUNC, rl_insert },	/* x */
-  { ISFUNC, rl_insert },	/* y */
-  { ISFUNC, rl_insert },	/* z */
+  { ISFUNC, rl_insert },		/* a */
+  { ISFUNC, rl_insert },		/* b */
+  { ISFUNC, rl_insert },		/* c */
+  { ISFUNC, rl_insert },		/* d */
+  { ISFUNC, rl_insert },		/* e */
+  { ISFUNC, rl_insert },		/* f */
+  { ISFUNC, rl_insert },		/* g */
+  { ISFUNC, rl_insert },		/* h */
+  { ISFUNC, rl_insert },		/* i */
+  { ISFUNC, rl_insert },		/* j */
+  { ISFUNC, rl_insert },		/* k */
+  { ISFUNC, rl_insert },		/* l */
+  { ISFUNC, rl_insert },		/* m */
+  { ISFUNC, rl_insert },		/* n */
+  { ISFUNC, rl_insert },		/* o */
+  { ISFUNC, rl_insert },		/* p */
+  { ISFUNC, rl_insert },		/* q */
+  { ISFUNC, rl_insert },		/* r */
+  { ISFUNC, rl_insert },		/* s */
+  { ISFUNC, rl_insert },		/* t */
+  { ISFUNC, rl_insert },		/* u */
+  { ISFUNC, rl_insert },		/* v */
+  { ISFUNC, rl_insert },		/* w */
+  { ISFUNC, rl_insert },		/* x */
+  { ISFUNC, rl_insert },		/* y */
+  { ISFUNC, rl_insert },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, rl_insert },	/* { */
-  { ISFUNC, rl_insert },	/* | */
-#if defined (PAREN_MATCHING)
-  { ISFUNC, rl_insert_close },	/* } */
-#else
-  { ISFUNC, rl_insert },	/* } */
-#endif /* !PAREN_MATCHING */
-  { ISFUNC, rl_insert },	/* ~ */
-  { ISFUNC, rl_rubout },	/* RUBOUT */
+  { ISFUNC, rl_insert },		/* { */
+  { ISFUNC, rl_insert },		/* | */
+  { ISFUNC, rl_insert },		/* } */
+  { ISFUNC, rl_insert },		/* ~ */
+  { ISFUNC, rl_rubout },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Pure 8-bit characters (128 - 159).
      These might be used in some
      character sets. */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
 
   /* ISO Latin-1 characters (160 - 255) */
   { ISFUNC, rl_insert },	/* No-break space */
   { ISFUNC, rl_insert },	/* Inverted exclamation mark */
   { ISFUNC, rl_insert },	/* Cent sign */
   { ISFUNC, rl_insert },	/* Pound sign */
   { ISFUNC, rl_insert },	/* Currency sign */
   { ISFUNC, rl_insert },	/* Yen sign */
@@ -323,88 +311,88 @@ KEYMAP_ENTRY_ARRAY emacs_standard_keymap
   { ISFUNC, rl_insert },	/* Latin small letter thorn (Icelandic) */
   { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
 
   /* Meta keys.  Just like above, but the high bit is set. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-@ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-a */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-b */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-c */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-d */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-e */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-f */
-  { ISFUNC, rl_abort },		/* Meta-Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-f */
+  { ISFUNC, rl_abort },			/* Meta-Control-g */
   { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
-  { ISFUNC, rl_tab_insert },	/* Meta-Control-i */
-  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-j */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-k */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-l */
-  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-m */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-n */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-o */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-p */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-q */
-  { ISFUNC, rl_revert_line },	/* Meta-Control-r */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-s */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-t */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-u */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-v */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-w */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-x */
-  { ISFUNC, rl_yank_nth_arg },	/* Meta-Control-y */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-z */
+  { ISFUNC, rl_tab_insert },		/* Meta-Control-i */
+  { ISFUNC, rl_vi_editing_mode },	/* Meta-Control-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-l */
+  { ISFUNC, rl_vi_editing_mode }, 	/* Meta-Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-q */
+  { ISFUNC, rl_revert_line },		/* Meta-Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-t */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-x */
+  { ISFUNC, rl_yank_nth_arg },		/* Meta-Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-z */
 
-  { ISFUNC, rl_complete },	/* Meta-Control-[ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-\ */
+  { ISFUNC, rl_complete },		/* Meta-Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-\ */
   { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-^ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_set_mark },	/* Meta-SPACE */
-  { ISFUNC, (Function *)0x0 },	/* Meta-! */
-  { ISFUNC, (Function *)0x0 },	/* Meta-" */
-  { ISFUNC, rl_insert_comment },/* Meta-# */
-  { ISFUNC, (Function *)0x0 },	/* Meta-$ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-% */
-  { ISFUNC, rl_tilde_expand },	/* Meta-& */
-  { ISFUNC, (Function *)0x0 },	/* Meta-' */
-  { ISFUNC, (Function *)0x0 },	/* Meta-( */
-  { ISFUNC, (Function *)0x0 },	/* Meta-) */
+  { ISFUNC, rl_set_mark },		/* Meta-SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-! */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-" */
+  { ISFUNC, rl_insert_comment },	/* Meta-# */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-$ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-% */
+  { ISFUNC, rl_tilde_expand },		/* Meta-& */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-' */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-( */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-) */
   { ISFUNC, rl_insert_completions },	/* Meta-* */
-  { ISFUNC, (Function *)0x0 },	/* Meta-+ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-, */
-  { ISFUNC, rl_digit_argument }, /* Meta-- */
-  { ISFUNC, rl_yank_last_arg},	/* Meta-. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-/ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-+ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-, */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-- */
+  { ISFUNC, rl_yank_last_arg},		/* Meta-. */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-/ */
 
   /* Regular digits. */
-  { ISFUNC, rl_digit_argument }, /* Meta-0 */
-  { ISFUNC, rl_digit_argument }, /* Meta-1 */
-  { ISFUNC, rl_digit_argument }, /* Meta-2 */
-  { ISFUNC, rl_digit_argument }, /* Meta-3 */
-  { ISFUNC, rl_digit_argument }, /* Meta-4 */
-  { ISFUNC, rl_digit_argument }, /* Meta-5 */
-  { ISFUNC, rl_digit_argument }, /* Meta-6 */
-  { ISFUNC, rl_digit_argument }, /* Meta-7 */
-  { ISFUNC, rl_digit_argument }, /* Meta-8 */
-  { ISFUNC, rl_digit_argument }, /* Meta-9 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-0 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-1 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-2 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-3 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-4 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-5 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-6 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-7 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-8 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* Meta-: */
-  { ISFUNC, (Function *)0x0 },		/* Meta-; */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-: */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-; */
   { ISFUNC, rl_beginning_of_history },	/* Meta-< */
   { ISFUNC, rl_possible_completions },	/* Meta-= */
   { ISFUNC, rl_end_of_history },	/* Meta-> */
   { ISFUNC, rl_possible_completions },	/* Meta-? */
-  { ISFUNC, (Function *)0x0 },		/* Meta-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-@ */
 
   /* Uppercase alphabet. */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-A */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-B */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-C */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-D */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-E */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-F */
@@ -425,461 +413,461 @@ KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
   { ISFUNC, rl_do_lowercase_version },	/* Meta-U */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-V */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-W */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-X */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-Y */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
   { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
-  { ISFUNC, (Function *)0x0 },		/* Meta-] */
-  { ISFUNC, (Function *)0x0 },		/* Meta-^ */
-  { ISFUNC, rl_yank_last_arg },		/* Meta-_ */
-  { ISFUNC, (Function *)0x0 },		/* Meta-` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-^ */
+  { ISFUNC, rl_yank_last_arg },			/* Meta-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-a */
-  { ISFUNC, rl_backward_word },	/* Meta-b */
-  { ISFUNC, rl_capitalize_word }, /* Meta-c */
-  { ISFUNC, rl_kill_word },	/* Meta-d */
-  { ISFUNC, (Function *)0x0 },	/* Meta-e */
-  { ISFUNC, rl_forward_word },	/* Meta-f */
-  { ISFUNC, (Function *)0x0 },	/* Meta-g */
-  { ISFUNC, (Function *)0x0 },	/* Meta-h */
-  { ISFUNC, (Function *)0x0 },	/* Meta-i */
-  { ISFUNC, (Function *)0x0 },	/* Meta-j */
-  { ISFUNC, (Function *)0x0 },	/* Meta-k */
-  { ISFUNC, rl_downcase_word },	/* Meta-l */
-  { ISFUNC, (Function *)0x0 },	/* Meta-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-a */
+  { ISFUNC, rl_backward_word },		/* Meta-b */
+  { ISFUNC, rl_capitalize_word }, 	/* Meta-c */
+  { ISFUNC, rl_kill_word },		/* Meta-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-e */
+  { ISFUNC, rl_forward_word },		/* Meta-f */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-i */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-k */
+  { ISFUNC, rl_downcase_word },		/* Meta-l */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-m */
   { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
-  { ISFUNC, (Function *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
   { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
-  { ISFUNC, (Function *)0x0 },	/* Meta-q */
-  { ISFUNC, rl_revert_line },	/* Meta-r */
-  { ISFUNC, (Function *)0x0 },	/* Meta-s */
-  { ISFUNC, rl_transpose_words }, /* Meta-t */
-  { ISFUNC, rl_upcase_word },	/* Meta-u */
-  { ISFUNC, (Function *)0x0 },	/* Meta-v */
-  { ISFUNC, (Function *)0x0 },	/* Meta-w */
-  { ISFUNC, (Function *)0x0 },	/* Meta-x */
-  { ISFUNC, rl_yank_pop },	/* Meta-y */
-  { ISFUNC, (Function *)0x0 },	/* Meta-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-q */
+  { ISFUNC, rl_revert_line },		/* Meta-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-s */
+  { ISFUNC, rl_transpose_words }, 	/* Meta-t */
+  { ISFUNC, rl_upcase_word },		/* Meta-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-x */
+  { ISFUNC, rl_yank_pop },		/* Meta-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-{ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-| */
-  { ISFUNC, (Function *)0x0 },	/* Meta-} */
-  { ISFUNC, rl_tilde_expand },	/* Meta-~ */
-  { ISFUNC, rl_backward_kill_word }, /* Meta-rubout */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-{ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-| */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-} */
+  { ISFUNC, rl_tilde_expand },		/* Meta-~ */
+  { ISFUNC, rl_backward_kill_word },	/* Meta-rubout */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 KEYMAP_ENTRY_ARRAY emacs_ctlx_keymap = {
 
   /* Control keys. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, (Function *)0x0 },		/* Control-d */
-  { ISFUNC, (Function *)0x0 },		/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, (Function *)0x0 },		/* Control-h */
-  { ISFUNC, (Function *)0x0 },		/* Control-i */
-  { ISFUNC, (Function *)0x0 },		/* Control-j */
-  { ISFUNC, (Function *)0x0 },		/* Control-k */
-  { ISFUNC, (Function *)0x0 },		/* Control-l */
-  { ISFUNC, (Function *)0x0 },		/* Control-m */
-  { ISFUNC, (Function *)0x0 },		/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, (Function *)0x0 },		/* Control-p */
-  { ISFUNC, (Function *)0x0 },		/* Control-q */
-  { ISFUNC, rl_re_read_init_file },	/* Control-r */
-  { ISFUNC, (Function *)0x0 },		/* Control-s */
-  { ISFUNC, (Function *)0x0 },		/* Control-t */
-  { ISFUNC, rl_undo_command },		/* Control-u */
-  { ISFUNC, (Function *)0x0 },		/* Control-v */
-  { ISFUNC, (Function *)0x0 },		/* Control-w */
-  { ISFUNC, rl_exchange_point_and_mark },/* Control-x */
-  { ISFUNC, (Function *)0x0 },		/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-  { ISFUNC, (Function *)0x0 },		/* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, (Function *)0x0 },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
+  { ISFUNC, rl_re_read_init_file },		/* Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
+  { ISFUNC, rl_undo_command },			/* Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
+  { ISFUNC, rl_exchange_point_and_mark },	/* Control-x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, (Function *)0x0 },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, (Function *)0x0 },		/* # */
-  { ISFUNC, (Function *)0x0 },		/* $ */
-  { ISFUNC, (Function *)0x0 },		/* % */
-  { ISFUNC, (Function *)0x0 },		/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, rl_start_kbd_macro },	/* ( */
-  { ISFUNC, rl_end_kbd_macro  },	/* ) */
-  { ISFUNC, (Function *)0x0 },		/* * */
-  { ISFUNC, (Function *)0x0 },		/* + */
-  { ISFUNC, (Function *)0x0 },		/* , */
-  { ISFUNC, (Function *)0x0 },		/* - */
-  { ISFUNC, (Function *)0x0 },		/* . */
-  { ISFUNC, (Function *)0x0 },		/* / */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, rl_start_kbd_macro },		/* ( */
+  { ISFUNC, rl_end_kbd_macro  },		/* ) */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
 
   /* Regular digits. */
-  { ISFUNC, (Function *)0x0 },		/* 0 */
-  { ISFUNC, (Function *)0x0 },		/* 1 */
-  { ISFUNC, (Function *)0x0 },		/* 2 */
-  { ISFUNC, (Function *)0x0 },		/* 3 */
-  { ISFUNC, (Function *)0x0 },		/* 4 */
-  { ISFUNC, (Function *)0x0 },		/* 5 */
-  { ISFUNC, (Function *)0x0 },		/* 6 */
-  { ISFUNC, (Function *)0x0 },		/* 7 */
-  { ISFUNC, (Function *)0x0 },		/* 8 */
-  { ISFUNC, (Function *)0x0 },		/* 9 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 0 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 1 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 2 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 3 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 4 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 5 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 6 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 7 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 8 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },	/* : */
-  { ISFUNC, (Function *)0x0 },	/* ; */
-  { ISFUNC, (Function *)0x0 },	/* < */
-  { ISFUNC, (Function *)0x0 },	/* = */
-  { ISFUNC, (Function *)0x0 },	/* > */
-  { ISFUNC, (Function *)0x0 },	/* ? */
-  { ISFUNC, (Function *)0x0 },	/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },	/* A */
-  { ISFUNC, rl_do_lowercase_version },	/* B */
-  { ISFUNC, rl_do_lowercase_version },	/* C */
-  { ISFUNC, rl_do_lowercase_version },	/* D */
-  { ISFUNC, rl_do_lowercase_version },	/* E */
-  { ISFUNC, rl_do_lowercase_version },	/* F */
-  { ISFUNC, rl_do_lowercase_version },	/* G */
-  { ISFUNC, rl_do_lowercase_version },	/* H */
-  { ISFUNC, rl_do_lowercase_version },	/* I */
-  { ISFUNC, rl_do_lowercase_version },	/* J */
-  { ISFUNC, rl_do_lowercase_version },	/* K */
-  { ISFUNC, rl_do_lowercase_version },	/* L */
-  { ISFUNC, rl_do_lowercase_version },	/* M */
-  { ISFUNC, rl_do_lowercase_version },	/* N */
-  { ISFUNC, rl_do_lowercase_version },	/* O */
-  { ISFUNC, rl_do_lowercase_version },	/* P */
-  { ISFUNC, rl_do_lowercase_version },	/* Q */
-  { ISFUNC, rl_do_lowercase_version },	/* R */
-  { ISFUNC, rl_do_lowercase_version },	/* S */
-  { ISFUNC, rl_do_lowercase_version },	/* T */
-  { ISFUNC, rl_do_lowercase_version },	/* U */
-  { ISFUNC, rl_do_lowercase_version },	/* V */
-  { ISFUNC, rl_do_lowercase_version },	/* W */
-  { ISFUNC, rl_do_lowercase_version },	/* X */
-  { ISFUNC, rl_do_lowercase_version },	/* Y */
-  { ISFUNC, rl_do_lowercase_version },	/* Z */
+  { ISFUNC, rl_do_lowercase_version },		/* A */
+  { ISFUNC, rl_do_lowercase_version },		/* B */
+  { ISFUNC, rl_do_lowercase_version },		/* C */
+  { ISFUNC, rl_do_lowercase_version },		/* D */
+  { ISFUNC, rl_do_lowercase_version },		/* E */
+  { ISFUNC, rl_do_lowercase_version },		/* F */
+  { ISFUNC, rl_do_lowercase_version },		/* G */
+  { ISFUNC, rl_do_lowercase_version },		/* H */
+  { ISFUNC, rl_do_lowercase_version },		/* I */
+  { ISFUNC, rl_do_lowercase_version },		/* J */
+  { ISFUNC, rl_do_lowercase_version },		/* K */
+  { ISFUNC, rl_do_lowercase_version },		/* L */
+  { ISFUNC, rl_do_lowercase_version },		/* M */
+  { ISFUNC, rl_do_lowercase_version },		/* N */
+  { ISFUNC, rl_do_lowercase_version },		/* O */
+  { ISFUNC, rl_do_lowercase_version },		/* P */
+  { ISFUNC, rl_do_lowercase_version },		/* Q */
+  { ISFUNC, rl_do_lowercase_version },		/* R */
+  { ISFUNC, rl_do_lowercase_version },		/* S */
+  { ISFUNC, rl_do_lowercase_version },		/* T */
+  { ISFUNC, rl_do_lowercase_version },		/* U */
+  { ISFUNC, rl_do_lowercase_version },		/* V */
+  { ISFUNC, rl_do_lowercase_version },		/* W */
+  { ISFUNC, rl_do_lowercase_version },		/* X */
+  { ISFUNC, rl_do_lowercase_version },		/* Y */
+  { ISFUNC, rl_do_lowercase_version },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* [ */
-  { ISFUNC, (Function *)0x0 },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, (Function *)0x0 },		/* ^ */
-  { ISFUNC, (Function *)0x0 },		/* _ */
-  { ISFUNC, (Function *)0x0 },		/* ` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },		/* a */
-  { ISFUNC, (Function *)0x0 },		/* b */
-  { ISFUNC, (Function *)0x0 },		/* c */
-  { ISFUNC, (Function *)0x0 },		/* d */
-  { ISFUNC, rl_call_last_kbd_macro },	/* e */
-  { ISFUNC, (Function *)0x0 },		/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, (Function *)0x0 },		/* h */
-  { ISFUNC, (Function *)0x0 },		/* i */
-  { ISFUNC, (Function *)0x0 },		/* j */
-  { ISFUNC, (Function *)0x0 },		/* k */
-  { ISFUNC, (Function *)0x0 },		/* l */
-  { ISFUNC, (Function *)0x0 },		/* m */
-  { ISFUNC, (Function *)0x0 },		/* n */
-  { ISFUNC, (Function *)0x0 },		/* o */
-  { ISFUNC, (Function *)0x0 },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, (Function *)0x0 },		/* r */
-  { ISFUNC, (Function *)0x0 },		/* s */
-  { ISFUNC, (Function *)0x0 },		/* t */
-  { ISFUNC, (Function *)0x0 },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, (Function *)0x0 },		/* w */
-  { ISFUNC, (Function *)0x0 },		/* x */
-  { ISFUNC, (Function *)0x0 },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
+  { ISFUNC, rl_call_last_kbd_macro },		/* e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, (Function *)0x0 },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, (Function *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_line },	/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_line },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
diff --git a/readline/examples/Makefile.in b/readline/examples/Makefile.in
--- a/readline/examples/Makefile.in
+++ b/readline/examples/Makefile.in
@@ -1,37 +1,97 @@
-# This is the Makefile for the examples subdirectory of readline. -*- text -*-
+#
+# This is the Makefile for the readline examples subdirectory.
 #
+# Copyright (C) 1994 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+RL_LIBRARY_VERSION = @LIBVERSION@
+
+SHELL = @MAKE_SHELL@
+RM = rm -f
+
 srcdir = @srcdir@
 VPATH = .:@srcdir@
 top_srcdir = @top_srcdir@
 BUILD_DIR = .
 
 DEFS = @DEFS@
 CC = @CC@
 CFLAGS = @CFLAGS@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@
+LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DREADLINE_LIBRARY -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
 CPPFLAGS = @CPPFLAGS@
 
-INCLUDES = -I $(srcdir) -I $(top_srcdir) -I..
+INCLUDES = -I$(srcdir) -I$(top_srcdir) -I..
 
 CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
 LDFLAGS = -g -L..
 
+READLINE_LIB = ../libreadline.a
+HISTORY_LIB = ../libhistory.a
+
+TERMCAP_LIB = @TERMCAP_LIB@
+
 .c.o:
+	${RM} $@
 	$(CC) $(CCFLAGS) -c $<
 
-EXECUTABLES = fileman rltest rl
+EXECUTABLES = fileman rltest rl rlversion histexamp
+OBJECTS = fileman.o rltest.o rl.o rlversion.o histexamp.o
 
 all: $(EXECUTABLES)
+everything: all rlfe
 
 rl: rl.o
-	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline -ltermcap
+	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline $(TERMCAP_LIB)
 
 fileman: fileman.o
-	$(CC) $(LDFLAGS) -o $@ fileman.o -lreadline -ltermcap
+	$(CC) $(LDFLAGS) -o $@ fileman.o -lreadline $(TERMCAP_LIB)
 
 rltest: rltest.o
-	$(CC) $(LDFLAGS) -o $@ rltest.o -lreadline -ltermcap
+	$(CC) $(LDFLAGS) -o $@ rltest.o -lreadline $(TERMCAP_LIB)
+
+rlversion: rlversion.o $(READLINE_LIB)
+	$(CC) $(LDFLAGS) -o $@ rlversion.o -lreadline $(TERMCAP_LIB)
+
+histexamp: histexamp.o $(HISTORY_LIB)
+	$(CC) $(LDFLAGS) -o $@ histexamp.o -lhistory $(TERMCAP_LIB)
+
+clean mostlyclean:
+	$(RM) $(OBJECTS)
+	$(RM) $(EXECUTABLES) *.exe
+
+distclean maintainer-clean: clean
+	$(RM) Makefile
 
-fileman.o: $(srcdir)/fileman.c
-rltest.o: $(srcdir)/rltest.c
-rl.o: $(srcdir)/rl.c
+fileman.o: fileman.c
+rltest.o: rltest.c
+rl.o: rl.c
+rlversion.o: rlversion.c
+histexamp.o: histexamp.c
+
+fileman.o: $(top_srcdir)/readline.h
+rltest.o: $(top_srcdir)/readline.h
+rl.o: $(top_srcdir)/readline.h
+rlversion.o: $(top_srcdir)/readline.h
+histexamp.o: $(top_srcdir)/history.h
+
+# Stuff for Per Bothner's `rlfe' program
+ 
+rlfe: rlfe.o $(READLINE_LIB) $(HISTORY_LIB)
+	$(CC) $(LDFLAGS) -o $@ rlfe.o -lreadline -lhistory ${TERMCAP_LIB}
+
+rlfe.o: rlfe.c
+
+rlfe.o: $(top_srcdir)/readline.h
+rlfe.o: $(top_srcdir)/history.h
diff --git a/readline/examples/fileman.c b/readline/examples/fileman.c
--- a/readline/examples/fileman.c
+++ b/readline/examples/fileman.c
@@ -1,73 +1,83 @@
 /* fileman.c -- A tiny application which demonstrates how to use the
    GNU Readline library.  This application interactively allows users
    to manipulate files and their modes. */
-/*
- * Remove the next line if you're compiling this against an installed
- * libreadline.a
- */
-#define READLINE_LIBRARY
 
 #ifdef HAVE_CONFIG_H
-#include <config.h>
+#  include <config.h>
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_SYS_FILE_H
-#include <sys/file.h>
+#  include <sys/file.h>
 #endif
 #include <sys/stat.h>
 
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
+#include <fcntl.h>
 #include <stdio.h>
 #include <errno.h>
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else /* !HAVE_STRING_H */
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
+#ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+#endif
+
 #ifdef READLINE_LIBRARY
 #  include "readline.h"
 #  include "history.h"
 #else
 #  include <readline/readline.h>
 #  include <readline/history.h>
 #endif
 
-extern char *getwd ();
 extern char *xmalloc ();
 
 /* The names of functions that actually do the manipulation. */
-int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
-int com_delete (), com_help (), com_cd (), com_quit ();
+int com_list __P((char *));
+int com_view __P((char *));
+int com_rename __P((char *));
+int com_stat __P((char *));
+int com_pwd __P((char *));
+int com_delete __P((char *));
+int com_help __P((char *));
+int com_cd __P((char *));
+int com_quit __P((char *));
 
 /* A structure which contains information on the commands this program
    can understand. */
 
 typedef struct {
   char *name;			/* User printable name of the function. */
-  Function *func;		/* Function to call to do the job. */
+  rl_icpfunc_t *func;		/* Function to call to do the job. */
   char *doc;			/* Documentation for this function.  */
 } COMMAND;
 
 COMMAND commands[] = {
   { "cd", com_cd, "Change to directory DIR" },
   { "delete", com_delete, "Delete FILE" },
   { "help", com_help, "Display this text" },
   { "?", com_help, "Synonym for `help'" },
   { "list", com_list, "List files in DIR" },
   { "ls", com_list, "Synonym for `list'" },
   { "pwd", com_pwd, "Print the current working directory" },
   { "quit", com_quit, "Quit using Fileman" },
   { "rename", com_rename, "Rename FILE to NEWNAME" },
   { "stat", com_stat, "Print out statistics on FILE" },
   { "view", com_view, "View the contents of FILE" },
-  { (char *)NULL, (Function *)NULL, (char *)NULL }
+  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
 };
 
 /* Forward declarations. */
 char *stripwhite ();
 COMMAND *find_command ();
 
 /* The name of this program, as taken from argv[0]. */
 char *progname;
@@ -197,60 +207,60 @@ stripwhite (string)
 }
 
 /* **************************************************************** */
 /*                                                                  */
 /*                  Interface to Readline Completion                */
 /*                                                                  */
 /* **************************************************************** */
 
-char *command_generator ();
-char **fileman_completion ();
+char *command_generator __P((const char *, int));
+char **fileman_completion __P((const char *, int, int));
 
 /* Tell the GNU Readline library how to complete.  We want to try to complete
    on command names if this is the first word in the line, or on filenames
    if not. */
 initialize_readline ()
 {
   /* Allow conditional parsing of the ~/.inputrc file. */
   rl_readline_name = "FileMan";
 
   /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+  rl_attempted_completion_function = fileman_completion;
 }
 
 /* Attempt to complete on the contents of TEXT.  START and END bound the
    region of rl_line_buffer that contains the word to complete.  TEXT is
    the word to complete.  We can use the entire contents of rl_line_buffer
    in case we want to do some simple parsing.  Return the array of matches,
    or NULL if there aren't any. */
 char **
 fileman_completion (text, start, end)
-     char *text;
+     const char *text;
      int start, end;
 {
   char **matches;
 
   matches = (char **)NULL;
 
   /* If this word is at the start of the line, then it is a command
      to complete.  Otherwise it is the name of a file in the current
      directory. */
   if (start == 0)
-    matches = completion_matches (text, command_generator);
+    matches = rl_completion_matches (text, command_generator);
 
   return (matches);
 }
 
 /* Generator function for command completion.  STATE lets us know whether
    to start from scratch; without any state (i.e. STATE == 0), then we
    start at the top of the list. */
 char *
 command_generator (text, state)
-     char *text;
+     const char *text;
      int state;
 {
   static int list_index, len;
   char *name;
 
   /* If this is a new word to complete, initialize now.  This includes
      saving the length of TEXT for efficiency, and initializing the index
      variable to 0. */
@@ -295,17 +305,22 @@ com_list (arg)
 }
 
 com_view (arg)
      char *arg;
 {
   if (!valid_argument ("view", arg))
     return 1;
 
+#if defined (__MSDOS__)
+  /* more.com doesn't grok slashes in pathnames */
+  sprintf (syscom, "less %s", arg);
+#else
   sprintf (syscom, "more %s", arg);
+#endif
   return (system (syscom));
 }
 
 com_rename (arg)
      char *arg;
 {
   too_dangerous ("rename");
   return (1);
@@ -401,17 +416,17 @@ com_cd (arg)
 }
 
 /* Print out the current working directory. */
 com_pwd (ignore)
      char *ignore;
 {
   char dir[1024], *s;
 
-  s = getwd (dir);
+  s = getcwd (dir, sizeof(dir) - 1);
   if (s == 0)
     {
       printf ("Error getting pwd: %s\n", dir);
       return 1;
     }
 
   printf ("Current directory is %s\n", dir);
   return 0;
diff --git a/readline/examples/histexamp.c b/readline/examples/histexamp.c
--- a/readline/examples/histexamp.c
+++ b/readline/examples/histexamp.c
@@ -1,9 +1,19 @@
-main ()
+#include <stdio.h>
+
+#ifdef READLINE_LIBRARY
+#  include "history.h"
+#else
+#  include <readline/history.h>
+#endif
+
+main (argc, argv)
+     int argc;
+     char **argv;
 {
   char line[1024], *t;
   int len, done = 0;
 
   line[0] = 0;
 
   using_history ();
   while (!done)
diff --git a/readline/examples/manexamp.c b/readline/examples/manexamp.c
--- a/readline/examples/manexamp.c
+++ b/readline/examples/manexamp.c
@@ -1,17 +1,16 @@
 /* manexamp.c -- The examples which appear in the documentation are here. */
 
 #include <stdio.h>
 #include <readline/readline.h>
 
-
 /* **************************************************************** */
 /*                                                                  */
-*   			How to Emulate gets ()			    */
+/*   			How to Emulate gets ()			    */
 /*                                                                  */
 /* **************************************************************** */
 
 /* A static variable for holding the line. */
 static char *line_read = (char *)NULL;
 
 /* Read a string, and return a pointer to it.  Returns NULL on EOF. */
 char *
@@ -77,18 +76,17 @@ invert_case_line (count, key)
     return;
 
   /* Tell readline that we are modifying the line, so save the undo
      information. */
   rl_modifying (start, end);
 
   for (; start != end; start += direction)
     {
-      if (uppercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = to_lower (rl_line_buffer[start]);
-      else if (lowercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = to_upper (rl_line_buffer[start]);
+      if (_rl_uppercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
+      else if (_rl_lowercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
     }
 
   /* Move point to on top of the last character changed. */
   rl_point = end - direction;
 }
-
diff --git a/readline/examples/rl.c b/readline/examples/rl.c
--- a/readline/examples/rl.c
+++ b/readline/examples/rl.c
@@ -1,77 +1,82 @@
 /*
  * rl - command-line interface to read a line from the standard input
  *      (or another fd) using readline.
  *
- * usage: rl [-p prompt] [-u unit] [-d default]
+ * usage: rl [-p prompt] [-u unit] [-d default] [-n nchars]
  */
 
-/*
- * Remove the next line if you're compiling this against an installed
- * libreadline.a
- */
-#define READLINE_LIBRARY
-
 #if defined (HAVE_CONFIG_H)
-#include <config.h>
+#  include <config.h>
 #endif
 
 #include <stdio.h>
 #include <sys/types.h>
 #include "posixstat.h"
-#include "readline.h"
-#include "history.h"
+
+#if defined (READLINE_LIBRARY)
+#  include "readline.h"
+#  include "history.h"
+#else
+#  include <readline/readline.h>
+#  include <readline/history.h>
+#endif
 
 extern int optind;
 extern char *optarg;
 
+#if !defined (strchr) && !defined (__STDC__)
 extern char *strrchr();
+#endif
 
 static char *progname;
 static char *deftext;
 
 static int
 set_deftext ()
 {
   if (deftext)
     {
       rl_insert_text (deftext);
       deftext = (char *)NULL;
-      rl_startup_hook = (Function *)NULL;
+      rl_startup_hook = (rl_hook_func_t *)NULL;
     }
+  return 0;
 }
 
+static void
 usage()
 {
-  fprintf (stderr, "%s: usage: %s [-p prompt] [-u unit] [-d default]\n",
+  fprintf (stderr, "%s: usage: %s [-p prompt] [-u unit] [-d default] [-n nchars]\n",
 		progname, progname);
 }
 
+int
 main (argc, argv)
      int argc;
      char **argv;
 {
   char *temp, *prompt;
   struct stat sb;
-  int done, opt, fd;
+  int opt, fd, nch;
   FILE *ifp;
 
   progname = strrchr(argv[0], '/');
   if (progname == 0)
     progname = argv[0];
   else
     progname++;
 
   /* defaults */
   prompt = "readline$ ";
-  fd = 0;
+  fd = nch = 0;
   deftext = (char *)0;
 
-  while ((opt = getopt(argc, argv, "p:u:d:")) != EOF)
+  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
     {
       switch (opt)
 	{
 	case 'p':
 	  prompt = optarg;
 	  break;
 	case 'u':
 	  fd = atoi(optarg);
@@ -79,16 +84,24 @@ main (argc, argv)
 	    {
 	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
 	      exit (2);
 	    }
 	  break;
 	case 'd':
 	  deftext = optarg;
 	  break;
+	case 'n':
+	  nch = atoi(optarg);
+	  if (nch < 0)
+	    {
+	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
+	      exit (2);
+	    }
+	  break;
 	default:
 	  usage ();
 	  exit (2);
 	}
     }
 
   if (fd != 0)
     {
@@ -99,17 +112,20 @@ main (argc, argv)
 	}
       ifp = fdopen (fd, "r");
       rl_instream = ifp;
     }
 
   if (deftext && *deftext)
     rl_startup_hook = set_deftext;
 
+  if (nch > 0)
+    rl_num_chars_to_read = nch;
+
   temp = readline (prompt);
 
   /* Test for EOF. */
   if (temp == 0)
     exit (1);
 
-  puts (temp);
+  printf ("%s\n", temp);
   exit (0);
 }
diff --git a/readline/examples/rltest.c b/readline/examples/rltest.c
--- a/readline/examples/rltest.c
+++ b/readline/examples/rltest.c
@@ -1,35 +1,39 @@
 /* **************************************************************** */
 /*								    */
 /*			Testing Readline			    */
 /*								    */
 /* **************************************************************** */
 
-/*
- * Remove the next line if you're compiling this against an installed
- * libreadline.a
- */
-#define READLINE_LIBRARY
-
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <stdio.h>
 #include <sys/types.h>
-#include "readline.h"
-#include "history.h"
+
+#ifdef READLINE_LIBRARY
+#  include "readline.h"
+#  include "history.h"
+#else
+#  include <readline/readline.h>
+#  include <readline/history.h>
+#endif
+
+extern HIST_ENTRY **history_list ();
 
 main ()
 {
-  HIST_ENTRY **history_list ();
-  char *temp = (char *)NULL;
-  char *prompt = "readline$ ";
-  int done = 0;
+  char *temp, *prompt;
+  int done;
+
+  temp = (char *)NULL;
+  prompt = "readline$ ";
+  done = 0;
 
   while (!done)
     {
       temp = readline (prompt);
 
       /* Test for EOF. */
       if (!temp)
 	exit (1);
@@ -42,23 +46,22 @@ main ()
 	}
 
       /* Check for `command' that we handle. */
       if (strcmp (temp, "quit") == 0)
 	done = 1;
 
       if (strcmp (temp, "list") == 0)
 	{
-	  HIST_ENTRY **list = history_list ();
+	  HIST_ENTRY **list;
 	  register int i;
+
+	  list = history_list ();
 	  if (list)
 	    {
 	      for (i = 0; list[i]; i++)
-		{
-		  fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
-		  free (list[i]->line);
-		}
-	      free (list);
+		fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
 	    }
 	}
       free (temp);
     }
+  exit (0);
 }
diff --git a/readline/funmap.c b/readline/funmap.c
--- a/readline/funmap.c
+++ b/readline/funmap.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -20,32 +20,38 @@
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 #define READLINE_LIBRARY
 
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
-extern char *xmalloc (), *xrealloc ();
-
 #if !defined (BUFSIZ)
 #include <stdio.h>
 #endif /* BUFSIZ */
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #include "rlconf.h"
 #include "readline.h"
 
-extern int _rl_qsort_string_compare ();
+#include "xmalloc.h"
+
+#ifdef __STDC__
+typedef int QSFUNC (const void *, const void *);
+#else
+typedef int QSFUNC ();
+#endif
+
+extern int _rl_qsort_string_compare __P((char **, char **));
 
 FUNMAP **funmap;
 static int funmap_size;
 static int funmap_entry;
 
 /* After initializing the function map, this is the index of the first
    program specific function. */
 int funmap_program_specific_entry_start;
@@ -66,44 +72,50 @@ static FUNMAP default_funmap[] = {
   { "character-search", rl_char_search },
   { "character-search-backward", rl_backward_char_search },
   { "clear-screen", rl_clear_screen },
   { "complete", rl_complete },
   { "copy-backward-word", rl_copy_backward_word },
   { "copy-forward-word", rl_copy_forward_word },
   { "copy-region-as-kill", rl_copy_region_to_kill },
   { "delete-char", rl_delete },
+  { "delete-char-or-list", rl_delete_or_show_completions },
   { "delete-horizontal-space", rl_delete_horizontal_space },
   { "digit-argument", rl_digit_argument },
   { "do-lowercase-version", rl_do_lowercase_version },
   { "downcase-word", rl_downcase_word },
   { "dump-functions", rl_dump_functions },
   { "dump-macros", rl_dump_macros },
   { "dump-variables", rl_dump_variables },
   { "emacs-editing-mode", rl_emacs_editing_mode },
   { "end-kbd-macro", rl_end_kbd_macro },
   { "end-of-history", rl_end_of_history },
   { "end-of-line", rl_end_of_line },
   { "exchange-point-and-mark", rl_exchange_point_and_mark },
+  { "forward-backward-delete-char", rl_rubout_or_delete },
   { "forward-char", rl_forward },
   { "forward-search-history", rl_forward_search_history },
   { "forward-word", rl_forward_word },
   { "history-search-backward", rl_history_search_backward },
   { "history-search-forward", rl_history_search_forward },
   { "insert-comment", rl_insert_comment },
   { "insert-completions", rl_insert_completions },
   { "kill-whole-line", rl_kill_full_line },
   { "kill-line", rl_kill_line },
   { "kill-region", rl_kill_region },
   { "kill-word", rl_kill_word },
+  { "menu-complete", rl_menu_complete },
   { "next-history", rl_get_next_history },
   { "non-incremental-forward-search-history", rl_noninc_forward_search },
   { "non-incremental-reverse-search-history", rl_noninc_reverse_search },
   { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
   { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
+#ifdef __CYGWIN__
+  { "paste-from-clipboard", rl_paste_from_clipboard },
+#endif
   { "possible-completions", rl_possible_completions },
   { "previous-history", rl_get_previous_history },
   { "quoted-insert", rl_quoted_insert },
   { "re-read-init-file", rl_re_read_init_file },
   { "redraw-current-line", rl_refresh_line},
   { "reverse-search-history", rl_reverse_search_history },
   { "revert-line", rl_revert_line },
   { "self-insert", rl_insert },
@@ -125,17 +137,16 @@ static FUNMAP default_funmap[] = {
   { "yank-pop", rl_yank_pop },
 
 #if defined (VI_MODE)
   { "vi-append-eol", rl_vi_append_eol },
   { "vi-append-mode", rl_vi_append_mode },
   { "vi-arg-digit", rl_vi_arg_digit },
   { "vi-back-to-indent", rl_vi_back_to_indent },
   { "vi-bWord", rl_vi_bWord },
-  { "vi-bracktype", rl_vi_bracktype },
   { "vi-bword", rl_vi_bword },
   { "vi-change-case", rl_vi_change_case },
   { "vi-change-char", rl_vi_change_char },
   { "vi-change-to", rl_vi_change_to },
   { "vi-char-search", rl_vi_char_search },
   { "vi-column", rl_vi_column },
   { "vi-complete", rl_vi_complete },
   { "vi-delete", rl_vi_delete },
@@ -165,23 +176,23 @@ static FUNMAP default_funmap[] = {
   { "vi-search-again", rl_vi_search_again },
   { "vi-set-mark", rl_vi_set_mark },
   { "vi-subst", rl_vi_subst },
   { "vi-tilde-expand", rl_vi_tilde_expand },
   { "vi-yank-arg", rl_vi_yank_arg },
   { "vi-yank-to", rl_vi_yank_to },
 #endif /* VI_MODE */
 
- {(char *)NULL, (Function *)NULL }
+ {(char *)NULL, (rl_command_func_t *)NULL }
 };
 
 int
 rl_add_funmap_entry (name, function)
-     char *name;
-     Function *function;
+     const char *name;
+     rl_command_func_t *function;
 {
   if (funmap_entry + 2 >= funmap_size)
     {
       funmap_size += 64;
       funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
     }
   
   funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
@@ -208,41 +219,32 @@ rl_initialize_funmap ()
 
   funmap_initialized = 1;
   funmap_program_specific_entry_start = i;
 }
 
 /* Produce a NULL terminated array of known function names.  The array
    is sorted.  The array itself is allocated, but not the strings inside.
    You should free () the array when you done, but not the pointrs. */
-char **
+const char **
 rl_funmap_names ()
 {
-  char **result;
+  const char **result;
   int result_size, result_index;
 
   /* Make sure that the function map has been initialized. */
   rl_initialize_funmap ();
 
-  for (result_index = result_size = 0, result = (char **)NULL; funmap[result_index]; result_index++)
+  for (result_index = result_size = 0, result = (const char **)NULL; funmap[result_index]; result_index++)
     {
       if (result_index + 2 > result_size)
 	{
 	  result_size += 20;
-	  result = (char **)xrealloc (result, result_size * sizeof (char *));
+	  result = (const char **)xrealloc (result, result_size * sizeof (char *));
 	}
 
       result[result_index] = funmap[result_index]->name;
       result[result_index + 1] = (char *)NULL;
     }
 
-  qsort (result, result_index, sizeof (char *), _rl_qsort_string_compare);
+  qsort (result, result_index, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
   return (result);
 }
-
-/* Things that mean `Control'. */
-char *possible_control_prefixes[] = {
-  "Control-", "C-", "CTRL-", (char *)NULL
-};
-
-char *possible_meta_prefixes[] = {
-  "Meta", "M-", (char *)NULL
-};
diff --git a/readline/histexpand.c b/readline/histexpand.c
--- a/readline/histexpand.c
+++ b/readline/histexpand.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -30,44 +30,50 @@
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #if defined (HAVE_UNISTD_H)
+#  ifndef _MINIX
+#    include <sys/types.h>
+#  endif
 #  include <unistd.h>
 #endif
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
 #include "history.h"
 #include "histlib.h"
 
+#include "rlshell.h"
+#include "xmalloc.h"
+
+#define HISTORY_WORD_DELIMITERS		" \t\n;&()|<>"
+#define HISTORY_QUOTE_CHARACTERS	"\"'`"
+
+typedef int _hist_search_func_t __P((const char *, int));
+
 static char error_pointer;
 
 static char *subst_lhs;
 static char *subst_rhs;
 static int subst_lhs_len;
 static int subst_rhs_len;
 
-static char *get_history_word_specifier ();
-static char *history_find_word ();
-
-extern int history_offset;
+static char *get_history_word_specifier __P((char *, char *, int *));
+static char *history_find_word __P((char *, int));
 
-extern char *single_quote ();
-static char *quote_breaks ();
-
-extern char *xmalloc (), *xrealloc ();
+static char *quote_breaks __P((char *));
 
 /* Variables exported by this file. */
 /* The character that represents the start of a history expansion
    request.  This is usually `!'. */
 char history_expansion_char = '!';
 
 /* The character that invokes word substitution if found at the start of
    a line.  This is usually `^'. */
@@ -84,17 +90,17 @@ char history_comment_char = '\0';
 char *history_no_expand_chars = " \t\n\r=";
 
 /* If set to a non-zero value, single quotes inhibit history expansion.
    The default is 0. */
 int history_quotes_inhibit_expansion = 0;
 
 /* If set, this points to a function that is called to verify that a
    particular history expansion should be performed. */
-Function *history_inhibit_expansion_function;
+rl_linebuf_func_t *history_inhibit_expansion_function;
 
 /* **************************************************************** */
 /*								    */
 /*			History Expansion			    */
 /*								    */
 /* **************************************************************** */
 
 /* Hairy history expansion on text, not tokens.  This is of general
@@ -113,25 +119,25 @@ static char *search_match;
    begins this specification.
    DELIMITING_QUOTE is a character that is allowed to end the string
    specification for what to search for in addition to the normal
    characters `:', ` ', `\t', `\n', and sometimes `?'.
    So you might call this function like:
    line = get_history_event ("!echo:p", &index, 0);  */
 char *
 get_history_event (string, caller_index, delimiting_quote)
-     char *string;
+     const char *string;
      int *caller_index;
      int delimiting_quote;
 {
   register int i;
   register char c;
   HIST_ENTRY *entry;
   int which, sign, local_index, substring_okay;
-  Function *search_func;
+  _hist_search_func_t *search_func;
   char *temp;
 
   /* The event can be specified in a number of ways.
 
      !!   the previous command
      !n   command line N
      !-n  current command-line minus N
      !str the most recent command starting with STR
@@ -331,17 +337,18 @@ quote_breaks (s)
   return ret;
 }
 
 static char *
 hist_error(s, start, current, errtype)
       char *s;
       int start, current, errtype;
 {
-  char *temp, *emsg;
+  char *temp;
+  const char *emsg;
   int ll, elen;
 
   ll = current - start;
 
   switch (errtype)
     {
     case EVENT_NOT_FOUND:
       emsg = "event not found";
@@ -354,16 +361,20 @@ hist_error(s, start, current, errtype)
     case SUBST_FAILED:
       emsg = "substitution failed";
       elen = 19;
       break;
     case BAD_MODIFIER:
       emsg = "unrecognized history modifier";
       elen = 29;
       break;
+    case NO_PREV_SUBST:
+      emsg = "no previous substitution";
+      elen = 24;
+      break;
     default:
       emsg = "unknown expansion error";
       elen = 23;
       break;
     }
 
   temp = xmalloc (ll + elen + 3);
   strncpy (temp, s + start, ll);
@@ -609,17 +620,17 @@ history_expand_internal (string, start, 
 	   occurrence of `this'.  :gs/this/that substitutes `that'
 	   for each occurrence of `this'.  :& repeats the last
 	   substitution.  :g& repeats the last substitution
 	   globally. */
 
 	case '&':
 	case 's':
 	  {
-	    char *new_event, *t;
+	    char *new_event;
 	    int delimiter, failed, si, l_temp;
 
 	    if (c == 's')
 	      {
 		if (i + 2 < (int)strlen (string))
 		  delimiter = string[i + 2];
 		else
 		  break;	/* no search delimiter */
@@ -643,36 +654,36 @@ history_expand_internal (string, start, 
 		      }
 		    else
 		      {
 			subst_lhs = (char *) NULL;
 			subst_lhs_len = 0;
 		      }
 		  }
 
-		/* If there is no lhs, the substitution can't succeed. */
-		if (subst_lhs_len == 0)
-		  {
-		    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-		    free (result);
-		    free (temp);
-		    return -1;
-		  }
-
 		FREE (subst_rhs);
 		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);
 
 		/* If `&' appears in the rhs, it's supposed to be replaced
 		   with the lhs. */
 		if (member ('&', subst_rhs))
 		  postproc_subst_rhs ();
 	      }
 	    else
 	      i += 2;
 
+	    /* If there is no lhs, the substitution can't succeed. */
+	    if (subst_lhs_len == 0)
+	      {
+		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
+		free (result);
+		free (temp);
+		return -1;
+	      }
+
 	    l_temp = strlen (temp);
 	    /* Ignore impossible cases. */
 	    if (subst_lhs_len > l_temp)
 	      {
 		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
 		free (result);
 		free (temp);
 		return (-1);
@@ -728,17 +739,17 @@ history_expand_internal (string, start, 
   /* Believe it or not, we have to back the pointer up by one. */
   --i;
 
   if (want_quotes)
     {
       char *x;
 
       if (want_quotes == 'q')
-	x = single_quote (temp);
+	x = sh_single_quote (temp);
       else if (want_quotes == 'x')
 	x = quote_breaks (temp);
       else
 	x = savestring (temp);
 
       free (temp);
       temp = x;
     }
@@ -818,18 +829,18 @@ history_expand (hstring, output)
     
   /* Prepare the buffer for printing error messages. */
   result = xmalloc (result_len = 256);
   result[0] = '\0';
 
   only_printing = modified = 0;
   l = strlen (hstring);
 
-  /* Grovel the string.  Only backslash can quote the history escape
-     character.  We also handle arg specifiers. */
+  /* Grovel the string.  Only backslash and single quotes can quote the
+     history escape character.  We also handle arg specifiers. */
 
   /* Before we grovel forever, see if the history_expansion_char appears
      anywhere within the text. */
 
   /* The quick substitution character is a history expansion all right.  That
      is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
      that is the substitution that we do. */
   if (hstring[0] == history_subst_char)
@@ -847,31 +858,44 @@ history_expand (hstring, output)
       string = hstring;
       /* If not quick substitution, still maybe have to do expansion. */
 
       /* `!' followed by one of the characters in history_no_expand_chars
 	 is NOT an expansion. */
       for (i = 0; string[i]; i++)
 	{
 	  cc = string[i + 1];
-	  if (string[i] == history_expansion_char)
+	  /* The history_comment_char, if set, appearing that the beginning
+	     of a word signifies that the rest of the line should not have
+	     history expansion performed on it.
+	     Skip the rest of the line and break out of the loop. */
+	  if (history_comment_char && string[i] == history_comment_char &&
+	      (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS)))
+	    {
+	      while (string[i])
+		i++;
+	      break;
+	    }
+	  else if (string[i] == history_expansion_char)
 	    {
 	      if (!cc || member (cc, history_no_expand_chars))
 		continue;
 	      /* If the calling application has set
 		 history_inhibit_expansion_function to a function that checks
 		 for special cases that should not be history expanded,
 		 call the function and skip the expansion if it returns a
 		 non-zero value. */
 	      else if (history_inhibit_expansion_function &&
 			(*history_inhibit_expansion_function) (string, i))
 		continue;
 	      else
 		break;
 	    }
+	  /* XXX - at some point, might want to extend this to handle
+		   double quotes as well. */
 	  else if (history_quotes_inhibit_expansion && string[i] == '\'')
 	    {
 	      /* If this is bash, single quotes inhibit history expansion. */
 	      i++;
 	      hist_string_extract_single_quoted (string, &i);
 	    }
 	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
 	    {
@@ -899,16 +923,18 @@ history_expand (hstring, output)
 	{
 	  passc = 0;
 	  ADD_CHAR (tchar);
 	  continue;
 	}
 
       if (tchar == history_expansion_char)
 	tchar = -3;
+      else if (tchar == history_comment_char)
+	tchar = -2;
 
       switch (tchar)
 	{
 	default:
 	  ADD_CHAR (string[i]);
 	  break;
 
 	case '\\':
@@ -934,16 +960,29 @@ history_expand (hstring, output)
 		ADD_STRING (temp);
 		free (temp);
 	      }
 	    else
 	      ADD_CHAR (string[i]);
 	    break;
 	  }
 
+	case -2:		/* history_comment_char */
+	  if (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS))
+	    {
+	      temp = xmalloc (l - i + 1);
+	      strcpy (temp, string + i);
+	      ADD_STRING (temp);
+	      free (temp);
+	      i = l;
+	    }
+	  else
+	    ADD_CHAR (string[i]);
+	  break;
+
 	case -3:		/* history_expansion_char */
 	  cc = string[i + 1];
 
 	  /* If the history_expansion_char is followed by one of the
 	     characters in history_no_expand_chars, then it is not a
 	     candidate for expansion of any kind. */
 	  if (member (cc, history_no_expand_chars))
 	    {
@@ -1110,17 +1149,17 @@ get_history_word_specifier (spec, from, 
 /* Extract the args specified, starting at FIRST, and ending at LAST.
    The args are taken from STRING.  If either FIRST or LAST is < 0,
    then make that arg count from the right (subtract from the number of
    tokens, so that FIRST = -1 means the next to last token on the line).
    If LAST is `$' the last arg from STRING is used. */
 char *
 history_arg_extract (first, last, string)
      int first, last;
-     char *string;
+     const char *string;
 {
   register int i, len;
   char *result;
   int size, offset;
   char **list;
 
   /* XXX - think about making history_tokenize return a struct array,
      each struct in array being a string and a length to avoid the
@@ -1176,23 +1215,28 @@ history_arg_extract (first, last, string
 #define slashify_in_quotes "\\`\"$"
 
 /* Parse STRING into tokens and return an array of strings.  If WIND is
    not -1 and INDP is not null, we also want the word surrounding index
    WIND.  The position in the returned array of strings is returned in
    *INDP. */
 static char **
 history_tokenize_internal (string, wind, indp)
-     char *string;
+     const char *string;
      int wind, *indp;
 {
   char **result;
   register int i, start, result_index, size;
   int len, delimiter;
 
+  /* If we're searching for a string that's not part of a word (e.g., " "),
+     make sure we set *INDP to a reasonable value. */
+  if (indp && wind != -1)
+    *indp = -1;
+
   /* Get a token, and stuff it into RESULT.  The tokens are split
      exactly where the shell would split them. */
   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
     {
       delimiter = 0;
 
       /* Skip leading whitespace. */
       for (; string[i] && whitespace (string[i]); i++)
@@ -1233,17 +1277,17 @@ history_tokenize_internal (string, wind,
 	    {
 	      i++;
 	      goto got_token;
 	    }
 	}
 
       /* Get word from string + i; */
 
-      if (member (string[i], "\"'`"))
+      if (member (string[i], HISTORY_QUOTE_CHARACTERS))
 	delimiter = string[i++];
 
       for (; string[i]; i++)
 	{
 	  if (string[i] == '\\' && string[i + 1] == '\n')
 	    {
 	      i++;
 	      continue;
@@ -1257,20 +1301,20 @@ history_tokenize_internal (string, wind,
 	    }
 
 	  if (delimiter && string[i] == delimiter)
 	    {
 	      delimiter = 0;
 	      continue;
 	    }
 
-	  if (!delimiter && (member (string[i], " \t\n;&()|<>")))
+	  if (!delimiter && (member (string[i], HISTORY_WORD_DELIMITERS)))
 	    break;
 
-	  if (!delimiter && member (string[i], "\"'`"))
+	  if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
 	    delimiter = string[i];
 	}
 
     got_token:
 
       /* If we are looking for the word in which the character at a
 	 particular index falls, remember it. */
       if (indp && wind != -1 && wind >= start && wind < i)
@@ -1287,34 +1331,34 @@ history_tokenize_internal (string, wind,
 
   return (result);
 }
 
 /* Return an array of tokens, much as the shell might.  The tokens are
    parsed out of STRING. */
 char **
 history_tokenize (string)
-     char *string;
+     const char *string;
 {
   return (history_tokenize_internal (string, -1, (int *)NULL));
 }
 
 /* Find and return the word which contains the character at index IND
    in the history line LINE.  Used to save the word matched by the
    last history !?string? search. */
 static char *
 history_find_word (line, ind)
      char *line;
      int ind;
 {
   char **words, *s;
   int i, wind;
 
   words = history_tokenize_internal (line, ind, &wind);
-  if (wind == -1)
+  if (wind == -1 || words == 0)
     return ((char *)NULL);
   s = words[wind];
   for (i = 0; i < wind; i++)
     free (words[i]);
   for (i = wind + 1; words[i]; i++)
     free (words[i]);
   free (words);
   return s;
diff --git a/readline/histfile.c b/readline/histfile.c
--- a/readline/histfile.c
+++ b/readline/histfile.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -27,18 +27,20 @@
 
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
 #include <stdio.h>
 
 #include <sys/types.h>
-#include <sys/file.h>
-#include <sys/stat.h>
+#ifndef _MINIX
+#  include <sys/file.h>
+#endif
+#include "posixstat.h"
 #include <fcntl.h>
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
@@ -47,141 +49,162 @@
 #endif
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
+
+/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
+   on win 95/98/nt), we want to open files with O_BINARY mode so that there
+   is no \n -> \r\n conversion performed.  On other systems, we don't want to
+   mess around with O_BINARY at all, so we ensure that it's defined to 0. */
 #if defined (__EMX__) || defined (__CYGWIN__)
 #  ifndef O_BINARY
 #    define O_BINARY 0
 #  endif
 #else /* !__EMX__ && !__CYGWIN__ */
-   /* If we're not compiling for __EMX__, we don't want this at all.  Ever. */
 #  undef O_BINARY
 #  define O_BINARY 0
-#endif /* !__EMX__ */
+#endif /* !__EMX__ && !__CYGWIN__ */
 
 #include <errno.h>
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
 #include "history.h"
 #include "histlib.h"
 
-/* Functions imported from shell.c */
-extern char *get_env_value ();
-
-extern char *xmalloc (), *xrealloc ();
+#include "rlshell.h"
+#include "xmalloc.h"
 
 /* Return the string that should be used in the place of this
    filename.  This only matters when you don't specify the
    filename to read_history (), or write_history (). */
 static char *
 history_filename (filename)
-     char *filename;
+     const char *filename;
 {
-  char *return_val, *home;
+  char *return_val;
+  const char *home;
   int home_len;
 
   return_val = filename ? savestring (filename) : (char *)NULL;
 
   if (return_val)
     return (return_val);
   
-  home = get_env_value ("HOME");
+  home = sh_get_env_value ("HOME");
 
   if (home == 0)
     {
       home = ".";
       home_len = 1;
     }
   else
     home_len = strlen (home);
 
   return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
   strcpy (return_val, home);
   return_val[home_len] = '/';
+#if defined (__MSDOS__)
+  strcpy (return_val + home_len + 1, "_history");
+#else
   strcpy (return_val + home_len + 1, ".history");
+#endif
 
   return (return_val);
 }
 
 /* Add the contents of FILENAME to the history list, a line at a time.
    If FILENAME is NULL, then read from ~/.history.  Returns 0 if
    successful, or errno if not. */
 int
 read_history (filename)
-     char *filename;
+     const char *filename;
 {
   return (read_history_range (filename, 0, -1));
 }
 
 /* Read a range of lines from FILENAME, adding them to the history list.
    Start reading at the FROM'th line and end at the TO'th.  If FROM
    is zero, start at the beginning.  If TO is less than FROM, read
    until the end of the file.  If FILENAME is NULL, then read from
    ~/.history.  Returns 0 if successful, or errno if not. */
 int
 read_history_range (filename, from, to)
-     char *filename;
+     const char *filename;
      int from, to;
 {
   register int line_start, line_end;
-  char *input, *buffer = (char *)NULL;
-  int file, current_line;
+  char *input, *buffer;
+  int file, current_line, chars_read;
   struct stat finfo;
+  size_t file_size;
 
+  buffer = (char *)NULL;
   input = history_filename (filename);
   file = open (input, O_RDONLY|O_BINARY, 0666);
 
   if ((file < 0) || (fstat (file, &finfo) == -1))
     goto error_and_exit;
 
-  buffer = xmalloc ((int)finfo.st_size + 1);
+  file_size = (size_t)finfo.st_size;
 
-  if (read (file, buffer, finfo.st_size) != finfo.st_size)
+  /* check for overflow on very large files */
+  if (file_size != finfo.st_size || file_size + 1 < file_size)
+    {
+#if defined (EFBIG)
+      errno = EFBIG;
+#endif
+      goto error_and_exit;
+    }
+
+  buffer = xmalloc (file_size + 1);
+
+  chars_read = read (file, buffer, file_size);
+  if (chars_read < 0)
     {
   error_and_exit:
       if (file >= 0)
 	close (file);
 
       FREE (input);
       FREE (buffer);
 
       return (errno);
     }
 
   close (file);
 
   /* Set TO to larger than end of file if negative. */
   if (to < 0)
-    to = finfo.st_size;
+    to = chars_read;
 
   /* Start at beginning of file, work to end. */
   line_start = line_end = current_line = 0;
 
   /* Skip lines until we are at FROM. */
-  while (line_start < finfo.st_size && current_line < from)
+  while (line_start < chars_read && current_line < from)
     {
-      for (line_end = line_start; line_end < finfo.st_size; line_end++)
+      for (line_end = line_start; line_end < chars_read; line_end++)
 	if (buffer[line_end] == '\n')
 	  {
 	    current_line++;
 	    line_start = line_end + 1;
 	    if (current_line == from)
 	      break;
 	  }
     }
 
   /* If there are lines left to gobble, then gobble them now. */
-  for (line_end = line_start; line_end < finfo.st_size; line_end++)
+  for (line_end = line_start; line_end < chars_read; line_end++)
     if (buffer[line_end] == '\n')
       {
 	buffer[line_end] = '\0';
 
 	if (buffer[line_start])
 	  add_history (buffer + line_start);
 
 	current_line++;
@@ -197,33 +220,51 @@ read_history_range (filename, from, to)
 
   return (0);
 }
 
 /* Truncate the history file FNAME, leaving only LINES trailing lines.
    If FNAME is NULL, then use ~/.history. */
 int
 history_truncate_file (fname, lines)
-     char *fname;
-     register int lines;
+     const char *fname;
+     int lines;
 {
   register int i;
   int file, chars_read;
   char *buffer, *filename;
   struct stat finfo;
+  size_t file_size;
 
   buffer = (char *)NULL;
   filename = history_filename (fname);
   file = open (filename, O_RDONLY|O_BINARY, 0666);
 
-  if (file == -1 || fstat (file, &finfo) == -1)
-    goto truncate_exit;
+  /* Don't try to truncate non-regular files. */
+  if (file == -1 || fstat (file, &finfo) == -1 || S_ISREG (finfo.st_mode) == 0)
+    {
+      if (file != -1)
+	close (file);
+      goto truncate_exit;
+    }
+
+  file_size = (size_t)finfo.st_size;
 
-  buffer = xmalloc ((int)finfo.st_size + 1);
-  chars_read = read (file, buffer, finfo.st_size);
+  /* check for overflow on very large files */
+  if (file_size != finfo.st_size || file_size + 1 < file_size)
+    {
+      close (file);
+#if defined (EFBIG)
+      errno = EFBIG;
+#endif
+      goto truncate_exit;
+    }
+
+  buffer = xmalloc (file_size + 1);
+  chars_read = read (file, buffer, file_size);
   close (file);
 
   if (chars_read <= 0)
     goto truncate_exit;
 
   /* Count backwards from the end of buffer until we have passed
      LINES lines. */
   for (i = chars_read - 1; lines && i; i--)
@@ -241,46 +282,52 @@ history_truncate_file (fname, lines)
     if (buffer[i] == '\n')
       {
 	i++;
 	break;
       }
 
   /* Write only if there are more lines in the file than we want to
      truncate to. */
-  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0666)) != -1))
+  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
     {
-      write (file, buffer + i, finfo.st_size - i);
+      write (file, buffer + i, chars_read - i);
+
+#if defined (__BEOS__)
+      /* BeOS ignores O_TRUNC. */
+      ftruncate (file, chars_read - i);
+#endif
+
       close (file);
     }
 
  truncate_exit:
 
   FREE (buffer);
 
   free (filename);
   return 0;
 }
 
 /* Workhorse function for writing history.  Writes NELEMENT entries
    from the history list to FILENAME.  OVERWRITE is non-zero if you
    wish to replace FILENAME with the entries. */
 static int
 history_do_write (filename, nelements, overwrite)
-     char *filename;
+     const char *filename;
      int nelements, overwrite;
 {
   register int i;
   char *output;
   int file, mode;
 
   mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
   output = history_filename (filename);
 
-  if ((file = open (output, mode, 0666)) == -1)
+  if ((file = open (output, mode, 0600)) == -1)
     {
       FREE (output);
       return (errno);
     }
 
   if (nelements > history_length)
     nelements = history_length;
 
@@ -318,22 +365,22 @@ history_do_write (filename, nelements, o
   return (0);
 }
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
    the end of the list minus NELEMENTs up to the end of the list. */
 int
 append_history (nelements, filename)
      int nelements;
-     char *filename;
+     const char *filename;
 {
   return (history_do_write (filename, nelements, HISTORY_APPEND));
 }
 
 /* Overwrite FILENAME with the current history.  If FILENAME is NULL,
    then write the history list to ~/.history.  Values returned
    are as in read_history ().*/
 int
 write_history (filename)
-     char *filename;
+     const char *filename;
 {
   return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
 }
diff --git a/readline/histlib.h b/readline/histlib.h
--- a/readline/histlib.h
+++ b/readline/histlib.h
@@ -1,43 +1,37 @@
 /* histlib.h -- internal definitions for the history library. */
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
    is generally kept in a file called COPYING or LICENSE.  If you do not
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
 #if !defined (_HISTLIB_H_)
 #define _HISTLIB_H_
 
-/* Function pointers can be declared as (Function *)foo. */
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-#endif /* _FUNCTION_DEF */
-
+#if !defined (STREQ)
 #define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
-#define STREQN(a, b, n)	(((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
+#define STREQN(a, b, n) (((n) == 0) ? (1) \
+				    : ((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
+#endif
 
 #ifndef savestring
 #  ifndef strcpy
 extern char *strcpy ();
 #  endif
 #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
 #endif
 
@@ -64,18 +58,22 @@ extern char *strchr ();
 #  define FREE(x)	if (x) free (x)
 #endif
 
 /* Possible history errors passed to hist_error. */
 #define EVENT_NOT_FOUND 0
 #define BAD_WORD_SPEC	1
 #define SUBST_FAILED	2
 #define BAD_MODIFIER	3
+#define NO_PREV_SUBST	4
 
 /* Possible definitions for history starting point specification. */
 #define ANCHORED_SEARCH 1
 #define NON_ANCHORED_SEARCH 0
 
 /* Possible definitions for what style of writing the history file we want. */
 #define HISTORY_APPEND 0
 #define HISTORY_OVERWRITE 1
 
+/* Some variable definitions shared across history source files. */
+extern int history_offset;
+
 #endif /* !_HISTLIB_H_ */
diff --git a/readline/history.c b/readline/history.c
--- a/readline/history.c
+++ b/readline/history.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -33,29 +33,32 @@
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
 #  include <unistd.h>
 #endif
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
 #include "history.h"
 #include "histlib.h"
 
-extern char *xmalloc (), *xrealloc ();
+#include "xmalloc.h"
 
 /* The number of slots to increase the_history by. */
 #define DEFAULT_HISTORY_GROW_SIZE 50
 
 /* **************************************************************** */
 /*								    */
 /*			History Functions			    */
 /*								    */
@@ -126,19 +129,17 @@ using_history ()
 
 /* Return the number of bytes that the primary history entries are using.
    This just adds up the lengths of the_history->lines. */
 int
 history_total_bytes ()
 {
   register int i, result;
 
-  result = 0;
-
-  for (i = 0; the_history && the_history[i]; i++)
+  for (i = result = 0; the_history && the_history[i]; i++)
     result += strlen (the_history[i]->line);
 
   return (result);
 }
 
 /* Returns the magic number which says what history element we are
    looking at now.  In this implementation, it returns history_offset. */
 int
@@ -209,17 +210,17 @@ history_get (offset)
 		? (HIST_ENTRY *)NULL
 		: the_history[local_index];
 }
 
 /* Place STRING at the end of the history list.  The data field
    is  set to NULL. */
 void
 add_history (string)
-     char *string;
+     const char *string;
 {
   HIST_ENTRY *temp;
 
   if (history_stifled && (history_length == max_input_history))
     {
       register int i;
 
       /* If the history is stifled, and history_length is zero,
@@ -269,25 +270,25 @@ add_history (string)
 }
 
 /* Make the history entry at WHICH have LINE and DATA.  This returns
    the old entry so you can dispose of the data.  In the case of an
    invalid WHICH, a NULL pointer is returned. */
 HIST_ENTRY *
 replace_history_entry (which, line, data)
      int which;
-     char *line;
-     char *data;
+     const char *line;
+     histdata_t data;
 {
-  HIST_ENTRY *temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-  HIST_ENTRY *old_value;
+  HIST_ENTRY *temp, *old_value;
 
   if (which >= history_length)
     return ((HIST_ENTRY *)NULL);
 
+  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
   old_value = the_history[which];
 
   temp->line = savestring (line);
   temp->data = data;
   the_history[which] = temp;
 
   return (old_value);
 }
@@ -295,45 +296,45 @@ replace_history_entry (which, line, data
 /* Remove history element WHICH from the history.  The removed
    element is returned to you so you can free the line, data,
    and containing structure. */
 HIST_ENTRY *
 remove_history (which)
      int which;
 {
   HIST_ENTRY *return_value;
+  register int i;
 
   if (which >= history_length || !history_length)
     return_value = (HIST_ENTRY *)NULL;
   else
     {
-      register int i;
       return_value = the_history[which];
 
       for (i = which; i < history_length; i++)
 	the_history[i] = the_history[i + 1];
 
       history_length--;
     }
 
   return (return_value);
 }
 
 /* Stifle the history list, remembering only MAX number of lines. */
 void
 stifle_history (max)
      int max;
 {
+  register int i, j;
+
   if (max < 0)
     max = 0;
 
   if (history_length > max)
     {
-      register int i, j;
-
       /* This loses because we cannot free the data. */
       for (i = 0, j = history_length - max; i < j; i++)
 	{
 	  free (the_history[i]->line);
 	  free (the_history[i]);
 	}
 
       history_base = i;
diff --git a/readline/history.h b/readline/history.h
--- a/readline/history.h
+++ b/readline/history.h
@@ -1,17 +1,17 @@
 /* History.h -- the names of functions that you can call in history. */
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -21,28 +21,34 @@
 
 #ifndef _HISTORY_H_
 #define _HISTORY_H_
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
+#if defined READLINE_LIBRARY
+#  include "rlstdc.h"
+#  include "rltypedefs.h"
+#else
+#  include <readline/rlstdc.h>
+#  include <readline/rltypedefs.h>
+#endif
+
+#ifdef __STDC__
+typedef void *histdata_t;
+#else
+typedef char *histdata_t;
 #endif
 
 /* The structure used to store a history entry. */
 typedef struct _hist_entry {
   char *line;
-  char *data;
+  histdata_t data;
 } HIST_ENTRY;
 
 /* A structure used to pass the current state of the history stuff around. */
 typedef struct _hist_state {
   HIST_ENTRY **entries;		/* Pointer to the entries themselves. */
   int offset;			/* The location pointer within this array. */
   int length;			/* Number of elements within this array. */
   int size;			/* Number of slots allocated to this array. */
@@ -51,181 +57,186 @@ typedef struct _hist_state {
 
 /* Flag values for the `flags' member of HISTORY_STATE. */
 #define HS_STIFLED	0x01
 
 /* Initialization and state management. */
 
 /* Begin a session in which the history functions might be used.  This
    just initializes the interactive variables. */
-extern void using_history ();
+extern void using_history __P((void));
 
 /* Return the current HISTORY_STATE of the history. */
-extern HISTORY_STATE *history_get_history_state ();
+extern HISTORY_STATE *history_get_history_state __P((void));
 
 /* Set the state of the current history array to STATE. */
-extern void history_set_history_state ();
+extern void history_set_history_state __P((HISTORY_STATE *));
 
 /* Manage the history list. */
 
 /* Place STRING at the end of the history list.
    The associated data field (if any) is set to NULL. */
-extern void add_history ();
+extern void add_history __P((const char *));
 
 /* A reasonably useless function, only here for completeness.  WHICH
    is the magic number that tells us which element to delete.  The
    elements are numbered from 0. */
-extern HIST_ENTRY *remove_history ();
+extern HIST_ENTRY *remove_history __P((int));
 
 /* Make the history entry at WHICH have LINE and DATA.  This returns
    the old entry so you can dispose of the data.  In the case of an
    invalid WHICH, a NULL pointer is returned. */
-extern HIST_ENTRY *replace_history_entry ();
+extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
 
 /* Clear the history list and start over. */
-extern void clear_history ();
+extern void clear_history __P((void));
 
 /* Stifle the history list, remembering only MAX number of entries. */
-extern void stifle_history ();
+extern void stifle_history __P((int));
 
 /* Stop stifling the history.  This returns the previous amount the
    history was stifled by.  The value is positive if the history was
    stifled, negative if it wasn't. */
-extern int unstifle_history ();
+extern int unstifle_history __P((void));
 
 /* Return 1 if the history is stifled, 0 if it is not. */
-extern int history_is_stifled ();
+extern int history_is_stifled __P((void));
 
 /* Information about the history list. */
 
 /* Return a NULL terminated array of HIST_ENTRY which is the current input
    history.  Element 0 of this list is the beginning of time.  If there
    is no history, return NULL. */
-extern HIST_ENTRY **history_list ();
+extern HIST_ENTRY **history_list __P((void));
 
 /* Returns the number which says what history element we are now
    looking at.  */
-extern int where_history ();
+extern int where_history __P((void));
   
 /* Return the history entry at the current position, as determined by
    history_offset.  If there is no entry there, return a NULL pointer. */
-HIST_ENTRY *current_history ();
+extern HIST_ENTRY *current_history __P((void));
 
 /* Return the history entry which is logically at OFFSET in the history
    array.  OFFSET is relative to history_base. */
-extern HIST_ENTRY *history_get ();
+extern HIST_ENTRY *history_get __P((int));
 
 /* Return the number of bytes that the primary history entries are using.
    This just adds up the lengths of the_history->lines. */
-extern int history_total_bytes ();
+extern int history_total_bytes __P((void));
 
 /* Moving around the history list. */
 
 /* Set the position in the history list to POS. */
-int history_set_pos ();
+extern int history_set_pos __P((int));
 
 /* Back up history_offset to the previous history entry, and return
    a pointer to that entry.  If there is no previous entry, return
    a NULL pointer. */
-extern HIST_ENTRY *previous_history ();
+extern HIST_ENTRY *previous_history __P((void));
 
 /* Move history_offset forward to the next item in the input_history,
    and return the a pointer to that entry.  If there is no next entry,
    return a NULL pointer. */
-extern HIST_ENTRY *next_history ();
+extern HIST_ENTRY *next_history __P((void));
 
 /* Searching the history list. */
 
 /* Search the history for STRING, starting at history_offset.
    If DIRECTION < 0, then the search is through previous entries,
    else through subsequent.  If the string is found, then
    current_history () is the history entry, and the value of this function
    is the offset in the line of that history entry that the string was
    found in.  Otherwise, nothing is changed, and a -1 is returned. */
-extern int history_search ();
+extern int history_search __P((const char *, int));
 
 /* Search the history for STRING, starting at history_offset.
-   The search is anchored: matching lines must begin with string. */
-extern int history_search_prefix ();
+   The search is anchored: matching lines must begin with string.
+   DIRECTION is as in history_search(). */
+extern int history_search_prefix __P((const char *, int));
 
 /* Search for STRING in the history list, starting at POS, an
    absolute index into the list.  DIR, if negative, says to search
    backwards from POS, else forwards.
    Returns the absolute index of the history element where STRING
    was found, or -1 otherwise. */
-extern int history_search_pos ();
+extern int history_search_pos __P((const char *, int, int));
 
 /* Managing the history file. */
 
 /* Add the contents of FILENAME to the history list, a line at a time.
    If FILENAME is NULL, then read from ~/.history.  Returns 0 if
    successful, or errno if not. */
-extern int read_history ();
+extern int read_history __P((const char *));
 
 /* Read a range of lines from FILENAME, adding them to the history list.
    Start reading at the FROM'th line and end at the TO'th.  If FROM
    is zero, start at the beginning.  If TO is less than FROM, read
    until the end of the file.  If FILENAME is NULL, then read from
    ~/.history.  Returns 0 if successful, or errno if not. */
-extern int read_history_range ();
+extern int read_history_range __P((const char *, int, int));
 
 /* Write the current history to FILENAME.  If FILENAME is NULL,
    then write the history list to ~/.history.  Values returned
    are as in read_history ().  */
-extern int write_history ();
+extern int write_history __P((const char *));
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
    the end of the list minus NELEMENTs up to the end of the list. */
-int append_history ();
+extern int append_history __P((int, const char *));
 
 /* Truncate the history file, leaving only the last NLINES lines. */
-extern int history_truncate_file ();
+extern int history_truncate_file __P((const char *, int));
 
 /* History expansion. */
 
 /* Expand the string STRING, placing the result into OUTPUT, a pointer
    to a string.  Returns:
 
    0) If no expansions took place (or, if the only change in
       the text was the de-slashifying of the history expansion
       character)
    1) If expansions did take place
   -1) If there was an error in expansion.
    2) If the returned line should just be printed.
 
   If an error ocurred in expansion, then OUTPUT contains a descriptive
   error message. */
-extern int history_expand ();
+extern int history_expand __P((char *, char **));
 
 /* Extract a string segment consisting of the FIRST through LAST
    arguments present in STRING.  Arguments are broken up as in
    the shell. */
-extern char *history_arg_extract ();
+extern char *history_arg_extract __P((int, int, const char *));
 
 /* Return the text of the history event beginning at the current
-   offset into STRING. */
-extern char *get_history_event ();
+   offset into STRING.  Pass STRING with *INDEX equal to the
+   history_expansion_char that begins this specification.
+   DELIMITING_QUOTE is a character that is allowed to end the string
+   specification for what to search for in addition to the normal
+   characters `:', ` ', `\t', `\n', and sometimes `?'. */
+extern char *get_history_event __P((const char *, int *, int));
 
 /* Return an array of tokens, much as the shell might.  The tokens are
    parsed out of STRING. */
-extern char **history_tokenize ();
+extern char **history_tokenize __P((const char *));
 
 /* Exported history variables. */
 extern int history_base;
 extern int history_length;
 extern int max_input_history;
 extern char history_expansion_char;
 extern char history_subst_char;
 extern char history_comment_char;
 extern char *history_no_expand_chars;
 extern char *history_search_delimiter_chars;
 extern int history_quotes_inhibit_expansion;
 
 /* If set, this function is called to decide whether or not a particular
    history expansion should be treated as a special case for the calling
    application and not expanded. */
-extern Function *history_inhibit_expansion_function;
+extern rl_linebuf_func_t *history_inhibit_expansion_function;
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* !_HISTORY_H_ */
diff --git a/readline/histsearch.c b/readline/histsearch.c
--- a/readline/histsearch.c
+++ b/readline/histsearch.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (the Library), a set of
    routines for managing the text of previously typed lines.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -28,47 +28,47 @@
 
 #include <stdio.h>
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 #if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
 #  include <unistd.h>
 #endif
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
 #include "history.h"
 #include "histlib.h"
 
-/* Variables imported from other history library files. */
-extern int history_offset;
-
 /* The list of alternate characters that can delimit a history search
    string. */
 char *history_search_delimiter_chars = (char *)NULL;
 
 /* Search the history for STRING, starting at history_offset.
    If DIRECTION < 0, then the search is through previous entries, else
    through subsequent.  If ANCHORED is non-zero, the string must
    appear at the beginning of a history line, otherwise, the string
    may appear anywhere in the line.  If the string is found, then
    current_history () is the history entry, and the value of this
    function is the offset in the line of that history entry that the
    string was found in.  Otherwise, nothing is changed, and a -1 is
    returned. */
 
 static int
 history_search_internal (string, direction, anchored)
-     char *string;
+     const char *string;
      int direction, anchored;
 {
   register int i, reverse;
   register char *line;
   register int line_index;
   int string_len;
   HIST_ENTRY **the_history; 	/* local */
 
@@ -154,37 +154,37 @@ history_search_internal (string, directi
 	}
       NEXT_LINE ();
     }
 }
 
 /* Do a non-anchored search for STRING through the history in DIRECTION. */
 int
 history_search (string, direction)
-     char *string;
+     const char *string;
      int direction;
 {
   return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
 }
 
 /* Do an anchored search for string through the history in DIRECTION. */
 int
 history_search_prefix (string, direction)
-     char *string;
+     const char *string;
      int direction;
 {
   return (history_search_internal (string, direction, ANCHORED_SEARCH));
 }
 
 /* Search for STRING in the history list.  DIR is < 0 for searching
    backwards.  POS is an absolute index into the history list at
    which point to begin searching. */
 int
 history_search_pos (string, dir, pos)
-     char *string;
+     const char *string;
      int dir, pos;
 {
   int ret, old;
 
   old = where_history ();
   history_set_pos (pos);
   if (history_search (string, dir) == -1)
     {
diff --git a/readline/input.c b/readline/input.c
--- a/readline/input.c
+++ b/readline/input.c
@@ -62,54 +62,30 @@ extern int errno;
 #endif /* !errno */
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 
+#include "rlprivate.h"
+#include "rlshell.h"
+#include "xmalloc.h"
+
 /* What kind of non-blocking I/O do we have? */
 #if !defined (O_NDELAY) && defined (O_NONBLOCK)
 #  define O_NDELAY O_NONBLOCK	/* Posix style */
 #endif
 
-/* Functions imported from other files in the library. */
-extern char *xmalloc (), *xrealloc ();
-
-/* Variables and functions from macro.c. */
-extern void _rl_add_macro_char ();
-extern void _rl_with_macro_input ();
-extern int _rl_next_macro_key ();
-extern int _rl_defining_kbd_macro;
-
-#if defined (VI_MODE)
-extern void _rl_vi_set_last ();
-extern int _rl_vi_textmod_command ();
-#endif /* VI_MODE */
-
-extern FILE *rl_instream, *rl_outstream;
-extern Function *rl_last_func;
-extern int rl_key_sequence_length;
-extern int rl_pending_input;
-extern int rl_editing_mode;
-
-extern Keymap _rl_keymap;
-
-extern int _rl_convert_meta_chars_to_ascii;
-
-#if defined (__GO32__)
-#  include <pc.h>
-#endif /* __GO32__ */
-
 /* Non-null means it is a pointer to a function to run while waiting for
    character input. */
-Function *rl_event_hook = (Function *)NULL;
+rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
 
-Function *rl_getc_function = rl_getc;
+rl_getc_func_t *rl_getc_function = rl_getc;
 
 /* **************************************************************** */
 /*								    */
 /*			Character Input Buffering       	    */
 /*								    */
 /* **************************************************************** */
 
 static int pop_index, push_index;
@@ -119,48 +95,23 @@ static int ibuffer_len = sizeof (ibuffer
 #define any_typein (push_index != pop_index)
 
 int
 _rl_any_typein ()
 {
   return any_typein;
 }
 
-/* Add KEY to the buffer of characters to be read. */
-int
-rl_stuff_char (key)
-     int key;
-{
-  if (key == EOF)
-    {
-      key = NEWLINE;
-      rl_pending_input = EOF;
-    }
-  ibuffer[push_index++] = key;
-  if (push_index >= ibuffer_len)
-    push_index = 0;
-  return push_index;
-}
-
-/* Make C be the next command to be executed. */
-int
-rl_execute_next (c)
-     int c;
-{
-  rl_pending_input = c;
-  return 0;
-}
-
-/* Return the amount of space available in the
-   buffer for stuffing characters. */
+/* Return the amount of space available in the buffer for stuffing
+   characters. */
 static int
 ibuffer_space ()
 {
   if (pop_index > push_index)
-    return (pop_index - push_index);
+    return (pop_index - push_index - 1);
   else
     return (ibuffer_len - (push_index - pop_index));
 }
 
 /* Get a key from the buffer of characters to be read.
    Return the key in KEY.
    Result is KEY if there was a key, or 0 if there wasn't. */
 static int
@@ -196,27 +147,16 @@ rl_unget_char (key)
   return (0);
 }
 
 /* If a character is available to be read, then read it
    and stuff it into IBUFFER.  Otherwise, just return. */
 static void
 rl_gather_tyi ()
 {
-#if defined (__GO32__)
-  char input;
-
-  if (isatty (0) && kbhit () && ibuffer_space ())
-    {
-      int i;
-      i = (*rl_getc_function) (rl_instream);
-      rl_stuff_char (i);
-    }
-#else /* !__GO32__ */
-
   int tty;
   register int tem, result;
   int chars_avail;
   char input;
 #if defined(HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
 #endif
@@ -275,17 +215,16 @@ rl_gather_tyi ()
       while (chars_avail--)
 	rl_stuff_char ((*rl_getc_function) (rl_instream));
     }
   else
     {
       if (chars_avail)
 	rl_stuff_char (input);
     }
-#endif /* !__GO32__ */
 }
 
 /* Is there input available to be read on the readline input file
    descriptor?  Only works if the system has select(2) or FIONREAD. */
 int
 _rl_input_available ()
 {
 #if defined(HAVE_SELECT)
@@ -336,16 +275,57 @@ void
   if (t)
     rl_unget_char (key);
 
   string[i] = '\0';
   rl_insert_text (string);
   free (string);
 }
 
+/* Add KEY to the buffer of characters to be read.  Returns 1 if the
+   character was stuffed correctly; 0 otherwise. */
+int
+rl_stuff_char (key)
+     int key;
+{
+  if (ibuffer_space () == 0)
+    return 0;
+
+  if (key == EOF)
+    {
+      key = NEWLINE;
+      rl_pending_input = EOF;
+      RL_SETSTATE (RL_STATE_INPUTPENDING);
+    }
+  ibuffer[push_index++] = key;
+  if (push_index >= ibuffer_len)
+    push_index = 0;
+
+  return 1;
+}
+
+/* Make C be the next command to be executed. */
+int
+rl_execute_next (c)
+     int c;
+{
+  rl_pending_input = c;
+  RL_SETSTATE (RL_STATE_INPUTPENDING);
+  return 0;
+}
+
+/* Clear any pending input pushed with rl_execute_next() */
+int
+rl_clear_pending_input ()
+{
+  rl_pending_input = 0;
+  RL_UNSETSTATE (RL_STATE_INPUTPENDING);
+  return 0;
+}
+
 /* **************************************************************** */
 /*								    */
 /*			     Character Input			    */
 /*								    */
 /* **************************************************************** */
 
 /* Read a key, including pending input. */
 int
@@ -353,17 +333,17 @@ rl_read_key ()
 {
   int c;
 
   rl_key_sequence_length++;
 
   if (rl_pending_input)
     {
       c = rl_pending_input;
-      rl_pending_input = 0;
+      rl_clear_pending_input ();
     }
   else
     {
       /* If input is coming from a macro, then use that. */
       if (c = _rl_next_macro_key ())
 	return (c);
 
       /* If the user has an event function, then call it periodically. */
@@ -384,66 +364,57 @@ rl_read_key ()
 
   return (c);
 }
 
 int
 rl_getc (stream)
      FILE *stream;
 {
-  int result, flags;
+  int result;
   unsigned char c;
 
-#if defined (__GO32__)
-  if (isatty (0))
-    return (getkey () & 0x7F);
-#endif /* __GO32__ */
-
   while (1)
     {
       result = read (fileno (stream), &c, sizeof (unsigned char));
 
       if (result == sizeof (unsigned char))
 	return (c);
 
       /* If zero characters are returned, then the file that we are
 	 reading from is empty!  Return EOF in that case. */
       if (result == 0)
 	return (EOF);
 
+#if defined (__BEOS__)
+      if (errno == EINTR)
+	continue;
+#endif
+
 #if defined (EWOULDBLOCK)
-      if (errno == EWOULDBLOCK)
+#  define X_EWOULDBLOCK EWOULDBLOCK
+#else
+#  define X_EWOULDBLOCK -99
+#endif
+
+#if defined (EAGAIN)
+#  define X_EAGAIN EAGAIN
+#else
+#  define X_EAGAIN -99
+#endif
+
+      if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
 	{
-	  if ((flags = fcntl (fileno (stream), F_GETFL, 0)) < 0)
+	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
 	    return (EOF);
-	  if (flags & O_NDELAY)
-	    {
-	      flags &= ~O_NDELAY;
-	      fcntl (fileno (stream), F_SETFL, flags);
-	      continue;
-	    }
 	  continue;
 	}
-#endif /* EWOULDBLOCK */
 
-#if defined (_POSIX_VERSION) && defined (EAGAIN) && defined (O_NONBLOCK)
-      if (errno == EAGAIN)
-	{
-	  if ((flags = fcntl (fileno (stream), F_GETFL, 0)) < 0)
-	    return (EOF);
-	  if (flags & O_NONBLOCK)
-	    {
-	      flags &= ~O_NONBLOCK;
-	      fcntl (fileno (stream), F_SETFL, flags);
-	      continue;
-	    }
-	}
-#endif /* _POSIX_VERSION && EAGAIN && O_NONBLOCK */
+#undef X_EWOULDBLOCK
+#undef X_EAGAIN
 
-#if !defined (__GO32__)
       /* If the error that we received was SIGINT, then try again,
 	 this is simply an interrupted system call to read ().
 	 Otherwise, some error ocurred, also signifying EOF. */
       if (errno != EINTR)
 	return (EOF);
-#endif /* !__GO32__ */
     }
 }
diff --git a/readline/isearch.c b/readline/isearch.c
--- a/readline/isearch.c
+++ b/readline/isearch.c
@@ -7,17 +7,17 @@
 /* Copyright (C) 1987,1989 Free Software Foundation, Inc.
 
    This file contains the Readline Library (the Library), a set of
    routines for providing Emacs style line input to programs that ask
    for it.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -43,34 +43,27 @@
 #else
 #  include "ansi_stdlib.h"
 #endif
 
 #include "rldefs.h"
 #include "readline.h"
 #include "history.h"
 
-/* Variables imported from other files in the readline library. */
-extern Keymap _rl_keymap;
-extern HIST_ENTRY *saved_line_for_history;
-extern int rl_line_buffer_len;
-extern int rl_point, rl_end;
-extern char *rl_line_buffer;
+#include "rlprivate.h"
+#include "xmalloc.h"
+
+/* Variables exported to other files in the readline library. */
+unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;
 
-extern void _rl_save_prompt ();
-extern void _rl_restore_prompt ();
-
-extern int rl_execute_next ();
-extern void rl_extend_line_buffer ();
+/* Variables imported from other files in the readline library. */
+extern HIST_ENTRY *_rl_saved_line_for_history;
 
-extern int _rl_input_available ();
-
-extern char *xmalloc (), *xrealloc ();
-
-static int rl_search_history ();
+/* Forward declarations */
+static int rl_search_history __P((int, int));
 
 /* Last line found by the current incremental search, so we don't `find'
    identical lines many times in a row. */
 static char *prev_line_found;
 
 /* Search backwards through the history looking for a string which is typed
    interactively.  Start with the current line. */
 int
@@ -173,50 +166,59 @@ rl_search_history (direction, invoking_k
   char *sline;
 
   /* Offset in that line. */
   int line_index;
 
   /* Non-zero if we are doing a reverse search. */
   int reverse;
 
+  /* The list of characters which terminate the search, but are not
+     subsequently executed.  If the variable isearch-terminators has
+     been set, we use that value, otherwise we use ESC and C-J. */
+  unsigned char *isearch_terminators;
+
+  RL_SETSTATE(RL_STATE_ISEARCH);
   orig_point = rl_point;
   last_found_line = orig_line = where_history ();
   reverse = direction < 0;
   hlist = history_list ();
   allocated_line = (char *)NULL;
 
+  isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
+						: (unsigned char *)"\033\012";
+
   /* Create an arrary of pointers to the lines that we want to search. */
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
   i = 0;
   if (hlist)
     for (i = 0; hlist[i]; i++);
 
   /* Allocate space for this many lines, +1 for the current input line,
      and remember those lines. */
   lines = (char **)xmalloc ((1 + (hlen = i)) * sizeof (char *));
   for (i = 0; i < hlen; i++)
     lines[i] = hlist[i]->line;
 
-  if (saved_line_for_history)
-    lines[i] = saved_line_for_history->line;
+  if (_rl_saved_line_for_history)
+    lines[i] = _rl_saved_line_for_history->line;
   else
     {
       /* Keep track of this so we can free it. */
       allocated_line = xmalloc (1 + strlen (rl_line_buffer));
       strcpy (allocated_line, &rl_line_buffer[0]);
       lines[i] = allocated_line;
     }
 
   hlen++;
 
   /* The line where we start the search. */
   i = orig_line;
 
-  _rl_save_prompt ();
+  rl_save_prompt ();
 
   /* Initialize search parameters. */
   search_string = xmalloc (search_string_size = 128);
   *search_string = '\0';
   search_string_index = 0;
   prev_line_found = (char *)0;		/* XXX */
 
   /* Normalize DIRECTION into 1 or -1. */
@@ -226,83 +228,111 @@ rl_search_history (direction, invoking_k
 
   sline = rl_line_buffer;
   sline_len = strlen (sline);
   line_index = rl_point;
 
   found = failed = 0;
   for (;;)
     {
-      Function *f = (Function *)NULL;
+      rl_command_func_t *f = (rl_command_func_t *)NULL;
 
       /* Read a key and decide how to proceed. */
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       if (_rl_keymap[c].type == ISFUNC)
 	{
 	  f = _rl_keymap[c].function;
 
 	  if (f == rl_reverse_search_history)
 	    c = reverse ? -1 : -2;
 	  else if (f == rl_forward_search_history)
 	    c =  !reverse ? -1 : -2;
 	}
 
+#if 0
       /* Let NEWLINE (^J) terminate the search for people who don't like
 	 using ESC.  ^M can still be used to terminate the search and
 	 immediately execute the command. */
       if (c == ESC || c == NEWLINE)
+#else
+      /* The characters in isearch_terminators (set from the user-settable
+	 variable isearch-terminators) are used to terminate the search but
+	 not subsequently execute the character as a command.  The default
+	 value is "\033\012" (ESC and C-J). */
+      if (strchr (isearch_terminators, c))
+#endif
 	{
 	  /* ESC still terminates the search, but if there is pending
 	     input or if input arrives within 0.1 seconds (on systems
 	     with select(2)) it is used as a prefix character
 	     with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
 	     to allow the arrow keys to be used like ^F and ^B are used
 	     to terminate the search and execute the movement command. */
 	  if (c == ESC && _rl_input_available ())	/* XXX */
 	    rl_execute_next (ESC);
 	  break;
 	}
 
-      if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT))
+      if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
 	{
+	  /* This sets rl_pending_input to c; it will be picked up the next
+	     time rl_read_key is called. */
 	  rl_execute_next (c);
 	  break;
 	}
 
       switch (c)
 	{
 	case -1:
 	  if (search_string_index == 0)
 	    continue;
 	  else if (reverse)
 	    --line_index;
 	  else if (line_index != sline_len)
 	    ++line_index;
 	  else
-	    ding ();
+	    rl_ding ();
 	  break;
 
 	  /* switch directions */
 	case -2:
 	  direction = -direction;
 	  reverse = direction < 0;
 	  break;
 
 	case CTRL ('G'):
 	  strcpy (rl_line_buffer, lines[orig_line]);
 	  rl_point = orig_point;
 	  rl_end = strlen (rl_line_buffer);
-	  _rl_restore_prompt();
+	  rl_restore_prompt();
 	  rl_clear_message ();
 	  if (allocated_line)
 	    free (allocated_line);
 	  free (lines);
+	  RL_UNSETSTATE(RL_STATE_ISEARCH);
 	  return 0;
 
+#if 0
+	/* delete character from search string. */
+	case -3:
+	  if (search_string_index == 0)
+	    rl_ding ();
+	  else
+	    {
+	      search_string[--search_string_index] = '\0';
+	      /* This is tricky.  To do this right, we need to keep a
+		 stack of search positions for the current search, with
+		 sentinels marking the beginning and end. */
+	    }
+	  break;
+#endif
+
 	default:
 	  /* Add character to search string and continue search. */
 	  if (search_string_index + 2 >= search_string_size)
 	    {
 	      search_string_size += 128;
 	      search_string = xrealloc (search_string, search_string_size);
 	    }
 	  search_string[search_string_index++] = c;
@@ -355,17 +385,17 @@ rl_search_history (direction, invoking_k
 
 	  /* Now set up the line for searching... */
 	  line_index = reverse ? sline_len - search_string_index : 0;
 	}
 
       if (failed)
 	{
 	  /* We cannot find the search string.  Ding the bell. */
-	  ding ();
+	  rl_ding ();
 	  i = last_found_line;
 	  continue; 		/* XXX - was break */
 	}
 
       /* We have found the search string.  Just display it.  But don't
 	 actually move there in the history list until the user accepts
 	 the location. */
       if (found)
@@ -389,30 +419,32 @@ rl_search_history (direction, invoking_k
   /* The searching is over.  The user may have found the string that she
      was looking for, or else she may have exited a failing search.  If
      LINE_INDEX is -1, then that shows that the string searched for was
      not found.  We use this to determine where to place rl_point. */
 
   /* First put back the original state. */
   strcpy (rl_line_buffer, lines[orig_line]);
 
-  _rl_restore_prompt ();
+  rl_restore_prompt ();
 
   /* Free the search string. */
   free (search_string);
 
   if (last_found_line < orig_line)
-    rl_get_previous_history (orig_line - last_found_line);
+    rl_get_previous_history (orig_line - last_found_line, 0);
   else
-    rl_get_next_history (last_found_line - orig_line);
+    rl_get_next_history (last_found_line - orig_line, 0);
 
   /* If the string was not found, put point at the end of the line. */
   if (line_index < 0)
     line_index = strlen (rl_line_buffer);
   rl_point = line_index;
   rl_clear_message ();
 
   if (allocated_line)
     free (allocated_line);
   free (lines);
 
+  RL_UNSETSTATE(RL_STATE_ISEARCH);
+
   return 0;
 }
diff --git a/readline/keymaps.c b/readline/keymaps.c
--- a/readline/keymaps.c
+++ b/readline/keymaps.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1988,1989 Free Software Foundation, Inc.
 
    This file is part of GNU Readline, a library for reading lines
    of text with interactive input and history editing.
 
    Readline is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 1, or (at your option) any
+   Free Software Foundation; either version 2, or (at your option) any
    later version.
 
    Readline is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    You should have received a copy of the GNU General Public License
@@ -25,28 +25,28 @@
 #endif
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#include <stdio.h>	/* for FILE * definition for readline.h */
+
+#include "readline.h"
 #include "rlconf.h"
-#include "keymaps.h"
+
 #include "emacs_keymap.c"
 
 #if defined (VI_MODE)
 #include "vi_keymap.c"
 #endif
 
-extern int rl_do_lowercase_version ();
-extern int rl_rubout (), rl_insert ();
-
-extern char *xmalloc (), *xrealloc ();
+#include "xmalloc.h"
 
 /* **************************************************************** */
 /*								    */
 /*		      Functions for manipulating Keymaps.	    */
 /*								    */
 /* **************************************************************** */
 
 
@@ -56,17 +56,17 @@ Keymap
 rl_make_bare_keymap ()
 {
   register int i;
   Keymap keymap = (Keymap)xmalloc (KEYMAP_SIZE * sizeof (KEYMAP_ENTRY));
 
   for (i = 0; i < KEYMAP_SIZE; i++)
     {
       keymap[i].type = ISFUNC;
-      keymap[i].function = (Function *)NULL;
+      keymap[i].function = (rl_command_func_t *)NULL;
     }
 
   for (i = 'A'; i < ('Z' + 1); i++)
     {
       keymap[i].type = ISFUNC;
       keymap[i].function = rl_do_lowercase_version;
     }
 
@@ -119,17 +119,17 @@ rl_make_keymap ()
 #endif /* KEYMAP_SIZE > 128 */
 
   return (newmap);
 }
 
 /* Free the storage associated with MAP. */
 void
 rl_discard_keymap (map)
-     Keymap (map);
+     Keymap map;
 {
   int i;
 
   if (!map)
     return;
 
   for (i = 0; i < KEYMAP_SIZE; i++)
     {
diff --git a/readline/keymaps.h b/readline/keymaps.h
--- a/readline/keymaps.h
+++ b/readline/keymaps.h
@@ -2,94 +2,101 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
    is generally kept in a file called COPYING or LICENSE.  If you do not
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
 #ifndef _KEYMAPS_H_
 #define _KEYMAPS_H_
 
-#if defined (READLINE_LIBRARY)
-#  include "chardefs.h"
-#else
-#  include <readline/chardefs.h>
+#ifdef __cplusplus
+extern "C" {
 #endif
 
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
+#if defined (READLINE_LIBRARY)
+#  include "rlstdc.h"
+#  include "chardefs.h"
+#  include "rltypedefs.h"
+#else
+#  include <readline/rlstdc.h>
+#  include <readline/chardefs.h>
+#  include <readline/rltypedefs.h>
 #endif
 
 /* A keymap contains one entry for each key in the ASCII set.
    Each entry consists of a type and a pointer.
-   POINTER is the address of a function to run, or the
+   FUNCTION is the address of a function to run, or the
    address of a keymap to indirect through.
-   TYPE says which kind of thing POINTER is. */
+   TYPE says which kind of thing FUNCTION is. */
 typedef struct _keymap_entry {
   char type;
-  Function *function;
+  rl_command_func_t *function;
 } KEYMAP_ENTRY;
 
 /* This must be large enough to hold bindings for all of the characters
    in a desired character set (e.g, 128 for ASCII, 256 for ISO Latin-x,
    and so on). */
 #define KEYMAP_SIZE 256
 
 /* I wanted to make the above structure contain a union of:
-   union { Function *function; struct _keymap_entry *keymap; } value;
+   union { rl_command_func_t *function; struct _keymap_entry *keymap; } value;
    but this made it impossible for me to create a static array.
    Maybe I need C lessons. */
 
 typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[KEYMAP_SIZE];
 typedef KEYMAP_ENTRY *Keymap;
 
 /* The values that TYPE can have in a keymap entry. */
 #define ISFUNC 0
 #define ISKMAP 1
 #define ISMACR 2
 
 extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
 extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
 
 /* Return a new, empty keymap.
    Free it with free() when you are done. */
-extern Keymap rl_make_bare_keymap ();
+extern Keymap rl_make_bare_keymap __P((void));
 
 /* Return a new keymap which is a copy of MAP. */
-extern Keymap rl_copy_keymap ();
+extern Keymap rl_copy_keymap __P((Keymap));
 
 /* Return a new keymap with the printing characters bound to rl_insert,
    the lowercase Meta characters bound to run their equivalents, and
    the Meta digits bound to produce numeric arguments. */
-extern Keymap rl_make_keymap ();
+extern Keymap rl_make_keymap __P((void));
 
-extern void rl_discard_keymap ();
+/* Free the storage associated with a keymap. */
+extern void rl_discard_keymap __P((Keymap));
+
+/* These functions actually appear in bind.c */
 
 /* Return the keymap corresponding to a given name.  Names look like
-   `emacs' or `emacs-meta' or `vi-insert'. */
-extern Keymap rl_get_keymap_by_name ();
+   `emacs' or `emacs-meta' or `vi-insert'.  */
+extern Keymap rl_get_keymap_by_name __P((const char *));
 
 /* Return the current keymap. */
-extern Keymap rl_get_keymap ();
+extern Keymap rl_get_keymap __P((void));
 
 /* Set the current keymap to MAP. */
-extern void rl_set_keymap ();
+extern void rl_set_keymap __P((Keymap));
+
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* _KEYMAPS_H_ */
diff --git a/readline/kill.c b/readline/kill.c
--- a/readline/kill.c
+++ b/readline/kill.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1994 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -41,27 +41,18 @@
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
-extern int _rl_last_command_was_kill;
-extern int rl_editing_mode;
-extern int rl_explicit_arg;
-extern Function *rl_last_func;
-
-extern void _rl_init_argument ();
-extern int _rl_set_mark_at_pos ();
-extern void _rl_fix_point ();
-extern void _rl_abort_internal ();
-
-extern char *xmalloc (), *xrealloc ();
+#include "rlprivate.h"
+#include "xmalloc.h"
 
 /* **************************************************************** */
 /*								    */
 /*			Killing Mechanism			    */
 /*								    */
 /* **************************************************************** */
 
 /* What we assume for a max number of kills. */
@@ -268,17 +259,17 @@ rl_backward_kill_line (direction, ignore
 {
   int orig_point = rl_point;
 
   if (direction < 0)
     return (rl_kill_line (1, ignore));
   else
     {
       if (!rl_point)
-	ding ();
+	rl_ding ();
       else
 	{
 	  rl_beg_of_line (1, ignore);
 	  rl_kill_text (orig_point, rl_point);
 	}
     }
   return 0;
 }
@@ -303,17 +294,17 @@ rl_kill_full_line (count, ignore)
    using behaviour that they expect. */
 int
 rl_unix_word_rubout (count, key)
      int count, key;
 {
   int orig_point;
 
   if (rl_point == 0)
-    ding ();
+    rl_ding ();
   else
     {
       orig_point = rl_point;
       if (count <= 0)
 	count = 1;
 
       while (count--)
 	{
@@ -335,17 +326,17 @@ rl_unix_word_rubout (count, key)
    latter, because if you are a Unix weenie, then you haven't backspaced
    into the line at all, and if you aren't, then you know what you are
    doing. */
 int
 rl_unix_line_discard (count, key)
      int count, key;
 {
   if (rl_point == 0)
-    ding ();
+    rl_ding ();
   else
     {
       rl_kill_text (rl_point, 0);
       rl_point = 0;
     }
   return 0;
 }
 
@@ -380,20 +371,22 @@ rl_copy_region_to_kill (count, ignore)
   return (region_kill_internal (0));
 }
 
 /* Kill the text between the point and mark. */
 int
 rl_kill_region (count, ignore)
      int count, ignore;
 {
-  int r;
+  int r, npoint;
 
+  npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
   r = region_kill_internal (1);
   _rl_fix_point (1);
+  rl_point = npoint;
   return r;
 }
 
 /* Copy COUNT words to the kill ring.  DIR says which direction we look
    to find the words. */
 static int
 _rl_copy_word_as_kill (count, dir)
      int count, dir;
@@ -490,37 +483,48 @@ rl_yank_pop (count, key)
     }
   else
     {
       _rl_abort_internal ();
       return -1;
     }
 }
 
-/* Yank the COUNTth argument from the previous history line. */
-int
-rl_yank_nth_arg (count, ignore)
-     int count, ignore;
+/* Yank the COUNTh argument from the previous history line, skipping
+   HISTORY_SKIP lines before looking for the `previous line'. */
+static int
+rl_yank_nth_arg_internal (count, ignore, history_skip)
+     int count, ignore, history_skip;
 {
   register HIST_ENTRY *entry;
   char *arg;
+  int i, pos;
+
+  pos = where_history ();
+
+  if (history_skip)
+    {
+      for (i = 0; i < history_skip; i++)
+	entry = previous_history ();
+    }
 
   entry = previous_history ();
-  if (entry)
-    next_history ();
-  else
+
+  history_set_pos (pos);
+
+  if (entry == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   arg = history_arg_extract (count, count, entry->line);
   if (!arg || !*arg)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   rl_begin_undo_group ();
 
 #if defined (VI_MODE)
   /* Vi mode always inserts a space before yanking the argument, and it
      inserts it right *after* rl_point. */
@@ -533,20 +537,92 @@ rl_yank_nth_arg (count, ignore)
 
   rl_insert_text (arg);
   free (arg);
 
   rl_end_undo_group ();
   return 0;
 }
 
+/* Yank the COUNTth argument from the previous history line. */
+int
+rl_yank_nth_arg (count, ignore)
+     int count, ignore;
+{
+  return (rl_yank_nth_arg_internal (count, ignore, 0));
+}
+
 /* Yank the last argument from the previous history line.  This `knows'
    how rl_yank_nth_arg treats a count of `$'.  With an argument, this
    behaves the same as rl_yank_nth_arg. */
 int
 rl_yank_last_arg (count, key)
      int count, key;
 {
-  if (rl_explicit_arg)
-    return (rl_yank_nth_arg (count, key));
+  static int history_skip = 0;
+  static int explicit_arg_p = 0;
+  static int count_passed = 1;
+  static int direction = 1;
+  static int undo_needed = 0;
+  int retval;
+
+  if (rl_last_func != rl_yank_last_arg)
+    {
+      history_skip = 0;
+      explicit_arg_p = rl_explicit_arg;
+      count_passed = count;
+      direction = 1;
+    }
+  else
+    {
+      if (undo_needed)
+	rl_do_undo ();
+      if (count < 1)
+        direction = -direction;
+      history_skip += direction;
+      if (history_skip < 0)
+	history_skip = 0;
+    }
+ 
+  if (explicit_arg_p)
+    retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);
   else
-    return (rl_yank_nth_arg ('$', key));
+    retval = rl_yank_nth_arg_internal ('$', key, history_skip);
+
+  undo_needed = retval == 0;
+  return retval;
 }
+
+/* A special paste command for users of Cygnus's cygwin32. */
+#if defined (__CYGWIN__)
+#include <windows.h>
+
+int
+rl_paste_from_clipboard (count, key)
+     int count, key;
+{
+  char *data, *ptr;
+  int len;
+
+  if (OpenClipboard (NULL) == 0)
+    return (0);
+
+  data = (char *)GetClipboardData (CF_TEXT);
+  if (data)
+    {
+      ptr = strchr (data, '\r');
+      if (ptr)
+	{
+	  len = ptr - data;
+	  ptr = xmalloc (len + 1);
+	  ptr[len] = '\0';
+	  strncpy (ptr, data, len);
+	}
+      else
+        ptr = data;
+      rl_insert_text (ptr);
+      if (ptr != data)
+	free (ptr);
+      CloseClipboard ();
+    }
+  return (0);
+}
+#endif /* __CYGWIN__ */
diff --git a/readline/macro.c b/readline/macro.c
--- a/readline/macro.c
+++ b/readline/macro.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1994 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -41,43 +41,34 @@
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* Forward definitions. */
-void _rl_push_executing_macro (), _rl_pop_executing_macro ();
-void _rl_add_macro_char ();
+#include "rlprivate.h"
+#include "xmalloc.h"
 
-/* Extern declarations. */
-extern int rl_explicit_arg;
-extern int rl_key_sequence_length;
-
-extern void _rl_abort_internal ();
-
-extern char *xmalloc (), *xrealloc ();
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
 
 /* **************************************************************** */
 /*								    */
 /*			Hacking Keyboard Macros 		    */
 /*								    */
 /* **************************************************************** */
 
+/* The currently executing macro string.  If this is non-zero,
+   then it is a malloc ()'ed string where input is coming from. */
+char *rl_executing_macro = (char *)NULL;
+
 /* Non-zero means to save keys that we dispatch on in a kbd macro. */
 int _rl_defining_kbd_macro = 0;
 
-/* The currently executing macro string.  If this is non-zero,
-   then it is a malloc ()'ed string where input is coming from. */
-char *_rl_executing_macro = (char *)NULL;
-
 /* The offset in the above string to the next character to be read. */
 static int executing_macro_index;
 
 /* The current macro string being built.  Characters get stuffed
    in here by add_macro_char (). */
 static char *current_macro = (char *)NULL;
 
 /* The size of the buffer allocated to current_macro. */
@@ -99,72 +90,74 @@ static struct saved_macro *macro_list = 
 
 /* Set up to read subsequent input from STRING.
    STRING is free ()'ed when we are done with it. */
 void
 _rl_with_macro_input (string)
      char *string;
 {
   _rl_push_executing_macro ();
-  _rl_executing_macro = string;
+  rl_executing_macro = string;
   executing_macro_index = 0;
+  RL_SETSTATE(RL_STATE_MACROINPUT);
 }
 
 /* Return the next character available from a macro, or 0 if
    there are no macro characters. */
 int
 _rl_next_macro_key ()
 {
-  if (_rl_executing_macro == 0)
+  if (rl_executing_macro == 0)
     return (0);
 
-  if (_rl_executing_macro[executing_macro_index] == 0)
+  if (rl_executing_macro[executing_macro_index] == 0)
     {
       _rl_pop_executing_macro ();
       return (_rl_next_macro_key ());
     }
 
-  return (_rl_executing_macro[executing_macro_index++]);
+  return (rl_executing_macro[executing_macro_index++]);
 }
 
 /* Save the currently executing macro on a stack of saved macros. */
 void
 _rl_push_executing_macro ()
 {
   struct saved_macro *saver;
 
   saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
   saver->next = macro_list;
   saver->sindex = executing_macro_index;
-  saver->string = _rl_executing_macro;
+  saver->string = rl_executing_macro;
 
   macro_list = saver;
 }
 
 /* Discard the current macro, replacing it with the one
    on the top of the stack of saved macros. */
 void
 _rl_pop_executing_macro ()
 {
   struct saved_macro *macro;
 
-  if (_rl_executing_macro)
-    free (_rl_executing_macro);
-
-  _rl_executing_macro = (char *)NULL;
+  FREE (rl_executing_macro);
+  rl_executing_macro = (char *)NULL;
   executing_macro_index = 0;
 
   if (macro_list)
     {
       macro = macro_list;
-      _rl_executing_macro = macro_list->string;
+      rl_executing_macro = macro_list->string;
       executing_macro_index = macro_list->sindex;
       macro_list = macro_list->next;
       free (macro);
     }
+
+  if (rl_executing_macro == 0)
+    RL_UNSETSTATE(RL_STATE_MACROINPUT);
 }
 
 /* Add a character to the macro being built. */
 void
 _rl_add_macro_char (c)
      int c;
 {
   if (current_macro_index + 1 >= current_macro_size)
@@ -184,24 +177,22 @@ void
 {
   if (current_macro)
     {
       free (current_macro);
       current_macro = (char *) NULL;
     }
   current_macro_size = current_macro_index = 0;
 
-  if (_rl_executing_macro)
-    {
-      free (_rl_executing_macro);
-      _rl_executing_macro = (char *) NULL;
-    }
+  FREE (rl_executing_macro);
+  rl_executing_macro = (char *) NULL;
   executing_macro_index = 0;
 
   _rl_defining_kbd_macro = 0;
+  RL_UNSETSTATE(RL_STATE_MACRODEF);
 }
 
 /* Begin defining a keyboard macro.
    Keystrokes are recorded as they are executed.
    End the definition with rl_end_kbd_macro ().
    If a numeric argument was explicitly typed, then append this
    definition to the end of the existing macro, and start by
    re-executing the existing macro. */
@@ -219,16 +210,17 @@ rl_start_kbd_macro (ignore1, ignore2)
     {
       if (current_macro)
 	_rl_with_macro_input (savestring (current_macro));
     }
   else
     current_macro_index = 0;
 
   _rl_defining_kbd_macro = 1;
+  RL_SETSTATE(RL_STATE_MACRODEF);
   return 0;
 }
 
 /* Stop defining a keyboard macro.
    A numeric argument says to execute the macro right now,
    that many times, counting the definition as the first time. */
 int
 rl_end_kbd_macro (count, ignore)
@@ -239,32 +231,33 @@ rl_end_kbd_macro (count, ignore)
       _rl_abort_internal ();
       return -1;
     }
 
   current_macro_index -= rl_key_sequence_length - 1;
   current_macro[current_macro_index] = '\0';
 
   _rl_defining_kbd_macro = 0;
+  RL_UNSETSTATE(RL_STATE_MACRODEF);
 
   return (rl_call_last_kbd_macro (--count, 0));
 }
 
 /* Execute the most recently defined keyboard macro.
    COUNT says how many times to execute it. */
 int
 rl_call_last_kbd_macro (count, ignore)
      int count, ignore;
 {
   if (current_macro == 0)
     _rl_abort_internal ();
 
   if (_rl_defining_kbd_macro)
     {
-      ding ();		/* no recursive macros */
+      rl_ding ();		/* no recursive macros */
       current_macro[--current_macro_index] = '\0';	/* erase this char */
       return 0;
     }
 
   while (count--)
     _rl_with_macro_input (savestring (current_macro));
   return 0;
 }
diff --git a/readline/nls.c b/readline/nls.c
--- a/readline/nls.c
+++ b/readline/nls.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1996 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -22,16 +22,18 @@
 #define READLINE_LIBRARY
 
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
 #include <sys/types.h>
 
+#include <stdio.h>
+
 #if defined (HAVE_UNISTD_H)
 #  include <unistd.h>
 #endif /* HAVE_UNISTD_H */
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
@@ -39,23 +41,19 @@
 
 #if defined (HAVE_LOCALE_H)
 #  include <locale.h>
 #endif
 
 #include <ctype.h>
 
 #include "rldefs.h"
-
-extern int _rl_convert_meta_chars_to_ascii;
-extern int _rl_output_meta_chars;
-extern int _rl_meta_flag;
-
-/* Functions imported from shell.c */
-extern char *get_env_value ();
+#include "readline.h"
+#include "rlshell.h"
+#include "rlprivate.h"
 
 #if !defined (HAVE_SETLOCALE)    
 /* A list of legal values for the LANG or LC_CTYPE environment variables.
    If a locale name in this list is the value for the LC_ALL, LC_CTYPE,
    or LANG environment variable (using the first of those with a value),
    readline eight-bit mode is enabled. */
 static char *legal_lang_values[] =
 {
@@ -64,22 +62,22 @@ static char *legal_lang_values[] =
  "iso88593",
  "iso88594",
  "iso88595",
  "iso88596",
  "iso88597",
  "iso88598",
  "iso88599",
  "iso885910",
- "koi8r",   
+ "koi8r",
   0
 };
 
-static char *normalize_codeset ();
-static char *find_codeset ();
+static char *normalize_codeset __P((char *));
+static char *find_codeset __P((char *, size_t *));
 #endif /* !HAVE_SETLOCALE */
 
 /* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
    to decide the defaults for 8-bit character input and output.  Returns
    1 if we set eight-bit mode. */
 int
 _rl_init_eightbit ()
 {
@@ -102,19 +100,19 @@ int
 
 #else /* !HAVE_SETLOCALE */
   char *lspec, *t;
   int i;
 
   /* We don't have setlocale.  Finesse it.  Check the environment for the
      appropriate variables and set eight-bit mode if they have the right
      values. */
-  lspec = get_env_value ("LC_ALL");
-  if (lspec == 0) lspec = get_env_value ("LC_CTYPE");
-  if (lspec == 0) lspec = get_env_value ("LANG");
+  lspec = sh_get_env_value ("LC_ALL");
+  if (lspec == 0) lspec = sh_get_env_value ("LC_CTYPE");
+  if (lspec == 0) lspec = sh_get_env_value ("LANG");
   if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
     return (0);
   for (i = 0; t && legal_lang_values[i]; i++)
     if (STREQ (t, legal_lang_values[i]))
       {
 	_rl_meta_flag = 1;
 	_rl_convert_meta_chars_to_ascii = 0;
 	_rl_output_meta_chars = 1;
diff --git a/readline/parens.c b/readline/parens.c
--- a/readline/parens.c
+++ b/readline/parens.c
@@ -2,44 +2,32 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
    is generally kept in a file called COPYING or LICENSE.  If you do not
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 #define READLINE_LIBRARY
 
 #include "rlconf.h"
 
-#if !defined (PAREN_MATCHING)
-extern int rl_insert ();
-
-int
-rl_insert_close (count, invoking_key)
-     int count, invoking_key;
-{
-  return (rl_insert (count, invoking_key));
-}
-
-#else /* PAREN_MATCHING */
-
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
 #include <stdio.h>
 #include <sys/types.h>
 
 #if defined (FD_SET) && !defined (HAVE_SELECT)
@@ -59,28 +47,61 @@ rl_insert_close (count, invoking_key)
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
 #if !defined (strchr) && !defined (__STDC__)
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
 
 #include "readline.h"
+#include "rlprivate.h"
 
-extern int rl_explicit_arg;
+static int find_matching_open __P((char *, int, int));
 
 /* Non-zero means try to blink the matching open parenthesis when the
    close parenthesis is inserted. */
 #if defined (HAVE_SELECT)
 int rl_blink_matching_paren = 1;
 #else /* !HAVE_SELECT */
 int rl_blink_matching_paren = 0;
 #endif /* !HAVE_SELECT */
 
-static int find_matching_open ();
+static int _paren_blink_usec = 500000;
+
+/* Change emacs_standard_keymap to have bindings for paren matching when
+   ON_OR_OFF is 1, change them back to self_insert when ON_OR_OFF == 0. */
+void
+_rl_enable_paren_matching (on_or_off)
+     int on_or_off;
+{
+  if (on_or_off)
+    {	/* ([{ */
+      rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);
+      rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);
+      rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);
+    }
+  else
+    {	/* ([{ */
+      rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);
+      rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);
+      rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);
+    }
+}
+
+int
+rl_set_paren_blink_timeout (u)
+     int u;
+{
+  int o;
+
+  o = _paren_blink_usec;
+  if (u > 0)
+    _paren_blink_usec = u;
+  return (o);
+}
 
 int
 rl_insert_close (count, invoking_key)
      int count, invoking_key;
 {
   if (rl_explicit_arg || !rl_blink_matching_paren)
     rl_insert (count, invoking_key);
   else
@@ -97,17 +118,17 @@ rl_insert_close (count, invoking_key)
 
       /* Emacs might message or ring the bell here, but I don't. */
       if (match_point < 0)
 	return -1;
 
       FD_ZERO (&readfds);
       FD_SET (fileno (rl_instream), &readfds);
       timer.tv_sec = 0;
-      timer.tv_usec = 500000;
+      timer.tv_usec = _paren_blink_usec;
 
       orig_point = rl_point;
       rl_point = match_point;
       (*rl_redisplay_function) ();
       ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
       rl_point = orig_point;
 #else /* !HAVE_SELECT */
       rl_insert (count, invoking_key);
@@ -147,10 +168,8 @@ find_matching_open (string, from, closer
       else if (!delimiter && (string[i] == opener))
 	level--;
 
       if (!level)
 	break;
     }
   return (i);
 }
-
-#endif /* PAREN_MATCHING */
diff --git a/readline/posixjmp.h b/readline/posixjmp.h
--- a/readline/posixjmp.h
+++ b/readline/posixjmp.h
@@ -1,20 +1,40 @@
 /* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
 
+/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   Bash is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+
 #ifndef _POSIXJMP_H_
 #define _POSIXJMP_H_
 
 #include <setjmp.h>
 
 /* This *must* be included *after* config.h */
 
 #if defined (HAVE_POSIX_SIGSETJMP)
 #  define procenv_t	sigjmp_buf
-#  undef setjmp
-#  define setjmp(x)	sigsetjmp((x), 1)
-#  undef longjmp
-#  define longjmp(x, n)	siglongjmp((x), (n))
+#  if !defined (__OPENNT)
+#    undef setjmp
+#    define setjmp(x)	sigsetjmp((x), 1)
+#    undef longjmp
+#    define longjmp(x, n)	siglongjmp((x), (n))
+#  endif /* !__OPENNT */
 #else
 #  define procenv_t	jmp_buf
 #endif
 
 #endif /* _POSIXJMP_H_ */
diff --git a/readline/readline.c b/readline/readline.c
--- a/readline/readline.c
+++ b/readline/readline.c
@@ -3,17 +3,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -42,151 +42,63 @@
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #if defined (HAVE_LOCALE_H)
 #  include <locale.h>
 #endif
 
-#include <signal.h>
 #include <stdio.h>
 #include "posixjmp.h"
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 #if defined (__EMX__)
 #  define INCL_DOSPROCESS
 #  include <os2.h>
 #endif /* __EMX__ */
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+#include "rlshell.h"
+#include "xmalloc.h"
+
 #ifndef RL_LIBRARY_VERSION
-#  define RL_LIBRARY_VERSION "2.1-bash"
+#  define RL_LIBRARY_VERSION "4.2-beta"
 #endif
 
 /* Evaluates its arguments multiple times. */
 #define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
 
-/* NOTE: Functions and variables prefixed with `_rl_' are
-   pseudo-global: they are global so they can be shared
-   between files in the readline library, but are not intended
-   to be visible to readline callers. */
-
-/* Variables and functions imported from terminal.c */
-extern int _rl_init_terminal_io ();
-extern void _rl_enable_meta_key ();
-extern int _rl_output_character_function ();
-extern void _rl_get_screen_size ();
-
-extern int _rl_enable_meta;
-extern int _rl_term_autowrap;
-extern int screenwidth, screenheight, screenchars;
-
-/* Variables and functions imported from rltty.c. */
-extern void rl_prep_terminal (), rl_deprep_terminal ();
-extern void rltty_set_default_bindings ();
-
-/* Functions imported from util.c. */
-extern void _rl_abort_internal ();
-extern void rl_extend_line_buffer ();
-extern int alphabetic ();
-
-/* Functions imported from bind.c. */
-extern void _rl_bind_if_unbound ();
-extern int rl_set_keymap_from_edit_mode ();
-
-/* Functions imported from input.c. */
-extern int _rl_any_typein ();
-extern void _rl_insert_typein ();
-extern int rl_read_key ();
-
-/* Functions imported from nls.c */
-extern int _rl_init_eightbit ();
-
-/* Functions imported from shell.c */
-extern char *get_env_value ();
-
-/* External redisplay functions and variables from display.c */
-extern void _rl_move_vert ();
-extern void _rl_update_final ();
-extern void _rl_clear_to_eol ();
-extern void _rl_clear_screen ();
-
-extern void _rl_save_prompt ();
-extern void _rl_restore_prompt ();
-
-extern void _rl_erase_at_end_of_line ();
-extern void _rl_move_cursor_relative ();
+/* Forward declarations used in this file. */
+void _rl_free_history_entry __P((HIST_ENTRY *));
 
-extern int _rl_vis_botlin;
-extern int _rl_last_c_pos;
-extern int _rl_horizontal_scroll_mode;
-extern int rl_display_fixed;
-extern int _rl_suppress_redisplay;
-extern char *rl_display_prompt;
-
-/* Variables imported from complete.c. */
-extern char *rl_completer_word_break_characters;
-extern char *rl_basic_word_break_characters;
-extern int rl_completion_query_items;
-extern int rl_complete_with_tilde_expansion;
-
-/* Variables and functions from macro.c. */
-extern void _rl_add_macro_char ();
-extern void _rl_with_macro_input ();
-extern int _rl_next_macro_key ();
-extern int _rl_defining_kbd_macro;
+static char *readline_internal __P((void));
+static void readline_initialize_everything __P((void));
+static void start_using_history __P((void));
+static void bind_arrow_keys __P((void));
+static int rl_change_case __P((int, int));
 
-#if defined (VI_MODE)
-/* Functions imported from vi_mode.c. */
-extern void _rl_vi_set_last ();
-extern void _rl_vi_reset_last ();
-extern void _rl_vi_done_inserting ();
-extern int _rl_vi_textmod_command ();
-extern void _rl_vi_initialize_line ();
-#endif /* VI_MODE */
-
-extern UNDO_LIST *rl_undo_list;
-extern int _rl_doing_an_undo;
-
-/* Forward declarations used in this file. */
-void _rl_free_history_entry ();
-
-int _rl_dispatch ();
-int _rl_init_argument ();
-
-static char *readline_internal ();
-static void readline_initialize_everything ();
-static void start_using_history ();
-static void bind_arrow_keys ();
-
-#if !defined (__GO32__)
-static void readline_default_bindings ();
-#endif /* !__GO32__ */
-
-#if defined (__GO32__)
-#  include <go32.h>
-#  include <pc.h>
-#  undef HANDLE_SIGNALS
-#endif /* __GO32__ */
-
-extern char *xmalloc (), *xrealloc ();
+static void readline_default_bindings __P((void));
 
 /* **************************************************************** */
 /*								    */
 /*			Line editing input utility		    */
 /*								    */
 /* **************************************************************** */
 
-char *rl_library_version = RL_LIBRARY_VERSION;
+const char *rl_library_version = RL_LIBRARY_VERSION;
+
+/* True if this is `real' readline as opposed to some stub substitute. */
+int rl_gnu_readline_p = 1;
 
 /* A pointer to the keymap that is currently in use.
    By default, it is the standard emacs keymap. */
 Keymap _rl_keymap = emacs_standard_keymap;
 
 /* The current style of editing. */
 int rl_editing_mode = emacs_mode;
 
@@ -205,70 +117,84 @@ int rl_numeric_arg = 1;
 int rl_explicit_arg = 0;
 
 /* Temporary value used while generating the argument. */
 int rl_arg_sign = 1;
 
 /* Non-zero means we have been called at least once before. */
 static int rl_initialized;
 
+#if 0
 /* If non-zero, this program is running in an EMACS buffer. */
 static int running_in_emacs;
+#endif
+
+/* Flags word encapsulating the current readline state. */
+int rl_readline_state = RL_STATE_NONE;
 
 /* The current offset in the current input line. */
 int rl_point;
 
 /* Mark in the current input line. */
 int rl_mark;
 
 /* Length of the current input line. */
 int rl_end;
 
 /* Make this non-zero to return the current input_line. */
 int rl_done;
 
 /* The last function executed by readline. */
-Function *rl_last_func = (Function *)NULL;
+rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
 
 /* Top level environment for readline_internal (). */
 procenv_t readline_top_level;
 
 /* The streams we interact with. */
 FILE *_rl_in_stream, *_rl_out_stream;
 
 /* The names of the streams that we do input and output to. */
 FILE *rl_instream = (FILE *)NULL;
 FILE *rl_outstream = (FILE *)NULL;
 
 /* Non-zero means echo characters as they are read. */
 int readline_echoing_p = 1;
 
 /* Current prompt. */
-char *rl_prompt;
+char *rl_prompt = (char *)NULL;
 int rl_visible_prompt_length = 0;
 
+/* Set to non-zero by calling application if it has already printed rl_prompt
+   and does not want readline to do it the first time. */
+int rl_already_prompted = 0;
+
 /* The number of characters read in order to type this complete command. */
 int rl_key_sequence_length = 0;
 
 /* If non-zero, then this is the address of a function to call just
-   before readline_internal () prints the first prompt. */
-Function *rl_startup_hook = (Function *)NULL;
+   before readline_internal_setup () prints the first prompt. */
+rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
+
+/* If non-zero, this is the address of a function to call just before
+   readline_internal_setup () returns and readline_internal starts
+   reading input characters. */
+rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
 
 /* What we use internally.  You should always refer to RL_LINE_BUFFER. */
 static char *the_line;
 
 /* The character that can generate an EOF.  Really read from
    the terminal driver... just defaulted here. */
 int _rl_eof_char = CTRL ('D');
 
 /* Non-zero makes this the next keystroke to read. */
 int rl_pending_input = 0;
 
 /* Pointer to a useful terminal name. */
-char *rl_terminal_name = (char *)NULL;
+const char *rl_terminal_name = (const char *)NULL;
 
 /* Non-zero means to always use horizontal scrolling in line display. */
 int _rl_horizontal_scroll_mode = 0;
 
 /* Non-zero means to display an asterisk at the starts of history lines
    which have been modified. */
 int _rl_mark_modified_lines = 0;  
 
@@ -277,16 +203,23 @@ int _rl_mark_modified_lines = 0;
 int _rl_bell_preference = AUDIBLE_BELL;
      
 /* String inserted into the line by rl_insert_comment (). */
 char *_rl_comment_begin;
 
 /* Keymap holding the function currently being executed. */
 Keymap rl_executing_keymap;
 
+/* Non-zero means to erase entire line, including prompt, on empty input lines. */
+int rl_erase_empty_line = 0;
+
+/* Non-zero means to read only this many characters rather than up to a
+   character bound to accept-line. */
+int rl_num_chars_to_read;
+
 /* Line buffer and maintenence. */
 char *rl_line_buffer = (char *)NULL;
 int rl_line_buffer_len = 0;
 
 /* Forward declarations used by the display and termcap code. */
 
 /* **************************************************************** */
 /*								    */
@@ -311,34 +244,47 @@ int _rl_output_meta_chars = 0;
 /*								    */
 /*			Top Level Functions			    */
 /*								    */
 /* **************************************************************** */
 
 /* Non-zero means treat 0200 bit in terminal input as Meta bit. */
 int _rl_meta_flag = 0;	/* Forward declaration */
 
+/* Set up the prompt and expand it.  Called from readline() and
+   rl_callback_handler_install (). */
+int
+rl_set_prompt (prompt)
+     const char *prompt;
+{
+  FREE (rl_prompt);
+  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
+
+  rl_visible_prompt_length = (rl_prompt && *rl_prompt)
+				? rl_expand_prompt (rl_prompt)
+				: 0;
+  return 0;
+}
+  
 /* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
    none.  A return value of NULL means that EOF was encountered. */
 char *
 readline (prompt)
-     char *prompt;
+     const char *prompt;
 {
   char *value;
 
-  rl_prompt = prompt;
-
   /* If we are at EOF return a NULL string. */
   if (rl_pending_input == EOF)
     {
-      rl_pending_input = 0;
+      rl_clear_pending_input ();
       return ((char *)NULL);
     }
 
-  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
+  rl_set_prompt (prompt);
 
   rl_initialize ();
   (*rl_prep_term_function) (_rl_meta_flag);
 
 #if defined (HANDLE_SIGNALS)
   rl_set_signals ();
 #endif
 
@@ -356,39 +302,49 @@ readline (prompt)
 #  define STATIC_CALLBACK
 #else
 #  define STATIC_CALLBACK static
 #endif
 
 STATIC_CALLBACK void
 readline_internal_setup ()
 {
+  char *nprompt;
+
   _rl_in_stream = rl_instream;
   _rl_out_stream = rl_outstream;
 
   if (rl_startup_hook)
     (*rl_startup_hook) ();
 
   if (readline_echoing_p == 0)
     {
-      if (rl_prompt)
+      if (rl_prompt && rl_already_prompted == 0)
 	{
-	  fprintf (_rl_out_stream, "%s", rl_prompt);
+	  nprompt = _rl_strip_prompt (rl_prompt);
+	  fprintf (_rl_out_stream, "%s", nprompt);
 	  fflush (_rl_out_stream);
+	  free (nprompt);
 	}
     }
   else
     {
-      rl_on_new_line ();
+      if (rl_prompt && rl_already_prompted)
+	rl_on_new_line_with_prompt ();
+      else
+	rl_on_new_line ();
       (*rl_redisplay_function) ();
 #if defined (VI_MODE)
       if (rl_editing_mode == vi_mode)
 	rl_vi_insertion_mode (1, 0);
 #endif /* VI_MODE */
     }
+
+  if (rl_pre_input_hook)
+    (*rl_pre_input_hook) ();
 }
 
 STATIC_CALLBACK char *
 readline_internal_teardown (eof)
      int eof;
 {
   char *temp;
   HIST_ENTRY *entry;
@@ -396,27 +352,27 @@ readline_internal_teardown (eof)
   /* Restore the original of this history line, iff the line that we
      are editing was originally in the history, AND the line has changed. */
   entry = current_history ();
 
   if (entry && rl_undo_list)
     {
       temp = savestring (the_line);
       rl_revert_line (1, 0);
-      entry = replace_history_entry (where_history (), the_line, (HIST_ENTRY *)NULL);
+      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
       _rl_free_history_entry (entry);
 
       strcpy (the_line, temp);
       free (temp);
     }
 
   /* At any rate, it is highly likely that this line has an undo list.  Get
      rid of it now. */
   if (rl_undo_list)
-    free_undo_list ();
+    rl_free_undo_list ();
 
   return (eof ? (char *)NULL : savestring (the_line));
 }
 
 STATIC_CALLBACK int
 #if defined (READLINE_CALLBACKS)
 readline_internal_char ()
 #else
@@ -442,67 +398,82 @@ readline_internal_charloop ()
 
       if (rl_pending_input == 0)
 	{
 	  /* Then initialize the argument and number of keys read. */
 	  _rl_init_argument ();
 	  rl_key_sequence_length = 0;
 	}
 
+      RL_SETSTATE(RL_STATE_READCMD);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_READCMD);
 
       /* EOF typed to a non-blank line is a <NL>. */
       if (c == EOF && rl_end)
 	c = NEWLINE;
 
       /* The character _rl_eof_char typed to blank line, and not as the
 	 previous character is interpreted as EOF. */
       if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
 	{
 #if defined (READLINE_CALLBACKS)
+	  RL_SETSTATE(RL_STATE_DONE);
 	  return (rl_done = 1);
 #else
 	  eof_found = 1;
 	  break;
 #endif
 	}
 
       lastc = c;
-      _rl_dispatch (c, _rl_keymap);
+      _rl_dispatch ((unsigned char)c, _rl_keymap);
 
       /* If there was no change in _rl_last_command_was_kill, then no kill
 	 has taken place.  Note that if input is pending we are reading
 	 a prefix command, so nothing has changed yet. */
       if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)
 	_rl_last_command_was_kill = 0;
 
 #if defined (VI_MODE)
       /* In vi mode, when you exit insert mode, the cursor moves back
 	 over the previous character.  We explicitly check for that here. */
       if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
 	rl_vi_check ();
 #endif /* VI_MODE */
 
+      if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
+        {
+          (*rl_redisplay_function) ();
+          rl_newline (1, '\n');
+        }
+
       if (rl_done == 0)
 	(*rl_redisplay_function) ();
 
+      /* If the application writer has told us to erase the entire line if
+	  the only character typed was something bound to rl_newline, do so. */
+      if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
+	  rl_point == 0 && rl_end == 0)
+	_rl_erase_entire_line ();
+
 #if defined (READLINE_CALLBACKS)
       return 0;
 #else
     }
 
   return (eof_found);
 #endif
 }
 
 #if defined (READLINE_CALLBACKS)
 static int
 readline_internal_charloop ()
 {
-  int eof;
+  int eof = 1;
 
   while (rl_done == 0)
     eof = readline_internal_char ();
   return (eof);
 }
 #endif /* READLINE_CALLBACKS */
 
 /* Read a line of input from the global rl_instream, doing output on
@@ -537,87 +508,97 @@ void
    another key, and dispatch into that map. */
 int
 _rl_dispatch (key, map)
      register int key;
      Keymap map;
 {
   int r, newkey;
   char *macro;
-  Function *func;
+  rl_command_func_t *func;
 
   if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
     {
       if (map[ESC].type == ISKMAP)
 	{
 	  if (_rl_defining_kbd_macro)
 	    _rl_add_macro_char (ESC);
 	  map = FUNCTION_TO_KEYMAP (map, ESC);
 	  key = UNMETA (key);
 	  rl_key_sequence_length += 2;
 	  return (_rl_dispatch (key, map));
 	}
       else
-	ding ();
+	rl_ding ();
       return 0;
     }
 
   if (_rl_defining_kbd_macro)
     _rl_add_macro_char (key);
 
   r = 0;
   switch (map[key].type)
     {
     case ISFUNC:
       func = map[key].function;
-      if (func != (Function *)NULL)
+      if (func)
 	{
 	  /* Special case rl_do_lowercase_version (). */
 	  if (func == rl_do_lowercase_version)
 	    return (_rl_dispatch (_rl_to_lower (key), map));
 
 	  rl_executing_keymap = map;
 
 #if 0
 	  _rl_suppress_redisplay = (map[key].function == rl_insert) && _rl_input_available ();
 #endif
 
 	  rl_dispatching = 1;
+	  RL_SETSTATE(RL_STATE_DISPATCHING);
 	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
 	  rl_dispatching = 0;
 
 	  /* If we have input pending, then the last command was a prefix
 	     command.  Don't change the state of rl_last_func.  Otherwise,
 	     remember the last command executed in this variable. */
-	  if (!rl_pending_input && map[key].function != rl_digit_argument)
+	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
 	    rl_last_func = map[key].function;
 	}
       else
 	{
 	  _rl_abort_internal ();
 	  return -1;
 	}
       break;
 
     case ISKMAP:
-      if (map[key].function != (Function *)NULL)
+      if (map[key].function != 0)
 	{
 	  rl_key_sequence_length++;
+
+	  if (key == ESC)
+	    RL_SETSTATE(RL_STATE_METANEXT);
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  newkey = rl_read_key ();
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	  if (key == ESC)
+	    RL_UNSETSTATE(RL_STATE_METANEXT);
+
 	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
 	}
       else
 	{
 	  _rl_abort_internal ();
 	  return -1;
 	}
       break;
 
     case ISMACR:
-      if (map[key].function != (Function *)NULL)
+      if (map[key].function != 0)
 	{
 	  macro = savestring ((char *)map[key].function);
 	  _rl_with_macro_input (macro);
 	  return 0;
 	}
       break;
     }
 #if defined (VI_MODE)
@@ -637,46 +618,51 @@ int
 /* Initialize readline (and terminal if not already). */
 int
 rl_initialize ()
 {
   /* If we have never been called before, initialize the
      terminal and data structures. */
   if (!rl_initialized)
     {
+      RL_SETSTATE(RL_STATE_INITIALIZING);
       readline_initialize_everything ();
+      RL_UNSETSTATE(RL_STATE_INITIALIZING);
       rl_initialized++;
+      RL_SETSTATE(RL_STATE_INITIALIZED);
     }
 
   /* Initalize the current line information. */
   _rl_init_line_state ();
 
   /* We aren't done yet.  We haven't even gotten started yet! */
   rl_done = 0;
+  RL_UNSETSTATE(RL_STATE_DONE);
 
   /* Tell the history routines what is going on. */
   start_using_history ();
 
   /* Make the display buffer match the state of the line. */
   rl_reset_line_state ();
 
   /* No such function typed yet. */
-  rl_last_func = (Function *)NULL;
+  rl_last_func = (rl_command_func_t *)NULL;
 
   /* Parsing of key-bindings begins in an enabled state. */
   _rl_parsing_conditionalized_out = 0;
 
 #if defined (VI_MODE)
   if (rl_editing_mode == vi_mode)
     _rl_vi_initialize_line ();
 #endif
 
   return 0;
 }
 
+#if 0
 #if defined (__EMX__)
 static void
 _emx_build_environ ()
 {
   TIB *tibp;
   PIB *pibp;
   char *t, **tp;
   int c;
@@ -690,28 +676,33 @@ static void
   while (*t)
     {
       *tp++ = t;
       t += strlen (t) + 1;
     }
   *tp = 0;
 }
 #endif /* __EMX__ */
+#endif
 
 /* Initialize the entire state of the world. */
 static void
 readline_initialize_everything ()
 {
+#if 0
 #if defined (__EMX__)
   if (environ == 0)
     _emx_build_environ ();
 #endif
+#endif
 
-  /* Find out if we are running in Emacs. */
-  running_in_emacs = get_env_value ("EMACS") != (char *)0;
+#if 0
+  /* Find out if we are running in Emacs -- UNUSED. */
+  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
+#endif
 
   /* Set up input and output if they are not already set up. */
   if (!rl_instream)
     rl_instream = stdin;
 
   if (!rl_outstream)
     rl_outstream = stdout;
 
@@ -721,37 +712,37 @@ readline_initialize_everything ()
   _rl_in_stream = rl_instream;
   _rl_out_stream = rl_outstream;
 
   /* Allocate data structures. */
   if (rl_line_buffer == 0)
     rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
 
   /* Initialize the terminal interface. */
-  _rl_init_terminal_io ((char *)NULL);
+  if (rl_terminal_name == 0)
+    rl_terminal_name = sh_get_env_value ("TERM");
+  _rl_init_terminal_io (rl_terminal_name);
 
-#if !defined (__GO32__)
   /* Bind tty characters to readline functions. */
   readline_default_bindings ();
-#endif /* !__GO32__ */
 
   /* Initialize the function names. */
   rl_initialize_funmap ();
 
   /* Decide whether we should automatically go into eight-bit mode. */
   _rl_init_eightbit ();
       
   /* Read in the init file. */
   rl_read_init_file ((char *)NULL);
 
   /* XXX */
   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
     {
-      screenwidth--;
-      screenchars -= screenheight;
+      _rl_screenwidth--;
+      _rl_screenchars -= _rl_screenheight;
     }
 
   /* Override the effect of any `set keymap' assignments in the
      inputrc file. */
   rl_set_keymap_from_edit_mode ();
 
   /* Try to bind a common arrow key prefix, if not already bound. */
   bind_arrow_keys ();
@@ -767,24 +758,35 @@ readline_initialize_everything ()
 }
 
 /* If this system allows us to look at the values of the regular
    input editing characters, then bind them to their readline
    equivalents, iff the characters are not bound to keymaps. */
 static void
 readline_default_bindings ()
 {
-  rltty_set_default_bindings (_rl_keymap);
+  rl_tty_set_default_bindings (_rl_keymap);
 }
 
 static void
 bind_arrow_keys_internal ()
 {
-  Function *f;
+  rl_command_func_t *f;
 
+#if defined (__MSDOS__)
+  f = rl_function_of_keyseq ("\033[0A", _rl_keymap, (int *)NULL);
+  if (!f || f == rl_do_lowercase_version)
+    {
+       _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
+       _rl_bind_if_unbound ("\033[0B", rl_backward);
+       _rl_bind_if_unbound ("\033[0C", rl_forward);
+       _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
+    }
+#endif
+	
   f = rl_function_of_keyseq ("\033[A", _rl_keymap, (int *)NULL);
   if (!f || f == rl_do_lowercase_version)
     {
       _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
       _rl_bind_if_unbound ("\033[B", rl_get_next_history);
       _rl_bind_if_unbound ("\033[C", rl_forward);
       _rl_bind_if_unbound ("\033[D", rl_backward);
     }
@@ -828,39 +830,54 @@ bind_arrow_keys ()
 /* **************************************************************** */
 
 /* Handle C-u style numeric args, as well as M--, and M-digits. */
 static int
 rl_digit_loop ()
 {
   int key, c, sawminus, sawdigits;
 
-  _rl_save_prompt ();
+  rl_save_prompt ();
 
+  RL_SETSTATE(RL_STATE_NUMERICARG);
   sawminus = sawdigits = 0;
   while (1)
     {
+      if (rl_numeric_arg > 1000000)
+	{
+	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
+	  rl_ding ();
+	  rl_restore_prompt ();
+	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
+	  return 1;
+	}
       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       key = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       /* If we see a key bound to `universal-argument' after seeing digits,
 	 it ends the argument but is otherwise ignored. */
       if (_rl_keymap[c].type == ISFUNC &&
 	  _rl_keymap[c].function == rl_universal_argument)
 	{
 	  if (sawdigits == 0)
 	    {
 	      rl_numeric_arg *= 4;
 	      continue;
 	    }
 	  else
 	    {
+	      RL_SETSTATE(RL_STATE_MOREINPUT);
 	      key = rl_read_key ();
-	      _rl_restore_prompt ();
+	      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	      rl_restore_prompt ();
 	      rl_clear_message ();
+	      RL_UNSETSTATE(RL_STATE_NUMERICARG);
 	      return (_rl_dispatch (key, _rl_keymap));
 	    }
 	}
 
       c = UNMETA (c);
 
       if (_rl_digit_p (c))
 	{
@@ -872,39 +889,41 @@ rl_digit_loop ()
 	  rl_numeric_arg = sawminus = 1;
 	  rl_arg_sign = -1;
 	}
       else
 	{
 	  /* Make M-- command equivalent to M--1 command. */
 	  if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
 	    rl_explicit_arg = 1;
-	  _rl_restore_prompt ();
+	  rl_restore_prompt ();
 	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
 	  return (_rl_dispatch (key, _rl_keymap));
 	}
     }
 
+  RL_UNSETSTATE(RL_STATE_NUMERICARG);
   return 0;
 }
 
 /* Add the current digit to the argument in progress. */
 int
 rl_digit_argument (ignore, key)
      int ignore, key;
 {
-  rl_pending_input = key;
+  rl_execute_next (key);
   return (rl_digit_loop ());
 }
 
 /* What to do when you abort reading an argument. */
 int
 rl_discard_argument ()
 {
-  ding ();
+  rl_ding ();
   rl_clear_message ();
   _rl_init_argument ();
   return 0;
 }
 
 /* Create a default argument. */
 int
 _rl_init_argument ()
@@ -931,17 +950,17 @@ rl_universal_argument (count, key)
 /*								    */
 /* **************************************************************** */
 
 /* Insert a string of text into the line at point.  This is the only
    way that you should do insertion.  rl_insert () calls this
    function. */
 int
 rl_insert_text (string)
-     char *string;
+     const char *string;
 {
   register int i, l = strlen (string);
 
   if (rl_end + l >= rl_line_buffer_len)
     rl_extend_line_buffer (rl_end + l);
 
   for (i = rl_end; i >= rl_point; i--)
     the_line[i + l] = the_line[i];
@@ -1022,16 +1041,28 @@ void
      int fix_mark_too;
 {
   _RL_FIX_POINT (rl_point);
   if (fix_mark_too)
     _RL_FIX_POINT (rl_mark);
 }
 #undef _RL_FIX_POINT
 
+void
+_rl_replace_text (text, start, end)
+     const char *text;
+     int start, end;
+{
+  rl_begin_undo_group ();
+  rl_delete_text (start, end + 1);
+  rl_point = start;
+  rl_insert_text (text);
+  rl_end_undo_group ();
+}
+
 /* **************************************************************** */
 /*								    */
 /*			Readline character functions		    */
 /*								    */
 /* **************************************************************** */
 
 /* This is not a gap editor, just a stupid line input routine.  No hair
    is involved in writing any of the functions, and none should be. */
@@ -1066,45 +1097,49 @@ rl_forward (count, key)
      int count, key;
 {
   if (count < 0)
     rl_backward (-count, key);
   else if (count > 0)
     {
       int end = rl_point + count;
 #if defined (VI_MODE)
-      int lend = rl_end - (rl_editing_mode == vi_mode);
+      int lend = rl_end > 0 ? rl_end - (rl_editing_mode == vi_mode) : rl_end;
 #else
       int lend = rl_end;
 #endif
 
       if (end > lend)
 	{
 	  rl_point = lend;
-	  ding ();
+	  rl_ding ();
 	}
       else
 	rl_point = end;
     }
+
+  if (rl_end < 0)
+    rl_end = 0;
+
   return 0;
 }
 
 /* Move backward COUNT characters. */
 int
 rl_backward (count, key)
      int count, key;
 {
   if (count < 0)
     rl_forward (-count, key);
   else if (count > 0)
     {
       if (rl_point < count)
 	{
 	  rl_point = 0;
-	  ding ();
+	  rl_ding ();
 	}
       else
         rl_point -= count;
     }
   return 0;
 }
 
 /* Move to the beginning of the line. */
@@ -1141,31 +1176,31 @@ rl_forward_word (count, key)
   while (count)
     {
       if (rl_point == rl_end)
 	return 0;
 
       /* If we are not in a word, move forward until we are in one.
 	 Then, move forward until we hit a non-alphabetic character. */
       c = the_line[rl_point];
-      if (alphabetic (c) == 0)
+      if (rl_alphabetic (c) == 0)
 	{
 	  while (++rl_point < rl_end)
 	    {
 	      c = the_line[rl_point];
-	      if (alphabetic (c))
+	      if (rl_alphabetic (c))
 		break;
 	    }
 	}
       if (rl_point == rl_end)
 	return 0;
       while (++rl_point < rl_end)
 	{
 	  c = the_line[rl_point];
-	  if (alphabetic (c) == 0)
+	  if (rl_alphabetic (c) == 0)
 	    break;
 	}
       --count;
     }
   return 0;
 }
 
 /* Move backward a word.  We do what Emacs does. */
@@ -1185,106 +1220,88 @@ rl_backward_word (count, key)
     {
       if (!rl_point)
 	return 0;
 
       /* Like rl_forward_word (), except that we look at the characters
 	 just before point. */
 
       c = the_line[rl_point - 1];
-      if (alphabetic (c) == 0)
+      if (rl_alphabetic (c) == 0)
 	{
 	  while (--rl_point)
 	    {
 	      c = the_line[rl_point - 1];
-	      if (alphabetic (c))
+	      if (rl_alphabetic (c))
 		break;
 	    }
 	}
 
       while (rl_point)
 	{
 	  c = the_line[rl_point - 1];
-	  if (alphabetic (c) == 0)
+	  if (rl_alphabetic (c) == 0)
 	    break;
 	  else
 	    --rl_point;
 	}
       --count;
     }
   return 0;
 }
 
 /* Clear the current line.  Numeric argument to C-l does this. */
 int
-rl_refresh_line ()
+rl_refresh_line (ignore1, ignore2)
+     int ignore1, ignore2;
 {
-  int curr_line, nleft;
+  int curr_line;
 
-  /* Find out whether or not there might be invisible characters in the
-     editing buffer. */
-  if (rl_display_prompt == rl_prompt)
-    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
-  else
-    nleft = _rl_last_c_pos - screenwidth;
-
-  if (nleft > 0)
-    curr_line = 1 + nleft / screenwidth;
-  else
-    curr_line = 0;
+  curr_line = _rl_current_display_line ();
 
   _rl_move_vert (curr_line);
   _rl_move_cursor_relative (0, the_line);   /* XXX is this right */
 
-#if defined (__GO32__)
-  {
-    int row, col, width, row_start;
-
-    ScreenGetCursor (&row, &col);
-    width = ScreenCols ();
-    row_start = ScreenPrimary + (row * width);
-    memset (row_start + col, 0, (width - col) * 2);
-  }
-#else /* !__GO32__ */
   _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */
-#endif /* !__GO32__ */
 
   rl_forced_update_display ();
   rl_display_fixed = 1;
 
   return 0;
 }
 
 /* C-l typed to a line without quoting clears the screen, and then reprints
    the prompt and the current input line.  Given a numeric arg, redraw only
    the current line. */
 int
 rl_clear_screen (count, key)
      int count, key;
 {
   if (rl_explicit_arg)
     {
-      rl_refresh_line ();
+      rl_refresh_line (count, key);
       return 0;
     }
 
   _rl_clear_screen ();		/* calls termcap function to clear screen */
   rl_forced_update_display ();
   rl_display_fixed = 1;
 
   return 0;
 }
 
 int
 rl_arrow_keys (count, c)
      int count, c;
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
   switch (_rl_to_upper (ch))
     {
     case 'A':
       rl_get_previous_history (count, ch);
       break;
 
     case 'B':
@@ -1295,17 +1312,17 @@ rl_arrow_keys (count, c)
       rl_forward (count, ch);
       break;
 
     case 'D':
       rl_backward (count, ch);
       break;
 
     default:
-      ding ();
+      rl_ding ();
     }
   return 0;
 }
 
 
 /* **************************************************************** */
 /*								    */
 /*			Text commands				    */
@@ -1378,17 +1395,28 @@ rl_insert (count, c)
 
 /* Insert the next typed character verbatim. */
 int
 rl_quoted_insert (count, key)
      int count, key;
 {
   int c;
 
+#if defined (HANDLE_SIGNALS)
+  _rl_disable_tty_signals ();
+#endif
+
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
+#if defined (HANDLE_SIGNALS)
+  _rl_restore_tty_signals ();
+#endif
+
   return (rl_insert (count, c));  
 }
 
 /* Insert a tab character. */
 int
 rl_tab_insert (count, key)
      int count, key;
 {
@@ -1398,25 +1426,31 @@ rl_tab_insert (count, key)
 /* What to do when a NEWLINE is pressed.  We accept the whole line.
    KEY is the key that invoked this command.  I guess it could have
    meaning in the future. */
 int
 rl_newline (count, key)
      int count, key;
 {
   rl_done = 1;
+  RL_SETSTATE(RL_STATE_DONE);
 
 #if defined (VI_MODE)
   if (rl_editing_mode == vi_mode)
     {
       _rl_vi_done_inserting ();
       _rl_vi_reset_last ();
     }
 #endif /* VI_MODE */
 
+  /* If we've been asked to erase empty lines, suppress the final update,
+     since _rl_update_final calls rl_crlf(). */
+  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
+    return 0;
+
   if (readline_echoing_p)
     _rl_update_final ();
   return 0;
 }
 
 /* What to do for some uppercase characters, like meta characters,
    and some characters appearing in emacs_ctlx_keymap.  This function
    is just a stub, you bind keys to it and the code in _rl_dispatch ()
@@ -1436,17 +1470,17 @@ rl_rubout (count, key)
   if (count < 0)
     {
       rl_delete (-count, key);
       return 0;
     }
 
   if (!rl_point)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
       rl_backward (count, key);
       rl_kill_text (orig_point, rl_point);
@@ -1472,33 +1506,46 @@ int
 rl_delete (count, key)
      int count, key;
 {
   if (count < 0)
     return (rl_rubout (-count, key));
 
   if (rl_point == rl_end)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
       rl_forward (count, key);
       rl_kill_text (orig_point, rl_point);
       rl_point = orig_point;
       return 0;
     }
   else
     return (rl_delete_text (rl_point, rl_point + 1));
-  
 }
 
+/* Delete the character under the cursor, unless the insertion
+   point is at the end of the line, in which case the character
+   behind the cursor is deleted.  COUNT is obeyed and may be used
+   to delete forward or backward that many characters. */      
+int
+rl_rubout_or_delete (count, key)
+     int count, key;
+{
+  if (rl_end != 0 && rl_point == rl_end)
+    return (rl_rubout (count, key));
+  else
+    return (rl_delete (count, key));
+}  
+
 /* Delete all spaces and tabs around point. */
 int
 rl_delete_horizontal_space (count, ignore)
      int count, ignore;
 {
   int start = rl_point;
 
   while (rl_point && whitespace (the_line[rl_point - 1]))
@@ -1512,16 +1559,29 @@ rl_delete_horizontal_space (count, ignor
   if (start != rl_point)
     {
       rl_delete_text (start, rl_point);
       rl_point = start;
     }
   return 0;
 }
 
+/* Like the tcsh editing function delete-char-or-list.  The eof character
+   is caught before this is invoked, so this really does the same thing as
+   delete-char-or-list-or-eof, as long as it's bound to the eof character. */
+int
+rl_delete_or_show_completions (count, key)
+     int count, key;
+{
+  if (rl_end != 0 && rl_point == rl_end)
+    return (rl_possible_completions (count, key));
+  else
+    return (rl_delete (count, key));
+}
+
 #ifndef RL_COMMENT_BEGIN_DEFAULT
 #define RL_COMMENT_BEGIN_DEFAULT "#"
 #endif
 
 /* Turn the current line into a comment in shell history.
    A K*rn shell style function. */
 int
 rl_insert_comment (count, key)
@@ -1541,18 +1601,16 @@ rl_insert_comment (count, key)
 /*								    */
 /* **************************************************************** */
 
 /* The three kinds of things that we know how to do. */
 #define UpCase 1
 #define DownCase 2
 #define CapCase 3
 
-static int rl_change_case ();
-
 /* Uppercase the word at point. */
 int
 rl_upcase_word (count, key)
      int count, key;
 {
   return (rl_change_case (count, UpCase));
 }
 
@@ -1604,21 +1662,21 @@ rl_change_case (count, op)
 	  break;
 
 	case DownCase:
 	  the_line[start] = _rl_to_lower (c);
 	  break;
 
 	case CapCase:
 	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
-	  inword = alphabetic (the_line[start]);
+	  inword = rl_alphabetic (the_line[start]);
 	  break;
 
 	default:
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
     }
   rl_point = end;
   return 0;
 }
 
 /* **************************************************************** */
@@ -1647,17 +1705,17 @@ rl_transpose_words (count, key)
   rl_backward_word (count, key);
   w1_beg = rl_point;
   rl_forward_word (1, key);
   w1_end = rl_point;
 
   /* Do some check to make sure that there really are two words. */
   if ((w1_beg == w2_beg) || (w2_beg < w1_end))
     {
-      ding ();
+      rl_ding ();
       rl_point = orig_point;
       return -1;
     }
 
   /* Get the text of the words. */
   word1 = rl_copy_text (w1_beg, w1_end);
   word2 = rl_copy_text (w2_beg, w2_end);
 
@@ -1695,17 +1753,17 @@ rl_transpose_chars (count, key)
 {
   char dummy[2];
 
   if (!count)
     return 0;
 
   if (!rl_point || rl_end < 2)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   rl_begin_undo_group ();
 
   if (rl_point == rl_end)
     {
       --rl_point;
@@ -1739,17 +1797,17 @@ int
   int pos, inc;
 
   pos = rl_point;
   inc = (dir < 0) ? -1 : 1;
   while (count)
     {
       if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
 	{
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
 
       pos += inc;
       do
 	{
 	  if (rl_line_buffer[pos] == schar)
 	    {
@@ -1770,17 +1828,20 @@ int
    FDIR is the direction to search if COUNT is non-negative; otherwise
    the search goes in BDIR. */
 static int
 _rl_char_search (count, fdir, bdir)
      int count, fdir, bdir;
 {
   int c;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (count < 0)
     return (_rl_char_search_internal (-count, bdir, c));
   else
     return (_rl_char_search_internal (count, fdir, c));
 }
 
 int
 rl_char_search (count, key)
@@ -1803,95 +1864,106 @@ rl_backward_char_search (count, key)
 /* **************************************************************** */
 
 /* We already have a history library, and that is what we use to control
    the history features of readline.  This is our local interface to
    the history mechanism. */
 
 /* While we are editing the history, this is the saved
    version of the original line. */
-HIST_ENTRY *saved_line_for_history = (HIST_ENTRY *)NULL;
+HIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;
 
 /* Set the history pointer back to the last entry in the history. */
 static void
 start_using_history ()
 {
   using_history ();
-  if (saved_line_for_history)
-    _rl_free_history_entry (saved_line_for_history);
+  if (_rl_saved_line_for_history)
+    _rl_free_history_entry (_rl_saved_line_for_history);
 
-  saved_line_for_history = (HIST_ENTRY *)NULL;
+  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
 }
 
 /* Free the contents (and containing structure) of a HIST_ENTRY. */
 void
 _rl_free_history_entry (entry)
      HIST_ENTRY *entry;
 {
   if (entry == 0)
     return;
   if (entry->line)
     free (entry->line);
   free (entry);
 }
 
 /* Perhaps put back the current line if it has changed. */
 int
-maybe_replace_line ()
+rl_maybe_replace_line ()
 {
   HIST_ENTRY *temp;
 
   temp = current_history ();
   /* If the current line has changed, save the changes. */
   if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))
     {
-      temp = replace_history_entry (where_history (), the_line, rl_undo_list);
+      temp = replace_history_entry (where_history (), the_line, (histdata_t)rl_undo_list);
       free (temp->line);
       free (temp);
     }
   return 0;
 }
 
-/* Put back the saved_line_for_history if there is one. */
+/* Restore the _rl_saved_line_for_history if there is one. */
 int
-maybe_unsave_line ()
+rl_maybe_unsave_line ()
 {
   int line_len;
 
-  if (saved_line_for_history)
+  if (_rl_saved_line_for_history)
     {
-      line_len = strlen (saved_line_for_history->line);
+      line_len = strlen (_rl_saved_line_for_history->line);
 
       if (line_len >= rl_line_buffer_len)
 	rl_extend_line_buffer (line_len);
 
-      strcpy (the_line, saved_line_for_history->line);
-      rl_undo_list = (UNDO_LIST *)saved_line_for_history->data;
-      _rl_free_history_entry (saved_line_for_history);
-      saved_line_for_history = (HIST_ENTRY *)NULL;
+      strcpy (the_line, _rl_saved_line_for_history->line);
+      rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;
+      _rl_free_history_entry (_rl_saved_line_for_history);
+      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
       rl_end = rl_point = strlen (the_line);
     }
   else
-    ding ();
+    rl_ding ();
   return 0;
 }
 
-/* Save the current line in saved_line_for_history. */
+/* Save the current line in _rl_saved_line_for_history. */
 int
-maybe_save_line ()
+rl_maybe_save_line ()
 {
-  if (saved_line_for_history == 0)
+  if (_rl_saved_line_for_history == 0)
     {
-      saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-      saved_line_for_history->line = savestring (the_line);
-      saved_line_for_history->data = (char *)rl_undo_list;
+      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
+      _rl_saved_line_for_history->line = savestring (the_line);
+      _rl_saved_line_for_history->data = (char *)rl_undo_list;
     }
   return 0;
 }
 
+int
+_rl_free_saved_history_line ()
+{
+  if (_rl_saved_line_for_history)
+    {
+      _rl_free_history_entry (_rl_saved_line_for_history);
+      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
+    }
+  return 0;
+}      
+
 /* **************************************************************** */
 /*								    */
 /*			History Commands			    */
 /*								    */
 /* **************************************************************** */
 
 /* Meta-< goes to the start of the history. */
 int
@@ -1901,19 +1973,19 @@ rl_beginning_of_history (count, key)
   return (rl_get_previous_history (1 + where_history (), key));
 }
 
 /* Meta-> goes to the end of the history.  (The current line). */
 int
 rl_end_of_history (count, key)
      int count, key;
 {
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
   using_history ();
-  maybe_unsave_line ();
+  rl_maybe_unsave_line ();
   return 0;
 }
 
 /* Move down to the next history line. */
 int
 rl_get_next_history (count, key)
      int count, key;
 {
@@ -1921,29 +1993,29 @@ rl_get_next_history (count, key)
   int line_len;
 
   if (count < 0)
     return (rl_get_previous_history (-count, key));
 
   if (count == 0)
     return 0;
 
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
 
   temp = (HIST_ENTRY *)NULL;
   while (count)
     {
       temp = next_history ();
       if (!temp)
 	break;
       --count;
     }
 
   if (temp == 0)
-    maybe_unsave_line ();
+    rl_maybe_unsave_line ();
   else
     {
       line_len = strlen (temp->line);
 
       if (line_len >= rl_line_buffer_len)
 	rl_extend_line_buffer (line_len);
 
       strcpy (the_line, temp->line);
@@ -1968,20 +2040,20 @@ rl_get_previous_history (count, key)
 
   if (count < 0)
     return (rl_get_next_history (-count, key));
 
   if (count == 0)
     return 0;
 
   /* If we don't have a line saved, then save this one. */
-  maybe_save_line ();
+  rl_maybe_save_line ();
 
   /* If the current line has changed, save the changes. */
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
 
   temp = old_temp = (HIST_ENTRY *)NULL;
   while (count)
     {
       temp = previous_history ();
       if (temp == 0)
 	break;
 
@@ -1990,17 +2062,17 @@ rl_get_previous_history (count, key)
     }
 
   /* If there was a large argument, and we moved back to the start of the
      history, that is not an error.  So use the last value found. */
   if (!temp && old_temp)
     temp = old_temp;
 
   if (temp == 0)
-    ding ();
+    rl_ding ();
   else
     {
       line_len = strlen (temp->line);
 
       if (line_len >= rl_line_buffer_len)
 	rl_extend_line_buffer (line_len);
 
       strcpy (the_line, temp->line);
@@ -2046,17 +2118,17 @@ int
 rl_exchange_point_and_mark (count, key)
      int count, key;
 {
   if (rl_mark > rl_end)
     rl_mark = -1;
 
   if (rl_mark == -1)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   else
     SWAP (rl_point, rl_mark);
 
   return 0;
 }
 
diff --git a/readline/readline.h b/readline/readline.h
--- a/readline/readline.h
+++ b/readline/readline.h
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -23,19 +23,21 @@
 #if !defined (_READLINE_H_)
 #define _READLINE_H_
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #if defined (READLINE_LIBRARY)
+#  include "rlstdc.h"
 #  include "keymaps.h"
 #  include "tilde.h"
 #else
+#  include <readline/rlstdc.h>
 #  include <readline/keymaps.h>
 #  include <readline/tilde.h>
 #endif
 
 /* Readline data structures. */
 
 /* Maintaining the state of undo.  We remember individual deletes and inserts
    on a chain of things to do. */
@@ -53,328 +55,603 @@ typedef struct undo_list {
   enum undo_code what;		/* Delete, Insert, Begin, End. */
 } UNDO_LIST;
 
 /* The current undo list for RL_LINE_BUFFER. */
 extern UNDO_LIST *rl_undo_list;
 
 /* The data structure for mapping textual names to code addresses. */
 typedef struct _funmap {
-  char *name;
-  Function *function;
+  const char *name;
+  rl_command_func_t *function;
 } FUNMAP;
 
 extern FUNMAP **funmap;
 
-/* Functions available to bind to key sequences. */
-extern int
-  rl_tilde_expand (), rl_set_mark (), rl_exchange_point_and_mark (),
-  rl_beg_of_line (), rl_backward (), rl_delete (), rl_end_of_line (),
-  rl_forward (), ding (), rl_newline (), rl_kill_line (),
-  rl_copy_region_to_kill (), rl_kill_region (), rl_char_search (),
-  rl_clear_screen (), rl_get_next_history (), rl_get_previous_history (),
-  rl_quoted_insert (), rl_reverse_search_history (), rl_transpose_chars (),
-  rl_unix_line_discard (), rl_unix_word_rubout (),
-  rl_yank (), rl_rubout (), rl_backward_word (), rl_kill_word (),
-  rl_forward_word (), rl_tab_insert (), rl_yank_pop (), rl_yank_nth_arg (),
-  rl_backward_kill_word (), rl_backward_kill_line (), rl_transpose_words (),
-  rl_complete (), rl_possible_completions (), rl_insert_completions (),
-  rl_do_lowercase_version (), rl_kill_full_line (),
-  rl_digit_argument (), rl_universal_argument (), rl_abort (),
-  rl_undo_command (), rl_revert_line (), rl_beginning_of_history (),
-  rl_end_of_history (), rl_forward_search_history (), rl_insert (),
-  rl_upcase_word (), rl_downcase_word (), rl_capitalize_word (),
-  rl_restart_output (), rl_re_read_init_file (),
-  rl_dump_functions (), rl_dump_variables (), rl_dump_macros (),
-  rl_delete_horizontal_space (), rl_history_search_forward (),
-  rl_history_search_backward (), rl_tty_status (), rl_yank_last_arg (),
-  rl_insert_comment (), rl_backward_char_search (),
-  rl_copy_forward_word (), rl_copy_backward_word ();
+/* **************************************************************** */
+/*								    */
+/*	     Functions available to bind to key sequences	    */
+/*								    */
+/* **************************************************************** */
+
+/* Bindable commands for numeric arguments. */
+extern int rl_digit_argument __P((int, int));
+extern int rl_universal_argument __P((int, int));
+
+/* Bindable commands for moving the cursor. */
+extern int rl_forward __P((int, int));
+extern int rl_backward __P((int, int));
+extern int rl_beg_of_line __P((int, int));
+extern int rl_end_of_line __P((int, int));
+extern int rl_forward_word __P((int, int));
+extern int rl_backward_word __P((int, int));
+extern int rl_refresh_line __P((int, int));
+extern int rl_clear_screen __P((int, int));
+extern int rl_arrow_keys __P((int, int));
+
+/* Bindable commands for inserting and deleting text. */
+extern int rl_insert __P((int, int));
+extern int rl_quoted_insert __P((int, int));
+extern int rl_tab_insert __P((int, int));
+extern int rl_newline __P((int, int));
+extern int rl_do_lowercase_version __P((int, int));
+extern int rl_rubout __P((int, int));
+extern int rl_delete __P((int, int));
+extern int rl_rubout_or_delete __P((int, int));
+extern int rl_delete_horizontal_space __P((int, int));
+extern int rl_delete_or_show_completions __P((int, int));
+extern int rl_insert_comment __P((int, int));
+
+/* Bindable commands for changing case. */
+extern int rl_upcase_word __P((int, int));
+extern int rl_downcase_word __P((int, int));
+extern int rl_capitalize_word __P((int, int));
+
+/* Bindable commands for transposing characters and words. */
+extern int rl_transpose_words __P((int, int));
+extern int rl_transpose_chars __P((int, int));
+
+/* Bindable commands for searching within a line. */
+extern int rl_char_search __P((int, int));
+extern int rl_backward_char_search __P((int, int));
+
+/* Bindable commands for readline's interface to the command history. */
+extern int rl_beginning_of_history __P((int, int));
+extern int rl_end_of_history __P((int, int));
+extern int rl_get_next_history __P((int, int));
+extern int rl_get_previous_history __P((int, int));
+
+/* Bindable commands for managing the mark and region. */
+extern int rl_set_mark __P((int, int));
+extern int rl_exchange_point_and_mark __P((int, int));
+
+/* Bindable commands to set the editing mode (emacs or vi). */
+extern int rl_vi_editing_mode __P((int, int));
+extern int rl_emacs_editing_mode __P((int, int));
 
-/* Not available unless readline is compiled -DPAREN_MATCHING. */
-extern int rl_insert_close ();
+/* Bindable commands for managing key bindings. */
+extern int rl_re_read_init_file __P((int, int));
+extern int rl_dump_functions __P((int, int));
+extern int rl_dump_macros __P((int, int));
+extern int rl_dump_variables __P((int, int));
+
+/* Bindable commands for word completion. */
+extern int rl_complete __P((int, int));
+extern int rl_possible_completions __P((int, int));
+extern int rl_insert_completions __P((int, int));
+extern int rl_menu_complete __P((int, int));
+
+/* Bindable commands for killing and yanking text, and managing the kill ring. */
+extern int rl_kill_word __P((int, int));
+extern int rl_backward_kill_word __P((int, int));
+extern int rl_kill_line __P((int, int));
+extern int rl_backward_kill_line __P((int, int));
+extern int rl_kill_full_line __P((int, int));
+extern int rl_unix_word_rubout __P((int, int));
+extern int rl_unix_line_discard __P((int, int));
+extern int rl_copy_region_to_kill __P((int, int));
+extern int rl_kill_region __P((int, int));
+extern int rl_copy_forward_word __P((int, int));
+extern int rl_copy_backward_word __P((int, int));
+extern int rl_yank __P((int, int));
+extern int rl_yank_pop __P((int, int));
+extern int rl_yank_nth_arg __P((int, int));
+extern int rl_yank_last_arg __P((int, int));
+/* Not available unless __CYGWIN__ is defined. */
+#ifdef __CYGWIN__
+extern int rl_paste_from_clipboard __P((int, int));
+#endif
+
+/* Bindable commands for incremental searching. */
+extern int rl_reverse_search_history __P((int, int));
+extern int rl_forward_search_history __P((int, int));
+
+/* Bindable keyboard macro commands. */
+extern int rl_start_kbd_macro __P((int, int));
+extern int rl_end_kbd_macro __P((int, int));
+extern int rl_call_last_kbd_macro __P((int, int));
+
+/* Bindable undo commands. */
+extern int rl_revert_line __P((int, int));
+extern int rl_undo_command __P((int, int));
+
+/* Bindable tilde expansion commands. */
+extern int rl_tilde_expand __P((int, int));
+
+/* Bindable terminal control commands. */
+extern int rl_restart_output __P((int, int));
+extern int rl_stop_output __P((int, int));
+
+/* Miscellaneous bindable commands. */
+extern int rl_abort __P((int, int));
+extern int rl_tty_status __P((int, int));
+
+/* Bindable commands for incremental and non-incremental history searching. */
+extern int rl_history_search_forward __P((int, int));
+extern int rl_history_search_backward __P((int, int));
+extern int rl_noninc_forward_search __P((int, int));
+extern int rl_noninc_reverse_search __P((int, int));
+extern int rl_noninc_forward_search_again __P((int, int));
+extern int rl_noninc_reverse_search_again __P((int, int));
+
+/* Bindable command used when inserting a matching close character. */
+extern int rl_insert_close __P((int, int));
 
 /* Not available unless READLINE_CALLBACKS is defined. */
-extern void rl_callback_handler_install ();
-extern void rl_callback_read_char ();
-extern void rl_callback_handler_remove ();
-
-/* These are *both* defined even when VI_MODE is not. */
-extern int rl_vi_editing_mode (), rl_emacs_editing_mode ();
-
-/* Non incremental history searching. */
-extern int
-  rl_noninc_forward_search (), rl_noninc_reverse_search (),
-  rl_noninc_forward_search_again (), rl_noninc_reverse_search_again ();
+extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
+extern void rl_callback_read_char __P((void));
+extern void rl_callback_handler_remove __P((void));
 
 /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
-extern int rl_vi_check ();
-extern int
-  rl_vi_undo (), rl_vi_redo (), rl_vi_tilde_expand (),
-  rl_vi_movement_mode (), rl_vi_insertion_mode (), rl_vi_arg_digit (),
-  rl_vi_prev_word (), rl_vi_next_word (), rl_vi_char_search (),
-  rl_vi_eof_maybe (), rl_vi_append_mode (), rl_vi_put (),
-  rl_vi_append_eol (), rl_vi_insert_beg (), rl_vi_delete (),
-  rl_vi_first_print (), rl_vi_fword (), rl_vi_fWord (), rl_vi_bword (),
-  rl_vi_bWord (), rl_vi_eword (), rl_vi_eWord (), rl_vi_end_word (),
-  rl_vi_change_case (), rl_vi_match (), rl_vi_bracktype (),
-  rl_vi_change_char (), rl_vi_yank_arg (), rl_vi_search (),
-  rl_vi_search_again (),  rl_vi_subst (), rl_vi_overstrike (),
-  rl_vi_overstrike_delete (), rl_vi_replace(), rl_vi_column (),
-  rl_vi_delete_to (), rl_vi_change_to (), rl_vi_yank_to (),
-  rl_vi_complete (), rl_vi_fetch_history (), rl_vi_set_mark (),
-  rl_vi_goto_mark (), rl_vi_back_to_indent ();
+/* VI-mode bindable commands. */
+extern int rl_vi_redo __P((int, int));
+extern int rl_vi_undo __P((int, int));
+extern int rl_vi_yank_arg __P((int, int));
+extern int rl_vi_fetch_history __P((int, int));
+extern int rl_vi_search_again __P((int, int));
+extern int rl_vi_search __P((int, int));
+extern int rl_vi_complete __P((int, int));
+extern int rl_vi_tilde_expand __P((int, int));
+extern int rl_vi_prev_word __P((int, int));
+extern int rl_vi_next_word __P((int, int));
+extern int rl_vi_end_word __P((int, int));
+extern int rl_vi_insert_beg __P((int, int));
+extern int rl_vi_append_mode __P((int, int));
+extern int rl_vi_append_eol __P((int, int));
+extern int rl_vi_eof_maybe __P((int, int));
+extern int rl_vi_insertion_mode __P((int, int));
+extern int rl_vi_movement_mode __P((int, int));
+extern int rl_vi_arg_digit __P((int, int));
+extern int rl_vi_change_case __P((int, int));
+extern int rl_vi_put __P((int, int));
+extern int rl_vi_column __P((int, int));
+extern int rl_vi_delete_to __P((int, int));
+extern int rl_vi_change_to __P((int, int));
+extern int rl_vi_yank_to __P((int, int));
+extern int rl_vi_delete __P((int, int));
+extern int rl_vi_back_to_indent __P((int, int));
+extern int rl_vi_first_print __P((int, int));
+extern int rl_vi_char_search __P((int, int));
+extern int rl_vi_match __P((int, int));
+extern int rl_vi_change_char __P((int, int));
+extern int rl_vi_subst __P((int, int));
+extern int rl_vi_overstrike __P((int, int));
+extern int rl_vi_overstrike_delete __P((int, int));
+extern int rl_vi_replace __P((int, int));
+extern int rl_vi_set_mark __P((int, int));
+extern int rl_vi_goto_mark __P((int, int));
 
-/* Keyboard macro commands. */
-extern int rl_start_kbd_macro (), rl_end_kbd_macro ();
-extern int rl_call_last_kbd_macro ();
-extern void rl_push_macro_input ();
+/* VI-mode utility functions. */
+extern int rl_vi_check __P((void));
+extern int rl_vi_domove __P((int, int *));
+extern int rl_vi_bracktype __P((int));
 
-extern int rl_arrow_keys(), rl_refresh_line ();
+/* VI-mode pseudo-bindable commands, used as utility functions. */
+extern int rl_vi_fWord __P((int, int));
+extern int rl_vi_bWord __P((int, int));
+extern int rl_vi_eWord __P((int, int));
+extern int rl_vi_fword __P((int, int));
+extern int rl_vi_bword __P((int, int));
+extern int rl_vi_eword __P((int, int));
 
 /* **************************************************************** */
 /*								    */
 /*			Well Published Functions		    */
 /*								    */
 /* **************************************************************** */
 
 /* Readline functions. */
 /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
-extern char *readline ();
+extern char *readline __P((const char *));
+
+extern int rl_set_prompt __P((const char *));
 
-/* These functions are from bind.c. */
-/* rl_add_defun (char *name, Function *function, int key)
-   Add NAME to the list of named functions.  Make FUNCTION
-   be the function that gets called.
-   If KEY is not -1, then bind it. */
-extern int rl_add_defun ();
+extern int rl_initialize __P((void));
 
-extern Keymap rl_make_bare_keymap ();
-extern Keymap rl_copy_keymap ();
-extern Keymap rl_make_keymap ();
-extern void rl_discard_keymap ();
-extern Keymap rl_get_keymap (), rl_get_keymap_by_name ();
-extern void rl_set_keymap ();
-extern char *rl_get_keymap_name ();
+extern int rl_discard_argument __P((void));
 
-extern int rl_bind_key (), rl_bind_key_in_map ();
-extern int rl_unbind_key (), rl_unbind_key_in_map ();
-extern int rl_set_key ();
-extern int rl_generic_bind ();
-extern int rl_parse_and_bind ();
-/* Backwards compatibility, use rl_generic_bind instead. */
-extern int rl_macro_bind (), rl_variable_bind ();
+/* Utility functions to bind keys to readline commands. */
+extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
+extern int rl_bind_key __P((int, rl_command_func_t *));
+extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
+extern int rl_unbind_key __P((int));
+extern int rl_unbind_key_in_map __P((int, Keymap));
+extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
+extern int rl_unbind_command_in_map __P((const char *, Keymap));
+extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
+extern int rl_generic_bind __P((int, const char *, char *, Keymap));
+extern int rl_variable_bind __P((const char *, const char *));
 
-extern int rl_read_init_file ();
-
-extern Function *rl_named_function (), *rl_function_of_keyseq ();
-extern char **rl_invoking_keyseqs (), **rl_invoking_keyseqs_in_map ();
-extern void rl_function_dumper ();
-extern void rl_variable_dumper ();
-extern void rl_macro_dumper ();
-extern void rl_list_funmap_names ();
+/* Backwards compatibility, use rl_generic_bind instead. */
+extern int rl_macro_bind __P((const char *, const char *, Keymap));
 
 /* Undocumented in the texinfo manual; not really useful to programs. */
-extern int rl_translate_keyseq ();
-extern void rl_initialize_funmap ();
+extern int rl_translate_keyseq __P((const char *, char *, int *));
+extern char *rl_untranslate_keyseq __P((int));
+
+extern rl_command_func_t *rl_named_function __P((const char *));
+extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
+
+extern void rl_list_funmap_names __P((void));
+extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
+extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
+ 
+extern void rl_function_dumper __P((int));
+extern void rl_macro_dumper __P((int));
+extern void rl_variable_dumper __P((int));
+
+extern int rl_read_init_file __P((const char *));
+extern int rl_parse_and_bind __P((char *));
+
+/* Functions for manipulating keymaps. */
+extern Keymap rl_make_bare_keymap __P((void));
+extern Keymap rl_copy_keymap __P((Keymap));
+extern Keymap rl_make_keymap __P((void));
+extern void rl_discard_keymap __P((Keymap));
 
-/* Functions for undoing. */
-extern int rl_begin_undo_group (), rl_end_undo_group ();
-extern void rl_add_undo (), free_undo_list ();
-extern int rl_do_undo ();
-extern int rl_modifying ();
+extern Keymap rl_get_keymap_by_name __P((const char *));
+extern char *rl_get_keymap_name __P((Keymap));
+extern void rl_set_keymap __P((Keymap));
+extern Keymap rl_get_keymap __P((void));
+extern void rl_set_keymap_from_edit_mode __P((void));
+extern char *rl_get_keymap_name_from_edit_mode __P((void));
+
+/* Functions for manipulating the funmap, which maps command names to functions. */
+extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
+extern void rl_initialize_funmap __P((void));
+extern const char **rl_funmap_names __P((void));
+
+/* Utility functions for managing keyboard macros. */
+extern void rl_push_macro_input __P((char *));
+
+/* Functions for undoing, from undo.c */
+extern void rl_add_undo __P((enum undo_code, int, int, char *));
+extern void rl_free_undo_list __P((void));
+extern int rl_do_undo __P((void));
+extern int rl_begin_undo_group __P((void));
+extern int rl_end_undo_group __P((void));
+extern int rl_modifying __P((int, int));
 
 /* Functions for redisplay. */
-extern void rl_redisplay ();
-extern int rl_forced_update_display ();
-extern int rl_clear_message ();
-extern int rl_reset_line_state ();
-extern int rl_on_new_line ();
+extern void rl_redisplay __P((void));
+extern int rl_on_new_line __P((void));
+extern int rl_on_new_line_with_prompt __P((void));
+extern int rl_forced_update_display __P((void));
+extern int rl_clear_message __P((void));
+extern int rl_reset_line_state __P((void));
+extern int rl_crlf __P((void));
 
-#if defined (__STDC__) && defined (USE_VARARGS) && defined (PREFER_STDARG)
+#if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
 extern int rl_message (const char *, ...);
 #else
 extern int rl_message ();
 #endif
 
 /* Undocumented in texinfo manual. */
-extern int rl_character_len ();
-extern int rl_show_char ();
-extern int crlf ();
+extern int rl_show_char __P((int));
+extern int rl_character_len __P((int, int));
+
+/* Save and restore internal prompt redisplay information. */
+extern void rl_save_prompt __P((void));
+extern void rl_restore_prompt __P((void));
 
 /* Modifying text. */
-extern int rl_insert_text (), rl_delete_text ();
-extern int rl_kill_text ();
-extern char *rl_copy_text ();
+extern int rl_insert_text __P((const char *));
+extern int rl_delete_text __P((int, int));
+extern int rl_kill_text __P((int, int));
+extern char *rl_copy_text __P((int, int));
+
+/* Terminal and tty mode management. */
+extern void rl_prep_terminal __P((int));
+extern void rl_deprep_terminal __P((void));
+extern void rl_tty_set_default_bindings __P((Keymap));
+
+extern int rl_reset_terminal __P((const char *));
+extern void rl_resize_terminal __P((void));
+extern void rl_set_screen_size __P((int, int));
+extern void rl_get_screen_size __P((int*, int*));
 
-/* `Public' utility functions. */
-extern int rl_reset_terminal ();
-extern void rl_resize_terminal ();
-extern int rl_stuff_char ();
-extern int rl_read_key (), rl_getc ();
+/* Functions for character input. */
+extern int rl_stuff_char __P((int));
+extern int rl_execute_next __P((int));
+extern int rl_clear_pending_input __P((void));
+extern int rl_read_key __P((void));
+extern int rl_getc __P((FILE *));
+
+/* `Public' utility functions . */
+extern void rl_extend_line_buffer __P((int));
+extern int rl_ding __P((void));
+extern int rl_alphabetic __P((int));
 
-extern int rl_initialize ();
-
+/* Readline signal handling, from signals.c */
+extern int rl_set_signals __P((void));
+extern int rl_clear_signals __P((void));
+extern void rl_cleanup_after_signal __P((void));
+extern void rl_reset_after_signal __P((void));
+extern void rl_free_line_state __P((void));
+ 
 /* Undocumented. */
-extern int rl_expand_prompt ();
-extern int rl_set_signals (), rl_clear_signals ();
-extern int maybe_save_line (), maybe_unsave_line (), maybe_replace_line ();
+extern int rl_expand_prompt __P((char *));
+
+extern int rl_set_paren_blink_timeout __P((int));
+
+extern int rl_maybe_save_line __P((void));
+extern int rl_maybe_unsave_line __P((void));
+extern int rl_maybe_replace_line __P((void));
 
 /* Completion functions. */
-/* These functions are from complete.c. */
-extern int rl_complete_internal ();
+extern int rl_complete_internal __P((int));
+extern void rl_display_match_list __P((char **, int, int));
+
+extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
+extern char *rl_username_completion_function __P((const char *, int));
+extern char *rl_filename_completion_function __P((const char *, int));
 
-/* Return an array of strings which are the result of repeatadly calling
-   FUNC with TEXT. */
-extern char **completion_matches ();
-extern char *username_completion_function ();
-extern char *filename_completion_function ();
+#if 0
+/* Backwards compatibility (compat.c).  These will go away sometime. */
+extern void free_undo_list __P((void));
+extern int maybe_save_line __P((void));
+extern int maybe_unsave_line __P((void));
+extern int maybe_replace_line __P((void));
+
+extern int ding __P((void));
+extern int alphabetic __P((int));
+extern int crlf __P((void));
+
+extern char **completion_matches __P((char *, rl_compentry_func_t *));
+extern char *username_completion_function __P((const char *, int));
+extern char *filename_completion_function __P((const char *, int));
+#endif
 
 /* **************************************************************** */
 /*								    */
 /*			Well Published Variables		    */
 /*								    */
 /* **************************************************************** */
 
 /* The version of this incarnation of the readline library. */
-extern char *rl_library_version;
+extern const char *rl_library_version;
+
+/* True if this is real GNU readline. */
+extern int rl_gnu_readline_p;
+
+/* Flags word encapsulating the current readline state. */
+extern int rl_readline_state;
+
+/* Says which editing mode readline is currently using.  1 means emacs mode;
+   0 means vi mode. */
+extern int rl_editing_mode;
 
 /* The name of the calling program.  You should initialize this to
    whatever was in argv[0].  It is used when parsing conditionals. */
-extern char *rl_readline_name;
+extern const char *rl_readline_name;
 
 /* The prompt readline uses.  This is set from the argument to
    readline (), and should not be assigned to directly. */
 extern char *rl_prompt;
 
 /* The line buffer that is in use. */
 extern char *rl_line_buffer;
 
 /* The location of point, and end. */
-extern int rl_point, rl_end;
+extern int rl_point;
+extern int rl_end;
 
+/* The mark, or saved cursor position. */
 extern int rl_mark;
 
+/* Flag to indicate that readline has finished with the current input
+   line and should return it. */
 extern int rl_done;
 
+/* If set to a character value, that will be the next keystroke read. */
 extern int rl_pending_input;
 
 /* Non-zero if we called this function from _rl_dispatch().  It's present
    so functions can find out whether they were called from a key binding
    or directly from an application. */
 extern int rl_dispatching;
 
+/* Non-zero if the user typed a numeric argument before executing the
+   current function. */
+extern int rl_explicit_arg;
+
+/* The current value of the numeric argument specified by the user. */
+extern int rl_numeric_arg;
+
+/* The address of the last command function Readline executed. */
+extern rl_command_func_t *rl_last_func;
+
 /* The name of the terminal to use. */
-extern char *rl_terminal_name;
+extern const char *rl_terminal_name;
 
 /* The input and output streams. */
-extern FILE *rl_instream, *rl_outstream;
+extern FILE *rl_instream;
+extern FILE *rl_outstream;
 
 /* If non-zero, then this is the address of a function to call just
    before readline_internal () prints the first prompt. */
-extern Function *rl_startup_hook;
+extern rl_hook_func_t *rl_startup_hook;
 
+/* If non-zero, this is the address of a function to call just before
+   readline_internal_setup () returns and readline_internal starts
+   reading input characters. */
+extern rl_hook_func_t *rl_pre_input_hook;
+      
 /* The address of a function to call periodically while Readline is
    awaiting character input, or NULL, for no event handling. */
-extern Function *rl_event_hook;
+extern rl_hook_func_t *rl_event_hook;
 
-extern Function *rl_getc_function;
-extern VFunction *rl_redisplay_function;
-extern VFunction *rl_prep_term_function;
-extern VFunction *rl_deprep_term_function;
+/* The address of the function to call to fetch a character from the current
+   Readline input stream */
+extern rl_getc_func_t *rl_getc_function;
+
+extern rl_voidfunc_t *rl_redisplay_function;
+
+extern rl_vintfunc_t *rl_prep_term_function;
+extern rl_voidfunc_t *rl_deprep_term_function;
 
 /* Dispatch variables. */
 extern Keymap rl_executing_keymap;
 extern Keymap rl_binding_keymap;
 
+/* Display variables. */
+/* If non-zero, readline will erase the entire line, including any prompt,
+   if the only thing typed on an otherwise-blank line is something bound to
+   rl_newline. */
+extern int rl_erase_empty_line;
+
+/* If non-zero, the application has already printed the prompt (rl_prompt)
+   before calling readline, so readline should not output it the first time
+   redisplay is done. */
+extern int rl_already_prompted;
+
+/* A non-zero value means to read only this many characters rather than
+   up to a character bound to accept-line. */
+extern int rl_num_chars_to_read;
+
+/* The text of a currently-executing keyboard macro. */
+extern char *rl_executing_macro;
+
+/* Variables to control readline signal handling. */
+/* If non-zero, readline will install its own signal handlers for
+   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
+extern int rl_catch_signals;
+
+/* If non-zero, readline will install a signal handler for SIGWINCH
+   that also attempts to call any calling application's SIGWINCH signal
+   handler.  Note that the terminal is not cleaned up before the
+   application's signal handler is called; use rl_cleanup_after_signal()
+   to do that. */
+extern int rl_catch_sigwinch;
+
 /* Completion variables. */
 /* Pointer to the generator function for completion_matches ().
    NULL means to use filename_entry_function (), the default filename
    completer. */
-extern Function *rl_completion_entry_function;
+extern rl_compentry_func_t *rl_completion_entry_function;
 
 /* If rl_ignore_some_completions_function is non-NULL it is the address
    of a function to call after all of the possible matches have been
    generated, but before the actual completion is done to the input line.
    The function is called with one argument; a NULL terminated array
    of (char *).  If your function removes any of the elements, they
    must be free()'ed. */
-extern Function *rl_ignore_some_completions_function;
+extern rl_compignore_func_t *rl_ignore_some_completions_function;
 
 /* Pointer to alternative function to create matches.
    Function is called with TEXT, START, and END.
    START and END are indices in RL_LINE_BUFFER saying what the boundaries
    of TEXT are.
    If this function exists and returns NULL then call the value of
    rl_completion_entry_function to try to match, otherwise use the
    array of strings returned. */
-extern CPPFunction *rl_attempted_completion_function;
+extern rl_completion_func_t *rl_attempted_completion_function;
 
 /* The basic list of characters that signal a break between words for the
    completer routine.  The initial contents of this variable is what
    breaks words in the shell, i.e. "n\"\\'`@$>". */
-extern char *rl_basic_word_break_characters;
+extern const char *rl_basic_word_break_characters;
 
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-extern char *rl_completer_word_break_characters;
+extern const char *rl_completer_word_break_characters;
 
 /* List of characters which can be used to quote a substring of the line.
    Completion occurs on the entire substring, and within the substring   
    rl_completer_word_break_characters are treated as any other character,
    unless they also appear within this list. */
-extern char *rl_completer_quote_characters;
+extern const char *rl_completer_quote_characters;
 
 /* List of quote characters which cause a word break. */
-extern char *rl_basic_quote_characters;
+extern const char *rl_basic_quote_characters;
 
 /* List of characters that need to be quoted in filenames by the completer. */
-extern char *rl_filename_quote_characters;
+extern const char *rl_filename_quote_characters;
 
 /* List of characters that are word break characters, but should be left
    in TEXT when it is passed to the completion function.  The shell uses
    this to help determine what kind of completing to do. */
-extern char *rl_special_prefixes;
+extern const char *rl_special_prefixes;
 
 /* If non-zero, then this is the address of a function to call when
    completing on a directory name.  The function is called with
-   the address of a string (the current directory name) as an arg. */
-extern Function *rl_directory_completion_hook;
+   the address of a string (the current directory name) as an arg.  It
+   changes what is displayed when the possible completions are printed
+   or inserted. */
+extern rl_icppfunc_t *rl_directory_completion_hook;
+
+/* If non-zero, this is the address of a function to call when completing
+   a directory name.  This function takes the address of the directory name
+   to be modified as an argument.  Unlike rl_directory_completion_hook, it
+   only modifies the directory name used in opendir(2), not what is displayed
+   when the possible completions are printed or inserted.  It is called
+   before rl_directory_completion_hook. */
+extern rl_icppfunc_t *rl_directory_rewrite_hook;
 
 /* Backwards compatibility with previous versions of readline. */
 #define rl_symbolic_link_hook rl_directory_completion_hook
 
+/* If non-zero, then this is the address of a function to call when
+   completing a word would normally display the list of possible matches.
+   This function is called instead of actually doing the display.
+   It takes three arguments: (char **matches, int num_matches, int max_length)
+   where MATCHES is the array of strings that matched, NUM_MATCHES is the
+   number of strings in that array, and MAX_LENGTH is the length of the
+   longest string in that array. */
+extern rl_compdisp_func_t *rl_completion_display_matches_hook;
+
 /* Non-zero means that the results of the matches are to be treated
    as filenames.  This is ALWAYS zero on entry, and can only be changed
    within a completion entry finder function. */
 extern int rl_filename_completion_desired;
 
 /* Non-zero means that the results of the matches are to be quoted using
    double quotes (or an application-specific quoting mechanism) if the
    filename contains any characters in rl_word_break_chars.  This is
    ALWAYS non-zero on entry, and can only be changed within a completion
    entry finder function. */
 extern int rl_filename_quoting_desired;
 
 /* Set to a function to quote a filename in an application-specific fashion.
    Called with the text to quote, the type of match found (single or multiple)
    and a pointer to the quoting character to be used, which the function can
    reset if desired. */
-extern CPFunction *rl_filename_quoting_function;
+extern rl_quote_func_t *rl_filename_quoting_function;
 
 /* Function to call to remove quoting characters from a filename.  Called
    before completion is attempted, so the embedded quotes do not interfere
    with matching names in the file system. */
-extern CPFunction *rl_filename_dequoting_function;
+extern rl_dequote_func_t *rl_filename_dequoting_function;
 
 /* Function to call to decide whether or not a word break character is
    quoted.  If a character is quoted, it does not break words for the
    completer. */
-extern Function *rl_char_is_quoted_p;
+extern rl_linebuf_func_t *rl_char_is_quoted_p;
 
 /* Non-zero means to suppress normal filename completion after the
    user-specified completion function has been called. */
 extern int rl_attempted_completion_over;
 
 /* Set to a character describing the type of completion being attempted by
    rl_complete_internal; available for use by application completion
    functions. */
@@ -401,17 +678,41 @@ extern int rl_inhibit_completion;
 #define RL_PROMPT_END_IGNORE	'\002'
 
 /* Possible values for do_replace argument to rl_filename_quoting_function,
    called by rl_complete_internal. */
 #define NO_MATCH        0
 #define SINGLE_MATCH    1
 #define MULT_MATCH      2
 
-#if !defined (savestring)
-extern char *savestring ();	/* XXX backwards compatibility */
-#endif
+/* Possible state values for rl_readline_state */
+#define RL_STATE_NONE		0x00000		/* no state; before first call */
+
+#define RL_STATE_INITIALIZING	0x00001		/* initializing */
+#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
+#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
+#define RL_STATE_READCMD	0x00008		/* reading a command key */
+#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
+#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
+#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
+#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
+#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
+#define RL_STATE_SEARCH		0x00200		/* doing a history search */
+#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
+#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
+#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
+#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
+#define RL_STATE_COMPLETING	0x04000		/* doing completion */
+#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
+#define RL_STATE_UNDOING	0x10000		/* doing an undo */
+#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */
+
+#define RL_STATE_DONE		0x80000		/* done; accepted line */
+
+#define RL_SETSTATE(x)		(rl_readline_state |= (x))
+#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
+#define RL_ISSTATE(x)		(rl_readline_state & (x))
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* _READLINE_H_ */
diff --git a/readline/rldefs.h b/readline/rldefs.h
--- a/readline/rldefs.h
+++ b/readline/rldefs.h
@@ -5,17 +5,17 @@
 /* Copyright (C) 1987,1989 Free Software Foundation, Inc.
 
    This file contains the Readline Library (the Library), a set of
    routines for providing Emacs style line input to programs that ask
    for it.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -25,16 +25,18 @@
 
 #if !defined (_RLDEFS_H_)
 #define _RLDEFS_H_
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "rlstdc.h"
+
 #if defined (_POSIX_VERSION) && !defined (TERMIOS_MISSING)
 #  define TERMIOS_TTY_DRIVER
 #else
 #  if defined (HAVE_TERMIO_H)
 #    define TERMIO_TTY_DRIVER
 #  else
 #    define NEW_TTY_DRIVER
 #  endif
@@ -66,40 +68,41 @@ extern char *strchr (), *strrchr ();
 #    include <varargs.h>
 #  endif
 #endif
 
 #if defined (HAVE_STRCASECMP)
 #define _rl_stricmp strcasecmp
 #define _rl_strnicmp strncasecmp
 #else
-extern int _rl_stricmp (), _rl_strnicmp ();
+extern int _rl_stricmp __P((char *, char *);
+extern int _rl_strnicmp __P((char *, char *));
 #endif
 
 #if !defined (emacs_mode)
 #  define no_mode -1
 #  define vi_mode 0
 #  define emacs_mode 1
 #endif
 
 /* If you cast map[key].function to type (Keymap) on a Cray,
    the compiler takes the value of map[key].function and
    divides it by 4 to convert between pointer types (pointers
    to functions and pointers to structs are different sizes).
    This is not what is wanted. */
 #if defined (CRAY)
 #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(Function *)((int)(data))
+#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)((int)(data))
 #else
 #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(Function *)(data)
+#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)(data)
 #endif
 
 #ifndef savestring
-extern char *xmalloc ();
+extern char *xmalloc __P((int));
 #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
 #endif
 
 /* Possible values for _rl_bell_preference. */
 #define NO_BELL 0
 #define AUDIBLE_BELL 1
 #define VISIBLE_BELL 2
 
@@ -117,17 +120,18 @@ extern char *xmalloc ();
 #define RL_QF_DOUBLE_QUOTE	0x2
 #define RL_QF_BACKSLASH		0x4
 
 /* Default readline line buffer length. */
 #define DEFAULT_BUFFER_SIZE 256
 
 #if !defined (STREQ)
 #define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
-#define STREQN(a, b, n)	(((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
+#define STREQN(a, b, n)	(((n) == 0) ? (1) \
+				    : ((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
 #endif
 
 #if !defined (FREE)
 #  define FREE(x)	if (x) free (x)
 #endif
 
 /* CONFIGURATION SECTION */
 #include "rlconf.h"
diff --git a/readline/rltty.c b/readline/rltty.c
--- a/readline/rltty.c
+++ b/readline/rltty.c
@@ -3,17 +3,17 @@
 
 /* Copyright (C) 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -32,44 +32,30 @@
 #include <stdio.h>
 
 #if defined (HAVE_UNISTD_H)
 #  include <unistd.h>
 #endif /* HAVE_UNISTD_H */
 
 #include "rldefs.h"
 
-#if !defined (SHELL) && defined (GWINSZ_IN_SYS_IOCTL)
+#if defined (GWINSZ_IN_SYS_IOCTL)
 #  include <sys/ioctl.h>
-#endif /* !SHELL && GWINSZ_IN_SYS_IOCTL */
+#endif /* GWINSZ_IN_SYS_IOCTL */
 
 #include "rltty.h"
 #include "readline.h"
+#include "rlprivate.h"
 
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
-extern int readline_echoing_p;
-extern int _rl_eof_char;
-
-extern int _rl_enable_keypad, _rl_enable_meta;
-
-extern void _rl_control_keypad ();
-
-#if defined (__GO32__)
-#  include <pc.h>
-#  undef HANDLE_SIGNALS
-#endif /* __GO32__ */
-
-/* Indirect functions to allow apps control over terminal management. */
-extern void rl_prep_terminal (), rl_deprep_terminal ();
-
-VFunction *rl_prep_term_function = rl_prep_terminal;
-VFunction *rl_deprep_term_function = rl_deprep_terminal;
+rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
+rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
 
 /* **************************************************************** */
 /*								    */
 /*			   Signal Management			    */
 /*								    */
 /* **************************************************************** */
 
 #if defined (HAVE_POSIX_SIGNALS)
@@ -99,24 +85,25 @@ block_sigint ()
 #  if defined (HAVE_BSD_SIGNALS)
   sigint_oldmask = sigblock (sigmask (SIGINT));
 #  else /* !HAVE_BSD_SIGNALS */
 #    if defined (HAVE_USG_SIGHOLD)
   sighold (SIGINT);
 #    endif /* HAVE_USG_SIGHOLD */
 #  endif /* !HAVE_BSD_SIGNALS */
 #endif /* !HAVE_POSIX_SIGNALS */
+
   sigint_blocked = 1;
 }
 
 /* Allow SIGINT to be delivered. */
 static void
 release_sigint ()
 {
-  if (!sigint_blocked)
+  if (sigint_blocked == 0)
     return;
 
 #if defined (HAVE_POSIX_SIGNALS)
   sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
 #else
 #  if defined (HAVE_BSD_SIGNALS)
   sigsetmask (sigint_oldmask);
 #  else /* !HAVE_BSD_SIGNALS */
@@ -133,37 +120,37 @@ release_sigint ()
 /*								    */
 /*		      Saving and Restoring the TTY	    	    */
 /*								    */
 /* **************************************************************** */
 
 /* Non-zero means that the terminal is in a prepped state. */
 static int terminal_prepped;
 
+static _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;
+
 /* If non-zero, means that this process has called tcflow(fd, TCOOFF)
    and output is suspended. */
 #if defined (__ksr1__)
 static int ksrflow;
 #endif
 
-#if !defined (SHELL) && defined (TIOCGWINSZ)
 /* Dummy call to force a backgrounded readline to stop before it tries
    to get the tty settings. */
 static void
 set_winsize (tty)
      int tty;
 {
+#if defined (TIOCGWINSZ)
   struct winsize w;
 
   if (ioctl (tty, TIOCGWINSZ, &w) == 0)
-    (void) ioctl (tty, TIOCSWINSZ, &w);
+      (void) ioctl (tty, TIOCSWINSZ, &w);
+#endif /* TIOCGWINSZ */
 }
-#else /* SHELL || !TIOCGWINSZ */
-#  define set_winsize(tty)
-#endif /* SHELL || !TIOCGWINSZ */
 
 #if defined (NEW_TTY_DRIVER)
 
 /* Values for the `flags' field of a struct bsdtty.  This tells which
    elements of the struct bsdtty have been fetched from the system and
    are valid. */
 #define SGTTY_SET	0x01
 #define LFLAG_SET	0x02
@@ -181,41 +168,78 @@ struct bsdtty {
 #endif
   int flags;		/* Bitmap saying which parts of the struct are valid. */
 };
 
 #define TIOTYPE struct bsdtty
 
 static TIOTYPE otio;
 
+static void
+save_tty_chars (tiop)
+     TIOTYPE *tiop;
+{
+  _rl_last_tty_chars = _rl_tty_chars;
+
+  if (tiop->flags & SGTTY_SET)
+    {
+      _rl_tty_chars.t_erase = tiop->sgttyb.sg_erase;
+      _rl_tty_chars.t_kill = tiop->sgttyb.sg_kill;
+    }
+
+  if (tiop->flags & TCHARS_SET)
+    {
+      _rl_tty_chars.t_intr = tiop->tchars.t_intrc;
+      _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
+      _rl_tty_chars.t_start = tiop->tchars.t_startc;
+      _rl_tty_chars.t_stop = tiop->tchars.t_stopc;
+      _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
+      _rl_tty_chars.t_eol = '\n';
+      _rl_tty_chars.t_eol2 = tiop->tchars.t_brkc;
+    }
+
+  if (tiop->flags & LTCHARS_SET)
+    {
+      _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;
+      _rl_tty_chars.t_dsusp = tiop->ltchars.t_dsuspc;
+      _rl_tty_chars.t_reprint = tiop->ltchars.t_rprntc;
+      _rl_tty_chars.t_flush = tiop->ltchars.t_flushc;
+      _rl_tty_chars.t_werase = tiop->ltchars.t_werasc;
+      _rl_tty_chars.t_lnext = tiop->ltchars.t_lnextc;
+    }
+
+  _rl_tty_chars.t_status = -1;
+}
+
 static int
 get_tty_settings (tty, tiop)
      int tty;
      TIOTYPE *tiop;
 {
   set_winsize (tty);
 
   tiop->flags = tiop->lflag = 0;
 
-  ioctl (tty, TIOCGETP, &(tiop->sgttyb));
+  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
+    return -1;
   tiop->flags |= SGTTY_SET;
 
 #if defined (TIOCLGET)
-  ioctl (tty, TIOCLGET, &(tiop->lflag));
-  tiop->flags |= LFLAG_SET;
+  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
+    tiop->flags |= LFLAG_SET;
 #endif
 
 #if defined (TIOCGETC)
-  ioctl (tty, TIOCGETC, &(tiop->tchars));
-  tiop->flags |= TCHARS_SET;
+  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
+    tiop->flags |= TCHARS_SET;
 #endif
 
 #if defined (TIOCGLTC)
-  ioctl (tty, TIOCGLTC, &(tiop->ltchars));
-  tiop->flags |= LTCHARS_SET;
+  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
+    tiop->flags |= LTCHARS_SET;
 #endif
 
   return 0;
 }
 
 static int
 set_tty_settings (tty, tiop)
      int tty;
@@ -251,48 +275,47 @@ set_tty_settings (tty, tiop)
       tiop->flags &= ~LTCHARS_SET;
     }
 #endif
 
   return 0;
 }
 
 static void
-prepare_terminal_settings (meta_flag, otio, tiop)
+prepare_terminal_settings (meta_flag, oldtio, tiop)
      int meta_flag;
-     TIOTYPE otio, *tiop;
+     TIOTYPE oldtio, *tiop;
 {
-#if !defined (__GO32__)
-  readline_echoing_p = (otio.sgttyb.sg_flags & ECHO);
+  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
 
   /* Copy the original settings to the structure we're going to use for
      our settings. */
-  tiop->sgttyb = otio.sgttyb;
-  tiop->lflag = otio.lflag;
+  tiop->sgttyb = oldtio.sgttyb;
+  tiop->lflag = oldtio.lflag;
 #if defined (TIOCGETC)
-  tiop->tchars = otio.tchars;
+  tiop->tchars = oldtio.tchars;
 #endif
 #if defined (TIOCGLTC)
-  tiop->ltchars = otio.ltchars;
+  tiop->ltchars = oldtio.ltchars;
 #endif
-  tiop->flags = otio.flags;
+  tiop->flags = oldtio.flags;
 
   /* First, the basic settings to put us into character-at-a-time, no-echo
      input mode. */
   tiop->sgttyb.sg_flags &= ~(ECHO | CRMOD);
   tiop->sgttyb.sg_flags |= CBREAK;
 
   /* If this terminal doesn't care how the 8th bit is used, then we can
      use it for the meta-key.  If only one of even or odd parity is
      specified, then the terminal is using parity, and we cannot. */
 #if !defined (ANYP)
 #  define ANYP (EVENP | ODDP)
 #endif
-  if (((otio.sgttyb.sg_flags & ANYP) == ANYP) ||
-      ((otio.sgttyb.sg_flags & ANYP) == 0))
+  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
+      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
     {
       tiop->sgttyb.sg_flags |= ANYP;
 
       /* Hack on local mode flags if we can. */
 #if defined (TIOCLGET)
 #  if defined (LPASS8)
       tiop->lflag |= LPASS8;
 #  endif /* LPASS8 */
@@ -301,37 +324,36 @@ prepare_terminal_settings (meta_flag, ot
 
 #if defined (TIOCGETC)
 #  if defined (USE_XON_XOFF)
   /* Get rid of terminal output start and stop characters. */
   tiop->tchars.t_stopc = -1; /* C-s */
   tiop->tchars.t_startc = -1; /* C-q */
 
   /* If there is an XON character, bind it to restart the output. */
-  if (otio.tchars.t_startc != -1)
-    rl_bind_key (otio.tchars.t_startc, rl_restart_output);
+  if (oldtio.tchars.t_startc != -1)
+    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
 #  endif /* USE_XON_XOFF */
 
   /* If there is an EOF char, bind _rl_eof_char to it. */
-  if (otio.tchars.t_eofc != -1)
-    _rl_eof_char = otio.tchars.t_eofc;
+  if (oldtio.tchars.t_eofc != -1)
+    _rl_eof_char = oldtio.tchars.t_eofc;
 
 #  if defined (NO_KILL_INTR)
   /* Get rid of terminal-generated SIGQUIT and SIGINT. */
   tiop->tchars.t_quitc = -1; /* C-\ */
   tiop->tchars.t_intrc = -1; /* C-c */
 #  endif /* NO_KILL_INTR */
 #endif /* TIOCGETC */
 
 #if defined (TIOCGLTC)
   /* Make the interrupt keys go away.  Just enough to make people happy. */
   tiop->ltchars.t_dsuspc = -1;	/* C-y */
   tiop->ltchars.t_lnextc = -1;	/* C-v */
 #endif /* TIOCGLTC */
-#endif /* !__GO32__ */
 }
 
 #else  /* !defined (NEW_TTY_DRIVER) */
 
 #if !defined (VMIN)
 #  define VMIN VEOF
 #endif
 
@@ -347,54 +369,100 @@ prepare_terminal_settings (meta_flag, ot
 #    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSANOW, tiop))
 #  else
 #    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSADRAIN, tiop))
 #  endif /* !M_UNIX */
 #else
 #  define TIOTYPE struct termio
 #  define DRAIN_OUTPUT(fd)
 #  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
-#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETA, tiop))
+#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
 #endif /* !TERMIOS_TTY_DRIVER */
 
 static TIOTYPE otio;
 
 #if defined (FLUSHO)
 #  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
 #else
 #  define OUTPUT_BEING_FLUSHED(tp)  0
 #endif
 
 static void
+save_tty_chars (tiop)
+     TIOTYPE *tiop;
+{
+  _rl_last_tty_chars = _rl_tty_chars;
+
+  _rl_tty_chars.t_eof = tiop->c_cc[VEOF];
+  _rl_tty_chars.t_eol = tiop->c_cc[VEOL];
+#ifdef VEOL2
+  _rl_tty_chars.t_eol2 = tiop->c_cc[VEOL2];
+#endif
+  _rl_tty_chars.t_erase = tiop->c_cc[VERASE];
+#ifdef VWERASE
+  _rl_tty_chars.t_werase = tiop->c_cc[VWERASE];
+#endif
+  _rl_tty_chars.t_kill = tiop->c_cc[VKILL];
+#ifdef VREPRINT
+  _rl_tty_chars.t_reprint = tiop->c_cc[VREPRINT];
+#endif
+  _rl_tty_chars.t_intr = tiop->c_cc[VINTR];
+  _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];
+#ifdef VSUSP
+  _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];
+#endif
+#ifdef VDSUSP
+  _rl_tty_chars.t_dsusp = tiop->c_cc[VDSUSP];
+#endif
+#ifdef VSTART
+  _rl_tty_chars.t_start = tiop->c_cc[VSTART];
+#endif
+#ifdef VSTOP
+  _rl_tty_chars.t_stop = tiop->c_cc[VSTOP];
+#endif
+#ifdef VLNEXT
+  _rl_tty_chars.t_lnext = tiop->c_cc[VLNEXT];
+#endif
+#ifdef VDISCARD
+  _rl_tty_chars.t_flush = tiop->c_cc[VDISCARD];
+#endif
+#ifdef VSTATUS
+  _rl_tty_chars.t_status = tiop->c_cc[VSTATUS];
+#endif
+}
+
+#if defined (_AIX) || defined (_AIX41)
+/* Currently this is only used on AIX */
+static void
 rltty_warning (msg)
      char *msg;
 {
   fprintf (stderr, "readline: warning: %s\n", msg);
 }
+#endif
 
 #if defined (_AIX)
 void
 setopost(tp)
 TIOTYPE *tp;
 {
   if ((tp->c_oflag & OPOST) == 0)
     {
       rltty_warning ("turning on OPOST for terminal\r");
       tp->c_oflag |= OPOST|ONLCR;
     }
 }
 #endif
 
 static int
-get_tty_settings (tty, tiop)
+_get_tty_settings (tty, tiop)
      int tty;
      TIOTYPE *tiop;
 {
   int ioctl_ret;
-  set_winsize (tty);
 
   while (1)
     {
       ioctl_ret = GETATTR (tty, tiop);
       if (ioctl_ret < 0)
 	{
 	  if (errno != EINTR)
 	    return -1;
@@ -409,67 +477,90 @@ get_tty_settings (tty, tiop)
 	  break;
 #else
 	  continue;
 #endif
 	}
       break;
     }
 
+  return 0;
+}
+
+static int
+get_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  set_winsize (tty);
+
+  if (_get_tty_settings (tty, tiop) < 0)
+    return -1;
+
 #if defined (_AIX)
   setopost(tiop);
 #endif
 
   return 0;
 }
 
 static int
-set_tty_settings (tty, tiop)
+_set_tty_settings (tty, tiop)
      int tty;
      TIOTYPE *tiop;
 {
   while (SETATTR (tty, tiop) < 0)
     {
       if (errno != EINTR)
 	return -1;
       errno = 0;
     }
+  return 0;
+}
 
+static int
+set_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  if (_set_tty_settings (tty, tiop) < 0)
+    return -1;
+    
 #if 0
 
 #if defined (TERMIOS_TTY_DRIVER)
 #  if defined (__ksr1__)
   if (ksrflow)
     {
       ksrflow = 0;
       tcflow (tty, TCOON);
     }
 #  else /* !ksr1 */
   tcflow (tty, TCOON);		/* Simulate a ^Q. */
 #  endif /* !ksr1 */
 #else
   ioctl (tty, TCXONC, 1);	/* Simulate a ^Q. */
 #endif /* !TERMIOS_TTY_DRIVER */
 
-#endif
+#endif /* 0 */
 
   return 0;
 }
 
 static void
-prepare_terminal_settings (meta_flag, otio, tiop)
+prepare_terminal_settings (meta_flag, oldtio, tiop)
      int meta_flag;
-     TIOTYPE otio, *tiop;
+     TIOTYPE oldtio, *tiop;
 {
-  readline_echoing_p = (otio.c_lflag & ECHO);
+  readline_echoing_p = (oldtio.c_lflag & ECHO);
 
   tiop->c_lflag &= ~(ICANON | ECHO);
 
-  if ((unsigned char) otio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
-    _rl_eof_char = otio.c_cc[VEOF];
+  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
+    _rl_eof_char = oldtio.c_cc[VEOF];
 
 #if defined (USE_XON_XOFF)
 #if defined (IXANY)
   tiop->c_iflag &= ~(IXON | IXOFF | IXANY);
 #else
   /* `strict' Posix systems do not define IXANY. */
   tiop->c_iflag &= ~(IXON | IXOFF);
 #endif /* IXANY */
@@ -490,17 +581,17 @@ prepare_terminal_settings (meta_flag, ot
 
   tiop->c_cc[VMIN] = 1;
   tiop->c_cc[VTIME] = 0;
 
 #if defined (FLUSHO)
   if (OUTPUT_BEING_FLUSHED (tiop))
     {
       tiop->c_lflag &= ~FLUSHO;
-      otio.c_lflag &= ~FLUSHO;
+      oldtio.c_lflag &= ~FLUSHO;
     }
 #endif
 
   /* Turn off characters that we need on Posix systems with job control,
      just to be sure.  This includes ^Y and ^V.  This should not really
      be necessary.  */
 #if defined (TERMIOS_TTY_DRIVER) && defined (_POSIX_VDISABLE)
 
@@ -516,17 +607,16 @@ prepare_terminal_settings (meta_flag, ot
 }
 #endif  /* NEW_TTY_DRIVER */
 
 /* Put the terminal in CBREAK mode so that we can detect key presses. */
 void
 rl_prep_terminal (meta_flag)
      int meta_flag;
 {
-#if !defined (__GO32__)
   int tty;
   TIOTYPE tio;
 
   if (terminal_prepped)
     return;
 
   /* Try to keep this function from being INTerrupted. */
   block_sigint ();
@@ -536,39 +626,40 @@ rl_prep_terminal (meta_flag)
   if (get_tty_settings (tty, &tio) < 0)
     {
       release_sigint ();
       return;
     }
 
   otio = tio;
 
+  save_tty_chars (&otio);
+
   prepare_terminal_settings (meta_flag, otio, &tio);
 
   if (set_tty_settings (tty, &tio) < 0)
     {
       release_sigint ();
       return;
     }
 
   if (_rl_enable_keypad)
     _rl_control_keypad (1);
 
   fflush (rl_outstream);
   terminal_prepped = 1;
+  RL_SETSTATE(RL_STATE_TERMPREPPED);
 
   release_sigint ();
-#endif /* !__GO32__ */
 }
 
 /* Restore the terminal's normal settings and modes. */
 void
 rl_deprep_terminal ()
 {
-#if !defined (__GO32__)
   int tty;
 
   if (!terminal_prepped)
     return;
 
   /* Try to keep this function from being interrupted. */
   block_sigint ();
 
@@ -581,19 +672,19 @@ rl_deprep_terminal ()
 
   if (set_tty_settings (tty, &otio) < 0)
     {
       release_sigint ();
       return;
     }
 
   terminal_prepped = 0;
+  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
 
   release_sigint ();
-#endif /* !__GO32__ */
 }
 
 /* **************************************************************** */
 /*								    */
 /*			Bogus Flow Control      		    */
 /*								    */
 /* **************************************************************** */
 
@@ -658,16 +749,19 @@ rl_stop_output (count, key)
   return 0;
 }
 
 /* **************************************************************** */
 /*								    */
 /*			Default Key Bindings			    */
 /*								    */
 /* **************************************************************** */
+
+/* Set the system's default editing characters to their readline equivalents
+   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
 void
 rltty_set_default_bindings (kmap)
      Keymap kmap;
 {
   TIOTYPE ttybuff;
   int tty = fileno (rl_instream);
 
 #if defined (NEW_TTY_DRIVER)
@@ -721,8 +815,68 @@ rltty_set_default_bindings (kmap)
 #  endif /* VLNEXT && TERMIOS_TTY_DRIVER */
 
 #  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
       SET_SPECIAL (VWERASE, rl_unix_word_rubout);
 #  endif /* VWERASE && TERMIOS_TTY_DRIVER */
     }
 #endif /* !NEW_TTY_DRIVER */
 }
+
+/* New public way to set the system default editing chars to their readline
+   equivalents. */
+void
+rl_tty_set_default_bindings (kmap)
+     Keymap kmap;
+{
+  rltty_set_default_bindings (kmap);
+}
+
+#if defined (HANDLE_SIGNALS)
+
+#if defined (NEW_TTY_DRIVER)
+int
+_rl_disable_tty_signals ()
+{
+  return 0;
+}
+
+int
+_rl_restore_tty_signals ()
+{
+  return 0;
+}
+#else
+
+static TIOTYPE sigstty, nosigstty;
+static int tty_sigs_disabled = 0;
+
+int
+_rl_disable_tty_signals ()
+{
+  if (tty_sigs_disabled)
+    return 0;
+
+  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)
+    return -1;
+
+  nosigstty = sigstty;
+
+  nosigstty.c_lflag &= ~ISIG;
+
+  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)
+    return (_set_tty_settings (fileno (rl_instream), &sigstty));
+
+  tty_sigs_disabled = 1;
+  return 0;
+}
+
+int
+_rl_restore_tty_signals ()
+{
+  if (tty_sigs_disabled == 0)
+    return 0;
+
+  return (_set_tty_settings (fileno (rl_instream), &sigstty));
+}
+#endif /* !NEW_TTY_DRIVER */
+
+#endif /* HANDLE_SIGNALS */
diff --git a/readline/search.c b/readline/search.c
--- a/readline/search.c
+++ b/readline/search.c
@@ -3,17 +3,17 @@
 /* Copyright (C) 1992 Free Software Foundation, Inc.
 
    This file is part of the Readline Library (the Library), a set of
    routines for providing Emacs style line input to programs that ask
    for it.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -38,157 +38,182 @@
 #else
 #  include "ansi_stdlib.h"
 #endif
 
 #include "rldefs.h"
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+#include "xmalloc.h"
+
 #ifdef abs
 #  undef abs
 #endif
 #define abs(x)		(((x) >= 0) ? (x) : -(x))
 
-extern char *xmalloc (), *xrealloc ();
-
-/* Variables imported from readline.c */
-extern int rl_point, rl_end, rl_line_buffer_len;
-extern int rl_editing_mode;
-extern char *rl_prompt;
-extern char *rl_line_buffer;
-extern HIST_ENTRY *saved_line_for_history;
-extern Function *rl_last_func;
+extern HIST_ENTRY *_rl_saved_line_for_history;
 
 /* Functions imported from the rest of the library. */
-extern int _rl_free_history_entry ();
-extern char *_rl_make_prompt_for_search ();
-extern void _rl_restore_prompt ();
-extern void rl_extend_line_buffer ();
+extern int _rl_free_history_entry __P((HIST_ENTRY *));
 
 static char *noninc_search_string = (char *) NULL;
 static int noninc_history_pos;
+
 static char *prev_line_found = (char *) NULL;
 
+static int rl_history_search_len;
+static int rl_history_search_pos;
+static char *history_search_string;
+static int history_string_size;
+
+/* Make the data from the history entry ENTRY be the contents of the
+   current line.  This doesn't do anything with rl_point; the caller
+   must set it. */
+static void
+make_history_line_current (entry)
+     HIST_ENTRY *entry;
+{
+  int line_len;
+
+  line_len = strlen (entry->line);
+  if (line_len >= rl_line_buffer_len)
+    rl_extend_line_buffer (line_len);
+  strcpy (rl_line_buffer, entry->line);
+
+  rl_undo_list = (UNDO_LIST *)entry->data;
+  rl_end = line_len;
+
+  if (_rl_saved_line_for_history)
+    _rl_free_history_entry (_rl_saved_line_for_history);
+  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
+}
+
 /* Search the history list for STRING starting at absolute history position
    POS.  If STRING begins with `^', the search must match STRING at the
    beginning of a history line, otherwise a full substring match is performed
    for STRING.  DIR < 0 means to search backwards through the history list,
    DIR >= 0 means to search forward. */
 static int
 noninc_search_from_pos (string, pos, dir)
      char *string;
      int pos, dir;
 {
   int ret, old;
 
+  if (pos < 0)
+    return -1;
+
   old = where_history ();
-  history_set_pos (pos);
+  if (history_set_pos (pos) == 0)
+    return -1;
 
+  RL_SETSTATE(RL_STATE_SEARCH);
   if (*string == '^')
     ret = history_search_prefix (string + 1, dir);
   else
     ret = history_search (string, dir);
+  RL_UNSETSTATE(RL_STATE_SEARCH);
 
   if (ret != -1)
     ret = where_history ();
 
   history_set_pos (old);
   return (ret);
 }
 
 /* Search for a line in the history containing STRING.  If DIR is < 0, the
    search is backwards through previous entries, else through subsequent
    entries. */
 static void
 noninc_dosearch (string, dir)
      char *string;
      int dir;
 {
-  int oldpos, pos, line_len;
+  int oldpos, pos;
   HIST_ENTRY *entry;
 
   if (string == 0 || *string == '\0' || noninc_history_pos < 0)
     {
-      ding ();
+      rl_ding ();
       return;
     }
 
   pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
   if (pos == -1)
     {
       /* Search failed, current history position unchanged. */
-      maybe_unsave_line ();
+      rl_maybe_unsave_line ();
       rl_clear_message ();
       rl_point = 0;
-      ding ();
+      rl_ding ();
       return;
     }
 
   noninc_history_pos = pos;
 
   oldpos = where_history ();
   history_set_pos (noninc_history_pos);
   entry = current_history ();
 #if defined (VI_MODE)
   if (rl_editing_mode != vi_mode)
 #endif
   history_set_pos (oldpos);
 
-  line_len = strlen (entry->line);
-  if (line_len >= rl_line_buffer_len)
-    rl_extend_line_buffer (line_len);
-  strcpy (rl_line_buffer, entry->line);
+  make_history_line_current (entry);
 
-  rl_undo_list = (UNDO_LIST *)entry->data;
-  rl_end = strlen (rl_line_buffer);
   rl_point = 0;
   rl_clear_message ();
-
-  if (saved_line_for_history)
-    _rl_free_history_entry (saved_line_for_history);
-  saved_line_for_history = (HIST_ENTRY *)NULL;
 }
 
 /* Search non-interactively through the history list.  DIR < 0 means to
    search backwards through the history of previous commands; otherwise
    the search is for commands subsequent to the current position in the
    history list.  PCHAR is the character to use for prompting when reading
    the search string; if not specified (0), it defaults to `:'. */
 static void
 noninc_search (dir, pchar)
      int dir;
      int pchar;
 {
   int saved_point, c;
   char *p;
 
-  maybe_save_line ();
+  rl_maybe_save_line ();
   saved_point = rl_point;
 
   /* Use the line buffer to read the search string. */
   rl_line_buffer[0] = 0;
   rl_end = rl_point = 0;
 
   p = _rl_make_prompt_for_search (pchar ? pchar : ':');
   rl_message (p, 0, 0);
   free (p);
 
-#define SEARCH_RETURN _rl_restore_prompt (); return
+#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
 
+  RL_SETSTATE(RL_STATE_NSEARCH);
   /* Read the search string. */
-  while (c = rl_read_key ())
+  while (1)
     {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
+      c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
+      if (c == 0)
+	break;
+
       switch (c)
 	{
 	case CTRL('H'):
 	case RUBOUT:
 	  if (rl_point == 0)
 	    {
-	      maybe_unsave_line ();
+	      rl_maybe_unsave_line ();
 	      rl_clear_message ();
 	      rl_point = saved_point;
 	      SEARCH_RETURN;
 	    }
 	  rl_rubout (1, c);
 	  break;
 
 	case CTRL('W'):
@@ -202,20 +227,20 @@ noninc_search (dir, pchar)
 	case RETURN:
 	case NEWLINE:
 	  goto dosearch;
 	  /* NOTREACHED */
 	  break;
 
 	case CTRL('C'):
 	case CTRL('G'):
-	  maybe_unsave_line ();
+	  rl_maybe_unsave_line ();
 	  rl_clear_message ();
 	  rl_point = saved_point;
-	  ding ();
+	  rl_ding ();
 	  SEARCH_RETURN;
 
 	default:
 	  rl_insert (1, c);
 	  break;
 	}
       (*rl_redisplay_function) ();
     }
@@ -223,31 +248,31 @@ noninc_search (dir, pchar)
  dosearch:
   /* If rl_point == 0, we want to re-use the previous search string and
      start from the saved history position.  If there's no previous search
      string, punt. */
   if (rl_point == 0)
     {
       if (!noninc_search_string)
 	{
-	  ding ();
+	  rl_ding ();
 	  SEARCH_RETURN;
 	}
     }
   else
     {
       /* We want to start the search from the current history position. */
       noninc_history_pos = where_history ();
-      if (noninc_search_string)
-	free (noninc_search_string);
+      FREE (noninc_search_string);
       noninc_search_string = savestring (rl_line_buffer);
     }
 
-  _rl_restore_prompt ();
+  rl_restore_prompt ();
   noninc_dosearch (noninc_search_string, dir);
+  RL_UNSETSTATE(RL_STATE_NSEARCH);
 }
 
 /* Search forward through the history list for a string.  If the vi-mode
    code calls this, KEY will be `?'. */
 int
 rl_noninc_forward_search (count, key)
      int count, key;
 {
@@ -268,111 +293,147 @@ rl_noninc_reverse_search (count, key)
 /* Search forward through the history list for the last string searched
    for.  If there is no saved search string, abort. */
 int
 rl_noninc_forward_search_again (count, key)
      int count, key;
 {
   if (!noninc_search_string)
     {
-      ding ();
+      rl_ding ();
       return (-1);
     }
   noninc_dosearch (noninc_search_string, 1);
   return 0;
 }
 
 /* Reverse search in the history list for the last string searched
    for.  If there is no saved search string, abort. */
 int
 rl_noninc_reverse_search_again (count, key)
      int count, key;
 {
   if (!noninc_search_string)
     {
-      ding ();
+      rl_ding ();
       return (-1);
     }
   noninc_dosearch (noninc_search_string, -1);
   return 0;
 }
 
 static int
-rl_history_search_internal (count, direction)
-     int count, direction;
+rl_history_search_internal (count, dir)
+     int count, dir;
 {
-  HIST_ENTRY *temp, *old_temp;
-  int line_len;
+  HIST_ENTRY *temp;
+  int ret, oldpos;
 
-  maybe_save_line ();
+  rl_maybe_save_line ();
+  temp = (HIST_ENTRY *)NULL;
 
-  temp = old_temp = (HIST_ENTRY *)NULL;
+  /* Search COUNT times through the history for a line whose prefix
+     matches history_search_string.  When this loop finishes, TEMP,
+     if non-null, is the history line to copy into the line buffer. */
   while (count)
     {
-      temp = (direction < 0) ? previous_history () : next_history ();
-      if (temp == 0)
-        break;
-      /* On an empty prefix, make this the same as previous-history. */
-      if (rl_point == 0)
-	{
-	  count--;
-	  continue;
-	}
-      if (STREQN (rl_line_buffer, temp->line, rl_point))
-	{
-	  /* Don't find multiple instances of the same line. */
-	  if (prev_line_found && STREQ (prev_line_found, temp->line))
-	    continue;
-          if (direction < 0)
-            old_temp = temp;
-          prev_line_found = temp->line;
-          count--;
-	}
+      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
+      if (ret == -1)
+	break;
+
+      /* Get the history entry we found. */
+      rl_history_search_pos = ret;
+      oldpos = where_history ();
+      history_set_pos (rl_history_search_pos);
+      temp = current_history ();
+      history_set_pos (oldpos);
+
+      /* Don't find multiple instances of the same line. */
+      if (prev_line_found && STREQ (prev_line_found, temp->line))
+        continue;
+      prev_line_found = temp->line;
+      count--;
     }
 
+  /* If we didn't find anything at all, return. */
   if (temp == 0)
     {
-      if (direction < 0 && old_temp)
-	temp = old_temp;
-      else
-	{
-	  maybe_unsave_line ();
-	  ding ();
-	  return 1;
-	}
+      rl_maybe_unsave_line ();
+      rl_ding ();
+      /* If you don't want the saved history line (last match) to show up
+         in the line buffer after the search fails, change the #if 0 to
+         #if 1 */
+#if 0
+      if (rl_point > rl_history_search_len)
+        {
+          rl_point = rl_end = rl_history_search_len;
+          rl_line_buffer[rl_end] = '\0';
+        }
+#else
+      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
+#endif
+      return 1;
     }
 
-  line_len = strlen (temp->line);
-  if (line_len >= rl_line_buffer_len)
-    rl_extend_line_buffer (line_len);
-  strcpy (rl_line_buffer, temp->line);
-  rl_undo_list = (UNDO_LIST *)temp->data;
-  rl_end = line_len;
+  /* Copy the line we found into the current line buffer. */
+  make_history_line_current (temp);
+
+  rl_point = rl_history_search_len;
   return 0;
 }
 
+static void
+rl_history_search_reinit ()
+{
+  rl_history_search_pos = where_history ();
+  rl_history_search_len = rl_point;
+  prev_line_found = (char *)NULL;
+  if (rl_point)
+    {
+      if (rl_history_search_len >= history_string_size - 2)
+	{
+	  history_string_size = rl_history_search_len + 2;
+	  history_search_string = xrealloc (history_search_string, history_string_size);
+	}
+      history_search_string[0] = '^';
+      strncpy (history_search_string + 1, rl_line_buffer, rl_point);
+      history_search_string[rl_point + 1] = '\0';
+    }
+  _rl_free_saved_history_line ();
+}
+
 /* Search forward in the history for the string of characters
    from the start of the line to rl_point.  This is a non-incremental
    search. */
 int
 rl_history_search_forward (count, ignore)
      int count, ignore;
 {
   if (count == 0)
     return (0);
-  if (rl_last_func != rl_history_search_forward)
-    prev_line_found = (char *)NULL;
+
+  if (rl_last_func != rl_history_search_forward &&
+      rl_last_func != rl_history_search_backward)
+    rl_history_search_reinit ();
+
+  if (rl_history_search_len == 0)
+    return (rl_get_next_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
 }
 
 /* Search backward through the history for the string of characters
    from the start of the line to rl_point.  This is a non-incremental
    search. */
 int
 rl_history_search_backward (count, ignore)
      int count, ignore;
 {
   if (count == 0)
     return (0);
-  if (rl_last_func != rl_history_search_backward)
-    prev_line_found = (char *)NULL;
+
+  if (rl_last_func != rl_history_search_forward &&
+      rl_last_func != rl_history_search_backward)
+    rl_history_search_reinit ();
+
+  if (rl_history_search_len == 0)
+    return (rl_get_previous_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
 }
diff --git a/readline/shell.c b/readline/shell.c
--- a/readline/shell.c
+++ b/readline/shell.c
@@ -3,17 +3,17 @@
 
 /* Copyright (C) 1997 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -21,52 +21,63 @@
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 #define READLINE_LIBRARY
 
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
+#include <sys/types.h>
+
 #if defined (HAVE_UNISTD_H)
 #  include <unistd.h>
 #endif /* HAVE_UNISTD_H */
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
-extern char *xmalloc (), *xrealloc ();
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#include <fcntl.h>
+#include <pwd.h>
+
+#include <stdio.h>
 
-#if !defined (SHELL)
+#include "rlstdc.h"
+#include "rlshell.h"
+#include "xmalloc.h"
 
-#ifdef savestring
-#undef savestring
+#if !defined (HAVE_GETPW_DECLS)
+extern struct passwd *getpwuid __P((uid_t));
+#endif /* !HAVE_GETPW_DECLS */
+
+#ifndef NULL
+#  define NULL 0
 #endif
 
-/* Backwards compatibility, now that savestring has been removed from
-   all `public' readline header files. */
-char *
-savestring (s)
-     char *s;
-{
-  return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
-}
+/* All of these functions are resolved from bash if we are linking readline
+   as part of bash. */
 
 /* Does shell-like quoting using single quotes. */
 char *
-single_quote (string)
+sh_single_quote (string)
      char *string;
 {
   register int c;
   char *result, *r, *s;
 
-  result = (char *)xmalloc (3 + (3 * strlen (string)));
+  result = (char *)xmalloc (3 + (4 * strlen (string)));
   r = result;
   *r++ = '\'';
 
   for (s = string; s && (c = *s); s++)
     {
       *r++ = c;
 
       if (c == '\'')
@@ -81,17 +92,17 @@ single_quote (string)
   *r = '\0';
 
   return (result);
 }
 
 /* Set the environment variables LINES and COLUMNS to lines and cols,
    respectively. */
 void
-set_lines_and_columns (lines, cols)
+sh_set_lines_and_columns (lines, cols)
      int lines, cols;
 {
   char *b;
 
 #if defined (HAVE_PUTENV)
   b = xmalloc (24);
   sprintf (b, "LINES=%d", lines);
   putenv (b);
@@ -106,24 +117,60 @@ set_lines_and_columns (lines, cols)
   b = xmalloc (8);
   sprintf (b, "%d", cols);
   setenv ("COLUMNS", b, 1);
 #  endif /* HAVE_SETENV */
 #endif /* !HAVE_PUTENV */
 }
 
 char *
-get_env_value (varname)
-     char *varname;
+sh_get_env_value (varname)
+     const char *varname;
 {
   return ((char *)getenv (varname));
 }
 
-#else /* SHELL */
-extern char *get_string_value ();
+char *
+sh_get_home_dir ()
+{
+  char *home_dir;
+  struct passwd *entry;
+
+  home_dir = (char *)NULL;
+  entry = getpwuid (getuid ());
+  if (entry)
+    home_dir = entry->pw_dir;
+  return (home_dir);
+}
+
+#if !defined (O_NDELAY)
+#  if defined (FNDELAY)
+#    define O_NDELAY FNDELAY
+#  endif
+#endif
 
-char *
-get_env_value (varname)
-     char *varname;
+int
+sh_unset_nodelay_mode (fd)
+     int fd;
 {
-  return get_string_value (varname);
-}	
-#endif /* SHELL */
+  int flags, bflags;
+
+  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
+    return -1;
+
+  bflags = 0;
+
+#ifdef O_NONBLOCK
+  bflags |= O_NONBLOCK;
+#endif
+
+#ifdef O_NDELAY
+  bflags |= O_NDELAY;
+#endif
+
+  if (flags & bflags)
+    {
+      flags &= ~bflags;
+      return (fcntl (fd, F_SETFL, flags));
+    }
+
+  return 0;
+}
diff --git a/readline/signals.c b/readline/signals.c
--- a/readline/signals.c
+++ b/readline/signals.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -35,89 +35,75 @@
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 #if defined (GWINSZ_IN_SYS_IOCTL)
 #  include <sys/ioctl.h>
 #endif /* GWINSZ_IN_SYS_IOCTL */
 
-#if defined (__GO32__)
-#  undef HANDLE_SIGNALS
-#endif /* __GO32__ */
-
 #if defined (HANDLE_SIGNALS)
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
-extern int readline_echoing_p;
-extern int rl_pending_input;
-extern int _rl_meta_flag;
-
-extern void free_undo_list ();
-extern void _rl_get_screen_size ();
-extern void _rl_redisplay_after_sigwinch ();
-extern void _rl_clean_up_for_exit ();
-extern void _rl_kill_kbd_macro ();
-extern void _rl_init_argument ();
-extern void rl_deprep_terminal (), rl_prep_terminal ();
+#include "rlprivate.h"
 
 #if !defined (RETSIGTYPE)
 #  if defined (VOID_SIGHANDLER)
 #    define RETSIGTYPE void
 #  else
 #    define RETSIGTYPE int
 #  endif /* !VOID_SIGHANDLER */
 #endif /* !RETSIGTYPE */
 
 #if defined (VOID_SIGHANDLER)
 #  define SIGHANDLER_RETURN return
 #else
 #  define SIGHANDLER_RETURN return (0)
 #endif
 
-/* This typedef is equivalant to the one for Function; it allows us
+/* This typedef is equivalent to the one for Function; it allows us
    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
 typedef RETSIGTYPE SigHandler ();
 
-static SigHandler *rl_set_sighandler ();
+#if defined (HAVE_POSIX_SIGNALS)
+typedef struct sigaction sighandler_cxt;
+#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
+#else
+typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
+#  define sigemptyset(m)
+#endif /* !HAVE_POSIX_SIGNALS */
+
+static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
+
+/* Exported variables for use by applications. */
+
+/* If non-zero, readline will install its own signal handlers for
+   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
+int rl_catch_signals = 1;
+
+/* If non-zero, readline will install a signal handler for SIGWINCH. */
+#ifdef SIGWINCH
+int rl_catch_sigwinch = 1;
+#endif
+
+static int signals_set_flag;
+static int sigwinch_set_flag;
 
 /* **************************************************************** */
 /*					        		    */
 /*			   Signal Handling                          */
 /*								    */
 /* **************************************************************** */
 
-/* If we're not being compiled as part of bash, initialize handlers for
-   and catch the job control signals (SIGTTIN, SIGTTOU, SIGTSTP) and
-   SIGTERM. */
-#if !defined (SHELL)
-#  define HANDLE_JOB_SIGNALS
-#  define HANDLE_SIGTERM
-#endif /* !SHELL */
-
-#if defined (HAVE_POSIX_SIGNALS)
-typedef struct sigaction sighandler_cxt;
-#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-#else
-typedef struct { SigHandler *sa_handler; } sighandler_cxt;
-#  define sigemptyset(m)
-#endif /* !HAVE_POSIX_SIGNALS */
-
-static sighandler_cxt old_int, old_alrm;
-
-#if defined (HANDLE_JOB_SIGNALS)
+static sighandler_cxt old_int, old_term, old_alrm, old_quit;
+#if defined (SIGTSTP)
 static sighandler_cxt old_tstp, old_ttou, old_ttin;
-#endif /* HANDLE_JOB_SIGNALS */
-
-#if defined (HANDLE_SIGTERM)
-static sighandler_cxt old_term;
 #endif
-
 #if defined (SIGWINCH)
 static sighandler_cxt old_winch;
 #endif
 
 /* Readline signal handler functions. */
 
 static RETSIGTYPE
 rl_signal_handler (sig)
@@ -128,106 +114,98 @@ rl_signal_handler (sig)
 #else /* !HAVE_POSIX_SIGNALS */
 #  if defined (HAVE_BSD_SIGNALS)
   long omask;
 #  else /* !HAVE_BSD_SIGNALS */
   sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
 #  endif /* !HAVE_BSD_SIGNALS */
 #endif /* !HAVE_POSIX_SIGNALS */
 
+  RL_SETSTATE(RL_STATE_SIGHANDLER);
+
 #if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
   /* Since the signal will not be blocked while we are in the signal
      handler, ignore it until rl_clear_signals resets the catcher. */
   if (sig == SIGINT || sig == SIGALRM)
     rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
 #endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */
 
   switch (sig)
     {
     case SIGINT:
-      {
-	register HIST_ENTRY *entry;
-
-	free_undo_list ();
-
-	entry = current_history ();
-	if (entry)
-	  entry->data = (char *)NULL;
-      }
-      _rl_kill_kbd_macro ();
-      rl_clear_message ();
-      _rl_init_argument ();
+      rl_free_line_state ();
+      /* FALLTHROUGH */
 
 #if defined (SIGTSTP)
     case SIGTSTP:
     case SIGTTOU:
     case SIGTTIN:
 #endif /* SIGTSTP */
     case SIGALRM:
     case SIGTERM:
-      _rl_clean_up_for_exit ();
-      (*rl_deprep_term_function) ();
-      rl_clear_signals ();
-      rl_pending_input = 0;
+    case SIGQUIT:
+      rl_cleanup_after_signal ();
 
 #if defined (HAVE_POSIX_SIGNALS)
       sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
       sigdelset (&set, sig);
 #else /* !HAVE_POSIX_SIGNALS */
 #  if defined (HAVE_BSD_SIGNALS)
       omask = sigblock (0);
 #  endif /* HAVE_BSD_SIGNALS */
 #endif /* !HAVE_POSIX_SIGNALS */
 
+#if defined (__EMX__)
+      signal (sig, SIG_ACK);
+#endif
+
       kill (getpid (), sig);
 
       /* Let the signal that we just sent through.  */
 #if defined (HAVE_POSIX_SIGNALS)
       sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
 #else /* !HAVE_POSIX_SIGNALS */
 #  if defined (HAVE_BSD_SIGNALS)
       sigsetmask (omask & ~(sigmask (sig)));
 #  endif /* HAVE_BSD_SIGNALS */
 #endif /* !HAVE_POSIX_SIGNALS */
 
-      (*rl_prep_term_function) (_rl_meta_flag);
-      rl_set_signals ();
+      rl_reset_after_signal ();
     }
 
+  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
   SIGHANDLER_RETURN;
 }
 
 #if defined (SIGWINCH)
 static RETSIGTYPE
-rl_handle_sigwinch (sig)
+rl_sigwinch_handler (sig)
      int sig;
 {
   SigHandler *oh;
 
 #if defined (MUST_REINSTALL_SIGHANDLERS)
   sighandler_cxt dummy_winch;
 
   /* We don't want to change old_winch -- it holds the state of SIGWINCH
      disposition set by the calling application.  We need this state
      because we call the application's SIGWINCH handler after updating
      our own idea of the screen size. */
-  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &dummy_winch);
+  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
 #endif
 
-  if (readline_echoing_p)
-    {
-      _rl_get_screen_size (fileno (rl_instream), 1);
-      _rl_redisplay_after_sigwinch ();
-    }
+  RL_SETSTATE(RL_STATE_SIGHANDLER);
+  rl_resize_terminal ();
 
   /* If another sigwinch handler has been installed, call it. */
   oh = (SigHandler *)old_winch.sa_handler;
   if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
     (*oh) (sig);
 
+  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
   SIGHANDLER_RETURN;
 }
 #endif  /* SIGWINCH */
 
 /* Functions to manage signal handling. */
 
 #if !defined (HAVE_POSIX_SIGNALS)
 static int
@@ -244,120 +222,176 @@ rl_sigaction (sig, nh, oh)
    information in OHANDLER.  Return the old signal handler, like
    signal(). */
 static SigHandler *
 rl_set_sighandler (sig, handler, ohandler)
      int sig;
      SigHandler *handler;
      sighandler_cxt *ohandler;
 {
+  sighandler_cxt old_handler;
 #if defined (HAVE_POSIX_SIGNALS)
   struct sigaction act;
 
   act.sa_handler = handler;
   act.sa_flags = 0;
   sigemptyset (&act.sa_mask);
   sigemptyset (&ohandler->sa_mask);
-  sigaction (sig, &act, ohandler);
+  sigaction (sig, &act, &old_handler);
 #else
-  ohandler->sa_handler = (SigHandler *)signal (sig, handler);
+  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
 #endif /* !HAVE_POSIX_SIGNALS */
+
+  /* XXX -- assume we have memcpy */
+  /* If rl_set_signals is called twice in a row, don't set the old handler to
+     rl_signal_handler, because that would cause infinite recursion. */
+  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
+    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));
+
   return (ohandler->sa_handler);
 }
 
+static void
+rl_maybe_set_sighandler (sig, handler, ohandler)
+     int sig;
+     SigHandler *handler;
+     sighandler_cxt *ohandler;
+{
+  sighandler_cxt dummy;
+  SigHandler *oh;
+
+  sigemptyset (&dummy.sa_mask);
+  oh = rl_set_sighandler (sig, handler, ohandler);
+  if (oh == (SigHandler *)SIG_IGN)
+    rl_sigaction (sig, ohandler, &dummy);
+}
+
 int
 rl_set_signals ()
 {
   sighandler_cxt dummy;
   SigHandler *oh;
 
-#if defined (HAVE_POSIX_SIGNALS)
-  sigemptyset (&dummy.sa_mask);
-#endif
-
-  oh = rl_set_sighandler (SIGINT, rl_signal_handler, &old_int);
-  if (oh == (SigHandler *)SIG_IGN)
-    rl_sigaction (SIGINT, &old_int, &dummy);
+  if (rl_catch_signals && signals_set_flag == 0)
+    {
+      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
+      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
+      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
 
-  oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
-  if (oh == (SigHandler *)SIG_IGN)
-    rl_sigaction (SIGALRM, &old_alrm, &dummy);
+      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
+      if (oh == (SigHandler *)SIG_IGN)
+	rl_sigaction (SIGALRM, &old_alrm, &dummy);
 #if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)
-  /* If the application using readline has already installed a signal
-     handler with SA_RESTART, SIGALRM will cause reads to be restarted
-     automatically, so readline should just get out of the way.  Since
-     we tested for SIG_IGN above, we can just test for SIG_DFL here. */
-  if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
-    rl_sigaction (SIGALRM, &old_alrm, &dummy);
+      /* If the application using readline has already installed a signal
+	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
+	 automatically, so readline should just get out of the way.  Since
+	 we tested for SIG_IGN above, we can just test for SIG_DFL here. */
+      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
+	rl_sigaction (SIGALRM, &old_alrm, &dummy);
 #endif /* HAVE_POSIX_SIGNALS */
 
-#if defined (HANDLE_JOB_SIGNALS)
-
 #if defined (SIGTSTP)
-  oh = rl_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
-  if (oh == (SigHandler *)SIG_IGN)
-    rl_sigaction (SIGTSTP, &old_tstp, &dummy);
-#else
-  oh = (SigHandler *)NULL;
+      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
 #endif /* SIGTSTP */
 
 #if defined (SIGTTOU)
-  rl_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
-  rl_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
-
-  if (oh == (SigHandler *)SIG_IGN)
-    {
-      rl_set_sighandler (SIGTTOU, SIG_IGN, &dummy);
-      rl_set_sighandler (SIGTTIN, SIG_IGN, &dummy);
-    }
+      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
 #endif /* SIGTTOU */
 
-#endif /* HANDLE_JOB_SIGNALS */
+#if defined (SIGTTIN)
+      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
+#endif /* SIGTTIN */
 
-#if defined (HANDLE_SIGTERM)
-  /* Handle SIGTERM if we're not being compiled as part of bash. */
-  rl_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
-#endif /* HANDLE_SIGTERM */
+      signals_set_flag = 1;
+    }
 
 #if defined (SIGWINCH)
-  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &old_winch);
+  if (rl_catch_sigwinch && sigwinch_set_flag == 0)
+    {
+      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);
+      sigwinch_set_flag = 1;
+    }
 #endif /* SIGWINCH */
 
   return 0;
 }
 
 int
 rl_clear_signals ()
 {
   sighandler_cxt dummy;
 
-#if defined (HAVE_POSIX_SIGNALS)
-  sigemptyset (&dummy.sa_mask);
-#endif
+  if (rl_catch_signals && signals_set_flag == 1)
+    {
+      sigemptyset (&dummy.sa_mask);
 
-  rl_sigaction (SIGINT, &old_int, &dummy);
-  rl_sigaction (SIGALRM, &old_alrm, &dummy);
-
-#if defined (HANDLE_JOB_SIGNALS)
+      rl_sigaction (SIGINT, &old_int, &dummy);
+      rl_sigaction (SIGTERM, &old_term, &dummy);
+      rl_sigaction (SIGQUIT, &old_quit, &dummy);
+      rl_sigaction (SIGALRM, &old_alrm, &dummy);
 
 #if defined (SIGTSTP)
-  rl_sigaction (SIGTSTP, &old_tstp, &dummy);
-#endif
+      rl_sigaction (SIGTSTP, &old_tstp, &dummy);
+#endif /* SIGTSTP */
 
 #if defined (SIGTTOU)
-  rl_sigaction (SIGTTOU, &old_ttou, &dummy);
-  rl_sigaction (SIGTTIN, &old_ttin, &dummy);
+      rl_sigaction (SIGTTOU, &old_ttou, &dummy);
 #endif /* SIGTTOU */
 
-#endif /* HANDLE_JOB_SIGNALS */
+#if defined (SIGTTIN)
+      rl_sigaction (SIGTTIN, &old_ttin, &dummy);
+#endif /* SIGTTIN */
 
-#if defined (HANDLE_SIGTERM)
-  rl_sigaction (SIGTERM, &old_term, &dummy);
-#endif /* HANDLE_SIGTERM */
+      signals_set_flag = 0;
+    }
 
 #if defined (SIGWINCH)
-  sigemptyset (&dummy.sa_mask);
-  rl_sigaction (SIGWINCH, &old_winch, &dummy);
+  if (rl_catch_sigwinch && sigwinch_set_flag == 1)
+    {
+      sigemptyset (&dummy.sa_mask);
+      rl_sigaction (SIGWINCH, &old_winch, &dummy);
+      sigwinch_set_flag = 0;
+    }
 #endif
 
   return 0;
 }
+
+/* Clean up the terminal and readline state after catching a signal, before
+   resending it to the calling application. */
+void
+rl_cleanup_after_signal ()
+{
+  _rl_clean_up_for_exit ();
+  (*rl_deprep_term_function) ();
+  rl_clear_signals ();
+  rl_clear_pending_input ();
+}
+
+/* Reset the terminal and readline state after a signal handler returns. */
+void
+rl_reset_after_signal ()
+{
+  (*rl_prep_term_function) (_rl_meta_flag);
+  rl_set_signals ();
+}
+
+/* Free up the readline variable line state for the current line (undo list,
+   any partial history entry, any keyboard macros in progress, and any
+   numeric arguments in process) after catching a signal, before calling
+   rl_cleanup_after_signal(). */ 
+void
+rl_free_line_state ()
+{
+  register HIST_ENTRY *entry;
+
+  rl_free_undo_list ();
+
+  entry = current_history ();
+  if (entry)
+    entry->data = (char *)NULL;
+
+  _rl_kill_kbd_macro ();
+  rl_clear_message ();
+  _rl_init_argument ();
+}
+
 #endif  /* HANDLE_SIGNALS */
diff --git a/readline/support/config.guess b/readline/support/config.guess
--- a/readline/support/config.guess
+++ b/readline/support/config.guess
@@ -1,12 +1,11 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
-#   Free Software Foundation, Inc.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
 #
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -18,17 +17,17 @@
 # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
 # Written by Per Bothner <bothner@cygnus.com>.
-# Please send patches to <config-patches@gnu.org>.
+# The master version of this file is at the FSF in /home/gd/gnu/lib.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
 # The plan is that this can be called by configure scripts if you
 # don't specify an explicit system type (host/target name).
 #
@@ -44,37 +43,147 @@ if test x"$CC_FOR_BUILD" = x; then
     if test x"$CC" != x; then
       CC_FOR_BUILD="$CC"
     else
       CC_FOR_BUILD=cc
     fi
   fi
 fi
 
-
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 8/24/94.)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
+elif (test -f /usr/5bin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/usr/5bin
 fi
 
+UNAME=`(uname) 2>/dev/null` || UNAME=unknown
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
 UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
+case "$RELEASE" in
+"")	RELEASE=0 ;;
+*)	RELEASE=`expr "$RELEASE" + 0` ;;
+esac
+REL_LEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.\([0-9]*\)'`    # 1
+REL_SUBLEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.[0-9]*.\([0-9]*\)'` # 2
+
 dummy=dummy-$$
 trap 'rm -f $dummy.c $dummy.o $dummy; exit 1' 1 2 15
 
+# Some versions of i386 SVR4.2 make `uname' equivalent to `uname -n', which
+# is contrary to all other versions of uname
+if [ -n "$UNAME" ] && [ "$UNAME_S" != "$UNAME" ] && [ "$UNAME_S" = UNIX_SV ]; then
+	UNAME=UNIX_SV
+fi
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    # Begin cases added for Bash
+    alpha:NetBSD:*:*)
+	echo alpha-dec-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    alpha:OpenBSD:*:*)
+	echo alpha-dec-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i?86:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    sparc:NetBSD:*:*)
+	echo sparc-unknown-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sparc:OpenBSD:*:*)
+	echo sparc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    vax:NetBSD:*:*)
+	echo vax-dec-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    vax:OpenBSD:*:*)
+	echo vax-dec-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:machten:*:*)
+	echo mac68k-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    concurrent*:*:*:*)
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo concurrent-concurrent-sysv3
+	else
+		echo concurrent-concurrent-bsd
+	fi
+	exit 0 ;;
+    ppc*:SunOS:5.*:*)
+	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sparc:UNIX_SV:4.*:*)
+	echo sparc-unknown-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    mips:UNIX_SV:4.*:*)
+	echo mips-mips-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    mips:OSF*1:*:*)
+	echo mips-mips-osf1
+	exit 0 ;;
+    mips:4.4BSD:*:*)
+	echo mips-mips-bsd4.4
+	exit 0 ;;
+    MIServer-S:SMP_DC.OSx:*:dcosx)
+	echo mips-pyramid-sysv4
+	exit 0 ;;
+    news*:NEWS*:*:*)
+	echo mips-sony-newsos${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:NEXTSTEP:*:*)
+	echo i386-next-nextstep${RELEASE}
+	exit 0 ;;
+    *680?0:NEXTSTEP:*:*)
+	echo m68k-next-nextstep${RELEASE}
+	exit 0 ;;    
+    *370:AIX:*:*)
+	echo ibm370-ibm-aix
+	exit 0 ;;
+    ksr1:OSF*1:*:*)
+	echo ksr1-ksr-osf1
+	exit 0 ;;
+    esa:OSF*1:*:* | ESA:OSF*:*:*)
+	echo esa-ibm-osf1
+	exit 0 ;;
+    DNP*:DNIX:*:*)
+	echo m68k-dnix-sysv
+	exit 0 ;;
+    *3b2*:*:*:*)
+	echo we32k-att-sysv3
+	exit 0 ;;
+    *:QNX:*:42*)
+	echo i386-qssl-qnx`echo ${UNAME_VERSION}`
+	exit 0 ;;
+    Alpha*:Windows:NT:*:SP*)
+	echo alpha-pc-opennt
+	exit 0 ;;
+    *:Windows:NT:*:SP*)
+	echo intel-pc-opennt
+	exit 0 ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit 0 ;;
+    # end cases added for Bash
     alpha:OSF1:*:*)
-	if test $UNAME_RELEASE = "V4.0"; then
+	# TEST CHANGED FOR BASH to handle `letter version' releases
+	UNAME_MAJOR=`echo "$UNAME_RELEASE" | sed -e 's/^.\([0-9]\).*/\1/'`
+	if test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR = 4 ; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+	elif test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR -gt 4 ; then
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`		
 	fi
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
 	cat <<EOF >$dummy.s
 	.globl main
 	.ent main
@@ -112,32 +221,32 @@ EOF
 				UNAME_MACHINE="alphaev6"
 				;;
 		esac
 	fi
 	rm -f $dummy.s $dummy
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
 	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit 0 ;;
+        # How do we know it's Interix rather than the generic POSIX subsystem?
+        # Should we change UNAME_MACHINE based on the output of uname instead
+        # of the specific Alpha model?
+        echo alpha-pc-interix
+        exit 0 ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
 	exit 0 ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-cbm-sysv4
 	exit 0;;
     amiga:NetBSD:*:*)
-      echo m68k-cbm-netbsd${UNAME_RELEASE}
-      exit 0 ;;
+	echo m68k-cbm-netbsd${UNAME_RELEASE}
+	exit 0 ;;
     amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	echo m68k-cbm-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
 	exit 0 ;;
     arc64:OpenBSD:*:*)
 	echo mips64el-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     arc:OpenBSD:*:*)
@@ -150,19 +259,16 @@ EOF
 	echo mipsel-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     sgi:OpenBSD:*:*)
 	echo mips-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     wgrisc:OpenBSD:*:*)
 	echo mipsel-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit 0 ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit 0;;
     arm32:NetBSD:*:*)
 	echo arm-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
     SR2?01:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
@@ -170,22 +276,22 @@ EOF
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
 	exit 0 ;;
-    NILE*:*:*:dcosx)
+    NILE:*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit 0 ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+        echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+        exit 0 ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     i86pc:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
@@ -230,24 +336,24 @@ EOF
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor 
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
         exit 0 ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
         exit 0 ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
@@ -265,16 +371,19 @@ EOF
 	echo m68k-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     mvme68k:OpenBSD:*:*)
 	echo m68k-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     mvme88k:OpenBSD:*:*)
 	echo m88k-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
+    *:"Mac OS":*:*)
+	echo `uname -p`-apple-macos${UNAME_RELEASE}
+	exit 0 ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
 	exit 0 ;;
     macppc:NetBSD:*:*)
         echo powerpc-apple-netbsd${UNAME_RELEASE}
         exit 0 ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
@@ -286,17 +395,16 @@ EOF
 	echo vax-dec-ultrix${UNAME_RELEASE}
 	exit 0 ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
 	exit 0 ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
 #endif
 	#if defined (host_mips) && defined (MIPSEB)
 	#if defined (SYSTYPE_SYSV)
 	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
 	#endif
@@ -324,29 +432,27 @@ EOF
 	exit 0 ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
 	exit 0 ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
 	exit 0 ;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
+	  if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
+	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
 		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
+	  else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
+	  fi
 	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
+	  echo i586-dg-dgux${UNAME_RELEASE}
 	fi
  	exit 0 ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
 	exit 0 ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
@@ -392,16 +498,20 @@ EOF
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -EHl ${IBM_CPU_ID} | grep POWER >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
+	elif grep bos410 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1
+	elif grep bos411 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1.1
 	else
 		IBM_REV=4.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
 	exit 0 ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
 	exit 0 ;;
@@ -420,18 +530,18 @@ EOF
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
 	exit 0 ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
 	exit 0 ;;
     9000/[34678]??:HP-UX:*:*)
 	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/31? )		HP_ARCH=m68000 ;;
+	    9000/[34]?? )	HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
               sed 's/^              //' << EOF >$dummy.c
               #include <stdlib.h>
               #include <unistd.h>
 
               int main ()
               {
               #if defined(_SC_KERNEL_BITS)
@@ -454,17 +564,17 @@ EOF
               #else  /* !defined(_SC_KERNEL_BITS) */
               	    puts ("hppa2.0"); break;
               #endif
               	default: puts ("hppa1.0"); break;
               	}
                   exit (0);
               }
 EOF
-	(CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
+	($CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
 	rm -f $dummy.c $dummy
 	esac
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
 	exit 0 ;;
     3050*:HI-UX:*:*)
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
@@ -497,18 +607,18 @@ EOF
 	exit 0 ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
 	exit 0 ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
 	exit 0 ;;
     *9??*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit 0 ;;
+        echo hppa1.0-hp-mpeix
+        exit 0 ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
 	exit 0 ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
 	exit 0 ;;
     i?86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
@@ -516,18 +626,18 @@ EOF
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
 	exit 0 ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
 	exit 0 ;;
     hppa*:OpenBSD:*:*)
-	echo hppa-unknown-openbsd
-	exit 0 ;;
+        echo hppa-unknown-openbsd
+        exit 0 ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
         exit 0 ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
@@ -548,134 +658,111 @@ EOF
 	echo ymp-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
 	exit 0 ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo t90-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
     CRAY*T3E:*:*:*)
-	echo alpha-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'    
-	exit 0 ;;
+        echo alpha-cray-unicosmk${UNAME_RELEASE}
+        exit 0 ;;
     CRAY-2:*:*:*)
 	echo cray2-cray-unicos
         exit 0 ;;
     F300:UNIX_System_V:*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit 0 ;;
     F301:UNIX_System_V:*:*)
-       echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
-       exit 0 ;;
+	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
+	exit 0 ;;
     hp3[0-9][05]:NetBSD:*:*)
 	echo m68k-hp-netbsd${UNAME_RELEASE}
 	exit 0 ;;
     hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+        echo m68k-unknown-openbsd${UNAME_RELEASE}
+        exit 0 ;;
     i?86:BSD/386:*:* | i?86:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+        echo sparc-unknown-bsdi${UNAME_RELEASE}
+        exit 0 ;;
     *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+        echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+        exit 0 ;;
     *:FreeBSD:*:*)
 	if test -x /usr/bin/objformat; then
 	    if test "elf" = "`/usr/bin/objformat`"; then
 		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
 		exit 0
 	    fi
 	fi
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-=(].*//'`
 	exit 0 ;;
     *:NetBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
+	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
     *:OpenBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit 0 ;;
     i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i386-pc-interix
-	exit 0 ;;
+        # How do we know it's Interix rather than the generic POSIX subsystem?
+        # It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+        # UNAME_MACHINE based on the output of uname instead of i386?
+        echo i386-pc-interix
+        exit 0 ;;
     i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
+        echo ${UNAME_MACHINE}-pc-uwin
+        exit 0 ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit 0 ;;    
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     *:GNU:*:*)
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit 0 ;;
     *:Linux:*:*)
+        # uname on the ARM produces all sorts of strangeness, and we need to
+        # filter it out.
+        case "$UNAME_MACHINE" in
+          armv*)                      UNAME_MACHINE=$UNAME_MACHINE ;;
+          arm* | sa110*)              UNAME_MACHINE="arm" ;;
+        esac
 
 	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
+	# first see if it will tell us.  cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
 	ld_help_string=`cd /; ld --help 2>&1`
 	ld_supported_emulations=`echo $ld_help_string \
 			 | sed -ne '/supported emulations:/!d
 				    s/[ 	][ 	]*/ /g
 				    s/.*supported emulations: *//
 				    s/ .*//
 				    p'`
-        case "$ld_supported_emulations" in
-	  *ia64)
-		echo "${UNAME_MACHINE}-unknown-linux"
-		exit 0
-		;;
-	  i?86linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0
-		;;
-	  i?86coff)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0
-		;;
-	  sparclinux)
-		echo "${UNAME_MACHINE}-unknown-linux-gnuaout"
-		exit 0
-		;;
-	  armlinux)
-		echo "${UNAME_MACHINE}-unknown-linux-gnuaout"
-		exit 0
-		;;
-	  elf32arm*)
-		echo "${UNAME_MACHINE}-unknown-linux-gnu"
-		exit 0
-		;;
-	  armelf_linux*)
-		echo "${UNAME_MACHINE}-unknown-linux-gnu"
-		exit 0
-		;;
-	  m68klinux)
-		echo "${UNAME_MACHINE}-unknown-linux-gnuaout"
-		exit 0
-		;;
+	case "$ld_supported_emulations" in
+	  *ia64)      echo "${UNAME_MACHINE}-unknown-linux"         ; exit 0 ;;
+	  i?86linux)  echo "${UNAME_MACHINE}-pc-linux-gnuaout"      ; exit 0 ;;
+	  i?86coff)   echo "${UNAME_MACHINE}-pc-linux-gnucoff"      ; exit 0 ;;
+	  sparclinux) echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  armlinux)   echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  m68klinux)  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
 	  elf32ppc | elf32ppclinux)
 		# Determine Lib Version
 		cat >$dummy.c <<EOF
 #include <features.h>
 #if defined(__GLIBC__)
 extern char __libc_version[];
 extern char __libc_release[];
 #endif
@@ -695,20 +782,18 @@ EOF
 		$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null
 		if test "$?" = 0 ; then
 			./$dummy | grep 1\.99 > /dev/null
 			if test "$?" = 0 ; then
 				LIBC="libc1"
 			fi
 		fi	
 		rm -f $dummy.c $dummy
-		echo powerpc-unknown-linux-gnu${LIBC}
-		exit 0
-		;;
-	esac
+		echo powerpc-unknown-linux-gnu${LIBC} ; exit 0 ;;
+ 	esac
 
 	if test "${UNAME_MACHINE}" = "alpha" ; then
 		sed 's/^	//'  <<EOF >$dummy.s
 		.globl main
 		.ent main
 	main:
 		.frame \$30,0,\$26,0
 		.prologue 0
@@ -751,20 +836,19 @@ EOF
 				LIBC="libc1"
 			fi
 		fi
 		rm -f $dummy.s $dummy
 		echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC} ; exit 0
 	elif test "${UNAME_MACHINE}" = "mips" ; then
 	  cat >$dummy.c <<EOF
 #ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
+int main (int argc, char *argv[]) {
 #else
-	int main (argc, argv) int argc; char *argv[]; {
+int main (argc, argv) int argc; char *argv[]; {
 #endif
 #ifdef __MIPSEB__
   printf ("%s-unknown-linux-gnu\n", argv[1]);
 #endif
 #ifdef __MIPSEL__
   printf ("%sel-unknown-linux-gnu\n", argv[1]);
 #endif
   return 0;
@@ -788,17 +872,16 @@ EOF
 	  *)
 	    VENDOR=unknown;
 	    ;;
 	  esac
 	  # Determine whether the default compiler is a.out or elf
 	  cat >$dummy.c <<EOF
 #include <features.h>
 #ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
 #endif
 #ifdef __ELF__
 # ifdef __GLIBC__
 #  if __GLIBC__ >= 2
     printf ("%s-${VENDOR}-linux-gnu\n", argv[1]);
@@ -809,49 +892,52 @@ EOF
    printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
 # endif
 #else
   printf ("%s-${VENDOR}-linux-gnuaout\n", argv[1]);
 #endif
   return 0;
 }
 EOF
-	  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
+	  ${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
 	  rm -f $dummy.c $dummy
 	fi ;;
 # ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
 # are messed up and put the nodename in both sysname and nodename.
     i?86:DYNIX/ptx:4*:*)
 	echo i386-sequent-sysv4
 	exit 0 ;;
+# added by chet for bash based on usenet posting from <hops@sco.com> and
+# documentation on SCO's web site -- UnixWare 7 (SVR5)
+#    i?86:UnixWare:5*:*)
+#	echo ${UNAME_MACHINE}-pc-sysv5uw${UNAME_VERSION}
+#	exit 0 ;;
     i?86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
+	# Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
 	exit 0 ;;
-    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i?86:UNIX_SV:4.*:*)
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
 	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
 	fi
 	exit 0 ;;
     i?86:*:5:7*)
-        # Fixed at (any) Pentium or better
-        UNAME_MACHINE=i586
-        if [ ${UNAME_SYSTEM} = "UnixWare" ] ; then
-	    echo ${UNAME_MACHINE}-sco-sysv${UNAME_RELEASE}uw${UNAME_VERSION}
-	else
-	    echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
-	fi
-	exit 0 ;;
+        UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+        (/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+        (/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) && UNAME_MACHINE=i586
+        (/bin/uname -X|egrep '^Machine.*Pent.*II' >/dev/null) && UNAME_MACHINE=i686
+        (/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) && UNAME_MACHINE=i585
+        echo ${UNAME_MACHINE}-${UNAME_SYSTEM}${UNAME_VERSION}-sysv${UNAME_RELEASE}
+        exit 0 ;;
     i?86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
@@ -860,25 +946,21 @@ EOF
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit 0 ;;
-    i?86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+    pc:*:*:*)
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
 	exit 0 ;;
-    pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit 0 ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
 	exit 0 ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
 	exit 0 ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
@@ -897,99 +979,102 @@ EOF
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4 && exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
     m68*:LynxOS:2.*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit 0 ;;
     i?86:LynxOS:2.*:* | i?86:LynxOS:3.[01]*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
+	echo i386-pc-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
+    *:LynxOS:*:*)
+	echo ${UNAME_MACHINE}-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
 	exit 0 ;;
-    RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit 0 ;;
-    RM*:SINIX-*:*:*)
+    RM*:SINIX-*:*:* | RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
 	exit 0 ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
 	exit 0 ;;
     PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                           # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit 0 ;;
+			   # says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit 0 ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
 	exit 0 ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
+	exit 0 ;;              
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
 	exit 0 ;;
     news*:NEWS-OS:*:6*)
 	echo mips-sony-newsos6
 	exit 0 ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv${UNAME_RELEASE}
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
 	exit 0 ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+    BeBox:BeOS:*:*)    # BeOS running on hardware made by Be, PPC only.
 	echo powerpc-apple-beos
 	exit 0 ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+    BeMac:BeOS:*:*)
+	echo powerpc-apple-beos
+	exit 0 ;;
+    BePC:BeOS:*:*)
 	echo i586-pc-beos
 	exit 0 ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit 0 ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
 	exit 0 ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit 0 ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
 	exit 0 ;;
-    *:QNX:*:4*)
-	echo i386-qnx-qnx${UNAME_VERSION}
+    Power*:Darwin:*:*)
+	echo powerpc-apple-darwin${UNAME_RELEASE}
+	exit 0 ;;
+    *:Darwin:*:*)
+	echo ${UNAME_MACHINE}-apple-darwin${UNAME_RELEASE}
 	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
@@ -1011,17 +1096,21 @@ main ()
 #else
 	  ""
 #endif
          ); exit (0);
 #endif
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp9000) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
   printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
 #if !defined (__ARCHITECTURE__)
@@ -1083,21 +1172,128 @@ main ()
   printf ("vax-dec-ultrix\n"); exit (0);
 #endif
 #endif
 
 #if defined (alliant) && defined (i860)
   printf ("i860-alliant-bsd\n"); exit (0);
 #endif
 
+/* Begin cases added for Bash */
+#if defined (tahoe)
+  printf ("tahoe-cci-bsd\n"); exit (0);
+#endif
+
+#if defined (nec_ews)
+#  if defined (SYSTYPE_SYSV)
+  printf ("ews4800-nec-sysv4\n"); exit 0;
+#  else
+  printf ("ews4800-nec-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (sony)
+#  if defined (SYSTYPE_SYSV)
+  printf ("mips-sony-sysv4\n"); exit 0;
+#  else
+  printf ("mips-sony-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (ardent)
+  printf ("titan-ardent-bsd\n"); exit (0);
+#endif
+
+#if defined (stardent)
+  printf ("stardent-stardent-sysv\n"); exit (0);
+#endif
+
+#if defined (ibm032)
+  printf ("ibmrt-ibm-bsd4.3\n"); exit (0);
+#endif
+
+#if defined (sequent) && defined (i386)
+  printf ("i386-sequent-bsd\n"); exit (0);
+#endif
+
+#if defined (qnx) && defined (i386)
+  printf ("i386-pc-qnx\n"); exit (0);
+#endif
+
+#if defined (gould)
+  printf ("gould-gould-bsd\n"); exit (0);
+#endif
+
+#if defined (unixpc)
+  printf ("unixpc-att-sysv\n"); exit (0);
+#endif
+
+#if defined (att386)
+  printf ("i386-att-sysv3\n"); exit (0);
+#endif
+
+#if defined (__m88k) && defined (__UMAXV__)
+  printf ("m88k-encore-sysv3\n"); exit (0);
+#endif
+
+#if defined (drs6000)
+  printf ("drs6000-icl-sysv4.2\n"); exit (0);
+#endif
+
+#if defined (clipper)
+  printf ("clipper-orion-bsd\n"); exit (0);
+#endif
+
+#if defined (is68k)
+  printf ("m68k-isi-bsd\n"); exit (0);
+#endif
+
+#if defined (luna88k)
+  printf ("luna88k-omron-bsd\n"); exit (0);
+#endif
+
+#if defined (butterfly) && defined (BFLY1)
+  printf ("butterfly-bbn-mach\n"); exit (0);
+#endif
+
+#if defined (tower32)
+  printf ("tower32-ncr-sysv4\n"); exit (0);
+#endif
+
+#if defined (MagicStation)
+  printf ("magicstation-unknown-bsd\n"); exit (0);
+#endif
+
+#if defined (scs)
+  printf ("symmetric-scs-bsd4.2\n"); exit (0);
+#endif
+
+#if defined (tandem)
+  printf ("tandem-tandem-sysv\n"); exit (0);
+#endif
+
+#if defined (cadmus)
+  printf ("cadmus-pcs-sysv\n"); exit (0);
+#endif
+
+#if defined (masscomp)
+  printf ("masscomp-masscomp-sysv3\n"); exit (0);
+#endif
+
+#if defined (hbullx20)
+  printf ("hbullx20-bull-sysv3\n"); exit (0);
+#endif
+
+/* End cases added for Bash */
+
   exit (1);
 }
 EOF
 
-$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0
+${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0
 rm -f $dummy.c $dummy
 
 # Apollos put the system type in the environment.
 
 test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
@@ -1120,11 +1316,26 @@ then
 	echo c38-convex-bsd
 	exit 0 ;;
     c4*)
 	echo c4-convex-bsd
 	exit 0 ;;
     esac
 fi
 
+# Begin cases added for Bash
+case "$UNAME" in
+uts) echo uts-amdahl-sysv${UNAME_RELEASE}; exit 0 ;;
+esac
+
+if [ -d /usr/amiga ]; then
+	echo m68k-cbm-sysv${UNAME_RELEASE}; exit 0;
+fi
+
+if [ -f /bin/fxc.info ]; then
+	echo fxc-alliant-concentrix
+	exit 0
+fi
+# end cases added for Bash
+
 #echo '(Unable to guess system type)' 1>&2
 
 exit 1
diff --git a/readline/support/config.sub b/readline/support/config.sub
--- a/readline/support/config.sub
+++ b/readline/support/config.sub
@@ -1,13 +1,11 @@
 #! /bin/sh
 # Configuration validation subroutine script, version 1.1.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
-#   Free Software Foundation, Inc.
-#
+#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
@@ -22,19 +20,16 @@
 # Foundation, Inc., 59 Temple Place - Suite 330,
 # Boston, MA 02111-1307, USA.
 
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Written by Per Bothner <bothner@cygnus.com>.
-# Please send patches to <config-patches@gnu.org>.
-#
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
@@ -94,28 +89,28 @@ case $os in
 		# Prevent following clause from handling this invalid input.
 		;;
 	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple)
+	-apple )
 		os=
 		basic_machine=$1
 		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
 		;;
 	-scout)
 		;;
 	-wrs)
-		os=-vxworks
+		os=vxworks
 		basic_machine=$1
 		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
@@ -156,20 +151,16 @@ case $os in
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
 		;;
 	-windowsnt*)
 		os=`echo $os | sed -e 's/windowsnt/winnt/'`
 		;;
 	-psos*)
 		os=-psos
 		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
 	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \
 		| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \
@@ -177,20 +168,20 @@ case $basic_machine in
 		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
 		| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \
 		| we32k | ns16k | clipper | i370 | sh | powerpc | powerpcle \
 		| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \
 		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
 		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
 		| mips64vr5000 | miprs64vr5000el | mcore \
 		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
-		| thumb | d10v | fr30)
+	        | thumb | d10v)
 		basic_machine=$basic_machine-unknown
 		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65 | pj | pjl)
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65)
 		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i[34567]86)
 	  basic_machine=$basic_machine-pc
 	  ;;
@@ -210,20 +201,28 @@ case $basic_machine in
 	      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \
 	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
 	      | clipper-* | orion-* \
 	      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \
 	      | sparc64-* | sparcv9-* | sparc86x-* | mips16-* | mips64-* | mipsel-* \
 	      | mips64el-* | mips64orion-* | mips64orionel-* \
 	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
 	      | mipstx39-* | mipstx39el-* | mcore-* \
-	      | f301-* | armv*-* | sv1-* | t3e-* \
+	      | f301-* | armv*-* | t3e-* \
 	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
-	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* )
+	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* )
 		;;
+	# BEGIN cases added for Bash
+	butterfly-bbn* | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
+	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
+	      | concurrent-* | ksr1-* | esa-ibm | fxc-alliant | *370-amdahl \
+	      | *-convex | sx[45]*-nec )
+		;;
+	# END cases added for Bash
+
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
 		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
 		basic_machine=m68000-att
@@ -249,17 +248,18 @@ case $basic_machine in
 		basic_machine=a29k-none
 		os=-bsd
 		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
-		basic_machine=m68k-cbm
+#		basic_machine=m68k-cbm
+		basic_machine=m68k-unknown
 		;;
 	amigaos | amigados)
 		basic_machine=m68k-cbm
 		os=-amigaos
 		;;
 	amigaunix | amix)
 		basic_machine=m68k-cbm
 		os=-sysv4
@@ -332,25 +332,28 @@ case $basic_machine in
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
 		;;
 	dpx2* | dpx2*-bull)
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
+	hbullx20-bull)
+		basic_machine=m68k-bull
+		;;
 	ebmon29k)
 		basic_machine=a29k-amd
 		os=-ebmon
 		;;
 	elxsi)
 		basic_machine=elxsi-elxsi
 		os=-bsd
 		;;
-	encore | umax | mmax)
+	encore | umax | mmax | multimax)
 		basic_machine=ns32k-encore
 		;;
 	es1800 | OSE68k | ose68k | ose | OSE)
 		basic_machine=m68k-ericsson
 		os=-ose
 		;;
 	fx2800)
 		basic_machine=i860-alliant
@@ -428,18 +431,22 @@ case $basic_machine in
 	hppaosf)
 		basic_machine=hppa1.1-hp
 		os=-osf
 		;;
 	hppro)
 		basic_machine=hppa1.1-hp
 		os=-proelf
 		;;
+	ibm032-*)
+		basic_machine=ibmrt-ibm
+		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
+		os=-mvs
 		;;
 # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i[34567]86v32)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
 	i[34567]86v4*)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
@@ -464,48 +471,48 @@ case $basic_machine in
 	i386-go32 | go32)
 		basic_machine=i386-unknown
 		os=-go32
 		;;
 	i386-mingw32 | mingw32)
 		basic_machine=i386-unknown
 		os=-mingw32
 		;;
-	i386-qnx | qnx)
-		basic_machine=i386-qnx
-		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
 		    -irix*)
 			;;
 		    *)
 			os=-irix4
 			;;
 		esac
 		;;
 	isi68 | isi)
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
-	m88k-omron*)
+	luna88k-omron* | m88k-omron*)
 		basic_machine=m88k-omron
 		;;
+	magicstation*)
+		basic_machine=magicstation-unknown
+		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
 		;;
 	merlin)
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+	*mint | *MiNT)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
 	mipsel*-linux*)
 		basic_machine=mipsel-unknown
 		os=-linux-gnu
 		;;
 	mips*-linux*)
@@ -513,60 +520,52 @@ case $basic_machine in
 		os=-linux-gnu
 		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	msdos)
 		basic_machine=i386-unknown
 		os=-msdos
 		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
 	netbsd386)
 		basic_machine=i386-unknown
 		os=-netbsd
 		;;
 	netwinder)
-		basic_machine=armv4l-rebel
+		basic_machine=armv4l-corel
 		os=-linux
 		;;
 	news | news700 | news800 | news900)
 		basic_machine=m68k-sony
 		os=-newsos
 		;;
 	news1000)
 		basic_machine=m68030-sony
 		os=-newsos
 		;;
 	news-3600 | risc-news)
 		basic_machine=mips-sony
 		os=-newsos
 		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
+        necv70)
+                basic_machine=v70-nec
+                os=-sysv
+                ;;
 	next | m*-next )
 		basic_machine=m68k-next
 		case $os in
 		    -nextstep* )
 			;;
 		    -ns2*)
 		      os=-nextstep2
 			;;
@@ -582,127 +581,135 @@ case $basic_machine in
 	nh[45]000)
 		basic_machine=m88k-harris
 		os=-cxux
 		;;
 	nindy960)
 		basic_machine=i960-intel
 		os=-nindy
 		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
+        mon960)
+                basic_machine=i960-intel
+                os=-mon960
+                ;;
 	np1)
 		basic_machine=np1-gould
 		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
+	osr5 | sco5)	# SCO Open Server
+		basic_machine=i386-pc
+		os=-sco3.2v5
+		;;
+	odt | odt3 | odt4)	# SCO Open Desktop
+		basic_machine=i386-pc
+		os=-sco3.2v4
 		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
-		;;
+        op50n-* | op60c-*)
+                basic_machine=hppa1.1-oki
+                os=-proelf
+                ;;
+        OSE68000 | ose68000)
+                basic_machine=m68000-ericsson
+                os=-ose
+                ;;
+        os68k)
+                basic_machine=m68k-none
+                os=-os68k
+                ;;
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
 		;;
 	paragon)
 		basic_machine=i860-intel
 		os=-osf
 		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
 	pbb)
 		basic_machine=m68k-tti
 		;;
-        pc532 | pc532-*)
+	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
 	pentium | p5 | k5 | k6 | nexen)
-		basic_machine=i586-pc
+		basic_machine=i586-intel
 		;;
-	pentiumpro | p6 | 6x86)
-		basic_machine=i686-pc
-		;;
+        pentiumpro | p6 | 6x86)
+                basic_machine=i686-pc
+                ;;
 	pentiumii | pentium2)
 		basic_machine=i786-pc
 		;;
 	pentium-* | p5-* | k5-* | k6-* | nexen-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumpro-* | p6-* | 6x86-*)
+	pentiumpro-* | p6-* | 6x86*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumii-* | pentium2-*)
 		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=rs6000-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
-	        ;;
+		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
-	        ;;
+		;;
 	ppcle-* | powerpclittle-*)
 		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
+        rom68k)
+                basic_machine=m68k-rom68k
+                os=-coff
+                ;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
 		basic_machine=romp-ibm
 		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
+        sa29200)
+                basic_machine=a29k-amd
+                os=-udi
+                ;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
-	sparclite-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
+        sparclite-wrs)
+                basic_machine=sparclite-wrs
+                os=-vxworks
+                ;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
 		;;
 	spur)
 		basic_machine=spur-unknown
 		;;
-	st2000)
-		basic_machine=m68k-tandem
-		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
+        st2000)
+                basic_machine=m68k-tandem
+                ;;
+        stratus)
+                basic_machine=i860-stratus
+                os=-sysv4
+                ;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
 	sun2os3)
 		basic_machine=m68000-sun
 		os=-sunos3
 		;;
 	sun2os4)
@@ -733,109 +740,113 @@ case $basic_machine in
 		basic_machine=m68k-sun
 		;;
 	sun4)
 		basic_machine=sparc-sun
 		;;
 	sun386 | sun386i | roadrunner)
 		basic_machine=i386-sun
 		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
 	symmetry)
 		basic_machine=i386-sequent
 		os=-dynix
 		;;
-	t3e)
-		basic_machine=t3e-cray
-		os=-unicos
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
+        t3e)
+                basic_machine=t3e-cray
+                os=-unicos
+                ;;
+        tx39)
+                basic_machine=mipstx39-unknown
+                ;;
+        tx39el)
+                basic_machine=mipstx39el-unknown
+                ;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
 	ultra3)
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
+	uw2 | unixware | unixware2)
+		basic_machine=i386-pc
+		os=-sysv4.2uw2.1
 		;;
+	uw7 | unixware7)
+		basic_machine=i386-pc
+		os=-sysv5uw7
+		;;
+        v810 | necv810)
+                basic_machine=v810-nec
+                os=-none
+                ;;
 	vaxv)
 		basic_machine=vax-dec
 		os=-sysv
 		;;
 	vms)
 		basic_machine=vax-dec
 		os=-vms
 		;;
 	vpp*|vx|vx-*)
-               basic_machine=f301-fujitsu
-               ;;
+		basic_machine=f301-fujitsu
+		;;
 	vxworks960)
 		basic_machine=i960-wrs
 		os=-vxworks
 		;;
 	vxworks68)
 		basic_machine=m68k-wrs
 		os=-vxworks
 		;;
 	vxworks29k)
 		basic_machine=a29k-wrs
 		os=-vxworks
 		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
+        w65*)
+                basic_machine=w65-wdc
+                os=-none
+                ;;
+        w89k-*)
+                basic_machine=hppa1.1-winbond
+                os=-proelf
+                ;;
 	xmp)
 		basic_machine=xmp-cray
 		os=-unicos
 		;;
-        xps | xps100)
+	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
+        z8k-*-coff)
+                basic_machine=z8k-unknown
+                os=-sim
+                ;;
 	none)
 		basic_machine=none-none
 		os=-none
 		;;
 
 # Here we handle the default manufacturer of certain CPU types.  It is in
 # some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
+        w89k)
+                basic_machine=hppa1.1-winbond
+                ;;
+        op50n)
+                basic_machine=hppa1.1-oki
+                ;;
+        op60c)
+                basic_machine=hppa1.1-oki
+                ;;
 	mips)
-		if [ x$os = x-linux-gnu ]; then
+		if test "x$os" = "x-linux-gnu" ; then
 			basic_machine=mips-unknown
 		else
 			basic_machine=mips-mips
 		fi
 		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
@@ -849,35 +860,35 @@ case $basic_machine in
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
 	sparc | sparcv9)
 		basic_machine=sparc-sun
 		;;
-        cydra)
+	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
 		basic_machine=orion-highlevel
 		;;
 	orion105)
 		basic_machine=clipper-highlevel
 		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	c4x*)
-		basic_machine=c4x-none
-		os=-coff
-		;;
+        mac | mpw | mac-mpw)
+                basic_machine=m68k-apple
+                ;;
+        pmac | pmac-mpw)
+                basic_machine=powerpc-apple
+                ;;
+        c4x*)
+                basic_machine=c4x-none
+                os=-coff
+                ;;
 	*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 esac
 
 # Here we canonicalize certain aliases for manufacturers.
 case $basic_machine in
@@ -891,30 +902,36 @@ case $basic_machine in
 		;;
 esac
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
 if [ x"$os" != x"" ]
 then
 case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
+	# First match some system type aliases
+	# that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
 		;;
 	-solaris)
 		os=-solaris2
 		;;
 	-svr4*)
 		os=-sysv4
 		;;
-	-unixware*)
-		os=-sysv4.2uw
+	-unixware | -uw | -unixware2* | -uw2*)
+		os=-sysv4.2uw2.1
+		;;
+	-unixware7* | -uw7*)
+		os=-sysv5uw7
+		;;
+        -unixware*)
+                os=-sysv4.2uw
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
@@ -926,102 +943,104 @@ case $os in
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -opened* | -openstep* | -oskit*)
+	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+	# BEGIN CASES ADDED FOR Bash
+	-qnx* | -powerux* | -superux* | -darwin* | -nonstopux*)
 		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
+	# END CASES ADDED FOR Bash
+        -sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+              | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+              | -macos* | -mpw* | -magic* | -mon960* | -lnews*)
+                ;;
+        -mac*)
+                os=`echo $os | sed -e 's|mac|macos|'`
+                ;;
+
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
-	-opened*)
-		os=-openedition
-		;;
 	-osfrose*)
 		os=-osfrose
 		;;
 	-osf*)
 		os=-osf
 		;;
 	-utek*)
 		os=-bsd
 		;;
 	-dynix*)
 		os=-bsd
 		;;
 	-acis*)
 		os=-aos
 		;;
-	-386bsd)
-		os=-bsd
-		;;
+        -386bsd)
+                os=-bsd
+                ;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
 	-ns2 )
-	        os=-nextstep2
+		os=-nextstep2
 		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
 		;;
 	-sinix*)
 		os=-sysv4
 		;;
 	-triton*)
 		os=-sysv3
 		;;
 	-oss*)
 		os=-sysv3
 		;;
-        -qnx)
-		os=-qnx4
-		;;
 	-svr4)
 		os=-sysv4
 		;;
 	-svr3)
 		os=-sysv3
 		;;
 	-sysvr4)
 		os=-sysv4
 		;;
-	# This must come after -sysvr4.
+	-sysvr5)
+		os=-sysv5
+		;;
+	# This must come after -sysvr[45].
 	-sysv*)
 		;;
-	-ose*)
-		os=-ose
-		;;
-	-es1800*)
-		os=-ose
-		;;
+        -ose*)
+                os=-ose
+                ;;
+        -es1800*)
+                os=-ose
+                ;;
 	-xenix)
 		os=-xenix
 		;;
         -*mint | -*MiNT)
-	        os=-mint
-		;;
+                os=-mint
+                ;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
 		exit 1
 		;;
@@ -1037,23 +1056,20 @@ else
 # that MANUFACTURER isn't an operating system.  Otherwise, code above
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
 case $basic_machine in
 	*-acorn)
 		os=-riscix1.2
 		;;
-	arm*-rebel)
-		os=-linux
-		;;
 	arm*-semi)
 		os=-aout
 		;;
-        pdp11-*)
+	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
 		os=-ultrix4.2
 		;;
 	m68*-apollo)
 		os=-domain
 		;;
@@ -1061,46 +1077,46 @@ case $basic_machine in
 		os=-sunos4.0.2
 		;;
 	m68000-sun)
 		os=-sunos3
 		# This also exists in the configure program, but was not the
 		# default.
 		# os=-sunos4
 		;;
-	m68*-cisco)
-		os=-aout
-		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
+        m68*-cisco)
+                os=-aout
+                ;;
+        mips*-cisco)
+                os=-elf
+                ;;
+        mips*-*)
+                os=-elf
+                ;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
 	*-be)
 		os=-beos
 		;;
 	*-ibm)
 		os=-aix
 		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
-		;;
-	*-oki)
-		os=-proelf
-		;;
+        *-wec)
+                os=-proelf
+                ;;
+        *-winbond)
+                os=-proelf
+                ;;
+        *-oki)
+                os=-proelf
+                ;;
 	*-hp)
 		os=-hpux
 		;;
 	*-hitachi)
 		os=-hiux
 		;;
 	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
 		os=-sysv
@@ -1133,49 +1149,49 @@ case $basic_machine in
 		os=-genix
 		;;
 	i370-*)
 		os=-mvs
 		;;
 	*-next)
 		os=-nextstep3
 		;;
-        *-gould)
+	*-gould)
 		os=-sysv
 		;;
-        *-highlevel)
+	*-highlevel)
 		os=-bsd
 		;;
 	*-encore)
 		os=-bsd
 		;;
-        *-sgi)
+	*-sgi)
 		os=-irix
 		;;
-        *-siemens)
+	*-siemens)
 		os=-sysv4
 		;;
 	*-masscomp)
 		os=-rtu
 		;;
 	f301-fujitsu)
 		os=-uxpv
 		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
-		;;
+        *-rom68k)
+                os=-coff
+                ;;
+        *-*bug)
+                os=-coff
+                ;;
+        *-apple)
+                os=-macos
+                ;;
+        *-atari*)
+                os=-mint
+                ;;
 	*)
 		os=-none
 		;;
 esac
 fi
 
 # Here we handle the case where we know the os, and the CPU type, but not the
 # manufacturer.  We pick the logical manufacturer.
@@ -1184,62 +1200,62 @@ case $basic_machine in
 	*-unknown)
 		case $os in
 			-riscix*)
 				vendor=acorn
 				;;
 			-sunos*)
 				vendor=sun
 				;;
+			-lynxos*)
+				vendor=lynx
+				;;
 			-aix*)
 				vendor=ibm
 				;;
-			-beos*)
-				vendor=be
-				;;
+                        -beos*)
+                                vendor=be
+                                ;;
 			-hpux*)
 				vendor=hp
 				;;
-			-mpeix*)
-				vendor=hp
-				;;
 			-hiux*)
 				vendor=hitachi
 				;;
 			-unos*)
 				vendor=crds
 				;;
 			-dgux*)
 				vendor=dg
 				;;
 			-luna*)
 				vendor=omron
 				;;
 			-genix*)
 				vendor=ns
 				;;
-			-mvs* | -opened*)
+			-mvs*)
 				vendor=ibm
 				;;
 			-ptx*)
 				vendor=sequent
 				;;
 			-vxsim* | -vxworks*)
 				vendor=wrs
 				;;
 			-aux*)
 				vendor=apple
 				;;
-			-hms*)
-				vendor=hitachi
-				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -*MiNT)
-				vendor=atari
-				;;
+                        -hms*)
+                                vendor=hitachi
+                                ;;
+                        -mpw* | -macos*)
+                                vendor=apple
+                                ;;
+                        -*mint | -*MiNT)
+                                vendor=atari
+                                ;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
diff --git a/readline/support/mkdist b/readline/support/mkdist
--- a/readline/support/mkdist
+++ b/readline/support/mkdist
@@ -43,17 +43,17 @@ shift $(( $OPTIND - 1 ))
 
 if [ $# -lt 1 ]; then
 	usage
 fi
 
 version=$1
 newdir=${ROOTNAME}-$version
 
-vmsg creating distribution for version $version in $newdir
+vmsg creating distribution for $ROOTNAME version $version in $newdir
 
 if [ ! -d $newdir ]; then
 	mkdir $newdir || { echo $0: cannot make directory $newdir 1>&2 ; exit 1; }
 fi
 
 dirmode=755
 filmode=644
 
diff --git a/readline/terminal.c b/readline/terminal.c
--- a/readline/terminal.c
+++ b/readline/terminal.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1996 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -41,390 +41,441 @@
 #else
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #if defined (HAVE_LOCALE_H)
 #  include <locale.h>
 #endif
 
-#include <signal.h>
 #include <stdio.h>
-#include <setjmp.h>
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
 #  include <sys/ioctl.h>
 #endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
 
 #include "rltty.h"
 #include "tcap.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
-/* Variables and functions imported from readline.c */
-extern FILE *_rl_in_stream, *_rl_out_stream;
-extern int readline_echoing_p;
-extern int _rl_bell_preference;
-extern Keymap _rl_keymap;
-
-/* Functions imported from bind.c */
-extern void _rl_bind_if_unbound ();
-
-/* Functions imported from shell.c */
-extern void set_lines_and_columns ();
-extern char *get_env_value ();
+#include "rlprivate.h"
+#include "rlshell.h"
 
 /* **************************************************************** */
 /*								    */
 /*			Terminal and Termcap			    */
 /*								    */
 /* **************************************************************** */
 
 static char *term_buffer = (char *)NULL;
 static char *term_string_buffer = (char *)NULL;
 
 static int tcap_initialized;
 
-/* Non-zero means this terminal can't really do anything. */
-static int dumb_term;
-
 #if !defined (__linux__)
 #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
 extern 
 #  endif /* __EMX__ || NEED_EXTERN_PC */
 char PC, *BC, *UP;
 #endif /* __linux__ */
 
 /* Some strings to control terminal actions.  These are output by tputs (). */
-char *term_goto, *term_clreol, *term_cr, *term_clrpag, *term_backspace;
-char *term_pc;
+char *_rl_term_clreol;
+char *_rl_term_clrpag;
+char *_rl_term_cr;
+char *_rl_term_backspace;
+char *_rl_term_goto;
+char *_rl_term_pc;
 
 /* Non-zero if we determine that the terminal can do character insertion. */
-int terminal_can_insert = 0;
+int _rl_terminal_can_insert = 0;
 
 /* How to insert characters. */
-char *term_im, *term_ei, *term_ic, *term_ip, *term_IC;
+char *_rl_term_im;
+char *_rl_term_ei;
+char *_rl_term_ic;
+char *_rl_term_ip;
+char *_rl_term_IC;
 
 /* How to delete characters. */
-char *term_dc, *term_DC;
+char *_rl_term_dc;
+char *_rl_term_DC;
 
 #if defined (HACK_TERMCAP_MOTION)
-char *term_forward_char;
+char *_rl_term_forward_char;
 #endif  /* HACK_TERMCAP_MOTION */
 
 /* How to go up a line. */
-char *term_up;
+char *_rl_term_up;
 
-/* A visible bell, if the terminal can be made to flash the screen. */
-static char *visible_bell;
+/* A visible bell; char if the terminal can be made to flash the screen. */
+static char *_rl_visible_bell;
 
 /* Non-zero means the terminal can auto-wrap lines. */
 int _rl_term_autowrap;
 
 /* Non-zero means that this terminal has a meta key. */
 static int term_has_meta;
 
 /* The sequences to write to turn on and off the meta key, if this
-   terminal    has one. */
-static char *term_mm, *term_mo;
+   terminal has one. */
+static char *_rl_term_mm;
+static char *_rl_term_mo;
 
 /* The key sequences output by the arrow keys, if this terminal has any. */
-static char *term_ku, *term_kd, *term_kr, *term_kl;
+static char *_rl_term_ku;
+static char *_rl_term_kd;
+static char *_rl_term_kr;
+static char *_rl_term_kl;
 
 /* How to initialize and reset the arrow keys, if this terminal has any. */
-static char *term_ks, *term_ke;
+static char *_rl_term_ks;
+static char *_rl_term_ke;
 
 /* The key sequences sent by the Home and End keys, if any. */
-static char *term_kh, *term_kH;
+static char *_rl_term_kh;
+static char *_rl_term_kH;
 
 /* Variables that hold the screen dimensions, used by the display code. */
-int screenwidth, screenheight, screenchars;
+int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
 
 /* Non-zero means the user wants to enable the keypad. */
 int _rl_enable_keypad;
 
 /* Non-zero means the user wants to enable a meta key. */
 int _rl_enable_meta = 1;
 
+#if defined (__EMX__)
+static void
+_emx_get_screensize (swp, shp)
+     int *swp, *shp;
+{
+  int sz[2];
+
+  _scrsize (sz);
+
+  if (swp)
+    *swp = sz[0];
+  if (shp)
+    *shp = sz[1];
+}
+#endif
+
 /* Get readline's idea of the screen size.  TTY is a file descriptor open
    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
    non-null serve to check whether or not we have initialized termcap. */
 void
 _rl_get_screen_size (tty, ignore_env)
      int tty, ignore_env;
 {
   char *ss;
 #if defined (TIOCGWINSZ)
   struct winsize window_size;
 #endif /* TIOCGWINSZ */
-#if defined (__EMX__)
-  int sz[2];
-#endif
 
 #if defined (TIOCGWINSZ)
   if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
     {
-      screenwidth = (int) window_size.ws_col;
-      screenheight = (int) window_size.ws_row;
+      _rl_screenwidth = (int) window_size.ws_col;
+      _rl_screenheight = (int) window_size.ws_row;
     }
 #endif /* TIOCGWINSZ */
 
 #if defined (__EMX__)
-  _scrsize (sz);
-  screenwidth = sz[0];
-  screenheight = sz[1];
+  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
 #endif
 
   /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
      is unset. */
-  if (screenwidth <= 0)
+  if (_rl_screenwidth <= 0)
     {
-      if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
-	screenwidth = atoi (ss);
+      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
+	_rl_screenwidth = atoi (ss);
 
-      if (screenwidth <= 0 && term_string_buffer)
-	screenwidth = tgetnum ("co");
+#if !defined (__DJGPP__)
+      if (_rl_screenwidth <= 0 && term_string_buffer)
+	_rl_screenwidth = tgetnum ("co");
+#endif
     }
 
   /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
      is unset. */
-  if (screenheight <= 0)
+  if (_rl_screenheight <= 0)
     {
-      if (ignore_env == 0 && (ss = get_env_value ("LINES")))
-	screenheight = atoi (ss);
+      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
+	_rl_screenheight = atoi (ss);
 
-      if (screenheight <= 0 && term_string_buffer)
-	screenheight = tgetnum ("li");
+#if !defined (__DJGPP__)
+      if (_rl_screenheight <= 0 && term_string_buffer)
+	_rl_screenheight = tgetnum ("li");
+#endif
     }
 
   /* If all else fails, default to 80x24 terminal. */
-  if (screenwidth <= 1)
-    screenwidth = 80;
+  if (_rl_screenwidth <= 1)
+    _rl_screenwidth = 80;
 
-  if (screenheight <= 0)
-    screenheight = 24;
+  if (_rl_screenheight <= 0)
+    _rl_screenheight = 24;
 
   /* If we're being compiled as part of bash, set the environment
      variables $LINES and $COLUMNS to new values.  Otherwise, just
      do a pair of putenv () or setenv () calls. */
-  set_lines_and_columns (screenheight, screenwidth);
+  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
 
-  if (!_rl_term_autowrap)
-    screenwidth--;
+  if (_rl_term_autowrap == 0)
+    _rl_screenwidth--;
 
-  screenchars = screenwidth * screenheight;
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
 }
 
 void
 _rl_set_screen_size (rows, cols)
      int rows, cols;
 {
-  screenheight = rows;
-  screenwidth = cols;
+  _rl_screenheight = rows;
+  _rl_screenwidth = cols;
 
   if (_rl_term_autowrap == 0)
-    screenwidth--;
+    _rl_screenwidth--;
+
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+}
 
-  screenchars = screenwidth * screenheight;
+void
+rl_set_screen_size (rows, cols)
+     int rows, cols;
+{
+  _rl_set_screen_size (rows, cols);
+}
+
+void
+rl_get_screen_size (rows, cols)   
+     int *rows, *cols; 
+{
+  if (rows) 
+    *rows = _rl_screenheight;
+  if (cols)  
+    *cols = _rl_screenwidth;   
 }
 
 void
 rl_resize_terminal ()
 {
   if (readline_echoing_p)
     {
       _rl_get_screen_size (fileno (rl_instream), 1);
       _rl_redisplay_after_sigwinch ();
     }
 }
 
 struct _tc_string {
-     char *tc_var;
+     const char *tc_var;
      char **tc_value;
 };
 
 /* This should be kept sorted, just in case we decide to change the
    search algorithm to something smarter. */
 static struct _tc_string tc_strings[] =
 {
-  "DC", &term_DC,
-  "IC", &term_IC,
-  "ce", &term_clreol,
-  "cl", &term_clrpag,
-  "cr", &term_cr,
-  "dc", &term_dc,
-  "ei", &term_ei,
-  "ic", &term_ic,
-  "im", &term_im,
-  "kd", &term_kd,
-  "kh", &term_kh,	/* home */
-  "kH", &term_kH,	/* end */
-  "kl", &term_kl,
-  "kr", &term_kr,
-  "ku", &term_ku,
-  "ks", &term_ks,
-  "ke", &term_ke,
-  "le", &term_backspace,
-  "mm", &term_mm,
-  "mo", &term_mo,
+  { "DC", &_rl_term_DC },
+  { "IC", &_rl_term_IC },
+  { "ce", &_rl_term_clreol },
+  { "cl", &_rl_term_clrpag },
+  { "cr", &_rl_term_cr },
+  { "dc", &_rl_term_dc },
+  { "ei", &_rl_term_ei },
+  { "ic", &_rl_term_ic },
+  { "im", &_rl_term_im },
+  { "kd", &_rl_term_kd },
+  { "kh", &_rl_term_kh },	/* home */
+  { "kH", &_rl_term_kH },	/* end */
+  { "kl", &_rl_term_kl },
+  { "kr", &_rl_term_kr },
+  { "ku", &_rl_term_ku },
+  { "ks", &_rl_term_ks },
+  { "ke", &_rl_term_ke },
+  { "le", &_rl_term_backspace },
+  { "mm", &_rl_term_mm },
+  { "mo", &_rl_term_mo },
 #if defined (HACK_TERMCAP_MOTION)
-  "nd", &term_forward_char,
+  { "nd", &_rl_term_forward_char },
 #endif
-  "pc", &term_pc,
-  "up", &term_up,
-  "vb", &visible_bell,
+  { "pc", &_rl_term_pc },
+  { "up", &_rl_term_up },
+  { "vb", &_rl_visible_bell },
 };
 
 #define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))
 
 /* Read the desired terminal capability strings into BP.  The capabilities
    are described in the TC_STRINGS table. */
 static void
 get_term_capabilities (bp)
      char **bp;
 {
+#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
   register int i;
 
   for (i = 0; i < NUM_TC_STRINGS; i++)
     *(tc_strings[i].tc_value) = tgetstr (tc_strings[i].tc_var, bp);
+#endif
   tcap_initialized = 1;
 }
 
+#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
+#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
+
 int
 _rl_init_terminal_io (terminal_name)
-     char *terminal_name;
+     const char *terminal_name;
 {
-#if defined (__GO32__)
-  screenwidth = ScreenCols ();
-  screenheight = ScreenRows ();
-  screenchars = screenwidth * screenheight;
-  term_cr = "\r";
-  term_im = term_ei = term_ic = term_IC = (char *)NULL;
-  term_up = term_dc = term_DC = visible_bell = (char *)NULL;
-
-  /* Does the __GO32__ have a meta key?  I don't know. */
-  term_has_meta = 0;
-  term_mm = term_mo = (char *)NULL;
-
-  /* It probably has arrow keys, but I don't know what they are. */
-  term_ku = term_kd = term_kr = term_kl = (char *)NULL;
-
-#if defined (HACK_TERMCAP_MOTION)
-  term_forward_char = (char *)NULL;
-#endif /* HACK_TERMCAP_MOTION */
-  terminal_can_insert = _rl_term_autowrap = 0;
-  return;
-#else /* !__GO32__ */
-
-  char *term, *buffer;
-  int tty;
+  const char *term;
+  char *buffer;
+  int tty, tgetent_ret;
   Keymap xkeymap;
 
-  term = terminal_name ? terminal_name : get_env_value ("TERM");
-
-  if (term_string_buffer == 0)
-    term_string_buffer = xmalloc (2032);
-
-  if (term_buffer == 0)
-    term_buffer = xmalloc (4080);
-
-  buffer = term_string_buffer;
-
-  term_clrpag = term_cr = term_clreol = (char *)NULL;
+  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
+  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
+  tty = rl_instream ? fileno (rl_instream) : 0;
+  _rl_screenwidth = _rl_screenheight = 0;
 
   if (term == 0)
     term = "dumb";
 
-  if (tgetent (term_buffer, term) <= 0)
+  /* I've separated this out for later work on not calling tgetent at all
+     if the calling application has supplied a custom redisplay function,
+     (and possibly if the application has supplied a custom input function). */
+  if (CUSTOM_REDISPLAY_FUNC())
+    {
+      tgetent_ret = -1;
+    }
+  else
+    {
+      if (term_string_buffer == 0)
+	term_string_buffer = xmalloc(2032);
+
+      if (term_buffer == 0)
+	term_buffer = xmalloc(4080);
+
+      buffer = term_string_buffer;
+
+      tgetent_ret = tgetent (term_buffer, term);
+    }
+
+  if (tgetent_ret <= 0)
     {
-      dumb_term = 1;
-      screenwidth = 79;
-      screenheight = 24;
-      screenchars = 79 * 24;
-      term_cr = "\r";
-      term_im = term_ei = term_ic = term_IC = (char *)NULL;
-      term_up = term_dc = term_DC = visible_bell = (char *)NULL;
-      term_ku = term_kd = term_kl = term_kr = (char *)NULL;
+      FREE (term_string_buffer);
+      FREE (term_buffer);
+      buffer = term_buffer = term_string_buffer = (char *)NULL;
+
+      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */
+
+#if defined (__EMX__)
+      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
+      _rl_screenwidth--;
+#else /* !__EMX__ */
+      _rl_get_screen_size (tty, 0);
+#endif /* !__EMX__ */
+
+      /* Defaults. */
+      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
+        {
+	  _rl_screenwidth = 79;
+	  _rl_screenheight = 24;
+        }
+
+      /* Everything below here is used by the redisplay code (tputs). */
+      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+      _rl_term_cr = "\r";
+      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
+      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
+      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
+      _rl_term_mm = _rl_term_mo = (char *)NULL;
 #if defined (HACK_TERMCAP_MOTION)
       term_forward_char = (char *)NULL;
 #endif
-      terminal_can_insert = 0;
+      _rl_terminal_can_insert = term_has_meta = 0;
+
+      /* Reasonable defaults for tgoto().  Readline currently only uses
+         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
+         change that later... */
+      PC = '\0';
+      BC = _rl_term_backspace = "\b";
+      UP = _rl_term_up;
+
       return 0;
     }
 
   get_term_capabilities (&buffer);
 
   /* Set up the variables that the termcap library expects the application
      to provide. */
-  PC = term_pc ? *term_pc : 0;
-  BC = term_backspace;
-  UP = term_up;
+  PC = _rl_term_pc ? *_rl_term_pc : 0;
+  BC = _rl_term_backspace;
+  UP = _rl_term_up;
 
-  if (!term_cr)
-    term_cr = "\r";
-
-  tty = rl_instream ? fileno (rl_instream) : 0;
-
-  screenwidth = screenheight = 0;
+  if (!_rl_term_cr)
+    _rl_term_cr = "\r";
 
   _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
 
   _rl_get_screen_size (tty, 0);
 
   /* "An application program can assume that the terminal can do
       character insertion if *any one of* the capabilities `IC',
       `im', `ic' or `ip' is provided."  But we can't do anything if
       only `ip' is provided, so... */
-  terminal_can_insert = (term_IC || term_im || term_ic);
+  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
 
   /* Check to see if this terminal has a meta key and clear the capability
      variables if there is none. */
   term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
   if (!term_has_meta)
-    term_mm = term_mo = (char *)NULL;
+    _rl_term_mm = _rl_term_mo = (char *)NULL;
 
   /* Attempt to find and bind the arrow keys.  Do not override already
      bound keys in an overzealous attempt, however. */
   xkeymap = _rl_keymap;
 
   _rl_keymap = emacs_standard_keymap;
-  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (term_kr, rl_forward);
-  _rl_bind_if_unbound (term_kl, rl_backward);
+  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
+  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
 
-  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
 
 #if defined (VI_MODE)
   _rl_keymap = vi_movement_keymap;
-  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (term_kr, rl_forward);
-  _rl_bind_if_unbound (term_kl, rl_backward);
+  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
+  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
 
-  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
 #endif /* VI_MODE */
 
   _rl_keymap = xkeymap;
 
-#endif /* !__GO32__ */
   return 0;
 }
 
 char *
 rl_get_termcap (cap)
-     char *cap;
+     const char *cap;
 {
   register int i;
 
   if (tcap_initialized == 0)
     return ((char *)NULL);
   for (i = 0; i < NUM_TC_STRINGS; i++)
     {
       if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
@@ -432,123 +483,122 @@ rl_get_termcap (cap)
     }
   return ((char *)NULL);
 }
 
 /* Re-initialize the terminal considering that the TERM/TERMCAP variable
    has changed. */
 int
 rl_reset_terminal (terminal_name)
-     char *terminal_name;
+     const char *terminal_name;
 {
   _rl_init_terminal_io (terminal_name);
   return 0;
 }
 
 /* A function for the use of tputs () */
+#ifdef _MINIX
+void
+_rl_output_character_function (c)
+     int c;
+{
+  putc (c, _rl_out_stream);
+}
+#else /* !_MINIX */
 int
 _rl_output_character_function (c)
      int c;
 {
   return putc (c, _rl_out_stream);
 }
+#endif /* !_MINIX */
 
 /* Write COUNT characters from STRING to the output stream. */
 void
 _rl_output_some_chars (string, count)
-     char *string;
+     const char *string;
      int count;
 {
   fwrite (string, 1, count, _rl_out_stream);
 }
 
 /* Move the cursor back. */
 int
 _rl_backspace (count)
      int count;
 {
   register int i;
 
-#if !defined (__GO32__)
-  if (term_backspace)
+  if (_rl_term_backspace)
     for (i = 0; i < count; i++)
-      tputs (term_backspace, 1, _rl_output_character_function);
+      tputs (_rl_term_backspace, 1, _rl_output_character_function);
   else
-#endif /* !__GO32__ */
     for (i = 0; i < count; i++)
       putc ('\b', _rl_out_stream);
   return 0;
 }
 
 /* Move to the start of the next line. */
 int
-crlf ()
+rl_crlf ()
 {
 #if defined (NEW_TTY_DRIVER)
-  if (term_cr)
-    tputs (term_cr, 1, _rl_output_character_function);
+  if (_rl_term_cr)
+    tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif /* NEW_TTY_DRIVER */
   putc ('\n', _rl_out_stream);
   return 0;
 }
 
 /* Ring the terminal bell. */
 int
-ding ()
+rl_ding ()
 {
   if (readline_echoing_p)
     {
-#if !defined (__GO32__)
       switch (_rl_bell_preference)
         {
 	case NO_BELL:
 	default:
 	  break;
 	case VISIBLE_BELL:
-	  if (visible_bell)
+	  if (_rl_visible_bell)
 	    {
-	      tputs (visible_bell, 1, _rl_output_character_function);
+	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
 	      break;
 	    }
 	  /* FALLTHROUGH */
 	case AUDIBLE_BELL:
 	  fprintf (stderr, "\007");
 	  fflush (stderr);
 	  break;
         }
-#else /* __GO32__ */
-      fprintf (stderr, "\007");
-      fflush (stderr);
-#endif /* __GO32__ */
       return (0);
     }
   return (-1);
 }
 
 /* **************************************************************** */
 /*								    */
 /*	 	Controlling the Meta Key and Keypad		    */
 /*								    */
 /* **************************************************************** */
 
-static int
-outchar (c)
-     int c;
-{
-  return putc (c, rl_outstream);
-}
-
 void
 _rl_enable_meta_key ()
 {
-  if (term_has_meta && term_mm)
-    tputs (term_mm, 1, outchar);
+#if !defined (__DJGPP__)
+  if (term_has_meta && _rl_term_mm)
+    tputs (_rl_term_mm, 1, _rl_output_character_function);
+#endif
 }
 
 void
 _rl_control_keypad (on)
      int on;
 {
-  if (on && term_ks)
-    tputs (term_ks, 1, outchar);
-  else if (!on && term_ke)
-    tputs (term_ke, 1, outchar);
+#if !defined (__DJGPP__)
+  if (on && _rl_term_ks)
+    tputs (_rl_term_ks, 1, _rl_output_character_function);
+  else if (!on && _rl_term_ke)
+    tputs (_rl_term_ke, 1, _rl_output_character_function);
+#endif
 }
diff --git a/readline/tilde.c b/readline/tilde.c
--- a/readline/tilde.c
+++ b/readline/tilde.c
@@ -2,33 +2,36 @@
 
 /* Copyright (C) 1988,1989 Free Software Foundation, Inc.
 
    This file is part of GNU Readline, a library for reading lines
    of text with interactive input and history editing.
 
    Readline is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 1, or (at your option) any
+   Free Software Foundation; either version 2, or (at your option) any
    later version.
 
    Readline is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with Readline; see the file COPYING.  If not, write to the Free
    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
 
 #if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
 #  include <unistd.h>
 #endif
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
 #else /* !HAVE_STRING_H */
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */  
@@ -39,90 +42,95 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
 #include <sys/types.h>
 #include <pwd.h>
 
 #include "tilde.h"
 
-#ifdef SHELL
-#include "shell.h"
-#endif
+#if defined (TEST) || defined (STATIC_MALLOC)
+static char *xmalloc (), *xrealloc ();
+#else
+extern char *xmalloc __P((int));
+extern char *xrealloc __P((void *, int));
+#endif /* TEST || STATIC_MALLOC */
 
 #if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid (), *getpwnam ();
+extern struct passwd *getpwuid __P((uid_t));
+extern struct passwd *getpwnam __P((const char *));
 #endif /* !HAVE_GETPW_DECLS */
 
 #if !defined (savestring)
-extern char *xmalloc ();
 #  ifndef strcpy
 extern char *strcpy ();
 #  endif
 #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
 #endif /* !savestring */
 
 #if !defined (NULL)
 #  if defined (__STDC__)
 #    define NULL ((void *) 0)
 #  else
 #    define NULL 0x0
 #  endif /* !__STDC__ */
 #endif /* !NULL */
 
-#if defined (TEST) || defined (STATIC_MALLOC)
-static char *xmalloc (), *xrealloc ();
-#else
-extern char *xmalloc (), *xrealloc ();
-#endif /* TEST || STATIC_MALLOC */
+/* If being compiled as part of bash, these will be satisfied from
+   variables.o.  If being compiled as part of readline, they will
+   be satisfied from shell.o. */
+extern char *sh_get_home_dir __P((void));
+extern char *sh_get_env_value __P((const char *));
 
 /* The default value of tilde_additional_prefixes.  This is set to
    whitespace preceding a tilde so that simple programs which do not
    perform any word separation get desired behaviour. */
-static char *default_prefixes[] =
-  { " ~", "\t~", (char *)NULL };
+static const char *default_prefixes[] =
+  { " ~", "\t~", (const char *)NULL };
 
 /* The default value of tilde_additional_suffixes.  This is set to
    whitespace or newline so that simple programs which do not
    perform any word separation get desired behaviour. */
-static char *default_suffixes[] =
-  { " ", "\n", (char *)NULL };
+static const char *default_suffixes[] =
+  { " ", "\n", (const char *)NULL };
 
 /* If non-null, this contains the address of a function that the application
    wants called before trying the standard tilde expansions.  The function
    is called with the text sans tilde, and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if the expansion fails. */
-CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
+tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
 
 /* If non-null, this contains the address of a function to call if the
    standard meaning for expanding a tilde fails.  The function is called
    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if there is no expansion. */
-CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
+tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
 
 /* When non-null, this is a NULL terminated array of strings which
    are duplicates for a tilde prefix.  Bash uses this to expand
    `=~' and `:~'. */
-char **tilde_additional_prefixes = default_prefixes;
+char **tilde_additional_prefixes = (char **)default_prefixes;
 
 /* When non-null, this is a NULL terminated array of strings which match
    the end of a username, instead of just "/".  Bash sets this to
    `:' and `=~'. */
-char **tilde_additional_suffixes = default_suffixes;
+char **tilde_additional_suffixes = (char **)default_suffixes;
 
 /* Find the start of a tilde expansion in STRING, and return the index of
    the tilde which starts the expansion.  Place the length of the text
    which identified this tilde starter in LEN, excluding the tilde itself. */
 static int
 tilde_find_prefix (string, len)
      char *string;
      int *len;
 {
   register int i, j, string_len;
-  register char **prefixes = tilde_additional_prefixes;
+  register char **prefixes;
+
+  prefixes = tilde_additional_prefixes;
 
   string_len = strlen (string);
   *len = 0;
 
   if (*string == '\0' || *string == '~')
     return (0);
 
   if (prefixes)
@@ -151,50 +159,45 @@ tilde_find_suffix (string)
   register int i, j, string_len;
   register char **suffixes;
 
   suffixes = tilde_additional_suffixes;
   string_len = strlen (string);
 
   for (i = 0; i < string_len; i++)
     {
+#if defined (__MSDOS__)
+      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
+#else
       if (string[i] == '/' /* || !string[i] */)
+#endif
 	break;
 
       for (j = 0; suffixes && suffixes[j]; j++)
 	{
 	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
 	    return (i);
 	}
     }
   return (i);
 }
 
-#if !defined (SHELL)
-static char *
-get_string_value (varname)
-     char *varname;
-{
-  return ((char *)getenv (varname));
-}
-#endif
-
 /* Return a new string which is the result of tilde expanding STRING. */
 char *
 tilde_expand (string)
-     char *string;
+     const char *string;
 {
   char *result;
   int result_size, result_index;
 
   result_index = result_size = 0;
   if (result = strchr (string, '~'))
     result = xmalloc (result_size = (strlen (string) + 16));
   else
-    result = xmalloc (result_size = strlen (string));
+    result = xmalloc (result_size = (strlen (string) + 1));
 
   /* Scan through STRING expanding tildes as we come to them. */
   while (1)
     {
       register int start, end;
       char *tilde_word, *expansion;
       int len;
 
@@ -224,21 +227,28 @@ tilde_expand (string)
       strncpy (tilde_word, string, end);
       tilde_word[end] = '\0';
       string += end;
 
       expansion = tilde_expand_word (tilde_word);
       free (tilde_word);
 
       len = strlen (expansion);
-      if ((result_index + len + 1) > result_size)
-	result = xrealloc (result, 1 + (result_size += (len + 20)));
+#ifdef __CYGWIN__
+      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
+         $HOME for `user' is /.  On cygwin, // denotes a network drive. */
+      if (len > 1 || *expansion != '/' || *string != '/')
+#endif
+	{
+	  if ((result_index + len + 1) > result_size)
+	    result = xrealloc (result, 1 + (result_size += (len + 20)));
 
-      strcpy (result + result_index, expansion);
-      result_index += len;
+	  strcpy (result + result_index, expansion);
+	  result_index += len;
+	}
       free (expansion);
     }
 
   result[result_index] = '\0';
 
   return (result);
 }
 
@@ -249,17 +259,21 @@ static char *
 isolate_tilde_prefix (fname, lenp)
      char *fname;
      int *lenp;
 {
   char *ret;
   int i;
 
   ret = xmalloc (strlen (fname));
+#if defined (__MSDOS__)
+  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
+#else
   for (i = 1; fname[i] && fname[i] != '/'; i++)
+#endif
     ret[i - 1] = fname[i];
   ret[i - 1] = '\0';
   if (lenp)
     *lenp = i;
   return ret;
 }
 
 /* Return a string that is PREFIX concatenated with SUFFIX starting at
@@ -270,49 +284,28 @@ glue_prefix_and_suffix (prefix, suffix, 
      int suffind;
 {
   char *ret;
   int plen, slen;
 
   plen = (prefix && *prefix) ? strlen (prefix) : 0;
   slen = strlen (suffix + suffind);
   ret = xmalloc (plen + slen + 1);
-  if (prefix && *prefix)
+  if (plen)
     strcpy (ret, prefix);
   strcpy (ret + plen, suffix + suffind);
   return ret;
 }
 
-static char *
-get_home_dir ()
-{
-  char *home_dir;
-
-#ifdef SHELL
-  home_dir = (char *)NULL;
-  if (current_user.home_dir == 0)
-    get_current_user_info ();
-  home_dir = current_user.home_dir;
-#else
-  struct passwd *entry;
-
-  home_dir = (char *)NULL;
-  entry = getpwuid (getuid ());
-  if (entry)
-    home_dir = entry->pw_dir;
-#endif
-  return (home_dir);
-}
-
 /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
    tilde.  If there is no expansion, call tilde_expansion_failure_hook.
    This always returns a newly-allocated string, never static storage. */
 char *
 tilde_expand_word (filename)
-     char *filename;
+     const char *filename;
 {
   char *dirname, *expansion, *username;
   int user_len;
   struct passwd *user_entry;
 
   if (filename == 0)
     return ((char *)NULL);
 
@@ -320,22 +313,22 @@ tilde_expand_word (filename)
     return (savestring (filename));
 
   /* A leading `~/' or a bare `~' is *always* translated to the value of
      $HOME or the home directory of the current user, regardless of any
      preexpansion hook. */
   if (filename[1] == '\0' || filename[1] == '/')
     {
       /* Prefix $HOME to the rest of the string. */
-      expansion = get_string_value ("HOME");
+      expansion = sh_get_env_value ("HOME");
 
       /* If there is no HOME variable, look up the directory in
 	 the password database. */
       if (expansion == 0)
-	expansion = get_home_dir ();
+	expansion = sh_get_home_dir ();
 
       return (glue_prefix_and_suffix (expansion, filename, 1));
     }
 
   username = isolate_tilde_prefix (filename, &user_len);
 
   if (tilde_expansion_preexpansion_hook)
     {
diff --git a/readline/tilde.h b/readline/tilde.h
--- a/readline/tilde.h
+++ b/readline/tilde.h
@@ -3,63 +3,88 @@
 /* Copyright (C) 1992 Free Software Foundation, Inc.
 
    This file contains the Readline Library (the Library), a set of
    routines for providing Emacs style line input to programs that ask
    for it.
 
    The Library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    The Library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
    is generally kept in a file called COPYING or LICENSE.  If you do not
    have a copy of the license, write to the Free Software Foundation,
    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
 #if !defined (_TILDE_H_)
 #  define _TILDE_H_
 
-/* Function pointers can be declared as (Function *)foo. */
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-#endif /* _FUNCTION_DEF */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* A function can be defined using prototypes and compile on both ANSI C
+   and traditional C compilers with something like this:
+	extern char *func __P((char *, char *, int)); */
+
+#if !defined (__P)
+#  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
+#    define __P(protos) protos
+#  else
+#    define __P(protos) ()
+#  endif
+#endif
+
+#if !defined (__STDC__) && !defined (__cplusplus)
+#  if defined (__GNUC__)	/* gcc with -traditional */
+#    if !defined (const)
+#      define const __const
+#    endif /* !const */
+#  else /* !__GNUC__ */
+#    if !defined (const)
+#      define const
+#    endif /* !const */
+#  endif /* !__GNUC__ */
+#endif /* !__STDC__ && !__cplusplus */
+
+typedef char *tilde_hook_func_t __P((char *));
 
 /* If non-null, this contains the address of a function that the application
    wants called before trying the standard tilde expansions.  The function
    is called with the text sans tilde, and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if the expansion fails. */
-extern CPFunction *tilde_expansion_preexpansion_hook;
+extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
 
 /* If non-null, this contains the address of a function to call if the
    standard meaning for expanding a tilde fails.  The function is called
    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if there is no expansion. */
-extern CPFunction *tilde_expansion_failure_hook;
+extern tilde_hook_func_t *tilde_expansion_failure_hook;
 
 /* When non-null, this is a NULL terminated array of strings which
    are duplicates for a tilde prefix.  Bash uses this to expand
    `=~' and `:~'. */
 extern char **tilde_additional_prefixes;
 
 /* When non-null, this is a NULL terminated array of strings which match
    the end of a username, instead of just "/".  Bash sets this to
    `:' and `=~'. */
 extern char **tilde_additional_suffixes;
 
 /* Return a new string which is the result of tilde expanding STRING. */
-extern char *tilde_expand ();
+extern char *tilde_expand __P((const char *));
 
 /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
-extern char *tilde_expand_word ();
+extern char *tilde_expand_word __P((const char *));
+
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* _TILDE_H_ */
diff --git a/readline/undo.c b/readline/undo.c
--- a/readline/undo.c
+++ b/readline/undo.c
@@ -3,17 +3,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -42,16 +42,18 @@
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
 /* Some standard library routines. */
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+
 #define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
 
 /* Non-zero tells rl_delete_text and rl_insert_text to not add to
    the undo list. */
 int _rl_doing_an_undo = 0;
 
 /* How many unclosed undo groups we currently have. */
 int _rl_undo_group_level = 0;
@@ -79,17 +81,17 @@ rl_add_undo (what, start, end, text)
   temp->end = end;
   temp->text = text;
   temp->next = rl_undo_list;
   rl_undo_list = temp;
 }
 
 /* Free the existing undo list. */
 void
-free_undo_list ()
+rl_free_undo_list ()
 {
   while (rl_undo_list)
     {
       UNDO_LIST *release = rl_undo_list;
       rl_undo_list = rl_undo_list->next;
 
       if (release->what == UNDO_DELETE)
 	free (release->text);
@@ -111,16 +113,17 @@ rl_do_undo ()
 #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
 
   do
     {
       if (!rl_undo_list)
 	return (0);
 
       _rl_doing_an_undo = 1;
+      RL_SETSTATE(RL_STATE_UNDOING);
 
       /* To better support vi-mode, a start or end value of -1 means
 	 rl_point, and a value of -2 means rl_end. */
       if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)
 	{
 	  start = TRANS (rl_undo_list->start);
 	  end = TRANS (rl_undo_list->end);
 	}
@@ -145,21 +148,22 @@ rl_do_undo ()
 	  waiting_for_begin++;
 	  break;
 
 	/* Undoing a BEGIN means that we are done with this group. */
 	case UNDO_BEGIN:
 	  if (waiting_for_begin)
 	    waiting_for_begin--;
 	  else
-	    ding ();
+	    rl_ding ();
 	  break;
 	}
 
       _rl_doing_an_undo = 0;
+      RL_UNSETSTATE(RL_STATE_UNDOING);
 
       release = rl_undo_list;
       rl_undo_list = rl_undo_list->next;
       free (release);
     }
   while (waiting_for_begin);
 
   return (1);
@@ -224,17 +228,17 @@ rl_modifying (start, end)
 }
 
 /* Revert the current line to its previous state. */
 int
 rl_revert_line (count, key)
      int count, key;
 {
   if (!rl_undo_list)
-    ding ();
+    rl_ding ();
   else
     {
       while (rl_undo_list)
 	rl_do_undo ();
     }
   return 0;
 }
 
@@ -247,14 +251,14 @@ rl_undo_command (count, key)
     return 0;	/* Nothing to do. */
 
   while (count)
     {
       if (rl_do_undo ())
 	count--;
       else
 	{
-	  ding ();
+	  rl_ding ();
 	  break;
 	}
     }
   return 0;
 }
diff --git a/readline/util.c b/readline/util.c
--- a/readline/util.c
+++ b/readline/util.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -47,71 +47,58 @@
 
 #if defined (TIOCSTAT_IN_SYS_IOCTL)
 #  include <sys/ioctl.h>
 #endif /* TIOCSTAT_IN_SYS_IOCTL */
 
 /* Some standard library routines. */
 #include "readline.h"
 
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* Pseudo-globals imported from readline.c */
-extern int readline_echoing_p;
-extern procenv_t readline_top_level;
-extern int rl_line_buffer_len;
-extern Function *rl_last_func;
+#include "rlprivate.h"
+#include "xmalloc.h"
 
-extern int _rl_defining_kbd_macro;
-extern char *_rl_executing_macro;
-
-/* Pseudo-global functions imported from other library files. */
-extern void _rl_pop_executing_macro ();
-extern void _rl_set_the_line ();
-extern void _rl_init_argument ();
-
-extern char *xmalloc (), *xrealloc ();
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
 
 /* **************************************************************** */
 /*								    */
 /*			Utility Functions			    */
 /*								    */
 /* **************************************************************** */
 
 /* Return 0 if C is not a member of the class of characters that belong
    in words, or 1 if it is. */
 
 int _rl_allow_pathname_alphabetic_chars = 0;
-static char *pathname_alphabetic_chars = "/-_=~.#$";
+static const char *pathname_alphabetic_chars = "/-_=~.#$";
 
 int
-alphabetic (c)
+rl_alphabetic (c)
      int c;
 {
   if (ALPHABETIC (c))
     return (1);
 
   return (_rl_allow_pathname_alphabetic_chars &&
 	    strchr (pathname_alphabetic_chars, c) != NULL);
 }
 
 /* How to abort things. */
 int
 _rl_abort_internal ()
 {
-  ding ();
+  rl_ding ();
   rl_clear_message ();
   _rl_init_argument ();
-  rl_pending_input = 0;
+  rl_clear_pending_input ();
 
   _rl_defining_kbd_macro = 0;
-  while (_rl_executing_macro)
+  while (rl_executing_macro)
     _rl_pop_executing_macro ();
 
-  rl_last_func = (Function *)NULL;
+  rl_last_func = (rl_command_func_t *)NULL;
   longjmp (readline_top_level, 1);
   return (0);
 }
 
 int
 rl_abort (count, key)
      int count, key;
 {
@@ -119,19 +106,19 @@ rl_abort (count, key)
 }
 
 int
 rl_tty_status (count, key)
      int count, key;
 {
 #if defined (TIOCSTAT)
   ioctl (1, TIOCSTAT, (char *)0);
-  rl_refresh_line ();
+  rl_refresh_line (count, key);
 #else
-  ding ();
+  rl_ding ();
 #endif
   return 0;
 }
 
 /* Return a copy of the string between FROM and TO.
    FROM is inclusive, TO is not. */
 char *
 rl_copy_text (from, to)
@@ -161,33 +148,85 @@ rl_extend_line_buffer (len)
     {
       rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
       rl_line_buffer = xrealloc (rl_line_buffer, rl_line_buffer_len);
     }
 
   _rl_set_the_line ();
 }
 
+
+/* A function for simple tilde expansion. */
+int
+rl_tilde_expand (ignore, key)
+     int ignore, key;
+{
+  register int start, end;
+  char *homedir, *temp;
+  int len;
+
+  end = rl_point;
+  start = end - 1;
+
+  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
+    {
+      homedir = tilde_expand ("~");
+      _rl_replace_text (homedir, start, end);
+      return (0);
+    }
+  else if (rl_line_buffer[start] != '~')
+    {
+      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
+        ;
+      start++;
+    }
+
+  end = start;
+  do
+    end++;
+  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);
+
+  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
+    end--;
+
+  /* If the first character of the current word is a tilde, perform
+     tilde expansion and insert the result.  If not a tilde, do
+     nothing. */
+  if (rl_line_buffer[start] == '~')
+    {
+      len = end - start + 1;
+      temp = xmalloc (len + 1);
+      strncpy (temp, rl_line_buffer + start, len);
+      temp[len] = '\0';
+      homedir = tilde_expand (temp);
+      free (temp);
+
+      _rl_replace_text (homedir, start, end);
+    }
+
+  return (0);
+}
+
 /* **************************************************************** */
 /*								    */
 /*			String Utility Functions		    */
 /*								    */
 /* **************************************************************** */
 
 /* Determine if s2 occurs in s1.  If so, return a pointer to the
    match in s1.  The compare is case insensitive. */
 char *
 _rl_strindex (s1, s2)
-     register char *s1, *s2;
+     register const char *s1, *s2;
 {
   register int i, l, len;
 
   for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
     if (_rl_strnicmp (s1 + i, s2, l) == 0)
-      return (s1 + i);
+      return ((char *) (s1 + i));
   return ((char *)NULL);
 }
 
 #if !defined (HAVE_STRCASECMP)
 /* Compare at most COUNT characters from string1 to string2.  Case
    doesn't matter. */
 int
 _rl_strnicmp (string1, string2, count)
@@ -295,8 +334,18 @@ int
 
 #undef _rl_digit_value
 int
 _rl_digit_value (c)
      int c;
 {
   return (isdigit (c) ? c - '0' : c);
 }
+
+/* Backwards compatibility, now that savestring has been removed from
+   all `public' readline header files. */
+#undef _rl_savestring
+char *
+_rl_savestring (s)
+     const char *s;
+{
+  return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
+}
diff --git a/readline/vi_keymap.c b/readline/vi_keymap.c
--- a/readline/vi_keymap.c
+++ b/readline/vi_keymap.c
@@ -2,17 +2,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -28,439 +28,439 @@
 
 #if 0
 extern KEYMAP_ENTRY_ARRAY vi_escape_keymap;
 #endif
 
 /* The keymap arrays for handling vi mode. */
 KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
-  { ISFUNC, rl_emacs_editing_mode },	/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, rl_backward },		/* Control-h */
-  { ISFUNC, (Function *)0x0 },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, rl_clear_screen },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_get_next_history },	/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },	/* Control-p */
-  { ISFUNC, rl_quoted_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISFUNC, (Function *)0x0 },		/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
+  { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, rl_backward },			/* Control-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, rl_clear_screen },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_get_next_history },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },		/* Control-p */
+  { ISFUNC, rl_quoted_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
 
-  { ISFUNC, (Function *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_forward },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, rl_insert_comment },	/* # */
-  { ISFUNC, rl_end_of_line },		/* $ */
-  { ISFUNC, rl_vi_match },		/* % */
-  { ISFUNC, rl_vi_tilde_expand },	/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, (Function *)0x0 },		/* ( */
-  { ISFUNC, (Function *)0x0 },		/* ) */
-  { ISFUNC, rl_vi_complete },		/* * */
-  { ISFUNC, rl_get_next_history},	/* + */
-  { ISFUNC, rl_vi_char_search },	/* , */
-  { ISFUNC, rl_get_previous_history },	/* - */
-  { ISFUNC, rl_vi_redo },		/* . */
-  { ISFUNC, rl_vi_search },		/* / */
+  { ISFUNC, rl_forward },			/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, rl_insert_comment },		/* # */
+  { ISFUNC, rl_end_of_line },			/* $ */
+  { ISFUNC, rl_vi_match },			/* % */
+  { ISFUNC, rl_vi_tilde_expand },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
+  { ISFUNC, rl_vi_complete },			/* * */
+  { ISFUNC, rl_get_next_history},		/* + */
+  { ISFUNC, rl_vi_char_search },		/* , */
+  { ISFUNC, rl_get_previous_history },		/* - */
+  { ISFUNC, rl_vi_redo },			/* . */
+  { ISFUNC, rl_vi_search },			/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_beg_of_line },		/* 0 */
-  { ISFUNC, rl_vi_arg_digit },		/* 1 */
-  { ISFUNC, rl_vi_arg_digit },		/* 2 */
-  { ISFUNC, rl_vi_arg_digit },		/* 3 */
-  { ISFUNC, rl_vi_arg_digit },		/* 4 */
-  { ISFUNC, rl_vi_arg_digit },		/* 5 */
-  { ISFUNC, rl_vi_arg_digit },		/* 6 */
-  { ISFUNC, rl_vi_arg_digit },		/* 7 */
-  { ISFUNC, rl_vi_arg_digit },		/* 8 */
-  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+  { ISFUNC, rl_beg_of_line },			/* 0 */
+  { ISFUNC, rl_vi_arg_digit },			/* 1 */
+  { ISFUNC, rl_vi_arg_digit },			/* 2 */
+  { ISFUNC, rl_vi_arg_digit },			/* 3 */
+  { ISFUNC, rl_vi_arg_digit },			/* 4 */
+  { ISFUNC, rl_vi_arg_digit },			/* 5 */
+  { ISFUNC, rl_vi_arg_digit },			/* 6 */
+  { ISFUNC, rl_vi_arg_digit },			/* 7 */
+  { ISFUNC, rl_vi_arg_digit },			/* 8 */
+  { ISFUNC, rl_vi_arg_digit },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* : */
-  { ISFUNC, rl_vi_char_search },	/* ; */
-  { ISFUNC, (Function *)0x0 },		/* < */
-  { ISFUNC, rl_vi_complete },		/* = */
-  { ISFUNC, (Function *)0x0 },		/* > */
-  { ISFUNC, rl_vi_search },		/* ? */
-  { ISFUNC, (Function *)0x0 },		/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, rl_vi_char_search },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, rl_vi_complete },			/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, rl_vi_search },			/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_vi_append_eol },		/* A */
-  { ISFUNC, rl_vi_prev_word},		/* B */
-  { ISFUNC, rl_vi_change_to },		/* C */
-  { ISFUNC, rl_vi_delete_to },		/* D */
-  { ISFUNC, rl_vi_end_word },		/* E */
-  { ISFUNC, rl_vi_char_search },	/* F */
-  { ISFUNC, rl_vi_fetch_history },	/* G */
-  { ISFUNC, (Function *)0x0 },		/* H */
-  { ISFUNC, rl_vi_insert_beg },		/* I */
-  { ISFUNC, (Function *)0x0 },		/* J */
-  { ISFUNC, (Function *)0x0 },		/* K */
-  { ISFUNC, (Function *)0x0 },		/* L */
-  { ISFUNC, (Function *)0x0 },		/* M */
-  { ISFUNC, rl_vi_search_again },	/* N */
-  { ISFUNC, (Function *)0x0 },		/* O */
-  { ISFUNC, rl_vi_put },		/* P */
-  { ISFUNC, (Function *)0x0 },		/* Q */
-  { ISFUNC, rl_vi_replace },		/* R */
-  { ISFUNC, rl_vi_subst },		/* S */
-  { ISFUNC, rl_vi_char_search },	/* T */
-  { ISFUNC, rl_revert_line },		/* U */
-  { ISFUNC, (Function *)0x0 },		/* V */
-  { ISFUNC, rl_vi_next_word },		/* W */
-  { ISFUNC, rl_rubout },		/* X */
-  { ISFUNC, rl_vi_yank_to },		/* Y */
-  { ISFUNC, (Function *)0x0 },		/* Z */
+  { ISFUNC, rl_vi_append_eol },			/* A */
+  { ISFUNC, rl_vi_prev_word},			/* B */
+  { ISFUNC, rl_vi_change_to },			/* C */
+  { ISFUNC, rl_vi_delete_to },			/* D */
+  { ISFUNC, rl_vi_end_word },			/* E */
+  { ISFUNC, rl_vi_char_search },		/* F */
+  { ISFUNC, rl_vi_fetch_history },		/* G */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* H */
+  { ISFUNC, rl_vi_insert_beg },			/* I */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* J */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* K */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* L */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* M */
+  { ISFUNC, rl_vi_search_again },		/* N */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* O */
+  { ISFUNC, rl_vi_put },			/* P */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Q */
+  { ISFUNC, rl_vi_replace },			/* R */
+  { ISFUNC, rl_vi_subst },			/* S */
+  { ISFUNC, rl_vi_char_search },		/* T */
+  { ISFUNC, rl_revert_line },			/* U */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* V */
+  { ISFUNC, rl_vi_next_word },			/* W */
+  { ISFUNC, rl_rubout },			/* X */
+  { ISFUNC, rl_vi_yank_to },			/* Y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* [ */
-  { ISFUNC, rl_vi_complete },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, rl_vi_first_print },	/* ^ */
-  { ISFUNC, rl_vi_yank_arg },		/* _ */
-  { ISFUNC, rl_vi_goto_mark },		/* ` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
+  { ISFUNC, rl_vi_complete },			/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, rl_vi_first_print },		/* ^ */
+  { ISFUNC, rl_vi_yank_arg },			/* _ */
+  { ISFUNC, rl_vi_goto_mark },			/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_vi_append_mode },	/* a */
-  { ISFUNC, rl_vi_prev_word },		/* b */
-  { ISFUNC, rl_vi_change_to },		/* c */
-  { ISFUNC, rl_vi_delete_to },		/* d */
-  { ISFUNC, rl_vi_end_word },		/* e */
-  { ISFUNC, rl_vi_char_search },	/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, rl_backward },		/* h */
-  { ISFUNC, rl_vi_insertion_mode },	/* i */
-  { ISFUNC, rl_get_next_history },	/* j */
-  { ISFUNC, rl_get_previous_history },	/* k */
-  { ISFUNC, rl_forward },		/* l */
-  { ISFUNC, rl_vi_set_mark },		/* m */
-  { ISFUNC, rl_vi_search_again },	/* n */
-  { ISFUNC, (Function *)0x0 },		/* o */
-  { ISFUNC, rl_vi_put },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, rl_vi_change_char },	/* r */
-  { ISFUNC, rl_vi_subst },		/* s */
-  { ISFUNC, rl_vi_char_search },	/* t */
-  { ISFUNC, rl_vi_undo },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, rl_vi_next_word },		/* w */
-  { ISFUNC, rl_vi_delete },		/* x */
-  { ISFUNC, rl_vi_yank_to },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, rl_vi_append_mode },		/* a */
+  { ISFUNC, rl_vi_prev_word },			/* b */
+  { ISFUNC, rl_vi_change_to },			/* c */
+  { ISFUNC, rl_vi_delete_to },			/* d */
+  { ISFUNC, rl_vi_end_word },			/* e */
+  { ISFUNC, rl_vi_char_search },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, rl_backward },			/* h */
+  { ISFUNC, rl_vi_insertion_mode },		/* i */
+  { ISFUNC, rl_get_next_history },		/* j */
+  { ISFUNC, rl_get_previous_history },		/* k */
+  { ISFUNC, rl_forward },			/* l */
+  { ISFUNC, rl_vi_set_mark },			/* m */
+  { ISFUNC, rl_vi_search_again },		/* n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
+  { ISFUNC, rl_vi_put },			/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, rl_vi_change_char },		/* r */
+  { ISFUNC, rl_vi_subst },			/* s */
+  { ISFUNC, rl_vi_char_search },		/* t */
+  { ISFUNC, rl_vi_undo },			/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, rl_vi_next_word },			/* w */
+  { ISFUNC, rl_vi_delete },			/* x */
+  { ISFUNC, rl_vi_yank_to },			/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, rl_vi_column },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, rl_vi_change_case },	/* ~ */
-  { ISFUNC, (Function *)0x0 },		/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, rl_vi_column },			/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, rl_vi_change_case },		/* ~ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 
 KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, rl_insert },		/* Control-a */
-  { ISFUNC, rl_insert },		/* Control-b */
-  { ISFUNC, rl_insert },		/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
-  { ISFUNC, rl_insert },		/* Control-e */
-  { ISFUNC, rl_insert },		/* Control-f */
-  { ISFUNC, rl_insert },		/* Control-g */
-  { ISFUNC, rl_rubout },		/* Control-h */
-  { ISFUNC, rl_complete },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_insert },		/* Control-k */
-  { ISFUNC, rl_insert },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_insert },		/* Control-n */
-  { ISFUNC, rl_insert },		/* Control-o */
-  { ISFUNC, rl_insert },		/* Control-p */
-  { ISFUNC, rl_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISFUNC, rl_insert },		/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, rl_insert },		/* Control-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, rl_insert },			/* Control-a */
+  { ISFUNC, rl_insert },			/* Control-b */
+  { ISFUNC, rl_insert },			/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
+  { ISFUNC, rl_insert },			/* Control-e */
+  { ISFUNC, rl_insert },			/* Control-f */
+  { ISFUNC, rl_insert },			/* Control-g */
+  { ISFUNC, rl_rubout },			/* Control-h */
+  { ISFUNC, rl_complete },			/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_insert },			/* Control-k */
+  { ISFUNC, rl_insert },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_insert },			/* Control-n */
+  { ISFUNC, rl_insert },			/* Control-o */
+  { ISFUNC, rl_insert },			/* Control-p */
+  { ISFUNC, rl_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISFUNC, rl_insert },			/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, rl_insert },			/* Control-z */
 
-  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
-  { ISFUNC, rl_insert },		/* Control-\ */
-  { ISFUNC, rl_insert },		/* Control-] */
-  { ISFUNC, rl_insert },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
+  { ISFUNC, rl_insert },			/* Control-\ */
+  { ISFUNC, rl_insert },			/* Control-] */
+  { ISFUNC, rl_insert },			/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_insert },		/* SPACE */
-  { ISFUNC, rl_insert },		/* ! */
-  { ISFUNC, rl_insert },		/* " */
-  { ISFUNC, rl_insert },		/* # */
-  { ISFUNC, rl_insert },		/* $ */
-  { ISFUNC, rl_insert },		/* % */
-  { ISFUNC, rl_insert },		/* & */
-  { ISFUNC, rl_insert },		/* ' */
-  { ISFUNC, rl_insert },		/* ( */
-  { ISFUNC, rl_insert },		/* ) */
-  { ISFUNC, rl_insert },		/* * */
-  { ISFUNC, rl_insert },		/* + */
-  { ISFUNC, rl_insert },		/* , */
-  { ISFUNC, rl_insert },		/* - */
-  { ISFUNC, rl_insert },		/* . */
-  { ISFUNC, rl_insert },		/* / */
+  { ISFUNC, rl_insert },			/* SPACE */
+  { ISFUNC, rl_insert },			/* ! */
+  { ISFUNC, rl_insert },			/* " */
+  { ISFUNC, rl_insert },			/* # */
+  { ISFUNC, rl_insert },			/* $ */
+  { ISFUNC, rl_insert },			/* % */
+  { ISFUNC, rl_insert },			/* & */
+  { ISFUNC, rl_insert },			/* ' */
+  { ISFUNC, rl_insert },			/* ( */
+  { ISFUNC, rl_insert },			/* ) */
+  { ISFUNC, rl_insert },			/* * */
+  { ISFUNC, rl_insert },			/* + */
+  { ISFUNC, rl_insert },			/* , */
+  { ISFUNC, rl_insert },			/* - */
+  { ISFUNC, rl_insert },			/* . */
+  { ISFUNC, rl_insert },			/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_insert },		/* 0 */
-  { ISFUNC, rl_insert },		/* 1 */
-  { ISFUNC, rl_insert },		/* 2 */
-  { ISFUNC, rl_insert },		/* 3 */
-  { ISFUNC, rl_insert },		/* 4 */
-  { ISFUNC, rl_insert },		/* 5 */
-  { ISFUNC, rl_insert },		/* 6 */
-  { ISFUNC, rl_insert },		/* 7 */
-  { ISFUNC, rl_insert },		/* 8 */
-  { ISFUNC, rl_insert },		/* 9 */
+  { ISFUNC, rl_insert },			/* 0 */
+  { ISFUNC, rl_insert },			/* 1 */
+  { ISFUNC, rl_insert },			/* 2 */
+  { ISFUNC, rl_insert },			/* 3 */
+  { ISFUNC, rl_insert },			/* 4 */
+  { ISFUNC, rl_insert },			/* 5 */
+  { ISFUNC, rl_insert },			/* 6 */
+  { ISFUNC, rl_insert },			/* 7 */
+  { ISFUNC, rl_insert },			/* 8 */
+  { ISFUNC, rl_insert },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, rl_insert },		/* : */
-  { ISFUNC, rl_insert },		/* ; */
-  { ISFUNC, rl_insert },		/* < */
-  { ISFUNC, rl_insert },		/* = */
-  { ISFUNC, rl_insert },		/* > */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* @ */
+  { ISFUNC, rl_insert },			/* : */
+  { ISFUNC, rl_insert },			/* ; */
+  { ISFUNC, rl_insert },			/* < */
+  { ISFUNC, rl_insert },			/* = */
+  { ISFUNC, rl_insert },			/* > */
+  { ISFUNC, rl_insert },			/* ? */
+  { ISFUNC, rl_insert },			/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },		/* A */
-  { ISFUNC, rl_insert },		/* B */
-  { ISFUNC, rl_insert },		/* C */
-  { ISFUNC, rl_insert },		/* D */
-  { ISFUNC, rl_insert },		/* E */
-  { ISFUNC, rl_insert },		/* F */
-  { ISFUNC, rl_insert },		/* G */
-  { ISFUNC, rl_insert },		/* H */
-  { ISFUNC, rl_insert },		/* I */
-  { ISFUNC, rl_insert },		/* J */
-  { ISFUNC, rl_insert },		/* K */
-  { ISFUNC, rl_insert },		/* L */
-  { ISFUNC, rl_insert },		/* M */
-  { ISFUNC, rl_insert },		/* N */
-  { ISFUNC, rl_insert },		/* O */
-  { ISFUNC, rl_insert },		/* P */
-  { ISFUNC, rl_insert },		/* Q */
-  { ISFUNC, rl_insert },		/* R */
-  { ISFUNC, rl_insert },		/* S */
-  { ISFUNC, rl_insert },		/* T */
-  { ISFUNC, rl_insert },		/* U */
-  { ISFUNC, rl_insert },		/* V */
-  { ISFUNC, rl_insert },		/* W */
-  { ISFUNC, rl_insert },		/* X */
-  { ISFUNC, rl_insert },		/* Y */
-  { ISFUNC, rl_insert },		/* Z */
+  { ISFUNC, rl_insert },			/* A */
+  { ISFUNC, rl_insert },			/* B */
+  { ISFUNC, rl_insert },			/* C */
+  { ISFUNC, rl_insert },			/* D */
+  { ISFUNC, rl_insert },			/* E */
+  { ISFUNC, rl_insert },			/* F */
+  { ISFUNC, rl_insert },			/* G */
+  { ISFUNC, rl_insert },			/* H */
+  { ISFUNC, rl_insert },			/* I */
+  { ISFUNC, rl_insert },			/* J */
+  { ISFUNC, rl_insert },			/* K */
+  { ISFUNC, rl_insert },			/* L */
+  { ISFUNC, rl_insert },			/* M */
+  { ISFUNC, rl_insert },			/* N */
+  { ISFUNC, rl_insert },			/* O */
+  { ISFUNC, rl_insert },			/* P */
+  { ISFUNC, rl_insert },			/* Q */
+  { ISFUNC, rl_insert },			/* R */
+  { ISFUNC, rl_insert },			/* S */
+  { ISFUNC, rl_insert },			/* T */
+  { ISFUNC, rl_insert },			/* U */
+  { ISFUNC, rl_insert },			/* V */
+  { ISFUNC, rl_insert },			/* W */
+  { ISFUNC, rl_insert },			/* X */
+  { ISFUNC, rl_insert },			/* Y */
+  { ISFUNC, rl_insert },			/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_insert },		/* [ */
-  { ISFUNC, rl_insert },		/* \ */
-  { ISFUNC, rl_insert },		/* ] */
-  { ISFUNC, rl_insert },		/* ^ */
-  { ISFUNC, rl_insert },		/* _ */
-  { ISFUNC, rl_insert },		/* ` */
+  { ISFUNC, rl_insert },			/* [ */
+  { ISFUNC, rl_insert },			/* \ */
+  { ISFUNC, rl_insert },			/* ] */
+  { ISFUNC, rl_insert },			/* ^ */
+  { ISFUNC, rl_insert },			/* _ */
+  { ISFUNC, rl_insert },			/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },		/* a */
-  { ISFUNC, rl_insert },		/* b */
-  { ISFUNC, rl_insert },		/* c */
-  { ISFUNC, rl_insert },		/* d */
-  { ISFUNC, rl_insert },		/* e */
-  { ISFUNC, rl_insert },		/* f */
-  { ISFUNC, rl_insert },		/* g */
-  { ISFUNC, rl_insert },		/* h */
-  { ISFUNC, rl_insert },		/* i */
-  { ISFUNC, rl_insert },		/* j */
-  { ISFUNC, rl_insert },		/* k */
-  { ISFUNC, rl_insert },		/* l */
-  { ISFUNC, rl_insert },		/* m */
-  { ISFUNC, rl_insert },		/* n */
-  { ISFUNC, rl_insert },		/* o */
-  { ISFUNC, rl_insert },		/* p */
-  { ISFUNC, rl_insert },		/* q */
-  { ISFUNC, rl_insert },		/* r */
-  { ISFUNC, rl_insert },		/* s */
-  { ISFUNC, rl_insert },		/* t */
-  { ISFUNC, rl_insert },		/* u */
-  { ISFUNC, rl_insert },		/* v */
-  { ISFUNC, rl_insert },		/* w */
-  { ISFUNC, rl_insert },		/* x */
-  { ISFUNC, rl_insert },		/* y */
-  { ISFUNC, rl_insert },		/* z */
+  { ISFUNC, rl_insert },			/* a */
+  { ISFUNC, rl_insert },			/* b */
+  { ISFUNC, rl_insert },			/* c */
+  { ISFUNC, rl_insert },			/* d */
+  { ISFUNC, rl_insert },			/* e */
+  { ISFUNC, rl_insert },			/* f */
+  { ISFUNC, rl_insert },			/* g */
+  { ISFUNC, rl_insert },			/* h */
+  { ISFUNC, rl_insert },			/* i */
+  { ISFUNC, rl_insert },			/* j */
+  { ISFUNC, rl_insert },			/* k */
+  { ISFUNC, rl_insert },			/* l */
+  { ISFUNC, rl_insert },			/* m */
+  { ISFUNC, rl_insert },			/* n */
+  { ISFUNC, rl_insert },			/* o */
+  { ISFUNC, rl_insert },			/* p */
+  { ISFUNC, rl_insert },			/* q */
+  { ISFUNC, rl_insert },			/* r */
+  { ISFUNC, rl_insert },			/* s */
+  { ISFUNC, rl_insert },			/* t */
+  { ISFUNC, rl_insert },			/* u */
+  { ISFUNC, rl_insert },			/* v */
+  { ISFUNC, rl_insert },			/* w */
+  { ISFUNC, rl_insert },			/* x */
+  { ISFUNC, rl_insert },			/* y */
+  { ISFUNC, rl_insert },			/* z */
 
   /* Final punctuation. */
-  { ISFUNC, rl_insert },		/* { */
-  { ISFUNC, rl_insert },		/* | */
-  { ISFUNC, rl_insert },		/* } */
-  { ISFUNC, rl_insert },		/* ~ */
-  { ISFUNC, rl_rubout },		/* RUBOUT */
+  { ISFUNC, rl_insert },			/* { */
+  { ISFUNC, rl_insert },			/* | */
+  { ISFUNC, rl_insert },			/* } */
+  { ISFUNC, rl_insert },			/* ~ */
+  { ISFUNC, rl_rubout },			/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Pure 8-bit characters (128 - 159).
      These might be used in some
      character sets. */
   { ISFUNC, rl_insert },	/* ? */
   { ISFUNC, rl_insert },	/* ? */
   { ISFUNC, rl_insert },	/* ? */
@@ -593,285 +593,285 @@ KEYMAP_ENTRY_ARRAY vi_insertion_keymap =
   { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 /* Unused for the time being. */
 #if 0
 KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, (Function *)0x0 },		/* Control-d */
-  { ISFUNC, (Function *)0x0 },		/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, (Function *)0x0 },		/* Control-g */
-  { ISFUNC, (Function *)0x0 },		/* Control-h */
-  { ISFUNC, rl_tab_insert},		/* Control-i */
-  { ISFUNC, rl_emacs_editing_mode},	/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, (Function *)0x0 },		/* Control-l */
-  { ISFUNC, rl_emacs_editing_mode},	/* Control-m */
-  { ISFUNC, (Function *)0x0 },		/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, (Function *)0x0 },		/* Control-p */
-  { ISFUNC, (Function *)0x0 },		/* Control-q */
-  { ISFUNC, (Function *)0x0 },		/* Control-r */
-  { ISFUNC, (Function *)0x0 },		/* Control-s */
-  { ISFUNC, (Function *)0x0 },		/* Control-t */
-  { ISFUNC, (Function *)0x0 },		/* Control-u */
-  { ISFUNC, (Function *)0x0 },		/* Control-v */
-  { ISFUNC, (Function *)0x0 },		/* Control-w */
-  { ISFUNC, (Function *)0x0 },		/* Control-x */
-  { ISFUNC, (Function *)0x0 },		/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
+  { ISFUNC, rl_tab_insert},			/* Control-i */
+  { ISFUNC, rl_emacs_editing_mode},		/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
+  { ISFUNC, rl_emacs_editing_mode},		/* Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
 
-  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, (Function *)0x0 },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, (Function *)0x0 },		/* # */
-  { ISFUNC, (Function *)0x0 },		/* $ */
-  { ISFUNC, (Function *)0x0 },		/* % */
-  { ISFUNC, (Function *)0x0 },		/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, (Function *)0x0 },		/* ( */
-  { ISFUNC, (Function *)0x0 },		/* ) */
-  { ISFUNC, (Function *)0x0 },		/* * */
-  { ISFUNC, (Function *)0x0 },		/* + */
-  { ISFUNC, (Function *)0x0 },		/* , */
-  { ISFUNC, (Function *)0x0 },		/* - */
-  { ISFUNC, (Function *)0x0 },		/* . */
-  { ISFUNC, (Function *)0x0 },		/* / */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_vi_arg_digit },		/* 0 */
-  { ISFUNC, rl_vi_arg_digit },		/* 1 */
-  { ISFUNC, rl_vi_arg_digit },		/* 2 */
-  { ISFUNC, rl_vi_arg_digit },		/* 3 */
-  { ISFUNC, rl_vi_arg_digit },		/* 4 */
-  { ISFUNC, rl_vi_arg_digit },		/* 5 */
-  { ISFUNC, rl_vi_arg_digit },		/* 6 */
-  { ISFUNC, rl_vi_arg_digit },		/* 7 */
-  { ISFUNC, rl_vi_arg_digit },		/* 8 */
-  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+  { ISFUNC, rl_vi_arg_digit },			/* 0 */
+  { ISFUNC, rl_vi_arg_digit },			/* 1 */
+  { ISFUNC, rl_vi_arg_digit },			/* 2 */
+  { ISFUNC, rl_vi_arg_digit },			/* 3 */
+  { ISFUNC, rl_vi_arg_digit },			/* 4 */
+  { ISFUNC, rl_vi_arg_digit },			/* 5 */
+  { ISFUNC, rl_vi_arg_digit },			/* 6 */
+  { ISFUNC, rl_vi_arg_digit },			/* 7 */
+  { ISFUNC, rl_vi_arg_digit },			/* 8 */
+  { ISFUNC, rl_vi_arg_digit },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* : */
-  { ISFUNC, (Function *)0x0 },		/* ; */
-  { ISFUNC, (Function *)0x0 },		/* < */
-  { ISFUNC, (Function *)0x0 },		/* = */
-  { ISFUNC, (Function *)0x0 },		/* > */
-  { ISFUNC, (Function *)0x0 },		/* ? */
-  { ISFUNC, (Function *)0x0 },		/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },	/* A */
-  { ISFUNC, rl_do_lowercase_version },	/* B */
-  { ISFUNC, rl_do_lowercase_version },	/* C */
-  { ISFUNC, rl_do_lowercase_version },	/* D */
-  { ISFUNC, rl_do_lowercase_version },	/* E */
-  { ISFUNC, rl_do_lowercase_version },	/* F */
-  { ISFUNC, rl_do_lowercase_version },	/* G */
-  { ISFUNC, rl_do_lowercase_version },	/* H */
-  { ISFUNC, rl_do_lowercase_version },	/* I */
-  { ISFUNC, rl_do_lowercase_version },	/* J */
-  { ISFUNC, rl_do_lowercase_version },	/* K */
-  { ISFUNC, rl_do_lowercase_version },	/* L */
-  { ISFUNC, rl_do_lowercase_version },	/* M */
-  { ISFUNC, rl_do_lowercase_version },	/* N */
-  { ISFUNC, rl_do_lowercase_version },	/* O */
-  { ISFUNC, rl_do_lowercase_version },	/* P */
-  { ISFUNC, rl_do_lowercase_version },	/* Q */
-  { ISFUNC, rl_do_lowercase_version },	/* R */
-  { ISFUNC, rl_do_lowercase_version },	/* S */
-  { ISFUNC, rl_do_lowercase_version },	/* T */
-  { ISFUNC, rl_do_lowercase_version },	/* U */
-  { ISFUNC, rl_do_lowercase_version },	/* V */
-  { ISFUNC, rl_do_lowercase_version },	/* W */
-  { ISFUNC, rl_do_lowercase_version },	/* X */
-  { ISFUNC, rl_do_lowercase_version },	/* Y */
-  { ISFUNC, rl_do_lowercase_version },	/* Z */
+  { ISFUNC, rl_do_lowercase_version },		/* A */
+  { ISFUNC, rl_do_lowercase_version },		/* B */
+  { ISFUNC, rl_do_lowercase_version },		/* C */
+  { ISFUNC, rl_do_lowercase_version },		/* D */
+  { ISFUNC, rl_do_lowercase_version },		/* E */
+  { ISFUNC, rl_do_lowercase_version },		/* F */
+  { ISFUNC, rl_do_lowercase_version },		/* G */
+  { ISFUNC, rl_do_lowercase_version },		/* H */
+  { ISFUNC, rl_do_lowercase_version },		/* I */
+  { ISFUNC, rl_do_lowercase_version },		/* J */
+  { ISFUNC, rl_do_lowercase_version },		/* K */
+  { ISFUNC, rl_do_lowercase_version },		/* L */
+  { ISFUNC, rl_do_lowercase_version },		/* M */
+  { ISFUNC, rl_do_lowercase_version },		/* N */
+  { ISFUNC, rl_do_lowercase_version },		/* O */
+  { ISFUNC, rl_do_lowercase_version },		/* P */
+  { ISFUNC, rl_do_lowercase_version },		/* Q */
+  { ISFUNC, rl_do_lowercase_version },		/* R */
+  { ISFUNC, rl_do_lowercase_version },		/* S */
+  { ISFUNC, rl_do_lowercase_version },		/* T */
+  { ISFUNC, rl_do_lowercase_version },		/* U */
+  { ISFUNC, rl_do_lowercase_version },		/* V */
+  { ISFUNC, rl_do_lowercase_version },		/* W */
+  { ISFUNC, rl_do_lowercase_version },		/* X */
+  { ISFUNC, rl_do_lowercase_version },		/* Y */
+  { ISFUNC, rl_do_lowercase_version },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_arrow_keys },		/* [ */
-  { ISFUNC, (Function *)0x0 },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, (Function *)0x0 },		/* ^ */
-  { ISFUNC, (Function *)0x0 },		/* _ */
-  { ISFUNC, (Function *)0x0 },		/* ` */
+  { ISFUNC, rl_arrow_keys },			/* [ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },		/* a */
-  { ISFUNC, (Function *)0x0 },		/* b */
-  { ISFUNC, (Function *)0x0 },		/* c */
-  { ISFUNC, (Function *)0x0 },		/* d */
-  { ISFUNC, (Function *)0x0 },		/* e */
-  { ISFUNC, (Function *)0x0 },		/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, (Function *)0x0 },		/* h */
-  { ISFUNC, (Function *)0x0 },		/* i */
-  { ISFUNC, (Function *)0x0 },		/* j */
-  { ISFUNC, (Function *)0x0 },		/* k */
-  { ISFUNC, (Function *)0x0 },		/* l */
-  { ISFUNC, (Function *)0x0 },		/* m */
-  { ISFUNC, (Function *)0x0 },		/* n */
-  { ISFUNC, rl_arrow_keys },		/* o */
-  { ISFUNC, (Function *)0x0 },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, (Function *)0x0 },		/* r */
-  { ISFUNC, (Function *)0x0 },		/* s */
-  { ISFUNC, (Function *)0x0 },		/* t */
-  { ISFUNC, (Function *)0x0 },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, (Function *)0x0 },		/* w */
-  { ISFUNC, (Function *)0x0 },		/* x */
-  { ISFUNC, (Function *)0x0 },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
+  { ISFUNC, rl_arrow_keys },			/* o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, (Function *)0x0 },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, (Function *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_word },	/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_word },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 #endif
diff --git a/readline/vi_mode.c b/readline/vi_mode.c
--- a/readline/vi_mode.c
+++ b/readline/vi_mode.c
@@ -3,17 +3,17 @@
 
 /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library, a library for
    reading lines of text with interactive input and history editing.
 
    The GNU Readline Library is free software; you can redistribute it
    and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 1, or
+   as published by the Free Software Foundation; either version 2, or
    (at your option) any later version.
 
    The GNU Readline Library is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    The GNU General Public License is often shipped with GNU software, and
@@ -49,16 +49,19 @@
 
 #include <stdio.h>
 
 /* Some standard library routines. */
 #include "rldefs.h"
 #include "readline.h"
 #include "history.h"
 
+#include "rlprivate.h"
+#include "xmalloc.h"
+
 #ifndef _rl_digit_p
 #define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
 #endif
 
 #ifndef _rl_digit_value
 #define _rl_digit_value(c) ((c) - '0')
 #endif
 
@@ -69,41 +72,21 @@
 #ifndef isident
 #define isident(c) ((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
 #endif
 
 #ifndef exchange
 #define exchange(x, y) do {int temp = x; x = y; y = temp;} while (0)
 #endif
 
-extern char *xmalloc (), *xrealloc ();
-
-/* Variables imported from readline.c */
-extern int rl_point, rl_end, rl_mark, rl_done;
-extern FILE *rl_instream;
-extern int rl_line_buffer_len, rl_explicit_arg, rl_numeric_arg;
-extern Keymap _rl_keymap;
-extern char *rl_prompt;
-extern char *rl_line_buffer;
-extern int rl_arg_sign;
-
-extern int _rl_doing_an_undo;
-extern int _rl_undo_group_level;
-
-extern void _rl_dispatch ();
-extern int _rl_char_search_internal ();
-
-extern void rl_extend_line_buffer ();
-extern int rl_vi_check ();
-
 /* Non-zero means enter insertion mode. */
 static int _rl_vi_doing_insert;
 
 /* Command keys which do movement for xxx_to commands. */
-static char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
+static const char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
 
 /* Keymap used for vi replace characters.  Created dynamically since
    rarely used. */
 static Keymap vi_replace_map;
 
 /* The number of characters inserted in the last replace operation. */
 static int vi_replace_count;
 
@@ -121,22 +104,22 @@ static int _rl_vi_last_motion;
 static int _rl_vi_last_search_char;
 static int _rl_vi_last_replacement;
 
 static int _rl_vi_last_key_before_insert;
 
 static int vi_redoing;
 
 /* Text modification commands.  These are the `redoable' commands. */
-static char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
+static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
 
 /* Arrays for the saved marks. */
 static int vi_mark_chars[27];
 
-static int rl_digit_loop1 ();
+static int rl_digit_loop1 __P((void));
 
 void
 _rl_vi_initialize_line ()
 {
   register int i;
 
   for (i = 0; i < sizeof (vi_mark_chars) / sizeof (int); i++)
     vi_mark_chars[i] = -1;
@@ -286,17 +269,17 @@ rl_vi_search (count, key)
       rl_noninc_forward_search (count, key);
       break;
 
     case '/':
       rl_noninc_reverse_search (count, key);
       break;
 
     default:
-      ding ();
+      rl_ding ();
       break;
     }
   return (0);
 }
 
 /* Completion, from vi's point of view. */
 int
 rl_vi_complete (ignore, key)
@@ -342,88 +325,88 @@ int
 rl_vi_prev_word (count, key)
      int count, key;
 {
   if (count < 0)
     return (rl_vi_next_word (-count, key));
 
   if (rl_point == 0)
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
   if (_rl_uppercase_p (key))
-    rl_vi_bWord (count);
+    rl_vi_bWord (count, key);
   else
-    rl_vi_bword (count);
+    rl_vi_bword (count, key);
 
   return (0);
 }
 
 /* Next word in vi mode. */
 int
 rl_vi_next_word (count, key)
      int count, key;
 {
   if (count < 0)
     return (rl_vi_prev_word (-count, key));
 
   if (rl_point >= (rl_end - 1))
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
   if (_rl_uppercase_p (key))
-    rl_vi_fWord (count);
+    rl_vi_fWord (count, key);
   else
-    rl_vi_fword (count);
+    rl_vi_fword (count, key);
   return (0);
 }
 
 /* Move to the end of the ?next? word. */
 int
 rl_vi_end_word (count, key)
      int count, key;
 {
   if (count < 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   if (_rl_uppercase_p (key))
-    rl_vi_eWord (count);
+    rl_vi_eWord (count, key);
   else
-    rl_vi_eword (count);
+    rl_vi_eword (count, key);
   return (0);
 }
 
 /* Move forward a word the way that 'W' does. */
 int
-rl_vi_fWord (count)
-     int count;
+rl_vi_fWord (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point < (rl_end - 1))
     {
       /* Skip until whitespace. */
       while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
 	rl_point++;
 
       /* Now skip whitespace. */
       while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
 	rl_point++;
     }
   return (0);
 }
 
 int
-rl_vi_bWord (count)
-     int count;
+rl_vi_bWord (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point > 0)
     {
       /* If we are at the start of a word, move back to whitespace so
 	 we will go back to the start of the previous word. */
       if (!whitespace (rl_line_buffer[rl_point]) &&
 	  whitespace (rl_line_buffer[rl_point - 1]))
 	rl_point--;
@@ -436,18 +419,18 @@ rl_vi_bWord (count)
 	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
 	  rl_point++;
 	}
     }
   return (0);
 }
 
 int
-rl_vi_eWord (count)
-     int count;
+rl_vi_eWord (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point < (rl_end - 1))
     {
       if (!whitespace (rl_line_buffer[rl_point]))
 	rl_point++;
 
       /* Move to the next non-whitespace character (to the start of the
 	 next word). */
@@ -466,18 +449,18 @@ rl_vi_eWord (count)
 	  /* Move back to the last character of the word. */
 	  rl_point--;
 	}
     }
   return (0);
 }
 
 int
-rl_vi_fword (count)
-     int count;
+rl_vi_fword (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point < (rl_end - 1))
     {
       /* Move to white space (really non-identifer). */
       if (isident (rl_line_buffer[rl_point]))
 	{
 	  while (isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
 	    rl_point++;
@@ -492,18 +475,18 @@ rl_vi_fword (count)
       /* Move past whitespace. */
       while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
 	rl_point++;
     }
   return (0);
 }
 
 int
-rl_vi_bword (count)
-     int count;
+rl_vi_bword (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point > 0)
     {
       int last_is_ident;
 
       /* If we are at the start of a word, move back to whitespace
 	 so we will go back to the start of the previous word. */
       if (!whitespace (rl_line_buffer[rl_point]) &&
@@ -531,18 +514,18 @@ rl_vi_bword (count)
 		   !whitespace (rl_line_buffer[rl_point]));
 	  rl_point++;
 	}
     }
   return (0);
 }
 
 int
-rl_vi_eword (count)
-     int count;
+rl_vi_eword (count, ignore)
+     int count, ignore;
 {
   while (count-- && rl_point < rl_end - 1)
     {
       if (!whitespace (rl_line_buffer[rl_point]))
 	rl_point++;
 
       while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
 	rl_point++;
@@ -610,16 +593,23 @@ rl_vi_insertion_mode (count, key)
 }
 
 static void
 _rl_vi_save_insert (up)
       UNDO_LIST *up;
 {
   int len, start, end;
 
+  if (up == 0)
+    {
+      if (vi_insert_buffer_size >= 1)
+	vi_insert_buffer[0] = '\0';
+      return;
+    }
+
   start = up->start;
   end = up->end;
   len = end - start + 1;
   if (len >= vi_insert_buffer_size)
     {
       vi_insert_buffer_size += (len + 32) - (len % 32);
       vi_insert_buffer = xrealloc (vi_insert_buffer, vi_insert_buffer_size);
     }
@@ -717,17 +707,17 @@ rl_vi_change_case (count, ignore)
 
 int
 rl_vi_put (count, key)
      int count, key;
 {
   if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
     rl_point++;
 
-  rl_yank ();
+  rl_yank (1, key);
   rl_backward (1, key);
   return (0);
 }
 
 int
 rl_vi_check ()
 {
   if (rl_point && rl_point == rl_end)
@@ -749,28 +739,32 @@ rl_vi_column (count, key)
 int
 rl_vi_domove (key, nextkey)
      int key, *nextkey;
 {
   int c, save;
   int old_end;
 
   rl_mark = rl_point;
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
   *nextkey = c;
 
   if (!member (c, vi_motion))
     {
       if (_rl_digit_p (c))
 	{
 	  save = rl_numeric_arg;
 	  rl_numeric_arg = _rl_digit_value (c);
 	  rl_digit_loop1 ();
 	  rl_numeric_arg *= save;
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  c = rl_read_key ();	/* real command */
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
 	  *nextkey = c;
 	}
       else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
 	{
 	  rl_mark = rl_end;
 	  rl_beg_of_line (1, c);
 	  _rl_vi_last_motion = c;
 	  return (0);
@@ -830,26 +824,38 @@ rl_vi_domove (key, nextkey)
 
   if (rl_mark < rl_point)
     exchange (rl_point, rl_mark);
 
   return (0);
 }
 
 /* A simplified loop for vi. Don't dispatch key at end.
-   Don't recognize minus sign? */
+   Don't recognize minus sign?
+   Should this do rl_save_prompt/rl_restore_prompt? */
 static int
 rl_digit_loop1 ()
 {
   int key, c;
 
+  RL_SETSTATE(RL_STATE_NUMERICARG);
   while (1)
     {
+      if (rl_numeric_arg > 1000000)
+	{
+	  rl_explicit_arg = rl_numeric_arg = 0;
+	  rl_ding ();
+	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
+	  return 1;
+	}
       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       key = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       if (_rl_keymap[c].type == ISFUNC &&
 	  _rl_keymap[c].function == rl_universal_argument)
 	{
 	  rl_numeric_arg *= 4;
 	  continue;
 	}
 
@@ -864,33 +870,35 @@ rl_digit_loop1 ()
 	}
       else
 	{
 	  rl_clear_message ();
 	  rl_stuff_char (key);
 	  break;
 	}
     }
+
+  RL_UNSETSTATE(RL_STATE_NUMERICARG);
   return (0);
 }
 
 int
 rl_vi_delete_to (count, key)
      int count, key;
 {
   int c;
 
   if (_rl_uppercase_p (key))
     rl_stuff_char ('$');
   else if (vi_redoing)
     rl_stuff_char (_rl_vi_last_motion);
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   /* These are the motion commands that do not require adjusting the
      mark. */
   if ((strchr (" l|h^0bB", c) == 0) && (rl_mark < rl_end))
     rl_mark++;
 
@@ -908,17 +916,17 @@ rl_vi_change_to (count, key)
     rl_stuff_char ('$');
   else if (vi_redoing)
     rl_stuff_char (_rl_vi_last_motion);
 
   start_pos = rl_point;
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   /* These are the motion commands that do not require adjusting the
      mark.  c[wW] are handled by special-case code in rl_vi_domove(),
      and already leave the mark at the correct location. */
   if ((strchr (" l|hwW^0bB", c) == 0) && (rl_mark < rl_end))
     rl_mark++;
@@ -958,17 +966,17 @@ rl_vi_yank_to (count, key)
 {
   int c, save = rl_point;
 
   if (_rl_uppercase_p (key))
     rl_stuff_char ('$');
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   /* These are the motion commands that do not require adjusting the
      mark. */
   if ((strchr (" l|h^0%bB", c) == 0) && (rl_mark < rl_end))
     rl_mark++;
 
@@ -984,17 +992,17 @@ rl_vi_yank_to (count, key)
 int
 rl_vi_delete (count, key)
      int count, key;
 {
   int end;
 
   if (rl_end == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   end = rl_point + count;
 
   if (end >= rl_end)
     end = rl_end;
 
@@ -1031,17 +1039,21 @@ rl_vi_char_search (count, key)
 
   if (key == ';' || key == ',')
     dir = key == ';' ? orig_dir : -orig_dir;
   else
     {
       if (vi_redoing)
 	target = _rl_vi_last_search_char;
       else
-	_rl_vi_last_search_char = target = rl_getc (rl_instream);
+	{
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
+	  _rl_vi_last_search_char = target = rl_read_key ();
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	}
 
       switch (key)
         {
         case 't':
           orig_dir = dir = FTO;
           break;
 
         case 'T':
@@ -1073,17 +1085,17 @@ rl_vi_match (ignore, key)
     {
       while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
 	     rl_point < rl_end - 1)
 	rl_forward (1, key);
 
       if (brack <= 0)
 	{
 	  rl_point = pos;
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
     }
 
   pos = rl_point;
 
   if (brack < 0)
     {
@@ -1094,17 +1106,17 @@ rl_vi_match (ignore, key)
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
 		count--;
 	      else if (b == brack)
 		count++;
 	    }
 	  else
 	    {
-	      ding ();
+	      rl_ding ();
 	      return -1;
 	    }
 	}
     }
   else
     {			/* brack > 0 */
       while (count)
 	{
@@ -1113,17 +1125,17 @@ rl_vi_match (ignore, key)
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
 		count--;
 	      else if (b == brack)
 		count++;
 	    }
 	  else
 	    {
-	      ding ();
+	      rl_ding ();
 	      return -1;
 	    }
 	}
     }
   rl_point = pos;
   return (0);
 }
 
@@ -1147,17 +1159,21 @@ int
 rl_vi_change_char (count, key)
      int count, key;
 {
   int c;
 
   if (vi_redoing)
     c = _rl_vi_last_replacement;
   else
-    _rl_vi_last_replacement = c = rl_getc (rl_instream);
+    {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
+      _rl_vi_last_replacement = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+    }
 
   if (c == '\033' || c == CTRL ('C'))
     return -1;
 
   while (count-- && rl_point < rl_end)
     {
       rl_begin_undo_group ();
 
@@ -1243,17 +1259,17 @@ rl_vi_overstrike_delete (count, key)
      int count, key;
 {
   int i, s;
 
   for (i = 0; i < count; i++)
     {
       if (vi_replace_count == 0)
 	{
-	  ding ();
+	  rl_ding ();
 	  break;
 	}
       s = rl_point;
 
       if (rl_do_undo ())
 	vi_replace_count--;
 
       if (rl_point == s)
@@ -1313,17 +1329,17 @@ rl_vi_possible_completions()
   if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')
     {
       while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&
 	     rl_line_buffer[rl_point] != ';')
 	rl_point++;
     }
   else if (rl_line_buffer[rl_point - 1] == ';')
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
   rl_possible_completions ();
   rl_point = save_pos;
 
   return (0);
 }
@@ -1331,48 +1347,54 @@ rl_vi_possible_completions()
 
 /* Functions to save and restore marks. */
 int
 rl_vi_set_mark (count, key)
      int count, key;
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (_rl_lowercase_p (ch) == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   ch -= 'a';
   vi_mark_chars[ch] = rl_point;
   return 0;
 }
 
 int
 rl_vi_goto_mark (count, key)
      int count, key;
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (ch == '`')
     {
       rl_point = rl_mark;
       return 0;
     }
   else if (_rl_lowercase_p (ch) == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   ch -= 'a';
   if (vi_mark_chars[ch] == -1)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   rl_point = vi_mark_chars[ch];
   return 0;
 }
 
 #endif /* VI_MODE */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,16 @@
+2001-02-06  Mumit Khan  <khan@nanotech.wisc.edu>
+
+	* oct-stream.cc (octave_scan): Partially implement and specialize
+	for char*.  Delete the old template instantiations.
+	(BEGIN_S_CONVERSION): Use strings instead of ostrstreambuf.
+	(octave_base_stream::do_scanf): Pass correct parameter to
+	do_scan_conv.
+
 2001-02-05  Mumit Khan  <khan@nanotech.wisc.edu>
 
 	* pr-output.cc (set_format): Add std:: namespace qualifier as
 	needed.
 
 	* oct-stream.cc (octave_scan): Implement, and specialize for
 	char*. Delete the old template instantiations.
 	(BEGIN_S_CONVERSION): Use strings instead of ostrstreambuf.
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1353,23 +1353,19 @@ next_token_is_postfix_unary_op (bool spc
 // Try to determine if the next token should be treated as a binary
 // operator.
 //
 // This kluge exists because whitespace is not always ignored inside
 // the square brackets that are used to create matrix objects (though
 // spacing only really matters in the cases that can be interpreted
 // either as binary ops or prefix unary ops: currently just +, -).
 //
-// Note that
-//
-//   octave> [a +\
-//   > b]
-//
-// (the characters '[' 'a' ' ' '+' '\' LFD 'b' ']') will cause Octave
-// to treat the + as a binary operator.
+// Note that a line continuation directly following a + or - operator
+// (e.g., the characters '[' 'a' ' ' '+' '\' LFD 'b' ']') will be
+// parsed as a binary operator.
 
 static bool
 next_token_is_bin_op (bool spc_prev)
 {
   bool bin_op = false;
 
   int c0 = yyinput ();
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1059,58 +1059,60 @@ octave_base_stream::read (const Matrix& 
 	}
     }
   else
     invalid_operation ("fread", "reading");
 
   return retval;
 }
 
-#if defined (__GNUG__) && !CXX_ISO_COMPLIANT_LIBRARY
+#if defined (__GNUG__) && ! defined (CXX_ISO_COMPLIANT_LIBRARY)
 
 #define OCTAVE_SCAN(is, fmt, arg) is.scan ((fmt).text, arg)
 
 #else
 
 #define OCTAVE_SCAN(is, fmt, arg) octave_scan (is, fmt, arg)
 
+// XXX FIXME XXX -- this needs to be fixed to handle formats which
+// specify a maximum width.
+
 template <class T>
 std::istream&
-octave_scan (std::istream& is, const scanf_format_elt& fmt, T valptr)
+octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
 {
-  // Someone else who cares will have to fix this code.  I refuse to
-  // waste my time working on it when a reasonable alternative like
-  // istream::scan exists in the GNU iostream library.  --jwe
-
-  error ("formatted input only works when Octave is compiled with G++");
-
-  is.setstate (std::ios::failbit);
+  T& ref = *valptr;
+
+  switch (fmt.type)
+    {
+    case 'o':
+      is >> std::oct >> ref;
+      break;
+
+    case 'x':
+      is >> std::hex >> ref;
+      break;
+
+    default:
+      is >> ref;
+      break;
+    }
 
   return is;
 }
 
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, char*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, long int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, short int*);
-
-#if 0
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, float*);
-#endif
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, double*);
+// Note that this specialization is only used for reading characters, not 
+// character strings. See BEGIN_S_CONVERSION for details.
+
+template<>
+std::istream&
+octave_scan<> (std::istream& is, const scanf_format_elt& fmt, char* valptr)
+{
+  return is >> valptr;
+}
 
 #endif
 
 template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
 	       T valptr, Matrix& mval, double *data, int& idx,
 	       int& conversion_count, int nr, int max_size,
@@ -1249,35 +1251,19 @@ do_scanf_conv (std::istream&, const scan
 	  tmp = new char [width+1]; \
  \
 	  OCTAVE_SCAN (is, *elt, tmp); \
  \
 	  tmp[width] = '\0'; \
 	} \
       else \
 	{ \
-	  std::ostrstream buf; \
- \
-	  int c = EOF; \
- \
-	  while (is && (c = is.get ()) != EOF && isspace (c)) \
-	    /* skip leading whitespace */; \
- \
-	  if (is && c != EOF) \
-	    buf << (char) c; \
- \
-	  while (is && (c = is.get ()) != EOF && ! isspace (c)) \
-	    buf << (char) c; \
- \
-	  if (isspace (c)) \
-	    is.putback (c); \
- \
-	  buf << std::ends; \
- \
-	  tmp = buf.str (); \
+	  std::string buf; \
+	  is >> std::ws >> buf; \
+	  tmp = strsave (buf.c_str()); \
 	} \
     } \
   while (0)
 
 // This format must match a nonempty sequence of characters.
 #define BEGIN_CHAR_CLASS_CONVERSION() \
   int width = elt->width; \
  \
@@ -1507,48 +1493,48 @@ octave_base_stream::do_scanf (scanf_form
 
 		case 'd': case 'i': case 'o': case 'u': case 'x':
 		  {
 		    switch (elt->modifier)
 		      {
 		      case 'h':
 			{
 			  short int tmp;
-			  do_scanf_conv (is, fmt, &tmp, mval, data,
+			  do_scanf_conv (is, *elt, &tmp, mval, data,
 					 data_index, conversion_count,
 					 nr, max_size, discard);
 			}
 			break;
 
 		      case 'l':
 			{
 			  long int tmp;
-			  do_scanf_conv (is, fmt, &tmp, mval, data,
+			  do_scanf_conv (is, *elt, &tmp, mval, data,
 					 data_index, conversion_count,
 					 nr, max_size, discard);
 			}
 			break;
 
 		      default:
 			{
 			  int tmp;
-			  do_scanf_conv (is, fmt, &tmp, mval, data,
+			  do_scanf_conv (is, *elt, &tmp, mval, data,
 					 data_index, conversion_count,
 					 nr, max_size, discard);
 			}
 			break;
 		      }
 		  }
 		  break;
 
 		case 'e': case 'f': case 'g':
 		  {
 		    double tmp;
 
-		    do_scanf_conv (is, fmt, &tmp, mval, data,
+		    do_scanf_conv (is, *elt, &tmp, mval, data,
 				   data_index, conversion_count,
 				   nr, max_size, discard);
 		  }
 		  break;
 
 		case 'c':
 		  {
 		    BEGIN_C_CONVERSION ();
