# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463677007 14400
#      Thu May 19 12:56:47 2016 -0400
# Node ID f4d7d0eb5b0cf83d02b98c8cb10b95d399a836be
# Parent  c86cacc3aaf4dfd13a1c190329bd4d095e41a623
use namespace for unwind_protect class

* unwind-prot.h, unwind-prot.cc: Put unwind_protect in octave
namespace.  Change all uses.

diff --git a/examples/code/unwinddemo.cc b/examples/code/unwinddemo.cc
--- a/examples/code/unwinddemo.cc
+++ b/examples/code/unwinddemo.cc
@@ -18,17 +18,17 @@ DEFUN_DLD (unwinddemo, args, nargout, "U
   if (args.length () < 2)
     print_usage ();
 
   NDArray a = args(0).array_value ();
   NDArray b = args(1).array_value ();
 
   // Declare unwind_protect frame which lasts as long as
   // the variable frame has scope.
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.add_fcn (set_liboctave_warning_handler,
                  current_liboctave_warning_handler);
 
   frame.add_fcn (set_liboctave_warning_with_id_handler,
                  current_liboctave_warning_with_id_handler);
 
   set_liboctave_warning_handler (my_err_handler);
   set_liboctave_warning_with_id_handler (my_err_with_id_handler);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -370,17 +370,17 @@ file_editor_tab::handle_context_menu_bre
         = QInputDialog::getText (this, tr ("Breakpoint condition"),
                                  tr (prompt.c_str ()), QLineEdit::Normal, cond,
                                  &ok);
       if (ok)     // If cancel, don't change breakpoint condition.
         {
           try
             {
               // Suppress error messages on the console.
-              unwind_protect frame;
+              octave::unwind_protect frame;
               frame.protect_var (buffer_error_messages);
               buffer_error_messages++;
 
               bp_table::condition_valid (new_condition.toStdString ());
               valid = true;
             }
           catch (const index_exception& e) { }
           catch (const octave_execution_exception& e) { }
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -535,17 +535,17 @@ v = cellfun (@@det, a); # faster\n\
             {
               if (mask[i] && inputs[i].dims () != fdims)
                 error ("cellfun: dimensions mismatch");
             }
           break;
         }
     }
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (buffer_error_messages);
 
   if (error_handler.is_defined ())
     buffer_error_messages++;
 
   // Apply functions.
 
   if (uniform_output)
@@ -1217,17 +1217,17 @@ arrayfun (@@str2num, [1234],\n\
                   if (mask[i] && inputs[i].dims () != fdims)
                     error_with_id ("Octave:invalid-input-arg",
                                    "arrayfun: dimensions mismatch");
                 }
               break;
             }
         }
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
       frame.protect_var (buffer_error_messages);
 
       if (error_handler.is_defined ())
         buffer_error_messages++;
 
       // Apply functions.
 
       if (uniform_output)
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -259,17 +259,17 @@ parameters for @code{daspk}.\n\
   if (nargin < 4 || nargin > 5)
     print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   octave_value_list retval (4);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("daspk: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -337,17 +337,17 @@ parameters for @code{dasrt}.\n\
     print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
   octave_value_list retval (5);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("dasrt: invalid recursive call");
 
   int argp = 0;
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -260,17 +260,17 @@ parameters for @code{dassl}.\n\
   if (nargin < 4 || nargin > 5)
     print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   octave_value_list retval (4);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("dassl: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1846,17 +1846,17 @@ do_dbstack (const octave_value_list& arg
 {
   int nargin = args.length ();
 
   if (nargin > 2)
     print_usage ();
 
   octave_value_list retval;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
   if (nargin == 1 || nargin == 2)
     {
       int n = 0;
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -242,17 +242,17 @@ clear (octave_shlib& oct_file)
 
 octave_function *
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
                                     const std::string& file_name,
                                     bool relative)
 {
   octave_function *retval = 0;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib oct_file = octave_shlib_list::find_file (file_name);
 
   if (oct_file && oct_file.is_out_of_date ())
@@ -296,17 +296,17 @@ octave_dynamic_loader::do_load_oct (cons
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
                                     const std::string& file_name,
                                     bool /*relative*/)
 {
   octave_function *retval = 0;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib mex_file = octave_shlib_list::find_file (file_name);
 
   if (mex_file && mex_file.is_out_of_date ())
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -313,17 +313,17 @@ static void
 maybe_enter_debugger (octave_execution_exception& e,
                       bool show_stack_trace = false)
 {
   if ((interactive || forced_interactive)
       && ((Vdebug_on_error && bp_table::debug_on_err (last_error_id ()))
           || (Vdebug_on_caught && bp_table::debug_on_caught (last_error_id ())))
       && octave_call_stack::caller_user_code ())
     {
-      unwind_protect frame;
+      octave::unwind_protect frame;
       frame.protect_var (Vdebug_on_error);
       Vdebug_on_error = false;
 
       tree_evaluator::debug_mode = true;
 
       tree_evaluator::current_frame = octave_call_stack::current_frame ();
 
       if (show_stack_trace)
@@ -718,17 +718,17 @@ warning_1 (const char *id, const char *f
       if (! fmt_suppresses_backtrace && in_user_code
           && Vbacktrace_on_warning
           && ! discard_warning_messages)
         pr_where (std::cerr, "warning");
 
       if ((interactive || forced_interactive)
           && Vdebug_on_warning && in_user_code && bp_table::debug_on_warn (id))
         {
-          unwind_protect frame;
+          octave::unwind_protect frame;
           frame.protect_var (Vdebug_on_warning);
           Vdebug_on_warning = false;
 
           tree_evaluator::debug_mode = true;
 
           tree_evaluator::current_frame = octave_call_stack::current_frame ();
 
           do_keyboard (octave_value_list ());
@@ -2151,17 +2151,17 @@ last_warning_message (void)
 
 std::string
 last_warning_id (void)
 {
   return Vlast_warning_id;
 }
 
 void
-interpreter_try (unwind_protect& frame)
+interpreter_try (octave::unwind_protect& frame)
 {
   frame.protect_var (buffer_error_messages);
   frame.protect_var (Vdebug_on_error);
   frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -23,19 +23,20 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_error_h)
 #define octave_error_h 1
 
 #include "octave-config.h"
 
 #include <cstdarg>
 #include <string>
 
+#include "unwind-prot.h"
+
 class octave_map;
 class octave_value_list;
-class unwind_protect;
 class octave_execution_exception;
 
 #define panic_impossible() \
   panic ("impossible state reached in file '%s' at line %d", __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
@@ -165,11 +166,11 @@ extern OCTINTERP_API bool discard_warnin
 
 // Helper functions to pass last error and warning messages and ids
 extern OCTINTERP_API std::string last_error_message (void);
 extern OCTINTERP_API std::string last_error_id (void);
 extern OCTINTERP_API octave_map last_error_stack (void);
 extern OCTINTERP_API std::string last_warning_message (void);
 extern OCTINTERP_API std::string last_warning_id (void);
 
-extern OCTINTERP_API void interpreter_try (unwind_protect&);
+extern OCTINTERP_API void interpreter_try (octave::unwind_protect&);
 
 #endif
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -157,17 +157,17 @@ private:
 void
 gl2ps_renderer::draw (const graphics_object& go, const std::string& print_cmd)
 {
   static bool in_draw = false;
   static std::string old_print_cmd;
 
   if (! in_draw)
     {
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       frame.protect_var (in_draw);
 
       in_draw = true;
 
       GLint gl2ps_term;
       if (term.find ("eps") != std::string::npos)
         gl2ps_term = GL2PS_EPS;
@@ -784,17 +784,17 @@ gl2ps_print (const graphics_object& fig,
 
   // FIXME: should we have a way to create a file that begins with the
   // character '|'?
 
   bool have_cmd = stream.length () > 1 && stream[0] == '|';
 
   FILE *fp = 0;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (have_cmd)
     {
       // Create process and pipe gl2ps output to it.
 
       std::string cmd = stream.substr (1);
 
       fp = octave_popen (cmd.c_str (), "w");
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1653,17 +1653,17 @@ callback_property::validate (const octav
 
 // If TRUE, we are executing any callback function, or the functions it calls.
 // Used to determine handle visibility inside callback functions.
 static bool executing_callback = false;
 
 void
 callback_property::execute (const octave_value& data) const
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   // We are executing the callback function associated with this
   // callback property.  When set to true, we avoid recursive calls to
   // callback routines.
   frame.protect_var (executing);
 
   // We are executing a callback function, so allow handles that have
   // their handlevisibility property set to "callback" to be visible.
@@ -2661,17 +2661,17 @@ delete_graphics_object (double val)
 
 // Flag to stop redraws due to callbacks while deletion is in progress.
 static bool delete_executing = false;
 
 static void
 delete_graphics_objects (const NDArray vals)
 {
   // Prevent redraw of partially deleted objects.
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (delete_executing);
   delete_executing = true;
 
   for (octave_idx_type i = 0; i < vals.numel (); i++)
     delete_graphics_object (vals.elem (i));
 }
 
 static void
@@ -3192,17 +3192,17 @@ base_graphics_object::remove_all_listene
   octave_map m = get (true).map_value ();
 
   for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
     {
       // FIXME: there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       frame.protect_var (discard_error_messages);
       frame.protect_var (Vdebug_on_error);
       frame.protect_var (Vdebug_on_warning);
 
       discard_error_messages = true;
       Vdebug_on_error = false;
       Vdebug_on_warning = false;
@@ -5501,17 +5501,17 @@ axes::properties::update_axes_layout (vo
         zPlane = (dir(1) < 0 ? z_min : z_max);
     }
   else
     zPlane = (dir(2) < 0 ? z_min : z_max);
 
   zPlaneN = (zPlane == z_min ? z_max : z_min);
   fz = (z_max - z_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
   xyzSym = zSign ? xySym : ! xySym;
   xpTick = (zSign ? xPlaneN : xPlane);
   ypTick = (zSign ? yPlaneN : yPlane);
@@ -5647,17 +5647,17 @@ axes::properties::update_xlabel_position
   if (! go.valid_object ())
     return;
 
   text::properties& xlabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool is_empty = xlabel_props.get_string ().is_empty ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_xlabel_position);
   updating_xlabel_position = true;
 
   if (! is_empty)
     {
       if (xlabel_props.horizontalalignmentmode_is ("auto"))
         {
           xlabel_props.set_horizontalalignment
@@ -5748,17 +5748,17 @@ axes::properties::update_ylabel_position
   if (! go.valid_object ())
     return;
 
   text::properties& ylabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool is_empty = ylabel_props.get_string ().is_empty ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
   if (! is_empty)
     {
       if (ylabel_props.horizontalalignmentmode_is ("auto"))
         {
           ylabel_props.set_horizontalalignment
@@ -5859,17 +5859,17 @@ axes::properties::update_zlabel_position
     return;
 
   text::properties& zlabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool camAuto = cameraupvectormode_is ("auto");
   bool is_empty = zlabel_props.get_string ().is_empty ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_zlabel_position);
   updating_zlabel_position = true;
 
   if (! is_empty)
     {
       if (zlabel_props.horizontalalignmentmode_is ("auto"))
         {
           zlabel_props.set_horizontalalignment
@@ -5980,17 +5980,17 @@ axes::properties::update_title_position 
   graphics_object go = gh_manager::get_object (get_title ());
 
   if (! go.valid_object ())
     return;
 
   text::properties& title_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_title_position);
   updating_title_position = true;
 
   if (title_props.positionmode_is ("auto"))
     {
       graphics_xform xform = get_transform ();
 
       // FIXME: bbox should be stored in axes::properties
@@ -6134,17 +6134,17 @@ axes::properties::update_aspectratios (v
       else if (zlimmode_is ("auto") && xlimmode_is ("auto"))
         {
           modified_limits = true;
           max_axes_scale (s, ylimits, kids, pba(1), da(1), 'y', false);
         }
 
       if (modified_limits)
         {
-          unwind_protect frame;
+          octave::unwind_protect frame;
           frame.protect_var (updating_aspectratios);
 
           updating_aspectratios.insert (get___myhandle__ ().value ());
 
           dx = pba(0) * da(0);
           dy = pba(1) * da(1);
           dz = pba(2) * da(2);
           if (xisinf (s))
@@ -7260,17 +7260,17 @@ axes::update_axis_limits (const std::str
 
           update_type = 'a';
         }
 
     }
 
 #undef FIX_LIMITS
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_axis_limits);
 
   updating_axis_limits.insert (get_handle ().value ());
 
   switch (update_type)
     {
     case 'x':
       xproperties.set_xlim (limits);
@@ -7421,17 +7421,17 @@ axes::update_axis_limits (const std::str
           limits(0) = min_val;
           limits(1) = max_val;
 
           update_type = 'a';
         }
 
     }
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_axis_limits);
 
   updating_axis_limits.insert (get_handle ().value ());
 
   switch (update_type)
     {
     case 'x':
       xproperties.set_xlim (limits);
@@ -8164,17 +8164,17 @@ patch::properties::update_fvc (void)
       dv(1) = cd.dims ()(2);
       fvc = cd.reshape (dv);
     }
   else
     fvc = cd.as_column ();
 
   // FIXME: shouldn't we update facevertexalphadata here ?
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_patch_data);
   updating_patch_data = true;
 
   faces.set (idx);
   vertices.set (vert);
   facevertexcdata.set (fvc);
 }
 
@@ -8268,17 +8268,17 @@ patch::properties::update_data (void)
 
           if (pervertex)
             for (int kk = 0; kk < fvc.columns (); kk++)
               cd(ii,jj,kk) = fvc(row,kk);
         }
     }
 
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_patch_data);
   updating_patch_data = true;
 
   set_xdata (xd);
   set_ydata (yd);
   set_zdata (zd);
   set_cdata (cd);
 }
@@ -8492,17 +8492,17 @@ hggroup::update_axis_limits (const std::
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
       limits(3) = max_neg;
     }
 
   get_children_limits (min_val, max_val, min_pos, max_neg, kids, update_type);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_hggroup_limits);
 
   updating_hggroup_limits = true;
 
   if (limits(0) != min_val || limits(1) != max_val
       || limits(2) != min_pos || limits(3) != max_neg)
     {
       limits(0) = min_val;
@@ -8581,17 +8581,17 @@ hggroup::update_axis_limits (const std::
     }
   else if (axis_type == "alim" || axis_type == "aliminclude")
     {
       get_children_limits (min_val, max_val, min_pos, max_neg, kids, 'a');
 
       update_type = 'a';
     }
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (updating_hggroup_limits);
 
   updating_hggroup_limits = true;
 
   Matrix limits (1, 4, 0.0);
 
   limits(0) = min_val;
   limits(1) = max_val;
@@ -9298,17 +9298,17 @@ gh_manager::do_execute_callback (const g
       octave_function *fcn = 0;
 
       args(0) = h.as_octave_value ();
       if (data.is_defined ())
         args(1) = data;
       else
         args(1) = Matrix ();
 
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
       frame.add_fcn (gh_manager::restore_gcbo);
 
       if (true)
         {
           gh_manager::auto_lock guard;
 
           callback_objects.push_front (get_object (h));
           xset_gcbo (h);
@@ -10719,17 +10719,17 @@ undocumented.\n\
 @seealso{refresh}\n\
 @end deftypefn")
 {
   static int drawnow_executing = 0;
 
   if (args.length () > 3)
     print_usage ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (Vdrawnow_requested, false);
   frame.protect_var (drawnow_executing);
 
   // Redraw, unless we are in the middle of an existing redraw or deletion.
   if (++drawnow_executing <= 1 && ! delete_executing)
     {
       gh_manager::auto_lock guard;
@@ -11258,17 +11258,17 @@ In all cases, typing CTRL-C stops progra
 {
   if (args.length () == 0)
     print_usage ();
 
   double h = args(0).xdouble_value ("waitfor: invalid handle value");
 
   caseless_str pname;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   static uint32_t id_counter = 0;
   uint32_t id = 0;
 
   int max_arg_index = 0;
   int timeout_index = -1;
 
   int timeout = 0;
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -519,17 +519,17 @@ static void
 execute_in_debugger_handler (const std::pair<std::string, int>& arg)
 {
   octave_link::execute_in_debugger_event (arg.first, arg.second);
 }
 
 static void
 get_debug_input (const std::string& prompt)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   bool silent = tree_evaluator::quiet_breakpoint_flag;
   tree_evaluator::quiet_breakpoint_flag = false;
 
   octave_user_code *caller = octave_call_stack::caller_user_code ();
   std::string nm;
   int curr_debug_line;
 
@@ -859,17 +859,17 @@ octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (command_history::ignore_entries,
                  command_history::ignoring_entries ());
 
   command_history::ignore_entries (false);
 
   frame.protect_var (Vdebugging);
 
@@ -909,17 +909,17 @@ The @code{keyboard} function does not re
 If @code{keyboard} is invoked without arguments, a default prompt of\n\
 @samp{debug> } is used.\n\
 @seealso{dbstop, dbcont, dbquit}\n\
 @end deftypefn")
 {
   if (args.length () > 1)
     print_usage ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
   // Skip the frame assigned to the keyboard function.
   octave_call_stack::goto_frame_relative (0);
 
   tree_evaluator::debug_mode = true;
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -675,17 +675,17 @@ load_path::do_set (const std::string& p,
                                "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
               break;
             }
         }
     }
 
   // Temporarily disable add hook.
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
   do_clear ();
 
   for (std::list<std::string>::const_iterator i = elts.begin ();
        i != elts.end (); i++)
@@ -2202,17 +2202,17 @@ load_path::do_get_all_package_names (boo
 
 static void
 execute_pkg_add_or_del (const std::string& dir,
                         const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   std::string file = octave::sys::file_ops::concat (dir, script_file);
 
   octave::sys::file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
 }
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -444,17 +444,17 @@ save_mat_binary_data (std::ostream& os, 
 
   int32_t name_len = name.length () + 1;
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name << '\0';
 
   if (tc.is_string ())
     {
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       charMatrix chm = tc.char_matrix_value ();
 
       octave_idx_type nrow = chm.rows ();
       octave_idx_type ncol = chm.cols ();
 
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -969,17 +969,17 @@ read_mat5_binary_element (std::istream& 
             uint32NDArray MCOS = m2.contents ("MCOS").uint32_array_value ();
             octave_idx_type off
               = static_cast<octave_idx_type>(MCOS(4).double_value ());
             m2 = subsys_ov.scalar_map_value ();
             m2 = m2.contents ("MCOS").scalar_map_value ();
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
-            unwind_protect_safe frame;
+            octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
             frame.add_fcn (symbol_table::erase_scope, local_scope);
 
             symbol_table::set_scope (local_scope);
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -260,17 +260,17 @@ parameters for @code{lsode}.\n\
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("lsode: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -2981,17 +2981,17 @@ call_mex (bool have_fmex, void *f, const
   for (int i = 0; i < nargin; i++)
     argin[i] = 0;
 
   int nout = nargout == 0 ? 1 : nargout;
   OCTAVE_LOCAL_BUFFER (mxArray *, argout, nout);
   for (int i = 0; i < nout; i++)
     argout[i] = 0;
 
-  unwind_protect_safe frame;
+  octave::unwind_protect_safe frame;
 
   // Save old mex pointer.
   frame.protect_var (mex_context);
 
   mex context (curr_mex_fcn);
 
   for (int i = 0; i < nargin; i++)
     argin[i] = context.make_value (args(i));
@@ -3213,17 +3213,17 @@ mexGetVariable (const char *space, const
   octave_value val;
 
   if (! strcmp (space, "global"))
     val = get_global_value (name);
   else
     {
       // FIXME: should this be in variables.cc?
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
@@ -3273,17 +3273,17 @@ mexPutVariable (const char *space, const
     return 1;
 
   if (! strcmp (space, "global"))
     set_global_value (name, mxArray::as_octave_value (ptr));
   else
     {
       // FIXME: should this be in variables.cc?
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -129,17 +129,17 @@ static std::string Vhistory_timestamp_fo
 // means read file, arg of -q means don't number lines.  Arg of N
 // means only display that many items.
 
 static string_vector
 do_history (const octave_value_list& args, int nargout)
 {
   bool numbered_output = nargout == 0;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   string_vector hlist;
 
   frame.add_fcn (command_history::set_file, command_history::file ());
 
   int nargin = args.length ();
 
   // Number of history lines to show (-1 = all)
@@ -491,17 +491,17 @@ do_edit_history (const octave_value_list
       delete [] line;
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
   frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
@@ -513,17 +513,17 @@ do_run_history (const octave_value_list&
 {
   std::string name = mk_tmp_hist_file (args, false, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better sense.
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
   frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -446,17 +446,17 @@ octave_diary_stream::instance_ok (void)
   return retval;
 }
 
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       frame.protect_var (really_flush_to_pager);
       frame.protect_var (flushing_output_to_pager);
 
       really_flush_to_pager = true;
       flushing_output_to_pager = true;
 
       octave_stdout.flush ();
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3434,17 +3434,17 @@ If the length of the smallest possible r
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
   if (! arg.is_numeric_type ())
     error ("rats: X must be numeric");
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (rat_string_len);
 
   rat_string_len = 9;
   if (nargin == 2)
     rat_string_len = args(1).nint_value ();
 
   frame.protect_var (rat_format);
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -375,19 +375,19 @@ jit_convert::visit_decl_init_list (tree_
 void
 jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   // Note we do an initial check to see if the loop will run atleast once.
   // This allows us to get better type inference bounds on variables defined
   // and used only inside the for loop (e.g. the index variable)
 
   // If we are a nested for loop we need to store the previous breaks
-  unwind_protect prot;
-  prot.protect_var (breaks);
-  prot.protect_var (continues);
+  octave::unwind_protect frame;
+  frame.protect_var (breaks);
+  frame.protect_var (continues);
   breaks.clear ();
   continues.clear ();
 
   // we need a variable for our iterator, because it is used in multiple blocks
   std::string iter_name = next_iterator ();
   jit_variable *iterator = factory.create<jit_variable> (iter_name);
   factory.create<jit_variable> (iter_name);
   vmap[iter_name] = iterator;
@@ -950,19 +950,19 @@ void
 jit_convert::visit_unwind_protect_command (tree_unwind_protect_command&)
 {
   throw jit_fail_exception ("No visit_unwind_protect_command implementation");
 }
 
 void
 jit_convert::visit_while_command (tree_while_command& wc)
 {
-  unwind_protect prot;
-  prot.protect_var (breaks);
-  prot.protect_var (continues);
+  octave::unwind_protect frame;
+  frame.protect_var (breaks);
+  frame.protect_var (continues);
   breaks.clear ();
   continues.clear ();
 
   jit_block *cond_check = factory.create<jit_block> ("while_cond_check");
   block->append (factory.create<jit_branch> (cond_check));
   blocks.push_back (cond_check);
   block = cond_check;
 
@@ -1012,19 +1012,19 @@ jit_convert::visit_while_command (tree_w
 
   blocks.push_back (tail);
   block = tail;
 }
 
 void
 jit_convert::visit_do_until_command (tree_do_until_command& duc)
 {
-  unwind_protect prot;
-  prot.protect_var (breaks);
-  prot.protect_var (continues);
+  octave::unwind_protect frame;
+  frame.protect_var (breaks);
+  frame.protect_var (continues);
   breaks.clear ();
   continues.clear ();
 
   jit_block *body = factory.create<jit_block> ("do_until_body");
   jit_block *cond_check = factory.create<jit_block> ("do_until_cond_check");
   jit_block *tail = factory.create<jit_block> ("do_until_tail");
 
   block->append (factory.create<jit_branch> (body));
@@ -1211,18 +1211,18 @@ jit_convert::resolve (tree_index_express
   size_t narg = arg_list->size ();
   tree_argument_list::iterator iter = arg_list->begin ();
   bool have_extra = extra_arg;
   std::vector<jit_value *> call_args (narg + 1 + have_extra);
   call_args[0] = object;
 
   for (size_t idx = 0; iter != arg_list->end (); ++idx, ++iter)
     {
-      unwind_protect prot;
-      prot.add_method (&end_context,
+      octave::unwind_protect frame;
+      frame.add_method (&end_context,
                        &std::vector<jit_magic_end::context>::pop_back);
 
       jit_magic_end::context ctx (factory, object, idx, narg);
       end_context.push_back (ctx);
       call_args[idx + 1] = visit (*iter);
     }
 
   if (extra_arg)
@@ -1273,18 +1273,18 @@ jit_convert::do_assign (const std::strin
     }
 
   return var;
 }
 
 jit_value *
 jit_convert::visit (tree& tee)
 {
-  unwind_protect prot;
-  prot.protect_var (result);
+  octave::unwind_protect frame;
+  frame.protect_var (result);
 
   tee.accept (*this);
   return result;
 }
 
 void
 jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
 {
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -177,17 +177,17 @@ variable by routines @code{dblquad} and 
 {
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
 
   warned_imaginary = false;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("quad: invalid recursive call");
 
   std::string fcn_name;
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -87,17 +87,17 @@ do_rand (const octave_value_list& args, 
           idx++;
           nargin--;
         }
     }
 
   octave_value retval;
   dim_vector dims;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   // Restore current distribution on any exit.
   frame.add_fcn (octave_rand::distribution,
                  octave_rand::distribution ());
 
   octave_rand::distribution (distribution);
 
   switch (nargin)
     {
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -125,17 +125,17 @@ Compressed Column Sparse (rows = 3, cols
   int nargin = args.length ();
 
   if (nargin == 0 || nargin > 6)
     print_usage ();
 
   octave_value retval;
 
   // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
-  unwind_protect frame;
+  octave::unwind_protect frame;
   frame.protect_var (Vsparse_auto_mutate);
   Vsparse_auto_mutate = false;
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
       if (arg.is_bool_type ())
         retval = arg.sparse_bool_matrix_value ();
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1015,17 +1015,17 @@ wait_for_input (int fid)
 
   return retval;
 }
 
 static octave_value_list
 run_command_and_return_output (const std::string& cmd_str)
 {
   octave_value_list retval;
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   frame.add_delete (cmd);
   frame.add_fcn (octave_child_list::remove, cmd->pid ());
 
   if (! *cmd)
     error ("system: unable to start subprocess for '%s'", cmd_str.c_str ());
@@ -1136,17 +1136,17 @@ command shell that is started to run the
         type = et_async;
       else
         error ("system: TYPE must be \"sync\" or \"async\"");
     }
 
   octave_value_list retval;
 
   // FIXME: Is this unwind_protect frame needed anymore (12/16/15)?
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   bool return_output = (nargin == 1 && nargout > 1);
 
   if (nargin > 1)
     {
       try
         {
           return_output = args(1).is_true ();
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -523,17 +523,17 @@ private:
       recover_from_exception (); \
     }
 
 #define OCTAVE_SAFE_CALL(F, ARGS) \
   do \
     { \
       try \
         { \
-          unwind_protect frame; \
+          octave::unwind_protect frame; \
  \
           frame.protect_var (Vdebug_on_error); \
           frame.protect_var (Vdebug_on_warning); \
  \
           Vdebug_on_error = false; \
           Vdebug_on_warning = false; \
  \
           F ARGS; \
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -47,17 +47,17 @@ get_vec_dims (const dim_vector& old_dims
 }
 
 template <typename ArrayType>
 static void
 get_data_and_bytesize (const ArrayType& array,
                        const void *& data,
                        octave_idx_type& byte_size,
                        dim_vector& old_dims,
-                       unwind_protect& frame)
+                       octave::unwind_protect& frame)
 {
   // The array given may be a temporary, constructed from a scalar or sparse
   // array. This will ensure the data will be deallocated after we exit.
   frame.add_delete (new ArrayType (array));
 
   data = reinterpret_cast<const void *> (array.data ());
   byte_size = array.byte_size ();
 
@@ -138,17 +138,17 @@ typecast (@var{x}, \"uint8\")\n\
 @seealso{cast, bitpack, bitunpack, swapbytes}\n\
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   const void *data = 0;
   octave_idx_type byte_size = 0;
   dim_vector old_dims;
 
   octave_value array = args(0);
 
   if (array.is_bool_type ())
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -361,17 +361,17 @@ urlwrite (\"http://www.google.com/search
 
   octave::sys::file_stat fs (filename);
 
   std::ofstream ofile (filename.c_str (), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
     error ("urlwrite: unable to open file");
 
-  unwind_protect_safe frame;
+  octave::unwind_protect_safe frame;
 
   frame.add_fcn (delete_file, filename);
 
   url_transfer curl = url_transfer (url, ofile);
 
   octave_value_list retval;
 
   if (! curl.is_valid ())
@@ -899,17 +899,17 @@ Undocumented internal function\n\
             {
               std::ofstream ofile ((target + sv(i)).c_str (),
                                    std::ios::out |
                                    std::ios::binary);
 
               if (! ofile.is_open ())
                 error ("__ftp_mget__: unable to open file");
 
-              unwind_protect_safe frame;
+              octave::unwind_protect_safe frame;
 
               frame.add_fcn (delete_file, target + sv(i));
 
               curl.get (sv(i), ofile);
 
               ofile.close ();
 
               if (curl.good ())
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1361,17 +1361,17 @@ character @nospell{\"@xbackslashchar{}0\
     print_usage ();
 
   octave_idx_type n = 0;
   if (nargin == 2)
     n = args(1).idx_type_value ();
 
   octave_value retval;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (discard_error_messages);
   discard_error_messages = true;
 
   try
     {
       idx_vector idx = args(0).index_vector (true);
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -253,17 +253,17 @@ generate_struct_completions (const std::
 
       if (pos != std::string::npos)
         base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
         {
           int parse_status;
 
-          unwind_protect frame;
+          octave::unwind_protect frame;
 
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           try
@@ -299,17 +299,17 @@ looks_like_struct (const std::string& te
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       frame.protect_var (discard_error_messages);
 
       discard_error_messages = true;
 
       octave_value tmp = eval_string (text, true, parse_status);
 
       frame.run ();
@@ -365,17 +365,17 @@ isglobal (\"x\")\n\
 %!error isglobal (1)
 */
 
 static octave_value
 safe_symbol_lookup (const std::string& symbol_name)
 {
   octave_value retval;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
   interpreter_try (frame);
 
   try
     {
       retval = symbol_table::find (symbol_name);
     }
   catch (const octave_execution_exception&)
     {
@@ -1661,17 +1661,17 @@ do_who (int argc, const string_vector& a
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a filename");
 
           std::string nm = argv[i + 1];
 
-          unwind_protect frame;
+          octave::unwind_protect frame;
 
           // Set up temporary scope.
 
           symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
           frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
           symbol_table::set_scope (tmp_scope);
 
@@ -2638,17 +2638,17 @@ void maybe_missing_function_hook (const 
   // Don't do this if we're handling errors.
   if (buffer_error_messages == 0 && ! Vmissing_function_hook.empty ())
     {
       octave_value val = symbol_table::find_function (Vmissing_function_hook);
 
       if (val.is_defined ())
         {
           // Ensure auto-restoration.
-          unwind_protect frame;
+          octave::unwind_protect frame;
           frame.protect_var (Vmissing_function_hook);
 
           // Clear the variable prior to calling the function.
           const std::string func_name = Vmissing_function_hook;
           Vmissing_function_hook.clear ();
 
           // Call.
           feval (func_name, octave_value (name));
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -141,17 +141,17 @@ Undocumented internal function.\n\
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
       // Qhull flags argument is not const char*
       OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length ());
 
       sprintf (flags, "qhull d %s", options.c_str ());
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
 
       // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
       FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
       FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
       FILE *errfile = stderr;
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -185,17 +185,17 @@ Undocumented internal function.\n\
   int disp = 0;
   octave_idx_type p = -1;
   ColumnVector resid;
   ComplexColumnVector cresid;
   octave_idx_type info = 1;
 
   warned_imaginary = false;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("eigs: invalid recursive call");
 
   if (args(0).is_function_handle () || args(0).is_inline_function ()
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -133,17 +133,17 @@ instead.\n\
   // (Version 8.0 until 9.1.4 all return MAJOR 6, MINOR 5)
   GLint z, s;
   glGetIntegerv (GL_DEPTH_BITS, &z);
   glGetIntegerv (GL_STENCIL_BITS, &s);
   if (z != 16 || s != 0)
     error ("__osmesa_print__: Depth and stencil doesn't match,"
            " are you sure you are using OSMesa >= 9.0?");
 
-  unwind_protect outer_frame;
+  octave::unwind_protect outer_frame;
 
   bool v = fp.is_visible ();
 
   if (v)
     {
       outer_frame.add_fcn (reset_visibility, &fp);
 
       fp.set_visible ("off");
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -132,17 +132,17 @@ Undocumented internal function.\n\
         }
       else
         error ("%s: OPTIONS must be a string, cell array of strings, or empty",
                caller.c_str ());
     }
 
   boolT ismalloc = false;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
   FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -1098,17 +1098,17 @@ audioplayer::playblocking (void)
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audioplayer: unable to start start audio playback stream");
 
   unsigned int start, end;
   start = get_sample_number ();
   end = get_end_sample ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (safe_audioplayer_stop, this);
 
   for (unsigned int i = start; i < end; i += buffer_size)
     {
       OCTAVE_QUIT;
       if (octave_callback_function != 0)
         octave_play_callback (0, buffer, buffer_size, 0, 0, this);
@@ -1718,17 +1718,17 @@ audiorecorder::recordblocking (float sec
     error ("audiorecorder: unable to open audio recording stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audiorecorder: unable to start audio recording stream");
 
   unsigned int frames = seconds * get_fs ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (safe_audiorecorder_stop, this);
 
   for (unsigned int i = 0; i < frames; i += buffer_size)
     {
       OCTAVE_QUIT;
       Pa_ReadStream (get_stream (), buffer, buffer_size);
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -86,17 +86,17 @@ is stored in the audio file.\n\
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
     error ("audioread: failed to open input file %s", filename.c_str ());
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   OCTAVE_LOCAL_BUFFER (float, data, info.frames * info.channels);
 
   sf_read_float (file, data, info.frames * info.channels);
 
   sf_count_t start = 0;
@@ -389,17 +389,17 @@ Comment.\n\
         error ("audiowrite: wrong argument name");
     }
 
   SNDFILE *file = sf_open (filename.c_str (), SFM_WRITE, &info);
 
   if (! file)
     error ("audiowrite: failed to open output file %s", filename.c_str ());
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   if (title != "")
     sf_set_string (file, SF_STR_TITLE, title.c_str ());
 
   if (artist != "")
     sf_set_string (file, SF_STR_ARTIST, artist.c_str ());
@@ -457,17 +457,17 @@ Return information about an audio file s
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
     error ("audioinfo: failed to open file %s", filename.c_str ());
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (safe_close, file);
 
   octave_scalar_map result;
 
   result.assign ("Filename", filename);
   result.assign ("CompressionMethod", "");
   result.assign ("NumChannels", info.channels);
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -149,17 +149,17 @@ convex hull is calculated.\n\n\
             options += " " + tmp(i);
         }
       else
         error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
     }
 
   boolT ismalloc = false;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
   FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -103,17 +103,17 @@ octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args,
                                    const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_call_stack::push (this);
 
   frame.add_fcn (octave_call_stack::pop);
 
   if (lvalue_list || curr_lvalue_list)
     {
       frame.protect_var (curr_lvalue_list);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -552,17 +552,17 @@ octave_class::subsasgn_common (const oct
           // copies anywhere. If it does, things will not break but the
           // optimization won't work.
 
           octave_value_list tmp;
 
           if (obsolete_copies == 0 && meth.is_user_function ()
               && meth.user_function_value ()->subsasgn_optimization_ok ())
             {
-              unwind_protect frame;
+              octave::unwind_protect frame;
               frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
               tmp = feval (meth.function_value (), args);
             }
           else
             tmp = feval (meth.function_value (), args);
 
@@ -989,17 +989,17 @@ void
 octave_class::print (std::ostream& os, bool)
 {
   print_raw (os);
 }
 
 void
 octave_class::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   indent (os);
   os << "  <class " << class_name () << ">";
   newline (os);
 }
 
 bool
 octave_class::print_name_tag (std::ostream& os, const std::string& name) const
@@ -1073,17 +1073,17 @@ octave_class::reconstruct_exemplar (void
           // Something has gone terribly wrong if
           // symbol_table::find_method (c_name, c_name) does not return
           // a class constructor for the class c_name...
           assert (have_ctor);
         }
 
       if (have_ctor)
         {
-          unwind_protect frame;
+          octave::unwind_protect frame;
 
           // Simulate try/catch.
 
           interpreter_try (frame);
 
           bool execution_error = false;
 
           octave_value_list result;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -419,17 +419,17 @@ octave_fcn_handle::load_ascii (std::istr
           // Get a line of text whitespace characters included, leaving
           // newline in the stream.
           buf = read_until_newline (is, true);
 
         }
 
       pos = is.tellg ();
 
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
@@ -603,17 +603,17 @@ octave_fcn_handle::load_binary (std::ist
         swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       // is.get (ctmp2, tmp+1, 0); caused is.eof () to be true though
       // effectively not reading over file end
       is.read (ctmp2, tmp);
       ctmp2[tmp] = 0;
 
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
@@ -1110,17 +1110,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
       // restore error reporting:
 #if defined (HAVE_HDF5_18)
       H5Eset_auto (octave_H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
@@ -2032,17 +2032,17 @@ octave_fcn_binder::maybe_binder (const o
                           // dispatch, so we make sure it's not
                           // defined.
 
                           if (symbol_table::get_dispatch (head_name).size () > 0)
                             bad = true;
                           else
                             {
                               // Simulate try/catch.
-                              unwind_protect frame;
+                              octave::unwind_protect frame;
                               interpreter_try (frame);
 
                               try
                                 {
                                   root_val = make_fcn_handle (head_name);
                                 }
                               catch (const octave_execution_exception&)
                                 {
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -130,17 +130,17 @@ octave_value_list
 octave_mex_function::do_multi_index_op (int nargout,
                                         const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_call_stack::push (this);
 
   frame.add_fcn (octave_call_stack::pop);
 
   BEGIN_PROFILER_BLOCK (octave_mex_function)
 
     retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -61,17 +61,17 @@ octave_oncleanup::octave_oncleanup (cons
     }
 }
 
 octave_oncleanup::~octave_oncleanup (void)
 {
   if (fcn.is_undefined ())
     return;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   // Clear interrupts.
   frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // Disallow quit().
   frame.protect_var (quit_allowed);
   quit_allowed = false;
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -564,17 +564,17 @@ void
 octave_struct::print (std::ostream& os, bool)
 {
   print_raw (os);
 }
 
 void
 octave_struct::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print >= 0)
     {
       bool max_depth_reached = Vstruct_levels_to_print-- == 0;
 
       bool print_fieldnames_only
@@ -1246,17 +1246,17 @@ void
 octave_scalar_struct::print (std::ostream& os, bool)
 {
   print_raw (os);
 }
 
 void
 octave_scalar_struct::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print >= 0)
     {
       bool max_depth_reached = Vstruct_levels_to_print-- == 0;
 
       bool print_fieldnames_only = max_depth_reached;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -119,17 +119,17 @@ octave_user_script::subsref (const std::
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
                                        const octave_value_list& args)
 {
   octave_value_list retval;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (args.length () != 0 || nargout != 0)
     error ("invalid call to script %s", file_name.c_str ());
 
   if (cmd_list)
     {
       frame.protect_var (call_depth);
       call_depth++;
@@ -486,17 +486,17 @@ octave_user_function::do_multi_index_op 
     }
 
 #if defined (HAVE_LLVM)
   if (is_special_expr ()
       && tree_jit::execute (*this, args, retval))
     return retval;
 #endif
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
     error ("max_recursion_depth exceeded");
 
   // Save old and set current symbol table context, for
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -493,17 +493,17 @@ private:
   bool class_method;
 
   // The scope of the parent function, if any.
   symbol_table::scope_id parent_scope;
 
   symbol_table::scope_id local_scope;
 
   // pointer to the current unwind_protect frame of this function.
-  unwind_protect *curr_unwind_protect_frame;
+  octave::unwind_protect *curr_unwind_protect_frame;
 
 #if defined (HAVE_LLVM)
   jit_function_info *jit_info;
 #endif
 
   void maybe_relocate_end_internal (void);
 
   void print_code_function_header (void);
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -237,17 +237,17 @@ initialize_load_path (void)
   // Temporarily set the execute_pkg_add function to one that catches
   // exceptions.  This is better than wrapping load_path::initialize in
   // a try-catch block because it will not stop executing PKG_ADD files
   // at the first exception.  It's also better than changing the default
   // execute_pkg_add function to use safe_source file because that will
   // normally be evaluated from the normal intepreter loop where
   // exceptions are already handled.
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.add_fcn (load_path::set_add_hook, load_path::get_add_hook ());
 
   load_path::set_add_hook (execute_pkg_add);
 
   load_path::initialize (set_initial_path);
 }
 
@@ -345,17 +345,17 @@ safe_source_file (const std::string& fil
     }
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   std::string context;
 
   bool verbose = (verbose_flag && ! inhibit_startup_message);
 
   bool require_file = false;
 
   if (read_site_files)
@@ -417,17 +417,17 @@ execute_startup_files (void)
           safe_source_file (local_rc, context, verbose, require_file);
         }
     }
 }
 
 static int
 execute_eval_option_code (const std::string& code)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
   octave_interrupt_hook = 0;
   octave_bad_alloc_hook = 0;
@@ -462,17 +462,17 @@ execute_eval_option_code (const std::str
     }
 
   return parse_status;
 }
 
 static void
 execute_command_line_file (const std::string& fname)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
   octave_interrupt_hook = 0;
   octave_bad_alloc_hook = 0;
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2209,17 +2209,17 @@ octave_base_parser::maybe_warn_variable_
 
 // Finish building a range.
 
 tree_expression *
 octave_base_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (discard_error_messages);
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *base = e->base ();
@@ -3834,17 +3834,17 @@ octave_base_parser::validate_matrix_for_
 
 // Finish building an array_list.
 
 tree_expression *
 octave_base_parser::finish_array_list (tree_array_list *array_list)
 {
   tree_expression *retval = array_list;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (discard_error_messages);
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   if (array_list->all_elements_are_constant ())
@@ -4135,17 +4135,17 @@ safe_fclose (FILE *f)
 
 static octave_function *
 parse_fcn_file (const std::string& full_file, const std::string& file,
                 const std::string& dispatch_type,
                 const std::string& package_name,
                 bool require_file, bool force_script, bool autoload,
                 bool relative_lookup, const std::string& warn_for)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
   FILE *in_stream = command_editor::get_input_stream ();
 
   frame.add_fcn (command_editor::set_input_stream, in_stream);
@@ -4325,17 +4325,17 @@ reverse_lookup_autoload (const std::stri
 octave_function *
 load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
                     const std::string& dispatch_type,
                     const std::string& package_name,
                     const std::string& fcn_name, bool autoload)
 {
   octave_function *retval = 0;
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   std::string nm = file_name;
 
   size_t nm_len = nm.length ();
 
   std::string file;
 
   bool relative_lookup = false;
@@ -4565,17 +4565,17 @@ source_file (const std::string& file_nam
   // (for example).
 
   static std::map<std::string, int> source_call_depth;
 
   std::string file_full_name = octave::sys::file_ops::tilde_expand (file_name);
 
   file_full_name = octave::sys::env::make_absolute (file_full_name);
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (source_call_depth.find (file_full_name) == source_call_depth.end ())
     source_call_depth[file_full_name] = -1;
 
   frame.protect_var (source_call_depth[file_full_name]);
 
   source_call_depth[file_full_name]++;
 
@@ -5082,17 +5082,17 @@ the security considerations that the eva
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (nargin > 1)
     {
       frame.protect_var (buffer_error_messages);
       buffer_error_messages++;
     }
 
   int parse_status = 0;
@@ -5188,17 +5188,17 @@ may be either @qcode{\"base\"} or @qcode
 {
   octave_value_list retval;
 
   if (args.length () != 3)
     print_usage ();
 
   std::string context = args(0).xstring_value ("assignin: CONTEXT must be a string");
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (context == "caller")
     octave_call_stack::goto_caller_frame ();
   else if (context == "base")
     octave_call_stack::goto_base_frame ();
   else
     error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
@@ -5242,17 +5242,17 @@ Like @code{eval}, except that the expres
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
   std::string context = args(0).xstring_value ("evalin: CONTEXT must be a string");
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (context == "caller")
     octave_call_stack::goto_caller_frame ();
   else if (context == "base")
     octave_call_stack::goto_base_frame ();
   else
     error ("evalin: CONTEXT must be \"caller\" or \"base\"");
 
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -204,17 +204,17 @@ tree_argument_list::convert_to_const_vec
   // END doesn't make sense for functions.  Maybe we need a different
   // way of asking an octave_value object this question?
 
   bool stash_object = (list_includes_magic_end
                        && object
                        && ! (object->is_function ()
                              || object->is_function_handle ()));
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   if (stash_object)
     {
       frame.protect_var (indexed_object);
 
       indexed_object = object;
     }
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -282,17 +282,17 @@ void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint (true));
 
   // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
   // and cmd.maxproc_expr ();
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
@@ -394,17 +394,17 @@ tree_evaluator::visit_simple_for_command
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint (true));
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
@@ -825,17 +825,17 @@ tree_evaluator::visit_switch_command (tr
             }
         }
     }
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (buffer_error_messages);
   frame.protect_var (Vdebug_on_error);
   frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
@@ -897,17 +897,17 @@ tree_evaluator::visit_try_catch_command 
             catch_code->accept (*this);
         }
     }
 }
 
 void
 tree_evaluator::do_unwind_protect_cleanup_code (tree_statement_list *list)
 {
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // We want to preserve the last location info for possible
   // backtracking.
   frame.add_fcn (octave_call_stack::set_line,
                  octave_call_stack::current_line ());
@@ -1016,17 +1016,17 @@ tree_evaluator::visit_unwind_protect_com
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
 #if defined (HAVE_LLVM)
   if (tree_jit::execute (cmd))
     return;
 #endif
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
@@ -1055,17 +1055,17 @@ tree_evaluator::visit_while_command (tre
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
 #if defined (HAVE_LLVM)
   if (tree_jit::execute (cmd))
     return;
 #endif
 
-  unwind_protect frame;
+  octave::unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
   int until_line = cmd.line ();
   int until_column = cmd.column ();
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -60,17 +60,17 @@ tree::meets_bp_condition () const
   if (bp == 0)
     retval = false;
   else if (bp->length () == 0)     // empty condition always met
     retval = true;
   else
     {
       int parse_status = 0;
 
-      unwind_protect frame;
+      octave::unwind_protect frame;
       frame.protect_var (buffer_error_messages);
       frame.protect_var (Vdebug_on_error);
       frame.protect_var (Vdebug_on_warning);
 
       buffer_error_messages++;
       Vdebug_on_error = false;
       Vdebug_on_warning = false;
 
diff --git a/liboctave/util/unwind-prot.cc b/liboctave/util/unwind-prot.cc
--- a/liboctave/util/unwind-prot.cc
+++ b/liboctave/util/unwind-prot.cc
@@ -23,16 +23,19 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "lo-error.h"
 #include "unwind-prot.h"
 
-void
-unwind_protect_safe::warn_unhandled_exception (void) const
+namespace octave
 {
-  (*current_liboctave_warning_handler)
-    ("unhandled exception in unwind_protect_safe handler.  "
-     "It is a bug in Octave for this to happen.  "
-     "Please help improve Octave by reporting it.");
+  void
+  unwind_protect_safe::warn_unhandled_exception (void) const
+  {
+    (*current_liboctave_warning_handler)
+      ("unhandled exception in unwind_protect_safe handler.  "
+       "It is a bug in Octave for this to happen.  "
+       "Please help improve Octave by reporting it.");
+  }
 }
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -28,125 +28,138 @@ along with Octave; see the file COPYING.
 
 #include <cstddef>
 
 #include <stack>
 #include <memory>
 
 #include "action-container.h"
 
-class
-OCTAVE_API
-unwind_protect : public action_container
+namespace octave
 {
-public:
+  class
+  OCTAVE_API
+  unwind_protect : public action_container
+  {
+  public:
+
+    unwind_protect (void) : lifo () { }
 
-  unwind_protect (void) : lifo () { }
+    // Destructor should not raise an exception, so all actions
+    // registered should be exception-safe.  If you're not sure, see
+    // unwind_protect_safe.
 
-  // Destructor should not raise an exception, so all actions
-  // registered should be exception-safe.  If you're not sure, see
-  // unwind_protect_safe.
+    ~unwind_protect (void) { run (); }
+
+    virtual void add (elem *new_elem)
+    {
+      lifo.push (new_elem);
+    }
 
-  ~unwind_protect (void) { run (); }
+    OCTAVE_DEPRECATED ("use 'add (new fcn_arg_elem<void *> (fcn, ptr))' instead")
+    void add (void (*fcn) (void *), void *ptr = 0)
+    {
+      add (new fcn_arg_elem<void *> (fcn, ptr));
+    }
+
+    operator bool (void) const { return ! empty (); }
+
+    OCTAVE_DEPRECATED ("use 'run_first' instead")
+    void run_top (void) { run_first (); }
 
-  virtual void add (elem *new_elem)
-  {
-    lifo.push (new_elem);
-  }
+    void run_first (void)
+    {
+      if (! empty ())
+        {
+          // No leak on exception!
+          std::unique_ptr<elem> ptr (lifo.top ());
+          lifo.pop ();
+          ptr->run ();
+        }
+    }
 
-  OCTAVE_DEPRECATED ("use 'add (new fcn_arg_elem<void *> (fcn, ptr))' instead")
-  void add (void (*fcn) (void *), void *ptr = 0)
-  {
-    add (new fcn_arg_elem<void *> (fcn, ptr));
-  }
+    OCTAVE_DEPRECATED ("use 'run' instead")
+    void run_top (int num) { run (num); }
 
-  operator bool (void) const { return ! empty (); }
+    OCTAVE_DEPRECATED ("use 'discard_first' instead")
+    void discard_top (void) { discard_first (); }
+
+    void discard_first (void)
+    {
+      if (! empty ())
+        {
+          elem *ptr = lifo.top ();
+          lifo.pop ();
+          delete ptr;
+        }
+    }
+
+    OCTAVE_DEPRECATED ("use 'discard' instead")
+    void discard_top (int num) { discard (num); }
+
+    size_t size (void) const { return lifo.size (); }
+
+  protected:
 
-  OCTAVE_DEPRECATED ("use 'run_first' instead")
-  void run_top (void) { run_first (); }
+    std::stack<elem *> lifo;
+
+  private:
+
+    // No copying!
+
+    unwind_protect (const unwind_protect&);
 
-  void run_first (void)
+    unwind_protect& operator = (const unwind_protect&);
+  };
+
+  // Like unwind_protect, but this one will guard against the
+  // possibility of seeing an exception (or interrupt) in the cleanup
+  // actions. Not that we can do much about it, but at least we won't
+  // crash.
+
+  class
+  OCTAVE_API
+  unwind_protect_safe : public unwind_protect
   {
-    if (! empty ())
-      {
-        // No leak on exception!
-        std::unique_ptr<elem> ptr (lifo.top ());
-        lifo.pop ();
-        ptr->run ();
-      }
-  }
+  private:
+
+    void warn_unhandled_exception (void) const;
 
-  OCTAVE_DEPRECATED ("use 'run' instead")
-  void run_top (int num) { run (num); }
+  public:
 
-  OCTAVE_DEPRECATED ("use 'discard_first' instead")
-  void discard_top (void) { discard_first (); }
+    unwind_protect_safe (void) : unwind_protect () { }
 
-  void discard_first (void)
-  {
-    if (! empty ())
+    ~unwind_protect_safe (void)
       {
-        elem *ptr = lifo.top ();
-        lifo.pop ();
-        delete ptr;
-      }
-  }
-
-  OCTAVE_DEPRECATED ("use 'discard' instead")
-  void discard_top (int num) { discard (num); }
-
-  size_t size (void) const { return lifo.size (); }
-
-protected:
-
-  std::stack<elem *> lifo;
-
-private:
-
-  // No copying!
-
-  unwind_protect (const unwind_protect&);
-
-  unwind_protect& operator = (const unwind_protect&);
-};
-
-// Like unwind_protect, but this one will guard against the
-// possibility of seeing an exception (or interrupt) in the cleanup
-// actions. Not that we can do much about it, but at least we won't
-// crash.
-
-class
-OCTAVE_API
-unwind_protect_safe : public unwind_protect
-{
-private:
-
-  void warn_unhandled_exception (void) const;
-
-public:
-
-  unwind_protect_safe (void) : unwind_protect () { }
-
-  ~unwind_protect_safe (void)
-  {
-    while (! empty ())
-      {
-        try
+        while (! empty ())
           {
-            run_first ();
-          }
-        catch (...) // Yes, the black hole.  Remember we're in a destructor.
-          {
-            warn_unhandled_exception ();
+            try
+              {
+                run_first ();
+              }
+            catch (...) // Yes, the black hole.  Remember we're in a destructor.
+              {
+                warn_unhandled_exception ();
+              }
           }
       }
-  }
+
+  private:
 
-private:
+    // No copying!
+
+    unwind_protect_safe (const unwind_protect_safe&);
 
-  // No copying!
+    unwind_protect_safe& operator = (const unwind_protect_safe&);
+  };
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  unwind_protect_safe (const unwind_protect_safe&);
+OCTAVE_DEPRECATED ("use octave::unwind_protect instead")
+typedef octave::unwind_protect unwind_protect;
 
-  unwind_protect_safe& operator = (const unwind_protect_safe&);
-};
+OCTAVE_DEPRECATED ("use octave::unwind_protect_safe instead")
+typedef octave::unwind_protect_safe unwind_protect_safe;
 
 #endif
+
+#endif
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -71,17 +71,17 @@ base_url_transfer::mget_directory (const
           return;
         }
     }
 
   cwd (directory);
 
   if (good ())
     {
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, this);
 
       string_vector sv = list ();
 
       for (octave_idx_type i = 0; i < sv.numel (); i++)
         {
           time_t ftime;
@@ -101,17 +101,17 @@ base_url_transfer::mget_directory (const
 
               if (! ofile.is_open ())
                 {
                   ok = false;
                   errmsg = "__ftp_mget__: unable to open file";
                   break;
                 }
 
-              unwind_protect_safe frame2;
+              octave::unwind_protect_safe frame2;
 
               frame2.add_fcn (delete_file, realfile);
 
               get (sv(i), ofile);
 
               ofile.close ();
 
               if (good ())
@@ -138,17 +138,17 @@ base_url_transfer::mput_directory (const
 
   if (! good ())
     return file_list;
 
   cwd (directory);
 
   if (good ())
     {
-      unwind_protect_safe frame;
+      octave::unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, this);
 
       octave::sys::dir_entry dirlist (realdir);
 
       if (dirlist)
         {
           string_vector files = dirlist.read ();
@@ -403,17 +403,17 @@ public:
   {
     ftp_file_or_dir_action (path, "mkd");
   }
 
   void rename (const std::string& oldname, const std::string& newname)
   {
     struct curl_slist *slist = 0;
 
-    unwind_protect frame;
+    octave::unwind_protect frame;
     frame.add_fcn (curl_slist_free_all, slist);
 
     std::string cmd = "rnfr " + oldname;
     slist = curl_slist_append (slist, cmd.c_str ());
     cmd = "rnto " + newname;
     slist = curl_slist_append (slist, cmd.c_str ());
     SETOPT (CURLOPT_POSTQUOTE, slist);
 
@@ -571,17 +571,17 @@ public:
   }
 
   std::string pwd (void)
   {
     std::string retval;
 
     struct curl_slist *slist = 0;
 
-    unwind_protect frame;
+    octave::unwind_protect frame;
     frame.add_fcn (curl_slist_free_all, slist);
 
     slist = curl_slist_append (slist, "pwd");
     SETOPTR (CURLOPT_POSTQUOTE, slist);
     SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
 
     std::ostringstream buf;
     SETOPTR (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
@@ -741,17 +741,17 @@ private:
     return query.str ();
   }
 
   void ftp_file_or_dir_action (const std::string& file_or_dir,
                                const std::string& action)
   {
     struct curl_slist *slist = 0;
 
-    unwind_protect frame;
+    octave::unwind_protect frame;
 
     frame.add_fcn (curl_slist_free_all, slist);
 
     std::string cmd = action + " " + file_or_dir;
 
     slist = curl_slist_append (slist, cmd.c_str ());
 
     SETOPT (CURLOPT_POSTQUOTE, slist);
