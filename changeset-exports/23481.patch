# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1494428992 14400
#      Wed May 10 11:09:52 2017 -0400
# Node ID 73558a835b6461db5634ef3bc80e42dba21e9e80
# Parent  0670624ea91b7ffe24bce5c1838cba72a9ed949d
eliminate lvalue list arguments from evaluator functions

* ov.cc, ov.h, ov-base.cc, ov-base.h, ov-builtin.cc, ov-builtin.h,
ov-cell.cc, ov-cell.h, ov-fcn-handle.cc, ov-fcn-handle.h,
ov-usr-fcn.cc, ov-usr-fcn.h: Eliminate lvalue_list arguments from
subsref, next_subsref, and do_multi_index_op methods.  Change all
callers.

* pt-eval.cc, pt-eval.h (tree_evaluator::ignored_fcn_outputs):
New function.
* ov-usr-fcn.h, ov-usr-fcn.cc
(octave_user_function::bind_automatic_vars): Get list of ignored
output arguments from evaluator.

* pt-eval.cc, pt-eval.h (tree_evaluator::visit_simple_assignment,
tree_evaluator::visit_multi_assignment): Push lvalue list on stack
here, not in tree_evaluator::evaluate or tree_evaluator::evaluate_n.
Use unwind_protect frame to pop from stack.  Don't pass lvalue list to
evaluate or evaluate_n functions.

* pt-arg-list.cc, pt-arg-list.h (tree_argument_list::lvalue_list):
Delete.
* pt-eval.cc, pt-eval.h (tree_evaluator::make_lvalue_list):
New function.
(tree_evaluator::visit_multi_assignment): Use it instead of
tree_argument_list::lvalue_list.

* ov-builtin.cc, ov-builtin.h (octave_builtin::curr_lvalue_list):
Delete data member and all uses.
* defun.cc (defun_isargout): Get current lvalue_list from evaluator.

diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -37,18 +37,20 @@ along with Octave; see the file COPYING.
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-fcn.h"
 #include "ov-mex-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "pager.h"
+#include "pt-eval.h"
+#include "interpreter-private.h"
+#include "interpreter.h"
 #include "symtab.h"
-#include "interpreter.h"
 #include "variables.h"
 #include "parse.h"
 
 // Print the usage part of the doc string of FCN (user-defined or DEFUN).
 void
 print_usage (void)
 {
   const octave_function *cur = octave::call_stack::current ();
@@ -153,17 +155,17 @@ get_current_shlib (void)
     }
 
   return retval;
 }
 
 bool defun_isargout (int nargout, int iout)
 {
   const std::list<octave_lvalue> *lvalue_list
-    = octave_builtin::curr_lvalue_list;
+    = octave::current_evaluator->lvalue_list ();
 
   if (iout >= std::max (nargout, 1))
     return false;
   else if (lvalue_list)
     {
       int k = 0;
       for (const auto& lval : *lvalue_list)
         {
@@ -178,17 +180,17 @@ bool defun_isargout (int nargout, int io
     }
   else
     return true;
 }
 
 void defun_isargout (int nargout, int nout, bool *isargout)
 {
   const std::list<octave_lvalue> *lvalue_list
-    = octave_builtin::curr_lvalue_list;
+    = octave::current_evaluator->lvalue_list ();
 
   if (lvalue_list)
     {
       int k = 0;
       for (const auto& lval : *lvalue_list)
         {
           if (lval.is_black_hole ())
             isargout[k++] = false;
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -233,48 +233,30 @@ octave_value
 octave_base_value::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             bool /* auto_add */)
 {
   // This way we may get a more meaningful error message.
   return subsref (type, idx);
 }
 
-octave_value_list
-octave_base_value::subsref (const std::string& type,
-                            const std::list<octave_value_list>& idx,
-                            int nargout,
-                            const std::list<octave_lvalue> *)
-{
-  // Fall back to call without passing lvalue list.
-  return subsref (type, idx, nargout);
-}
-
 octave_value
 octave_base_value::do_index_op (const octave_value_list&, bool)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
 }
 
 octave_value_list
 octave_base_value::do_multi_index_op (int, const octave_value_list&)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
 }
 
-octave_value_list
-octave_base_value::do_multi_index_op (int nargout, const octave_value_list& idx,
-                                      const std::list<octave_lvalue> *)
-{
-  // Fall back.
-  return do_multi_index_op (nargout, idx);
-}
-
 idx_vector
 octave_base_value::index_vector (bool /* require_integers */) const
 {
   std::string nm = "<" + type_name () + ">";
   octave::err_invalid_index (nm.c_str ());
 }
 
 octave_value
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -270,32 +270,22 @@ public:
            const std::list<octave_value_list>& idx,
            int nargout);
 
   virtual octave_value
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            bool auto_add);
 
-  virtual octave_value_list
-  subsref (const std::string& type,
-           const std::list<octave_value_list>& idx,
-           int nargout,
-           const std::list<octave_lvalue> *lvalue_list);
-
   virtual octave_value
   do_index_op (const octave_value_list& idx, bool resize_ok = false);
 
   virtual octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
-  virtual octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& idx,
-                     const std::list<octave_lvalue> *lvalue_list);
-
   virtual void assign (const std::string&, const octave_value&) { }
 
   virtual octave_value
   subsasgn (const std::string& type,
             const std::list<octave_value_list>& idx,
             const octave_value& rhs);
 
   virtual octave_value
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -39,35 +39,25 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "built-in function",
                                      "built-in function");
 
 octave_value_list
 octave_builtin::subsref (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          int nargout)
 {
-  return octave_builtin::subsref (type, idx, nargout, 0);
-}
-
-octave_value_list
-octave_builtin::subsref (const std::string& type,
-                         const std::list<octave_value_list>& idx,
-                         int nargout,
-                         const std::list<octave_lvalue>* lvalue_list)
-{
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-        retval = do_multi_index_op (tmp_nargout, idx.front (),
-                                    idx.size () == 1 ? lvalue_list : 0);
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
         std::string nm = type_name ();
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
@@ -92,40 +82,27 @@ octave_builtin::subsref (const std::stri
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args)
 {
-  return octave_builtin::do_multi_index_op (nargout, args, 0);
-}
-
-octave_value_list
-octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args,
-                                   const std::list<octave_lvalue> *lvalue_list)
-{
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
   octave::unwind_protect frame;
 
   octave::call_stack::push (this);
 
   frame.add_fcn (octave::call_stack::pop);
 
-  if (lvalue_list || curr_lvalue_list)
-    {
-      frame.protect_var (curr_lvalue_list);
-      curr_lvalue_list = lvalue_list;
-    }
-
   profile_data_accumulator::enter<octave_builtin> block (profiler, *this);
 
   retval = (*f) (args, nargout);
 
   // Do not allow null values to be returned from functions.
   // FIXME: perhaps true builtins should be allowed?
 
   retval.make_storable_values ();
@@ -171,10 +148,8 @@ octave_builtin::push_dispatch_class (con
   dispatch_classes.insert (dispatch_type);
 }
 
 bool
 octave_builtin::handles_dispatch_class (const std::string& dispatch_type) const
 {
   return dispatch_classes.find (dispatch_type) != dispatch_classes.end ();
 }
-
-const std::list<octave_lvalue> *octave_builtin::curr_lvalue_list = nullptr;
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -72,44 +72,33 @@ public:
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout,
-                             const std::list<octave_lvalue>* lvalue_list);
-
   octave_function * function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args,
-                     const std::list<octave_lvalue>* lvalue_list);
-
   jit_type * to_jit (void) const;
 
   void stash_jit (jit_type& type);
 
   fcn function (void) const;
 
   void push_dispatch_class (const std::string& dispatch_type);
 
   bool handles_dispatch_class (const std::string& dispatch_type) const;
 
-  static const std::list<octave_lvalue> *curr_lvalue_list;
-
 protected:
 
   // A pointer to the actual function.
   fcn f;
 
   // The name of the file where this function was defined.
   std::string file;
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -126,18 +126,17 @@ octave_base_matrix<Cell>::fast_elem_inse
 
 template class octave_base_matrix<Cell>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cell, "cell", "cell");
 
 octave_value_list
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
-                      int nargout,
-                      const std::list<octave_lvalue> *lvalue_list)
+                      int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval(0) = do_index_op (idx.front ());
       break;
@@ -169,19 +168,17 @@ octave_cell::subsref (const std::string&
       panic_impossible ();
     }
 
   // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
-    retval = (lvalue_list
-              ? retval(0).next_subsref (nargout, type, idx, lvalue_list)
-              : retval(0).next_subsref (nargout, type, idx));
+    retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
                       bool auto_add)
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -75,25 +75,17 @@ public:
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
-                             int nargout)
-  {
-    return subsref (type, idx, nargout, 0);
-  }
-
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout,
-                             const std::list<octave_lvalue> *lvalue_list);
+                             int nargout);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -91,35 +91,25 @@ octave_fcn_handle::octave_fcn_handle (co
     error ("handles to nested functions are not yet supported");
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             int nargout)
 {
-  return octave_fcn_handle::subsref (type, idx, nargout, 0);
-}
-
-octave_value_list
-octave_fcn_handle::subsref (const std::string& type,
-                            const std::list<octave_value_list>& idx,
-                            int nargout,
-                            const std::list<octave_lvalue>* lvalue_list)
-{
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-        retval = do_multi_index_op (tmp_nargout, idx.front (),
-                                    idx.size () == 1 ? lvalue_list : 0);
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
         std::string tnm = type_name ();
         error ("%s cannot be indexed with %c", tnm.c_str (), type[0]);
@@ -139,24 +129,16 @@ octave_fcn_handle::subsref (const std::s
 
   return retval;
 }
 
 octave_value_list
 octave_fcn_handle::do_multi_index_op (int nargout,
                                       const octave_value_list& args)
 {
-  return do_multi_index_op (nargout, args, 0);
-}
-
-octave_value_list
-octave_fcn_handle::do_multi_index_op (int nargout,
-                                      const octave_value_list& args,
-                                      const std::list<octave_lvalue>* lvalue_list)
-{
   octave_value_list retval;
 
   out_of_date_check (fcn, "", false);
 
   if (has_overloads)
     {
       // Possibly overloaded function.
       octave_value ov_fcn;
@@ -208,28 +190,28 @@ octave_fcn_handle::do_multi_index_op (in
           else
             {
               out_of_date_check (it->second, dispatch_type, false);
               ov_fcn = it->second;
             }
         }
 
       if (ov_fcn.is_defined ())
-        retval = ov_fcn.do_multi_index_op (nargout, args, lvalue_list);
+        retval = ov_fcn.do_multi_index_op (nargout, args);
       else if (fcn.is_defined ())
-        retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
+        retval = fcn.do_multi_index_op (nargout, args);
       else
         error ("%s: no method for class %s",
                nm.c_str (), dispatch_type.c_str ());
     }
   else
     {
       // Non-overloaded function (anonymous, subfunction, private function).
       if (fcn.is_defined ())
-        retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
+        retval = fcn.do_multi_index_op (nargout, args);
       else
         error ("%s: no longer valid function handle", nm.c_str ());
     }
 
   return retval;
 }
 
 dim_vector
@@ -2084,42 +2066,34 @@ octave_fcn_binder::maybe_binder (const o
 %! f = @(t) eval ('2*t');
 %! assert (f (21), 42);
 */
 
 octave_value_list
 octave_fcn_binder::do_multi_index_op (int nargout,
                                       const octave_value_list& args)
 {
-  return do_multi_index_op (nargout, args, 0);
-}
-
-octave_value_list
-octave_fcn_binder::do_multi_index_op (int nargout,
-                                      const octave_value_list& args,
-                                      const std::list<octave_lvalue>* lvalue_list)
-{
   octave_value_list retval;
 
   if (args.length () == expected_nargin)
     {
       for (int i = 0; i < arg_template.length (); i++)
         {
           int j = arg_mask[i];
           if (j >= 0)
             arg_template(i) = args(j); // May force a copy...
         }
 
       // Make a shallow copy of arg_template, to ensure consistency throughout
       // the following call even if we happen to get back here.
       octave_value_list tmp (arg_template);
-      retval = root_handle.do_multi_index_op (nargout, tmp, lvalue_list);
+      retval = root_handle.do_multi_index_op (nargout, tmp);
     }
   else
-    retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
+    retval = octave_fcn_handle::do_multi_index_op (nargout, args);
 
   return retval;
 }
 
 /*
 %!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -85,28 +85,19 @@ public:
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout,
-                             const std::list<octave_lvalue>* lvalue_list);
-
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args,
-                     const std::list<octave_lvalue>* lvalue_list);
-
   bool is_defined (void) const { return true; }
 
   bool is_function_handle (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_func_handle; }
 
   bool is_overloaded (void) const { return has_overloads; }
 
@@ -206,20 +197,16 @@ public:
 
   // Factory method.
   static octave_fcn_handle * maybe_binder (const octave_value& f,
                                            octave::tree_evaluator *tw);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args,
-                     const std::list<octave_lvalue>* lvalue_list);
-
 protected:
 
   octave_value root_handle;
   octave_value_list arg_template;
   std::vector<int> arg_mask;
   int expected_nargin;
 };
 #endif
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -405,35 +405,25 @@ octave_user_function::all_va_args (const
   return retval;
 }
 
 octave_value_list
 octave_user_function::subsref (const std::string& type,
                                const std::list<octave_value_list>& idx,
                                int nargout)
 {
-  return octave_user_function::subsref (type, idx, nargout, 0);
-}
-
-octave_value_list
-octave_user_function::subsref (const std::string& type,
-                               const std::list<octave_value_list>& idx,
-                               int nargout,
-                               const std::list<octave_lvalue>* lvalue_list)
-{
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-        retval = do_multi_index_op (tmp_nargout, idx.front (),
-                                    idx.size () == 1 ? lvalue_list : 0);
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
         std::string nm = type_name ();
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
@@ -451,25 +441,17 @@ octave_user_function::subsref (const std
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
-                                         const octave_value_list& args)
-{
-  return do_multi_index_op (nargout, args, 0);
-}
-
-octave_value_list
-octave_user_function::do_multi_index_op (int nargout,
-                                         const octave_value_list& _args,
-                                         const std::list<octave_lvalue>* lvalue_list)
+                                         const octave_value_list& _args)
 {
   octave_value_list retval;
 
   if (! cmd_list)
     return retval;
 
   // If this function is a classdef constructor, extract the first input
   // argument, which must be the partially constructed object instance.
@@ -565,18 +547,18 @@ octave_user_function::do_multi_index_op 
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
       frame.add_fcn (symbol_table::clear_variables);
     }
 
-  bind_automatic_vars (arg_names, args.length (), nargout,
-                       all_va_args (args), lvalue_list);
+  bind_automatic_vars (tw, arg_names, args.length (), nargout,
+                       all_va_args (args));
 
   frame.add_method (this, &octave_user_function::restore_warning_states);
 
   bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
 
   if (echo_commands)
     print_code_function_header ();
 
@@ -602,17 +584,17 @@ octave_user_function::do_multi_index_op 
         octave::tree_statement *stmt = cmd_list->front ();
 
         octave::tree_expression *expr = stmt->expression ();
 
         if (expr)
           {
             octave::call_stack::set_location (stmt->line (), stmt->column ());
 
-            retval = tw->evaluate_n (expr, nargout, lvalue_list);
+            retval = tw->evaluate_n (expr, nargout);
           }
       }
     else
       cmd_list->accept (*tw);
   }
 
   if (echo_commands)
     print_code_function_trailer ();
@@ -700,19 +682,18 @@ octave_user_function::print_code_functio
 {
   octave::tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::bind_automatic_vars
-  (const string_vector& arg_names, int nargin, int nargout,
-   const octave_value_list& va_args,
-   const std::list<octave_lvalue> *lvalue_list)
+  (octave::tree_evaluator *tw, const string_vector& arg_names,
+   int nargin, int nargout, const octave_value_list& va_args)
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
@@ -738,41 +719,22 @@ octave_user_function::bind_automatic_var
   symbol_table::assign (".saved_warning_states.");
 
   symbol_table::mark_automatic (".saved_warning_states.");
   symbol_table::mark_automatic (".saved_warning_states.");
 
   if (takes_varargs ())
     symbol_table::assign ("varargin", va_args.cell_value ());
 
-  // Force .ignored. variable to be undefined by default.
-  symbol_table::assign (".ignored.");
-
-  if (lvalue_list)
-    {
-      octave_idx_type nbh = 0;
-      for (const auto& lval : *lvalue_list)
-        nbh += lval.is_black_hole ();
+  Matrix ignored_fcn_outputs = tw ? tw->ignored_fcn_outputs () : Matrix ();
 
-      if (nbh > 0)
-        {
-          // Only assign the hidden variable if black holes actually present.
-          Matrix bh (1, nbh);
-          octave_idx_type k = 0;
-          octave_idx_type l = 0;
-          for (const auto& lval : *lvalue_list)
-            {
-              if (lval.is_black_hole ())
-                bh(l++) = k+1;
-              k += lval.numel ();
-            }
-
-          symbol_table::assign (".ignored.", bh);
-        }
-    }
+  if (ignored_fcn_outputs.is_empty ())
+    symbol_table::assign (".ignored.");
+  else
+    symbol_table::assign (".ignored.", ignored_fcn_outputs);
 
   symbol_table::mark_hidden (".ignored.");
   symbol_table::mark_automatic (".ignored.");
 }
 
 void
 octave_user_function::restore_warning_states (void)
 {
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -40,16 +40,17 @@ along with Octave; see the file COPYING.
 class string_vector;
 
 class octave_value;
 
 namespace octave
 {
   class tree_parameter_list;
   class tree_statement_list;
+  class tree_evaluator;
   class tree_expression;
   class tree_walker;
 }
 
 #if defined (HAVE_LLVM)
 class jit_function_info;
 #endif
 
@@ -365,28 +366,19 @@ public:
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout,
-                             const std::list<octave_lvalue>* lvalue_list);
-
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args,
-                     const std::list<octave_lvalue>* lvalue_list);
-
   octave::tree_parameter_list * parameter_list (void) { return param_list; }
 
   octave::tree_parameter_list * return_list (void) { return ret_list; }
 
   octave::tree_statement_list * body (void) { return cmd_list; }
 
   octave_comment_list * leading_comment (void) { return lead_comm; }
 
@@ -512,18 +504,19 @@ private:
 #endif
 
   void maybe_relocate_end_internal (void);
 
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
-  void bind_automatic_vars (const string_vector& arg_names, int nargin,
-                            int nargout, const octave_value_list& va_args,
-                            const std::list<octave_lvalue> *lvalue_list);
+  void bind_automatic_vars (octave::tree_evaluator *tw,
+                            const string_vector& arg_names,
+                            int nargin, int nargout,
+                            const octave_value_list& va_args);
 
   void restore_warning_states (void);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1446,27 +1446,16 @@ octave_value::subsref (const std::string
                        const std::list<octave_value_list>& idx, int nargout)
 {
   if (nargout == 1)
     return rep->subsref (type, idx);
   else
     return rep->subsref (type, idx, nargout);
 }
 
-octave_value_list
-octave_value::subsref (const std::string& type,
-                       const std::list<octave_value_list>& idx, int nargout,
-                       const std::list<octave_lvalue> *lvalue_list)
-{
-  if (lvalue_list)
-    return rep->subsref (type, idx, nargout, lvalue_list);
-  else
-    return subsref (type, idx, nargout);
-}
-
 octave_value
 octave_value::next_subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
   if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
@@ -1489,33 +1478,16 @@ octave_value::next_subsref (int nargout,
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout);
     }
   else
     return *this;
 }
 
-octave_value_list
-octave_value::next_subsref (int nargout, const std::string& type,
-                            const std::list<octave_value_list>& idx,
-                            const std::list<octave_lvalue> *lvalue_list,
-                            size_t skip)
-{
-  if (idx.size () > skip)
-    {
-      std::list<octave_value_list> new_idx (idx);
-      for (size_t i = 0; i < skip; i++)
-        new_idx.erase (new_idx.begin ());
-      return subsref (type.substr (skip), new_idx, nargout, lvalue_list);
-    }
-  else
-    return *this;
-}
-
 octave_value
 octave_value::next_subsref (bool auto_add, const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
   if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
@@ -1528,23 +1500,16 @@ octave_value::next_subsref (bool auto_ad
 }
 
 octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx)
 {
   return rep->do_multi_index_op (nargout, idx);
 }
 
-octave_value_list
-octave_value::do_multi_index_op (int nargout, const octave_value_list& idx,
-                                 const std::list<octave_lvalue> *lvalue_list)
-{
-  return rep->do_multi_index_op (nargout, idx, lvalue_list);
-}
-
 octave_value
 octave_value::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
 {
   return rep->subsasgn (type, idx, rhs);
 }
 
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -426,51 +426,36 @@ public:
                         const std::list<octave_value_list>& idx,
                         bool auto_add)
   { return rep->subsref (type, idx, auto_add); }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout,
-                             const std::list<octave_lvalue> *lvalue_list);
-
   octave_value next_subsref (const std::string& type, const
                              std::list<octave_value_list>& idx,
                              size_t skip = 1);
 
   octave_value_list next_subsref (int nargout,
                                   const std::string& type, const
                                   std::list<octave_value_list>& idx,
                                   size_t skip = 1);
 
-  octave_value_list next_subsref (int nargout,
-                                  const std::string& type, const
-                                  std::list<octave_value_list>& idx,
-                                  const std::list<octave_lvalue> *lvalue_list,
-                                  size_t skip = 1);
-
   octave_value next_subsref (bool auto_add, const std::string& type, const
                              std::list<octave_value_list>& idx,
                              size_t skip = 1);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
   { return rep->do_index_op (idx, resize_ok); }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& idx,
-                     const std::list<octave_lvalue> *lvalue_list);
-
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value undef_subsasgn (const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs);
 
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "str-vec.h"
 
 #include "defun.h"
 #include "error.h"
-#include "oct-lvalue.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "parse.h"
 #include "pt-arg-list.h"
 #include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-id.h"
@@ -257,27 +256,16 @@ namespace octave
             args.push_back (octave_value ());
             break;
           }
       }
 
     return args;
   }
 
-  std::list<octave_lvalue>
-  tree_argument_list::lvalue_list (tree_evaluator *tw)
-  {
-    std::list<octave_lvalue> retval;
-
-    for (tree_expression *elt : *this)
-      retval.push_back (elt->lvalue (tw));
-
-    return retval;
-  }
-
   string_vector
   tree_argument_list::get_arg_names (void) const
   {
     int len = length ();
 
     string_vector retval (len);
 
     int k = 0;
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -23,17 +23,16 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_arg_list_h)
 #define octave_pt_arg_list_h 1
 
 #include "octave-config.h"
 
 #include <list>
 
 class octave_value_list;
-class octave_lvalue;
 
 #include "str-vec.h"
 
 #include "base-list.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
@@ -88,18 +87,16 @@ namespace octave
 
     bool all_elements_are_constant (void) const;
 
     bool is_valid_lvalue_list (void) const;
 
     octave_value_list convert_to_const_vector (tree_evaluator *tw,
                                                const octave_value *object = nullptr);
 
-    std::list<octave_lvalue> lvalue_list (tree_evaluator *tw);
-
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
     tree_argument_list * dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -77,18 +77,18 @@ namespace octave
   bool tree_evaluator::in_loop_command = false;
 
   // Normal evaluator.
 
   void
   tree_evaluator::reset (void)
   {
     m_value_stack.clear ();
-    m_lvalue_list_stack.pop ();
-    m_nargout_stack.pop ();
+    m_lvalue_list_stack.clear ();
+    m_nargout_stack.clear ();
   }
 
   void
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& expr)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
@@ -403,16 +403,53 @@ namespace octave
 
   bool
   tree_evaluator::statement_printing_enabled (void)
   {
     return ! (Vsilent_functions && (statement_context == function
                                     || statement_context == script));
   }
 
+  Matrix
+  tree_evaluator::ignored_fcn_outputs (void) const
+  {
+    Matrix retval;
+
+    if (m_lvalue_list_stack.empty ())
+      return retval;
+
+    //    std::cerr << "lvalue_list_stack size: "
+    //              << m_lvalue_list_stack.size () << std::endl;
+
+    const std::list<octave_lvalue> *lvalue_list = m_lvalue_list_stack.top ();
+
+    octave_idx_type nbh = 0;
+
+    for (const auto& lval : *lvalue_list)
+      nbh += lval.is_black_hole ();
+
+    if (nbh > 0)
+      {
+        retval.resize (1, nbh);
+
+        octave_idx_type k = 0;
+        octave_idx_type l = 0;
+
+        for (const auto& lval : *lvalue_list)
+          {
+            if (lval.is_black_hole ())
+              retval(l++) = k+1;
+
+            k += lval.numel ();
+          }
+      }
+
+    return retval;
+  }
+
   octave_value
   tree_evaluator::evaluate (tree_decl_elt *elt)
   {
     // Do not allow functions to return null values.
 
     tree_identifier *id = elt->ident ();
 
     return id ? evaluate (id).storable_value () : octave_value ();
@@ -937,24 +974,17 @@ namespace octave
         if (val.is_function ())
           fcn = val.function_value (true);
 
         int nargout = m_nargout_stack.top ();
 
         if (fcn && ! (expr.is_postfix_indexed ()
                       && fcn->is_postfix_index_handled (expr.postfix_index ())))
           {
-            octave_value_list tmp_args;
-
-            const std::list<octave_lvalue> *lvalue_list
-              = m_lvalue_list_stack.top ();
-
-            retval = (lvalue_list
-                      ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
-                      : val.do_multi_index_op (nargout, tmp_args));
+            retval = val.do_multi_index_op (nargout, octave_value_list ());
           }
         else
           {
             if (expr.print_result () && nargout == 0
                 && octave::tree_evaluator::statement_printing_enabled ())
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (expr.name ()));
@@ -1225,42 +1255,36 @@ namespace octave
             panic_impossible ();
           }
 
         p_args++;
         p_arg_nm++;
         p_dyn_field++;
       }
 
-    const std::list<octave_lvalue> *lvalue_list = m_lvalue_list_stack.top ();
-
     try
       {
-        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
-                              lvalue_list);
+        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout);
       }
     catch (octave::index_exception& e)  // range problems, bad index type, etc.
       {
         final_index_error (e, expr);
       }
 
     octave_value val = (retval.length () ? retval(0) : octave_value ());
 
     if (val.is_function ())
       {
         octave_function *fcn = val.function_value (true);
 
         if (fcn)
           {
             octave_value_list empty_args;
 
-            retval = (lvalue_list
-                      ? val.do_multi_index_op (nargout, empty_args,
-                                               lvalue_list)
-                      : val.do_multi_index_op (nargout, empty_args));
+            retval = val.do_multi_index_op (nargout, empty_args);
           }
       }
 
     m_value_stack.push (retval);
   }
 
   void
   tree_evaluator::visit_matrix (tree_matrix& expr)
@@ -1515,27 +1539,34 @@ namespace octave
   tree_evaluator::visit_multi_assignment (tree_multi_assignment& expr)
   {
     octave_value_list val;
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       {
+        unwind_protect frame;
+
         tree_argument_list *lhs = expr.left_hand_side ();
 
-        std::list<octave_lvalue> lvalue_list = lhs->lvalue_list (this);
+        std::list<octave_lvalue> lvalue_list = make_lvalue_list (lhs);
+
+        m_lvalue_list_stack.push (&lvalue_list);
+
+        frame.add_method (m_lvalue_list_stack,
+                          &value_stack<const std::list<octave_lvalue>*>::pop);
 
         octave_idx_type n_out = 0;
 
         for (const auto& lval : lvalue_list)
           n_out += lval.numel ();
 
         // The following trick is used to keep rhs_val constant.
-        const octave_value_list rhs_val1 = evaluate_n (rhs, n_out, &lvalue_list);
+        const octave_value_list rhs_val1 = evaluate_n (rhs, n_out);
         const octave_value_list rhs_val = (rhs_val1.length () == 1
                                            && rhs_val1(0).is_cs_list ()
                                            ? rhs_val1(0).list_value ()
                                            : rhs_val1);
 
         octave_idx_type k = 0;
 
         octave_idx_type n = rhs_val.length ();
@@ -1864,18 +1895,28 @@ namespace octave
 
             rhs_val = lst(0);
           }
 
         tree_expression *lhs = expr.left_hand_side ();
 
         try
           {
+            octave::unwind_protect frame;
+
             octave_lvalue ult = lhs->lvalue (this);
 
+            std::list<octave_lvalue> lvalue_list;
+            lvalue_list.push_back (ult);
+
+            m_lvalue_list_stack.push (&lvalue_list);
+
+            frame.add_method (m_lvalue_list_stack,
+                              &value_stack<const std::list<octave_lvalue>*>::pop);
+
             if (ult.numel () != 1)
               err_nonbraced_cs_list_assignment ();
 
             octave_value::assign_op etype = expr.op_type ();
 
             ult.assign (etype, rhs_val);
 
             if (etype == octave_value::op_asn_eq)
@@ -2462,16 +2503,27 @@ namespace octave
 
     if (t1.is_defined ())
       return t1.is_true ();
     else
       error ("%s: undefined value used in conditional expression", warn_for);
 
     return expr_value;
   }
+
+  std::list<octave_lvalue>
+  tree_evaluator::make_lvalue_list (tree_argument_list *lhs)
+  {
+    std::list<octave_lvalue> retval;
+
+    for (tree_expression *elt : *lhs)
+      retval.push_back (elt->lvalue (this));
+
+    return retval;
+  }
 }
 
 DEFUN (max_recursion_depth, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} max_recursion_depth ()
 @deftypefnx {} {@var{old_val} =} max_recursion_depth (@var{new_val})
 @deftypefnx {} {} max_recursion_depth (@var{new_val}, "local")
 Query or set the internal limit on the number of times a function may
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -57,28 +57,43 @@ namespace octave
       value_stack (const value_stack&) = default;
 
       value_stack& operator = (const value_stack&) = default;
 
       ~value_stack (void) = default;
 
       void push (const T& val) { m_stack.push (val); }
 
-      T pop (void)
+      void pop (void)
+      {
+        m_stack.pop ();
+      }
+
+      T val_pop (void)
       {
         T retval = m_stack.top ();
         m_stack.pop ();
         return retval;
       }
 
       T top (void) const
       {
         return m_stack.top ();
       }
 
+      size_t size (void) const
+      {
+        return m_stack.size ();
+      }
+
+      bool empty (void) const
+      {
+        return m_stack.empty ();
+      }
+
       void clear (void)
       {
         while (! m_stack.empty ())
           m_stack.pop ();
       }
 
     private:
 
@@ -220,45 +235,45 @@ namespace octave
     };
 
     // The context for the current evaluation.
     static stmt_list_type statement_context;
 
     // TRUE means we are evaluating some kind of looping construct.
     static bool in_loop_command;
 
-    octave_value evaluate (tree_expression *expr, int nargout = 1,
-                           const std::list<octave_lvalue> *lvalue_list = nullptr)
+    Matrix ignored_fcn_outputs (void) const;
+
+    const std::list<octave_lvalue> * lvalue_list (void)
+    {
+      return m_lvalue_list_stack.empty () ? 0 : m_lvalue_list_stack.top ();
+    }
+
+    octave_value evaluate (tree_expression *expr, int nargout = 1)
     {
       m_nargout_stack.push (nargout);
-      m_lvalue_list_stack.push (lvalue_list);
 
       expr->accept (*this);
 
       m_nargout_stack.pop ();
-      m_lvalue_list_stack.pop ();
 
-      octave_value_list tmp = m_value_stack.pop ();
+      octave_value_list tmp = m_value_stack.val_pop ();
 
       return tmp.empty () ? octave_value () : tmp(0);
     }
 
-    octave_value_list
-    evaluate_n (tree_expression *expr, int nargout = 1,
-                const std::list<octave_lvalue> *lvalue_list = nullptr)
+    octave_value_list evaluate_n (tree_expression *expr, int nargout = 1)
     {
       m_nargout_stack.push (nargout);
-      m_lvalue_list_stack.push (lvalue_list);
 
       expr->accept (*this);
 
       m_nargout_stack.pop ();
-      m_lvalue_list_stack.pop ();
 
-      return m_value_stack.pop ();
+      return m_value_stack.val_pop ();
     }
 
     octave_value evaluate (tree_decl_elt *);
 
     void
     initialize_undefined_parameter_list_elements
       (tree_parameter_list *param_list, const std::string& warnfor,
        int nargout, const octave_value& val);
@@ -284,16 +299,18 @@ namespace octave
     void do_breakpoint (bool is_breakpoint,
                         bool is_end_of_fcn_or_script = false) const;
 
     virtual octave_value
     do_keyboard (const octave_value_list& args = octave_value_list ()) const;
 
     bool is_logically_true (tree_expression *expr, const char *warn_for);
 
+    std::list<octave_lvalue> make_lvalue_list (tree_argument_list *);
+
     value_stack<octave_value_list> m_value_stack;
 
     value_stack<const std::list<octave_lvalue>*> m_lvalue_list_stack;
 
     value_stack<int> m_nargout_stack;
 
     interpreter *m_interp_context;
   };
