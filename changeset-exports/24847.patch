# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1520458928 18000
#      Wed Mar 07 16:42:08 2018 -0500
# Node ID fa4e852dae1e0f9a5693d12444d10b4708090f42
# Parent  7620f1f5290dd6834d1929d493c3c6ae4e913fba
use m_ prefix consistently in jit compiler classes in the parser

* jit-ir.cc, jit-ir.h, jit-typeinfo.cc, jit-typeinfo.h, jit-util.cc,
jit-util.h, pt-jit.cc: Use m_ prefix consistently in jit compiler
classes in the parser.  Style fixes.

diff --git a/libinterp/parse-tree/jit-ir.cc b/libinterp/parse-tree/jit-ir.cc
--- a/libinterp/parse-tree/jit-ir.cc
+++ b/libinterp/parse-tree/jit-ir.cc
@@ -45,27 +45,27 @@ along with Octave; see the file COPYING.
 #include "error.h"
 
 namespace octave
 {
 
   // -------------------- jit_factory --------------------
   jit_factory::~jit_factory (void)
   {
-    for (value_list::iterator iter = all_values.begin ();
-         iter != all_values.end (); ++iter)
+    for (value_list::iterator iter = m_all_values.begin ();
+         iter != m_all_values.end (); ++iter)
       delete *iter;
   }
 
   void
   jit_factory::track_value (jit_value *value)
   {
     if (value->type ())
-      mconstants.push_back (value);
-    all_values.push_back (value);
+      m_constants.push_back (value);
+    m_all_values.push_back (value);
   }
 
   // -------------------- jit_block_list --------------------
   void
   jit_block_list::insert_after (iterator iter, jit_block *ablock)
   {
     ++iter;
     insert_before (iter, ablock);
@@ -75,32 +75,32 @@ namespace octave
   jit_block_list::insert_after (jit_block *loc, jit_block *ablock)
   {
     insert_after (loc->location (), ablock);
   }
 
   void
   jit_block_list::insert_before (iterator iter, jit_block *ablock)
   {
-    iter = mlist.insert (iter, ablock);
+    iter = m_list.insert (iter, ablock);
     ablock->stash_location (iter);
   }
 
   void
   jit_block_list::insert_before (jit_block *loc, jit_block *ablock)
   {
     insert_before (loc->location (), ablock);
   }
 
   void
   jit_block_list::label (void)
   {
-    if (mlist.size ())
+    if (m_list.size ())
       {
-        jit_block *block = mlist.back ();
+        jit_block *block = m_list.back ();
         block->label ();
       }
   }
 
   std::ostream&
   jit_block_list::print (std::ostream& os, const std::string& header) const
   {
     os << "-------------------- " << header << " --------------------\n";
@@ -119,18 +119,18 @@ namespace octave
     os << std::endl;
 
     return os;
   }
 
   void
   jit_block_list::push_back (jit_block *b)
   {
-    mlist.push_back (b);
-    iterator iter = mlist.end ();
+    m_list.push_back (b);
+    iterator iter = m_list.end ();
     b->stash_location (--iter);
   }
 
   std::ostream&
   operator<<(std::ostream& os, const jit_block_list& blocks)
   {
     for (jit_block_list::const_iterator iter = blocks.begin ();
          iter != blocks.end (); ++iter)
@@ -140,17 +140,17 @@ namespace octave
       }
     return os << std::endl;
   }
 
   // -------------------- jit_use --------------------
   jit_block *
   jit_use::user_parent (void) const
   {
-    return muser->parent ();
+    return m_user->parent ();
   }
 
   // -------------------- jit_value --------------------
   jit_value::~jit_value (void)
   { }
 
   jit_block *
   jit_value::first_use_block (void)
@@ -201,33 +201,33 @@ namespace octave
       return avalue->print (os);
     return os << "NULL";
   }
 
   // -------------------- jit_instruction --------------------
   void
   jit_instruction::remove (void)
   {
-    if (mparent)
-      mparent->remove (mlocation);
+    if (m_parent)
+      m_parent->remove (m_location);
     resize_arguments (0);
   }
 
   llvm::BasicBlock *
   jit_instruction::parent_llvm (void) const
   {
-    return mparent->to_llvm ();
+    return m_parent->to_llvm ();
   }
 
   std::ostream&
   jit_instruction::short_print (std::ostream& os) const
   {
     if (type ())
       jit_print (os, type ()) << ": ";
-    return os << '#' << mid;
+    return os << '#' << m_id;
   }
 
   void
   jit_instruction::do_construct_ssa (size_t start, size_t end)
   {
     for (size_t i = start; i < end; ++i)
       {
         jit_value *arg = argument (i);
@@ -243,40 +243,40 @@ namespace octave
   {
     assert (isa<jit_block> (value));
     jit_block *block = static_cast<jit_block *> (value);
 
     jit_value::replace_with (block);
 
     while (ILIST_T::first_use ())
       {
-        jit_phi_incomming *incomming = ILIST_T::first_use ();
-        incomming->stash_value (block);
+        jit_phi_incoming *incoming = ILIST_T::first_use ();
+        incoming->stash_value (block);
       }
   }
 
   void
   jit_block::replace_in_phi (jit_block *ablock, jit_block *with)
   {
-    jit_phi_incomming *node = ILIST_T::first_use ();
+    jit_phi_incoming *node = ILIST_T::first_use ();
     while (node)
       {
-        jit_phi_incomming *prev = node;
+        jit_phi_incoming *prev = node;
         node = node->next ();
 
         if (prev->user_parent () == ablock)
           prev->stash_value (with);
       }
   }
 
   jit_block *
-  jit_block::maybe_merge ()
+  jit_block::maybe_merge (void)
   {
     if (successor_count () == 1 && successor (0) != this
-        && (successor (0)->use_count () == 1 || instructions.size () == 1))
+        && (successor (0)->use_count () == 1 || m_instructions.size () == 1))
       {
         jit_block *to_merge = successor (0);
         merge (*to_merge);
         return to_merge;
       }
 
     return 0;
   }
@@ -289,17 +289,17 @@ namespace octave
     if (old_term)
       old_term->remove ();
 
     bool was_empty = end () == begin ();
     iterator merge_begin = end ();
     if (! was_empty)
       --merge_begin;
 
-    instructions.splice (end (), block.instructions);
+    m_instructions.splice (end (), block.m_instructions);
     if (was_empty)
       merge_begin = begin ();
     else
       ++merge_begin;
 
     // now merge_begin points to the start of the new instructions, we must
     // update their parent information
     for (iterator iter = merge_begin; iter != end (); ++iter)
@@ -309,18 +309,18 @@ namespace octave
       }
 
     block.replace_with (this);
   }
 
   jit_instruction *
   jit_block::prepend (jit_instruction *instr)
   {
-    instructions.push_front (instr);
-    instr->stash_parent (this, instructions.begin ());
+    m_instructions.push_front (instr);
+    instr->stash_parent (this, m_instructions.begin ());
     return instr;
   }
 
   jit_instruction *
   jit_block::prepend_after_phi (jit_instruction *instr)
   {
     // FIXME: Make this O(1)
     for (iterator iter = begin (); iter != end (); ++iter)
@@ -334,44 +334,44 @@ namespace octave
       }
 
     return append (instr);
   }
 
   void
   jit_block::internal_append (jit_instruction *instr)
   {
-    instructions.push_back (instr);
-    instr->stash_parent (this, --instructions.end ());
+    m_instructions.push_back (instr);
+    instr->stash_parent (this, --m_instructions.end ());
   }
 
   jit_instruction *
   jit_block::insert_before (iterator loc, jit_instruction *instr)
   {
-    iterator iloc = instructions.insert (loc, instr);
+    iterator iloc = m_instructions.insert (loc, instr);
     instr->stash_parent (this, iloc);
     return instr;
   }
 
   jit_instruction *
   jit_block::insert_after (iterator loc, jit_instruction *instr)
   {
     ++loc;
-    iterator iloc = instructions.insert (loc, instr);
+    iterator iloc = m_instructions.insert (loc, instr);
     instr->stash_parent (this, iloc);
     return instr;
   }
 
   jit_terminator *
   jit_block::terminator (void) const
   {
-    if (instructions.empty ())
+    if (m_instructions.empty ())
       return nullptr;
 
-    jit_instruction *last = instructions.back ();
+    jit_instruction *last = m_instructions.back ();
     return dynamic_cast<jit_terminator *> (last);
   }
 
   bool
   jit_block::branch_alive (jit_block *asucc) const
   {
     return terminator ()->alive (asucc);
   }
@@ -388,68 +388,68 @@ namespace octave
   {
     jit_terminator *term = terminator ();
     return term ? term->successor_count () : 0;
   }
 
   llvm::BasicBlock *
   jit_block::to_llvm (void) const
   {
-    return llvm::cast<llvm::BasicBlock> (llvm_value);
+    return llvm::cast<llvm::BasicBlock> (m_llvm_value);
   }
 
   std::ostream&
   jit_block::print_dom (std::ostream& os) const
   {
     short_print (os);
     os << ":\n";
-    os << "  mid: " << mid << std::endl;
+    os << "  m_id: " << m_id << std::endl;
     os << "  predecessors: ";
     for (jit_use *use = first_use (); use; use = use->next ())
       os << *use->user_parent () << ' ';
     os << std::endl;
 
     os << "  successors: ";
     for (size_t i = 0; i < successor_count (); ++i)
       os << *successor (i) << ' ';
     os << std::endl;
 
-    os << "  idom: ";
-    if (idom)
-      os << *idom;
+    os << "  m_idom: ";
+    if (m_idom)
+      os << *m_idom;
     else
       os << "NULL";
     os << std::endl;
     os << "  df: ";
     for (df_iterator iter = df_begin (); iter != df_end (); ++iter)
       os << **iter << ' ';
     os << std::endl;
 
-    os << "  dom_succ: ";
-    for (size_t i = 0; i < dom_succ.size (); ++i)
-      os << *dom_succ[i] << ' ';
+    os << "  m_dom_succ: ";
+    for (size_t i = 0; i < m_dom_succ.size (); ++i)
+      os << *m_dom_succ[i] << ' ';
 
     return os << std::endl;
   }
 
   void
   jit_block::compute_df (size_t avisit_count)
   {
     if (visited (avisit_count))
       return;
 
     if (use_count () >= 2)
       {
         for (jit_use *use = first_use (); use; use = use->next ())
           {
             jit_block *runner = use->user_parent ();
-            while (runner != idom)
+            while (runner != m_idom)
               {
-                runner->mdf.insert (this);
-                runner = runner->idom;
+                runner->m_df.insert (this);
+                runner = runner->m_idom;
               }
           }
       }
 
     for (size_t i = 0; i < successor_count (); ++i)
       successor (i)->compute_df (avisit_count);
   }
 
@@ -468,24 +468,24 @@ namespace octave
 
     jit_use *use = first_use ();
     jit_block *new_idom = use->user_parent ();
     use = use->next ();
 
     for (; use; use = use->next ())
       {
         jit_block *pred = use->user_parent ();
-        jit_block *pidom = pred->idom;
+        jit_block *pidom = pred->m_idom;
         if (pidom)
           new_idom = idom_intersect (pidom, new_idom);
       }
 
-    if (idom != new_idom)
+    if (m_idom != new_idom)
       {
-        idom = new_idom;
+        m_idom = new_idom;
         return true;
       }
 
     return changed;
   }
 
   void
   jit_block::label (size_t avisit_count, size_t& number)
@@ -494,17 +494,17 @@ namespace octave
       return;
 
     for (jit_use *use = first_use (); use; use = use->next ())
       {
         jit_block *pred = use->user_parent ();
         pred->label (avisit_count, number);
       }
 
-    mid = number++;
+    m_id = number++;
   }
 
   void
   jit_block::pop_all (void)
   {
     for (iterator iter = begin (); iter != end (); ++iter)
       {
         jit_instruction *instr = *iter;
@@ -537,17 +537,17 @@ namespace octave
   jit_block *
   jit_block::maybe_split (jit_factory& factory, jit_block_list& blocks,
                           jit_block *asuccessor)
   {
     if (successor_count () > 1)
       {
         jit_terminator *term = terminator ();
         size_t idx = term->successor_index (asuccessor);
-        jit_block *split = factory.create<jit_block> ("phi_split", mvisit_count);
+        jit_block *split = factory.create<jit_block> ("phi_split", m_visit_count);
 
         // place after this to ensure define before use in the blocks list
         blocks.insert_after (this, split);
 
         term->stash_argument (idx, split);
         jit_branch *br = split->append (factory.create<jit_branch> (asuccessor));
         replace_in_phi (asuccessor, split);
 
@@ -564,74 +564,74 @@ namespace octave
   }
 
   void
   jit_block::create_dom_tree (size_t avisit_count)
   {
     if (visited (avisit_count))
       return;
 
-    if (idom != this)
-      idom->dom_succ.push_back (this);
+    if (m_idom != this)
+      m_idom->m_dom_succ.push_back (this);
 
     for (size_t i = 0; i < successor_count (); ++i)
       successor (i)->create_dom_tree (avisit_count);
   }
 
   jit_block *
   jit_block::idom_intersect (jit_block *i, jit_block *j)
   {
     while (i && j && i != j)
       {
         while (i && i->id () > j->id ())
-          i = i->idom;
+          i = i->m_idom;
 
         while (i && j && j->id () > i->id ())
-          j = j->idom;
+          j = j->m_idom;
       }
 
     return i ? i : j;
   }
 
-  // -------------------- jit_phi_incomming --------------------
+  // -------------------- jit_phi_incoming --------------------
 
   jit_block *
-  jit_phi_incomming::user_parent (void) const
-  { return muser->parent (); }
+  jit_phi_incoming::user_parent (void) const
+  { return m_user->parent (); }
 
   // -------------------- jit_phi --------------------
   bool
   jit_phi::prune (void)
   {
     jit_block *p = parent ();
     size_t new_idx = 0;
     jit_value *unique = argument (1);
 
     for (size_t i = 0; i < argument_count (); ++i)
       {
-        jit_block *inc = incomming (i);
+        jit_block *inc = incoming (i);
         if (inc->branch_alive (p))
           {
             if (unique != argument (i))
               unique = 0;
 
             if (new_idx != i)
               {
                 stash_argument (new_idx, argument (i));
-                mincomming[new_idx].stash_value (inc);
+                m_incoming[new_idx].stash_value (inc);
               }
 
             ++new_idx;
           }
       }
 
     if (new_idx != argument_count ())
       {
         resize_arguments (new_idx);
-        mincomming.resize (new_idx);
+        m_incoming.resize (new_idx);
       }
 
     assert (argument_count () > 0);
     if (unique)
       {
         replace_with (unique);
         return true;
       }
@@ -644,17 +644,17 @@ namespace octave
   {
     jit_block *p = parent ();
     if (! p->alive ())
       return false;
 
     jit_type *infered = nullptr;
     for (size_t i = 0; i < argument_count (); ++i)
       {
-        jit_block *inc = incomming (i);
+        jit_block *inc = incoming (i);
         if (inc->branch_alive (p))
           infered = jit_type_join (infered, argument_type (i));
       }
 
     if (infered != type ())
       {
         stash_type (infered);
         return true;
@@ -683,21 +683,21 @@ namespace octave
 
   bool
   jit_terminator::infer (void)
   {
     if (! parent ()->alive ())
       return false;
 
     bool changed = false;
-    for (size_t i = 0; i < malive.size (); ++i)
-      if (! malive[i] && check_alive (i))
+    for (size_t i = 0; i < m_alive.size (); ++i)
+      if (! m_alive[i] && check_alive (i))
         {
           changed = true;
-          malive[i] = true;
+          m_alive[i] = true;
           successor (i)->mark_alive ();
         }
 
     return changed;
   }
 
   llvm::TerminatorInst *
   jit_terminator::to_llvm (void) const
@@ -724,22 +724,22 @@ namespace octave
   }
 
   bool
   jit_call::infer (void)
   {
     // FIXME: explain algorithm
     for (size_t i = 0; i < argument_count (); ++i)
       {
-        already_infered[i] = argument_type (i);
-        if (! already_infered[i])
+        m_already_infered[i] = argument_type (i);
+        if (! m_already_infered[i])
           return false;
       }
 
-    jit_type *infered = moperation.result (already_infered);
+    jit_type *infered = m_operation.result (m_already_infered);
     if (! infered && use_count ())
       {
         std::stringstream ss;
         ss << "Missing overload in type inference for ";
         print (ss, 0);
         throw jit_fail_exception (ss.str ());
       }
 
@@ -765,59 +765,59 @@ namespace octave
       default:
         panic_impossible ();
       }
   }
 
   std::ostream&
   jit_error_check::print (std::ostream& os, size_t indent) const
   {
-    print_indent (os, indent) << "error_check " << variable_to_string (mvariable)
+    print_indent (os, indent) << "error_check " << variable_to_string (m_variable)
                               << ", ";
 
     if (has_check_for ())
       os << "<for> " << *check_for () << ", ";
     print_successor (os << "<normal> ", 1) << ", ";
     return print_successor (os << "<error> ", 0);
   }
 
   // -------------------- jit_magic_end --------------------
   jit_magic_end::context::context (jit_factory& factory, jit_value *avalue,
                                    size_t aindex, size_t acount)
-    : value (avalue), index (factory.create<jit_const_index> (aindex)),
-      count (factory.create<jit_const_index> (acount))
+    : m_value (avalue), m_index (factory.create<jit_const_index> (aindex)),
+      m_count (factory.create<jit_const_index> (acount))
   { }
 
   jit_magic_end::jit_magic_end (const std::vector<context>& full_context)
-    : contexts (full_context)
+    : m_contexts (full_context)
   {
-    resize_arguments (contexts.size ());
+    resize_arguments (m_contexts.size ());
 
     size_t i;
     std::vector<context>::const_iterator iter;
-    for (iter = contexts.begin (), i = 0; iter != contexts.end (); ++iter, ++i)
-      stash_argument (i, iter->value);
+    for (iter = m_contexts.begin (), i = 0; iter != m_contexts.end (); ++iter, ++i)
+      stash_argument (i, iter->m_value);
   }
 
   jit_magic_end::context
   jit_magic_end::resolve_context (void) const
   {
     size_t idx;
-    for (idx = 0; idx < contexts.size (); ++idx)
+    for (idx = 0; idx < m_contexts.size (); ++idx)
       {
-        jit_type *ctx_type = contexts[idx].value->type ();
+        jit_type *ctx_type = m_contexts[idx].m_value->type ();
         if (! ctx_type || ctx_type->skip_paren ())
           break;
       }
 
-    if (idx >= contexts.size ())
+    if (idx >= m_contexts.size ())
       idx = 0;
 
-    context ret = contexts[idx];
-    ret.value = argument (idx);
+    context ret = m_contexts[idx];
+    ret.m_value = argument (idx);
     return ret;
   }
 
   bool
   jit_magic_end::infer (void)
   {
     jit_type *new_type = overload ().result ();
     if (new_type != type ())
@@ -828,22 +828,22 @@ namespace octave
 
     return false;
   }
 
   std::ostream&
   jit_magic_end::print (std::ostream& os, size_t indent) const
   {
     context ctx = resolve_context ();
-    short_print (print_indent (os, indent)) << " (" << *ctx.value << ", ";
-    return os << *ctx.index << ", " << *ctx.count << ')';
+    short_print (print_indent (os, indent)) << " (" << *ctx.m_value << ", ";
+    return os << *ctx.m_index << ", " << *ctx.m_count << ')';
   }
 
   const jit_function&
-  jit_magic_end::overload () const
+  jit_magic_end::overload (void) const
   {
     const context& ctx = resolve_context ();
-    return jit_typeinfo::end (ctx.value, ctx.index, ctx.count);
+    return jit_typeinfo::end (ctx.m_value, ctx.m_index, ctx.m_count);
   }
 
 }
 
 #endif
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -33,42 +33,42 @@ along with Octave; see the file COPYING.
 #include <stack>
 #include <set>
 
 #include "jit-typeinfo.h"
 
 namespace octave
 {
 
-  // The low level octave jit ir
-  // this ir is close to llvm, but contains information for doing type inference.
-  // We convert the octave parse tree to this IR directly.
+  // The low level octave JIT IR.  This ir is close to llvm, but
+  // contains information for doing type inference.  We convert the
+  // octave parse tree to this IR directly.
 
 #define JIT_VISIT_IR_NOTEMPLATE                 \
-  JIT_METH(block);                              \
-  JIT_METH(branch);                             \
-  JIT_METH(cond_branch);                        \
-  JIT_METH(call);                               \
-  JIT_METH(extract_argument);                   \
-  JIT_METH(store_argument);                     \
-  JIT_METH(return);                             \
-  JIT_METH(phi);                                \
-  JIT_METH(variable);                           \
-  JIT_METH(error_check);                        \
-  JIT_METH(assign)                              \
-  JIT_METH(argument)                            \
-  JIT_METH(magic_end)
+  JIT_METH (block);                             \
+  JIT_METH (branch);                            \
+  JIT_METH (cond_branch);                       \
+  JIT_METH (call);                              \
+  JIT_METH (extract_argument);                  \
+  JIT_METH (store_argument);                    \
+  JIT_METH (return);                            \
+  JIT_METH (phi);                               \
+  JIT_METH (variable);                          \
+  JIT_METH (error_check);                       \
+  JIT_METH (assign)                             \
+  JIT_METH (argument)                           \
+  JIT_METH (magic_end)
 
 #define JIT_VISIT_IR_CONST                      \
-  JIT_METH(const_bool);                         \
-  JIT_METH(const_scalar);                       \
-  JIT_METH(const_complex);                      \
-  JIT_METH(const_index);                        \
-  JIT_METH(const_string);                       \
-  JIT_METH(const_range)
+  JIT_METH (const_bool);                        \
+  JIT_METH (const_scalar);                      \
+  JIT_METH (const_complex);                     \
+  JIT_METH (const_index);                       \
+  JIT_METH (const_string);                      \
+  JIT_METH (const_range)
 
 #define JIT_VISIT_IR_CLASSES                    \
   JIT_VISIT_IR_NOTEMPLATE                       \
   JIT_VISIT_IR_CONST
 
   // forward declare all ir classes
 #define JIT_METH(cname)                         \
   class jit_ ## cname;
@@ -105,259 +105,273 @@ namespace octave
   jit_factory
   {
     typedef std::list<jit_value *> value_list;
 
   public:
 
     ~jit_factory (void);
 
-    const value_list& constants (void) const { return mconstants; }
+    const value_list& constants (void) const { return m_constants; }
 
     template <typename T, typename ...Args>
     T * create (const Args&... args)
     {
       T *ret = new T (args...);
       track_value (ret);
       return ret;
     }
 
   private:
 
     void track_value (jit_value *v);
 
-    value_list all_values;
+    value_list m_all_values;
 
-    value_list mconstants;
+    value_list m_constants;
   };
 
   // A list of basic blocks (jit_block) which form some body of code.
   //
   // We do not directly inherit from std::list because we need to update the
   // blocks stashed location in push_back and insert.
   class
   jit_block_list
   {
   public:
+
     typedef std::list<jit_block *>::iterator iterator;
     typedef std::list<jit_block *>::const_iterator const_iterator;
 
-    jit_block * back (void) const { return mlist.back (); }
+    jit_block * back (void) const { return m_list.back (); }
 
-    iterator begin (void) { return mlist.begin (); }
+    iterator begin (void) { return m_list.begin (); }
 
-    const_iterator begin (void) const { return mlist.begin (); }
+    const_iterator begin (void) const { return m_list.begin (); }
 
-    iterator end (void)  { return mlist.end (); }
+    iterator end (void)  { return m_list.end (); }
 
-    const_iterator end (void) const  { return mlist.end (); }
+    const_iterator end (void) const  { return m_list.end (); }
 
-    iterator erase (iterator iter) { return mlist.erase (iter); }
+    iterator erase (iterator iter) { return m_list.erase (iter); }
 
-    jit_block * front (void) const { return mlist.front (); }
+    jit_block * front (void) const { return m_list.front (); }
 
     void insert_after (iterator iter, jit_block *ablock);
 
     void insert_after (jit_block *loc, jit_block *ablock);
 
     void insert_before (iterator iter, jit_block *ablock);
 
     void insert_before (jit_block *loc, jit_block *ablock);
 
     void label (void);
 
     std::ostream& print (std::ostream& os, const std::string& header) const;
 
     std::ostream& print_dom (std::ostream& os) const;
 
     void push_back (jit_block *b);
+
   private:
-    std::list<jit_block *> mlist;
+
+    std::list<jit_block *> m_list;
   };
 
   std::ostream& operator<<(std::ostream& os, const jit_block_list& blocks);
 
   class
   jit_value : public jit_internal_list<jit_value, jit_use>
   {
   public:
-    jit_value (void) : llvm_value (0), ty (0), mlast_use (0),
-                       min_worklist (false) { }
+
+    jit_value (void)
+      : m_llvm_value (0), m_type (0), m_last_use (0), m_in_worklist (false)
+    { }
 
     virtual ~jit_value (void);
 
     bool in_worklist (void) const
     {
-      return min_worklist;
+      return m_in_worklist;
     }
 
     void stash_in_worklist (bool ain_worklist)
     {
-      min_worklist = ain_worklist;
+      m_in_worklist = ain_worklist;
     }
 
     // The block of the first use which is not a jit_error_check
     // So this is not necessarily first_use ()->parent ().
     jit_block * first_use_block (void);
 
     // replace all uses with
-    virtual void replace_with (jit_value *value);
+    virtual void replace_with (jit_value *m_value);
 
-    jit_type * type (void) const { return ty; }
+    jit_type * type (void) const { return m_type; }
 
     llvm::Type * type_llvm (void) const
     {
-      return ty ? ty->to_llvm () : nullptr;
+      return m_type ? m_type->to_llvm () : nullptr;
     }
 
     const std::string& type_name (void) const
     {
-      return ty->name ();
+      return m_type->name ();
     }
 
-    void stash_type (jit_type *new_ty) { ty = new_ty; }
+    void stash_type (jit_type *new_type) { m_type = new_type; }
 
     std::string print_string (void)
     {
       std::stringstream ss;
       print (ss);
       return ss.str ();
     }
 
-    jit_instruction * last_use (void) const { return mlast_use; }
+    jit_instruction * last_use (void) const { return m_last_use; }
 
     void stash_last_use (jit_instruction *alast_use)
     {
-      mlast_use = alast_use;
+      m_last_use = alast_use;
     }
 
     virtual bool needs_release (void) const { return false; }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const = 0;
 
     virtual std::ostream& short_print (std::ostream& os) const
     { return print (os); }
 
     virtual void accept (jit_ir_walker& walker) = 0;
 
     bool has_llvm (void) const
     {
-      return llvm_value;
+      return m_llvm_value;
     }
 
     llvm::Value * to_llvm (void) const
     {
-      assert (llvm_value);
-      return llvm_value;
+      assert (m_llvm_value);
+      return m_llvm_value;
     }
 
     void stash_llvm (llvm::Value *compiled)
     {
-      llvm_value = compiled;
+      m_llvm_value = compiled;
     }
 
   protected:
+
     std::ostream& print_indent (std::ostream& os, size_t indent = 0) const
     {
       for (size_t i = 0; i < indent * 8; ++i)
         os << ' ';
       return os;
     }
 
-    llvm::Value *llvm_value;
+    llvm::Value *m_llvm_value;
+
   private:
-    jit_type *ty;
-    jit_instruction *mlast_use;
-    bool min_worklist;
+
+    jit_type *m_type;
+    jit_instruction *m_last_use;
+    bool m_in_worklist;
   };
 
   std::ostream& operator<< (std::ostream& os, const jit_value& value);
   std::ostream& jit_print (std::ostream& os, jit_value *avalue);
 
   class
   jit_use : public jit_internal_node<jit_value, jit_use>
   {
   public:
+
     // some compilers don't allow us to use jit_internal_node without template
     // paremeters
     typedef jit_internal_node<jit_value, jit_use> PARENT_T;
 
-    jit_use (void) : muser (0), mindex (0) { }
+    jit_use (void) : m_user (0), m_index (0) { }
 
     // we should really have a move operator, but not until c++11 :(
-    jit_use (const jit_use& use) : muser (0), mindex (0)
+    jit_use (const jit_use& use) : m_user (0), m_index (0)
     {
       *this = use;
     }
 
     jit_use& operator= (const jit_use& use)
     {
       stash_value (use.value (), use.user (), use.index ());
       return *this;
     }
 
-    size_t index (void) const { return mindex; }
+    size_t index (void) const { return m_index; }
 
-    jit_instruction * user (void) const { return muser; }
+    jit_instruction * user (void) const { return m_user; }
 
     jit_block * user_parent (void) const;
 
     std::list<jit_block *> user_parent_location (void) const;
 
     void stash_value (jit_value *avalue, jit_instruction *auser = nullptr,
                       size_t aindex = -1)
     {
       PARENT_T::stash_value (avalue);
-      mindex = aindex;
-      muser = auser;
+      m_index = aindex;
+      m_user = auser;
     }
+
   private:
-    jit_instruction *muser;
-    size_t mindex;
+
+    jit_instruction *m_user;
+    size_t m_index;
   };
 
   class
   jit_instruction : public jit_value
   {
   public:
+
     // FIXME: this code could be so much pretier with varadic templates...
-    jit_instruction (void) : mid (next_id ()), mparent (0)
+    jit_instruction (void)
+      : m_id (next_id ()), m_parent (0)
     { }
 
-    jit_instruction (size_t nargs) : mid (next_id ()), mparent (0)
+    jit_instruction (size_t nargs)
+      : m_id (next_id ()), m_parent (0)
     {
-      already_infered.reserve (nargs);
-      marguments.reserve (nargs);
+      m_already_infered.reserve (nargs);
+      m_arguments.reserve (nargs);
     }
 
     template <typename ...Args>
     jit_instruction (jit_value * arg1, Args... other_args)
-      : already_infered (1 + sizeof... (other_args)),
-        marguments (1 + sizeof... (other_args)),
-        mid (next_id ()), mparent (nullptr)
+      : m_already_infered (1 + sizeof... (other_args)),
+        m_arguments (1 + sizeof... (other_args)),
+        m_id (next_id ()), m_parent (nullptr)
     {
       stash_argument (0, arg1, other_args...);
     }
 
     jit_instruction (const std::vector<jit_value *>& aarguments)
-      : already_infered (aarguments.size ()), marguments (aarguments.size ()),
-        mid (next_id ()), mparent (0)
+      : m_already_infered (aarguments.size ()), m_arguments (aarguments.size ()),
+        m_id (next_id ()), m_parent (0)
     {
       for (size_t i = 0; i < aarguments.size (); ++i)
         stash_argument (i, aarguments[i]);
     }
 
     static void reset_ids (void)
     {
       next_id (true);
     }
 
     jit_value * argument (size_t i) const
     {
-      return marguments[i].value ();
+      return m_arguments[i].value ();
     }
 
     llvm::Value * argument_llvm (size_t i) const
     {
       assert (argument (i));
       return argument (i)->to_llvm ();
     }
 
@@ -377,119 +391,123 @@ namespace octave
       if (argument (i))
         return argument (i)->short_print (os);
       else
         return os << "NULL";
     }
 
     void stash_argument (size_t i, jit_value * arg)
     {
-      marguments[i].stash_value (arg, this, i);
+      m_arguments[i].stash_value (arg, this, i);
     }
 
     template <typename ...Args>
     void stash_argument (size_t i, jit_value * arg1, Args... aargs)
     {
-      marguments[i].stash_value (arg1, this, i);
+      m_arguments[i].stash_value (arg1, this, i);
       stash_argument (++i, aargs...);
     }
 
     void push_argument (jit_value *arg)
     {
-      marguments.push_back (jit_use ());
-      stash_argument (marguments.size () - 1, arg);
-      already_infered.push_back (0);
+      m_arguments.push_back (jit_use ());
+      stash_argument (m_arguments.size () - 1, arg);
+      m_already_infered.push_back (0);
     }
 
     size_t argument_count (void) const
     {
-      return marguments.size ();
+      return m_arguments.size ();
     }
 
     void resize_arguments (size_t acount, jit_value *adefault = nullptr)
     {
-      size_t old = marguments.size ();
-      marguments.resize (acount);
-      already_infered.resize (acount);
+      size_t old = m_arguments.size ();
+      m_arguments.resize (acount);
+      m_already_infered.resize (acount);
 
       if (adefault)
         for (size_t i = old; i < acount; ++i)
           stash_argument (i, adefault);
     }
 
-    const std::vector<jit_use>& arguments (void) const { return marguments; }
+    const std::vector<jit_use>& arguments (void) const { return m_arguments; }
 
     // argument types which have been infered already
     const std::vector<jit_type *>& argument_types (void) const
-    { return already_infered; }
+    { return m_already_infered; }
 
     virtual void push_variable (void) { }
 
     virtual void pop_variable (void) { }
 
     virtual void construct_ssa (void)
     {
       do_construct_ssa (0, argument_count ());
     }
 
     virtual bool infer (void) { return false; }
 
     void remove (void);
 
     virtual std::ostream& short_print (std::ostream& os) const;
 
-    jit_block * parent (void) const { return mparent; }
+    jit_block * parent (void) const { return m_parent; }
 
     std::list<jit_instruction *>::iterator location (void) const
     {
-      return mlocation;
+      return m_location;
     }
 
     llvm::BasicBlock * parent_llvm (void) const;
 
     void stash_parent (jit_block *aparent,
                        std::list<jit_instruction *>::iterator alocation)
     {
-      mparent = aparent;
-      mlocation = alocation;
+      m_parent = aparent;
+      m_location = alocation;
     }
 
-    size_t id (void) const { return mid; }
+    size_t id (void) const { return m_id; }
+
   protected:
 
     // Do SSA replacement on arguments in [start, end)
     void do_construct_ssa (size_t start, size_t end);
 
-    std::vector<jit_type *> already_infered;
+    std::vector<jit_type *> m_already_infered;
+
   private:
+
     static size_t next_id (bool reset = false)
     {
       static size_t ret = 0;
       if (reset)
         return ret = 0;
 
       return ret++;
     }
 
-    std::vector<jit_use> marguments;
+    std::vector<jit_use> m_arguments;
 
-    size_t mid;
-    jit_block *mparent;
-    std::list<jit_instruction *>::iterator mlocation;
+    size_t m_id;
+    jit_block *m_parent;
+    std::list<jit_instruction *>::iterator m_location;
   };
 
   // defnie accept methods for subclasses
 #define JIT_VALUE_ACCEPT                        \
   virtual void accept (jit_ir_walker& walker);
 
   // for use as a dummy argument during conversion to LLVM
   class
   jit_argument : public jit_value
   {
   public:
+
     jit_argument (jit_type *atype, llvm::Value *avalue)
     {
       stash_type (atype);
       stash_llvm (avalue);
     }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
@@ -500,85 +518,90 @@ namespace octave
     JIT_VALUE_ACCEPT;
   };
 
   template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T, bool QUOTE>
   class
   jit_const : public jit_value
   {
   public:
+
     typedef PASS_T pass_t;
 
-    jit_const (PASS_T avalue) : mvalue (avalue)
+    jit_const (PASS_T avalue) : m_value (avalue)
     {
       stash_type (EXTRACT_T ());
     }
 
-    PASS_T value (void) const { return mvalue; }
+    PASS_T value (void) const { return m_value; }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
       print_indent (os, indent);
       jit_print (os, type ()) << ": ";
       if (QUOTE)
         os << '"';
-      os << mvalue;
+      os << m_value;
       if (QUOTE)
         os << '"';
       return os;
     }
 
     JIT_VALUE_ACCEPT;
+
   private:
-    T mvalue;
+
+    T m_value;
   };
 
-  class jit_phi_incomming;
+  class jit_phi_incoming;
 
   class
   jit_block : public jit_value, public jit_internal_list<jit_block,
-                                                         jit_phi_incomming>
+                                                         jit_phi_incoming>
   {
-    typedef jit_internal_list<jit_block, jit_phi_incomming> ILIST_T;
+    typedef jit_internal_list<jit_block, jit_phi_incoming> ILIST_T;
+
   public:
+
     typedef std::list<jit_instruction *> instruction_list;
     typedef instruction_list::iterator iterator;
     typedef instruction_list::const_iterator const_iterator;
 
     typedef std::set<jit_block *> df_set;
     typedef df_set::const_iterator df_iterator;
 
     static const size_t NO_ID = static_cast<size_t> (-1);
 
     jit_block (const std::string& aname, size_t avisit_count = 0)
-      : mvisit_count (avisit_count), mid (NO_ID), idom (0), mname (aname),
-        malive (false)
+      : m_visit_count (avisit_count), m_id (NO_ID), m_idom (0), m_name (aname),
+        m_alive (false)
     { }
 
     virtual void replace_with (jit_value *value);
 
     void replace_in_phi (jit_block *ablock, jit_block *with);
 
     // we have a new internal list, but we want to stay compatible with jit_value
     jit_use * first_use (void) const { return jit_value::first_use (); }
 
     size_t use_count (void) const { return jit_value::use_count (); }
 
     // if a block is alive, then it might be visited during execution
-    bool alive (void) const { return malive; }
+    bool alive (void) const { return m_alive; }
 
-    void mark_alive (void) { malive = true; }
+    void mark_alive (void) { m_alive = true; }
 
     // If we can merge with a successor, do so and return the now empty block
     jit_block * maybe_merge ();
 
     // merge another block into this block, leaving the merge block empty
     void merge (jit_block& merge);
 
-    const std::string& name (void) const { return mname; }
+    const std::string& name (void) const { return m_name; }
 
     jit_instruction * prepend (jit_instruction *instr);
 
     jit_instruction * prepend_after_phi (jit_instruction *instr);
 
     template <typename T>
     T * append (T *instr)
     {
@@ -598,94 +621,94 @@ namespace octave
     jit_instruction * insert_after (jit_instruction *loc, jit_instruction *instr)
     {
       return insert_after (loc->location (), instr);
     }
 
     iterator remove (iterator iter)
     {
       jit_instruction *instr = *iter;
-      iter = instructions.erase (iter);
-      instr->stash_parent (0, instructions.end ());
+      iter = m_instructions.erase (iter);
+      instr->stash_parent (0, m_instructions.end ());
       return iter;
     }
 
     jit_terminator * terminator (void) const;
 
     // is the jump from pred alive?
     bool branch_alive (jit_block *asucc) const;
 
     jit_block * successor (size_t i) const;
 
     size_t successor_count (void) const;
 
-    iterator begin (void) { return instructions.begin (); }
+    iterator begin (void) { return m_instructions.begin (); }
 
-    const_iterator begin (void) const { return instructions.begin (); }
+    const_iterator begin (void) const { return m_instructions.begin (); }
 
-    iterator end (void) { return instructions.end (); }
+    iterator end (void) { return m_instructions.end (); }
 
-    const_iterator end (void) const { return instructions.end (); }
+    const_iterator end (void) const { return m_instructions.end (); }
 
     iterator phi_begin (void);
 
     iterator phi_end (void);
 
     iterator nonphi_begin (void);
 
     // must label before id is valid
-    size_t id (void) const { return mid; }
+    size_t id (void) const { return m_id; }
 
     // dominance frontier
-    const df_set& df (void) const { return mdf; }
+    const df_set& df (void) const { return m_df; }
 
-    df_iterator df_begin (void) const { return mdf.begin (); }
+    df_iterator df_begin (void) const { return m_df.begin (); }
 
-    df_iterator df_end (void) const { return mdf.end (); }
+    df_iterator df_end (void) const { return m_df.end (); }
 
     // label with a RPO walk
     void label (void)
     {
       size_t number = 0;
-      label (mvisit_count, number);
+      label (m_visit_count, number);
     }
 
     void label (size_t avisit_count, size_t& number);
 
     // See for idom computation algorithm
     // Cooper, Keith D.; Harvey, Timothy J; and Kennedy, Ken (2001).
     // "A Simple, Fast Dominance Algorithm"
     void compute_idom (jit_block& entry_block)
     {
       bool changed;
-      entry_block.idom = &entry_block;
+      entry_block.m_idom = &entry_block;
       do
-        changed = update_idom (mvisit_count);
+        changed = update_idom (m_visit_count);
       while (changed);
     }
 
     // compute dominance frontier
     void compute_df (void)
     {
-      compute_df (mvisit_count);
+      compute_df (m_visit_count);
     }
 
     void create_dom_tree (void)
     {
-      create_dom_tree (mvisit_count);
+      create_dom_tree (m_visit_count);
     }
 
     jit_block * dom_successor (size_t idx) const
     {
-      return dom_succ[idx];
+      return m_dom_succ[idx];
     }
 
     size_t dom_successor_count (void) const
     {
-      return dom_succ.size ();
+      return m_dom_succ.size ();
     }
 
     // call pop_variable on all instructions
     void pop_all (void);
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
     jit_block * maybe_split (jit_factory& factory, jit_block_list& blocks,
@@ -697,227 +720,246 @@ namespace octave
       return maybe_split (factory, blocks, &asuccessor);
     }
 
     // print dominator infomration
     std::ostream& print_dom (std::ostream& os) const;
 
     virtual std::ostream& short_print (std::ostream& os) const
     {
-      os << mname;
-      if (mid != NO_ID)
-        os << mid;
+      os << m_name;
+      if (m_id != NO_ID)
+        os << m_id;
       else
         os << '!';
       return os;
     }
 
     llvm::BasicBlock * to_llvm (void) const;
 
     std::list<jit_block *>::iterator location (void) const
-    { return mlocation; }
+    { return m_location; }
 
     void stash_location (std::list<jit_block *>::iterator alocation)
-    { mlocation = alocation; }
+    { m_location = alocation; }
 
     // used to prevent visiting the same node twice in the graph
-    size_t visit_count (void) const { return mvisit_count; }
+    size_t visit_count (void) const { return m_visit_count; }
 
     // check if this node has been visited yet at the given visit count.
     // If we have not been visited yet, mark us as visited.
     bool visited (size_t avisit_count)
     {
-      if (mvisit_count <= avisit_count)
+      if (m_visit_count <= avisit_count)
         {
-          mvisit_count = avisit_count + 1;
+          m_visit_count = avisit_count + 1;
           return false;
         }
 
       return true;
     }
 
-    jit_instruction * front (void) { return instructions.front (); }
+    jit_instruction * front (void) { return m_instructions.front (); }
 
-    jit_instruction * back (void) { return instructions.back (); }
+    jit_instruction * back (void) { return m_instructions.back (); }
 
     JIT_VALUE_ACCEPT;
+
   private:
+
     void internal_append (jit_instruction *instr);
 
     void compute_df (size_t avisit_count);
 
     bool update_idom (size_t avisit_count);
 
     void create_dom_tree (size_t avisit_count);
 
     static jit_block * idom_intersect (jit_block *i, jit_block *j);
 
-    size_t mvisit_count;
-    size_t mid;
-    jit_block *idom;
-    df_set mdf;
-    std::vector<jit_block *> dom_succ;
-    std::string mname;
-    instruction_list instructions;
-    bool malive;
-    std::list<jit_block *>::iterator mlocation;
+    size_t m_visit_count;
+    size_t m_id;
+    jit_block *m_idom;
+    df_set m_df;
+    std::vector<jit_block *> m_dom_succ;
+    std::string m_name;
+    instruction_list m_instructions;
+    bool m_alive;
+    std::list<jit_block *>::iterator m_location;
   };
 
-  // keeps track of phi functions that use a block on incomming edges
+  // keeps track of phi functions that use a block on incoming edges
   class
-  jit_phi_incomming : public jit_internal_node<jit_block, jit_phi_incomming>
+  jit_phi_incoming : public jit_internal_node<jit_block, jit_phi_incoming>
   {
   public:
-    jit_phi_incomming (void) : muser (0) { }
+
+    jit_phi_incoming (void) : m_user (0) { }
 
-    jit_phi_incomming (jit_phi *auser) : muser (auser) { }
+    jit_phi_incoming (jit_phi *auser) : m_user (auser) { }
 
-    jit_phi_incomming (const jit_phi_incomming& use)
+    jit_phi_incoming (const jit_phi_incoming& use)
     {
       *this = use;
     }
 
-    jit_phi_incomming& operator= (const jit_phi_incomming& use)
+    jit_phi_incoming& operator= (const jit_phi_incoming& use)
     {
       stash_value (use.value ());
-      muser = use.muser;
+      m_user = use.m_user;
       return *this;
     }
 
-    jit_phi * user (void) const { return muser; }
+    jit_phi * user (void) const { return m_user; }
 
     jit_block * user_parent (void) const;
+
   private:
-    jit_phi *muser;
+
+    jit_phi *m_user;
   };
 
   // A non-ssa variable
   class
   jit_variable : public jit_value
   {
   public:
-    jit_variable (const std::string& aname) : mname (aname), mlast_use (0) { }
 
-    const std::string& name (void) const { return mname; }
+    jit_variable (const std::string& aname) : m_name (aname), m_last_use (0) { }
+
+    const std::string& name (void) const { return m_name; }
 
     // manipulate the value_stack, for use during SSA construction.  The top of
     // the value stack represents the current value for this variable
     bool has_top (void) const
     {
       return ! value_stack.empty ();
     }
 
     jit_value * top (void) const
     {
       return value_stack.top ();
     }
 
     void push (jit_instruction *v)
     {
       value_stack.push (v);
-      mlast_use = v;
+      m_last_use = v;
     }
 
     void pop (void)
     {
       value_stack.pop ();
     }
 
     jit_instruction * last_use (void) const
     {
-      return mlast_use;
+      return m_last_use;
     }
 
     void stash_last_use (jit_instruction *instr)
     {
-      mlast_use = instr;
+      m_last_use = instr;
     }
 
     // blocks in which we are used
     void use_blocks (jit_block::df_set& result)
     {
       jit_use *use = first_use ();
       while (use)
         {
           result.insert (use->user_parent ());
           use = use->next ();
         }
     }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
-      return print_indent (os, indent) << mname;
+      return print_indent (os, indent) << m_name;
     }
 
     JIT_VALUE_ACCEPT;
+
   private:
-    std::string mname;
+
+    std::string m_name;
     std::stack<jit_value *> value_stack;
-    jit_instruction *mlast_use;
+    jit_instruction *m_last_use;
   };
 
   class
   jit_assign_base : public jit_instruction
   {
   public:
-    jit_assign_base (jit_variable *adest) : jit_instruction (), mdest (adest) { }
 
-    jit_assign_base (jit_variable *adest, size_t npred) : jit_instruction (npred),
-                                                          mdest (adest) { }
+    jit_assign_base (jit_variable *adest)
+      : jit_instruction (), m_dest (adest)
+    { }
+
+    jit_assign_base (jit_variable *adest, size_t npred)
+      : jit_instruction (npred), m_dest (adest)
+    { }
 
     jit_assign_base (jit_variable *adest, jit_value *arg0, jit_value *arg1)
-      : jit_instruction (arg0, arg1), mdest (adest) { }
+      : jit_instruction (arg0, arg1), m_dest (adest)
+    { }
 
-    jit_variable * dest (void) const { return mdest; }
+    jit_variable * dest (void) const { return m_dest; }
 
     virtual void push_variable (void)
     {
-      mdest->push (this);
+      m_dest->push (this);
     }
 
     virtual void pop_variable (void)
     {
-      mdest->pop ();
+      m_dest->pop ();
     }
 
     virtual std::ostream& short_print (std::ostream& os) const
     {
       if (type ())
         jit_print (os, type ()) << ": ";
 
       dest ()->short_print (os);
       return os << '#' << id ();
     }
+
   private:
-    jit_variable *mdest;
+
+    jit_variable *m_dest;
   };
 
   class
   jit_assign : public jit_assign_base
   {
   public:
+
     jit_assign (jit_variable *adest, jit_value *asrc)
-      : jit_assign_base (adest, adest, asrc), martificial (false) { }
+      : jit_assign_base (adest, adest, asrc), m_artificial (false)
+    { }
 
     jit_value * overwrite (void) const
     {
       return argument (0);
     }
 
     jit_value * src (void) const
     {
       return argument (1);
     }
 
-    // variables don't get modified in an SSA, but COW requires we modify
-    // variables.  An artificial assign is for when a variable gets modified.  We
-    // need an assign in the SSA, but the reference counts shouldn't be updated.
-    bool artificial (void) const { return martificial; }
+    // Variables don't get modified in an SSA, but COW requires we
+    // modify variables.  An artificial assign is for when a variable
+    // gets modified.  We need an assign in the SSA, but the reference
+    // counts shouldn't be updated.
 
-    void mark_artificial (void) { martificial = true; }
+    bool artificial (void) const { return m_artificial; }
+
+    void mark_artificial (void) { m_artificial = true; }
 
     virtual bool infer (void)
     {
       jit_type *stype = src ()->type ();
       if (stype != type())
         {
           stash_type (stype);
           return true;
@@ -932,48 +974,51 @@ namespace octave
 
       if (artificial ())
         os << " [artificial]";
 
       return os;
     }
 
     JIT_VALUE_ACCEPT;
+
   private:
-    bool martificial;
+
+    bool m_artificial;
   };
 
   class
   jit_phi : public jit_assign_base
   {
   public:
+
     jit_phi (jit_variable *adest, size_t npred)
       : jit_assign_base (adest, npred)
     {
-      mincomming.reserve (npred);
+      m_incoming.reserve (npred);
     }
 
-    // removes arguments form dead incomming jumps
+    // removes arguments form dead incoming jumps
     bool prune (void);
 
-    void add_incomming (jit_block *from, jit_value *value)
+    void add_incoming (jit_block *from, jit_value *value)
     {
       push_argument (value);
-      mincomming.push_back (jit_phi_incomming (this));
-      mincomming[mincomming.size () - 1].stash_value (from);
+      m_incoming.push_back (jit_phi_incoming (this));
+      m_incoming[m_incoming.size () - 1].stash_value (from);
     }
 
-    jit_block * incomming (size_t i) const
+    jit_block * incoming (size_t i) const
     {
-      return mincomming[i].value ();
+      return m_incoming[i].value ();
     }
 
-    llvm::BasicBlock * incomming_llvm (size_t i) const
+    llvm::BasicBlock * incoming_llvm (size_t i) const
     {
-      return incomming (i)->to_llvm ();
+      return incoming (i)->to_llvm ();
     }
 
     virtual void construct_ssa (void) { }
 
     virtual bool infer (void);
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
@@ -985,42 +1030,44 @@ namespace octave
       os << ss_str;
 
       for (size_t i = 0; i < argument_count (); ++i)
         {
           if (i > 0)
             os << indent_str;
           os << "| ";
 
-          os << *incomming (i) << " -> ";
+          os << *incoming (i) << " -> ";
           os << *argument (i);
 
           if (i + 1 < argument_count ())
             os << std::endl;
         }
 
       return os;
     }
 
     llvm::PHINode * to_llvm (void) const;
 
     JIT_VALUE_ACCEPT;
+
   private:
-    std::vector<jit_phi_incomming> mincomming;
+
+    std::vector<jit_phi_incoming> m_incoming;
   };
 
   class
   jit_terminator : public jit_instruction
   {
   public:
 
     template <typename ...Args>
     jit_terminator (size_t asuccessor_count, Args... args)
       : jit_instruction (args...),
-        malive (asuccessor_count, false) { }
+        m_alive (asuccessor_count, false) { }
 
     jit_block * successor (size_t idx = 0) const
     {
       return static_cast<jit_block *> (argument (idx));
     }
 
     llvm::BasicBlock * successor_llvm (size_t idx = 0) const
     {
@@ -1040,35 +1087,40 @@ namespace octave
     }
 
     // Check if the jump to successor is live
     bool alive (const jit_block *asuccessor) const
     {
       return alive (successor_index (asuccessor));
     }
 
-    bool alive (size_t idx) const { return malive[idx]; }
+    bool alive (size_t idx) const { return m_alive[idx]; }
 
-    bool alive (int idx) const { return malive[idx]; }
+    bool alive (int idx) const { return m_alive[idx]; }
 
-    size_t successor_count (void) const { return malive.size (); }
+    size_t successor_count (void) const { return m_alive.size (); }
 
     virtual bool infer (void);
 
     llvm::TerminatorInst * to_llvm (void) const;
+
   protected:
+
     virtual bool check_alive (size_t) const { return true; }
+
   private:
-    std::vector<bool> malive;
+
+    std::vector<bool> m_alive;
   };
 
   class
   jit_branch : public jit_terminator
   {
   public:
+
     jit_branch (jit_block *succ) : jit_terminator (1, succ) { }
 
     virtual size_t successor_count (void) const { return 1; }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
       print_indent (os, indent) << "branch: ";
       return print_successor (os);
@@ -1076,16 +1128,17 @@ namespace octave
 
     JIT_VALUE_ACCEPT;
   };
 
   class
   jit_cond_branch : public jit_terminator
   {
   public:
+
     jit_cond_branch (jit_value *c, jit_block *ctrue, jit_block *cfalse)
       : jit_terminator (2, ctrue, cfalse, c) { }
 
     jit_value * cond (void) const { return argument (2); }
 
     std::ostream& print_cond (std::ostream& os) const
     {
       return cond ()->short_print (os);
@@ -1108,154 +1161,163 @@ namespace octave
 
     JIT_VALUE_ACCEPT;
   };
 
   class
   jit_call : public jit_instruction
   {
   public:
+
     jit_call (const jit_operation& (*aoperation) (void))
-      : moperation (aoperation ())
+      : m_operation (aoperation ())
     {
       const jit_function& ol = overload ();
       if (ol.valid ())
         stash_type (ol.result ());
     }
 
-    jit_call (const jit_operation& aoperation) : moperation (aoperation)
+    jit_call (const jit_operation& aoperation) : m_operation (aoperation)
     {
       const jit_function& ol = overload ();
       if (ol.valid ())
         stash_type (ol.result ());
     }
 
     template <typename ...Args>
     jit_call (const jit_operation& aoperation,
               jit_value * arg1, Args... other_args)
-      : jit_instruction (arg1, other_args...), moperation (aoperation)
+      : jit_instruction (arg1, other_args...), m_operation (aoperation)
   { }
 
     template <typename ...Args>
     jit_call (const jit_operation& (*aoperation) (void),
               jit_value * arg1, Args... other_args)
-      : jit_instruction (arg1, other_args...), moperation (aoperation ())
+      : jit_instruction (arg1, other_args...), m_operation (aoperation ())
     { }
 
     jit_call (const jit_operation& aoperation,
               const std::vector<jit_value *>& args)
-      : jit_instruction (args), moperation (aoperation)
+      : jit_instruction (args), m_operation (aoperation)
     { }
 
-    const jit_operation& operation (void) const { return moperation; }
+    const jit_operation& operation (void) const { return m_operation; }
 
     bool can_error (void) const
     {
       return overload ().can_error ();
     }
 
     const jit_function& overload (void) const
     {
-      return moperation.overload (argument_types ());
+      return m_operation.overload (argument_types ());
     }
 
     virtual bool needs_release (void) const;
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
       print_indent (os, indent);
 
       if (use_count ())
         short_print (os) << " = ";
-      os << "call " << moperation.name () << " (";
+      os << "call " << m_operation.name () << " (";
 
       for (size_t i = 0; i < argument_count (); ++i)
         {
           print_argument (os, i);
           if (i + 1 < argument_count ())
             os << ", ";
         }
       return os << ')';
     }
 
     virtual bool infer (void);
 
     JIT_VALUE_ACCEPT;
+
   private:
-    const jit_operation& moperation;
+
+    const jit_operation& m_operation;
   };
 
   // FIXME: This is just ugly...
   // checks error_state, if error_state is false then goto the normal branch,
   // otherwise goto the error branch
   class
   jit_error_check : public jit_terminator
   {
   public:
+
     // Which variable is the error check for?
     enum variable
       {
         var_error_state,
         var_interrupt
       };
 
     static std::string variable_to_string (variable v);
 
     jit_error_check (variable var, jit_call *acheck_for, jit_block *normal,
                      jit_block *error)
-      : jit_terminator (2, error, normal, acheck_for), mvariable (var) { }
+      : jit_terminator (2, error, normal, acheck_for), m_variable (var) { }
 
     jit_error_check (variable var, jit_block *normal, jit_block *error)
-      : jit_terminator (2, error, normal), mvariable (var) { }
+      : jit_terminator (2, error, normal), m_variable (var) { }
 
-    variable check_variable (void) const { return mvariable; }
+    variable check_variable (void) const { return m_variable; }
 
     bool has_check_for (void) const
     {
       return argument_count () == 3;
     }
 
     jit_call * check_for (void) const
     {
       assert (has_check_for ());
       return static_cast<jit_call *> (argument (2));
     }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
     JIT_VALUE_ACCEPT;
+
   protected:
+
     virtual bool check_alive (size_t idx) const
     {
       if (! has_check_for ())
         return true;
       return idx == 1 ? true : check_for ()->can_error ();
     }
+
   private:
-    variable mvariable;
+
+    variable m_variable;
   };
 
   // for now only handles the 1D case
   class
   jit_magic_end : public jit_instruction
   {
   public:
+
     class
     context
     {
     public:
-      context (void) : value (0), index (0), count (0)
-      { }
+
+      context (void) : m_value (0), m_index (0), m_count (0) { }
 
       context (jit_factory& factory, jit_value *avalue, size_t aindex,
                size_t acount);
 
-      jit_value *value;
-      jit_const_index *index;
-      jit_const_index *count;
+      jit_value *m_value;
+      jit_const_index *m_index;
+      jit_const_index *m_count;
     };
 
     jit_magic_end (const std::vector<context>& full_context);
 
     virtual bool infer (void);
 
     const jit_function& overload () const;
 
@@ -1264,24 +1326,27 @@ namespace octave
     context resolve_context (void) const;
 
     virtual std::ostream& short_print (std::ostream& os) const
     {
       return os << "magic_end" << '#' << id ();
     }
 
     JIT_VALUE_ACCEPT;
+
   private:
-    std::vector<context> contexts;
+
+    std::vector<context> m_contexts;
   };
 
   class
   jit_extract_argument : public jit_assign_base
   {
   public:
+
     jit_extract_argument (jit_type *atype, jit_variable *adest)
       : jit_assign_base (adest)
     {
       stash_type (atype);
     }
 
     const std::string& name (void) const
     {
@@ -1302,23 +1367,24 @@ namespace octave
 
     JIT_VALUE_ACCEPT;
   };
 
   class
   jit_store_argument : public jit_instruction
   {
   public:
+
     jit_store_argument (jit_variable *var)
-      : jit_instruction (var), dest (var)
+      : jit_instruction (var), m_dest (var)
     { }
 
     const std::string& name (void) const
     {
-      return dest->name ();
+      return m_dest->name ();
     }
 
     const jit_function& overload (void) const
     {
       return jit_typeinfo::cast (jit_typeinfo::get_any (), result_type ());
     }
 
     jit_value * result (void) const
@@ -1335,36 +1401,39 @@ namespace octave
     {
       return result ()->to_llvm ();
     }
 
     virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
     {
       jit_value *res = result ();
       print_indent (os, indent) << "store ";
-      dest->short_print (os);
+      m_dest->short_print (os);
 
       if (! isa<jit_variable> (res))
         {
           os << " = ";
           res->short_print (os);
         }
 
       return os;
     }
 
     JIT_VALUE_ACCEPT;
+
   private:
-    jit_variable *dest;
+
+    jit_variable *m_dest;
   };
 
   class
   jit_return : public jit_instruction
   {
   public:
+
     jit_return (void) { }
 
     jit_return (jit_value *retval) : jit_instruction (retval) { }
 
     jit_value * result (void) const
     {
       return argument_count () ? argument (0) : nullptr;
     }
@@ -1387,17 +1456,18 @@ namespace octave
 
     JIT_VALUE_ACCEPT;
   };
 
   class
   jit_ir_walker
   {
   public:
-    virtual ~jit_ir_walker () { }
+
+    virtual ~jit_ir_walker (void) { }
 
 #define JIT_METH(clname)                        \
     virtual void visit (jit_ ## clname&) = 0;
 
     JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
   };
@@ -1405,13 +1475,13 @@ namespace octave
   template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T, bool QUOTE>
   void
   jit_const<T, EXTRACT_T, PASS_T, QUOTE>::accept (jit_ir_walker& walker)
   {
     walker.visit (*this);
   }
 
 #undef JIT_VALUE_ACCEPT
-
 }
 
 #endif
+
 #endif
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -123,39 +123,39 @@ namespace octave
   octave_jit_release_any (octave_base_value *obv)
   {
     obv->release ();
   }
 
   extern "C" void
   octave_jit_release_matrix (jit_matrix *m)
   {
-    delete m->array;
+    delete m->m_array;
   }
 
   extern "C" octave_base_value *
   octave_jit_grab_any (octave_base_value *obv)
   {
     obv->grab ();
     return obv;
   }
 
   extern "C" jit_matrix
   octave_jit_grab_matrix (jit_matrix *m)
   {
-    return *m->array;
+    return *m->m_array;
   }
 
   extern "C" octave_base_value *
   octave_jit_cast_any_matrix (jit_matrix *m)
   {
-    octave_value ret (*m->array);
+    octave_value ret (*m->m_array);
     octave_base_value *rep = ret.internal_rep ();
     rep->grab ();
-    delete m->array;
+    delete m->m_array;
 
     return rep;
   }
 
   extern "C" jit_matrix
   octave_jit_cast_matrix_any (octave_base_value *obv)
   {
     NDArray m = obv->array_value ();
@@ -217,33 +217,34 @@ namespace octave
   octave_jit_err_nan_to_logical_conversion (void)
   {
     octave::err_nan_to_logical_conversion ();
   }
 
   extern "C" void
   octave_jit_ginvalid_index (void)
   {
-    // FIXME: 0-argument form of octave::err_invalid_index removed in cset dd6345fd8a97
-    //        Report -1 as the bad index for all occurrences.
+    // FIXME: 0-argument form of octave::err_invalid_index removed in
+    //        cset dd6345fd8a97.  Report -1 as the bad index for all
+    //        occurrences.
     octave::err_invalid_index (static_cast<octave_idx_type> (-1));
   }
 
   extern "C" void
   octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                            octave_idx_type ext)
   {
     octave::err_index_out_of_range (nd, dim, iext, ext);
   }
 
   extern "C" jit_matrix
   octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                   double value)
   {
-    NDArray *array = mat->array;
+    NDArray *array = mat->m_array;
     if (array->numel () < index)
       array->resize1 (index);
 
     double *data = array->fortran_vec ();
     data[index - 1] = value;
 
     mat->update ();
     return *mat;
@@ -261,63 +262,63 @@ namespace octave
   extern "C" double
   octave_jit_paren_scalar (jit_matrix *mat, double *indicies,
                            octave_idx_type idx_count)
   {
     // FIXME: Replace this with a more optimal version
     Array<idx_vector> idx;
     make_indices (indicies, idx_count, idx);
 
-    Array<double> ret = mat->array->index (idx);
+    Array<double> ret = mat->m_array->index (idx);
 
     return ret.xelem (0);
   }
 
   extern "C" jit_matrix
   octave_jit_paren_scalar_subsasgn (jit_matrix *mat, double *indices,
                                     octave_idx_type idx_count, double value)
   {
     // FIXME: Replace this with a more optimal version
     jit_matrix ret;
 
     Array<idx_vector> idx;
     make_indices (indices, idx_count, idx);
 
     Matrix temp (1, 1);
     temp.xelem(0) = value;
-    mat->array->assign (idx, temp);
-    ret.update (mat->array);
+    mat->m_array->assign (idx, temp);
+    ret.update (mat->m_array);
 
     return ret;
   }
 
   extern "C" jit_matrix
   octave_jit_paren_subsasgn_matrix_range (jit_matrix *mat, jit_range *index,
                                           double value)
   {
-    NDArray *array = mat->array;
+    NDArray *array = mat->m_array;
     bool done = false;
 
     // optimize for the simple case (no resizing and no errors)
     if (*array->jit_ref_count () == 1
         && index->all_elements_are_ints ())
       {
         // this code is similar to idx_vector::fill, but we avoid allocating an
         // idx_vector and its associated rep
-        octave_idx_type start = static_cast<octave_idx_type> (index->base) - 1;
-        octave_idx_type step = static_cast<octave_idx_type> (index->inc);
-        octave_idx_type nelem = index->nelem;
+        octave_idx_type start = static_cast<octave_idx_type> (index->m_base) - 1;
+        octave_idx_type step = static_cast<octave_idx_type> (index->m_inc);
+        octave_idx_type nelem = index->m_nelem;
         octave_idx_type final = start + nelem * step;
         if (step < 0)
           {
             step = -step;
             std::swap (final, start);
           }
 
-        if (start >= 0 && final < mat->slice_len)
+        if (start >= 0 && final < mat->m_slice_len)
           {
             done = true;
 
             double *data = array->jit_slice_data ();
             if (step == 1)
               std::fill (data + start, data + start + nelem, value);
             else
               {
@@ -339,33 +340,33 @@ namespace octave
     ret.update (array);
     return ret;
   }
 
   extern "C" double
   octave_jit_end_matrix (jit_matrix *mat, octave_idx_type idx,
                          octave_idx_type count)
   {
-    octave_idx_type ndim = mat->dimensions[-1];
+    octave_idx_type ndim = mat->m_dimensions[-1];
     if (ndim == count)
-      return mat->dimensions[idx];
+      return mat->m_dimensions[idx];
     else if (ndim > count)
       {
         if (idx == count - 1)
           {
-            double ret = mat->dimensions[idx];
+            double ret = mat->m_dimensions[idx];
             for (octave_idx_type i = idx + 1; i < ndim; ++i)
-              ret *= mat->dimensions[idx];
+              ret *= mat->m_dimensions[idx];
             return ret;
           }
 
-        return mat->dimensions[idx];
+        return mat->m_dimensions[idx];
       }
     else // ndim < count
-      return idx < ndim ? mat->dimensions[idx] : 1;
+      return idx < ndim ? mat->m_dimensions[idx] : 1;
   }
 
   extern "C" octave_base_value *
   octave_jit_create_undef (void)
   {
     octave_value undef;
     octave_base_value *ret = undef.internal_rep ();
     ret->grab ();
@@ -484,52 +485,52 @@ namespace octave
   {
     Range r (*this);
     return r.all_elements_are_ints ();
   }
 
   std::ostream&
   operator<< (std::ostream& os, const jit_range& rng)
   {
-    return os << "Range[" << rng.base << ", " << rng.limit << ", " << rng.inc
-              << ", " << rng.nelem << ']';
+    return os << "Range[" << rng.m_base << ", " << rng.m_limit
+              << ", " << rng.m_inc << ", " << rng.m_nelem << ']';
   }
 
 
   // -------------------- jit_matrix --------------------
 
   std::ostream&
   operator<< (std::ostream& os, const jit_matrix& mat)
   {
-    return os << "Matrix[" << mat.ref_count << ", " << mat.slice_data << ", "
-              << mat.slice_len << ", " << mat.dimensions << ", "
-              << mat.array << ']';
+    return os << "Matrix[" << mat.m_ref_count << ", " << mat.m_slice_data << ", "
+              << mat.m_slice_len << ", " << mat.m_dimensions << ", "
+              << mat.m_array << ']';
   }
 
 
   // -------------------- jit_type --------------------
 
   jit_type::jit_type (const std::string& aname, jit_type *aparent,
                       llvm::Type *allvm_type, bool askip_paren, int aid) :
-    mname (aname), mparent (aparent), llvm_type (allvm_type), mid (aid),
-    mdepth (aparent ? aparent->mdepth + 1 : 0), mskip_paren (askip_paren)
+    m_name (aname), m_parent (aparent), m_llvm_type (allvm_type), m_id (aid),
+    m_depth (aparent ? aparent->m_depth + 1 : 0), m_skip_paren (askip_paren)
   {
-    std::memset (msret, 0, sizeof (msret));
-    std::memset (mpointer_arg, 0, sizeof (mpointer_arg));
-    std::memset (mpack, 0, sizeof (mpack));
-    std::memset (munpack, 0, sizeof (munpack));
+    std::memset (m_sret, 0, sizeof (m_sret));
+    std::memset (m_pointer_arg, 0, sizeof (m_pointer_arg));
+    std::memset (m_pack, 0, sizeof (m_pack));
+    std::memset (m_unpack, 0, sizeof (m_unpack));
 
     for (size_t i = 0; i < jit_convention::length; ++i)
-      mpacked_type[i] = llvm_type;
+      m_packed_type[i] = m_llvm_type;
   }
 
   llvm::Type *
   jit_type::to_llvm_arg (void) const
   {
-    return llvm_type ? llvm_type->getPointerTo () : nullptr;
+    return m_llvm_type ? m_llvm_type->getPointerTo () : nullptr;
   }
 
   jit_type*
   jit_type_join (jit_type *lhs, jit_type *rhs)
   {
     // empty case
     if (! lhs)
       return rhs;
@@ -556,275 +557,275 @@ namespace octave
           }
       }
     return lhs;
   }
 
 
   // -------------------- jit_function --------------------
   jit_function::jit_function ()
-    : module (nullptr), llvm_function (nullptr), mresult (nullptr),
-      call_conv (jit_convention::length), mcan_error (false)
+    : m_module (nullptr), m_llvm_function (nullptr), m_result (nullptr),
+      m_call_conv (jit_convention::length), m_can_error (false)
   { }
 
   jit_function::jit_function (const jit_module *amodule,
                               jit_convention::type acall_conv,
                               const llvm::Twine& aname, jit_type *aresult,
                               const std::vector<jit_type *>& aargs)
-    : module (amodule), mresult (aresult), args (aargs), call_conv (acall_conv),
-      mcan_error (false)
+    : m_module (amodule), m_result (aresult), m_args (aargs), m_call_conv (acall_conv),
+      m_can_error (false)
   {
     llvm::SmallVector<llvm::Type *, 15> llvm_args;
 
     llvm::Type *rtype = llvm::Type::getVoidTy (context);
-    if (mresult)
+    if (m_result)
       {
-        rtype = mresult->packed_type (call_conv);
+        rtype = m_result->packed_type (m_call_conv);
         if (sret ())
           {
             llvm_args.push_back (rtype->getPointerTo ());
             rtype = llvm::Type::getVoidTy (context);
           }
       }
 
-    for (std::vector<jit_type *>::const_iterator iter = args.begin ();
-         iter != args.end (); ++iter)
+    for (std::vector<jit_type *>::const_iterator iter = m_args.begin ();
+         iter != m_args.end (); ++iter)
       {
         jit_type *ty = *iter;
         assert (ty);
-        llvm::Type *argty = ty->packed_type (call_conv);
-        if (ty->pointer_arg (call_conv))
+        llvm::Type *argty = ty->packed_type (m_call_conv);
+        if (ty->pointer_arg (m_call_conv))
           argty = argty->getPointerTo ();
 
         llvm_args.push_back (argty);
       }
 
     llvm::FunctionType *ft = llvm::FunctionType::get (rtype, llvm_args, false);
-    llvm_function = module->create_llvm_function (ft, aname);
+    m_llvm_function = m_module->create_llvm_function (ft, aname);
 
     if (sret ())
       {
 #if defined (FUNCTION_ADDATTRIBUTE_ARG_IS_ATTRIBUTES)
         llvm::AttrBuilder attr_builder;
         attr_builder.addAttribute (llvm::Attributes::StructRet);
         llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder);
-        llvm_function->addAttribute (1, attrs);
+        m_llvm_function->addAttribute (1, attrs);
 #else
-        llvm_function->addAttribute (1, llvm::Attribute::StructRet);
+        m_llvm_function->addAttribute (1, llvm::Attribute::StructRet);
 #endif
       }
 
-    if (call_conv == jit_convention::internal)
+    if (m_call_conv == jit_convention::internal)
 #if defined (FUNCTION_ADDFNATTR_ARG_IS_ATTRIBUTES)
-      llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
+      m_llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
 #else
-    llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
+    m_llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
 #endif
   }
 
   jit_function::jit_function (const jit_function& fn, jit_type *aresult,
                               const std::vector<jit_type *>& aargs)
-    : module (fn.module), llvm_function (fn.llvm_function), mresult (aresult),
-      args (aargs), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
+    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function), m_result (aresult),
+      m_args (aargs), m_call_conv (fn.m_call_conv), m_can_error (fn.m_can_error)
   { }
 
   jit_function::jit_function (const jit_function& fn)
-    : module (fn.module), llvm_function (fn.llvm_function), mresult (fn.mresult),
-      args (fn.args), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
+    : m_module (fn.m_module), m_llvm_function (fn.m_llvm_function), m_result (fn.m_result),
+      m_args (fn.m_args), m_call_conv (fn.m_call_conv), m_can_error (fn.m_can_error)
   { }
 
   void
   jit_function::erase (void)
   {
-    if (! llvm_function)
+    if (! m_llvm_function)
       return;
 
-    llvm_function->eraseFromParent ();
-    llvm_function = 0;
+    m_llvm_function->eraseFromParent ();
+    m_llvm_function = 0;
   }
 
   std::string
   jit_function::name (void) const
   {
-    return llvm_function->getName ();
+    return m_llvm_function->getName ();
   }
 
   llvm::BasicBlock *
   jit_function::new_block (const std::string& aname,
                            llvm::BasicBlock *insert_before)
   {
-    return llvm::BasicBlock::Create (context, aname, llvm_function,
+    return llvm::BasicBlock::Create (context, aname, m_llvm_function,
                                      insert_before);
   }
 
   llvm::Value *
   jit_function::call (llvm::IRBuilderD& builder,
                       const std::vector<jit_value *>& in_args) const
   {
     if (! valid ())
       throw jit_fail_exception ("Call not implemented");
 
-    assert (in_args.size () == args.size ());
-    std::vector<llvm::Value *> llvm_args (args.size ());
+    assert (in_args.size () == m_args.size ());
+    std::vector<llvm::Value *> llvm_args (m_args.size ());
     for (size_t i = 0; i < in_args.size (); ++i)
       llvm_args[i] = in_args[i]->to_llvm ();
 
     return call (builder, llvm_args);
   }
 
   llvm::Value *
   jit_function::call (llvm::IRBuilderD& builder,
                       const std::vector<llvm::Value *>& in_args) const
   {
     if (! valid ())
       throw jit_fail_exception ("Call not implemented");
 
-    assert (in_args.size () == args.size ());
+    assert (in_args.size () == m_args.size ());
     llvm::SmallVector<llvm::Value *, 10> llvm_args;
     llvm_args.reserve (in_args.size () + sret ());
 
     llvm::BasicBlock *insert_block = builder.GetInsertBlock ();
     llvm::Function *parent = insert_block->getParent ();
     assert (parent);
 
     // we insert allocas inside the prelude block to prevent stack overflows
     llvm::BasicBlock& prelude = parent->getEntryBlock ();
     llvm::IRBuilder<> pre_builder (&prelude, prelude.begin ());
 
     llvm::AllocaInst *sret_mem = nullptr;
     if (sret ())
       {
-        sret_mem = pre_builder.CreateAlloca (mresult->packed_type (call_conv));
+        sret_mem = pre_builder.CreateAlloca (m_result->packed_type (m_call_conv));
         llvm_args.push_back (sret_mem);
       }
 
     for (size_t i = 0; i < in_args.size (); ++i)
       {
         llvm::Value *arg = in_args[i];
-        jit_type::convert_fn convert = args[i]->pack (call_conv);
+        jit_type::convert_fn convert = m_args[i]->pack (m_call_conv);
         if (convert)
           arg = convert (builder, arg);
 
-        if (args[i]->pointer_arg (call_conv))
+        if (m_args[i]->pointer_arg (m_call_conv))
           {
-            llvm::Type *ty = args[i]->packed_type (call_conv);
+            llvm::Type *ty = m_args[i]->packed_type (m_call_conv);
             llvm::Value *alloca = pre_builder.CreateAlloca (ty);
             builder.CreateStore (arg, alloca);
             arg = alloca;
           }
 
         llvm_args.push_back (arg);
       }
 
-    llvm::CallInst *callinst = builder.CreateCall (llvm_function, llvm_args);
+    llvm::CallInst *callinst = builder.CreateCall (m_llvm_function, llvm_args);
     llvm::Value *ret = callinst;
 
     if (sret ())
       {
 #if defined (CALLINST_ADDATTRIBUTE_ARG_IS_ATTRIBUTES)
         llvm::AttrBuilder attr_builder;
         attr_builder.addAttribute(llvm::Attributes::StructRet);
         llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder);
         callinst->addAttribute (1, attrs);
 #else
         callinst->addAttribute (1, llvm::Attribute::StructRet);
 #endif
         ret = builder.CreateLoad (sret_mem);
       }
 
-    if (mresult)
+    if (m_result)
       {
-        jit_type::convert_fn unpack = mresult->unpack (call_conv);
+        jit_type::convert_fn unpack = m_result->unpack (m_call_conv);
         if (unpack)
           ret = unpack (builder, ret);
       }
 
     return ret;
   }
 
   llvm::Value *
   jit_function::argument (llvm::IRBuilderD& builder, size_t idx) const
   {
-    assert (idx < args.size ());
+    assert (idx < m_args.size ());
 
     // FIXME: We should be treating arguments like a list, not a vector.
     // Shouldn't matter much for now, as the number of arguments shouldn't
     // be much bigger than 4
-    llvm::Function::arg_iterator iter = llvm_function->arg_begin ();
+    llvm::Function::arg_iterator iter = m_llvm_function->arg_begin ();
     if (sret ())
       ++iter;
 
     for (size_t i = 0; i < idx; ++i, ++iter);
 
-    if (args[idx]->pointer_arg (call_conv))
+    if (m_args[idx]->pointer_arg (m_call_conv))
       return builder.CreateLoad (&*iter);
 
     return &*iter;
   }
 
   void
   jit_function::do_return (llvm::IRBuilderD& builder, llvm::Value *rval,
                            bool verify)
   {
-    assert (! rval == ! mresult);
+    assert (! rval == ! m_result);
 
     if (rval)
       {
-        jit_type::convert_fn convert = mresult->pack (call_conv);
+        jit_type::convert_fn convert = m_result->pack (m_call_conv);
         if (convert)
           rval = convert (builder, rval);
 
         if (sret ())
           {
-            builder.CreateStore (rval, &*(llvm_function->arg_begin ()));
+            builder.CreateStore (rval, &*(m_llvm_function->arg_begin ()));
             builder.CreateRetVoid ();
           }
         else
           builder.CreateRet (rval);
       }
     else
       builder.CreateRetVoid ();
 
     if (verify)
-      llvm::verifyFunction (*llvm_function);
+      llvm::verifyFunction (*m_llvm_function);
   }
 
   std::ostream&
   operator<< (std::ostream& os, const jit_function& fn)
   {
     llvm::Function *lfn = fn.to_llvm ();
-    os << "jit_function: cc=" << fn.call_conv;
+    os << "jit_function: cc=" << fn.m_call_conv;
     llvm::raw_os_ostream llvm_out (os);
     lfn->print (llvm_out);
     llvm_out.flush ();
     return os;
   }
 
   // -------------------- jit_operation --------------------
   jit_operation::~jit_operation (void)
   {
-    for (generated_map::iterator iter = generated.begin ();
-         iter != generated.end (); ++iter)
+    for (generated_map::iterator iter = m_generated.begin ();
+         iter != m_generated.end (); ++iter)
       {
         delete iter->first;
         delete iter->second;
       }
   }
 
   void
   jit_operation::add_overload (const jit_function& func,
                                const std::vector<jit_type*>& args)
   {
     // Number of input arguments of the overload that is being registered
     size_t nargs = args.size ();
 
-    if (nargs >= overloads.size ())
-      overloads.resize (nargs + 1);
+    if (nargs >= m_overloads.size ())
+      m_overloads.resize (nargs + 1);
 
-    Array<jit_function>& over = overloads[nargs];
+    Array<jit_function>& over = m_overloads[nargs];
     dim_vector dv (over.dims ());
     Array<octave_idx_type> idx = to_idx (args);
     bool must_resize = false;
 
     if (dv.length () != idx.numel ())
       {
         dv.resize (idx.numel ());
         must_resize = true;
@@ -849,20 +850,20 @@ namespace octave
     // Number of input arguments of the overload that is being looked for
     size_t nargs = types.size ();
 
     static jit_function null_overload;
     for (size_t i = 0; i < nargs; ++i)
       if (! types[i])
         return null_overload;
 
-    if (nargs >= overloads.size ())
+    if (nargs >= m_overloads.size ())
       return do_generate (types);
 
-    const Array<jit_function>& over = overloads[nargs];
+    const Array<jit_function>& over = m_overloads[nargs];
     dim_vector dv (over.dims ());
     Array<octave_idx_type> idx = to_idx (types);
     for (octave_idx_type i = 0; i < dv.length (); ++i)
       if (idx(i) >= dv(i))
         return do_generate (types);
 
     const jit_function& ret = over(idx);
     if (! ret.valid ())
@@ -892,27 +893,27 @@ namespace octave
 
     return idx;
   }
 
   const jit_function&
   jit_operation::do_generate (const signature_vec& types) const
   {
     static jit_function null_overload;
-    generated_map::const_iterator find = generated.find (&types);
-    if (find != generated.end ())
+    generated_map::const_iterator find = m_generated.find (&types);
+    if (find != m_generated.end ())
       {
         if (find->second)
           return *find->second;
         else
           return null_overload;
       }
 
     jit_function *ret = generate (types);
-    generated[new signature_vec (types)] = ret;
+    m_generated[new signature_vec (types)] = ret;
     return ret ? *ret : null_overload;
   }
 
   jit_function *
   jit_operation::generate (const signature_vec&) const
   {
     return 0;
   }
@@ -977,1205 +978,1204 @@ namespace octave
     builder.CreateStore (array, array_mem);
     return builder.CreateBitCast (array_mem, scalar_t->getPointerTo ());
   }
 
   // -------------------- jit_paren_subsref --------------------
 
   jit_paren_subsref::jit_paren_subsref (const jit_typeinfo& ti)
     : jit_index_operation (ti, "()subsref"),
-      paren_scalar (nullptr)
+      m_paren_scalar (nullptr)
   {
   }
 
-  jit_paren_subsref::~jit_paren_subsref ()
+  jit_paren_subsref::~jit_paren_subsref (void)
   {
-    delete paren_scalar;
+    delete m_paren_scalar;
   }
 
   jit_function *
   jit_paren_subsref::generate_matrix (const signature_vec& types) const
   {
-    if (paren_scalar == nullptr)
+    if (m_paren_scalar == nullptr)
       panic_impossible ();
 
     std::stringstream ss;
     ss << "jit_paren_subsref_matrix_scalar" << (types.size () - 1);
 
     // FIXME: Where will this be deleted?
     jit_function *fn = new jit_function
-      (typeinfo.create_internal (ss.str (), typeinfo.scalar, types));
+      (m_typeinfo.create_internal (ss.str (), m_typeinfo.m_scalar, types));
 
     fn->mark_can_error ();
     llvm::BasicBlock *body = fn->new_block ();
     llvm::IRBuilder<> builder (body);
 
     llvm::Value *array = create_arg_array (builder, *fn, 1, types.size ());
-    llvm::Value *nelem = llvm::ConstantInt::get (typeinfo.index_t,
+    llvm::Value *nelem = llvm::ConstantInt::get (m_typeinfo.m_index_t,
                                                  types.size () - 1);
     llvm::Value *mat = fn->argument (builder, 0);
-    llvm::Value *ret = paren_scalar->call (builder, mat, array, nelem);
+    llvm::Value *ret = m_paren_scalar->call (builder, mat, array, nelem);
     fn->do_return (builder, ret);
     return fn;
   }
 
   void
   jit_paren_subsref::init_paren_scalar ()
   {
     std::vector<jit_type *> types (3);
-    types[0] = typeinfo.matrix;
-    types[1] = typeinfo.scalar_ptr;
-    types[2] = typeinfo.index;
+    types[0] = m_typeinfo.m_matrix;
+    types[1] = m_typeinfo.m_scalar_ptr;
+    types[2] = m_typeinfo.m_index;
 
-    paren_scalar = new jit_function
-      (typeinfo.create_external (&octave_jit_paren_scalar,
-                                 "octave_jit_paren_scalar",
-                                 typeinfo.scalar, types));
+    m_paren_scalar = new jit_function
+      (m_typeinfo.create_external (&octave_jit_paren_scalar,
+                                   "octave_jit_paren_scalar",
+                                   m_typeinfo.m_scalar, types));
 
-    paren_scalar->mark_can_error ();
+    m_paren_scalar->mark_can_error ();
   }
 
   // -------------------- jit_paren_subsasgn --------------------
 
   jit_paren_subsasgn::jit_paren_subsasgn (const jit_typeinfo& ti)
     : jit_index_operation (ti, "()subsasgn"),
-      paren_scalar (nullptr)
-  {
-  }
+      m_paren_scalar (nullptr)
+  { }
 
-  jit_paren_subsasgn::~jit_paren_subsasgn ()
+  jit_paren_subsasgn::~jit_paren_subsasgn (void)
   {
-    delete paren_scalar;
+    delete m_paren_scalar;
   }
 
   jit_function *
   jit_paren_subsasgn::generate_matrix (const signature_vec& types) const
   {
-    if (paren_scalar == nullptr)
+    if (m_paren_scalar == nullptr)
       panic_impossible ();
 
     std::stringstream ss;
     ss << "jit_paren_subsasgn_matrix_scalar" << (types.size () - 2);
 
     // FIXME: Where will this be deleted?
     jit_function *fn = new jit_function
-      (typeinfo.create_internal (ss.str (), typeinfo.matrix, types));
+      (m_typeinfo.create_internal (ss.str (), m_typeinfo.m_matrix, types));
 
     fn->mark_can_error ();
     llvm::BasicBlock *body = fn->new_block ();
     llvm::IRBuilder<> builder (body);
 
     llvm::Value *array = create_arg_array (builder, *fn, 1, types.size () - 1);
-    llvm::Value *nelem = llvm::ConstantInt::get (typeinfo.index_t,
+    llvm::Value *nelem = llvm::ConstantInt::get (m_typeinfo.m_index_t,
                                                  types.size () - 2);
 
     llvm::Value *mat = fn->argument (builder, 0);
     llvm::Value *value = fn->argument (builder, types.size () - 1);
-    llvm::Value *ret = paren_scalar->call (builder, mat, array, nelem, value);
+    llvm::Value *ret = m_paren_scalar->call (builder, mat, array, nelem, value);
     fn->do_return (builder, ret);
 
     return fn;
   }
 
   void
   jit_paren_subsasgn::init_paren_scalar ()
   {
     std::vector<jit_type *> types (4);
-    types[0] = typeinfo.matrix;
-    types[1] = typeinfo.scalar_ptr;
-    types[2] = typeinfo.index;
-    types[3] = typeinfo.scalar;
+    types[0] = m_typeinfo.m_matrix;
+    types[1] = m_typeinfo.m_scalar_ptr;
+    types[2] = m_typeinfo.m_index;
+    types[3] = m_typeinfo.m_scalar;
 
-    paren_scalar = new jit_function
-      (typeinfo.create_external (&octave_jit_paren_scalar_subsasgn,
-                                 "octave_jit_paren_scalar",
-                                 typeinfo.matrix, types));
+    m_paren_scalar = new jit_function
+      (m_typeinfo.create_external (&octave_jit_paren_scalar_subsasgn,
+                                   "octave_jit_paren_scalar",
+                                   m_typeinfo.m_matrix, types));
 
-    paren_scalar->mark_can_error ();
+    m_paren_scalar->mark_can_error ();
   }
 
 
   // -------------------- jit_typeinfo --------------------
 
-  bool jit_typeinfo::in_construction = false;
+  bool jit_typeinfo::s_in_construction = false;
 
   // Static method that holds the singleton instance
   jit_typeinfo&
   jit_typeinfo::instance (void)
   {
-    if (in_construction)
+    if (s_in_construction)
       // This state is typically reached when the constructor calls one
       // of the static methods of the singleton class...
       panic_impossible ();
 
     static jit_typeinfo typeinfo;
     return typeinfo;
   }
 
-  jit_typeinfo::~jit_typeinfo ()
+  jit_typeinfo::~jit_typeinfo (void)
   {
-    while (! id_to_type.empty ())
+    while (! m_id_to_type.empty ())
       {
-        delete id_to_type.back ();
-        id_to_type.pop_back ();
+        delete m_id_to_type.back ();
+        m_id_to_type.pop_back ();
       }
 
-    delete builder_ptr;
-    delete base_jit_module;
+    delete m_builder_ptr;
+    delete m_base_jit_module;
   }
 
   // wrap function names to simplify jit_typeinfo::create_external
 #define JIT_FN(fn) &fn, #fn
 
-  jit_typeinfo::jit_typeinfo ()
+  jit_typeinfo::jit_typeinfo (void)
     : paren_subsref_fn (*this),
       paren_subsasgn_fn (*this),
-      next_id (0),
-      grab_fn ("grab"),
-      release_fn ("release"),
-      destroy_fn ("destroy"),
-      print_fn ("print"),
-      for_init_fn ("for_init"),
-      for_check_fn ("for_check"),
-      for_index_fn ("for_index"),
-      logically_true_fn ("logically_true"),
-      make_range_fn ("make_range"),
-      end1_fn ("end1"),
-      end_fn ("end"),
-      create_undef_fn ("create_undef"),
-      base_jit_module (new jit_module ("octaveJITBaseModule")),
-      builder_ptr (new llvm::IRBuilderD (context)),
-      builder (*builder_ptr)  // FIXME: Use a pointer directly in the constructor, and get rid of this
+      m_next_id (0),
+      m_grab_fn ("grab"),
+      m_release_fn ("release"),
+      m_destroy_fn ("destroy"),
+      m_print_fn ("print"),
+      m_for_init_fn ("for_init"),
+      m_for_check_fn ("for_check"),
+      m_for_index_fn ("for_index"),
+      m_logically_true_fn ("logically_true"),
+      m_make_range_fn ("make_range"),
+      m_end1_fn ("end1"),
+      m_end_fn ("end"),
+      m_create_undef_fn ("create_undef"),
+      m_base_jit_module (new jit_module ("octaveJITBaseModule")),
+      m_builder_ptr (new llvm::IRBuilderD (context)),
+      m_builder (*m_builder_ptr)  // FIXME: Use a pointer directly in the constructor, and get rid of this
   {
-    in_construction = true;
+    s_in_construction = true;
 
     // ----- Register basic JIT types -----
 
     // FIXME: It seems that our type lattice is not really a lattice
     //        since any and any_ptr have no common upper_bound (?!?)
 
     // jit_types: "any"     < (nullptr)
     //            "any_ptr" < (nullptr)
-    any_t = llvm::StructType::create (context, "octave_base_value");
-    any_t = any_t->getPointerTo ();
-    any = do_register_new_type ("any", nullptr, any_t);
-    any_ptr = do_register_new_type ("any_ptr", nullptr, any_t->getPointerTo ());
+    m_any_t = llvm::StructType::create (context, "octave_base_value");
+    m_any_t = m_any_t->getPointerTo ();
+    m_any = do_register_new_type ("any", nullptr, m_any_t);
+    m_any_ptr = do_register_new_type ("any_ptr", nullptr, m_any_t->getPointerTo ());
 
     // jit_types: "scalar"     < "complex" < "any"
     //       and: "scalar_ptr" < (nullptr)
     // FIXME: what about sing-precision floats ???
     // FIXME: shouldn't we make scalar_ptr a sub_type of any_ptr ?
-    scalar_t = llvm::Type::getDoubleTy (context);
-    complex_t = llvm::ArrayType::get (scalar_t, 2);
-    complex = do_register_new_type ("complex", any, complex_t);
-    scalar = do_register_new_type ("scalar", complex, scalar_t);
-    scalar_ptr = do_register_new_type ("scalar_ptr", nullptr, scalar_t->getPointerTo ());
+    m_scalar_t = llvm::Type::getDoubleTy (context);
+    m_complex_t = llvm::ArrayType::get (m_scalar_t, 2);
+    m_complex = do_register_new_type ("complex", m_any, m_complex_t);
+    m_scalar = do_register_new_type ("scalar", m_complex, m_scalar_t);
+    m_scalar_ptr = do_register_new_type ("scalar_ptr", nullptr, m_scalar_t->getPointerTo ());
 
     // jit_type: "bool" < "any"
-    bool_t = llvm::Type::getInt1Ty (context);
-    boolean = do_register_new_type ("bool", any, bool_t);
+    m_bool_t = llvm::Type::getInt1Ty (context);
+    m_boolean = do_register_new_type ("bool", m_any, m_bool_t);
 
     // jit_types: "int8", "int16", "int32", "int64" < "any"
-    ints[ 8] = do_register_new_type ("int8",  any, llvm::Type::getIntNTy (context,  8));
-    ints[16] = do_register_new_type ("int16", any, llvm::Type::getIntNTy (context, 16));
-    ints[32] = do_register_new_type ("int32", any, llvm::Type::getIntNTy (context, 32));
-    ints[64] = do_register_new_type ("int64", any, llvm::Type::getIntNTy (context, 64));
+    m_ints[ 8] = do_register_new_type ("int8",  m_any, llvm::Type::getIntNTy (context,  8));
+    m_ints[16] = do_register_new_type ("int16", m_any, llvm::Type::getIntNTy (context, 16));
+    m_ints[32] = do_register_new_type ("int32", m_any, llvm::Type::getIntNTy (context, 32));
+    m_ints[64] = do_register_new_type ("int64", m_any, llvm::Type::getIntNTy (context, 64));
 
     // jit_type: "string" < "any"
-    string_t = llvm::Type::getInt8Ty (context);
-    string_t = string_t->getPointerTo ();
-    string = do_register_new_type ("string", any, string_t);
+    m_string_t = llvm::Type::getInt8Ty (context);
+    m_string_t = m_string_t->getPointerTo ();
+    m_string = do_register_new_type ("string", m_any, m_string_t);
 
     // jit_type: "index" < "any"
-    index_t = llvm::Type::getIntNTy (context, sizeof (octave_idx_type) * 8);
-    index = do_register_new_type ("index", any, index_t);
+    m_index_t = llvm::Type::getIntNTy (context, sizeof (octave_idx_type) * 8);
+    m_index = do_register_new_type ("index", m_any, m_index_t);
 
     // jit_type: "range" < "any"
-    range_t = llvm::StructType::create (context, "range");
+    m_range_t = llvm::StructType::create (context, "range");
     {
-      std::vector<llvm::Type *> range_contents (4, scalar_t);
-      range_contents[3] = index_t;
-      range_t->setBody (range_contents);
+      std::vector<llvm::Type *> range_contents (4, m_scalar_t);
+      range_contents[3] = m_index_t;
+      m_range_t->setBody (range_contents);
     }
-    range = do_register_new_type ("range", any, range_t);
+    m_range = do_register_new_type ("range", m_any, m_range_t);
 
     // jit_type: "matrix" < "any"
-    matrix_t = llvm::StructType::create (context, "matrix");
+    m_matrix_t = llvm::StructType::create (context, "matrix");
     {
       llvm::Type *refcount_t = llvm::Type::getIntNTy (context, sizeof(int) * 8);
       llvm::Type *matrix_contents[5];
       matrix_contents[0] = refcount_t->getPointerTo ();
-      matrix_contents[1] = scalar_t->getPointerTo ();
-      matrix_contents[2] = index_t;
-      matrix_contents[3] = index_t->getPointerTo ();
-      matrix_contents[4] = string_t;
-      matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
+      matrix_contents[1] = m_scalar_t->getPointerTo ();
+      matrix_contents[2] = m_index_t;
+      matrix_contents[3] = m_index_t->getPointerTo ();
+      matrix_contents[4] = m_string_t;
+      m_matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
     }
-    matrix = do_register_new_type ("matrix", any, matrix_t);
+    m_matrix = do_register_new_type ("matrix", m_any, m_matrix_t);
 
     // ----- Specify calling conventions -----
 
     // complex_ret is what is passed to C functions
     // in order to get calling convention right
-    complex_ret = llvm::StructType::create (context, "complex_ret");
+    m_complex_ret = llvm::StructType::create (context, "complex_ret");
     {
-      llvm::Type *cmplx_inner_cont[] = {scalar_t, scalar_t};
+      llvm::Type *cmplx_inner_cont[] = {m_scalar_t, m_scalar_t};
       llvm::StructType *cmplx_inner = llvm::StructType::create (cmplx_inner_cont);
       llvm::Type *contents[] = {cmplx_inner};
-      complex_ret->setBody (contents);
+      m_complex_ret->setBody (contents);
     }
 
     // FIXME: We should detect architecture and do something sane
     //        based on that here we assume x86 or x86_64
-    matrix->mark_sret (jit_convention::external);
-    matrix->mark_pointer_arg (jit_convention::external);
+    m_matrix->mark_sret (jit_convention::external);
+    m_matrix->mark_pointer_arg (jit_convention::external);
 
-    range->mark_sret (jit_convention::external);
-    range->mark_pointer_arg (jit_convention::external);
+    m_range->mark_sret (jit_convention::external);
+    m_range->mark_pointer_arg (jit_convention::external);
 
-    complex->set_pack (jit_convention::external, &jit_typeinfo::pack_complex);
-    complex->set_unpack (jit_convention::external, &jit_typeinfo::unpack_complex);
-    complex->set_packed_type (jit_convention::external, complex_ret);
+    m_complex->set_pack (jit_convention::external, &jit_typeinfo::pack_complex);
+    m_complex->set_unpack (jit_convention::external, &jit_typeinfo::unpack_complex);
+    m_complex->set_packed_type (jit_convention::external, m_complex_ret);
 
     if (sizeof (void *) == 4)
-      complex->mark_sret (jit_convention::external);
+      m_complex->mark_sret (jit_convention::external);
 
     paren_subsref_fn.init_paren_scalar ();
     paren_subsasgn_fn.init_paren_scalar ();
 
     // bind global variables
-    lerror_state = base_jit_module->create_global_variable (bool_t, false,
-                                                            "error_state");
+    m_lerror_state = m_base_jit_module->create_global_variable (m_bool_t, false,
+                                                                "error_state");
 
-    base_jit_module->add_global_mapping (lerror_state, &error_state);
+    m_base_jit_module->add_global_mapping (m_lerror_state, &error_state);
 
     // sig_atomic_type is going to be some sort of integer
-    sig_atomic_type = llvm::Type::getIntNTy (context, sizeof(sig_atomic_t) * 8);
+    m_sig_atomic_type = llvm::Type::getIntNTy (context, sizeof(sig_atomic_t) * 8);
 
-    loctave_interrupt_state = base_jit_module->create_global_variable
-      (sig_atomic_type, false, "octave_interrupt_state");
+    m_loctave_interrupt_state = m_base_jit_module->create_global_variable
+      (m_sig_atomic_type, false, "octave_interrupt_state");
 
-    base_jit_module->add_global_mapping (loctave_interrupt_state,
-                                         &octave_interrupt_state);
+    m_base_jit_module->add_global_mapping (m_loctave_interrupt_state,
+                                           &octave_interrupt_state);
 
     // generic call function
     {
       jit_type *int_t = do_get_intN (sizeof (octave_builtin::fcn) * 8);
-      any_call = create_external (JIT_FN (octave_jit_call), any, int_t, int_t,
-                                  any_ptr, int_t);
+      m_any_call = create_external (JIT_FN (octave_jit_call), m_any, int_t, int_t,
+                                    m_any_ptr, int_t);
     }
 
     // any with anything is an any op
     jit_function fn;
     jit_type *binary_op_type = do_get_intN (sizeof (octave_value::binary_op) * 8);
     llvm::Type *llvm_bo_type = binary_op_type->to_llvm ();
     jit_function any_binary = create_external (JIT_FN (octave_jit_binary_any_any),
-                                               any, binary_op_type, any, any);
+                                               m_any, binary_op_type, m_any, m_any);
     any_binary.mark_can_error ();
 
     for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
       {
         octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
         std::string op_name = octave_value::binary_op_as_string (op);
-        binary_ops.push_back (jit_operation ("binary" + op_name));
+        m_binary_ops.push_back (jit_operation ("binary" + op_name));
       }
 
     for (size_t i = 0; i < octave_value::num_unary_ops; ++i)
       {
         octave_value::unary_op op = static_cast<octave_value::unary_op> (i);
         std::string op_name = octave_value::unary_op_as_string (op);
-        unary_ops.push_back (jit_operation ("unary" + op_name));
+        m_unary_ops.push_back (jit_operation ("unary" + op_name));
       }
 
     for (int op = 0; op < octave_value::num_binary_ops; ++op)
       {
         const llvm::Twine &fn_name =
           "octave_jit_binary_any_any_" + llvm::Twine (op);
 
-        fn = create_internal (fn_name, any, any, any);
+        fn = create_internal (fn_name, m_any, m_any, m_any);
         fn.mark_can_error ();
         llvm::BasicBlock *block = fn.new_block ();
-        builder.SetInsertPoint (block);
+        m_builder.SetInsertPoint (block);
         llvm::APInt op_int(sizeof (octave_value::binary_op) * 8, op,
                            std::numeric_limits<octave_value::binary_op>::is_signed);
         llvm::Value *op_as_llvm = llvm::ConstantInt::get (llvm_bo_type, op_int);
-        llvm::Value *ret = any_binary.call (builder, op_as_llvm,
-                                            fn.argument (builder, 0),
-                                            fn.argument (builder, 1));
-        fn.do_return (builder, ret);
-        binary_ops[op].add_overload (fn);
+        llvm::Value *ret = any_binary.call (m_builder, op_as_llvm,
+                                            fn.argument (m_builder, 0),
+                                            fn.argument (m_builder, 1));
+        fn.do_return (m_builder, ret);
+        m_binary_ops[op].add_overload (fn);
       }
 
     // grab matrix
-    fn = create_external (JIT_FN (octave_jit_grab_matrix), matrix, matrix);
-    grab_fn.add_overload (fn);
-    grab_fn.add_overload (create_identity (scalar));
-    grab_fn.add_overload (create_identity (scalar_ptr));
-    grab_fn.add_overload (create_identity (any_ptr));
-    grab_fn.add_overload (create_identity (boolean));
-    grab_fn.add_overload (create_identity (complex));
-    grab_fn.add_overload (create_identity (index));
+    fn = create_external (JIT_FN (octave_jit_grab_matrix), m_matrix, m_matrix);
+    m_grab_fn.add_overload (fn);
+    m_grab_fn.add_overload (create_identity (m_scalar));
+    m_grab_fn.add_overload (create_identity (m_scalar_ptr));
+    m_grab_fn.add_overload (create_identity (m_any_ptr));
+    m_grab_fn.add_overload (create_identity (m_boolean));
+    m_grab_fn.add_overload (create_identity (m_complex));
+    m_grab_fn.add_overload (create_identity (m_index));
 
     // release any
-    fn = create_external (JIT_FN (octave_jit_release_any), nullptr, any);
-    release_fn.add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_release_any), nullptr, m_any);
+    m_release_fn.add_overload (fn);
 
     // release matrix
-    fn = create_external (JIT_FN (octave_jit_release_matrix), nullptr, matrix);
-    release_fn.add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_release_matrix), nullptr, m_matrix);
+    m_release_fn.add_overload (fn);
 
     // destroy
-    destroy_fn = release_fn;
-    destroy_fn.add_overload (create_identity(scalar));
-    destroy_fn.add_overload (create_identity(boolean));
-    destroy_fn.add_overload (create_identity(index));
-    destroy_fn.add_overload (create_identity(complex));
+    m_destroy_fn = m_release_fn;
+    m_destroy_fn.add_overload (create_identity(m_scalar));
+    m_destroy_fn.add_overload (create_identity(m_boolean));
+    m_destroy_fn.add_overload (create_identity(m_index));
+    m_destroy_fn.add_overload (create_identity(m_complex));
 
     // -------------------- scalar related operations --------------------
 
     // now for binary scalar operations
-    add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
-    add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
-    add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
-    add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
+    add_binary_op (m_scalar, octave_value::op_add, llvm::Instruction::FAdd);
+    add_binary_op (m_scalar, octave_value::op_sub, llvm::Instruction::FSub);
+    add_binary_op (m_scalar, octave_value::op_mul, llvm::Instruction::FMul);
+    add_binary_op (m_scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
 
-    add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
-    add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
-    add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
-    add_binary_fcmp (scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
-    add_binary_fcmp (scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
-    add_binary_fcmp (scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
+    add_binary_fcmp (m_scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
+    add_binary_fcmp (m_scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
+    add_binary_fcmp (m_scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
+    add_binary_fcmp (m_scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
+    add_binary_fcmp (m_scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
+    add_binary_fcmp (m_scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
     jit_function gripe_div0 = create_external (JIT_FN (warn_divide_by_zero), nullptr);
     gripe_div0.mark_can_error ();
 
     // divide is annoying because it might error
-    fn = create_internal ("octave_jit_div_scalar_scalar", scalar, scalar, scalar);
+    fn = create_internal ("octave_jit_div_scalar_scalar", m_scalar, m_scalar, m_scalar);
     fn.mark_can_error ();
 
     llvm::BasicBlock *body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
       llvm::BasicBlock *warn_block = fn.new_block ("warn");
       llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
-      llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
-      llvm::Value *check = builder.CreateFCmpUEQ (zero, fn.argument (builder, 1));
-      builder.CreateCondBr (check, warn_block, normal_block);
+      llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
+      llvm::Value *check = m_builder.CreateFCmpUEQ (zero, fn.argument (m_builder, 1));
+      m_builder.CreateCondBr (check, warn_block, normal_block);
 
-      builder.SetInsertPoint (warn_block);
-      gripe_div0.call (builder);
-      builder.CreateBr (normal_block);
+      m_builder.SetInsertPoint (warn_block);
+      gripe_div0.call (m_builder);
+      m_builder.CreateBr (normal_block);
 
-      builder.SetInsertPoint (normal_block);
-      llvm::Value *ret = builder.CreateFDiv (fn.argument (builder, 0),
-                                             fn.argument (builder, 1));
-      fn.do_return (builder, ret);
+      m_builder.SetInsertPoint (normal_block);
+      llvm::Value *ret = m_builder.CreateFDiv (fn.argument (m_builder, 0),
+                                               fn.argument (m_builder, 1));
+      fn.do_return (m_builder, ret);
     }
-    binary_ops[octave_value::op_div].add_overload (fn);
-    binary_ops[octave_value::op_el_div].add_overload (fn);
+    m_binary_ops[octave_value::op_div].add_overload (fn);
+    m_binary_ops[octave_value::op_el_div].add_overload (fn);
 
     // ldiv is the same as div with the operators reversed
     fn = mirror_binary (fn);
-    binary_ops[octave_value::op_ldiv].add_overload (fn);
-    binary_ops[octave_value::op_el_ldiv].add_overload (fn);
+    m_binary_ops[octave_value::op_ldiv].add_overload (fn);
+    m_binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
     // In general, the result of scalar ^ scalar is a complex number.  We might
     // be able to improve on this if we keep track of the range of values
     // variables can take on.
-    fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), complex, scalar,
-                          scalar);
-    binary_ops[octave_value::op_pow].add_overload (fn);
-    binary_ops[octave_value::op_el_pow].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), m_complex, m_scalar,
+                          m_scalar);
+    m_binary_ops[octave_value::op_pow].add_overload (fn);
+    m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
     // now for unary scalar operations
     // FIXME: Impelment not
-    fn = create_internal ("octave_jit_++", scalar, scalar);
+    fn = create_internal ("octave_jit_++", m_scalar, m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
-      llvm::Value *val = fn.argument (builder, 0);
-      val = builder.CreateFAdd (val, one);
-      fn.do_return (builder, val);
+      llvm::Value *one = llvm::ConstantFP::get (m_scalar_t, 1);
+      llvm::Value *val = fn.argument (m_builder, 0);
+      val = m_builder.CreateFAdd (val, one);
+      fn.do_return (m_builder, val);
     }
-    unary_ops[octave_value::op_incr].add_overload (fn);
+    m_unary_ops[octave_value::op_incr].add_overload (fn);
 
-    fn = create_internal ("octave_jit_--", scalar, scalar);
+    fn = create_internal ("octave_jit_--", m_scalar, m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *one = llvm::ConstantFP::get (scalar_t, 1);
-      llvm::Value *val = fn.argument (builder, 0);
-      val = builder.CreateFSub (val, one);
-      fn.do_return (builder, val);
+      llvm::Value *one = llvm::ConstantFP::get (m_scalar_t, 1);
+      llvm::Value *val = fn.argument (m_builder, 0);
+      val = m_builder.CreateFSub (val, one);
+      fn.do_return (m_builder, val);
     }
-    unary_ops[octave_value::op_decr].add_overload (fn);
+    m_unary_ops[octave_value::op_decr].add_overload (fn);
 
-    fn = create_internal ("octave_jit_uminus", scalar, scalar);
+    fn = create_internal ("octave_jit_uminus", m_scalar, m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *mone = llvm::ConstantFP::get (scalar_t, -1);
-      llvm::Value *val = fn.argument (builder, 0);
-      val = builder.CreateFMul (val, mone);
-      fn.do_return (builder, val);
+      llvm::Value *mone = llvm::ConstantFP::get (m_scalar_t, -1);
+      llvm::Value *val = fn.argument (m_builder, 0);
+      val = m_builder.CreateFMul (val, mone);
+      fn.do_return (m_builder, val);
     }
-    unary_ops[octave_value::op_uminus].add_overload (fn);
+    m_unary_ops[octave_value::op_uminus].add_overload (fn);
 
-    fn = create_identity (scalar);
-    unary_ops[octave_value::op_uplus].add_overload (fn);
-    unary_ops[octave_value::op_transpose].add_overload (fn);
-    unary_ops[octave_value::op_hermitian].add_overload (fn);
+    fn = create_identity (m_scalar);
+    m_unary_ops[octave_value::op_uplus].add_overload (fn);
+    m_unary_ops[octave_value::op_transpose].add_overload (fn);
+    m_unary_ops[octave_value::op_hermitian].add_overload (fn);
 
     // now for binary complex operations
-    fn = create_internal ("octave_jit_+_complex_complex", complex, complex,
-                          complex);
+    fn = create_internal ("octave_jit_+_complex_complex", m_complex, m_complex,
+                          m_complex);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
-      llvm::Value *real = builder.CreateFAdd (complex_real (lhs),
-                                              complex_real (rhs));
-      llvm::Value *imag = builder.CreateFAdd (complex_imag (lhs),
-                                              complex_imag (rhs));
-      fn.do_return (builder, complex_new (real, imag));
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
+      llvm::Value *real = m_builder.CreateFAdd (complex_real (lhs),
+                                                complex_real (rhs));
+      llvm::Value *imag = m_builder.CreateFAdd (complex_imag (lhs),
+                                                complex_imag (rhs));
+      fn.do_return (m_builder, complex_new (real, imag));
     }
-    binary_ops[octave_value::op_add].add_overload (fn);
+    m_binary_ops[octave_value::op_add].add_overload (fn);
 
-    fn = create_internal ("octave_jit_-_complex_complex", complex, complex,
-                          complex);
+    fn = create_internal ("octave_jit_-_complex_complex", m_complex, m_complex,
+                          m_complex);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
-      llvm::Value *real = builder.CreateFSub (complex_real (lhs),
-                                              complex_real (rhs));
-      llvm::Value *imag = builder.CreateFSub (complex_imag (lhs),
-                                              complex_imag (rhs));
-      fn.do_return (builder, complex_new (real, imag));
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
+      llvm::Value *real = m_builder.CreateFSub (complex_real (lhs),
+                                                complex_real (rhs));
+      llvm::Value *imag = m_builder.CreateFSub (complex_imag (lhs),
+                                                complex_imag (rhs));
+      fn.do_return (m_builder, complex_new (real, imag));
     }
-    binary_ops[octave_value::op_sub].add_overload (fn);
+    m_binary_ops[octave_value::op_sub].add_overload (fn);
 
     fn = create_external (JIT_FN (octave_jit_complex_mul),
-                          complex, complex, complex);
-    binary_ops[octave_value::op_mul].add_overload (fn);
-    binary_ops[octave_value::op_el_mul].add_overload (fn);
+                          m_complex, m_complex, m_complex);
+    m_binary_ops[octave_value::op_mul].add_overload (fn);
+    m_binary_ops[octave_value::op_el_mul].add_overload (fn);
 
     jit_function complex_div = create_external (JIT_FN (octave_jit_complex_div),
-                                                complex, complex, complex);
+                                                m_complex, m_complex, m_complex);
     complex_div.mark_can_error ();
-    binary_ops[octave_value::op_div].add_overload (fn);
-    binary_ops[octave_value::op_ldiv].add_overload (fn);
+    m_binary_ops[octave_value::op_div].add_overload (fn);
+    m_binary_ops[octave_value::op_ldiv].add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_pow_complex_complex), complex,
-                          complex, complex);
-    binary_ops[octave_value::op_pow].add_overload (fn);
-    binary_ops[octave_value::op_el_pow].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_pow_complex_complex), m_complex,
+                          m_complex, m_complex);
+    m_binary_ops[octave_value::op_pow].add_overload (fn);
+    m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
-    fn = create_internal ("octave_jit_*_scalar_complex", complex, scalar,
-                          complex);
+    fn = create_internal ("octave_jit_*_scalar_complex", m_complex, m_scalar,
+                          m_complex);
     jit_function mul_scalar_complex = fn;
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
       llvm::BasicBlock *complex_mul = fn.new_block ("complex_mul");
       llvm::BasicBlock *scalar_mul = fn.new_block ("scalar_mul");
 
-      llvm::Value *fzero = llvm::ConstantFP::get (scalar_t, 0);
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
+      llvm::Value *fzero = llvm::ConstantFP::get (m_scalar_t, 0);
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
 
-      llvm::Value *cmp = builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
-      builder.CreateCondBr (cmp, scalar_mul, complex_mul);
+      llvm::Value *cmp = m_builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
+      m_builder.CreateCondBr (cmp, scalar_mul, complex_mul);
 
-      builder.SetInsertPoint (scalar_mul);
+      m_builder.SetInsertPoint (scalar_mul);
       llvm::Value *temp = complex_real (rhs);
-      temp = builder.CreateFMul (lhs, temp);
-      fn.do_return (builder, complex_new (temp, fzero), false);
+      temp = m_builder.CreateFMul (lhs, temp);
+      fn.do_return (m_builder, complex_new (temp, fzero), false);
 
-      builder.SetInsertPoint (complex_mul);
-      temp = complex_new (builder.CreateFMul (lhs, complex_real (rhs)),
-                          builder.CreateFMul (lhs, complex_imag (rhs)));
-      fn.do_return (builder, temp);
+      m_builder.SetInsertPoint (complex_mul);
+      temp = complex_new (m_builder.CreateFMul (lhs, complex_real (rhs)),
+                          m_builder.CreateFMul (lhs, complex_imag (rhs)));
+      fn.do_return (m_builder, temp);
     }
-    binary_ops[octave_value::op_mul].add_overload (fn);
-    binary_ops[octave_value::op_el_mul].add_overload (fn);
+    m_binary_ops[octave_value::op_mul].add_overload (fn);
+    m_binary_ops[octave_value::op_el_mul].add_overload (fn);
 
     fn = mirror_binary (mul_scalar_complex);
-    binary_ops[octave_value::op_mul].add_overload (fn);
-    binary_ops[octave_value::op_el_mul].add_overload (fn);
+    m_binary_ops[octave_value::op_mul].add_overload (fn);
+    m_binary_ops[octave_value::op_el_mul].add_overload (fn);
 
-    fn = create_internal ("octave_jit_+_scalar_complex", complex, scalar,
-                          complex);
+    fn = create_internal ("octave_jit_+_scalar_complex", m_complex, m_scalar,
+                          m_complex);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
-      llvm::Value *real = builder.CreateFAdd (lhs, complex_real (rhs));
-      fn.do_return (builder, complex_real (rhs, real));
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
+      llvm::Value *real = m_builder.CreateFAdd (lhs, complex_real (rhs));
+      fn.do_return (m_builder, complex_real (rhs, real));
     }
-    binary_ops[octave_value::op_add].add_overload (fn);
+    m_binary_ops[octave_value::op_add].add_overload (fn);
 
     fn = mirror_binary (fn);
-    binary_ops[octave_value::op_add].add_overload (fn);
+    m_binary_ops[octave_value::op_add].add_overload (fn);
 
-    fn = create_internal ("octave_jit_-_complex_scalar", complex, complex,
-                          scalar);
+    fn = create_internal ("octave_jit_-_complex_scalar", m_complex, m_complex,
+                          m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
-      llvm::Value *real = builder.CreateFSub (complex_real (lhs), rhs);
-      fn.do_return (builder, complex_real (lhs, real));
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
+      llvm::Value *real = m_builder.CreateFSub (complex_real (lhs), rhs);
+      fn.do_return (m_builder, complex_real (lhs, real));
     }
-    binary_ops[octave_value::op_sub].add_overload (fn);
+    m_binary_ops[octave_value::op_sub].add_overload (fn);
 
-    fn = create_internal ("octave_jit_-_scalar_complex", complex, scalar,
-                          complex);
+    fn = create_internal ("octave_jit_-_scalar_complex", m_complex, m_scalar,
+                          m_complex);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *lhs = fn.argument (builder, 0);
-      llvm::Value *rhs = fn.argument (builder, 1);
-      llvm::Value *real = builder.CreateFSub (lhs, complex_real (rhs));
-      fn.do_return (builder, complex_real (rhs, real));
+      llvm::Value *lhs = fn.argument (m_builder, 0);
+      llvm::Value *rhs = fn.argument (m_builder, 1);
+      llvm::Value *real = m_builder.CreateFSub (lhs, complex_real (rhs));
+      fn.do_return (m_builder, complex_real (rhs, real));
     }
-    binary_ops[octave_value::op_sub].add_overload (fn);
+    m_binary_ops[octave_value::op_sub].add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_pow_scalar_complex), complex, scalar,
-                          complex);
-    binary_ops[octave_value::op_pow].add_overload (fn);
-    binary_ops[octave_value::op_el_pow].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_pow_scalar_complex), m_complex, m_scalar,
+                          m_complex);
+    m_binary_ops[octave_value::op_pow].add_overload (fn);
+    m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_pow_complex_scalar), complex,
-                          complex, scalar);
-    binary_ops[octave_value::op_pow].add_overload (fn);
-    binary_ops[octave_value::op_el_pow].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_pow_complex_scalar), m_complex,
+                          m_complex, m_scalar);
+    m_binary_ops[octave_value::op_pow].add_overload (fn);
+    m_binary_ops[octave_value::op_el_pow].add_overload (fn);
 
     // now for binary index operators
-    add_binary_op (index, octave_value::op_add, llvm::Instruction::Add);
+    add_binary_op (m_index, octave_value::op_add, llvm::Instruction::Add);
 
     // and binary bool operators
-    add_binary_op (boolean, octave_value::op_el_or, llvm::Instruction::Or);
-    add_binary_op (boolean, octave_value::op_el_and, llvm::Instruction::And);
+    add_binary_op (m_boolean, octave_value::op_el_or, llvm::Instruction::Or);
+    add_binary_op (m_boolean, octave_value::op_el_and, llvm::Instruction::And);
 
     // now for printing functions
-    add_print (any, reinterpret_cast<void *> (&octave_jit_print_any));
-    add_print (scalar, reinterpret_cast<void *> (&octave_jit_print_scalar));
+    add_print (m_any, reinterpret_cast<void *> (&octave_jit_print_any));
+    add_print (m_scalar, reinterpret_cast<void *> (&octave_jit_print_scalar));
 
     // initialize for loop
-    fn = create_internal ("octave_jit_for_range_init", index, range);
+    fn = create_internal ("octave_jit_for_range_init", m_index, m_range);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *zero = llvm::ConstantInt::get (index_t, 0);
-      fn.do_return (builder, zero);
+      llvm::Value *zero = llvm::ConstantInt::get (m_index_t, 0);
+      fn.do_return (m_builder, zero);
     }
-    for_init_fn.add_overload (fn);
+    m_for_init_fn.add_overload (fn);
 
     // bounds check for for loop
-    fn = create_internal ("octave_jit_for_range_check", boolean, range, index);
+    fn = create_internal ("octave_jit_for_range_check", m_boolean, m_range, m_index);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
       llvm::Value *nelem
-        = builder.CreateExtractValue (fn.argument (builder, 0), 3);
-      llvm::Value *idx = fn.argument (builder, 1);
-      llvm::Value *ret = builder.CreateICmpULT (idx, nelem);
-      fn.do_return (builder, ret);
+        = m_builder.CreateExtractValue (fn.argument (m_builder, 0), 3);
+      llvm::Value *idx = fn.argument (m_builder, 1);
+      llvm::Value *ret = m_builder.CreateICmpULT (idx, nelem);
+      fn.do_return (m_builder, ret);
     }
-    for_check_fn.add_overload (fn);
+    m_for_check_fn.add_overload (fn);
 
     // index variabe for for loop
-    fn = create_internal ("octave_jit_for_range_idx", scalar, range, index);
+    fn = create_internal ("octave_jit_for_range_idx", m_scalar, m_range, m_index);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *idx = fn.argument (builder, 1);
-      llvm::Value *didx = builder.CreateSIToFP (idx, scalar_t);
-      llvm::Value *rng = fn.argument (builder, 0);
-      llvm::Value *base = builder.CreateExtractValue (rng, 0);
-      llvm::Value *inc = builder.CreateExtractValue (rng, 2);
+      llvm::Value *idx = fn.argument (m_builder, 1);
+      llvm::Value *didx = m_builder.CreateSIToFP (idx, m_scalar_t);
+      llvm::Value *rng = fn.argument (m_builder, 0);
+      llvm::Value *base = m_builder.CreateExtractValue (rng, 0);
+      llvm::Value *inc = m_builder.CreateExtractValue (rng, 2);
 
-      llvm::Value *ret = builder.CreateFMul (didx, inc);
-      ret = builder.CreateFAdd (base, ret);
-      fn.do_return (builder, ret);
+      llvm::Value *ret = m_builder.CreateFMul (didx, inc);
+      ret = m_builder.CreateFAdd (base, ret);
+      fn.do_return (m_builder, ret);
     }
-    for_index_fn.add_overload (fn);
+    m_for_index_fn.add_overload (fn);
 
     // logically true
     jit_function gripe_nantl
       = create_external (JIT_FN (octave_jit_err_nan_to_logical_conversion), nullptr);
     gripe_nantl.mark_can_error ();
-    fn = create_internal ("octave_jit_logically_true_scalar", boolean, scalar);
+    fn = create_internal ("octave_jit_logically_true_scalar", m_boolean, m_scalar);
     fn.mark_can_error ();
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
       llvm::BasicBlock *error_block = fn.new_block ("error");
       llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
-      llvm::Value *check = builder.CreateFCmpUNE (fn.argument (builder, 0),
-                                                  fn.argument (builder, 0));
-      builder.CreateCondBr (check, error_block, normal_block);
+      llvm::Value *check = m_builder.CreateFCmpUNE (fn.argument (m_builder, 0),
+                                                    fn.argument (m_builder, 0));
+      m_builder.CreateCondBr (check, error_block, normal_block);
 
-      builder.SetInsertPoint (error_block);
-      gripe_nantl.call (builder);
-      builder.CreateBr (normal_block);
-      builder.SetInsertPoint (normal_block);
+      m_builder.SetInsertPoint (error_block);
+      gripe_nantl.call (m_builder);
+      m_builder.CreateBr (normal_block);
+      m_builder.SetInsertPoint (normal_block);
 
-      llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
-      llvm::Value *ret = builder.CreateFCmpONE (fn.argument (builder, 0), zero);
-      fn.do_return (builder, ret);
+      llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
+      llvm::Value *ret = m_builder.CreateFCmpONE (fn.argument (m_builder, 0), zero);
+      fn.do_return (m_builder, ret);
     }
-    logically_true_fn.add_overload (fn);
+    m_logically_true_fn.add_overload (fn);
 
     // logically_true boolean
-    fn = create_identity (boolean);
-    logically_true_fn.add_overload (fn);
+    fn = create_identity (m_boolean);
+    m_logically_true_fn.add_overload (fn);
 
     // make_range
     // FIXME: May be benificial to implement all in LLVM
     jit_function compute_nelem
       = create_external (JIT_FN (octave_jit_compute_nelem),
-                         index, scalar, scalar, scalar);
-    fn = create_internal ("octave_jit_make_range", range, scalar, scalar, scalar);
+                         m_index, m_scalar, m_scalar, m_scalar);
+    fn = create_internal ("octave_jit_make_range", m_range, m_scalar, m_scalar, m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *base = fn.argument (builder, 0);
-      llvm::Value *limit = fn.argument (builder, 1);
-      llvm::Value *inc = fn.argument (builder, 2);
-      llvm::Value *nelem = compute_nelem.call (builder, base, limit, inc);
+      llvm::Value *base = fn.argument (m_builder, 0);
+      llvm::Value *limit = fn.argument (m_builder, 1);
+      llvm::Value *inc = fn.argument (m_builder, 2);
+      llvm::Value *nelem = compute_nelem.call (m_builder, base, limit, inc);
 
-      llvm::Value *dzero = llvm::ConstantFP::get (scalar_t, 0);
-      llvm::Value *izero = llvm::ConstantInt::get (index_t, 0);
-      llvm::Value *rng = llvm::ConstantStruct::get (range_t, dzero, dzero, dzero,
+      llvm::Value *dzero = llvm::ConstantFP::get (m_scalar_t, 0);
+      llvm::Value *izero = llvm::ConstantInt::get (m_index_t, 0);
+      llvm::Value *rng = llvm::ConstantStruct::get (m_range_t, dzero, dzero, dzero,
                                                     izero, NULL);
-      rng = builder.CreateInsertValue (rng, base, 0);
-      rng = builder.CreateInsertValue (rng, limit, 1);
-      rng = builder.CreateInsertValue (rng, inc, 2);
-      rng = builder.CreateInsertValue (rng, nelem, 3);
-      fn.do_return (builder, rng);
+      rng = m_builder.CreateInsertValue (rng, base, 0);
+      rng = m_builder.CreateInsertValue (rng, limit, 1);
+      rng = m_builder.CreateInsertValue (rng, inc, 2);
+      rng = m_builder.CreateInsertValue (rng, nelem, 3);
+      fn.do_return (m_builder, rng);
     }
-    make_range_fn.add_overload (fn);
+    m_make_range_fn.add_overload (fn);
 
     // paren_subsref
     jit_type *jit_int = do_get_intN (sizeof (int) * 8);
     llvm::Type *int_t = jit_int->to_llvm ();
     jit_function ginvalid_index
       = create_external (JIT_FN (octave_jit_ginvalid_index), nullptr);
     jit_function gindex_range = create_external (JIT_FN (octave_jit_gindex_range),
-                                                 nullptr, jit_int, jit_int, index,
-                                                 index);
+                                                 nullptr, jit_int, jit_int, m_index,
+                                                 m_index);
 
-    fn = create_internal ("()subsref", scalar, matrix, scalar);
+    fn = create_internal ("()subsref", m_scalar, m_matrix, m_scalar);
     fn.mark_can_error ();
 
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *one_idx = llvm::ConstantInt::get (index_t, 1);
+      llvm::Value *one_idx = llvm::ConstantInt::get (m_index_t, 1);
       llvm::Value *one_int = llvm::ConstantInt::get (int_t, 1);
 
-      llvm::Value *undef = llvm::UndefValue::get (scalar_t);
-      llvm::Value *mat = fn.argument (builder, 0);
-      llvm::Value *idx = fn.argument (builder, 1);
+      llvm::Value *undef = llvm::UndefValue::get (m_scalar_t);
+      llvm::Value *mat = fn.argument (m_builder, 0);
+      llvm::Value *idx = fn.argument (m_builder, 1);
 
       // convert index to scalar to integer, and check index >= 1
-      llvm::Value *int_idx = builder.CreateFPToSI (idx, index_t);
-      llvm::Value *check_idx = builder.CreateSIToFP (int_idx, scalar_t);
-      llvm::Value *cond0 = builder.CreateFCmpUNE (idx, check_idx);
-      llvm::Value *cond1 = builder.CreateICmpSLT (int_idx, one_idx);
-      llvm::Value *cond = builder.CreateOr (cond0, cond1);
+      llvm::Value *int_idx = m_builder.CreateFPToSI (idx, m_index_t);
+      llvm::Value *check_idx = m_builder.CreateSIToFP (int_idx, m_scalar_t);
+      llvm::Value *cond0 = m_builder.CreateFCmpUNE (idx, check_idx);
+      llvm::Value *cond1 = m_builder.CreateICmpSLT (int_idx, one_idx);
+      llvm::Value *cond = m_builder.CreateOr (cond0, cond1);
 
       llvm::BasicBlock *done = fn.new_block ("done");
       llvm::BasicBlock *conv_error = fn.new_block ("conv_error", done);
       llvm::BasicBlock *normal = fn.new_block ("normal", done);
-      builder.CreateCondBr (cond, conv_error, normal);
+      m_builder.CreateCondBr (cond, conv_error, normal);
 
-      builder.SetInsertPoint (conv_error);
-      ginvalid_index.call (builder);
-      builder.CreateBr (done);
+      m_builder.SetInsertPoint (conv_error);
+      ginvalid_index.call (m_builder);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (normal);
+      m_builder.SetInsertPoint (normal);
       llvm::Value *len
-        = builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (2));
-      cond = builder.CreateICmpSGT (int_idx, len);
+        = m_builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (2));
+      cond = m_builder.CreateICmpSGT (int_idx, len);
 
       llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
       llvm::BasicBlock *success = fn.new_block ("success", done);
-      builder.CreateCondBr (cond, bounds_error, success);
+      m_builder.CreateCondBr (cond, bounds_error, success);
 
-      builder.SetInsertPoint (bounds_error);
-      gindex_range.call (builder, one_int, one_int, int_idx, len);
-      builder.CreateBr (done);
+      m_builder.SetInsertPoint (bounds_error);
+      gindex_range.call (m_builder, one_int, one_int, int_idx, len);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (success);
-      llvm::Value *data = builder.CreateExtractValue (mat,
-                                                      llvm::ArrayRef<unsigned> (1));
-      llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
-      llvm::Value *ret = builder.CreateLoad (gep);
-      builder.CreateBr (done);
+      m_builder.SetInsertPoint (success);
+      llvm::Value *data = m_builder.CreateExtractValue (mat,
+                                                        llvm::ArrayRef<unsigned> (1));
+      llvm::Value *gep = m_builder.CreateInBoundsGEP (data, int_idx);
+      llvm::Value *ret = m_builder.CreateLoad (gep);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (done);
+      m_builder.SetInsertPoint (done);
 
-      llvm::PHINode *merge = llvm::PHINode::Create (scalar_t, 3);
-      builder.Insert (merge);
+      llvm::PHINode *merge = llvm::PHINode::Create (m_scalar_t, 3);
+      m_builder.Insert (merge);
       merge->addIncoming (undef, conv_error);
       merge->addIncoming (undef, bounds_error);
       merge->addIncoming (ret, success);
-      fn.do_return (builder, merge);
+      fn.do_return (m_builder, merge);
     }
     paren_subsref_fn.add_overload (fn);
 
     // paren subsasgn
     jit_function resize_paren_subsasgn
-      = create_external (JIT_FN (octave_jit_paren_subsasgn_impl), matrix, matrix,
-                         index, scalar);
-    fn = create_internal ("octave_jit_paren_subsasgn", matrix, matrix, scalar,
-                          scalar);
+      = create_external (JIT_FN (octave_jit_paren_subsasgn_impl), m_matrix, m_matrix,
+                         m_index, m_scalar);
+    fn = create_internal ("octave_jit_paren_subsasgn", m_matrix, m_matrix, m_scalar,
+                          m_scalar);
     fn.mark_can_error ();
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *one_idx = llvm::ConstantInt::get (index_t, 1);
+      llvm::Value *one_idx = llvm::ConstantInt::get (m_index_t, 1);
       llvm::Value *one_int = llvm::ConstantInt::get (int_t, 1);
 
-      llvm::Value *mat = fn.argument (builder, 0);
-      llvm::Value *idx = fn.argument (builder, 1);
-      llvm::Value *value = fn.argument (builder, 2);
+      llvm::Value *mat = fn.argument (m_builder, 0);
+      llvm::Value *idx = fn.argument (m_builder, 1);
+      llvm::Value *value = fn.argument (m_builder, 2);
 
-      llvm::Value *int_idx = builder.CreateFPToSI (idx, index_t);
-      llvm::Value *check_idx = builder.CreateSIToFP (int_idx, scalar_t);
-      llvm::Value *cond0 = builder.CreateFCmpUNE (idx, check_idx);
-      llvm::Value *cond1 = builder.CreateICmpSLT (int_idx, one_idx);
-      llvm::Value *cond = builder.CreateOr (cond0, cond1);
+      llvm::Value *int_idx = m_builder.CreateFPToSI (idx, m_index_t);
+      llvm::Value *check_idx = m_builder.CreateSIToFP (int_idx, m_scalar_t);
+      llvm::Value *cond0 = m_builder.CreateFCmpUNE (idx, check_idx);
+      llvm::Value *cond1 = m_builder.CreateICmpSLT (int_idx, one_idx);
+      llvm::Value *cond = m_builder.CreateOr (cond0, cond1);
 
       llvm::BasicBlock *done = fn.new_block ("done");
 
       llvm::BasicBlock *conv_error = fn.new_block ("conv_error", done);
       llvm::BasicBlock *normal = fn.new_block ("normal", done);
-      builder.CreateCondBr (cond, conv_error, normal);
-      builder.SetInsertPoint (conv_error);
-      ginvalid_index.call (builder);
-      builder.CreateBr (done);
+      m_builder.CreateCondBr (cond, conv_error, normal);
+      m_builder.SetInsertPoint (conv_error);
+      ginvalid_index.call (m_builder);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (normal);
-      llvm::Value *len = builder.CreateExtractValue (mat, 2);
-      cond0 = builder.CreateICmpSGT (int_idx, len);
+      m_builder.SetInsertPoint (normal);
+      llvm::Value *len = m_builder.CreateExtractValue (mat, 2);
+      cond0 = m_builder.CreateICmpSGT (int_idx, len);
 
-      llvm::Value *rcount = builder.CreateExtractValue (mat, 0);
-      rcount = builder.CreateLoad (rcount);
-      cond1 = builder.CreateICmpSGT (rcount, one_int);
-      cond = builder.CreateOr (cond0, cond1);
+      llvm::Value *rcount = m_builder.CreateExtractValue (mat, 0);
+      rcount = m_builder.CreateLoad (rcount);
+      cond1 = m_builder.CreateICmpSGT (rcount, one_int);
+      cond = m_builder.CreateOr (cond0, cond1);
 
       llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
       llvm::BasicBlock *success = fn.new_block ("success", done);
-      builder.CreateCondBr (cond, bounds_error, success);
+      m_builder.CreateCondBr (cond, bounds_error, success);
 
       // resize on out of bounds access
-      builder.SetInsertPoint (bounds_error);
-      llvm::Value *resize_result = resize_paren_subsasgn.call (builder, mat,
+      m_builder.SetInsertPoint (bounds_error);
+      llvm::Value *resize_result = resize_paren_subsasgn.call (m_builder, mat,
                                                                int_idx, value);
-      builder.CreateBr (done);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (success);
+      m_builder.SetInsertPoint (success);
       llvm::Value *data
-        = builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (1));
-      llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
-      builder.CreateStore (value, gep);
-      builder.CreateBr (done);
+        = m_builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (1));
+      llvm::Value *gep = m_builder.CreateInBoundsGEP (data, int_idx);
+      m_builder.CreateStore (value, gep);
+      m_builder.CreateBr (done);
 
-      builder.SetInsertPoint (done);
+      m_builder.SetInsertPoint (done);
 
-      llvm::PHINode *merge = llvm::PHINode::Create (matrix_t, 3);
-      builder.Insert (merge);
+      llvm::PHINode *merge = llvm::PHINode::Create (m_matrix_t, 3);
+      m_builder.Insert (merge);
       merge->addIncoming (mat, conv_error);
       merge->addIncoming (resize_result, bounds_error);
       merge->addIncoming (mat, success);
-      fn.do_return (builder, merge);
+      fn.do_return (m_builder, merge);
     }
     paren_subsasgn_fn.add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_paren_subsasgn_matrix_range), matrix,
-                          matrix, range, scalar);
+    fn = create_external (JIT_FN (octave_jit_paren_subsasgn_matrix_range), m_matrix,
+                          m_matrix, m_range, m_scalar);
     fn.mark_can_error ();
     paren_subsasgn_fn.add_overload (fn);
 
-    fn = create_internal ("octave_jit_end1_matrix", scalar, matrix, index, index);
+    fn = create_internal ("octave_jit_end1_matrix", m_scalar, m_matrix, m_index, m_index);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *mat = fn.argument (builder, 0);
-      llvm::Value *ret = builder.CreateExtractValue (mat, 2);
-      fn.do_return (builder, builder.CreateSIToFP (ret, scalar_t));
+      llvm::Value *mat = fn.argument (m_builder, 0);
+      llvm::Value *ret = m_builder.CreateExtractValue (mat, 2);
+      fn.do_return (m_builder, m_builder.CreateSIToFP (ret, m_scalar_t));
     }
-    end1_fn.add_overload (fn);
+    m_end1_fn.add_overload (fn);
 
-    fn = create_external (JIT_FN (octave_jit_end_matrix),scalar, matrix, index,
-                          index);
-    end_fn.add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_end_matrix),m_scalar, m_matrix, m_index,
+                          m_index);
+    m_end_fn.add_overload (fn);
 
     // -------------------- create_undef --------------------
-    fn = create_external (JIT_FN (octave_jit_create_undef), any);
-    create_undef_fn.add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_create_undef), m_any);
+    m_create_undef_fn.add_overload (fn);
 
-    casts[any->type_id ()].stash_name ("(any)");
-    casts[scalar->type_id ()].stash_name ("(scalar)");
-    casts[complex->type_id ()].stash_name ("(complex)");
-    casts[matrix->type_id ()].stash_name ("(matrix)");
-    casts[range->type_id ()].stash_name ("(range)");
+    m_casts[m_any->type_id ()].stash_name ("(any)");
+    m_casts[m_scalar->type_id ()].stash_name ("(scalar)");
+    m_casts[m_complex->type_id ()].stash_name ("(complex)");
+    m_casts[m_matrix->type_id ()].stash_name ("(matrix)");
+    m_casts[m_range->type_id ()].stash_name ("(range)");
 
-    // cast any <- matrix
-    fn = create_external (JIT_FN (octave_jit_cast_any_matrix), any, matrix);
-    casts[any->type_id ()].add_overload (fn);
+    // cast m_any <- matrix
+    fn = create_external (JIT_FN (octave_jit_cast_any_matrix), m_any, m_matrix);
+    m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast matrix <- any
-    fn = create_external (JIT_FN (octave_jit_cast_matrix_any), matrix, any);
-    casts[matrix->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_matrix_any), m_matrix, m_any);
+    m_casts[m_matrix->type_id ()].add_overload (fn);
 
     // cast any <- range
-    fn = create_external (JIT_FN (octave_jit_cast_any_range), any, range);
-    casts[any->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_any_range), m_any, m_range);
+    m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast range <- any
-    fn = create_external (JIT_FN (octave_jit_cast_range_any), range, any);
-    casts[range->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_range_any), m_range, m_any);
+    m_casts[m_range->type_id ()].add_overload (fn);
 
     // cast any <- scalar
-    fn = create_external (JIT_FN (octave_jit_cast_any_scalar), any, scalar);
-    casts[any->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_any_scalar), m_any, m_scalar);
+    m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast scalar <- any
-    fn = create_external (JIT_FN (octave_jit_cast_scalar_any), scalar, any);
-    casts[scalar->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_scalar_any), m_scalar, m_any);
+    m_casts[m_scalar->type_id ()].add_overload (fn);
 
     // cast any <- complex
-    fn = create_external (JIT_FN (octave_jit_cast_any_complex), any, complex);
-    casts[any->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_any_complex), m_any, m_complex);
+    m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast complex <- any
-    fn = create_external (JIT_FN (octave_jit_cast_complex_any), complex, any);
-    casts[complex->type_id ()].add_overload (fn);
+    fn = create_external (JIT_FN (octave_jit_cast_complex_any), m_complex, m_any);
+    m_casts[m_complex->type_id ()].add_overload (fn);
 
     // cast complex <- scalar
-    fn = create_internal ("octave_jit_cast_complex_scalar", complex, scalar);
+    fn = create_internal ("octave_jit_cast_complex_scalar", m_complex, m_scalar);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
     {
-      llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
-      fn.do_return (builder, complex_new (fn.argument (builder, 0), zero));
+      llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
+      fn.do_return (m_builder, complex_new (fn.argument (m_builder, 0), zero));
     }
-    casts[complex->type_id ()].add_overload (fn);
+    m_casts[m_complex->type_id ()].add_overload (fn);
 
     // cast scalar <- complex
-    fn = create_internal ("octave_jit_cast_scalar_complex", scalar, complex);
+    fn = create_internal ("octave_jit_cast_scalar_complex", m_scalar, m_complex);
     body = fn.new_block ();
-    builder.SetInsertPoint (body);
-    fn.do_return (builder, complex_real (fn.argument (builder, 0)));
-    casts[scalar->type_id ()].add_overload (fn);
+    m_builder.SetInsertPoint (body);
+    fn.do_return (m_builder, complex_real (fn.argument (m_builder, 0)));
+    m_casts[m_scalar->type_id ()].add_overload (fn);
 
     // cast any <- any
-    fn = create_identity (any);
-    casts[any->type_id ()].add_overload (fn);
+    fn = create_identity (m_any);
+    m_casts[m_any->type_id ()].add_overload (fn);
 
     // cast scalar <- scalar
-    fn = create_identity (scalar);
-    casts[scalar->type_id ()].add_overload (fn);
+    fn = create_identity (m_scalar);
+    m_casts[m_scalar->type_id ()].add_overload (fn);
 
     // cast complex <- complex
-    fn = create_identity (complex);
-    casts[complex->type_id ()].add_overload (fn);
+    fn = create_identity (m_complex);
+    m_casts[m_complex->type_id ()].add_overload (fn);
 
     // -------------------- builtin functions --------------------
     add_builtin ("#unknown_function");
-    unknown_function = builtins["#unknown_function"];
+    m_unknown_function = m_builtins["#unknown_function"];
 
     add_builtin ("sin");
-    register_intrinsic ("sin", llvm::Intrinsic::sin, scalar, scalar);
-    register_generic ("sin", matrix, matrix);
+    register_intrinsic ("sin", llvm::Intrinsic::sin, m_scalar, m_scalar);
+    register_generic ("sin", m_matrix, m_matrix);
 
     add_builtin ("cos");
-    register_intrinsic ("cos", llvm::Intrinsic::cos, scalar, scalar);
-    register_generic ("cos", matrix, matrix);
+    register_intrinsic ("cos", llvm::Intrinsic::cos, m_scalar, m_scalar);
+    register_generic ("cos", m_matrix, m_matrix);
 
     add_builtin ("exp");
-    register_intrinsic ("exp", llvm::Intrinsic::exp, scalar, scalar);
-    register_generic ("exp", matrix, matrix);
+    register_intrinsic ("exp", llvm::Intrinsic::exp, m_scalar, m_scalar);
+    register_generic ("exp", m_matrix, m_matrix);
 
     add_builtin ("balance");
-    register_generic ("balance", matrix, matrix);
+    register_generic ("balance", m_matrix, m_matrix);
 
     add_builtin ("cond");
-    register_generic ("cond", scalar, matrix);
+    register_generic ("cond", m_scalar, m_matrix);
 
     add_builtin ("det");
-    register_generic ("det", scalar, matrix);
+    register_generic ("det", m_scalar, m_matrix);
 
     add_builtin ("norm");
-    register_generic ("norm", scalar, matrix);
+    register_generic ("norm", m_scalar, m_matrix);
 
     add_builtin ("rand");
-    register_generic ("rand", matrix, scalar);
-    register_generic ("rand", matrix, std::vector<jit_type *> (2, scalar));
+    register_generic ("rand", m_matrix, m_scalar);
+    register_generic ("rand", m_matrix, std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("magic");
-    register_generic ("magic", matrix, scalar);
-    register_generic ("magic", matrix, std::vector<jit_type *> (2, scalar));
+    register_generic ("magic", m_matrix, m_scalar);
+    register_generic ("magic", m_matrix, std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("eye");
-    register_generic ("eye", matrix, scalar);
-    register_generic ("eye", matrix, std::vector<jit_type *> (2, scalar));
+    register_generic ("eye", m_matrix, m_scalar);
+    register_generic ("eye", m_matrix, std::vector<jit_type *> (2, m_scalar));
 
     add_builtin ("mod");
-    register_generic ("mod", scalar, std::vector<jit_type *> (2, scalar));
+    register_generic ("mod", m_scalar, std::vector<jit_type *> (2, m_scalar));
 
-    // casts.resize (next_id + 1);
-    jit_function any_id = create_identity (any);
+    // m_casts.resize (m_next_id + 1);
+    jit_function any_id = create_identity (m_any);
     jit_function grab_any = create_external (JIT_FN (octave_jit_grab_any),
-                                             any, any);
+                                             m_any, m_any);
 
-    jit_function release_any = release_fn.overload (any);
+    jit_function release_any = m_release_fn.overload (m_any);
 
     std::vector<jit_type *> args;
     args.resize (1);
 
-    for (std::map<std::string, jit_type *>::iterator iter = builtins.begin ();
-         iter != builtins.end (); ++iter)
+    for (std::map<std::string, jit_type *>::iterator iter = m_builtins.begin ();
+         iter != m_builtins.end (); ++iter)
       {
         jit_type *btype = iter->second;
         args[0] = btype;
 
-        grab_fn.add_overload (jit_function (grab_any, btype, args));
-        release_fn.add_overload (jit_function (release_any, 0, args));
-        casts[any->type_id ()].add_overload (jit_function (any_id, any, args));
+        m_grab_fn.add_overload (jit_function (grab_any, btype, args));
+        m_release_fn.add_overload (jit_function (release_any, 0, args));
+        m_casts[m_any->type_id ()].add_overload (jit_function (any_id, m_any, args));
 
-        args[0] = any;
-        casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
-                                                             args));
+        args[0] = m_any;
+        m_casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
+                                                               args));
       }
 
-    base_jit_module->finalizeObject ();
+    m_base_jit_module->finalizeObject ();
 
-    in_construction = false;
+    s_in_construction = false;
   }
 
   // create a function with an external calling convention
   // forces the function pointer to be specified
   template <typename fn_ptr_type> jit_function
   jit_typeinfo::create_external (fn_ptr_type fn,
                                  const llvm::Twine& name,
                                  jit_type *ret,
                                  const std::vector<jit_type *>& args) const
   {
-    jit_function retval (base_jit_module, jit_convention::external,
+    jit_function retval (m_base_jit_module, jit_convention::external,
                          name, ret, args);
 
-    base_jit_module->add_global_mapping (retval.to_llvm (), fn);
+    m_base_jit_module->add_global_mapping (retval.to_llvm (), fn);
 
     return retval;
   }
 
   jit_type*
   jit_typeinfo::do_register_new_type (const std::string& name,
                                       jit_type *parent,
                                       llvm::Type *llvm_type,
                                       bool skip_paren)
   {
     // FIXME: Currently our types do *not* form a lattice
     assert ((name == "any") || (name == "any_ptr") ||
             (name == "scalar_ptr") || (parent != nullptr));
 
-    jit_type *ret = new jit_type (name, parent, llvm_type, skip_paren, next_id++);
-    id_to_type.push_back (ret);
+    jit_type *ret = new jit_type (name, parent, llvm_type, skip_paren, m_next_id++);
+    m_id_to_type.push_back (ret);
 
-    casts.push_back (jit_operation ("(" + name + ")"));
-    identities.push_back (jit_function ());
+    m_casts.push_back (jit_operation ("(" + name + ")"));
+    m_identities.push_back (jit_function ());
 
     return ret;
   }
 
   jit_type*
   jit_typeinfo::do_get_intN (size_t nbits) const
   {
-    std::map<size_t, jit_type *>::const_iterator iter = ints.find (nbits);
-    if (iter != ints.end ())
+    std::map<size_t, jit_type *>::const_iterator iter = m_ints.find (nbits);
+    if (iter != m_ints.end ())
       return iter->second;
 
     throw jit_fail_exception ("No such integer type");
   }
 
   const jit_function&
   jit_typeinfo::do_end (jit_value *value, jit_value *idx, jit_value *count)
   {
     jit_const_index *ccount = dynamic_cast<jit_const_index *> (count);
     if (ccount && ccount->value () == 1)
-      return end1_fn.overload (value->type (), idx->type (), count->type ());
+      return m_end1_fn.overload (value->type (), idx->type (), count->type ());
 
-    return end_fn.overload (value->type (), idx->type (), count->type ());
+    return m_end_fn.overload (value->type (), idx->type (), count->type ());
   }
 
   void
   jit_typeinfo::add_print (jit_type *ty, void *fptr)
   {
     std::stringstream name;
     name << "octave_jit_print_" << ty->name ();
 
     jit_function fn = create_external (fptr, name.str (), nullptr,
                                        do_get_intN (8), ty);
 
-    print_fn.add_overload (fn);
+    m_print_fn.add_overload (fn);
   }
 
   // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
   void
   jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
   {
     std::stringstream fname;
     octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
     fname << "octave_jit_" << octave_value::binary_op_as_string (ov_op)
           << '_' << ty->name ();
 
     jit_function fn = create_internal (fname.str (), ty, ty, ty);
     llvm::BasicBlock *block = fn.new_block ();
-    builder.SetInsertPoint (block);
+    m_builder.SetInsertPoint (block);
     llvm::Instruction::BinaryOps temp
       = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
 
-    llvm::Value *ret = builder.CreateBinOp (temp, fn.argument (builder, 0),
-                                            fn.argument (builder, 1));
-    fn.do_return (builder, ret);
-    binary_ops[op].add_overload (fn);
+    llvm::Value *ret = m_builder.CreateBinOp (temp, fn.argument (m_builder, 0),
+                                              fn.argument (m_builder, 1));
+    fn.do_return (m_builder, ret);
+    m_binary_ops[op].add_overload (fn);
   }
 
   void
   jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
   {
     std::stringstream fname;
     octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
     fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
           << '_' << ty->name ();
 
-    jit_function fn = create_internal (fname.str (), boolean, ty, ty);
+    jit_function fn = create_internal (fname.str (), m_boolean, ty, ty);
     llvm::BasicBlock *block = fn.new_block ();
-    builder.SetInsertPoint (block);
+    m_builder.SetInsertPoint (block);
     llvm::CmpInst::Predicate temp
       = static_cast<llvm::CmpInst::Predicate>(llvm_op);
-    llvm::Value *ret = builder.CreateICmp (temp, fn.argument (builder, 0),
-                                           fn.argument (builder, 1));
-    fn.do_return (builder, ret);
-    binary_ops[op].add_overload (fn);
+    llvm::Value *ret = m_builder.CreateICmp (temp, fn.argument (m_builder, 0),
+                                             fn.argument (m_builder, 1));
+    fn.do_return (m_builder, ret);
+    m_binary_ops[op].add_overload (fn);
   }
 
   void
   jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
   {
     std::stringstream fname;
     octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
     fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
           << '_' << ty->name ();
 
-    jit_function fn = create_internal (fname.str (), boolean, ty, ty);
+    jit_function fn = create_internal (fname.str (), m_boolean, ty, ty);
     llvm::BasicBlock *block = fn.new_block ();
-    builder.SetInsertPoint (block);
+    m_builder.SetInsertPoint (block);
     llvm::CmpInst::Predicate temp
       = static_cast<llvm::CmpInst::Predicate>(llvm_op);
-    llvm::Value *ret = builder.CreateFCmp (temp, fn.argument (builder, 0),
-                                           fn.argument (builder, 1));
-    fn.do_return (builder, ret);
-    binary_ops[op].add_overload (fn);
+    llvm::Value *ret = m_builder.CreateFCmp (temp, fn.argument (m_builder, 0),
+                                             fn.argument (m_builder, 1));
+    fn.do_return (m_builder, ret);
+    m_binary_ops[op].add_overload (fn);
   }
 
   jit_function
   jit_typeinfo::create_identity (jit_type *type)
   {
     size_t id = type->type_id ();
-    if (id >= identities.size ())
-      identities.resize (id + 1);
+    if (id >= m_identities.size ())
+      m_identities.resize (id + 1);
 
-    if (! identities[id].valid ())
+    if (! m_identities[id].valid ())
       {
         std::stringstream name;
         name << "id_" << type->name ();
 
         jit_function fn = create_internal (name.str (), type, type);
         llvm::BasicBlock *body = fn.new_block ();
-        builder.SetInsertPoint (body);
-        fn.do_return (builder, fn.argument (builder, 0));
-        return identities[id] = fn;
+        m_builder.SetInsertPoint (body);
+        fn.do_return (m_builder, fn.argument (m_builder, 0));
+        return m_identities[id] = fn;
       }
 
-    return identities[id];
+    return m_identities[id];
   }
 
   llvm::Value *
   jit_typeinfo::do_insert_error_check (llvm::IRBuilderD& abuilder)
   {
-    return abuilder.CreateLoad (lerror_state);
+    return abuilder.CreateLoad (m_lerror_state);
   }
 
   llvm::Value *
   jit_typeinfo::do_insert_interrupt_check (llvm::IRBuilderD& abuilder)
   {
-    llvm::LoadInst *val = abuilder.CreateLoad (loctave_interrupt_state);
+    llvm::LoadInst *val = abuilder.CreateLoad (m_loctave_interrupt_state);
     val->setVolatile (true);
     return abuilder.CreateICmpSGT (val, abuilder.getInt32 (0));
   }
 
   void
   jit_typeinfo::add_builtin (const std::string& name)
   {
-    jit_type *btype = do_register_new_type (name, any, any_t, true);
-    builtins[name] = btype;
+    jit_type *btype = do_register_new_type (name, m_any, m_any_t, true);
+    m_builtins[name] = btype;
 
     octave_builtin *ov_builtin = find_builtin (name);
     if (ov_builtin)
       ov_builtin->stash_jit (*btype);
   }
 
   void
   jit_typeinfo::register_intrinsic (const std::string& name, size_t iid,
                                     jit_type *result,
                                     const std::vector<jit_type *>& args)
   {
-    jit_type *builtin_type = builtins[name];
+    jit_type *builtin_type = m_builtins[name];
     size_t nargs = args.size ();
     std::vector<llvm::Type*> llvm_args (nargs);
     for (size_t i = 0; i < nargs; ++i)
       llvm_args[i] = args[i]->to_llvm ();
 
-    llvm::Function *ifun = base_jit_module->
+    llvm::Function *ifun = m_base_jit_module->
       get_intrinsic_declaration (iid, llvm_args);
 
     std::stringstream fn_name;
     fn_name << "octave_jit_" << name;
 
     std::vector<jit_type *> args1 (nargs + 1);
     args1[0] = builtin_type;
     std::copy (args.begin (), args.end (), args1.begin () + 1);
 
     // The first argument will be the Octave function, but we already know that
     // the function call is the equivalent of the intrinsic, so we ignore it and
     // call the intrinsic with the remaining arguments.
     jit_function fn = create_internal (fn_name.str (), result, args1);
     llvm::BasicBlock *body = fn.new_block ();
-    builder.SetInsertPoint (body);
+    m_builder.SetInsertPoint (body);
 
     llvm::SmallVector<llvm::Value *, 5> fargs (nargs);
     for (size_t i = 0; i < nargs; ++i)
-      fargs[i] = fn.argument (builder, i + 1);
+      fargs[i] = fn.argument (m_builder, i + 1);
 
-    llvm::Value *ret = builder.CreateCall (ifun, fargs);
-    fn.do_return (builder, ret);
+    llvm::Value *ret = m_builder.CreateCall (ifun, fargs);
+    fn.do_return (m_builder, ret);
     paren_subsref_fn.add_overload (fn);
   }
 
   octave_builtin *
   jit_typeinfo::find_builtin (const std::string& name)
   {
     symbol_table& symtab = __get_symbol_table__ ("jit_typeinfo::find_builtin");
 
@@ -2189,166 +2189,165 @@ namespace octave
   jit_typeinfo::register_generic (const std::string& name, jit_type *result,
                                   const std::vector<jit_type *>& args)
   {
     octave_builtin *builtin = find_builtin (name);
     if (! builtin)
       return;
 
     std::vector<jit_type *> fn_args (args.size () + 1);
-    fn_args[0] = builtins[name];
+    fn_args[0] = m_builtins[name];
     std::copy (args.begin (), args.end (), fn_args.begin () + 1);
     jit_function fn = create_internal (name, result, fn_args);
     fn.mark_can_error ();
     llvm::BasicBlock *block = fn.new_block ();
-    builder.SetInsertPoint (block);
-    llvm::ArrayType *array_t = llvm::ArrayType::get (any_t, args.size ());
+    m_builder.SetInsertPoint (block);
+    llvm::ArrayType *array_t = llvm::ArrayType::get (m_any_t, args.size ());
     llvm::Value *array = llvm::UndefValue::get (array_t);
     for (size_t i = 0; i < args.size (); ++i)
       {
-        llvm::Value *arg = fn.argument (builder, i + 1);
-        jit_function agrab = grab_fn.overload (args[i]);
+        llvm::Value *arg = fn.argument (m_builder, i + 1);
+        jit_function agrab = m_grab_fn.overload (args[i]);
         if (agrab.valid ())
-          arg = agrab.call (builder, arg);
-        jit_function acast = do_cast (any, args[i]);
-        array = builder.CreateInsertValue (array, acast.call (builder, arg), i);
+          arg = agrab.call (m_builder, arg);
+        jit_function acast = do_cast (m_any, args[i]);
+        array = m_builder.CreateInsertValue (array, acast.call (m_builder, arg), i);
       }
 
-    llvm::Value *array_mem = builder.CreateAlloca (array_t);
-    builder.CreateStore (array, array_mem);
-    array = builder.CreateBitCast (array_mem, any_t->getPointerTo ());
+    llvm::Value *array_mem = m_builder.CreateAlloca (array_t);
+    m_builder.CreateStore (array, array_mem);
+    array = m_builder.CreateBitCast (array_mem, m_any_t->getPointerTo ());
 
     jit_type *jintTy = do_get_intN (sizeof (octave_builtin::fcn) * 8);
     llvm::Type *intTy = jintTy->to_llvm ();
     size_t fcn_int = reinterpret_cast<size_t> (builtin->function ());
     llvm::Value *fcn = llvm::ConstantInt::get (intTy, fcn_int);
     llvm::Value *nargin = llvm::ConstantInt::get (intTy, args.size ());
     size_t result_int = reinterpret_cast<size_t> (result);
     llvm::Value *res_llvm = llvm::ConstantInt::get (intTy, result_int);
-    llvm::Value *ret = any_call.call (builder, fcn, nargin, array, res_llvm);
+    llvm::Value *ret = m_any_call.call (m_builder, fcn, nargin, array, res_llvm);
 
-    jit_function cast_result = do_cast (result, any);
-    fn.do_return (builder, cast_result.call (builder, ret));
+    jit_function cast_result = do_cast (result, m_any);
+    fn.do_return (m_builder, cast_result.call (m_builder, ret));
     paren_subsref_fn.add_overload (fn);
   }
 
   jit_function
   jit_typeinfo::mirror_binary (const jit_function& fn)
   {
     jit_function ret = create_internal (fn.name () + "_reverse",
                                         fn.result (), fn.argument_type (1),
                                         fn.argument_type (0));
     if (fn.can_error ())
       ret.mark_can_error ();
 
     llvm::BasicBlock *body = ret.new_block ();
-    builder.SetInsertPoint (body);
-    llvm::Value *result = fn.call (builder, ret.argument (builder, 1),
-                                   ret.argument (builder, 0));
+    m_builder.SetInsertPoint (body);
+    llvm::Value *result = fn.call (m_builder, ret.argument (m_builder, 1),
+                                   ret.argument (m_builder, 0));
     if (ret.result ())
-      ret.do_return (builder, result);
+      ret.do_return (m_builder, result);
     else
-      ret.do_return (builder);
+      ret.do_return (m_builder);
 
     return ret;
   }
 
   llvm::Value *
   jit_typeinfo::do_pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx) const
   {
     llvm::Value *real = bld.CreateExtractValue (cplx, 0);
     llvm::Value *imag = bld.CreateExtractValue (cplx, 1);
-    llvm::Value *ret = llvm::UndefValue::get (complex_ret);
+    llvm::Value *ret = llvm::UndefValue::get (m_complex_ret);
 
     unsigned int re_idx[] = {0, 0};
     unsigned int im_idx[] = {0, 1};
     ret = bld.CreateInsertValue (ret, real, re_idx);
     return bld.CreateInsertValue (ret, imag, im_idx);
   }
 
   llvm::Value *
   jit_typeinfo::unpack_complex (llvm::IRBuilderD& bld, llvm::Value *result)
   {
     unsigned int re_idx[] = {0, 0};
     unsigned int im_idx[] = {0, 1};
 
-    llvm::Type *complex_t = get_complex ()->to_llvm ();
+    llvm::Type *m_complex_t = get_complex ()->to_llvm ();
     llvm::Value *real = bld.CreateExtractValue (result, re_idx);
     llvm::Value *imag = bld.CreateExtractValue (result, im_idx);
-    llvm::Value *ret = llvm::UndefValue::get (complex_t);
+    llvm::Value *ret = llvm::UndefValue::get (m_complex_t);
 
     ret = bld.CreateInsertValue (ret, real, 0);
     return bld.CreateInsertValue (ret, imag, 1);
   }
 
   llvm::Value *
   jit_typeinfo::complex_real (llvm::Value *cx)
   {
-    return builder.CreateExtractValue (cx, 0);
+    return m_builder.CreateExtractValue (cx, 0);
   }
 
   llvm::Value *
   jit_typeinfo::complex_real (llvm::Value *cx, llvm::Value *real)
   {
-    return builder.CreateInsertValue (cx, real, 0);
+    return m_builder.CreateInsertValue (cx, real, 0);
   }
 
   llvm::Value *
   jit_typeinfo::complex_imag (llvm::Value *cx)
   {
-    return builder.CreateExtractValue (cx, 1);
+    return m_builder.CreateExtractValue (cx, 1);
   }
 
   llvm::Value *
   jit_typeinfo::complex_imag (llvm::Value *cx, llvm::Value *imag)
   {
-    return builder.CreateInsertValue (cx, imag, 1);
+    return m_builder.CreateInsertValue (cx, imag, 1);
   }
 
   llvm::Value *
   jit_typeinfo::complex_new (llvm::Value *real, llvm::Value *imag)
   {
-    llvm::Value *ret = llvm::UndefValue::get (complex->to_llvm ());
+    llvm::Value *ret = llvm::UndefValue::get (m_complex->to_llvm ());
     ret = complex_real (ret, real);
     return complex_imag (ret, imag);
   }
 
   jit_type *
   jit_typeinfo::do_type_of (const octave_value& ov) const
   {
     if (ov.is_function ())
       {
         // FIXME: This is ugly, we need to finalize how we want to do this, then
         // have octave_value fully support the needed functionality
         octave_builtin *builtin
           = dynamic_cast<octave_builtin *> (ov.internal_rep ());
         return builtin && builtin->to_jit () ? builtin->to_jit ()
-          : unknown_function;
+          : m_unknown_function;
       }
 
     if (ov.is_range ())
-      return range;
+      return m_range;
 
     if (ov.is_double_type () && ! ov.iscomplex ())
       {
         if (ov.is_real_scalar ())
-          return scalar;
+          return m_scalar;
 
         if (ov.is_matrix_type ())
-          return matrix;
+          return m_matrix;
       }
 
     if (ov.is_complex_scalar ())
       {
         Complex cv = ov.complex_value ();
 
         // We don't really represent complex values, instead we represent
         // complex_or_scalar.  If the imag value is zero, we assume a scalar.
         if (cv.imag () != 0)
-          return complex;
+          return m_complex;
       }
 
-    return any;
+    return m_any;
   }
-
 }
 
 #endif
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -32,88 +32,88 @@ along with Octave; see the file COPYING.
 #include <map>
 #include <vector>
 
 #include "Range.h"
 #include "jit-util.h"
 
 namespace octave
 {
-
   class jit_typeinfo;
   class jit_module;
 
   // Defines the type system used by jit and a singleton class, jit_typeinfo, to
   // manage the types.
   //
   // FIXME:
   // Operations are defined and implemented in jit_typeinfo.  Eventually they
   // should be moved elsewhere. (just like with octave_typeinfo)
 
   // jit_range is compatible with the llvm range structure
   struct
   jit_range
   {
-    jit_range (const Range& from) : base (from.base ()), limit (from.limit ()),
-                                    inc (from.inc ()), nelem (from.numel ())
+    jit_range (const Range& from)
+      : m_base (from.base ()), m_limit (from.limit ()), m_inc (from.inc ()),
+        m_nelem (from.numel ())
     { }
 
     operator Range () const
     {
-      return Range (base, limit, inc);
+      return Range (m_base, m_limit, m_inc);
     }
 
-    bool all_elements_are_ints () const;
+    bool all_elements_are_ints (void) const;
 
-    double base;
-    double limit;
-    double inc;
-    octave_idx_type nelem;
+    double m_base;
+    double m_limit;
+    double m_inc;
+    octave_idx_type m_nelem;
   };
 
   std::ostream& operator << (std::ostream& os, const jit_range& rng);
 
   // jit_array is compatible with the llvm array/matrix structures
   template <typename T, typename U>
   struct
   jit_array
   {
-    jit_array () : array (0) { }
+    jit_array (void) : m_array (0) { }
 
-    jit_array (T& from) : array (new T (from))
+    jit_array (T& from) : m_array (new T (from))
     {
       update ();
     }
 
     void update (void)
     {
-      ref_count = array->jit_ref_count ();
-      slice_data = array->jit_slice_data () - 1;
-      slice_len = array->numel ();
-      dimensions = array->jit_dimensions ();
+      m_ref_count = m_array->jit_ref_count ();
+      m_slice_data = m_array->jit_slice_data () - 1;
+      m_slice_len = m_array->numel ();
+      m_dimensions = m_array->jit_dimensions ();
     }
 
     void update (T *aarray)
     {
-      array = aarray;
+      m_array = aarray;
       update ();
     }
 
     operator T () const
     {
-      return *array;
+      return *m_array;
     }
 
-    int *ref_count;
+    int *m_ref_count;
 
-    U *slice_data;
-    octave_idx_type slice_len;
-    octave_idx_type *dimensions;
+    U *m_slice_data;
+    octave_idx_type m_slice_len;
+    octave_idx_type *m_dimensions;
 
-    T *array;
+    T *m_array;
   };
 
   typedef jit_array<NDArray, double> jit_matrix;
 
   std::ostream& operator << (std::ostream& os, const jit_matrix& mat);
 
   // calling convention
   namespace jit_convention
@@ -135,93 +135,96 @@ namespace octave
   // hierarchical type system which includes both concrete and abstract types.
   //
   // The types form a lattice.  Currently we only allow for one parent type, but
   // eventually we may allow for multiple predecessors.
   class
   jit_type
   {
   public:
+
     typedef llvm::Value *(*convert_fn) (llvm::IRBuilderD&, llvm::Value *);
 
     jit_type (const std::string& aname, jit_type *aparent, llvm::Type *allvm_type,
               bool askip_paren, int aid);
 
     // a user readable type name
-    const std::string& name (void) const { return mname; }
+    const std::string& name (void) const { return m_name; }
 
     // a unique id for the type
-    int type_id (void) const { return mid; }
+    int type_id (void) const { return m_id; }
 
     // An abstract base type, may be null
-    jit_type * parent (void) const { return mparent; }
+    jit_type * parent (void) const { return m_parent; }
 
     // convert to an llvm type
-    llvm::Type * to_llvm (void) const { return llvm_type; }
+    llvm::Type * to_llvm (void) const { return m_llvm_type; }
 
     // how this type gets passed as a function argument
     llvm::Type * to_llvm_arg (void) const;
 
-    size_t depth (void) const { return mdepth; }
+    size_t depth (void) const { return m_depth; }
 
-    bool skip_paren (void) const { return mskip_paren; }
+    bool skip_paren (void) const { return m_skip_paren; }
 
     // -------------------- Calling Convention information --------------------
 
     // A function declared like: mytype foo (int arg0, int arg1);
     // Will be converted to: void foo (mytype *retval, int arg0, int arg1)
     // if mytype is sret.  The caller is responsible for allocating space for
     // retval. (on the stack)
-    bool sret (jit_convention::type cc) const { return msret[cc]; }
+    bool sret (jit_convention::type cc) const { return m_sret[cc]; }
 
     void mark_sret (jit_convention::type cc)
-    { msret[cc] = true; }
+    { m_sret[cc] = true; }
 
     // A function like: void foo (mytype arg0)
     // Will be converted to: void foo (mytype *arg0)
     // Basically just pass by reference.
-    bool pointer_arg (jit_convention::type cc) const { return mpointer_arg[cc]; }
+    bool pointer_arg (jit_convention::type cc) const { return m_pointer_arg[cc]; }
 
     void mark_pointer_arg (jit_convention::type cc)
-    { mpointer_arg[cc] = true; }
+    { m_pointer_arg[cc] = true; }
 
     // Convert into an equivalent form before calling.  For example, complex is
     // represented as two values llvm vector, but we need to pass it as a two
     // valued llvm structure to C functions.
-    convert_fn pack (jit_convention::type cc) { return mpack[cc]; }
+    convert_fn pack (jit_convention::type cc) { return m_pack[cc]; }
 
-    void set_pack (jit_convention::type cc, convert_fn fn) { mpack[cc] = fn; }
+    void set_pack (jit_convention::type cc, convert_fn fn) { m_pack[cc] = fn; }
 
     // The inverse operation of pack.
-    convert_fn unpack (jit_convention::type cc) { return munpack[cc]; }
+    convert_fn unpack (jit_convention::type cc) { return m_unpack[cc]; }
 
     void set_unpack (jit_convention::type cc, convert_fn fn)
-    { munpack[cc] = fn; }
+    { m_unpack[cc] = fn; }
 
     // The resulting type after pack is called.
     llvm::Type * packed_type (jit_convention::type cc)
-    { return mpacked_type[cc]; }
+    { return m_packed_type[cc]; }
 
     void set_packed_type (jit_convention::type cc, llvm::Type *ty)
-    { mpacked_type[cc] = ty; }
+    { m_packed_type[cc] = ty; }
+
   private:
-    std::string mname;
-    jit_type *mparent;
-    llvm::Type *llvm_type;
-    int mid;
-    size_t mdepth;
-    bool mskip_paren;
+
+    std::string m_name;
+    jit_type *m_parent;
+    llvm::Type *m_llvm_type;
+    int m_id;
+    size_t m_depth;
+    bool m_skip_paren;
 
-    bool msret[jit_convention::length];
-    bool mpointer_arg[jit_convention::length];
+    bool m_sret[jit_convention::length];
+    bool m_pointer_arg[jit_convention::length];
 
-    convert_fn mpack[jit_convention::length];
-    convert_fn munpack[jit_convention::length];
+    convert_fn m_pack[jit_convention::length];
+    convert_fn m_unpack[jit_convention::length];
 
-    llvm::Type *mpacked_type[jit_convention::length];
+    llvm::Type *m_packed_type[jit_convention::length];
   };
 
   // seperate print function to allow easy printing if type is null
   std::ostream& jit_print (std::ostream& os, jit_type *atype);
 
   // Find common type
   jit_type* jit_type_join (jit_type *lhs, jit_type *rhs);
 
@@ -230,35 +233,37 @@ namespace octave
   class jit_value;
 
   // An abstraction for calling llvm functions with jit_values.  Deals with
   // calling convention details.
   class
   jit_function
   {
     friend std::ostream& operator << (std::ostream& os, const jit_function& fn);
+
   public:
+
     // create a function in an invalid state
-    jit_function ();
+    jit_function (void);
 
     jit_function (const jit_module *amodule, jit_convention::type acall_conv,
                   const llvm::Twine& aname, jit_type *aresult,
                   const std::vector<jit_type *>& aargs);
 
     // Use an existing function, but change the argument types.  The new argument
     // types must behave the same for the current calling convention.
     jit_function (const jit_function& fn, jit_type *aresult,
                   const std::vector<jit_type *>& aargs);
 
     jit_function (const jit_function& fn);
 
     // erase the interal LLVM function (if it exists).  Will become invalid.
     void erase (void);
 
-    bool valid (void) const { return llvm_function; }
+    bool valid (void) const { return m_llvm_function; }
 
     std::string name (void) const;
 
     llvm::BasicBlock * new_block (const std::string& aname = "body",
                                   llvm::BasicBlock *insert_before = nullptr);
 
     typedef std::vector<llvm::Value *> arg_vec;
 
@@ -304,54 +309,55 @@ namespace octave
       return call (builder, in_args, other_args...);
     }
 
     llvm::Value * argument (llvm::IRBuilderD& builder, size_t idx) const;
 
     void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = nullptr,
                     bool verify = true);
 
-    llvm::Function * to_llvm (void) const { return llvm_function; }
+    llvm::Function * to_llvm (void) const { return m_llvm_function; }
 
     // If true, then the return value is passed as a pointer in the first argument
-    bool sret (void) const { return mresult && mresult->sret (call_conv); }
+    bool sret (void) const { return m_result && m_result->sret (m_call_conv); }
 
-    bool can_error (void) const { return mcan_error; }
+    bool can_error (void) const { return m_can_error; }
 
-    void mark_can_error (void) { mcan_error = true; }
+    void mark_can_error (void) { m_can_error = true; }
 
-    jit_type * result (void) const { return mresult; }
+    jit_type * result (void) const { return m_result; }
 
     jit_type * argument_type (size_t idx) const
     {
-      assert (idx < args.size ());
-      return args[idx];
+      assert (idx < m_args.size ());
+      return m_args[idx];
     }
 
-    const std::vector<jit_type *>& arguments (void) const { return args; }
+    const std::vector<jit_type *>& arguments (void) const { return m_args; }
 
   private:
 
-    const jit_module *module;
-    llvm::Function *llvm_function;
-    jit_type *mresult;
-    std::vector<jit_type *> args;
-    jit_convention::type call_conv;
-    bool mcan_error;
+    const jit_module *m_module;
+    llvm::Function *m_llvm_function;
+    jit_type *m_result;
+    std::vector<jit_type *> m_args;
+    jit_convention::type m_call_conv;
+    bool m_can_error;
   };
 
   std::ostream& operator << (std::ostream& os, const jit_function& fn);
 
   // Keeps track of information about how to implement operations (+, -, *, ect)
   // and their resulting types.
   class
   jit_operation
   {
   public:
-    jit_operation (const std::string& aname)  { mname = aname; }
+
+    jit_operation (const std::string& aname)  { m_name = aname; }
 
     // type signature vector
     typedef std::vector<jit_type *> signature_vec;
 
     virtual ~jit_operation (void);
 
     void add_overload (const jit_function& func)
     {
@@ -398,262 +404,381 @@ namespace octave
     jit_type * result (jit_type * arg1, Args... other_args) const
     {
       signature_vec args;
       args.reserve (1 + sizeof... (other_args));
       args.push_back (arg1);
       return overload (args, other_args...);
     }
 
-    const std::string& name (void) const { return mname; }
+    const std::string& name (void) const { return m_name; }
+
+    void stash_name (const std::string& aname) { m_name = aname; }
 
-    void stash_name (const std::string& aname) { mname = aname; }
   protected:
+
     virtual jit_function * generate (const signature_vec& types) const;
+
   private:
+
     Array<octave_idx_type> to_idx (const signature_vec& types) const;
 
     const jit_function& do_generate (const signature_vec& types) const;
 
     struct signature_cmp
     {
       bool operator () (const signature_vec *lhs, const signature_vec *rhs) const;
     };
 
     typedef std::map<const signature_vec *, jit_function *, signature_cmp>
     generated_map;
 
-    mutable generated_map generated;
+    mutable generated_map m_generated;
 
-    std::vector<Array<jit_function>> overloads;
+    std::vector<Array<jit_function>> m_overloads;
 
-    std::string mname;
+    std::string m_name;
   };
 
 
   class
   jit_index_operation : public jit_operation
   {
   public:
+
     jit_index_operation (const jit_typeinfo& ti, const std::string& name)
-      : jit_operation (name), typeinfo (ti) { }
+      : jit_operation (name), m_typeinfo (ti) { }
 
   protected:
+
     virtual jit_function * generate (const signature_vec& types) const;
 
     virtual jit_function * generate_matrix (const signature_vec& types) const = 0;
 
     // helper functions
     // [start_idx, end_idx).
     llvm::Value * create_arg_array (llvm::IRBuilderD& builder,
                                     const jit_function& fn, size_t start_idx,
                                     size_t end_idx) const;
 
-    const jit_typeinfo& typeinfo;
+    const jit_typeinfo& m_typeinfo;
   };
 
   class
   jit_paren_subsref : public jit_index_operation
   {
   public:
+
     // FIXME: Avoid creating object in an invalid state?
     jit_paren_subsref (const jit_typeinfo& ti);
-    ~jit_paren_subsref ();
-    void init_paren_scalar ();
+    ~jit_paren_subsref (void);
+    void init_paren_scalar (void);
 
   protected:
+
     virtual jit_function * generate_matrix (const signature_vec& types) const;
 
   private:
-    jit_function *paren_scalar;
+
+    jit_function *m_paren_scalar;
   };
 
   class
   jit_paren_subsasgn : public jit_index_operation
   {
   public:
+
     // FIXME: Avoid creating object in an invalid state?
     jit_paren_subsasgn (const jit_typeinfo& ti);
-    ~jit_paren_subsasgn ();
-    void init_paren_scalar ();
+    ~jit_paren_subsasgn (void);
+    void init_paren_scalar (void);
 
   protected:
+
     jit_function * generate_matrix (const signature_vec& types) const;
 
   private:
-    jit_function *paren_scalar;
+
+    jit_function *m_paren_scalar;
   };
 
 
   // A singleton class which handles the construction of jit_types
   class
   jit_typeinfo
   {
     // ----- Constructor/destructor (singleton pattern) -----
 
   public:
-    ~jit_typeinfo ();
+
+    ~jit_typeinfo (void);
 
   private:
+
     static jit_typeinfo& instance (void);
-    jit_typeinfo ();
-    static bool in_construction;
+    jit_typeinfo (void);
+    static bool s_in_construction;
 
     // ----- Registering types -----
 
   public:
+
     static jit_type *register_new_type (const std::string& name, jit_type *parent,
                                         llvm::Type *llvm_type, bool skip_paren = false)
     {
       return instance ().do_register_new_type (name, parent, llvm_type, skip_paren);
     }
 
   private:
+
     // List of all registered types
-    std::vector<jit_type*> id_to_type;
+    std::vector<jit_type*> m_id_to_type;
 
     // Register a new type
     jit_type *do_register_new_type (const std::string& name, jit_type *parent,
                                     llvm::Type *llvm_type, bool skip_paren = false);
 
     // ----- Base types -----
 
   public:
-    static jit_type *get_any (void)           { return instance ().any; }
-    static jit_type *get_matrix (void)        { return instance ().matrix; }
-    static jit_type *get_scalar (void)        { return instance ().scalar; }
-    static jit_type *get_scalar_ptr (void)    { return instance ().scalar_ptr; }
-    static jit_type *get_any_ptr (void)       { return instance ().any_ptr; }
-    static jit_type *get_range (void)         { return instance ().range; }
-    static jit_type *get_string (void)        { return instance ().string; }
-    static jit_type *get_bool (void)          { return instance ().boolean; }
-    static jit_type *get_index (void)         { return instance ().index; }
-    static jit_type *get_complex (void)       { return instance ().complex; }
-    static jit_type *intN (size_t nbits)  { return instance ().do_get_intN (nbits); }
+
+    static jit_type *get_any (void) { return instance ().m_any; }
+
+    static jit_type *get_matrix (void) { return instance ().m_matrix; }
+
+    static jit_type *get_scalar (void) { return instance ().m_scalar; }
+
+    static jit_type *get_scalar_ptr (void) { return instance ().m_scalar_ptr; }
+
+    static jit_type *get_any_ptr (void) { return instance ().m_any_ptr; }
+
+    static jit_type *get_range (void) { return instance ().m_range; }
+
+    static jit_type *get_string (void) { return instance ().m_string; }
+
+    static jit_type *get_bool (void) { return instance ().m_boolean; }
+
+    static jit_type *get_index (void) { return instance ().m_index; }
+
+    static jit_type *get_complex (void) { return instance ().m_complex; }
+
+    static jit_type *intN (size_t nbits) { return instance ().do_get_intN (nbits); }
 
     // FIXME: do we really need these two ?
-    static llvm::Type *get_scalar_llvm (void) { return instance ().scalar->to_llvm (); }  // this one is weird
-    static llvm::Type *get_index_llvm (void)  { return instance ().index->to_llvm (); }  // this one is weird too
+    static llvm::Type *get_scalar_llvm (void) { return instance ().m_scalar->to_llvm (); }  // this one is weird
+
+    static llvm::Type *get_index_llvm (void)  { return instance ().m_index->to_llvm (); }  // this one is weird too
 
   private:
 
     // Base types as LLVM types
 
-    llvm::Type *any_t;
-    llvm::Type *bool_t;  // FIXME: should be "boolean_t", for consistency
-    llvm::Type *complex_t;
-    llvm::Type *index_t;
-    llvm::Type *scalar_t;
-    llvm::Type *string_t;
+    llvm::Type *m_any_t;
+    llvm::Type *m_bool_t;  // FIXME: should be "boolean_t", for consistency
+    llvm::Type *m_complex_t;
+    llvm::Type *m_index_t;
+    llvm::Type *m_scalar_t;
+    llvm::Type *m_string_t;
 
-    llvm::StructType *range_t;
-    llvm::StructType *matrix_t;
+    llvm::StructType *m_range_t;
+    llvm::StructType *m_matrix_t;
 
     // Base types as jit_type objects)
 
-    jit_type *any;
-    jit_type *boolean;
-    jit_type *complex;
-    jit_type *index;
-    jit_type *scalar;
-    jit_type *string;
+    jit_type *m_any;
+    jit_type *m_boolean;
+    jit_type *m_complex;
+    jit_type *m_index;
+    jit_type *m_scalar;
+    jit_type *m_string;
 
-    jit_type *range;
-    jit_type *matrix;
+    jit_type *m_range;
+    jit_type *m_matrix;
 
-    jit_type *scalar_ptr;  // a fake type for interfacing with C++
-    jit_type *any_ptr;     // a fake type for interfacing with C++ (bis)
-    jit_type *unknown_function;
+    jit_type *m_scalar_ptr;  // a fake type for interfacing with C++
+    jit_type *m_any_ptr;     // a fake type for interfacing with C++ (bis)
+    jit_type *m_unknown_function;
 
     // complex_ret is what is passed to C functions
     // in order to get calling convention right
-    llvm::StructType *complex_ret;
+    llvm::StructType *m_complex_ret;
 
     // Get integer type from number of bits
     jit_type *do_get_intN (size_t nbits) const;
 
     // map container for integer types: int8, int16, etc.
     // (note that they are also stored in id_to_types)
-    std::map<size_t, jit_type *> ints;
-
+    std::map<size_t, jit_type *> m_ints;
 
     // ----- parenthesis subsref/subsasgn -----
 
     friend jit_paren_subsref;
     friend jit_paren_subsasgn;
 
   public:
+
     static const jit_operation& paren_subsref (void)   { return instance ().paren_subsref_fn; }
     static const jit_operation& paren_subsasgn (void)  { return instance ().paren_subsasgn_fn; }
 
   private:
+
     jit_paren_subsref paren_subsref_fn;
     jit_paren_subsasgn paren_subsasgn_fn;
 
     // ----- Miscellaneous (FIXME: needs to be organized) -----
 
   public:
+
     // Get the jit_type of an octave_value
-    static jit_type *type_of (const octave_value &ov) { return instance ().do_type_of (ov); };
+    static jit_type *type_of (const octave_value &ov)
+    {
+      return instance ().do_type_of (ov);
+    };
 
     // Get a unary or binary operation from its integer id
-    static const jit_operation& binary_op (int op) { return instance ().do_binary_op (op); }
-    static const jit_operation& unary_op (int op) { return instance ().do_unary_op (op); }
+    static const jit_operation& binary_op (int op)
+    {
+      return instance ().do_binary_op (op);
+    }
+
+    static const jit_operation& unary_op (int op)
+    {
+      return instance ().do_unary_op (op);
+    }
+
+    static const jit_operation& grab (void)
+    {
+      return instance ().m_grab_fn;
+    }
+
+    static const jit_function& get_grab (jit_type *type)
+    {
+      return instance ().m_grab_fn.overload (type);
+    }
+
+    static const jit_operation& release (void)
+    {
+      return instance ().m_release_fn;
+    }
 
-    static const jit_operation& grab (void)               { return instance ().grab_fn; }
-    static const jit_function& get_grab (jit_type *type)  { return instance ().grab_fn.overload (type); }
+    static const jit_function& get_release (jit_type *type)
+    {
+      return instance ().m_release_fn.overload (type);
+    }
+
+    static const jit_operation& destroy (void)
+    {
+      return instance ().m_destroy_fn;
+    }
+
+    static const jit_operation& print_value (void)
+    {
+      return instance ().m_print_fn;
+    }
 
-    static const jit_operation& release (void)               { return instance ().release_fn; }
-    static const jit_function& get_release (jit_type *type)  { return instance ().release_fn.overload (type); }
+    static const jit_operation& for_init (void)
+    {
+      return instance ().m_for_init_fn;
+    }
+
+    static const jit_operation& for_check (void)
+    {
+      return instance ().m_for_check_fn;
+    }
+
+    static const jit_operation& for_index (void)
+    {
+      return instance ().m_for_index_fn;
+    }
 
-    static const jit_operation& destroy (void)         { return instance ().destroy_fn; }
-    static const jit_operation& print_value (void)     { return instance ().print_fn; }
-    static const jit_operation& for_init (void)        { return instance ().for_init_fn; }
-    static const jit_operation& for_check (void)       { return instance ().for_check_fn; }
-    static const jit_operation& for_index (void)       { return instance ().for_index_fn; }
-    static const jit_operation& make_range (void)      { return instance ().make_range_fn; }
-    static const jit_operation& logically_true (void)  { return instance ().logically_true_fn; }
+    static const jit_operation& make_range (void)
+    {
+      return instance ().m_make_range_fn;
+    }
+
+    static const jit_operation& logically_true (void)
+    {
+      return instance ().m_logically_true_fn;
+    }
 
-    static const jit_operation& cast (jit_type *result)             { return instance ().do_cast (result); }
-    static const jit_function& cast (jit_type *to, jit_type *from)  { return instance ().do_cast (to, from); }
+    static const jit_operation& cast (jit_type *result)
+    {
+      return instance ().do_cast (result);
+    }
+
+    static const jit_function& cast (jit_type *to, jit_type *from)
+    {
+      return instance ().do_cast (to, from);
+    }
+
+    static llvm::Value *insert_error_check (llvm::IRBuilderD& bld)
+    {
+      return instance ().do_insert_error_check (bld);
+    }
 
-    static llvm::Value *insert_error_check (llvm::IRBuilderD& bld)      { return instance ().do_insert_error_check (bld); }
-    static llvm::Value *insert_interrupt_check (llvm::IRBuilderD& bld)  { return instance ().do_insert_interrupt_check (bld); }
+    static llvm::Value *insert_interrupt_check (llvm::IRBuilderD& bld)
+    {
+      return instance ().do_insert_interrupt_check (bld);
+    }
 
-    static const jit_operation& end (void)                                               { return instance ().end_fn; }
-    static const jit_function&  end (jit_value *value, jit_value *idx, jit_value *count) { return instance ().do_end (value, idx, count); }
+    static const jit_operation& end (void)
+    {
+      return instance ().m_end_fn;
+    }
+
+    static const jit_function& end (jit_value *value, jit_value *idx,
+                                    jit_value *count)
+    {
+      return instance ().do_end (value, idx, count);
+    }
 
-    static const jit_operation& create_undef (void)  { return instance ().create_undef_fn; }
+    static const jit_operation& create_undef (void)
+    {
+      return instance ().m_create_undef_fn;
+    }
 
-    static llvm::Value *create_complex (llvm::Value *real, llvm::Value *imag)    { return instance ().complex_new (real, imag); }
-    static llvm::Value *pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx)  { return instance ().do_pack_complex (bld, cplx); }
-    static llvm::Value *unpack_complex (llvm::IRBuilderD& bld, llvm::Value *result);
+    static llvm::Value *create_complex (llvm::Value *real, llvm::Value *imag)
+    {
+      return instance ().complex_new (real, imag);
+    }
+
+    static llvm::Value *pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx)
+    {
+      return instance ().do_pack_complex (bld, cplx);
+    }
+
+    static llvm::Value *unpack_complex (llvm::IRBuilderD& bld,
+                                        llvm::Value *result);
 
   private:
 
     jit_type * do_type_of (const octave_value& ov) const;
 
     const jit_operation& do_binary_op (int op) const
-    { assert (static_cast<size_t>(op) < binary_ops.size ());
-      return binary_ops[op]; }
+    {
+      assert (static_cast<size_t>(op) < m_binary_ops.size ());
+      return m_binary_ops[op];
+    }
 
     const jit_operation& do_unary_op (int op) const
-    { assert (static_cast<size_t> (op) < unary_ops.size ());
-      return unary_ops[op]; }
+    {
+      assert (static_cast<size_t> (op) < m_unary_ops.size ());
+      return m_unary_ops[op];
+    }
 
     const jit_operation& do_cast (jit_type *to)
     {
       static jit_operation null_function ("null_function");
       if (! to)
         return null_function;
 
       size_t id = to->type_id ();
-      if (id >= casts.size ())
+      if (id >= m_casts.size ())
         return null_function;
-      return casts[id];
+      return m_casts[id];
     }
 
     const jit_function& do_cast (jit_type *to, jit_type *from)
     {
       return do_cast (to).overload (from);
     }
 
     const jit_function& do_end (jit_value *value, jit_value *index,
@@ -696,17 +821,17 @@ namespace octave
       return create_external (fn, name, ret, args, other_args...);
     }
 
     // create an internal calling convention (a function defined in llvm)
     jit_function create_internal (const llvm::Twine& name, jit_type *ret,
                                   const signature_vec& args
                                   = signature_vec ()) const
     {
-      return jit_function (base_jit_module, jit_convention::internal,
+      return jit_function (m_base_jit_module, jit_convention::internal,
                            name, ret, args);
     }
 
     template <typename ...Args>
     jit_function create_internal (const llvm::Twine& name, jit_type *ret,
                                   signature_vec& args,
                                   jit_type * arg1, Args... other_args) const
     {
@@ -765,50 +890,49 @@ namespace octave
     llvm::Value * complex_imag (llvm::Value *cx);
 
     llvm::Value * complex_imag (llvm::Value *cx, llvm::Value *imag);
 
     llvm::Value * complex_new (llvm::Value *real, llvm::Value *imag);
 
     llvm::Value *do_pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx) const;
 
-    int next_id;
+    int m_next_id;
 
-    llvm::GlobalVariable *lerror_state;
-    llvm::GlobalVariable *loctave_interrupt_state;
+    llvm::GlobalVariable *m_lerror_state;
+    llvm::GlobalVariable *m_loctave_interrupt_state;
 
-    llvm::Type *sig_atomic_type;
+    llvm::Type *m_sig_atomic_type;
 
-    std::map<std::string, jit_type *> builtins;
+    std::map<std::string, jit_type *> m_builtins;
 
-    std::vector<jit_operation> binary_ops;
-    std::vector<jit_operation> unary_ops;
-    jit_operation grab_fn;
-    jit_operation release_fn;
-    jit_operation destroy_fn;
-    jit_operation print_fn;
-    jit_operation for_init_fn;
-    jit_operation for_check_fn;
-    jit_operation for_index_fn;
-    jit_operation logically_true_fn;
-    jit_operation make_range_fn;
-    jit_operation end1_fn;
-    jit_operation end_fn;
-    jit_operation create_undef_fn;
+    std::vector<jit_operation> m_binary_ops;
+    std::vector<jit_operation> m_unary_ops;
+    jit_operation m_grab_fn;
+    jit_operation m_release_fn;
+    jit_operation m_destroy_fn;
+    jit_operation m_print_fn;
+    jit_operation m_for_init_fn;
+    jit_operation m_for_check_fn;
+    jit_operation m_for_index_fn;
+    jit_operation m_logically_true_fn;
+    jit_operation m_make_range_fn;
+    jit_operation m_end1_fn;
+    jit_operation m_end_fn;
+    jit_operation m_create_undef_fn;
 
-    jit_function any_call;
+    jit_function m_any_call;
 
     // type id -> cast function TO that type
-    std::vector<jit_operation> casts;
+    std::vector<jit_operation> m_casts;
 
     // type id -> identity function
-    std::vector<jit_function> identities;
+    std::vector<jit_function> m_identities;
 
-    jit_module *base_jit_module;
+    jit_module *m_base_jit_module;
 
-    llvm::IRBuilderD *builder_ptr;
-    llvm::IRBuilderD& builder;
+    llvm::IRBuilderD *m_builder_ptr;
+    llvm::IRBuilderD& m_builder;
   };
-
 }
 
 #endif
 #endif
diff --git a/libinterp/parse-tree/jit-util.cc b/libinterp/parse-tree/jit-util.cc
--- a/libinterp/parse-tree/jit-util.cc
+++ b/libinterp/parse-tree/jit-util.cc
@@ -37,20 +37,18 @@ along with Octave; see the file COPYING.
 #else
 #  include <llvm/Value.h>
 #endif
 
 #include <llvm/Support/raw_os_ostream.h>
 
 namespace octave
 {
-
   std::ostream&
   operator<< (std::ostream& os, const llvm::Value& v)
   {
     llvm::raw_os_ostream llvm_out (os);
     v.print (llvm_out);
     return os;
   }
-
 }
 
 #endif
diff --git a/libinterp/parse-tree/jit-util.h b/libinterp/parse-tree/jit-util.h
--- a/libinterp/parse-tree/jit-util.h
+++ b/libinterp/parse-tree/jit-util.h
@@ -88,127 +88,143 @@ class tree;
 class tree_expression;
 
 namespace octave
 {
   // thrown when we should give up on JIT and interpret
   class jit_fail_exception : public std::runtime_error
   {
   public:
-    jit_fail_exception (void) : std::runtime_error ("unknown"), mknown (false) { }
-    jit_fail_exception (const std::string& reason) : std::runtime_error (reason),
-                                                     mknown (true)
+
+    jit_fail_exception (void)
+      : std::runtime_error ("unknown"), m_known (false)
     { }
 
-    bool known (void) const { return mknown; }
+    jit_fail_exception (const std::string& reason)
+      : std::runtime_error (reason), m_known (true)
+    { }
+
+    bool known (void) const { return m_known; }
+
   private:
-    bool mknown;
+
+    bool m_known;
   };
 
   // llvm doesn't provide this, and it's really useful for debugging
   std::ostream& operator<< (std::ostream& os, const llvm::Value& v);
 
   template <typename HOLDER_T, typename SUB_T>
   class jit_internal_node;
 
   // jit_internal_list and jit_internal_node implement generic embedded doubly
   // linked lists.  List items extend from jit_internal_list, and can be placed
   // in nodes of type jit_internal_node.  We use CRTP twice.
+
   template <typename LIST_T, typename NODE_T>
   class
   jit_internal_list
   {
     friend class jit_internal_node<LIST_T, NODE_T>;
+
   public:
-    jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) { }
+
+    jit_internal_list (void)
+      : m_use_head (0), m_use_tail (0), m_use_count (0)
+    { }
 
     virtual ~jit_internal_list (void)
     {
-      while (use_head)
-        use_head->stash_value (0);
+      while (m_use_head)
+        m_use_head->stash_value (0);
     }
 
-    NODE_T * first_use (void) const { return use_head; }
+    NODE_T * first_use (void) const { return m_use_head; }
 
-    size_t use_count (void) const { return muse_count; }
+    size_t use_count (void) const { return m_use_count; }
+
   private:
-    NODE_T *use_head;
-    NODE_T *use_tail;
-    size_t muse_count;
+
+    NODE_T *m_use_head;
+    NODE_T *m_use_tail;
+    size_t m_use_count;
   };
 
   // a node for internal linked lists
   template <typename LIST_T, typename NODE_T>
   class
   jit_internal_node
   {
   public:
+
     typedef jit_internal_list<LIST_T, NODE_T> jit_ilist;
 
     jit_internal_node (void)
-      : mvalue (nullptr), mnext (nullptr), mprev (nullptr)
+      : m_value (nullptr), m_next (nullptr), m_prev (nullptr)
     { }
 
     ~jit_internal_node (void) { remove (); }
 
-    LIST_T * value (void) const { return mvalue; }
+    LIST_T * value (void) const { return m_value; }
 
     void stash_value (LIST_T *avalue)
     {
       remove ();
 
-      mvalue = avalue;
+      m_value = avalue;
 
-      if (mvalue)
+      if (m_value)
         {
-          jit_ilist *ilist = mvalue;
+          jit_ilist *ilist = m_value;
           NODE_T *sthis = static_cast<NODE_T *> (this);
-          if (ilist->use_head)
+          if (ilist->m_use_head)
             {
-              ilist->use_tail->mnext = sthis;
-              mprev = ilist->use_tail;
+              ilist->m_use_tail->m_next = sthis;
+              m_prev = ilist->m_use_tail;
             }
           else
-            ilist->use_head = sthis;
+            ilist->m_use_head = sthis;
 
-          ilist->use_tail = sthis;
-          ++ilist->muse_count;
+          ilist->m_use_tail = sthis;
+          ++ilist->m_use_count;
         }
     }
 
-    NODE_T * next (void) const { return mnext; }
+    NODE_T * next (void) const { return m_next; }
+
+    NODE_T * prev (void) const { return m_prev; }
 
-    NODE_T * prev (void) const { return mprev; }
   private:
-    void remove ()
+
+    void remove (void)
     {
-      if (mvalue)
+      if (m_value)
         {
-          jit_ilist *ilist = mvalue;
-          if (mprev)
-            mprev->mnext = mnext;
+          jit_ilist *ilist = m_value;
+          if (m_prev)
+            m_prev->m_next = m_next;
           else
             // we are the use_head
-            ilist->use_head = mnext;
+            ilist->m_use_head = m_next;
 
-          if (mnext)
-            mnext->mprev = mprev;
+          if (m_next)
+            m_next->m_prev = m_prev;
           else
             // we are the use tail
-            ilist->use_tail = mprev;
+            ilist->m_use_tail = m_prev;
 
-          mnext = mprev = 0;
-          --ilist->muse_count;
-          mvalue = 0;
+          m_next = m_prev = 0;
+          --ilist->m_use_count;
+          m_value = 0;
         }
     }
 
-    LIST_T *mvalue;
-    NODE_T *mnext;
-    NODE_T *mprev;
+    LIST_T *m_value;
+    NODE_T *m_next;
+    NODE_T *m_prev;
   };
 
   // Use like: isa<jit_phi> (value)
   // basically just a short cut type typing dyanmic_cast.
   template <typename T, typename U>
   bool isa (U *value)
   {
     return dynamic_cast<T *> (value);
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -585,17 +585,17 @@ void
       entry_blocks[entry_blocks.size () - 1] = tail;
 
     // each branch in the if statement will have different breaks/continues
     block_list current_breaks = m_breaks;
     block_list current_continues = m_continues;
     m_breaks.clear ();
     m_continues.clear ();
 
-    size_t num_incomming = 0; // number of incomming blocks to our tail
+    size_t num_incoming = 0; // number of incoming blocks to our tail
     iter = lst.begin ();
     for (size_t i = 0; iter != lst.end (); ++iter, ++i)
       {
         tree_if_clause *tic = *iter;
         m_block = entry_blocks[i];
         assert (m_block);
 
         if (i) // the first block is prev_block, so it has already been added
@@ -618,30 +618,30 @@ void
           }
 
         tree_statement_list *stmt_lst = tic->commands ();
         assert (stmt_lst); // jwe: Can this be null?
 
         try
           {
             stmt_lst->accept (*this);
-            ++num_incomming;
+            ++num_incoming;
             m_block->append (m_factory.create<jit_branch> (tail));
           }
         catch (const jit_break_exception&)
           { }
 
         current_breaks.splice (current_breaks.end (), m_breaks);
         current_continues.splice (current_continues.end (), m_continues);
       }
 
     m_breaks.splice (m_breaks.end (), current_breaks);
     m_continues.splice (m_continues.end (), current_continues);
 
-    if (num_incomming || ! last_else)
+    if (num_incoming || ! last_else)
       {
         m_blocks.push_back (tail);
         m_block = tail;
       }
     else
       // every branch broke, so we don't have a tail
       throw jit_break_exception ();
   }
@@ -884,17 +884,17 @@ void
       entry_blocks[entry_blocks.size()-1] = tail;
 
     // each branch in the case statement will have different breaks/continues
     block_list current_breaks = m_breaks;
     block_list current_continues = m_continues;
     m_breaks.clear ();
     m_continues.clear ();
 
-    size_t num_incomming = 0; // number of incomming blocks to our tail
+    size_t num_incoming = 0; // number of incoming blocks to our tail
 
     tree_switch_case_list::iterator iter = lst->begin ();
     for (size_t i = 0; i < case_blocks_num; ++iter, ++i)
       {
         tree_switch_case *twc = *iter;
         m_block = entry_blocks[i]; // case_cond
         assert (m_block);
 
@@ -924,32 +924,32 @@ void
           }
 
         tree_statement_list *stmt_lst = twc->commands ();
         assert(stmt_lst);
 
         try
           {
             stmt_lst->accept (*this);
-            num_incomming++;
+            num_incoming++;
             m_block->append (m_factory.create<jit_branch> (tail));
           }
         catch (const jit_break_exception&)
           { }
 
         // each branch in the case statement will have different breaks/continues
         current_breaks.splice (current_breaks.end (), m_breaks);
         current_continues.splice (current_continues.end (), m_continues);
       }
 
     // each branch in the case statement will have different breaks/continues
     m_breaks.splice (m_breaks.end (), current_breaks);
     m_continues.splice (m_continues.end (), current_continues);
 
-    if (num_incomming || ! has_otherwise)
+    if (num_incoming || ! has_otherwise)
       {
         m_blocks.push_back (tail);
         m_block = tail; // switch_tail
       }
     else
       throw jit_break_exception ();   // every branch broke
   }
 
@@ -1452,17 +1452,17 @@ void
   }
 
   void
   jit_convert_llvm::finish_phi (jit_phi *phi)
   {
     llvm::PHINode *llvm_phi = phi->to_llvm ();
     for (size_t i = 0; i < phi->argument_count (); ++i)
       {
-        llvm::BasicBlock *pred = phi->incomming_llvm (i);
+        llvm::BasicBlock *pred = phi->incoming_llvm (i);
         llvm_phi->addIncoming (phi->argument_llvm (i), pred);
       }
   }
 
   void
   jit_convert_llvm::visit (jit_const_string& cs)
   {
     cs.stash_llvm (builder.CreateGlobalStringPtr (cs.value ()));
@@ -1499,20 +1499,20 @@ void
   jit_convert_llvm::visit (jit_const_range& cr)
   {
     llvm::StructType *stype = llvm::cast<llvm::StructType>(cr.type_llvm ());
     llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
     llvm::Type *idx = jit_typeinfo::get_index_llvm ();
     const jit_range& rng = cr.value ();
 
     llvm::Constant *constants[4];
-    constants[0] = llvm::ConstantFP::get (scalar_t, rng.base);
-    constants[1] = llvm::ConstantFP::get (scalar_t, rng.limit);
-    constants[2] = llvm::ConstantFP::get (scalar_t, rng.inc);
-    constants[3] = llvm::ConstantInt::get (idx, rng.nelem);
+    constants[0] = llvm::ConstantFP::get (scalar_t, rng.m_base);
+    constants[1] = llvm::ConstantFP::get (scalar_t, rng.m_limit);
+    constants[2] = llvm::ConstantFP::get (scalar_t, rng.m_inc);
+    constants[3] = llvm::ConstantInt::get (idx, rng.m_nelem);
 
     llvm::Value *as_llvm;
     as_llvm = llvm::ConstantStruct::get (stype,
                                          llvm::makeArrayRef (constants, 4));
     cr.stash_llvm (as_llvm);
   }
 
   void
@@ -1594,17 +1594,17 @@ void
           builder.CreateRetVoid ();
       }
   }
 
   void
   jit_convert_llvm::visit (jit_phi& phi)
   {
     // we might not have converted all incoming branches, so we don't
-    // set incomming branches now
+    // set incoming branches now
     llvm::PHINode *node = llvm::PHINode::Create (phi.type_llvm (),
                                                  phi.argument_count ());
     builder.Insert (node);
     phi.stash_llvm (node);
   }
 
   void
   jit_convert_llvm::visit (jit_variable&)
@@ -1657,17 +1657,17 @@ void
   { }
 
   void
   jit_convert_llvm::visit (jit_magic_end& me)
   {
     const jit_function& ol = me.overload ();
 
     jit_magic_end::context ctx = me.resolve_context ();
-    llvm::Value *ret = ol.call (builder, ctx.value, ctx.index, ctx.count);
+    llvm::Value *ret = ol.call (builder, ctx.m_value, ctx.m_index, ctx.m_count);
     me.stash_llvm (ret);
   }
 
   // -------------------- jit_infer --------------------
   jit_infer::jit_infer (jit_factory& afactory, jit_block_list& ablocks,
                         const variable_map& avmap)
     : m_blocks (ablocks), m_factory (afactory), m_vmap (avmap) { }
 
@@ -1805,17 +1805,17 @@ void
         for (jit_block::iterator iter = finish->begin ();
              iter != finish->end () && isa<jit_phi> (*iter);)
           {
             jit_phi *phi = static_cast<jit_phi *> (*iter);
             jit_variable *var = phi->dest ();
             ++iter;
 
             if (var->has_top ())
-              phi->add_incomming (&ablock, var->top ());
+              phi->add_incoming (&ablock, var->top ());
             else
               {
                 // temporaries may have extranious phi nodes which can be removed
                 assert (! phi->use_count ());
                 assert (var->name ().size () && var->name ()[0] == '#');
                 phi->remove ();
               }
           }
@@ -1910,25 +1910,25 @@ void
     while (iter != ablock.end () && isa<jit_phi> (*iter))
       {
         jit_phi *phi = static_cast<jit_phi *> (*iter);
         ++iter;
 
         jit_use *use = phi->first_use ();
         if (phi->use_count () == 1 && isa<jit_assign> (use->user ()))
           {
-            // instead of releasing on assign, release on all incomming branches,
+            // instead of releasing on assign, release on all incoming branches,
             // this can get rid of casts inside loops
             for (size_t i = 0; i < phi->argument_count (); ++i)
               {
                 jit_value *arg = phi->argument (i);
                 if (! arg->needs_release ())
                   continue;
 
-                jit_block *inc = phi->incomming (i);
+                jit_block *inc = phi->incoming (i);
                 jit_block *split = inc->maybe_split (m_factory, m_blocks, ablock);
                 jit_terminator *term = split->terminator ();
                 jit_call *release
                   = m_factory.create<jit_call> (jit_typeinfo::release, arg);
                 release->infer ();
                 split->insert_before (term, release);
               }
 
@@ -2011,17 +2011,17 @@ void
     jit_block& pblock = *phi.parent ();
     const jit_operation& cast_fn = jit_typeinfo::cast (phi.type ());
     jit_variable *dest = phi.dest ();
     for (size_t i = 0; i < phi.argument_count (); ++i)
       {
         jit_value *arg = phi.argument (i);
         if (arg->type () != phi.type ())
           {
-            jit_block *pred = phi.incomming (i);
+            jit_block *pred = phi.incoming (i);
             jit_block *split = pred->maybe_split (m_factory, m_blocks, pblock);
             jit_terminator *term = split->terminator ();
             jit_instruction *cast = m_factory.create<jit_call> (cast_fn, arg);
             jit_assign *assign = m_factory.create<jit_assign> (dest, cast);
 
             split->insert_before (term, cast);
             split->insert_before (term, assign);
             cast->infer ();
