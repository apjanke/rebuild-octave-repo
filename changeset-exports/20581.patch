# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444345251 14400
#      Thu Oct 08 19:00:51 2015 -0400
# Node ID fd0efcdb37188ecf35870f4751129c334a926f10
# Parent  729a85dafba8455407734a2f5484557dbe27c5da
use new string_value method to handle value extraction errors

* dirfns.cc, file-io.cc, gammainc.cc, help.cc, load-path.cc,
octave-link.cc, qz.cc, regexp.cc, strfns.cc, syscalls.cc, time.cc,
variables.cc: Use new string_value method.

diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -179,34 +179,29 @@ error message.\n\
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Cell ();
 
   if (args.length () == 1)
     {
-      std::string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ("readdir: DIR must be a string");
+
+      dir_entry dir (dirname);
 
-      if (error_state)
-        gripe_wrong_type_arg ("readdir", args(0));
+      if (dir)
+        {
+          string_vector dirlist = dir.read ();
+          retval(1) = 0.0;
+          retval(0) = Cell (dirlist.sort ());
+        }
       else
         {
-          dir_entry dir (dirname);
-
-          if (dir)
-            {
-              string_vector dirlist = dir.read ();
-              retval(1) = 0.0;
-              retval(0) = Cell (dirlist.sort ());
-            }
-          else
-            {
-              retval(2) = dir.error ();
-            }
+          retval(2) = dir.error ();
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -240,37 +235,23 @@ When creating a directory permissions wi
   retval(0) = false;
 
   int nargin = args.length ();
 
   std::string dirname;
 
   if (nargin == 2)
     {
-      std::string parent = args(0).string_value ();
-      std::string dir = args(1).string_value ();
+      std::string parent = args(0).string_value ("mkdir: PARENT must be a string");
+      std::string dir = args(1).string_value ("mkdir: DIR must be a string");
 
-      if (error_state)
-        {
-          gripe_wrong_type_arg ("mkdir", args(0));
-          return retval;
-        }
-      else
-        dirname = file_ops::concat (parent, dir);
+      dirname = file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
-    {
-      dirname = args(0).string_value ();
-
-      if (error_state)
-        {
-          gripe_wrong_type_arg ("mkdir", args(0));
-          return retval;
-        }
-    }
+    dirname = args(0).string_value ("mkdir: DIR must be a string");
 
   if (nargin == 1 || nargin == 2)
     {
       std::string msg;
 
       dirname = file_ops::tilde_expand (dirname);
 
       file_stat fs (dirname);
@@ -326,58 +307,53 @@ identifier.\n\
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ("rmdir: DIR must be a string");
 
-      if (error_state)
-        gripe_wrong_type_arg ("rmdir", args(0));
-      else
+      std::string fulldir = file_ops::tilde_expand (dirname);
+      int status = -1;
+      std::string msg;
+
+      if (nargin == 2)
         {
-          std::string fulldir = file_ops::tilde_expand (dirname);
-          int status = -1;
-          std::string msg;
+          if (args(1).string_value () == "s")
+            {
+              bool doit = true;
 
-          if (nargin == 2)
-            {
-              if (args(1).string_value () == "s")
+              if (interactive && ! forced_interactive
+                  && Vconfirm_recursive_rmdir)
                 {
-                  bool doit = true;
-
-                  if (interactive && ! forced_interactive
-                      && Vconfirm_recursive_rmdir)
-                    {
-                      std::string prompt
-                        = "remove entire contents of " + fulldir + "? ";
+                  std::string prompt
+                    = "remove entire contents of " + fulldir + "? ";
 
-                      doit = octave_yes_or_no (prompt);
-                    }
+                  doit = octave_yes_or_no (prompt);
+                }
 
-                  if (doit)
-                    status = octave_recursive_rmdir (fulldir, msg);
-                }
-              else
-                error ("rmdir: expecting second argument to be \"s\"");
+              if (doit)
+                status = octave_recursive_rmdir (fulldir, msg);
             }
           else
-            status = octave_rmdir (fulldir, msg);
+            error ("rmdir: expecting second argument to be \"s\"");
+        }
+      else
+        status = octave_rmdir (fulldir, msg);
 
-          if (status < 0)
-            {
-              retval(2) = "rmdir";
-              retval(1) = msg;
-            }
-          else
-            retval(0) = true;
+      if (status < 0)
+        {
+          retval(2) = "rmdir";
+          retval(1) = msg;
         }
+      else
+        retval(0) = true;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
@@ -394,37 +370,27 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ();
+      std::string from = args(0).string_value ("link: OLD must be a string");
+      std::string to = args(1).string_value ("link: NEW must be a string");
 
-      if (error_state)
-        gripe_wrong_type_arg ("link", args(0));
-      else
-        {
-          std::string to = args(1).string_value ();
+      std::string msg;
 
-          if (error_state)
-            gripe_wrong_type_arg ("link", args(1));
-          else
-            {
-              std::string msg;
+      int status = octave_link (from, to, msg);
 
-              int status = octave_link (from, to, msg);
+      if (status < 0)
+        retval(1) = msg;
 
-              if (status < 0)
-                retval(1) = msg;
-              retval(0) = status;
-            }
-        }
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
@@ -441,37 +407,27 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ();
+      std::string from = args(0).string_value ("symlink: OLD must be a string");
+      std::string to = args(1).string_value ("symlink: NEW must be a string");
 
-      if (error_state)
-        gripe_wrong_type_arg ("symlink", args(0));
-      else
-        {
-          std::string to = args(1).string_value ();
+      std::string msg;
 
-          if (error_state)
-            gripe_wrong_type_arg ("symlink", args(1));
-          else
-            {
-              std::string msg;
+      int status = octave_symlink (from, to, msg);
 
-              int status = octave_symlink (from, to, msg);
+      if (status < 0)
+        retval(1) = msg;
 
-              if (status < 0)
-                retval(1) = msg;
-              retval(0) = status;
-            }
-        }
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
@@ -490,32 +446,28 @@ error message.\n\
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = std::string ();
 
   if (args.length () == 1)
     {
-      std::string symlink = args(0).string_value ();
+      std::string symlink = args(0).string_value ("readlink: SYMLINK must be a string");
+
+      std::string result;
+      std::string msg;
 
-      if (error_state)
-        gripe_wrong_type_arg ("readlink", args(0));
-      else
-        {
-          std::string result;
-          std::string msg;
+      int status = octave_readlink (symlink, result, msg);
 
-          int status = octave_readlink (symlink, result, msg);
+      if (status < 0)
+        retval(2) = msg;
 
-          if (status < 0)
-            retval(2) = msg;
-          retval(1) = status;
-          retval(0) = result;
-        }
+      retval(1) = status;
+      retval(0) = result;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
@@ -532,37 +484,27 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      std::string from = args(0).string_value ();
+      std::string from = args(0).string_value ("rename: OLD must be a string");
+      std::string to = args(1).string_value ("rename: NEW must be a string");
 
-      if (error_state)
-        gripe_wrong_type_arg ("rename", args(0));
-      else
-        {
-          std::string to = args(1).string_value ();
+      std::string msg;
 
-          if (error_state)
-            gripe_wrong_type_arg ("rename", args(1));
-          else
-            {
-              std::string msg;
+      int status = octave_rename (from, to, msg);
 
-              int status = octave_rename (from, to, msg);
+      if (status < 0)
+        retval(1) = msg;
 
-              if (status < 0)
-                retval(1) = msg;
-              retval(0) = status;
-            }
-        }
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (glob, args, ,
@@ -615,26 +557,21 @@ glob (\"file[12]\")\n\
 @end example\n\
 @seealso{ls, dir, readdir, what}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      string_vector pat = args(0).all_strings ();
+      string_vector pat = args(0).all_strings ("glob: PATTERN must be a string");
 
-      if (error_state)
-        gripe_wrong_type_arg ("glob", args(0));
-      else
-        {
-          glob_match pattern (file_ops::tilde_expand (pat));
+      glob_match pattern (file_ops::tilde_expand (pat));
 
-          retval = Cell (pattern.glob ());
-        }
+      retval = Cell (pattern.glob ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -722,27 +659,21 @@ It is @samp{/} (forward slash) under UNI
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = file_ops::dir_sep_str ();
   else if (args.length () == 1)
     {
-      std::string s = args(0).string_value ();
-
-      if (! error_state)
-        {
-          if (s == "all")
-            retval = file_ops::dir_sep_chars ();
-          else
-            gripe_wrong_type_arg ("filesep", args(0));
-        }
+      std::string s = args(0).string_value ("filesep: argument must be a string");
+      if (s == "all")
+        retval = file_ops::dir_sep_chars ();
       else
-        gripe_wrong_type_arg ("filesep", args(0));
+        error ("filesep: argument must be \"all\"");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
@@ -757,37 +688,32 @@ Query or set the character used to separ
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = dir_path::path_sep_str ();
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ();
+      std::string sval = args(0).string_value ("pathsep: argument must be a single character");
 
-      if (! error_state)
+      switch (sval.length ())
         {
-          switch (sval.length ())
-            {
-            case 1:
-              dir_path::path_sep_char (sval[0]);
-              break;
+        case 1:
+          dir_path::path_sep_char (sval[0]);
+          break;
 
-            case 0:
-              dir_path::path_sep_char ('\0');
-              break;
+        case 0:
+          dir_path::path_sep_char ('\0');
+          break;
 
-            default:
-              error ("pathsep: argument must be a single character");
-              break;
-            }
+        default:
+          error ("pathsep: argument must be a single character");
+          break;
         }
-      else
-        error ("pathsep: argument must be a single character");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -533,38 +533,21 @@ do_stream_open (const std::string& name,
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
-  if (tc_name.is_string ())
-    {
-      std::string name = tc_name.string_value ();
-
-      if (tc_mode.is_string ())
-        {
-          std::string mode = tc_mode.string_value ();
+  std::string name = tc_name.string_value ("%s: file name must be a string", fcn);
+  std::string mode = tc_mode.string_value ("%s: file mode must be a string", fcn);
+  std::string arch = tc_arch.string_value ("%s: architecture type must be a string", fcn);
 
-          if (tc_arch.is_string ())
-            {
-              std::string arch = tc_arch.string_value ();
-
-              retval = do_stream_open (name, mode, arch, fid);
-            }
-          else
-            error ("%s: architecture type must be a string", fcn);
-        }
-      else
-        error ("%s: file mode must be a string", fcn);
-    }
-  else
-    error ("%s: file name must be a string", fcn);
+  retval = do_stream_open (name, mode, arch, fid);
 
   return retval;
 }
 
 DEFUN (fopen, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{fid} =} fopen (@var{name})\n\
 @deftypefnx {Built-in Function} {@var{fid} =} fopen (@var{name}, @var{mode})\n\
@@ -1342,54 +1325,44 @@ do_fread (octave_stream& os, const octav
   octave_value retval;
 
   count = -1;
 
   Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
     {
-      if (prec_arg.is_string ())
-        {
-          std::string prec = prec_arg.string_value ();
+      std::string prec = prec_arg.string_value ("fread: PRECISION must be a string");
+
+      int block_size = 1;
+      oct_data_conv::data_type input_type;
+      oct_data_conv::data_type output_type;
 
-          int block_size = 1;
-          oct_data_conv::data_type input_type;
-          oct_data_conv::data_type output_type;
+      oct_data_conv::string_to_data_type (prec, block_size,
+                                          input_type, output_type);
 
-          oct_data_conv::string_to_data_type (prec, block_size,
-                                              input_type, output_type);
+      if (! error_state)
+        {
+          int skip = skip_arg.int_value (true);
 
           if (! error_state)
             {
-              int skip = skip_arg.int_value (true);
-
-              if (! error_state)
-                {
-                  if (arch_arg.is_string ())
-                    {
-                      std::string arch = arch_arg.string_value ();
+              std::string arch = arch_arg.string_value ("fread: ARCH architecture type must be a string");
 
-                      oct_mach_info::float_format flt_fmt
-                        = oct_mach_info::string_to_float_format (arch);
+              oct_mach_info::float_format flt_fmt
+                = oct_mach_info::string_to_float_format (arch);
 
-                      retval = os.read (size, block_size, input_type,
-                                        output_type, skip, flt_fmt, count);
-                    }
-                  else
-                    error ("fread: ARCH architecture type must be a string");
-                }
-              else
-                error ("fread: SKIP must be an integer");
+              retval = os.read (size, block_size, input_type,
+                                output_type, skip, flt_fmt, count);
             }
           else
-            error ("fread: invalid PRECISION specified");
+            error ("fread: SKIP must be an integer");
         }
       else
-        error ("fread: PRECISION must be a string");
+        error ("fread: invalid PRECISION specified");
     }
   else
     error ("fread: invalid SIZE specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
@@ -1613,52 +1586,42 @@ The optional return value @var{count} co
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
   int retval = -1;
 
-  if (prec_arg.is_string ())
-    {
-      std::string prec = prec_arg.string_value ();
+  std::string prec = prec_arg.string_value ("fwrite: PRECISION must be a string");
+
+  int block_size = 1;
+  oct_data_conv::data_type output_type;
 
-      int block_size = 1;
-      oct_data_conv::data_type output_type;
+  oct_data_conv::string_to_data_type (prec, block_size, output_type);
 
-      oct_data_conv::string_to_data_type (prec, block_size, output_type);
+  if (! error_state)
+    {
+      int skip = skip_arg.int_value (true);
 
       if (! error_state)
         {
-          int skip = skip_arg.int_value (true);
-
-          if (! error_state)
-            {
-              if (arch_arg.is_string ())
-                {
-                  std::string arch = arch_arg.string_value ();
+          std::string arch = arch_arg.string_value ("fwrite: ARCH architecture type must be a string");
 
-                  oct_mach_info::float_format flt_fmt
-                    = oct_mach_info::string_to_float_format (arch);
+          oct_mach_info::float_format flt_fmt
+            = oct_mach_info::string_to_float_format (arch);
 
-                  retval = os.write (data, block_size, output_type,
-                                     skip, flt_fmt);
-                }
-              else
-                error ("fwrite: ARCH architecture type must be a string");
-            }
-          else
-            error ("fwrite: SKIP must be an integer");
+          retval = os.write (data, block_size, output_type,
+                             skip, flt_fmt);
         }
       else
-        error ("fwrite: invalid PRECISION specified");
+        error ("fwrite: SKIP must be an integer");
     }
   else
-    error ("fwrite: PRECISION must be a string");
+    error ("fwrite: invalid PRECISION specified");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fwrite (@var{fid}, @var{data})\n\
 @deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
@@ -1838,44 +1801,33 @@ endwhile\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("popen: COMMAND must be a string");
+      std::string mode = args(1).string_value ("popen: MODE must be a string");
 
-          if (args(1).is_string ())
-            {
-              std::string mode = args(1).string_value ();
-
-              if (mode == "r")
-                {
-                  octave_stream ips = octave_iprocstream::create (name);
+      if (mode == "r")
+        {
+          octave_stream ips = octave_iprocstream::create (name);
 
-                  retval = octave_stream_list::insert (ips);
-                }
-              else if (mode == "w")
-                {
-                  octave_stream ops = octave_oprocstream::create (name);
+          retval = octave_stream_list::insert (ips);
+        }
+      else if (mode == "w")
+        {
+          octave_stream ops = octave_oprocstream::create (name);
 
-                  retval = octave_stream_list::insert (ops);
-                }
-              else
-                error ("popen: invalid MODE specified");
-            }
-          else
-            error ("popen: MODE must be a string");
+          retval = octave_stream_list::insert (ops);
         }
       else
-        error ("popen: COMMAND must be a string");
+        error ("popen: invalid MODE specified");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
@@ -1921,32 +1873,24 @@ see @code{tmpfile}.\n\
 {
   octave_value retval;
 
   int len = args.length ();
 
   if (len < 3)
     {
       std::string dir;
+
       if (len > 0)
-        {
-          if (args(0).is_string ())
-            dir = args(0).string_value ();
-          else
-            error ("DIR must be a string");
-        }
+        dir = args(0).string_value ("tempname: DIR must be a string");
 
       std::string pfx ("oct-");
+
       if (len > 1)
-        {
-          if (args(1).is_string ())
-            pfx = args(1).string_value ();
-          else
-            error ("PREFIX must be a string");
-        }
+        pfx = args(1).string_value ("tempname: PREFIX must be a string");
 
       retval = octave_tempnam (dir, pfx);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2079,64 +2023,59 @@ file, and @var{msg} is an empty string. 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_string ())
+      std::string tmpl8 = args(0).string_value ("mkstemp: TEMPLATE argument must be a string");
+
+      OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
+      strcpy (tmp, tmpl8.c_str ());
+
+      int fd = gnulib::mkostemp (tmp, O_BINARY);
+
+      if (fd < 0)
         {
-          std::string tmpl8 = args(0).string_value ();
+          retval(2) = gnulib::strerror (errno);
+          retval(0) = fd;
+        }
+      else
+        {
+          const char *fopen_mode = "w+b";
 
-          OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
-          strcpy (tmp, tmpl8.c_str ());
+          FILE *fid = fdopen (fd, fopen_mode);
 
-          int fd = gnulib::mkostemp (tmp, O_BINARY);
+          if (fid)
+            {
+              std::string nm = tmp;
+
+              std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
+
+              octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-          if (fd < 0)
-            {
-              retval(2) = gnulib::strerror (errno);
-              retval(0) = fd;
+              if (s)
+                {
+                  retval(1) = nm;
+                  retval(0) = octave_stream_list::insert (s);
+
+                  if (nargin == 2 && args(1).is_true ())
+                    mark_for_deletion (nm);
+                }
+              else
+                error ("mkstemp: failed to create octave_stdiostream object");
             }
           else
             {
-              const char *fopen_mode = "w+b";
-
-              FILE *fid = fdopen (fd, fopen_mode);
-
-              if (fid)
-                {
-                  std::string nm = tmp;
-
-                  std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
-
-                  octave_stream s = octave_stdiostream::create (nm, fid, md);
-
-                  if (s)
-                    {
-                      retval(1) = nm;
-                      retval(0) = octave_stream_list::insert (s);
-
-                      if (nargin == 2 && args(1).is_true ())
-                        mark_for_deletion (nm);
-                    }
-                  else
-                    error ("mkstemp: failed to create octave_stdiostream object");
-                }
-              else
-                {
-                  retval(2) = gnulib::strerror (errno);
-                  retval(0) = -1;
-                }
+              retval(2) = gnulib::strerror (errno);
+              retval(0) = -1;
             }
         }
-      else
-        error ("mkstemp: TEMPLATE argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // FIXME: This routine also exists verbatim in syscalls.cc.
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -80,28 +80,24 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 {
   octave_value retval;
   bool lower = true;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
-      if (args(2).is_string ())
-        {
-          std::string s = args(2).string_value ();
-          std::transform (s.begin (), s.end (), s.begin (), tolower);
-          if (s == "upper")
-            lower = false;
-          else if (s != "lower")
-            error ("gammainc: third argument must be \"lower\" or \"upper\"");
-        }
-      else
+      std::string s = args(2).string_value ("gammainc: third argument must be \"lower\" or \"upper\"");
+
+      std::transform (s.begin (), s.end (), s.begin (), tolower);
+
+      if (s == "upper")
+        lower = false;
+      else if (s != "lower")
         error ("gammainc: third argument must be \"lower\" or \"upper\"");
-
     }
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1087,30 +1087,25 @@ The format is a string which is one of @
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text_from_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      const std::string name = args(0).string_value ();
+      const std::string name = args(0).string_value ("get_help_text: NAME must be a string");
 
-      if (! error_state)
-        {
-          std::string text;
-          std::string format;
+      std::string text;
+      std::string format;
 
-          do_get_help_text (name, text, format);
+      do_get_help_text (name, text, format);
 
-          retval(1) = format;
-          retval(0) = text;
-        }
-      else
-        error ("get_help_text: invalid input");
+      retval(1) = format;
+      retval(0) = text;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
@@ -1157,30 +1152,25 @@ The format is a string which is one of @
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      const std::string fname = args(0).string_value ();
+      const std::string fname = args(0).string_value ("get_help_text_from_file: NAME must be a string");
 
-      if (! error_state)
-        {
-          std::string text;
-          std::string format;
+      std::string text;
+      std::string format;
 
-          do_get_help_text_from_file (fname, text, format);
+      do_get_help_text_from_file (fname, text, format);
 
-          retval(1) = format;
-          retval(0) = text;
-        }
-      else
-        error ("get_help_text_from_file: invalid input");
+      retval(1) = format;
+      retval(0) = text;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
@@ -1375,34 +1365,29 @@ Undocumented internal function.\n\
   octave_value retval;
 
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
 
   if (args.length () == 0)
     retval = Cell (ffl.append (afl));
-  else if (args(0).is_string ())
+  else
     {
-      std::string dir = args(0).string_value ();
+      std::string dir = args(0).string_value ("__list_functions__: DIRECTORY argument must be a string");
 
       string_vector fl = load_path::files (dir, true);
 
-      if (! error_state)
-        {
-          // Return a sorted list with unique entries (in case of
-          // .m and .oct versions of the same function in a given
-          // directory, for example).
-          fl.sort (true);
+      // Return a sorted list with unique entries (in case of
+      // .m and .oct versions of the same function in a given
+      // directory, for example).
+      fl.sort (true);
 
-          retval = Cell (fl);
-        }
+      retval = Cell (fl);
     }
-  else
-    error ("__list_functions__: DIRECTORY argument must be a string");
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2234,36 +2234,30 @@ directories with those names.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_idx_type nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string dirname = args(0).string_value ();
-
-      if (! error_state)
-        retval = genpath (dirname);
-      else
-        error ("genpath: DIR must be a string");
+      std::string dirname = args(0).string_value ("genpath: DIR must be a string");
+
+      retval = genpath (dirname);
     }
   else if (nargin > 1)
     {
-      std::string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ("genpath: all arguments must be strings");
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
-        skip[i-1] = args(i).string_value ();
-
-      if (! error_state)
-        retval = genpath (dirname, skip);
-      else
-        error ("genpath: all arguments must be strings");
+        skip[i-1] = args(i).string_value ("genpath: all arguments must be strings");
+
+      retval = genpath (dirname, skip);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
@@ -2456,44 +2450,39 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
               return retval;
             }
         }
 
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
         {
-          if (args(i).is_string ())
+          std::string arg = args(i).string_value ("addpath: all arguments must be strings");
+
+          std::list<std::string> dir_elts = split_path (arg);
+
+          if (! append)
+            std::reverse (dir_elts.begin (), dir_elts.end ());
+
+          for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+               p != dir_elts.end ();
+               p++)
             {
-              std::string arg = args(i).string_value ();
-
-              std::list<std::string> dir_elts = split_path (arg);
-
-              if (! append)
-                std::reverse (dir_elts.begin (), dir_elts.end ());
-
-              for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-                   p != dir_elts.end ();
-                   p++)
-                {
-                  std::string dir = *p;
-
-                  //dir = regexprep (dir_elts{j}, '//+', "/");
-                  //dir = regexprep (dir, '/$', "");
-
-                  if (append)
-                    load_path::append (dir, true);
-                  else
-                    load_path::prepend (dir, true);
-
-                  need_to_update = true;
-                }
+              std::string dir = *p;
+
+              //dir = regexprep (dir_elts{j}, '//+', "/");
+              //dir = regexprep (dir, '/$', "");
+
+              if (append)
+                load_path::append (dir, true);
+              else
+                load_path::prepend (dir, true);
+
+              need_to_update = true;
             }
-          else
-            error ("addpath: all arguments must be strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
@@ -2525,38 +2514,33 @@ rmpath (\"dir1:/dir2:~/dir3\")\n\
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
         {
-          if (args(i).is_string ())
+          std::string arg = args(i).string_value ("rmpath: all arguments must be strings");
+          std::list<std::string> dir_elts = split_path (arg);
+
+          for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+               p != dir_elts.end ();
+               p++)
             {
-              std::string arg = args(i).string_value ();
-              std::list<std::string> dir_elts = split_path (arg);
-
-              for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-                   p != dir_elts.end ();
-                   p++)
-                {
-                  std::string dir = *p;
-
-                  //dir = regexprep (dir_elts{j}, '//+', "/");
-                  //dir = regexprep (dir, '/$', "");
-
-                  if (! load_path::remove (dir))
-                    warning ("rmpath: %s: not found", dir.c_str ());
-                  else
-                    need_to_update = true;
-                }
+              std::string dir = *p;
+
+              //dir = regexprep (dir_elts{j}, '//+', "/");
+              //dir = regexprep (dir, '/$', "");
+
+              if (! load_path::remove (dir))
+                warning ("rmpath: %s: not found", dir.c_str ());
+              else
+                need_to_update = true;
             }
-          else
-            error ("addpath: all arguments must be strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -117,97 +117,77 @@ DEFUN (__octave_link_edit_file__, args, 
 @deftypefn {Built-in Function} {} __octave_link_edit_file__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).string_value ();
+      std::string file = args(0).string_value ("expecting file name as argument");
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          retval = octave_link::edit_file (file);
-        }
-      else
-        error ("expecting file name as argument");
+      retval = octave_link::edit_file (file);
     }
   else if (args.length () == 2)
     {
-      std::string file = args(0).string_value ();
+      std::string file = args(0).string_value ("expecting file name as first argument");
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          retval = octave_link::prompt_new_edit_file (file);
-        }
-      else
-        error ("expecting file name as first argument");
+      retval = octave_link::prompt_new_edit_file (file);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_message_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_message_dialog__ (@var{dlg}, @var{msg}, @var{title})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
-      std::string dlg   = args(0).string_value ();
-      std::string msg   = args(1).string_value ();
-      std::string title = args(2).string_value ();
+      std::string dlg = args(0).string_value ("invalid arguments");
+      std::string msg = args(1).string_value ("invalid arguments");
+      std::string title = args(2).string_value ("invalid arguments");
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          retval = octave_link::message_dialog (dlg, msg, title);
-        }
-      else
-        error ("invalid arguments");
+      retval = octave_link::message_dialog (dlg, msg, title);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_question_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_question_dialog__ (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 6)
     {
-      std::string msg    = args(0).string_value ();
-      std::string title  = args(1).string_value ();
-      std::string btn1   = args(2).string_value ();
-      std::string btn2   = args(3).string_value ();
-      std::string btn3   = args(4).string_value ();
-      std::string btndef = args(5).string_value ();
+      std::string msg = args(0).string_value ("invalid arguments");
+      std::string title = args(1).string_value ("invalid arguments");
+      std::string btn1 = args(2).string_value ("invalid arguments");
+      std::string btn2 = args(3).string_value ("invalid arguments");
+      std::string btn3 = args(4).string_value ("invalid arguments");
+      std::string btndef = args(5).string_value ("invalid arguments");
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          retval = octave_link::question_dialog (msg, title, btn1, btn2, btn3,
-                                                 btndef);
-        }
-      else
-        error ("invalid arguments");
+      retval = octave_link::question_dialog (msg, title, btn1, btn2, btn3,
+                                             btndef);
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_file_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_file_dialog__ (@var{filterlist}, @var{title}, @var{filename}, @var{size} @var{multiselect}, @var{pathname})\n\
@@ -322,40 +302,35 @@ Undocumented internal function.\n\
       const Array<std::string> plist = list.cellstr_value ();
       nel = plist.numel ();
       std::list<std::string> prompt_lst;
       for (octave_idx_type i = 0; i < nel; i++)
         prompt_lst.push_back (plist(i));
       std::string ok_string = args(6).string_value ();
       std::string cancel_string = args(7).string_value ();
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          std::pair<std::list<int>, int> result
-            = octave_link::list_dialog (list_lst, mode, width, height,
-                                        initial_lst, name, prompt_lst,
-                                        ok_string, cancel_string);
+      std::pair<std::list<int>, int> result
+        = octave_link::list_dialog (list_lst, mode, width, height,
+                                    initial_lst, name, prompt_lst,
+                                    ok_string, cancel_string);
 
-          std::list<int> items_lst = result.first;
-          nel = items_lst.size ();
-          Matrix items (dim_vector (1, nel));
-          octave_idx_type i = 0;
-          for (std::list<int>::iterator it = items_lst.begin ();
-               it != items_lst.end (); it++)
-            {
-              items.xelem(i++) = *it;
-            }
+      std::list<int> items_lst = result.first;
+      nel = items_lst.size ();
+      Matrix items (dim_vector (1, nel));
+      octave_idx_type i = 0;
+      for (std::list<int>::iterator it = items_lst.begin ();
+           it != items_lst.end (); it++)
+        {
+          items.xelem(i++) = *it;
+        }
 
-          retval(1) = result.second;
-          retval(0) = items;
-        }
-      else
-        error ("invalid arguments");
+      retval(1) = result.second;
+      retval(0) = items;
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
@@ -387,37 +362,32 @@ Undocumented internal function.\n\
 
       Cell defaults = args(3).cell_value ();
       tmp = defaults.cellstr_value ();
       nel = tmp.numel ();
       std::list<std::string> defaults_lst;
       for (octave_idx_type i = 0; i < nel; i++)
         defaults_lst.push_back (tmp(i));
 
-      if (! error_state)
-        {
-          flush_octave_stdout ();
+      flush_octave_stdout ();
 
-          std::list<std::string> items_lst
-            = octave_link::input_dialog (prompt_lst, title, nr, nc,
-                                         defaults_lst);
+      std::list<std::string> items_lst
+        = octave_link::input_dialog (prompt_lst, title, nr, nc,
+                                     defaults_lst);
 
-          nel = items_lst.size ();
-          Cell items (dim_vector (nel, 1));
-          octave_idx_type i = 0;
-          for (std::list<std::string>::iterator it = items_lst.begin ();
-               it != items_lst.end (); it++)
-            {
-              items.xelem(i++) = *it;
-            }
+      nel = items_lst.size ();
+      Cell items (dim_vector (nel, 1));
+      octave_idx_type i = 0;
+      for (std::list<std::string>::iterator it = items_lst.begin ();
+           it != items_lst.end (); it++)
+        {
+          items.xelem(i++) = *it;
+        }
 
-          retval = items;
-        }
-      else
-        error ("invalid arguments");
+      retval = items;
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_show_preferences__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_show_preferences__ ()\n\
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -398,24 +398,19 @@ compatibility with @sc{matlab}.\n\
 #endif
 
   // Determine ordering option.
   volatile char ord_job = 0;
   static double safmin;
 
   if (nargin == 2)
     ord_job = 'N';
-  else if (! args(2).is_string ())
-    {
-      error ("qz: OPT must be a string");
-      return retval;
-    }
   else
     {
-      std::string tmp = args(2).string_value ();
+      std::string tmp = args(2).string_value ("qz: OPT must be a string");
 
       if (! tmp.empty ())
         ord_job = tmp[0];
 
       if (! (ord_job == 'N' || ord_job == 'n'
              || ord_job == 'S' || ord_job == 's'
              || ord_job == 'B' || ord_job == 'b'
              || ord_job == '+' || ord_job == '-'))
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -283,23 +283,17 @@ parse_options (regexp::opts& options, co
   int nargin = args.length ();
 
   extra_args = false;
 
   for (int i = skip; i < nargin; i++)
     {
       std::string str;
 
-      if (args(i).is_string ())
-        str = args(i).string_value ();
-      else
-        {
-          error ("%s: optional arguments must be strings", who.c_str ());
-          break;
-        }
+      str = args(i).string_value ("%s: optional arguments must be strings", who.c_str ());
 
       std::transform (str.begin (), str.end (), str.begin (), tolower);
 
       if (str.find ("once", 0) == 0)
         options.once (true);
       else if (str.find ("matchcase", 0) == 0)
         options.case_insensitive (false);
       else if (str.find ("ignorecase", 0) == 0)
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -918,25 +918,17 @@ whos ans\n\
           error ("list_in_columns: WIDTH must be an integer");
           return retval;
         }
     }
 
   std::string prefix;
 
   if (nargin > 2)
-    {
-      if (args(2).is_string ())
-        prefix = args(2).string_value ();
-      else
-        {
-          error ("list_in_columns: PREFIX must be a string");
-          return retval;
-        }
-    }
+    prefix = args(2).string_value ("list_in_columns: PREFIX must be a string");
 
   std::ostringstream buf;
 
   s.list_in_columns (buf, width, prefix);
 
   retval = buf.str ();
 
   return retval;
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -184,61 +184,56 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string exec_file = args(0).string_value ();
+      std::string exec_file = args(0).string_value ("exec: FILE must be a string");
+
+      string_vector exec_args;
 
-          string_vector exec_args;
-
-          if (nargin == 2)
-            {
-              string_vector tmp = args(1).all_strings ();
+      if (nargin == 2)
+        {
+          string_vector tmp = args(1).all_strings ();
 
-              if (! error_state)
-                {
-                  int len = tmp.numel ();
-
-                  exec_args.resize (len + 1);
+          if (! error_state)
+            {
+              int len = tmp.numel ();
 
-                  exec_args[0] = exec_file;
+              exec_args.resize (len + 1);
 
-                  for (int i = 0; i < len; i++)
-                    exec_args[i+1] = tmp[i];
-                }
-              else
-                error ("exec: all arguments must be strings");
+              exec_args[0] = exec_file;
+
+              for (int i = 0; i < len; i++)
+                exec_args[i+1] = tmp[i];
             }
           else
-            {
-              exec_args.resize (1);
-
-              exec_args[0] = exec_file;
-            }
-
-          octave_history_write_timestamp ();
-
-          if (! command_history::ignoring_entries ())
-            command_history::clean_up_and_save ();
-
-          std::string msg;
-
-          int status = octave_syscalls::execvp (exec_file, exec_args, msg);
-
-          retval(1) = msg;
-          retval(0) = status;
+            error ("exec: all arguments must be strings");
         }
       else
-        error ("exec: FILE must be a string");
+        {
+          exec_args.resize (1);
+
+          exec_args[0] = exec_file;
+        }
+
+      octave_history_write_timestamp ();
+
+      if (! command_history::ignoring_entries ())
+        command_history::clean_up_and_save ();
+
+      std::string msg;
+
+      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
+
+      retval(1) = msg;
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
@@ -293,84 +288,79 @@ exit status, it will linger until Octave
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
-      if (args(0).is_string ())
-        {
-          std::string exec_file = args(0).string_value ();
-
-          string_vector arg_list;
+      std::string exec_file = args(0).string_value ("popen2: COMMAND argument must be a string");
 
-          if (nargin >= 2)
-            {
-              string_vector tmp = args(1).all_strings ();
-
-              if (! error_state)
-                {
-                  int len = tmp.numel ();
+      string_vector arg_list;
 
-                  arg_list.resize (len + 1);
-
-                  arg_list[0] = exec_file;
-
-                  for (int i = 0; i < len; i++)
-                    arg_list[i+1] = tmp[i];
-                }
-              else
-                error ("popen2: all arguments must be strings");
-            }
-          else
-            {
-              arg_list.resize (1);
-
-              arg_list[0] = exec_file;
-            }
+      if (nargin >= 2)
+        {
+          string_vector tmp = args(1).all_strings ();
 
           if (! error_state)
             {
-              bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
-
-              int fildes[2];
-              std::string msg;
-              pid_t pid;
+              int len = tmp.numel ();
 
-              pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
-                                             fildes, msg, interactive);
-              if (pid >= 0)
-                {
-                  FILE *ifile = fdopen (fildes[1], "r");
-                  FILE *ofile = fdopen (fildes[0], "w");
-
-                  std::string nm;
+              arg_list.resize (len + 1);
 
-                  octave_stream is = octave_stdiostream::create (nm, ifile,
-                                                                 std::ios::in);
-
-                  octave_stream os = octave_stdiostream::create (nm, ofile,
-                                                                 std::ios::out);
+              arg_list[0] = exec_file;
 
-                  Cell file_ids (1, 2);
-
-                  retval(2) = pid;
-                  retval(1) = octave_stream_list::insert (is);
-                  retval(0) = octave_stream_list::insert (os);
-                }
-              else
-                error (msg.c_str ());
+              for (int i = 0; i < len; i++)
+                arg_list[i+1] = tmp[i];
             }
           else
             error ("popen2: all arguments must be strings");
         }
       else
-        error ("popen2: COMMAND argument must be a string");
+        {
+          arg_list.resize (1);
+
+          arg_list[0] = exec_file;
+        }
+
+      if (! error_state)
+        {
+          bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
+
+          int fildes[2];
+          std::string msg;
+          pid_t pid;
+
+          pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
+                                         fildes, msg, interactive);
+          if (pid >= 0)
+            {
+              FILE *ifile = fdopen (fildes[1], "r");
+              FILE *ofile = fdopen (fildes[0], "w");
+
+              std::string nm;
+
+              octave_stream is = octave_stdiostream::create (nm, ifile,
+                                                             std::ios::in);
+
+              octave_stream os = octave_stdiostream::create (nm, ofile,
+                                                             std::ios::out);
+
+              Cell file_ids (1, 2);
+
+              retval(2) = pid;
+              retval(1) = octave_stream_list::insert (is);
+              retval(0) = octave_stream_list::insert (os);
+            }
+          else
+            error (msg.c_str ());
+        }
+      else
+        error ("popen2: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -781,17 +771,17 @@ Return a structure @var{info} containing
 The function outputs are described in the documentation for @code{stat}.\n\
 @seealso{stat, symlink}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string fname = args(0).string_value ();
+      std::string fname = args(0).string_value ("lstat: NAME must be a string");
 
       file_stat fs (fname, false);
 
       retval = mk_stat_result (fs);
     }
   else
     print_usage ();
 
@@ -848,45 +838,40 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("mkfifo: FILE must be a string");
+
+      int octal_mode = args(1).int_value ();
 
-          int octal_mode = args(1).int_value ();
-
-          if (! error_state)
+      if (! error_state)
+        {
+          if (octal_mode < 0)
+            error ("mkfifo: MODE must be a positive integer value");
+          else
             {
-              if (octal_mode < 0)
-                error ("mkfifo: MODE must be a positive integer value");
-              else
-                {
-                  int mode = convert (octal_mode, 8, 10);
+              int mode = convert (octal_mode, 8, 10);
 
-                  std::string msg;
+              std::string msg;
+
+              int status = octave_mkfifo (name, mode, msg);
 
-                  int status = octave_mkfifo (name, mode, msg);
-
-                  retval(0) = status;
+              retval(0) = status;
 
-                  if (status < 0)
-                    retval(1) = msg;
-                }
+              if (status < 0)
+                retval(1) = msg;
             }
-          else
-            error ("mkfifo: MODE must be an integer");
         }
       else
-        error ("mkfifo: FILE must be a string");
+        error ("mkfifo: MODE must be an integer");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1062,17 +1047,17 @@ For example:\n\
           int fid = octave_stream_list::get_file_number (args(0));
 
           file_fstat fs (fid);
 
           retval = mk_stat_result (fs);
         }
       else
         {
-          std::string fname = args(0).string_value ();
+          std::string fname = args(0).string_value ("stat: NAME must be a string");
 
           file_stat fs (fname);
 
           retval = mk_stat_result (fs);
         }
     }
   else
     print_usage ();
@@ -1342,29 +1327,24 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("unlink: FILE must be a string");
 
-          std::string msg;
+      std::string msg;
 
-          int status = octave_unlink (name, msg);
+      int status = octave_unlink (name, msg);
 
-          retval(1) = msg;
-          retval(0) = status;
-        }
-      else
-        error ("unlink: FILE must be a string");
+      retval(1) = msg;
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
@@ -1663,29 +1643,24 @@ Return the canonical name of file @var{f
 If the file does not exist the empty string (\"\") is returned.\n\
 @seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
-          std::string msg;
-
-          std::string result = octave_canonicalize_file_name (name, msg);
+      std::string name = args(0).string_value ("canonicalize_file_name: NAME must be a string");
+      std::string msg;
 
-          retval(2) = msg;
-          retval(1) = msg.empty () ? 0 : -1;
-          retval(0) = result;
-        }
-      else
-        error ("canonicalize_file_name: NAME must be a string");
+      std::string result = octave_canonicalize_file_name (name, msg);
+
+      retval(2) = msg;
+      retval(1) = msg.empty () ? 0 : -1;
+      retval(0) = result;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static octave_value
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -468,36 +468,31 @@ Year (1970-).\n\
 @end table\n\
 @seealso{strptime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      if (args(0).is_string ())
+      std::string fmt = args(0).string_value ("strftime: FMT must be a string");
+
+      octave_scalar_map map = args(1).scalar_map_value ();
+
+      if (! error_state)
         {
-          std::string fmt = args(0).string_value ();
-
-          octave_scalar_map map = args(1).scalar_map_value ();
+          octave_base_tm tm = extract_tm (map);
 
           if (! error_state)
-            {
-              octave_base_tm tm = extract_tm (map);
-
-              if (! error_state)
-                retval = tm.strftime (fmt);
-              else
-                error ("strftime: invalid TM_STRUCT argument");
-            }
+            retval = tm.strftime (fmt);
           else
-            error ("strftime: TM_STRUCT must be a structure");
+            error ("strftime: invalid TM_STRUCT argument");
         }
       else
-        error ("strftime: FMT must be a string");
+        error ("strftime: TM_STRUCT must be a structure");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -524,34 +519,24 @@ position of last matched character plus 
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string str = args(0).string_value ();
+      std::string str = args(0).string_value ("strptime: argument STR must be a string");
 
-          if (args(1).is_string ())
-            {
-              std::string fmt = args(1).string_value ();
+      std::string fmt = args(1).string_value ("strptime: FMT must be a string");
 
-              octave_strptime t (str, fmt);
+      octave_strptime t (str, fmt);
 
-              retval(1) = t.characters_converted ();
-              retval(0) = octave_value (mk_tm_map (t));
-            }
-          else
-            error ("strptime: FMT must be a string");
-        }
-      else
-        error ("strptime: argument STR must be a string");
+      retval(1) = t.characters_converted ();
+      retval(0) = octave_value (mk_tm_map (t));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -142,49 +142,44 @@ extract_function (const octave_value& ar
                   const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
-      if (arg.is_string ())
+      std::string s = arg.string_value ("%s: expecting first argument to be a string",
+                                        warn_for.c_str ());
+
+      std::string cmd = header;
+      cmd.append (s);
+      cmd.append (trailer);
+
+      int parse_status;
+
+      eval_string (cmd, true, parse_status, 0);
+
+      if (parse_status == 0)
         {
-          std::string s = arg.string_value ();
-
-          std::string cmd = header;
-          cmd.append (s);
-          cmd.append (trailer);
-
-          int parse_status;
-
-          eval_string (cmd, true, parse_status, 0);
-
-          if (parse_status == 0)
+          retval = is_valid_function (fname, warn_for, 0);
+
+          if (! retval)
             {
-              retval = is_valid_function (fname, warn_for, 0);
-
-              if (! retval)
-                {
-                  error ("%s: '%s' is not valid as a function",
-                         warn_for.c_str (), fname.c_str ());
-                  return retval;
-                }
-
-              warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
-                       warn_for.c_str ());
+              error ("%s: '%s' is not valid as a function",
+                     warn_for.c_str (), fname.c_str ());
+              return retval;
             }
-          else
-            error ("%s: '%s' is not valid as a function",
-                   warn_for.c_str (), fname.c_str ());
+
+          warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
+                   warn_for.c_str ());
         }
       else
-        error ("%s: expecting first argument to be a string",
-               warn_for.c_str ());
+        error ("%s: '%s' is not valid as a function",
+               warn_for.c_str (), fname.c_str ());
     }
 
   return retval;
 }
 
 string_vector
 get_struct_elts (const std::string& text)
 {
@@ -590,39 +585,29 @@ not on the search path you should use so
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_string ())
+      std::string name = args(0).string_value ("exist: NAME must be a string");
+
+      if (nargin == 2)
         {
-          std::string name = args(0).string_value ();
-
-          if (nargin == 2)
-            {
-              if (args(1).is_string ())
-                {
-                  std::string type = args(1).string_value ();
-
-                  if (type == "class")
-                    warning ("exist: \"class\" type argument is not implemented");
-
-                  retval = symbol_exist (name, type);
-                }
-              else
-                error ("exist: TYPE must be a string");
-            }
-          else
-            retval = symbol_exist (name);
+          std::string type = args(1).string_value ("exist: TYPE must be a string");
+
+          if (type == "class")
+            warning ("exist: \"class\" type argument is not implemented");
+
+          retval = symbol_exist (name, type);
         }
       else
-        error ("exist: NAME must be a string");
+        retval = symbol_exist (name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -821,37 +806,32 @@ set_internal_variable (char& var, const 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ();
-
-      if (! error_state)
+      std::string sval = args(0).string_value ("%s: argument must be a single character", nm);
+
+      switch (sval.length ())
         {
-          switch (sval.length ())
-            {
-            case 1:
-              var = sval[0];
-              break;
-
-            case 0:
-              var = '\0';
-              break;
-
-            default:
-              error ("%s: argument must be a single character", nm);
-              break;
-            }
+        case 1:
+          var = sval[0];
+          break;
+
+        case 0:
+          var = '\0';
+          break;
+
+        default:
+          error ("%s: argument must be a single character", nm);
+          break;
         }
-      else
-        error ("%s: argument must be a single character", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -949,27 +929,22 @@ set_internal_variable (std::string& var,
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string sval = args(0).string_value ();
-
-          if (empty_ok || ! sval.empty ())
-            var = sval;
-          else
-            error ("%s: value must not be empty", nm);
-        }
+      std::string sval = args(0).string_value ("%s: first argument must be a string", nm);
+
+      if (empty_ok || ! sval.empty ())
+        var = sval;
       else
-        error ("%s: first argument must be a string", nm);
+        error ("%s: value must not be empty", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -990,34 +965,29 @@ set_internal_variable (int& var, const o
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
+      std::string sval = args(0).string_value ("%s: first argument must be a string", nm);
+
+      int i = 0;
+      for (; i < nchoices; i++)
         {
-          std::string sval = args(0).string_value ();
-
-          int i = 0;
-          for (; i < nchoices; i++)
+          if (sval == choices[i])
             {
-              if (sval == choices[i])
-                {
-                  var = i;
-                  break;
-                }
+              var = i;
+              break;
             }
-          if (i == nchoices)
-            error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
         }
-      else
-        error ("%s: first argument must be a string", nm);
+      if (i == nchoices)
+        error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 struct
@@ -2088,23 +2058,19 @@ Unlock the named function @var{fcn}.\n\
 If no function is named then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
-          munlock (name);
-        }
-      else
-        error ("munlock: FCN must be a string");
+      std::string name = args(0).string_value ("munlock: FCN must be a string");
+
+      munlock (name);
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         fcn->unlock ();
       else
@@ -2126,23 +2092,19 @@ Return true if the named function @var{f
 If no function is named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
-          retval = mislocked (name);
-        }
-      else
-        error ("mislocked: FCN must be a string");
+      std::string name = args(0).string_value ("mislocked: FCN must be a string");
+
+      retval = mislocked (name);
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         retval = fcn->islocked ();
       else
@@ -2707,22 +2669,19 @@ DEFUN (__varval__, args, ,
 @deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-        retval = symbol_table::varval (args(0).string_value ());
-      else
-        error ("__varval__: expecting argument to be variable name");
+      std::string name = args(0).string_value ("__varval__: expecting argument to be variable name");
+
+      retval = symbol_table::varval (args(0).string_value ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static std::string Vmissing_component_hook;
