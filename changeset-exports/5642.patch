# HG changeset patch
# User jwe
# Date 1141680414 0
#      Mon Mar 06 21:26:54 2006 +0000
# Node ID 2618a0750ae662ca3b36ec6384cf028064e7c352
# Parent  eb998631a4aa752320ad93237aa2d137e19d383c
[project @ 2006-03-06 21:26:48 by jwe]

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2006-03-06  Keith Goodman  <kwgoodman@gmail.com>
+
+	* interpreter/octave.texi (@seealso): Display args instead of
+	discarding them.
+
 2006-03-02  John W. Eaton  <jwe@octave.org>
 
 	* faq/Makefile.in (Octave-FAQ.ps): Depend on Octave-FAQ.dvi, not
 	$(TEXINFO).
 
 	* texinfo.tex: Update to 2004-11-25.16 version from Texinfo 4.8.
 
 2005-12-14  David Bateman  <dbateman@free.fr>
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -6,16 +6,19 @@
 @setfilename octave.info
 
 @c The following macro is used for the on-line help system, but we don't
 @c want lots of `See also: foo, bar, and baz' strings cluttering the
 @c printed manual (that information should be in the supporting text for
 @c each group of functions and variables).
 
 @macro seealso {args}
+@sp 1
+@noindent
+See also: \args\.
 @end macro
 
 @ifinfo
 @format
 START-INFO-DIR-ENTRY
 * Octave: (octave).	Interactive language for numerical computations.
 END-INFO-DIR-ENTRY
 @end format
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,75 @@
+2006-03-06  Keith Goodman  <kwgoodman@gmail.com>
+
+	* audio/lin2mu.m, audio/loadaudio.m, audio/mu2lin.m,
+	audio/playaudio.m, audio/record.m, audio/saveaudio.m,
+	audio/wavread.m, audio/wavwrite.m, control/base/DEMOcontrol.m,
+	control/base/__stepimp__.m, control/base/are.m,
+	control/base/controldemo.m, control/base/damp.m,
+	control/base/dare.m, control/base/impulse.m, control/base/lqg.m,
+	control/base/step.m, control/system/abcddim.m,
+	control/system/is_abcd.m, control/system/is_controllable.m,
+	control/system/is_detectable.m, control/system/is_observable.m,
+	control/system/is_stabilizable.m, control/system/is_stable.m,
+	control/system/jet707.m, control/system/sys2fir.m,
+	control/system/sysdimensions.m, control/system/sysupdate.m,
+	control/system/tfout.m, control/system/ugain.m,
+	control/system/zpout.m, elfun/lcm.m, finance/irr.m,
+	finance/nper.m, finance/npv.m, finance/pmt.m, finance/pv.m,
+	finance/rate.m, general/__isequal__.m, general/bitcmp.m,
+	general/bitget.m, general/bitset.m, general/blkdiag.m,
+	general/cart2pol.m, general/cart2sph.m, general/cell2mat.m,
+	general/circshift.m, general/columns.m, general/flipdim.m,
+	general/fliplr.m, general/flipud.m, general/ind2sub.m,
+	general/int2str.m, general/isdefinite.m, general/isequal.m,
+	general/isequalwithequalnans.m, general/isscalar.m,
+	general/issquare.m, general/issymmetric.m, general/isvector.m,
+	general/logspace.m, general/mod.m, general/nextpow2.m,
+	general/num2str.m, general/perror.m, general/pol2cart.m,
+	general/rem.m, general/rot90.m, general/rotdim.m, general/rows.m,
+	general/shiftdim.m, general/sph2cart.m, general/sub2ind.m,
+	general/tril.m, image/hsv2rgb.m, image/image.m, image/imagesc.m,
+	image/imshow.m, image/ind2gray.m, image/ind2rgb.m,
+	image/loadimage.m, image/rgb2hsv.m, image/rgb2ind.m,
+	image/saveimage.m, io/beep.m, linear-algebra/cond.m,
+	linear-algebra/norm.m, miscellaneous/comma.m, miscellaneous/dir.m,
+	miscellaneous/license.m, miscellaneous/menu.m,
+	miscellaneous/semicolon.m, miscellaneous/texas_lotto.m,
+	miscellaneous/unix.m, miscellaneous/ver.m, optimization/sqp.m,
+	plot/__errcomm__.m, plot/__errplot__.m, plot/__pltopt1__.m,
+	plot/__pltopt__.m, plot/bar.m, plot/contour.m, plot/errorbar.m,
+	plot/grid.m, plot/hist.m, plot/loglog.m, plot/loglogerr.m,
+	plot/mesh.m, plot/meshgrid.m, plot/plot.m, plot/polar.m,
+	plot/semilogx.m, plot/semilogxerr.m, plot/semilogy.m,
+	plot/semilogyerr.m, plot/shg.m, plot/stairs.m, plot/title.m,
+	plot/xlabel.m, polynomial/compan.m, polynomial/conv.m,
+	polynomial/deconv.m, polynomial/polyderiv.m, polynomial/polygcd.m,
+	polynomial/polyinteg.m, polynomial/polyout.m,
+	polynomial/polyreduce.m, polynomial/polyval.m,
+	polynomial/polyvalm.m, polynomial/residue.m, set/complement.m,
+	set/create_set.m, set/intersection.m, set/ismember.m,
+	set/setdiff.m, set/union.m, set/unique.m, sparse/etreeplot.m,
+	sparse/gplot.m, sparse/spalloc.m, sparse/sphcat.m,
+	sparse/sprand.m, sparse/sprandn.m, sparse/sprandsym.m,
+	sparse/spvcat.m, sparse/treeplot.m, specfun/erfinv.m,
+	specfun/log2.m, specfun/pow2.m, special-matrix/hankel.m,
+	special-matrix/hilb.m, special-matrix/invhilb.m,
+	special-matrix/sylvester_matrix.m, special-matrix/toeplitz.m,
+	special-matrix/vander.m, statistics/base/median.m,
+	statistics/base/std.m, statistics/distributions/gamcdf.m,
+	statistics/distributions/gaminv.m,
+	statistics/distributions/gampdf.m,
+	statistics/distributions/gamrnd.m, strings/base2dec.m,
+	strings/bin2dec.m, strings/dec2base.m, strings/dec2bin.m,
+	strings/dec2hex.m, strings/hex2dec.m, strings/isletter.m,
+	strings/lower.m, strings/upper.m, testfun/assert.m,
+	testfun/demo.m, testfun/example.m, testfun/test.m, time/etime.m:
+	Move @seealso inside @defXXX macro.  Remove "and" from @seealso.
+
 2006-02-27  John W. Eaton  <jwe@octave.org>
 
 	* time/tic.m: Move here from miscellaneous/tic.m.
 	* time/toc.m: Move here from miscellaneous/toc.m.
 
 2006-02-26  Keith Goodman  <kwgoodman@gmail.com>
  
  	* miscellaneous/toc.m: Display "Elapsed time is X seconds" if user
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -19,19 +19,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lin2mu (@var{x}, @var{n})
 ## Converts audio data from linear to mu-law.  Mu-law values use 8-bit
 ## unsigned integers.  Linear values use @var{n}-bit signed integers or 
 ## floating point values in the range -1<=@var{x}<=1 if @var{n} is 0.  
 ## If @var{n} is not specified it defaults to 0, 8 or 16 depending on 
 ## the range values in @var{x}.
+## @seealso{mu2lin, loadaudio, saveaudio, playaudio, setaudio, record}
 ## @end deftypefn
-##
-## @seealso{mu2lin, loadaudio, saveaudio, playaudio, setaudio, and record}
+
 
 ## Author: Andreas Weingessel <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = lin2mu (x, bit)
 
   if (nargin == 1)
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -24,19 +24,19 @@
 ##
 ## The extension @var{ext} determines how the data in the audio file is
 ## interpreted;  the extensions @file{lin} (default) and @file{raw}
 ## correspond to linear, the extensions @file{au}, @file{mu}, or @file{snd}
 ## to mu-law encoding.
 ##
 ## The argument @var{bps} can be either 8 (default) or 16, and specifies
 ## the number of bits per sample used in the audio file.
+## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, record}
 ## @end deftypefn
-##
-## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, and record}
+
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
 function X = loadaudio (name, ext, bit)
 
   if (nargin == 0 || nargin > 3)
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -18,19 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mu2lin (@var{x}, @var{bps})
 ## Converts audio data from linear to mu-law.  Mu-law values are 8-bit
 ## unsigned integers.  Linear values use @var{n}-bit signed integers
 ## or floating point values in the range -1<=y<=1 if @var{n} is 0.  If
 ## @var{n} is not specified it defaults to 8.
+## @seealso{lin2mu, loadaudio, saveaudio, playaudio, setaudio, record}
 ## @end deftypefn
-##
-## @seealso{lin2mu, loadaudio, saveaudio, playaudio, setaudio, and record}
 
 ## Author:  Andreas Weingessel <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 18 October 1994
 ## Adapted-By: jwe
 
 function y = mu2lin (x, bit)
 
   if (nargin == 1)
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} playaudio (@var{name}, @var{ext})
 ## @deftypefnx {Function File} {} playaudio (@var{x})
 ## Plays the audio file @file{@var{name}.@var{ext}} or the audio data
 ## stored in the vector @var{x}.
+## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, setaudio, record}
 ## @end deftypefn
-##
-## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
   usage_msg = "playaudio (name, ext)  or  playaudio (X)";
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -18,19 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} record (@var{sec}, @var{sampling_rate})
 ## Records @var{sec} seconds of audio input into the vector @var{x}.  The
 ## default value for @var{sampling_rate} is 8000 samples per second, or
 ## 8kHz.  The program waits until the user types @key{RET} and then
 ## immediately starts to record.
+## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, playaudio, setaudio}
 ## @end deftypefn
-##
-## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, playaudio, and setaudio}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 19 September 1994
 ## Adapted-By: jwe
 
 function X = record (sec, sampling_rate)
 
   if (nargin == 1)
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} saveaudio (@var{name}, @var{x}, @var{ext}, @var{bps})
 ## Saves a vector @var{x} of audio data to the file
 ## @file{@var{name}.@var{ext}}.  The optional parameters @var{ext} and
 ## @var{bps} determine the encoding and the number of bits per sample used
 ## in the audio file (see @code{loadaudio});  defaults are @file{lin} and
 ## 8, respectively.
+## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, record}
 ## @end deftypefn
-##
-## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, and record}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
 function saveaudio (name, X, ext, bit)
 
   if (nargin < 2 || nargin > 4)
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -31,20 +31,18 @@
 ## Read only the first @var{n} samples from each channel.
 ##
 ## @deftypefnx {Function File} {[@dots{}]} = wavread(@var{filename},[@var{n1} @var{n2}])
 ## Read only samples @var{n1} through @var{n2} from each channel.
 ##
 ## @deftypefnx {Function File} {[@var{samples}, @var{channels}]} = wavread (@var{filename}, "size")
 ## Return the number of samples (@var{n}) and channels (@var{ch})
 ## instead of the audio data.
-##
+## @seealso{wavwrite}
 ## @end deftypefn
-##
-## @seealso{wavwrite}
 
 ## Author: Michael Zeising <michael.zeising@stud.uni-erlangen.de>
 ## Created: 06 December 2005
 
 function [y, samples_per_sec, bits_per_sample] = wavread (filename, param)
 
   FORMAT_PCM        = 0x0001;   # PCM (8/16/32 bit)
   FORMAT_IEEE_FLOAT = 0x0003;   # IEEE float (32/64 bit)
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -23,20 +23,18 @@
 ## rate of 8000 Hz and 16-bit samples are assumed. Each column of the data 
 ## represents a separate channel.
 ##
 ## @deftypefnx {Function File} {} wavwrite(@var{filename}, @var{y}, @var{fs})
 ## Set the sample rate to @var{fs} Hz.
 ##
 ## @deftypefnx {Function File} {} wavwrite(@var{filename}, @var{y}, @var{fs}, @var{bits})
 ## Set the sample rate to @var{fs} Hz and resolution to @var{bits} bits.
-##
+## @seealso{wavread}
 ## @end deftypefn
-##
-## @seealso{wavread}
 
 ## Author: Michael Zeising <michael.zeising@stud.uni-erlangen.de>
 ## Created: 06 December 2005
 
 function wavwrite (filename, y, samples_per_sec, bits_per_sample)
 
   BYTEORDER = "ieee-le";
   
diff --git a/scripts/control/base/DEMOcontrol.m b/scripts/control/base/DEMOcontrol.m
--- a/scripts/control/base/DEMOcontrol.m
+++ b/scripts/control/base/DEMOcontrol.m
@@ -33,20 +33,19 @@
 ##   [ 4] State space analysis functions
 ##   [ 5] Root locus functions
 ##   [ 6] LQG/H2/Hinfinity functions
 ##   [ 7] End
 ## @end group
 ## @end example
 ## Command examples are interactively run for users to observe the use
 ## of @acronym{OCST} functions.
-## @end deftypefn
-##
 ## @seealso{Demo Programs: bddemo.m, frdemo.m, analdemo.m,
 ## moddmeo.m, rldemo.m}
+## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function DEMOcontrol ()
 
   puts ("O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X");
 
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -23,19 +23,18 @@
 ## The system can be discrete or multivariable (or both).
 ## This m-file contains the ``common code'' of step and impulse.
 ##
 ## Produces a plot or the response data for system @var{sys}.
 ##
 ## Limited argument checking; ``do not attempt to do this at home''.
 ## Used internally in @command{impulse}, @command{step}. Use @command{step}
 ## or @command{impulse} instead.
+## @seealso{step, impulse}
 ## @end deftypefn
-##
-## @seealso{step, impulse}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = __stepimp__ (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
diff --git a/scripts/control/base/are.m b/scripts/control/base/are.m
--- a/scripts/control/base/are.m
+++ b/scripts/control/base/are.m
@@ -55,20 +55,18 @@
 ## @item x
 ## solution of the @acronym{ARE}.
 ## @end table
 ##
 ## @strong{Method}
 ## Laub's Schur method (@acronym{IEEE} Transactions on
 ## Automatic Control, 1979) is applied to the appropriate Hamiltonian
 ## matrix.
-##
+## @seealso{balance, dare}
 ## @end deftypefn
-##
-## @seealso{balance and dare}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = are (a, b, c, opt)
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
diff --git a/scripts/control/base/controldemo.m b/scripts/control/base/controldemo.m
--- a/scripts/control/base/controldemo.m
+++ b/scripts/control/base/controldemo.m
@@ -15,18 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} controldemo ()
 ## Control Systems Toolbox demo.
+## @seealso{Demo programs: bddemo, frdemo, analdemo, moddmeo, rldemo}
 ## @end deftypefn
-##
-## @seealso{Demo programs: bddemo, frdemo, analdemo, moddmeo, rldemo}
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function controldemo ()
   DEMOcontrol ();
 endfunction
diff --git a/scripts/control/base/damp.m b/scripts/control/base/damp.m
--- a/scripts/control/base/damp.m
+++ b/scripts/control/base/damp.m
@@ -20,19 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} damp (@var{p}, @var{tsam})
 ## Displays eigenvalues, natural frequencies and damping ratios
 ## of the eigenvalues of a matrix @var{p} or the @math{A} matrix of a
 ## system @var{p}, respectively.
 ## If @var{p} is a system, @var{tsam} must not be specified.
 ## If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
 ## of @var{p} are assumed to be in @var{z}-domain.
+## @seealso{eig}
 ## @end deftypefn
-##
-## @seealso{eig}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 29, 1997.
 
 function damp (p, tsam)
 
   ## assume a continuous system
   DIGITAL = 0;
diff --git a/scripts/control/base/dare.m b/scripts/control/base/dare.m
--- a/scripts/control/base/dare.m
+++ b/scripts/control/base/dare.m
@@ -64,20 +64,18 @@
 ##
 ## @strong{Method}
 ## Generalized eigenvalue approach (Van Dooren; @acronym{SIAM} J.
 ##  Sci. Stat. Comput., Vol 2) applied  to the appropriate symplectic pencil.
 ##
 ##  See also: Ran and Rodman, @cite{Stable Hermitian Solutions of Discrete
 ##  Algebraic Riccati Equations}, Mathematics of Control, Signals and
 ##  Systems, Vol 5, no 2 (1992), pp 165--194.
-##
+## @seealso{balance, are}
 ## @end deftypefn
-##
-## @seealso{balance and are}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = dare (a, b, q, r, opt)
 
   if (nargin == 4 | nargin == 5)
diff --git a/scripts/control/base/impulse.m b/scripts/control/base/impulse.m
--- a/scripts/control/base/impulse.m
+++ b/scripts/control/base/impulse.m
@@ -41,19 +41,18 @@
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item y
 ## Values of the impulse response.
 ## @item t
 ## Times of the impulse response.
 ## @end table
+## @seealso{step, __stepimp__}
 ## @end deftypefn
-##
-## @seealso{step, __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
 function [y, t] = impulse (sys, inp, tstop, n)
 
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -56,19 +56,18 @@
 ## Solution of control (state feedback) algebraic Riccati equation.
 ## @item    q1
 ## Solution of estimation algebraic Riccati equation.
 ## @item    ee
 ## Estimator poles.
 ## @item    es
 ## Controller poles.
 ## @end table
+## @seealso{h2syn, lqe, lqr}
 ## @end deftypefn
-##
-## @seealso{h2syn, lqe, and lqr}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## revised for new system format August 1996
 
 function [K, Q1, P1, Ee, Er] = lqg (sys, Sigw, Sigv, Q, R, input_list)
 
   if ( (nargin < 5) | (nargin > 6))
diff --git a/scripts/control/base/step.m b/scripts/control/base/step.m
--- a/scripts/control/base/step.m
+++ b/scripts/control/base/step.m
@@ -43,19 +43,18 @@
 ## @table @var
 ## @item y
 ## Values of the step response.
 ## @item t
 ## Times of the step response.
 ## @end table
 ##
 ## When invoked with the output parameter @var{y} the plot is not displayed.
+## @seealso{impulse, __stepimp__}
 ## @end deftypefn
-##
-## @seealso{impulse and __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
 
   if ((nargin < 1) || (nargin > 4))
diff --git a/scripts/control/system/abcddim.m b/scripts/control/system/abcddim.m
--- a/scripts/control/system/abcddim.m
+++ b/scripts/control/system/abcddim.m
@@ -53,20 +53,18 @@
 ##
 ## @item p
 ## The number of system outputs.
 ## @end table
 ##
 ## Otherwise @code{abcddim} returns @var{n} = @var{m} = @var{p} = @minus{}1.
 ##
 ## Note: n = 0 (pure gain block) is returned without warning.
-##
+## @seealso{is_abcd}
 ## @end deftypefn
-##
-## @seealso{is_abcd}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993.
 ## a s hodel: modified to accept pure-gain systems aug 1996
 
 function [n, m, p] = abcddim (a, b, c, d)
 
   if (nargin != 4)
diff --git a/scripts/control/system/is_abcd.m b/scripts/control/system/is_abcd.m
--- a/scripts/control/system/is_abcd.m
+++ b/scripts/control/system/is_abcd.m
@@ -18,19 +18,18 @@
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} is_abcd (@var{a}, @var{b}, @var{c}, @var{d})
 ##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b},
 ##  @var{c}, @var{d} are compatible, otherwise @var{retval} = 0 with an
 ##  appropriate diagnostic message printed to the screen.  The matrices
 ##  @var{b}, @var{c}, or @var{d} may be omitted.
+## @seealso{abcddim}
 ## @end deftypefn
-##
-## @seealso{abcddim}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function retval = is_abcd (a, b, c, d)
 
   retval = 0;
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -48,20 +48,19 @@
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace
 ## @example
 ## span ([b,a*b,...,a^@{n-1@}*b]).
 ## @end example
 ## The Arnoldi iteration is executed with @code{krylov} if the system
 ## has a single input; otherwise a block Arnoldi iteration is performed
 ## with @code{krylovb}.
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
+## is_observable, is_stabilizable, is_detectable, krylov, krylovb}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
-## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -23,22 +23,19 @@
 ## Test for detactability (observability of unstable modes) of (@var{a}, @var{c}).
 ##
 ## Returns 1 if the system @var{a} or the pair (@var{a}, @var{c}) is
 ## detectable, 0 if not, and -1 if the system has unobservable modes at the
 ## imaginary axis (unit circle for discrete-time systems).
 ##
 ## @strong{See} @command{is_stabilizable} for detailed description of
 ## arguments and computational method.
-##
-##
+## @seealso{is_stabilizable, size, rows, columns, length, ismatrix,
+## isscalar, isvector}
 ## @end deftypefn
-##
-## @seealso{is_stabilizable, size, rows, columns, length, ismatrix,
-## isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol, dflg)
 
   if( nargin < 1)
diff --git a/scripts/control/system/is_observable.m b/scripts/control/system/is_observable.m
--- a/scripts/control/system/is_observable.m
+++ b/scripts/control/system/is_observable.m
@@ -24,19 +24,18 @@
 ##
 ## Default: tol = @code{tol = 10*norm(a,'fro')*eps}
 ##
 ## Returns 1 if the system @var{sys} or the pair (@var{a}, @var{c}) is
 ## observable, 0 if not.
 ##
 ## See @command{is_controllable} for detailed description of arguments
 ## and default values.
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, ismatrix, isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
   if( nargin < 1)
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -30,20 +30,19 @@
 ## @tex
 ## @var{dflg}$\neq$0
 ## @end tex
 ## @end iftex
 ## @ifinfo 
 ## @var{dflg}!=0
 ## @end ifinfo
 ## assume that discrete-time matrices (a,b) are supplied.
-## @end deftypefn
-##
 ## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
 ## is_observable, is_stabilizable, is_detectable}
+## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function retval = is_stabilizable (a, b, tol, dflg)
 
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -32,20 +32,19 @@
 ## @table @code
 ## @item @var{dflg} != 0
 ## stable if eig(a) is in the unit circle
 ##
 ## @item @var{dflg} == 0
 ## stable if eig(a) is in the open LHP (default)
 ## @end table
 ## @end table
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
+## is_observable, is_stabilizable, is_detectable, krylov, krylovb}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
-## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
diff --git a/scripts/control/system/jet707.m b/scripts/control/system/jet707.m
--- a/scripts/control/system/jet707.m
+++ b/scripts/control/system/jet707.m
@@ -30,19 +30,18 @@
 ## (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
 ## @end ifinfo
 ##
 ## System inputs: (1) thrust and (2) elevator angle.
 ##
 ## System outputs:  (1) airspeed and (2) pitch angle.
 ##
 ## @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight Control), Springer, 1994.
+## @seealso{ord2}
 ## @end deftypefn
-##
-## @seealso{ord2}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = jet707 ()
 
   if (nargin != 0)
     usage("outsys = jet707()")
diff --git a/scripts/control/system/sys2fir.m b/scripts/control/system/sys2fir.m
--- a/scripts/control/system/sys2fir.m
+++ b/scripts/control/system/sys2fir.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{c}, @var{tsam}, @var{input}, @var{output}] =} sys2fir (@var{sys})
 ##
 ## Extract @acronym{FIR} data from system data structure; see @command{fir2sys} for
 ## parameter descriptions.
+## @seealso{fir2sys}
 ## @end deftypefn
-##
-## @seealso{fir2sys}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function [c, tsam, inname, outname] = sys2fir (sys)
 
   ## let sys2tf do most of the work
 
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -58,19 +58,18 @@
 ##  number of system inputs
 ## @item  p
 ##  number of system outputs
 ## @item  yd
 ##  binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @math{yd(ii) = 0} if output @var{ii} is continous
 ## @end table
+## @seealso{sysgetsignals, sysgettsam}
 ## @end deftypefn
-##
-## @seealso{sysgetsignals and sysgettsam}
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
     usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
   elseif(!isstruct(sys))
     usage("[n,nz,m,p] = sysdimensions(sys)");
   elseif(nargin == 1)
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -43,19 +43,18 @@
 ## @table @var
 ## @item retsys
 ## Contains union of data in sys and requested data.
 ## If requested data in @var{sys} is already up to date then @var{retsys}=@var{sys}.
 ## @end table
 ##
 ## Conversion to @command{tf} or @command{zp} exits with an error if the system is
 ## mixed continuous/digital.
+## @seealso{tf, ss, zp, sysout, sys2ss, sys2tf, sys2zp}
 ## @end deftypefn
-##
-## @seealso{tf, ss, zp, sysout, sys2ss, sys2tf, and sys2zp}
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs
   if (nargin != 2)
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -16,20 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tfout (@var{num}, @var{denom}, @var{x})
 ## Print formatted transfer function @math{n(s)/d(s)} to the screen.
 ## @var{x} defaults to the string @code{"s"}
+## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
+## filter, polyderiv, polyinteg, polyout}
 ## @end deftypefn
-##
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
-## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function tfout (num, denom, x)
 
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
     usage("tfout(num,denom[,x])");
diff --git a/scripts/control/system/ugain.m b/scripts/control/system/ugain.m
--- a/scripts/control/system/ugain.m
+++ b/scripts/control/system/ugain.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ugain (@var{n})
 ## Creates a system with unity gain, no states.
 ## This trivial system is sometimes needed to create arbitrary
 ## complex systems from simple systems with @command{buildssic}.
 ## Watch out if you are forming sampled systems since @command{ugain}
 ## does not contain a sampling period.
+## @seealso{hinfdemo, jet707}
 ## @end deftypefn
-##
-## @seealso{hinfdemo and jet707}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
 
   if (nargin != 1 || nargout > 1)
     usage ("outsys = ugain(n)");
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -16,20 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} zpout (@var{zer}, @var{pol}, @var{k}, @var{x})
 ## print formatted zero-pole form to the screen.
 ## @var{x} defaults to the string @code{"s"}
+## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
+## filter, polyderiv, polyinteg, polyout}
 ## @end deftypefn
-##
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
-## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
     usage("zpout(zer,pol,k[,x])");
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -29,19 +29,18 @@
 ## @noindent
 ## is the same as
 ##
 ## @example
 ## lcm ([a1, ..., ak]).
 ## @end example
 ##
 ## All elements must be the same size or scalar.
+## @seealso{gcd, min, max, ceil, floor}
 ## @end deftypefn
-##
-## @seealso{gcd, min, max, ceil, and floor}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (varargin)
 
   if (nargin == 0)
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -18,19 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} irr (@var{p}, @var{i})
 ## Return the internal rate of return of a series of payments @var{p}
 ## from an initial investment @var{i} (i.e., the solution of
 ## @code{npv (r, p) = i}.  If the second argument is omitted, a value of
 ## 0 is used.
+## @seealso{npv, pv, rate}
 ## @end deftypefn
-##
-## @seealso{npv, pv, and rate}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Internal rate of return of an investment
 
 function r = irr (p, i)
 
   if (nargin == 1)
     i = 0;
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -26,19 +26,18 @@
 ## lump-sum payment of @var{l} made at the end of the amortization time.
 ##
 ## The optional argument @var{method} may be used to specify whether
 ## payments are made at the end (@var{"e"}, default) or at the beginning
 ## (@var{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
+## @seealso{pv, pmt, rate, npv}
 ## @end deftypefn
-##
-## @seealso{pv, pmt, rate, and npv}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("nper (r, p, a, l, method)");
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -25,19 +25,18 @@
 ## can either be a scalar (constant rates) or a vector of the same
 ## length as @var{p}.
 ##
 ## The optional argument @var{i} may be used to specify an initial
 ## investment.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
+## @seealso{irr, pv}
 ## @end deftypefn
-##
-## @seealso{irr and pv}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Net present value of a series of payments
 
 function v = npv (r, p, i)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("npv (r, p, i");
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -23,19 +23,18 @@
 ## of amount a with interest rate @var{r} in @var{n} periods.
 ##
 ## The optional argument @var{l} may be used to specify a terminal
 ## lump-sum payment.
 ##
 ## The optional argument @var{method} may be used to specify whether
 ## payments are made at the end (@var{"e"}, default) or at the beginning
 ## (@var{"b"}) of each period.
+## @seealso{pv, nper, rate}
 ## @end deftypefn
-##
-## @seealso{pv, nper, and rate}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
 
   if (nargin < 3 || nargin > 5)
     usage ("pmt (r, n, a, l, method)");
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -26,19 +26,18 @@
 ## lump-sum payment made at the end of @var{n} periods.
 ##
 ## The optional argument @var{method} may be used to specify whether
 ## payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
+## @seealso{pmt, nper, rate, npv}
 ## @end deftypefn
-##
-## @seealso{pmt, nper, rate, and npv}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Present value of an investment
 
 function v = pv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("pv (r, n, p, l, method)");
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -23,19 +23,18 @@
 ## pays @var{p} in @var{n} consecutive periods.
 ##
 ## The optional argument @var{l} may be used to specify an additional
 ## lump-sum payment made at the end of @var{n} periods.
 ##
 ## The optional string argument @var{method} may be used to specify
 ## whether payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
+## @seealso{pv, pmt, nper, npv}
 ## @end deftypefn
-##
-## @seealso{pv, pmt, nper, and npv}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Rate of return of an investment
 
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("rate (n, p, v, l, method)");
diff --git a/scripts/general/__isequal__.m b/scripts/general/__isequal__.m
--- a/scripts/general/__isequal__.m
+++ b/scripts/general/__isequal__.m
@@ -15,19 +15,18 @@
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __isequal__ (@var{nans_compare_equal}, @var{x1}, @var{x2}, @dots{})
 ## Return true if @var{x1}, @var{x2}, @dots{} are all equal and
 ## @var{nans_compare_equal} evaluates to false.
 ##
 ## If @var{nans_compare_equal} evaluates to true, then assume NaN == NaN.
+## @seealso{isequal, isequalwithequalnans}
 ## @end deftypefn
-##
-## @seealso{isequal, isequalwithequalnans}
 
 ## Modified by: William Poetra Yoga Hadisoeseno
 
 ## Algorithm:
 ##
 ## 1. Determine the class of x
 ## 2. If x is of the struct, cell, list or char class, for each
 ##    argument after x, determine whether it has the same class
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -23,19 +23,18 @@
 ## @example
 ## bitcmp(7,4)
 ## @result{} 8
 ## dec2bin(11)
 ## @result{} 1011
 ## dec2bin(bitcmp(11))
 ## @result{} 11111111111111111111111111110100
 ## @end example
+## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
-##
-## @seealso{bitand,bitor,bitxor,bitset,bitget,bitcmp,bitshift,bitmax}
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitcmp (A, n)
   
   if (nargin < 1 || nargin > 2)
     usage ("bitcmp (A, n)");
   endif
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -19,19 +19,18 @@
 ## @deftypefn {Function File} {@var{X} =} bitget (@var{a},@var{n})
 ## Return the status of bit(s) @var{n} of unsigned integers in @var{a}
 ## the lowest significant bit is @var{n} = 1.
 ##
 ## @example
 ## bitget (100, 8:-1:1)
 ## @result{} 0  1  1  0  0  1  0  0 
 ## @end example
+## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 ## @end deftypefn
-##
-## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitget (A, n)
 
   if (nargin != 2)
     usage ("bitget (A, n)");
   endif
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -21,19 +21,18 @@
 ## Set or reset bit(s) @var{n} of unsigned integers in @var{a}.
 ## @var{v} = 0 resets and @var{v} = 1 sets the bits.
 ## The lowest significant bit is: @var{n} = 1
 ##
 ## @example
 ## dec2bin (bitset (10, 1))
 ## @result{} 1011
 ## @end example
+## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
-##
-## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitset (A, n, value)
 
   if (nargin < 2 || nargin > 3)
     usage ("bitset (A, n, v)");
   endif
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -14,19 +14,18 @@
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blkdiag (@var{a}, @var{b}, @var{c}, ...)
 ## Build a block diagonal matrix from @var{a}, @var{b}, @var{c}, ... .
 ## All the arguments must be numeric and are two-dimensional matrices or
 ## scalars.
+## @seealso{diag, horzcat, vertcat}
 ## @end deftypefn
-##
-## @seealso{diag, horzcat, vertcat}
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
 function retval = blkdiag (varargin)
 
   if (nargin < 1)
     usage ("blkdiag (a, b, c, ...)");
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{x}, @var{y})
 ## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{x}, @var{y}, @var{z})
 ## Transform cartesian to polar or cylindrical coordinates.
 ## @var{x}, @var{y} (and @var{z}) must be of same shape.
 ## @var{theta} describes the angle relative to the x - axis.
 ## @var{r} is the distance to the z - axis (0, 0, z).
+## @seealso{pol2cart, cart2sph, sph2cart}
 ## @end deftypefn
-##
-## @seealso{pol2cart, cart2sph, sph2cart}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [Theta, R, Z] = cart2pol (X, Y, Z)
 
   if (nargin < 2 || nargin > 3)
     error ("cart2pol: number of arguments must be 2 or 3");
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{x}, @var{y}, @var{z})
 ## Transform cartesian to spherical coordinates.
 ## @var{x}, @var{y} and @var{z} must be of same shape.
 ## @var{theta} describes the angle relative to the x - axis.
 ## @var{phi} is the angle relative to the xy - plane.
 ## @var{r} is the distance to the origin (0, 0, 0).
+## @seealso{pol2cart, cart2pol, sph2cart}
 ## @end deftypefn
-##
-## @seealso{pol2cart, cart2pol, sph2cart}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [Theta, Phi, R] = cart2sph (X, Y, Z)
 
   if (nargin != 3)
     usage ("[Theta, Phi, R] = cart2sph (X, Y, Z)")
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -15,19 +15,18 @@
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{m} =} cell2mat (@var{c})
 ## Convert the cell array @var{c} into a matrix by concatenating all
 ## elements of @var{c} into a hyperrectangle.  Elements of @var{c} must
 ## be numeric, logical or char, and @code{cat} must be able to
 ## concatenate them together.
+## @seealso{mat2cell, num2cell}
 ## @end deftypefn
-##
-## @seealso{mat2cell, num2cell}
 
 function m = cell2mat (c)
 
   if (nargin != 1)
     usage ("m = cell2mat (c)");
   endif
 
   if (! iscell (c))
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -38,19 +38,18 @@
 ##     1, 2, 3
 ##     4, 5, 6
 ## circshift (x, [0,1])
 ## @result{}  3, 1, 2
 ##     6, 4, 5
 ##     9, 7, 8
 ## @end group
 ## @end example
+## @seealso {permute, ipermute, shiftdim}
 ## @end deftypefn
-##
-## @seealso {permute, ipermute, shiftdim}
 
 function y = circshift (x, n)
 
   if (nargin == 2)
     nd = ndims (x);
     sz = size (x);
 
     if (! isvector (n) && length (n) > nd)
diff --git a/scripts/general/columns.m b/scripts/general/columns.m
--- a/scripts/general/columns.m
+++ b/scripts/general/columns.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} columns (@var{a})
 ## Return the number of columns of @var{a}.
+## @seealso{size, rows, length, isscalar, isvector, ismatrix}
 ## @end deftypefn
-##
-## @seealso{size, rows, length, isscalar, isvector, and ismatrix}
 
 ## Author: jwe
 
 function nc = columns (x)
 
   if (nargin != 1)
     usage ("columns (x)");
   endif
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -24,19 +24,18 @@
 ##
 ## @example
 ## @group
 ## flipdim ([1, 2; 3, 4], 2)
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
+## @seealso{fliplr, flipud, rot90, rotdim}
 ## @end deftypefn
-##
-## @seealso{fliplr, flipud, rot90 and rotdim}
 
 ## Author: David Bateman
 
 function y = flipdim (x, dim)
 
   if (nargin != 1 && nargin != 2)
     usage ("flipdim (x, dim)");
   endif
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -27,19 +27,18 @@
 ## fliplr ([1, 2; 3, 4])
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
 ##
 ## Note that @code{fliplr} only work with 2-D arrays.  To flip N-d arrays
 ## use @code{flipdim} instead.
+## @seealso{flipud, flipdim, rot90, rotdim}
 ## @end deftypefn
-##
-## @seealso{flipud, flipdim, rot90 and rotdim}
 
 ## Author: jwe
 
 function y = fliplr (x)
 
   if (nargin != 1)
     usage ("fliplr (x)");
   endif
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -28,19 +28,18 @@
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ##
 ## Due to the difficulty of defining which axis about which to flip the 
 ## matrix @code{flipud} only work with 2-d arrays.  To flip N-d arrays
 ## use @code{flipdim} instead.
+## @seealso{fliplr, flipdim, rot90, rotdim}
 ## @end deftypefn
-##
-## @seealso{fliplr, flipdim, rot90 and rotdim}
 
 ## Author: jwe
 
 function y = flipud (x)
 
   if (nargin != 1)
     usage ("flipud (x)");
   endif
diff --git a/scripts/general/ind2sub.m b/scripts/general/ind2sub.m
--- a/scripts/general/ind2sub.m
+++ b/scripts/general/ind2sub.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})
 ## Convert a linear index into subscripts.
+## @seealso{sub2ind}
 ## @end deftypefn
-##
-## @seealso{sub2ind}
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Adapted-by: jwe
 
 function varargout = ind2sub (dims, ind)
 
   if (nargin == 2)
     if (isvector (dims) && round (dims) == dims)
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{precision})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{format})
 ## Convert a number to a string.  These functions are not very flexible,
 ## but are provided for compatibility with @sc{Matlab}.  For better control
 ## over the results, use @code{sprintf} (@pxref{Formatted Output}).
+## @seealso{sprintf, num2str}
 ## @end deftypefn
-##
-## @seealso{sprintf and num2str}
 
 ## Author: jwe
 
 function retval = int2str (x)
 
   if (nargin == 1)
     x = round (real(x));
     sz = size(x);
@@ -88,9 +87,9 @@ function fmt = get_fmt (x, sep)
       fw = max (tfw);
       if (any (t(tfw == fw) < 0))
 	fw++;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/general/isdefinite.m b/scripts/general/isdefinite.m
--- a/scripts/general/isdefinite.m
+++ b/scripts/general/isdefinite.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isdefinite (@var{x}, @var{tol})
 ## Return 1 if @var{x} is symmetric positive definite within the
 ## tolerance specified by @var{tol} or 0 if @var{x} is symmetric
 ## positive semidefinite.  Otherwise, return -1.  If @var{tol}
-## is omitted, use a tolerance equal to 100 times the machine precision.  
+## is omitted, use a tolerance equal to 100 times the machine precision.
+## @seealso{issymmetric}
 ## @end deftypefn
-##
-## @seealso{issymmetric}
 
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
 ## Adapted-By: jwe
 
 function retval = isdefinite (x, tol)
 
   if (nargin == 1 || nargin == 2)
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -14,19 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; if not, write to the Free Software
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequal (@var{x1}, @var{x2}, @dots{})
 ## Return true if all of @var{x1}, @var{x2}, @dots{} are equal.
+## @seealso{isequalwithequalnans}
 ## @end deftypefn
-##
-## @seealso{isequalwithequalnans}
 
 function retval = isequal (x, varargin)
 
   if (nargin > 1)
     retval = __isequal__ (0, x, varargin{:});
   else
     usage ("isequal (x1, x2, ...)");
   endif
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; if not, write to the Free Software
 ## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequalwithequalnans (@var{x1}, @var{x2}, @dots{})
 ## Assuming NaN == NaN, return true if all of @var{x1}, @var{x2}, @dots{}
 ## are equal.
+## @seealso{isequal}
 ## @end deftypefn
-##
-## @seealso{isequal}
 
 function retval = isequalwithequalnans (x, varargin)
 
   if (nargin > 1)
     retval = __isequal__ (1, x, varargin{:});
   else
     usage ("isequalwithequalnans (x1, x2, ...)");
   endif
diff --git a/scripts/general/isscalar.m b/scripts/general/isscalar.m
--- a/scripts/general/isscalar.m
+++ b/scripts/general/isscalar.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isscalar (@var{a})
 ## Return 1 if @var{a} is a scalar.  Otherwise, return 0.
+## @seealso{size, rows, columns, length, isscalar, ismatrix}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, isscalar, and ismatrix}
 
 ## Author: jwe
 
 function retval = isscalar (x)
 
   retval = 0;
 
   if (nargin == 1)
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} issquare (@var{x})
 ## If @var{x} is a square matrix, then return the dimension of @var{x}.
 ## Otherwise, return 0.
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, ismatrix, isscalar, and isvector}
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = issquare (x)
 
   retval = 0;
diff --git a/scripts/general/issymmetric.m b/scripts/general/issymmetric.m
--- a/scripts/general/issymmetric.m
+++ b/scripts/general/issymmetric.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} issymmetric (@var{x}, @var{tol})
 ## If @var{x} is symmetric within the tolerance specified by @var{tol},
 ## then return the dimension of @var{x}.  Otherwise, return 0.  If
 ## @var{tol} is omitted, use a tolerance equal to the machine precision.
+## @seealso{size, rows, columns, length, ismatrix, isscalar,
+## issquare, isvector}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, ismatrix, isscalar,
-## issquare, and isvector}
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = issymmetric (x,tol)
 
   if (nargin == 1 || nargin == 2)
diff --git a/scripts/general/isvector.m b/scripts/general/isvector.m
--- a/scripts/general/isvector.m
+++ b/scripts/general/isvector.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isvector (@var{a})
 ## Return 1 if @var{a} is a vector.  Otherwise, return 0.
+## @seealso{size, rows, columns, length, isscalar, ismatrix}
 ## @end deftypefn
-##
-## @seealso{size, rows, columns, length, isscalar, and ismatrix}
 
 ## Author: jwe
 
 function retval = isvector (x)
 
   retval = 0;
 
   if (nargin == 1)
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -53,19 +53,18 @@
 ## @tex
 ## $10^{base}$ and $10^{\pi}$,
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## 10^base and 10^pi,
 ## @end ifinfo
 ## in order to  be compatible with the corresponding @sc{Matlab} function.
+## @seealso{linspace}
 ## @end deftypefn
-##
-## @seealso{linspace}
 
 ## Author: jwe
 
 function retval = logspace (x1, x2, n)
 
   if (nargin == 2)
     npoints = 50;
   elseif (nargin == 3)
diff --git a/scripts/general/mod.m b/scripts/general/mod.m
--- a/scripts/general/mod.m
+++ b/scripts/general/mod.m
@@ -26,19 +26,18 @@
 ## @end example
 ##
 ## Note that this handles negative numbers correctly:
 ## @code{mod (-1, 3)} is 2, not -1 as @code{rem (-1, 3)} returns.
 ## Also, @code{mod (@var{x}, 0)} returns @var{x}.
 ##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
+## @seealso{rem, round}
 ## @end deftypefn
-##
-## @seealso{rem, round}
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Modified by: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Adapted by: jwe
 
 function r = mod (x, y)
 
   if (nargin != 2)
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -25,19 +25,18 @@
 ##  $2^n \ge |x|$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  2^n >= abs (x).
 ## @end ifinfo
 ##
 ## If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
+## @seealso{pow2}
 ## @end deftypefn
-##
-## @seealso{pow2}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
 
   if (nargin != 1)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{precision})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{format})
 ## Convert a number to a string.  These functions are not very flexible,
 ## but are provided for compatibility with @sc{Matlab}.  For better control
 ## over the results, use @code{sprintf} (@pxref{Formatted Output}).
+## @seealso{sprintf, int2str}
 ## @end deftypefn
-##
-## @seealso{sprintf and int2str}
 
 ## Author: jwe
 
 function retval = num2str (x, arg)
 
   if (nargin != 1 && nargin != 2)
     usage ("num2str (x) or num2str (x, precision) or num2str (x, fmt)");
   endif
diff --git a/scripts/general/perror.m b/scripts/general/perror.m
--- a/scripts/general/perror.m
+++ b/scripts/general/perror.m
@@ -18,19 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} perror (@var{name}, @var{num})
 ## Print the error message for function @var{name} corresponding to the
 ## error number @var{num}.  This function is intended to be used to print
 ## useful error messages for those functions that return numeric error
 ## codes.
+## @seealso{strerror}
 ## @end deftypefn
-##
-## @seealso{strerror}
 
 ## Author: jwe
 
 function perror (name, err)
 
   if (nargin != 2)
     usage ("perror (name, err)");
   else
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{theta}, @var{r})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{theta}, @var{r}, @var{z})
 ## Transform polar or cylindrical to cartesian coordinates.
 ## @var{theta}, @var{r} (and @var{z}) must be of same shape.
 ## @var{theta} describes the angle relative to the x - axis.
 ## @var{r} is the distance to the z - axis (0, 0, z).
+## @seealso{cart2pol, cart2sph, sph2cart}
 ## @end deftypefn
-##
-## @seealso{cart2pol, cart2sph, sph2cart}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [X, Y, Z] = pol2cart (Theta, R, Z)
 
   if (nargin < 2 || nargin > 3)
     error ("pol2cart: number of arguments must be 2 or 3");
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -23,19 +23,18 @@
 ## expression
 ##
 ## @example
 ## x - y .* fix (x ./ y)
 ## @end example
 ##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
+## @seealso{mod, round}
 ## @end deftypefn
-##
-## @seealso{mod, round}
 
 ## Author: jwe
 
 function r = rem (x, y)
 
   if (nargin != 2)
     usage ("rem (x, y)");
   endif
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -43,19 +43,18 @@
 ## rot90 ([1, 2; 3, 4], 3)
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
 ## @end example
 ##
 ## Due to the difficulty of defining an axis about which to rotate the 
 ## matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
 ## use @code{rotdim} instead.
+## @seealso{rotdim, flipud, fliplr, flipdim}
 ## @end deftypefn
-##
-## @seealso{rotdim, flipud, fliplr and flipdim}
 
 ## Author: jwe
 
 function y = rot90 (x, k)
 
   if (nargin == 1 || nargin == 2)
     if (nargin < 2)
       k = 1;
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -44,19 +44,18 @@
 ##
 ## @example
 ## @group
 ## rotdim ([1, 2; 3, 4], -1, [1, 2])
 ## rotdim ([1, 2; 3, 4], 3, [1, 2])
 ## rotdim ([1, 2; 3, 4], 7, [1, 2])
 ## @end group
 ## @end example
+## @seealso{rot90, flipud, fliplr, flipdim}
 ## @end deftypefn
-##
-## @seealso{rot90, flipud, fliplr and flipdim}
 
 function y = rotdim (x, k, plane)
   
   if (nargin < 1 || nargin > 3)
     usage ("rotdim (x, k, plane)");
   endif
 
   if (nargin > 1 && ! isempty(k))
diff --git a/scripts/general/rows.m b/scripts/general/rows.m
--- a/scripts/general/rows.m
+++ b/scripts/general/rows.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rows (@var{a})
 ## Return the number of rows of @var{a}.
+## @seealso{size, columns, length, isscalar, isvector, ismatrix}
 ## @end deftypefn
-##
-## @seealso{size, columns, length, isscalar, isvector, and ismatrix}
 
 ## Author: jwe
 
 function nr = rows (x)
 
   if (nargin != 1)
     usage ("rows (x)");
   endif
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -40,19 +40,18 @@
 ##      @result{} [2, 3, 1]
 ## size (shiftdim (x, 1))
 ##      @result{} [1, 1, 2, 3]
 ## [b, ns] = shiftdim (x);
 ##      @result{} b =  [1, 1, 1; 1, 1, 1]
 ##      @result{} ns = 1
 ## @end group
 ## @end example
+## @seealso {reshape, permute, ipermute, circshift, squeeze}
 ## @end deftypefn
-##
-## @seealso {reshape, permute, ipermute, circshift, squeeze}
 
 function [y, ns]  = shiftdim (x, n)
 
   if (nargin < 1 || nargin > 2)
     usage ("shiftdim (x, n) or [b, ns] = shiftdim (x)");
   endif
 
   nd = ndims (x);
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{theta}, @var{phi}, @var{r})
 ## Transform spherical to cartesian coordinates.
 ## @var{x}, @var{y} and @var{z} must be of same shape.
 ## @var{theta} describes the angle relative to the x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
 ## @var{r} is the distance to the origin (0, 0, 0).
+## @seealso{pol2cart, cart2pol, cart2sph}
 ## @end deftypefn
-##
-## @seealso{pol2cart, cart2pol, cart2sph}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [X, Y, Z] = sph2cart (Theta, Phi, R)
 
   if (nargin != 3)
     usage ("[X, Y, Z] = sph2cart (Theta, Phi, R)");
diff --git a/scripts/general/sub2ind.m b/scripts/general/sub2ind.m
--- a/scripts/general/sub2ind.m
+++ b/scripts/general/sub2ind.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})
 ## @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})
 ## Convert subscripts into a linear index.
+## @seealso{ind2sub}
 ## @end deftypefn
-##
-## @seealso{ind2sub}
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Adapted-by: jwe
 
 function ind = sub2ind (dims, varargin)
 
   if (nargin > 1)
     if (isvector (dims) && round (dims) == dims)
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -54,19 +54,18 @@
 ## @example
 ## @group
 ## tril (ones (3), 1)
 ##      @result{}  1  1  0
 ##          1  1  1
 ##          1  1  1
 ## @end group
 ## @end example
+## @seealso{triu, diag}
 ## @end deftypefn
-##
-## @seealso{triu and diag}
 
 ## Author: jwe
 
 function retval = tril (x, k)
 
   if (nargin > 0)
     [nr, nc] = size (x);
     if (isa (x, "sparse"))
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} @var{rgb_map} = hsv2rgb (@var{hsv_map})
 ## Transform a colormap from the hsv space to the rgb space. 
+## @seealso{rgb2hsv}
 ## @end deftypefn
-##
-## @seealso{rgb2hsv}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
 
 ## each color value x=(r,g,b) is calculated with
 ## x = (1-sat)*val+sat*val*f_x(hue)
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -25,19 +25,18 @@
 ## length of the colormap.  If @var{zoom} is omitted, the image will be
 ## scaled to fit within 600x350 (to a max of 4).
 ##
 ## It first tries to use @code{display} from @code{ImageMagick} then
 ## @code{xv} and then @code{xloadimage}.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}. At present they are ignored.
+## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
-##
-## @seealso{imshow, imagesc, and colormap}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function image (x, y, A, zoom)
 
   if (nargin == 0)
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -29,19 +29,18 @@
 ## comfortable size is chosen.  If @var{limits} = [@var{lo}, @var{hi}] are
 ## given, then that range maps into the full range of the colormap rather 
 ## than the minimum and maximum values of @var{A}.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{A}.  At present they are ignored.
+## @seealso{image, imshow}
 ## @end deftypefn
-##
-## @seealso{image and imshow}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function ret = imagesc (x, y, A, zoom, limits)
 
   if (nargin < 1 || nargin > 5)
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -36,18 +36,18 @@
 ##
 ## @code{imshow (@var{i}, @var{n})} displays a gray scale intensity image of
 ## N levels.
 ##
 ## @code{imshow (@var{r}, @var{g}, @var{b})} displays an RGB image.
 ##
 ## The character string @code{"truesize"} can always be used as an
 ## optional final argument to prevent automatic zooming of the image.
+## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
-## @seealso{image, imagesc, colormap, gray2ind, and rgb2ind}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function imshow (varargin)
 
   usage_str = "imshow (x) or imshow (x, map) or imshow (i, N) or imshow (r, g, b)";
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ind2gray (@var{x}, @var{map})
 ## Convert an Octave indexed image to a gray scale intensity image.
 ## If @var{map} is omitted, the current colormap is used to determine the
 ## intensities.
+## @seealso{gray2ind, rgb2ntsc, image, colormap}
 ## @end deftypefn
-##
-## @seealso{gray2ind, rgb2ntsc, image, and colormap}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function Y = ind2gray (X, map)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{g}, @var{b}] =} ind2rgb (@var{x}, @var{map})
 ## Convert an indexed image to red, green, and blue color components.
 ## If @var{map} is omitted, the current colormap is used for the conversion.
+## @seealso{rgb2ind, image, imshow, ind2gray, gray2ind}
 ## @end deftypefn
-##
-## @seealso{rgb2ind, image, imshow, ind2gray, and gray2ind}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (X, map)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} loadimage (@var{file})
 ## Load an image file and it's associated color map from the specified
 ## @var{file}.  The image must be stored in Octave's image format.
+## @seealso{saveimage, load, save}
 ## @end deftypefn
-##
-## @seealso{saveimage, load, and save}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [img_retval, map_retval] = loadimage (filename)
 
   if (nargin != 1)
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -21,20 +21,19 @@
 ## @deftypefn {Function File} {} @var{hsv_map} = rgb2hsv (@var{rgb_map})
 ## Transform a colormap from the rgb space to the hsv space.
 ##
 ## A color n the RGB space consists of the red, green and blue intensities.
 ##
 ## In the HSV space each color is represented by their hue, saturation
 ## and value (brightness).  Value gives the amount of light in the color.
 ## Hue describes the dominant wavelegth. 
-## Saturation is the amount of Hue mixed into the color. 
+## Saturation is the amount of Hue mixed into the color.
+## @seealso{hsv2rgb}
 ## @end deftypefn
-##
-## @seealso{hsv2rgb}
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsval = rgb2hsv (rgb)
 
   if (nargin != 1)
     usage ("hsv_map = rgb2hsv (rgb_map)");
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{r}, @var{g}, @var{b})
 ## Convert and RGB image to an Octave indexed image.
+## @seealso{ind2rgb, rgb2ntsc}
 ## @end deftypefn
-##
-## @seealso{ind2rgb and rgb2ntsc}
 
 ## Bugs: The color map may have duplicate entries.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = rgb2ind (R, G, B)
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -37,19 +37,18 @@
 ## If the fourth argument is supplied, the specified colormap will also be
 ## saved along with the image.
 ##
 ## Note: if the colormap contains only two entries and these entries are
 ## black and white, the bitmap ppm and PostScript formats are used.  If the
 ## image is a gray scale image (the entries within each row of the colormap
 ## are equal) the gray scale ppm and PostScript image formats are used,
 ## otherwise the full color formats are used.
+## @seealso{loadimage, save, load, colormap}
 ## @end deftypefn
-##
-## @seealso{loadimage, save, load, and colormap}
 
 ## The conversion to PostScript is based on pbmtolps.c, which was
 ## written by
 ##
 ##   George Phillips <phillips@cs.ubc.ca>
 ##   Department of Computer Science
 ##   University of British Columbia
 ##
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} puts (@var{string})
 ## Produce a beep from the speaker (or visual bell).
+## @seealso{puts, fputs, printf, fprintf}
 ## @end deftypefn
-##
-## @seealso{puts, fputs, printf and fprintf}
 
 ## Author: jwe
 
 function beep ()
 
   if (nargin == 0)
     puts ("\a");
   else
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cond (@var{a})
 ## Compute the (two-norm) condition number of a matrix. @code{cond (a)} is
 ## defined as @code{norm (a) * norm (inv (a))}, and is computed via a
 ## singular value decomposition.
+## @seealso{norm, svd, rank}
 ## @end deftypefn
-##
-## @seealso{norm, svd, and rank}
 
 ## Author: jwe
 
 function retval = cond (a)
 
   if (nargin == 1)
     if (ndims (a) > 2)
       error ("cond: Only valid on 2-D objects")
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -47,19 +47,18 @@
 ## @code{max (abs (@var{a}))}.
 ##
 ## @item @var{p} = @code{-Inf}
 ## @code{min (abs (@var{a}))}.
 ##
 ## @item other
 ## p-norm of @var{a}, @code{(sum (abs (@var{a}) .^ @var{p})) ^ (1/@var{p})}.
 ## @end table
+## @seealso{cond, svd}
 ## @end deftypefn
-##
-## @seealso{cond and svd}
 
 ## Author: jwe
 
 function retval = norm (x, p)
 
   if (nargin < 1 || nargin > 2)
     usage ("norm (x, p)");
   endif
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -15,11 +15,10 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deffn {Operator} ,
 ## Array index, function argument, or command separator.
+## @seealso{semicolon}
 ## @end deffn
-##
-## @seealso{semicolon}
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -34,20 +34,18 @@
 ## @end example
 ##
 ## @noindent
 ## in which @code{statinfo} is the structure returned from @code{stat}.
 ##
 ## If @var{directory} is not a directory, return information about the
 ## named file.
 ## @var{filename}.
-##
 ## @seealso{ls, stat, readdir, glob, filesep}
 ## @end deftypefn
-##
 
 ## Author: jwe
 
 ## XXX FIXME XXX -- this is quite slow for large directories, so perhaps
 ## it should be converted to C++.
 
 function retval = dir (file)
 
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -44,18 +44,18 @@
 ## Future tests for the specified license of @var{feature} return 0.
 ## @end table
 ##
 ## @deftypefnx {Function File} {@var{retval}} = license ("checkout", @var{feature})
 ## Check out a license for @var{feature}, returning 1 on success and 0
 ## on failure.
 ##
 ## This function is provided for compatibility with @sc{Matlab}.
+## @seealso{ver, version}
 ## @end deftypefn
-## @seealso{ver, version}
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function retval = license (varargin)
 
   persistent __octave_licenses__;
 
   if (isempty (__octave_licenses__))
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -20,19 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} menu (@var{title}, @var{opt1}, @dots{})
 ## Print a title string followed by a series of options.  Each option will
 ## be printed along with a number.  The return value is the number of the
 ## option selected by the user.  This function is useful for interactive
 ## programs.  There is no limit to the number of options that may be passed
 ## in, but it may be confusing to present more than will fit easily on one
 ## screen.
+## @seealso{disp, printf, input}
 ## @end deftypefn
-##
-## @seealso{disp, printf, and input}
 
 ## Author: jwe
 
 function num = menu (t, varargin)
 
   if (nargin < 2)
     usage ("menu (title, opt1, ...)");
   endif
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -15,11 +15,10 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deffn {Operator} ;
 ## Array row or command separator.
+## @seealso{comma}
 ## @end deffn
-##
-## @seealso{comma}
diff --git a/scripts/miscellaneous/texas_lotto.m b/scripts/miscellaneous/texas_lotto.m
--- a/scripts/miscellaneous/texas_lotto.m
+++ b/scripts/miscellaneous/texas_lotto.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} texas_lotto ()
 ## Pick 6 unique numbers between 1 and 50 that are guaranteed to win
 ## the Texas Lotto.
+## @seealso{rand}
 ## @end deftypefn
-##
-## @seealso{rand}
 
 ## Author: jwe
 
 function picks = texas_lotto ()
 
   if (nargin != 0)
     warning ("win_texas_lotto: ignoring extra arguments");
   endif
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -20,19 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{status}, @var{text}]} unix (@var{command})
 ## @deftypefnx {Function File} {[@var{status}, @var{text}]} unix (@var{command}, "-echo")
 ## Execute a system command if running under a Unix-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
 ## in @var{status} and any output sent to the standard output in
 ## @var{text}.  If the optional second argument @code{"-echo"} is given,
 ## then also send the output from the command to the standard output.
+## @seealso{isunix, ispc, system}
 ## @end deftypefn
-##
-## @seealso{isunix, ispc, system}
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = unix (cmd, echo_arg)
 
   if (nargin < 1 || nargin > 2)
     usage ( "[status, text] = unix (cmd, '-echo')");
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -17,18 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ver
 ## @code{ver} displays a header containing the current Octave version
 ## number, license string and operating system, followed by the version
 ## number for octave-forge, if installed.
+## @seealso{license, version}
 ## @end deftypefn
-## @seealso{license, version}
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function ver ()
 
   if (nargin > 0)
     usage ("ver");
   endif
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -157,18 +157,18 @@
 ## @code{sqrt (eps)}---edit @file{sqp.m} to modify this value.
 ## @item 102
 ## The BFGS update failed.
 ## @item 103
 ## The maximum number of iterations was reached (the maximum number of
 ## allowed iterations is currently fixed at 100---edit @file{sqp.m} to
 ## increase this value).
 ## @end table
+## @seealso{qp}
 ## @end deftypefn
-## @seealso{qp}
 
 function [x, obj, info, iter, nf, lambda] = sqp (x, objf, cef, cif)
 
   global nfun;
   global __sqp_obj_fun__;
   global __sqp_ce_fun__;
   global __sqp_ci_fun__;
 
diff --git a/scripts/plot/__errcomm__.m b/scripts/plot/__errcomm__.m
--- a/scripts/plot/__errcomm__.m
+++ b/scripts/plot/__errcomm__.m
@@ -16,20 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __errcomm__ (@var{args})
 ## Common argument handling code for all error plots (errorbar, loglogerr,
 ## semilogyerr, semilogxerr).
-##
+## @seealso{errorbar, semilogxerr, semilogyerr, loglogerr, __pltopt__}
 ## @end deftypefn
-##
-## @seealso{errorbar, semilogxerr, semilogyerr, loglogerr, __pltopt__}
 
 ## Created: 20.02.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function __errcomm__ (caller, varargin)
 
   if (nargin < 3)
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -20,21 +20,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __errplot__ (@var{args})
 ## Really plot errorbar plots. User interface in function errorbar.
 ##
 ## @example
 ## __errplot__ (@var{arg1}, @var{arg2}, ..., @var{fmt})
 ## @end example
 ##
+## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
+## bar, stairs, errorbar, replot, xlabel, ylabel, and title}
 ## @end deftypefn
-##
-## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, replot, xlabel, ylabel, and title}
-
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function __errplot__ (fstr, a1, a2, a3, a4, a5, a6)
 
   __plot_globals__;
 
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
--- a/scripts/plot/__pltopt1__.m
+++ b/scripts/plot/__pltopt1__.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __pltopt1__ (@var{caller}, @var{opt})
 ## Really decode plot option strings.
+## @seealso{__pltopt__}
 ## @end deftypefn
-##
-## @seealso{__pltopt__}
 
 ## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function fmt = __pltopt1__ (caller, opt)
 
   set_color = 0;
diff --git a/scripts/plot/__pltopt__.m b/scripts/plot/__pltopt__.m
--- a/scripts/plot/__pltopt__.m
+++ b/scripts/plot/__pltopt__.m
@@ -98,19 +98,18 @@
 ## =====================================================================
 ##   1    red       green       solid           "o"         "+"
 ##   2    green     blue        long dash       "+"         "x"
 ##   3    blue      red         short dash     square       "*"
 ##   4    magenta   magenta     dotted          "x"        open square
 ##   5    cyan      cyan        dot long dash  triangle    filled square
 ##   6    brown     yellow      dot short dash  "*"         "o"
 ## @end example
+## @seealso{__pltopt1__}
 ## @end deftypefn
-##
-## @seealso{__pltopt1__}
 
 ## Author: jwe
 
 function fmt = __pltopt__ (caller, opt)
 
   if (! ischar (opt))
     usage ("__pltopt__ (caller, opt)");
   endif
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -36,20 +36,19 @@
 ##
 ## @example
 ## [xb, yb] = bar (x, y);
 ## plot (xb, yb);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
     if (isvector (x))
       len = 3 * length (x) + 1;
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -18,19 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} contour (@var{z}, @var{n})
 ## @deftypefnx {Function File} {} contour (@var{x}, @var{y}, @var{z}, @var{n})
 ## Make a contour plot of the three-dimensional surface described by
 ## @var{z}.  Someone needs to improve @code{gnuplot}'s contour routines
 ## before this will be very useful.
+## @seealso{plot, mesh, meshgrid}
 ## @end deftypefn
-##
-## @seealso{plot, mesh, meshgrid}
 
 ## Author: jwe
 
 function contour (x, y, z, n)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -96,21 +96,19 @@
 ##
 ## @example
 ## errorbar(@var{x}, @var{y}, @var{lx}, @var{ux}, @var{ly}, @var{uy}, "~>")
 ## @end example
 ##
 ## xyerrorbar plot of @var{y} versus @var{x} where @var{x} errorbars
 ## are drawn from @var{x}-@var{lx} to @var{x}+@var{ux} and @var{y} errorbars
 ## from @var{y}-@var{ly} to @var{y}+@var{uy}.
-##
+## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
+## bar, stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
-## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function errorbar (varargin)
 
   if (nargin < 2)
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} grid (@var{arg})
 ## For two-dimensional plotting, force the display of a grid on the plot.
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, @code{"on"} is assumed.
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## bar, stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 ## PKG_ADD: mark_as_command grid
 
 function grid (x)
 
   usage_msg = "grid (\"on\" | \"off\")";
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -33,19 +33,18 @@
 ##
 ## If third argument is provided, the histogram is normalised such that
 ## the sum of the bars is equal to @var{norm}.
 ##
 ## Extreme values are lumped in the first and last bins.
 ##
 ## With two output arguments, produce the values @var{nn} and @var{xx} such
 ## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
+## @seealso{bar}
 ## @end deftypefn
-##
-## @seealso{bar}
 
 ## Author: jwe
 
 function [nn, xx] = hist (y, x, norm)
 
   if (nargin < 1 || nargin > 3)
     usage ("[nn, xx] = hist (y, x, norm)");
   endif
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} loglog (@var{args})
 ## Make a two-dimensional plot using log scales for both axes.  See the
 ## description of @code{plot} for a description of the arguments that
 ## @code{loglog} will accept.
+## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
+## replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function loglog (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -27,21 +27,19 @@
 ## loglogerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a double logarithm plot of @var{y} versus @var{x} 
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
-##
+## @seealso{errorbar, semilogxerr, semilogyerr, polar, mesh, contour, 
+## __pltopt__, bar, stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{errorbar, semilogxerr, semilogyerr, polar, mesh, contour, 
-## __pltopt__, bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function loglogerr (varargin)
 
   if (nargin < 2)
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -20,19 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mesh (@var{x}, @var{y}, @var{z})
 ## Plot a mesh given matrices @var{x}, and @var{y} from @code{meshdom} and
 ## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
+## @seealso{meshgrid, contour}
 ## @end deftypefn
-##
-## @seealso{meshgrid, contour}
 
 ## Author: jwe
 
 function mesh (x, y, z)
 
   ## XXX FIXME XXX -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -23,19 +23,18 @@
 ## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x})
 ## Given vectors of @var{x}, @var{y}, and @var{z} coordinates, return
 ## three dimensional arrays corresponding to the @var{x}, @var{y}, and
 ## @var{z} coordinates of a mesh.  Given only @var{x} and @var{y},
 ## return matrices corresponding to the @var{x} and @var{y} coordinates
 ## of a mesh.  The rows of @var{xx} are copies of @var{x}, and the
 ## columns of @var{yy} are copies of @var{y}.  If @var{y} is omitted,
 ## then it is assumed to be the same as @var{x}.
+## @seealso{mesh, contour}
 ## @end deftypefn
-##
-## @seealso{mesh, contour}
 
 ## Author: jwe
 
 function [xx, yy, zz] = meshgrid (x, y, z)
 
   if (nargin == 1)
     y = x;
   endif
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -157,20 +157,19 @@
 ##
 ## @example
 ## t = 0:0.1:6.3;
 ## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
+## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
+## bar, stairs, errorbar, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function plot (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -18,20 +18,19 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## Make a two-dimensional plot given polar the coordinates @var{theta} and
 ## @var{rho}.
 ##
 ## The optional third argument specifies the line type.
+## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
+## stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
-## stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogx (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{x} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogx} will accept.
+## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
+## replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogx (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -27,21 +27,19 @@
 ## semilogxerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
-##
+## @seealso{errorbar, loglogerr semilogyerr, polar, mesh, contour, __pltopt__, 
+## bar, stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{errorbar, loglogerr semilogyerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogxerr (varargin)
 
   if (nargin < 2)
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -17,20 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogy (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{y} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogy} will accept.
+## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
+## replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogy (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -27,21 +27,19 @@
 ## semilogyerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
-##
+## @seealso{errorbar, loglogerr semilogxerr, polar, mesh, contour, __pltopt__, 
+## bar, stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{errorbar, loglogerr semilogxerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogyerr (varargin)
 
   if (nargin < 2)
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -17,21 +17,19 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} shg
 ##
 ## Show the graph window.  Currently, this is the same as executing
 ## replot.
-##
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## bar, stairs, replot, xlabel, ylabel}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
     warning ("shg: ignoring extra arguments");
   endif
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -36,20 +36,19 @@
 ##
 ## @example
 ## [xs, ys] = stairs (x, y);
 ## plot (xs, ys);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## bar, replot, xlabel, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
 
   if (nargin == 1)
     if (isvector (x))
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -15,20 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} title (@var{string})
 ## Specify a title for a plot.
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## bar, stairs, replot, xlabel, ylabel}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function h = title (text)
 
   if (nargin != 1)
     usage ("title (text)");
   endif
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -19,20 +19,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{string})
 ## Specify x, y, and z axis labels for the plot.  If you already have a plot
 ## displayed, use the command @code{replot} to redisplay it with the new
 ## labels.
+## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
+## bar, stairs, replot, ylabel, title}
 ## @end deftypefn
-##
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, ylabel, and title}
 
 ## Author: jwe
 
 function h = xlabel (varargin)
 
   ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -46,20 +46,19 @@
 ##     |       .            .       .        .             .      |
 ##     |       .            .           .    .             .      |
 ##     |_      0            0      ...       1             0     _|
 ## @end smallexample
 ## @end ifinfo
 ##
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
+## @seealso{poly, roots, residue, conv, deconv, polyval, polyderiv,
+## polyinteg}
 ## @end deftypefn
-##
-## @seealso{poly, roots, residue, conv, deconv, polyval, polyderiv, and
-## polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -20,19 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} conv (@var{a}, @var{b})
 ## Convolve two vectors.
 ##
 ## @code{y = conv (a, b)} returns a vector of length equal to
 ## @code{length (a) + length (b) - 1}.
 ## If @var{a} and @var{b} are polynomial coefficient vectors, @code{conv}
 ## returns the coefficients of the product polynomial.
+## @seealso{deconv, poly, roots, residue, polyval, polyderiv, polyinteg}
 ## @end deftypefn
-##
-## @seealso{deconv, poly, roots, residue, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -22,19 +22,18 @@
 ## Deconvolve two vectors.
 ##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
 ##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
 ## a remander polynomial of lowest order.
+## @seealso{conv, poly, roots, residue, polyval, polyderiv, polyinteg}
 ## @end deftypefn
-##
-## @seealso{conv, poly, roots, residue, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -21,19 +21,19 @@
 ## @deftypefn {Function File} {} polyderiv (@var{c})
 ## @deftypefnx {Function File} {[@var{q}] =} polyder (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{q}, @var{r}] =} polyder (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by vector @var{c}.  If a pair of polynomials
 ## is given @var{b} and @var{a}, the derivative of the product is
 ## returned in @var{q}, or the quotient numerator in @var{q} and the
 ## quotient denominator in @var{r}.
+## @seealso{poly, polyinteg, polyreduce, roots, conv, deconv, residue,
+## filter, polygcd, polyval, polyvalm}
 ## @end deftypefn
-## @seealso{poly, polyinteg, polyreduce, roots, conv, deconv, residue,
-## filter, polygcd, polyval, and polyvalm}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [q, r] = polyderiv (p, a)
 
   if (nargin == 1 || nargin == 2)
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -28,20 +28,19 @@
 ##  Note that this is an unstable
 ## algorithm, so don't try it on large polynomials.
 ##
 ## Example
 ## @example
 ## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
 ##          deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) - poly(1:2)
 ## @end example
-## @end deftypefn
-##
 ## @seealso{poly, polyinteg, polyderiv, polyreduce, roots, conv, deconv,
 ## residue, filter, polyval, and polyvalm}
+## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
     if (nargin == 2)
       tol = sqrt (eps);
     endif
     if (length (a) == 1 || length (b) == 1)
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -18,20 +18,19 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyinteg (@var{c})
 ## Return the coefficients of the integral of the polynomial whose
 ## coefficients are represented by the vector @var{c}.
 ##
 ## The constant of integration is set to zero.
-## @end deftypefn
-##
 ## @seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
 ## filter, polyval, and polyvalm}
+## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyinteg (p)
 
   if(nargin != 1)
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -28,20 +28,19 @@
 ## @ifinfo
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
 ## @end ifinfo
 ##  and return it as a string or write it to the screen (if
 ##  @var{nargout} is zero).
 ##  @var{x} defaults to the string @code{"s"}.
-## @end deftypefn
-##
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, and polyinteg}
+## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
   if (nargin < 1) || (nargin > 2) || (nargout < 0) || (nargout > 1)
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -16,20 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyreduce (@var{c})
 ## Reduces a polynomial coefficient vector to a minimum number of terms by
 ## stripping off any leading zeros.
+## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
+## polyvalm, polyderiv, polyinteg}
 ## @end deftypefn
-##
-## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
-## polyvalm, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (p)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -21,20 +21,19 @@
 ## @deftypefn {Function File} {} polyval (@var{c}, @var{x})
 ## Evaluate a polynomial.
 ##
 ## @code{polyval (@var{c}, @var{x})} will evaluate the polynomial at the
 ## specified value of @var{x}.
 ##
 ## If @var{x} is a vector or matrix, the polynomial is evaluated at each of
 ## the elements of @var{x}.
+## @seealso{polyvalm, poly, roots, conv, deconv, residue, filter,
+## polyderiv, polyinteg}
 ## @end deftypefn
-##
-## @seealso{polyvalm, poly, roots, conv, deconv, residue, filter,
-## polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -21,20 +21,19 @@
 ## @deftypefn {Function File} {} polyvalm (@var{c}, @var{x})
 ## Evaluate a polynomial in the matrix sense.
 ##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
 ## matrix sense, i.e. matrix multiplication is used instead of element by
 ## element multiplication as is used in polyval.
 ##
 ## The argument @var{x} must be a square matrix.
-## @end deftypefn
-##
 ## @seealso{polyval, poly, roots, conv, deconv, residue, filter,
 ## polyderiv, and polyinteg}
+## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -94,19 +94,18 @@
 ## @ifinfo
 ##
 ## @example
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end example
 ## @end ifinfo
+## @seealso{poly, roots, conv, deconv, polyval, polyderiv, and polyinteg}
 ## @end deftypefn
-##
-## @seealso{poly, roots, conv, deconv, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [r, p, k, e] = residue (b, a, toler)
 
   ## Here's the method used to find the residues.
diff --git a/scripts/set/complement.m b/scripts/set/complement.m
--- a/scripts/set/complement.m
+++ b/scripts/set/complement.m
@@ -23,19 +23,18 @@
 ## example,
 ##
 ## @example
 ## @group
 ## complement ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} 5
 ## @end group
 ## @end example
+## @seealso{create_set, union, intersection}
 ## @end deftypefn
-##
-## @seealso{create_set, union, and intersection}
 
 ## Author: jwe
 
 function y = complement (a, b)
 
   if (nargin != 2)
     usage ("complement(a,b)");
   endif
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -23,19 +23,18 @@
 ## ascending order.  For example,
 ##
 ## @example
 ## @group
 ## create_set ([ 1, 2; 3, 4; 4, 2 ])
 ##      @result{} [ 1, 2, 3, 4 ]
 ## @end group
 ## @end example
+## @seealso{union, intersection, complement}
 ## @end deftypefn
-##
-## @seealso{union, intersection, and complement}
 
 ## Author: jwe
 
 function y = create_set(x)
 
   if (nargin != 1)
     usage ("create_set(x)");
   endif
diff --git a/scripts/set/intersection.m b/scripts/set/intersection.m
--- a/scripts/set/intersection.m
+++ b/scripts/set/intersection.m
@@ -23,19 +23,18 @@
 ## For example,
 ##
 ## @example
 ## @group
 ## intersection ([ 1, 2, 3 ], [ 2, 3, 5 ])
 ##      @result{} [ 2, 3 ]
 ## @end group
 ## @end example
+## @seealso{create_set, union, complement}
 ## @end deftypefn
-##
-## @seealso{create_set, union, and complement}
 
 ## Author: jwe
 
 function y = intersection(a,b)
 
   if (nargin != 2)
     usage ("intersection(a,b)");
   endif
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -16,18 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ismember (@var{A}, @var{S})
 ## Return a matrix the same shape as @var{A} which has 1 if
 ## @code{A(i,j)} is in @var{S} or 0 if it isn't.
+## @seealso{unique, union, intersection, setxor, setdiff}
 ## @end deftypefn
-## @seealso{unique, union, intersection, setxor, setdiff}
 
 ## Author: Paul Kienzle
 ## Adapted-by: jwe
 
 function c = ismember (a, S)
 
   if (nargin != 2)
     usage ("ismember (A, S)");
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -17,18 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} setdiff (@var{a}, @var{b})
 ## Return the elements in @var{a} but not in @var{b}, sorted in
 ## ascending order.  If @var{a} and @var{b} are both column vectors
 ## return a column vector, otherwise return a row vector.
+## @seealso{unique, union, intersect, setxor, ismember}
 ## @end deftypefn
-## @seealso{unique, union, intersect, setxor, ismember}
 
 ## Author: Paul Kienzle
 ## Adapted-by: jwe
 
 function c = setdiff (a, b)
 
   if (nargin != 2)
     usage ("setdiff (a, b)");
@@ -44,9 +44,9 @@ function c = setdiff (a, b)
     c(idx(find (dummy(1:n-1) == dummy(2:n)))) = [];
     ## Reshape if necessary.
     if (size (c, 1) != 1 && size (b, 1) == 1)
       c = c.';
     endif
   endif
 
 endfunction
-  
\ No newline at end of file
+  
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -23,19 +23,18 @@
 ## @var{y}.  For example,
 ##
 ## @example
 ## @group
 ## union ([ 1, 2, 4 ], [ 2, 3, 5 ])
 ##      @result{} [ 1, 2, 3, 4, 5 ]
 ## @end group
 ## @end example
+## @seealso{create_set, intersection, complement}
 ## @end deftypefn
-##
-## @seealso{create_set, intersection, and complement}
 
 ## Author: jwe
 
 function y = union(a,b)
 
   if (nargin != 2)
     usage ("union(a,b)");
   endif
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -25,19 +25,18 @@
 ## @deftypefnx {Function File} {} unique (@var{A}, 'rows')
 ##
 ## Return the unique rows of @var{A}, sorted in ascending order.
 ##
 ## @deftypefnx {Function File} {[@var{y}, @var{i}, @var{j}] = } unique (@var{x})
 ##
 ## Return index vectors @var{i} and @var{j} such that @code{x(i)==y} and
 ## @code{y(j)==x}.
-##
+## @seealso{union, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
-## @seealso{union, intersect, setdiff, setxor, ismember}
 
 function [y, i, j] = unique (x, r)
 
   if (nargin < 1 || nargin > 2 || (nargin == 2 && ! strcmp (r, "rows")))
     usage ("unique (x) or unique (x, 'rows')");
   endif
 
   if (nargin == 1)
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -17,14 +17,14 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} etreeplot (@var{tree})
 ## @deftypefnx {Function File} {} etreeplot (@var{tree}, @var{node_style}, @var{edge_style})
 ## Plot the elimination tree of the matrix @var{s} or
 ## @code{@var{s}+@var{s}'}  if @var{s} in non-symmetric.  The optional
 ## parameters @var{line_style} and @var{edge_style} define the output
 ## style.
+## @seealso{treeplot, gplot}
 ## @end deftypefn
-## @seealso{treeplot,gplot}
 
 function etreeplot (s, varargin)
   treeplot (etree (s+s'), varargin{:});
 endfunction
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -23,18 +23,18 @@
 ## sense.  @var{A} is the adjacency matrix of the array to be plotted
 ## and @var{xy} is an @var{n}-by-2 matrix containing the coordinates of
 ## the nodes of the graph.
 ##
 ## The optional parameter @var{line_style} defines the output style for
 ## the plot.  Called with no output arguments the graph is plotted
 ## directly.  Otherwise, return the coordinates of the plot in @var{x}
 ## and @var{y}.
+## @seealso{treeplot, etreeplot, spy}
 ## @end deftypefn
-## @seealso{treeplot, etreeplot, spy}
 
 function [x, y] = gplot (A, xy, line_style)
 
   if (nargin < 2 || nargin > 3 || nargout > 2)
     usage ("gplot (a, xy, line_style)");
   endif
 
   if (nargin == 2)
diff --git a/scripts/sparse/spalloc.m b/scripts/sparse/spalloc.m
--- a/scripts/sparse/spalloc.m
+++ b/scripts/sparse/spalloc.m
@@ -31,14 +31,14 @@
 ## for j = 1:c
 ##   idx = randperm (r);
 ##   s (:, j) = [zeros(r - k, 1); rand(k, 1)] (idx);
 ## endfor
 ## @end example
 ##
 ## will reallocate memory at each step. It is therefore vitally important
 ## that code like this is vectorized as much as possible.
+## @seealso{sparse, nzmax}
 ## @end deftypefn
-## @seealso{sparse, nzmax}
 
 function s = spalloc (r, c, nz)
   s = sparse (r, c);
 endfunction
diff --git a/scripts/sparse/sphcat.m b/scripts/sparse/sphcat.m
--- a/scripts/sparse/sphcat.m
+++ b/scripts/sparse/sphcat.m
@@ -13,19 +13,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} sphcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
 ## Return the horizontal concatenation of sparse matrices. This function
-## is obselete and @code{horzcat} should be used
+## is obselete and @code{horzcat} should be used.
+## @seealso {spvcat, vertcat, horzcat, cat}
 ## @end deftypefn
-## @seealso {spvcat, vertcat, horzcat, cat}
 
 function y = sphcat (varargin)
 
   persistent sphcat_warned = false;
 
   if (!sphcat_warned)
     sphcat_warned = true;
     warning ("sphcat: This function is depreciated. Use horzcat instead");
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -10,19 +10,18 @@
 ## @var{d} should be between 0 and 1. Values will be uniformly
 ## distributed between 0 and 1.
 ##
 ## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
+## @seealso{sprandn}
 ## @end deftypefn
-## @seealso{sprandn}
-
 
 ## This program is public domain
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ##
 ## Changelog:
 ##
 ## Piotr Krzyzanowski <przykry2004@users.sf.net>
 ## 	2004-09-27	use Paul's hint to allow larger random matrices
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -10,18 +10,18 @@
 ## @var{d} should be between 0 and 1. Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
 ## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
+## @seealso{sprand}
 ## @end deftypefn
-## @seealso{sprand}
 
 ## This program is public domain
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function S = sprandn(m,n,d)
   if nargin == 1
     [i,j,v,nr,nc] = spfind(m);
     S = sparse(i,j,randn(size(v)),nr,nc);
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -24,18 +24,18 @@
 ## distributed with mean of zero and variance 1.
 ##
 ## Note: sometimes the actual density  may be a bit smaller than @var{d}. 
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero in its lower
 ## triangular part.
+## @seealso{sprand, sprandn}
 ## @end deftypefn
-## @seealso{sprand, sprandn}
 
 function S = sprandsym(n,d)
   if nargin == 1
     [i,j,v,nr,nc] = spfind(tril(n));
     S = sparse(i,j,randn(size(v)),nr,nc);
     S = S + tril(S,-1)';
   elseif nargin == 2
     m1 = floor(n/2);
diff --git a/scripts/sparse/spvcat.m b/scripts/sparse/spvcat.m
--- a/scripts/sparse/spvcat.m
+++ b/scripts/sparse/spvcat.m
@@ -14,18 +14,18 @@
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spvcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
 ## Return the vertical concatenation of sparse matrices. This function
 ## is obselete and @code{vertcat} should be used
+## @seealso{sphcat, vertcat, horzcat, cat}
 ## @end deftypefn
-## @seealso {sphcat, vertcat, horzcat, cat}
 
 function y = spvcat (varargin)
 
   persistent spvcat_warned = false;
 
   if (!spvcat_warned)
     spvcat_warned = true;
     warning ("spvcat: This function is depreciated. Use vertcat instead");
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -17,18 +17,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} treeplot (@var{Tree})
 ## @deftypefnx {Function File} {} treeplot (@var{Tree}, @var{LineStyle}, @var{EdgeStyle})
 ## Produces a graph of tree or forest. The first argument is vector of
 ## predecessors, optional parametres @var{LineStyle} and @var{EdgeStyle}
 ## define the output style. The complexity of the algorithm is O(n) in
 ## terms of is time and memory requirements.
+## @seealso{etreeplot, gplot}
 ## @end deftypefn
-## @seealso{etreeplot,gplot}
 
 function treeplot (Tree, NodeS, EdgeS)
 
   if (nargin < 1 || nargin > 3 || nargout > 0)
     error ("treeplot: wrong number of input/output arguments");
   else
     if (!ismatrix(Tree) || size(Tree)(1) != 1 || !isnumeric(Tree) 
         || !isvector(Tree) || any(Tree>length (Tree)))
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} erfinv (@var{z})
 ## Computes the inverse of the error function.
+## @seealso{erf, erfc}
 ## @end deftypefn
-##
-## @seealso{erf and erfc}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 27 September 1994
 ## Adapted-By: jwe
 
 function [y, iterations] = erfinv (x)
 
   if (nargin != 1)
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -25,19 +25,18 @@
 ## @iftex
 ## @tex
 ##  $1/2 <= |f| < 1$ and $x = f \cdot 2^e$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  1/2 <= abs(f) < 1 and x = f * 2^e.
 ## @end ifinfo
+## @seealso{log, log10, logspace, exp}
 ## @end deftypefn
-##
-## @seealso{log, log10, logspace, and exp}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function [f, e] = log2 (x)
 
   if (nargin != 1)
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -33,19 +33,18 @@
 ## @iftex
 ## @tex
 ##  $f \cdot 2^e$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##  f .* (2 .^ e).
 ## @end ifinfo
+## @seealso{nextpow2}
 ## @end deftypefn
-##
-## @seealso{nextpow2}
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = pow2 (f, e)
 
   if (nargin == 1)
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -38,19 +38,18 @@
 ##
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
 ## @end group
 ## @end example
 ## @end ifinfo
+## @seealso{vander, sylvester_matrix, hilb, invhilb, toeplitz}
 ## @end deftypefn
-##
-## @seealso{vander, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
     r = zeros (size (c));
   elseif (nargin != 2)
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -37,19 +37,18 @@
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ## @end ifinfo
+## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
 ## @end deftypefn
-##
-## @seealso{hankel, vander, sylvester_matrix, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
   if (nargin != 1)
     usage ("hilb (n)");
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -56,20 +56,18 @@
 ## The validity of this formula can easily be checked by expanding 
 ## the binomial coefficients in both formulas as factorials.  It can 
 ## be derived more directly via the theory of Cauchy matrices: 
 ## see J. W. Demmel, Applied Numerical Linear Algebra, page 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
-##
+## @seealso{hankel, vander, sylvester_matrix, hilb, toeplitz}
 ## @end deftypefn
-##
-## @seealso{hankel, vander, sylvester_matrix, hilb, and toeplitz}
 
 ## Author: Dirk Laurie <dlaurie@na-net.ornl.gov>
 
 function retval = invhilb (n)
 
   if (nargin != 1)
     usage ("invhilb (n)");
   endif
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -23,19 +23,18 @@
 ## @iftex
 ## @tex
 ## $n = 2^k$.
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## n = 2^k.
 ## @end ifinfo
+## @seealso{hankel, vander, hilb, invhilb, toeplitz}
 ## @end deftypefn
-##
-## @seealso{hankel, vander, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
     usage ("sylvester_matrix (n)");
   endif
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -46,19 +46,18 @@
 ## c(2)  c(1)   c(0)  ... r(n-2)
 ##  .     ,      ,   .      .
 ##  .     ,      ,     .    .
 ##  .     ,      ,       .  .
 ## c(n) c(n-1) c(n-2) ...  c(0)
 ## @end group
 ## @end example
 ## @end ifinfo
+## @seealso{hankel, vander, sylvester_matrix, hilb, invhib}
 ## @end deftypefn
-##
-## @seealso{hankel, vander, sylvester_matrix, hilb, and invhib}
 
 ## Author: jwe
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
   elseif (nargin != 2)
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -40,19 +40,18 @@
 ## c(2)^(n-1) ... c(2)^2  c(2)  1
 ##     .     .      .      .    .
 ##     .       .    .      .    .
 ##     .         .  .      .    .
 ## c(n)^(n-1) ... c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ## @end ifinfo
+## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
 ## @end deftypefn
-##
-## @seealso{hankel, sylvester_matrix, hilb, invhilb, and toeplitz}
 
 ## Author: jwe
 
 function retval = vander (c)
 
   if (nargin != 1)
     usage ("vander (c)");
   endif
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -37,19 +37,18 @@
 ##             x(ceil(N/2)),             N odd
 ## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
 ## @end ifinfo
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.
+## @seealso{std, mean}
 ## @end deftypefn
-##
-## @seealso{std and mean}
 
 ## Author: jwe
 
 function retval = median (a, dim)
 
   if (nargin != 1 && nargin != 2)
     usage ("median (a, dim)");
   endif
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -50,19 +50,18 @@
 ##   the variance [default]
 ## @item 1:
 ##   normalizes with N, this provides the square root of the second moment around 
 ##   the mean
 ## @end table
 ##
 ## The third argument @var{dim} determines the dimension along which the standard
 ## deviation is calculated.
+## @seealso{mean, median}
 ## @end deftypefn
-##
-## @seealso{mean and median}
 
 ## Author: jwe
 
 function retval = std (a, opt, dim)
 
   if (nargin < 1 || nargin > 3)
     usage ("std (a, opt, dim)");
   endif
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gamcdf (@var{x}, @var{a}, @var{b})
 ## For each element of @var{x}, compute the cumulative distribution
 ## function (CDF) at @var{x} of the Gamma distribution with parameters
 ## @var{a} and @var{b}.
+## @seealso{gamma, gammaln, gammainc, gampdf, gaminv, gamrnd}
 ## @end deftypefn
-##
-## @seealso{gamma, gammaln, gammainc, gampdf, gaminv, gamrnd}
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: CDF of the Gamma distribution
 
 function cdf = gamcdf (x, a, b)
 
   if (nargin != 3)
     usage ("gamcdf (x, a, b)");
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -16,20 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gaminv (@var{x}, @var{a}, @var{b})
 ## For each component of @var{x}, compute the quantile (the inverse of
 ## the CDF) at @var{x} of the Gamma distribution with parameters @var{a}
-## and @var{b}. 
+## and @var{b}.
+## @seealso{gamma, gammaln, gammainc, gampdf, gamcdf, gamrnd}
 ## @end deftypefn
-##
-## @seealso{gamma, gammaln, gammainc, gampdf, gamcdf, gamrnd}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Gamma distribution
 
 function inv = gaminv (x, a, b)
 
   if (nargin != 3)
     usage ("gaminv (x, a, b)");
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -17,19 +17,18 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gampdf (@var{x}, @var{a}, @var{b})
 ## For each element of @var{x}, return the probability density function
 ## (PDF) at @var{x} of the Gamma distribution with parameters @var{a}
 ## and @var{b}.
+## @seealso{gamma, gammaln, gammainc, gamcdf, gaminv, gamrnd}
 ## @end deftypefn
-##
-## @seealso{gamma, gammaln, gammainc, gamcdf, gaminv, gamrnd}
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: PDF of the Gamma distribution
 
 function pdf = gampdf (x, a, b)
 
   if (nargin != 3)
     usage ("gampdf (x, a, b)");
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -22,19 +22,18 @@
 ## @deftypefnx {Function File} {} gamrnd (@var{a}, @var{b}, @var{sz})
 ## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of 
 ## random samples from the Gamma distribution with parameters @var{a}
 ## and @var{b}.  Both @var{a} and @var{b} must be scalar or of size 
 ## @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{a} and @var{b}.
+## @seealso{gamma, gammaln, gammainc, gampdf, gamcdf, gaminv}
 ## @end deftypefn
-##
-## @seealso{gamma, gammaln, gammainc, gampdf, gamcdf, gaminv}
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -35,20 +35,18 @@
 ## If @var{b} is a string, the characters of @var{b} are used as the
 ## symbols for the digits of @var{s}. Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
 ## base2dec ("yyyzx", "xyz")
 ##      @result{} 123
 ## @end example
-##
+## @seealso{dec2base, dec2bin, bin2dec, hex2dec, dec2hex}
 ## @end deftypefn
-##
-## @seealso{dec2base, dec2bin, bin2dec, hex2dec, dec2hex}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function out = base2dec (d, base)
 
   if (nargin != 2)
     usage ("n = base2dec('d', base)");
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -24,19 +24,18 @@
 ##
 ## @example
 ## hex2dec ("1110")
 ##      @result{} 14
 ## @end example
 ##
 ## If @var{s} is a string matrix, returns a column vector of converted
 ## numbers, one per row of @var{s}.  Invalid rows evaluate to NaN.
+## @seealso{dec2hex, base2dec, dec2base, bin2dec, dec2bin}
 ## @end deftypefn
-##
-## @seealso{dec2hex, base2dec, dec2base, bin2dec, dec2bin}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function d = bin2dec (h)
 
   if (nargin != 1)
     usage ("bin2dec (b)");
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -36,19 +36,18 @@
 ##
 ## @example
 ## dec2base (123, "aei")
 ##      @result{} "eeeia"
 ## @end example
 ##
 ## The optional third argument, @var{len}, specifies the minimum
 ## number of digits in the result.
+## @seealso{base2dec, dec2bin, bin2dec, hex2dec, dec2hex}
 ## @end deftypefn
-##
-## @seealso{base2dec, dec2bin, bin2dec, hex2dec, dec2hex}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function retval = dec2base (n, base, len)
 
   if (nargin < 2 || nargin > 3)
     usage ("dec2base (n, base [, len])");
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -27,19 +27,18 @@
 ##      @result{} "1110"
 ## @end example
 ##
 ## If @var{n} is a vector, returns a string matrix, one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
+## @seealso{bin2dec, dec2base, base2dec, hex2dec, dec2hex}
 ## @end deftypefn
-##
-## @seealso{bin2dec, dec2base, base2dec, hex2dec, dec2hex}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function retval = dec2bin (n, len)
 
   if (nargin == 1)
     retval = dec2base (n, 2);
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -27,19 +27,18 @@
 ##      @result{} "ABC"
 ## @end example
 ##
 ## If @var{n} is a vector, returns a string matrix, one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
 ## The optional second argument, @var{len}, specifies the minimum
 ## number of digits in the result.
+## @seealso{hex2dec, dec2base, base2dec, bin2dec, dec2bin}
 ## @end deftypefn
-##
-## @seealso{hex2dec, dec2base, base2dec, bin2dec, dec2bin}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function retval = dec2hex (n, len)
 
   if (nargin == 1)
     retval = dec2base (n, 16);
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -26,19 +26,18 @@
 ## hex2dec ("12B")
 ##      @result{} 299
 ## hex2dec ("12b")
 ##      @result{} 299
 ## @end example
 ##
 ## If @var{s} is a string matrix, returns a column vector of converted
 ## numbers, one per row of @var{s}.  Invalid rows evaluate to NaN.
+## @seealso{dec2hex, base2dec, dec2base, bin2dec, dec2bin}
 ## @end deftypefn
-##
-## @seealso{dec2hex, base2dec, dec2base, bin2dec, dec2bin}
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function d = hex2dec (h)
 
   if (nargin != 1)
     usage ("hex2dec (b)");
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isletter (@var{s})
 ## Returns true if @var{s} is a letter false otherwise.
+## @seealso{isalpha}
 ## @end deftypefn
-##
-## @seealso{isalpha}
 
 ## Author: jwe
 
 function retval = isletter (s)
 
   if (nargin != 1)
     usage ("isletter (s)");
   endif
diff --git a/scripts/strings/lower.m b/scripts/strings/lower.m
--- a/scripts/strings/lower.m
+++ b/scripts/strings/lower.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lower (@var{s})
 ## Transform all letters in the string @var{s} to lower case.
+## @seealso{tolower}
 ## @end deftypefn
-##
-## @seealso{tolower}
 
 ## Author: jwe
 
 function retval = lower (s)
 
   if (nargin != 1)
     usage ("lower (s)");
   endif
diff --git a/scripts/strings/upper.m b/scripts/strings/upper.m
--- a/scripts/strings/upper.m
+++ b/scripts/strings/upper.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} upper (@var{s})
 ## Transform all letters in the string @var{s} to upper case.
+## @seealso{toupper}
 ## @end deftypefn
-##
-## @seealso{toupper}
 
 ## Author: jwe
 
 function retval = upper (s)
 
   if (nargin != 1)
     usage ("upper (s)");
   endif
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -34,19 +34,18 @@
 ## lists or structures.
 ##
 ## @item assert(@var{observed}, @var{expected}, @var{tol})
 ## Produce an error if relative error is less than tolerance. That is, 
 ## @code{abs(@var{observed} - @var{expected}) > @var{tol} * @var{expected}}.  
 ## Absolute error @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})} 
 ## will be used when tolerance is negative or when the expected value is zero.
 ## @end table
-##
+## @seealso{test}
 ## @end deftypefn
-## @seealso{test}
 
 ## TODO: Output throttling: don't print out the entire 100x100 matrix,
 ## TODO: but instead give a summary; don't print out the whole list, just
 ## TODO: say what the first different element is, etc.  To do this, make
 ## TODO: the message generation type specific.
 function assert(cond, expected, tol)
 
   if (nargin < 1 || nargin > 3)
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -61,19 +61,18 @@
 ## @example
 ##   %!demo if 1
 ##   %!  function y=f(x)
 ##   %!    y=x;
 ##   %!  endfunction
 ##   %!  f(3)
 ##   %! endif
 ## @end example
-##
+## @seealso{test, example}
 ## @end deftypefn
-## @seealso{test, example}
 
 ## TODO: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## TODO: use the current figure window but pause if not plotting in the
 ## TODO: first subplot.
 
 ## PKG_ADD: mark_as_command demo
 
 function demo(name, n)
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -23,18 +23,18 @@
 ## '@var{name}', but do not run it. If @var{n} is not given, all examples 
 ## are displayed.
 ##
 ## Called with output arguments, the examples are returned in the form of
 ## a string @var{x}, with @var{idx} indicating the ending position of the 
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
+## @seealso{demo, test}
 ## @end deftypefn
-## @seealso{demo, test}
 
 ## PKG_ADD: mark_as_command example
 
 function [code_r, idx_r] = example(name, n)
 
   if (nargin < 1 || nargin > 2)
     usage("example('name')  or example('name', n)");
   endif
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -59,19 +59,18 @@
 ##
 ## If the second argument is the string 'grabdemo', the contents of the demo
 ## blocks are extracted but not executed. Code for all code blocks is
 ## concatented and returned as @var{code} with @var{idx} being a vector of
 ## positions of the ends of the demo blocks.
 ##
 ## If the second argument is 'explain', then @var{name} is ignored and an
 ## explanation of the line markers used is written to the file @var{fid}.
-##
+## @seealso{error, assert, fail, demo, example}
 ## @end deftypefn
-## @seealso{error, assert, fail, demo, example}
 
 ## TODO: * Consider using keyword fail rather then error?  This allows us
 ## TODO: to make a functional form of error blocks, which means we
 ## TODO: can include them in test sections which means that we can use
 ## TODO: octave flow control for both kinds of tests.
 
 ## PKG_ADD: mark_as_command test
 
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -26,19 +26,18 @@
 ## t0 = clock ();
 ## # many computations later...
 ## elapsed_time = etime (clock (), t0);
 ## @end example
 ##
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the variable @code{t0} was set.
+## @seealso{tic, toc, clock, cputime}
 ## @end deftypefn
-##
-## @seealso{tic, toc, clock, and cputime}
 
 ## Author: jwe
 
 function secs = etime (t1, t0)
 
   if (nargin != 2)
     usage ("etime (t1, t0)");
   endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,25 @@
+2006-03-06  Keith Goodman  <kwgoodman@gmail.com>
+ 
+	* bitfcns.cc, data.cc, debug.cc, file-io.cc, help.cc,
+	load-save.cc, mappers.cc, ov-cell.cc, ov-fcn-inline.cc,
+	ov-struct.cc, ov-usr-fcn.cc, ov.cc, pr-output.cc, utils.cc,
+	variables.cc, DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/cellfun.cc,
+	DLD-FUNCTIONS/colamd.cc, DLD-FUNCTIONS/daspk.cc,
+	DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/dassl.cc,
+	DLD-FUNCTIONS/fft.cc, DLD-FUNCTIONS/fft2.cc,
+	DLD-FUNCTIONS/fftn.cc, DLD-FUNCTIONS/fftw_wisdom.cc,
+	DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/gcd.cc,
+	DLD-FUNCTIONS/luinc.cc, DLD-FUNCTIONS/odessa.cc,
+	DLD-FUNCTIONS/sparse.cc, DLD-FUNCTIONS/spchol.cc,
+	DLD-FUNCTIONS/splu.cc, DLD-FUNCTIONS/spqr.cc,
+	DLD-FUNCTIONS/sqrtm.cc:
+	Move @seealso inside @defXXX macro.  Remove "and" from @seealso.
+
 2006-03-04  John W. Eaton  <jwe@octave.org>
 
 	* help.cc (additional_help_message): Don't print "\n" before message.
 	(help_from_symbol_table): If Vsuppress_verbose_help_message is
 	true, don't print which info.
 
 2006-03-03  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -126,19 +126,18 @@ or out-of-order row indices. @code{@var{
 the current version of CCOLAMD (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
-\n\
-@end deftypefn\n\
-@seealso{colamd, csymamd}")
+@seealso{colamd, csymamd}\n\
+@end deftypefn")
 {
 #ifdef HAVE_CCOLAMD
   octave_value_list retval;
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
@@ -379,19 +378,18 @@ or out-of-order row indices. @code{@var{
 the current version of CCOLAMD (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
-\n\
-@end deftypefn\n\
-@seealso{symamd, ccolamd}")
+@seealso{symamd, ccolamd}\n\
+@end deftypefn")
 {
 #if HAVE_CCOLAMD
   octave_value_list retval;
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -72,19 +72,18 @@ argument and return a single value, and 
 argument, the argument must be named @var{x}.  For example\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower(x)\", @{\"Foo\", \"Bar\", \"FooBar\"@})\n\
 @result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
-\n\
-@end deftypefn\n\
-@seealso{isempty, islogical, isreal, length, ndims, numel, size, isclass}")
+@seealso{isempty, islogical, isreal, length, ndims, numel, size, isclass}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   std::string name = "function";
 
   octave_function *func = 0;
 
   int nargin = args.length ();
@@ -247,18 +246,18 @@ cellfun (\"tolower(x)\", @{\"Foo\", \"Ba
 
 DEFUN_DLD (num2cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} num2cell (@var{m})\n\
 @deftypefnx {Loadable Function} {@var{c} =} num2cell (@var{m}, @var{d})\n\
 Convert to matrix @var{m} into a cell array. If @var{d} is defined the\n\
 value @var{c} is of dimension 1 in this dimension and the elements of\n\
 @var{m} are placed in slices in @var{c}.\n\
-@end deftypefn\n\
-@seealso{mat2cell}") 
+@seealso{mat2cell}\n\
+@end deftypefn") 
 {
   int nargin =  args.length();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ("num2cell");
   else
     {
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -258,18 +258,18 @@ the current version of COLAMD (reserved 
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory. (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
-@end deftypefn\n\
-@seealso{colperm, symamd}")
+@seealso{colperm, symamd}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
  
@@ -494,18 +494,18 @@ always zero in the current version of SY
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory. (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
-@end deftypefn\n\
-@seealso{colperm, colamd}")
+@seealso{colperm, colamd}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
  
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -261,18 +261,18 @@ discontinuity in the derivative.\n\
 After a successful computation, the value of @var{istate} will be\n\
 greater than zero (consistent with the Fortran version of @sc{Daspk}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{daspk_options} to set optional\n\
 parameters for @code{daspk}.\n\
-@end deftypefn\n\
-@seealso{dassl}")
+@seealso{dassl}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect::begin_frame ("Fdaspk");
 
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -334,18 +334,18 @@ discontinuity in the derivative.\n\
 After a successful computation, the value of @var{istate} will be\n\
 greater than zero (consistent with the Fortran version of @sc{Dassl}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dasrt_options} to set optional\n\
 parameters for @code{dasrt}.\n\
-@end deftypefn\n\
-@seealso{daspk, dasrt, lsode, odessa}")
+@seealso{daspk, dasrt, lsode, odessa}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
   unwind_protect::begin_frame ("Fdasrt");
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -266,18 +266,18 @@ discontinuity in the derivative.\n\
 After a successful computation, the value of @var{istate} will be\n\
 greater than zero (consistent with the Fortran version of @sc{Dassl}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dassl_options} to set optional\n\
 parameters for @code{dassl}.\n\
-@end deftypefn\n\
-@seealso{daspk, dasrt, lsode, odessa}")
+@seealso{daspk, dasrt, lsode, odessa}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect::begin_frame ("Fdassl");
 
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -161,18 +161,18 @@ specifying the number of elements of @va
 matrix to specify that its value should be ignored. If @var{n} is\n\
 larger than the dimension along which the FFT is calculated, then\n\
 @var{a} is resized and padded with zeros. Otherwise, if @var{n} is\n\
 smaller than the dimension along which the FFT is calculated, then\n\
 @var{a} is truncated.\n\
 \n\
 If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the FFT is performed\n\
-@end deftypefn\n\
-@seealso {ifft, fft2, fftn, fftw_wisdom}")
+@seealso{ifft, fft2, fftn, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
 DEFUN_DLD (ifft, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} ifft (@var{a}, @var{n}, @var{dim})\n\
@@ -187,18 +187,18 @@ specifying the number of elements of @va
 matrix to specify that its value should be ignored. If @var{n} is\n\
 larger than the dimension along which the inverse FFT is calculated, then\n\
 @var{a} is resized and padded with zeros. Otherwise, if@var{n} is\n\
 smaller than the dimension along which the inverse FFT is calculated,\n\
 then @var{a} is truncated.\n\
 \n\
 If called with three agruments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the inverse FFT is performed\n\
-@end deftypefn\n\
-@seealso {fft, ifft2, ifftn, fftw_wisdom}")
+@seealso{fft, ifft2, ifftn, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -144,18 +144,18 @@ Compute the two dimensional FFT of @var{
 FFTSRC
 ". The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 \n\
 If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
 of @var{a} is treated seperately\n\
-@end deftypefn\n\
-@seealso {ifft2, fft, fftn fftw_wisdom}")
+@seealso {ifft2, fft, fftn, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
 DEFUN_DLD (ifft2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} fft2 (@var{a}, @var{n}, @var{m})\n\
@@ -163,18 +163,18 @@ Compute the inverse two dimensional FFT 
 FFTSRC
 ". The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 \n\
 If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
 of @var{a} is treated seperately\n\
-@end deftypefn\n\
-@seealso {fft2, ifft, ifftn, fftw_wisdom}")
+@seealso {fft2, ifft, ifftn, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -125,35 +125,35 @@ DEFUN_DLD (fftn, args, ,
 Compute the N dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used. If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
 truncated prior to performing the FFT. Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
-@end deftypefn\n\
-@seealso {ifftn, fft, fft2, fftw_wisdom}")
+@seealso {ifftn, fft, fft2, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN_DLD (ifftn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} ifftn (@var{a}, @var{size})\n\
 Compute the invesre N dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used. If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
 truncated prior to performing the inverse FFT. Otherwise if an element\n\
 of @var{size} is larger than the corresponding dimension @var{a}\n\
 is resized and padded with zeros.\n\
-@end deftypefn\n\
-@seealso {fftn, ifft, ifft2, fftw_wisdom}")
+@seealso {fftn, ifft, ifft2, fftw_wisdom}\n\
+@end deftypefn")
 {
   return do_fftn (args, "ifftn", 1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/fftw_wisdom.cc b/src/DLD-FUNCTIONS/fftw_wisdom.cc
--- a/src/DLD-FUNCTIONS/fftw_wisdom.cc
+++ b/src/DLD-FUNCTIONS/fftw_wisdom.cc
@@ -77,18 +77,18 @@ restarting Octave. However, if it is sav
 can be reloaded. Also, any system-wide wisdom file that has been found\n\
 will also be used. Saved wisdom files should not be used on different\n\
 platforms since they will not be efficient and the point of calculating\n\
 the wisdom is lost.\n\
 \n\
 Note that the program @code{fftw-wisdom} supplied with FFTW can equally\n\
 be used to create a file containing wisdom that can be imported into\n\
 Octave.\n\
-@end deftypefn\n\
-@seealso {fft, ifft, fft2, ifft2, fftn, ifftn}")
+@seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("fftw_wisdom");
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -58,18 +58,18 @@ gammainc (x, a) = ---------    | exp (-t
 with the limiting value of 1 as @var{x} approaches infinity.\n\
 The standard notation is @math{P(a,x)}, e.g. Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
 for each element of @var{x} and vice versa.\n\
 \n\
 If neither @var{x} nor @var{a} is scalar, the sizes of @var{x} and\n\
 @var{a} must agree, and @var{gammainc} is applied element-by-element.\n\
-@end deftypefn\n\
-@seealso{gamma and lgamma}")
+@seealso{gamma, lgamma}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_value x_arg = args(0);
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -79,18 +79,18 @@ that,\n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @end iftex\n\
 \n\
 For backward compatiability with previous versions of this function, when\n\
 all arguments are scalr, a single return argument @var{v1} containing\n\
 all of the values of @var{v1}, @var{...} is acceptable.\n\
-@end deftypefn\n\
-@seealso{lcm, min, max, ceil, and floor}")
+@seealso{lcm, min, max, ceil, floor}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       print_usage ("gcd");
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -84,18 +84,18 @@ factors. The default is @code{false}.\n\
 \n\
 @item thresh\n\
 Defines the pivot threshold in the interval [0,1]. Values outside that\n\
 range are ignored.\n\
 @end table\n\
 \n\
 All other fields in @var{opts} are ignored. The outputs from @dfn{luinc}\n\
 are the same as for @dfn{lu}.\n\
-@end deftypefn\n\
-@seealso{sparse, lu, cholinc}")
+@seealso{sparse, lu, cholinc}\n\
+@end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin == 0)
     print_usage ("luinc");
   else if (nargin != 2)
     error ("luinc: incorrect number of arguments");
diff --git a/src/DLD-FUNCTIONS/odessa.cc b/src/DLD-FUNCTIONS/odessa.cc
--- a/src/DLD-FUNCTIONS/odessa.cc
+++ b/src/DLD-FUNCTIONS/odessa.cc
@@ -398,18 +398,18 @@ discontinuity in the derivative.\n\
 After a successful computation, the value of @var{istate} will be 2\n\
 (consistent with the Fortran version of @sc{Odessa}).\n\
 \n\
 If the computation is not successful, @var{istate} will be something\n\
 other than 2 and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{odessa_options} to set optional\n\
 parameters for @code{odessa}.\n\
-@end deftypefn\n\
-@seealso{daspk, dassl, dasrt, lsode}")
+@seealso{daspk, dassl, dasrt, lsode}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_b_imaginary = false;
 
   unwind_protect::begin_frame ("Fodessa");
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -615,60 +615,60 @@ returns column vectors @var{i},@var{j},@
 // PKG_ADD: dispatch ("prod", "spprod", "sparse matrix");
 // PKG_ADD: dispatch ("prod", "spprod", "sparse complex matrix");
 // PKG_ADD: dispatch ("prod", "spprod", "sparse bool matrix");
 DEFUN_DLD (spprod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} spprod (@var{x},@var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is omitted,\n\
 it defaults to 1 (column-wise products).\n\
-@end deftypefn\n\
-@seealso{spsum, spsumsq}")
+@seealso{spsum, spsumsq}\n\
+@end deftypefn")
 {
   SPARSE_DIM_ARG_BODY (spprod, prod);
 }
 
 // PKG_ADD: dispatch ("cumprod", "spcumprod", "sparse matrix");
 // PKG_ADD: dispatch ("cumprod", "spcumprod", "sparse complex matrix");
 // PKG_ADD: dispatch ("cumprod", "spcumprod", "sparse bool matrix");
 DEFUN_DLD (spcumprod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} spcumprod (@var{x},@var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to 1 (column-wise cumulative products).\n\
-@end deftypefn\n\
-@seealso{spcumsum}")
+@seealso{spcumsum}\n\
+@end deftypefn")
 {
   SPARSE_DIM_ARG_BODY (spcumprod, cumprod);
 }
 
 // PKG_ADD: dispatch ("sum", "spsum", "sparse matrix");
 // PKG_ADD: dispatch ("sum", "spsum", "sparse complex matrix");
 // PKG_ADD: dispatch ("sum", "spsum", "sparse bool matrix");
 DEFUN_DLD (spsum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} spsum (@var{x},@var{dim})\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is omitted, it\n\
 defaults to 1 (column-wise sum).\n\
-@end deftypefn\n\
-@seealso{spprod, spsumsq}")
+@seealso{spprod, spsumsq}\n\
+@end deftypefn")
 {
   SPARSE_DIM_ARG_BODY (spsum, sum);
 }
 
 // PKG_ADD: dispatch ("cumsum", "spcumsum", "sparse matrix");
 // PKG_ADD: dispatch ("cumsum", "spcumsum", "sparse complex matrix");
 // PKG_ADD: dispatch ("cumsum", "spcumsum", "sparse bool matrix");
 DEFUN_DLD (spcumsum, args, , 
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} spcumsum (@var{x},@var{dim})\n\
 Cumulative sum of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to 1 (column-wise cumulative sums).\n\
-@end deftypefn\n\
-@seealso{spcumprod}")
+@seealso{spcumprod}\n\
+@end deftypefn")
 {
   SPARSE_DIM_ARG_BODY (spcumsum, cumsum);
 }
 
 // PKG_ADD: dispatch ("sumsq", "spsumsq", "sparse matrix");
 // PKG_ADD: dispatch ("sumsq", "spsumsq", "sparse complex matrix");
 // PKG_ADD: dispatch ("sumsq", "spsumsq", "sparse bool matrix");
 DEFUN_DLD (spsumsq, args, ,
@@ -677,18 +677,18 @@ DEFUN_DLD (spsumsq, args, ,
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to 1 (column-wise sum of squares).\n\
 This function is equivalent to computing\n\
 @example\n\
 spsum (x .* spconj (x), dim)\n\
 @end example\n\
 but it uses less memory and avoids calling @code{spconj} if @var{x} is\n\
 real.\n\
-@end deftypefn\n\
-@seealso{spprod, spsum}")
+@seealso{spprod, spsum}\n\
+@end deftypefn")
 {
   SPARSE_DIM_ARG_BODY (spsumsq, sumsq);
 }
 
 #define MINMAX_BODY(FCN) \
  \
   octave_value_list retval;  \
  \
@@ -1235,19 +1235,18 @@ the vector is placed on the main diagona
 spdiag ([1, 2, 3], 1)\n\
 ans =\n\
 \n\
 Compressed Column Sparse (rows=4, cols=4, nnz=3)\n\
   (1 , 2) -> 1\n\
   (2 , 3) -> 2\n\
   (3 , 4) -> 3\n\
 @end example\n\
-\n\
-@end deftypefn\n\
-@seealso{diag}")
+@seealso{diag}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_spdiag (args(0), octave_value(0.));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -153,18 +153,18 @@ is the factorization of @code{@var{a}(@v
 @ifinfo\n\
 \n\
 @example\n\
 r' * r = q * a * q'.\n\
 @end example\n\
 @end ifinfo\n\
 \n\
 Note that @code{splchol} factorizations is faster and use less memory.\n\
-@end deftypefn\n\
-@seealso{spcholinv, spchol2inv, splchol}")
+@seealso{spcholinv, spchol2inv, splchol}\n\
+@end deftypefn")
 {
   return sparse_chol (args, nargout, "spchol", false);
 }
 
 // PKG_ADD: dispatch ("lchol", "splchol", "sparse matrix");
 // PKG_ADD: dispatch ("lchol", "splchol", "sparse complex matrix");
 // PKG_ADD: dispatch ("lchol", "splchol", "sparse bool matrix");
 DEFUN_DLD (splchol, args, nargout,
@@ -203,18 +203,18 @@ is the factorization of @code{@var{a}(@v
 @example\n\
 r * r' = a (q, q).\n\
 @end example\n\
 @end ifinfo\n\
 \n\
 Note that @code{splchol} factorizations is faster and use less memory\n\
 than @code{spchol}. @code{splchol(@var{a})} is equivalent to\n\
 @code{spchol(@var{a})'}.\n\
-@end deftypefn\n\
-@seealso{spcholinv, spchol2inv, splchol}")
+@seealso{spcholinv, spchol2inv, splchol}\n\
+@end deftypefn")
 {
   return sparse_chol (args, nargout, "splchol", true);
 }
 
 // PKG_ADD: dispatch ("cholinv", "spcholinv", "sparse matrix");
 // PKG_ADD: dispatch ("cholinv", "spcholinv", "sparse complex matrix");
 // PKG_ADD: dispatch ("cholinv", "spcholinv", "sparse bool matrix");
 DEFUN_DLD (spcholinv, args, ,
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -63,18 +63,18 @@ column permutations @var{Q} can be passe
 to be fixed if three are fewer than four output arguments. Otherwise,\n\
 the updated column permutations are returned as the fourth argument.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
 With two or three output arguments, if a user-defined @var{Q} is given,\n\
 then @code{@var{u} * @var{Q}'} is returned. The matrix is not required to\n\
 be square.\n\
-@end deftypefn\n\
-@seealso{sparse, spinv, colamd, symamd}")
+@seealso{sparse, spinv, colamd, symamd}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout > 4)
     {
       print_usage ("splu");
diff --git a/src/DLD-FUNCTIONS/spqr.cc b/src/DLD-FUNCTIONS/spqr.cc
--- a/src/DLD-FUNCTIONS/spqr.cc
+++ b/src/DLD-FUNCTIONS/spqr.cc
@@ -65,19 +65,18 @@ If an additional matrix @var{b} is suppl
 @var{c}, where @code{@var{c} = @var{q}' * @var{b}}. This allows the\n\
 least squares approximation of @code{@var{a} \\ @var{b}} to be calculated\n\
 as\n\
 \n\
 @example\n\
 [@var{c},@var{r}] = spqr (@var{a},@var{b})\n\
 @var{x} = @var{r} \\ @var{c}\n\
 @end example\n\
-\n\
-@end deftypefn\n\
-@seealso{spchol, qr}")
+@seealso{spchol, qr}\n\
+@end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
   bool economy = false;
   bool is_cmplx = false;
   bool have_b = false;
 
   if (nargin < 1 || nargin > 3)
@@ -241,18 +240,18 @@ diagonal.\n\
 Called with two or more output arguments, returns the row and column\n\
 permutations, such that @code{@var{s} (@var{p}, @var{q})} is in block\n\
 triangular form. The values of @var{r} and @var{s} define the boundaries\n\
 of the blocks. If @var{s} is square then @code{@var{r} == @var{s}}.\n\
 \n\
 The method used is described in: A. Pothen & C.-J. Fan. Computing the block\n\
 triangular form of a sparse matrix. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
-@end deftypefn\n\
-@seealso{colamd,ccolamd}")
+@seealso{colamd, ccolamd}\n\
+@end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
   
 #if HAVE_CXSPARSE
   if (nargin != 1)
     {
       print_usage ("dmperm");
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -110,18 +110,18 @@ sqrtm_from_schur (const ComplexMatrix& U
 DEFUN_DLD (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{result}, @var{error_estimate}] =} sqrtm (@var{a})\n\
 Compute the matrix square root of the square matrix @var{a}.\n\
 \n\
 Ref: Nicholas J. Higham. A new sqrtm for MATLAB. Numerical Analysis\n\
 Report No. 336, Manchester Centre for Computational Mathematics,\n\
 Manchester, England, January 1999.\n\
-@end deftypefn\n\
-@seealso{expm, logm, and funm}")
+@seealso{expm, logm, funm}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("sqrtm");
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -255,40 +255,40 @@ 02110-1301, USA.
  \
   return retval
 
 DEFUN (bitand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of nonnegative integers.\n\
 @var{x}, @var{y} must be in range [0..bitmax]\n\
-@end deftypefn\n\
-@seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}")
+@seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
+@end deftypefn")
 {
   BITOP (&, "bitand");
 }
 
 DEFUN (bitor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitor (@var{x}, @var{y})\n\
 Return the bitwise OR of nonnegative integers.\n\
 @var{x}, @var{y} must be in range [0..bitmax]\n\
-@end deftypefn\n\
-@seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}")
+@seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
+@end deftypefn")
 {
   BITOP (|, "bitor");
 }
 
 DEFUN (bitxor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitxor (@var{x}, @var{y})\n\
 Return the bitwise XOR of nonnegative integers.\n\
 @var{x}, @var{y} must be in range [0..bitmax]\n\
-@end deftypefn\n\
-@seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}")
+@seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
+@end deftypefn")
 {
   BITOP (^, "bitxor");
 }
 
 static EIGHT_BYTE_INT
 bitshift (double a, int n, EIGHT_BYTE_INT mask)
 {
   if (n > 0)
@@ -399,18 +399,18 @@ 0 0 2\n\
 @end group\n\
 \n\
 bitshift (10, [-2, -1, 0, 1, 2])\n\
 @result{} 2   5  10  20  40\n\
 \n\
 bitshift ([1, 10], 2, [3,4])\n\
 @result{} 4  8\n\
 @end example\n\
-@end deftypefn\n\
-@seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax}")
+@seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       int nbits = 64;
@@ -511,17 +511,17 @@ unsigned 8-bit integer.\n\
 unsigned 16-bit integer.\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
-@seealso{intmin,bitmax}\n\
+@seealso{intmin, bitmax}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
@@ -574,17 +574,17 @@ unsigned 8-bit integer.\n\
 unsigned 16-bit integer.\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
-@seealso{intmax,bitmax}\n\
+@seealso{intmax, bitmax}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -773,18 +773,18 @@ do_cat (const octave_value_list& args, s
   return retval;
 }
 
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-d array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
-@end deftypefn\n\
-@seealso{cat and vertcat}")
+@seealso{cat, vertcat}\n\
+@end deftypefn")
 {
   octave_value_list args_tmp = args;
   
   int dim = 2;
   
   octave_value d (dim);
   
   args_tmp.prepend (d);
@@ -792,18 +792,18 @@ Return the horizontal concatenation of N
   return do_cat (args_tmp, "horzcat");
 }
 
 DEFUN (vertcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-d array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
-@end deftypefn\n\
-@seealso{cat and horzcat}")
+@seealso{cat, horzcat}\n\
+@end deftypefn")
 {
   octave_value_list args_tmp = args;
   
   int dim = 1;
   
   octave_value d (dim);
   
   args_tmp.prepend (d);
@@ -851,19 +851,18 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
      1 1\n\
      1 1\n\
 \n\
    ans(:,:,1,2) =\n\
      0 0\n\
      0 0\n\
 @end group\n\
 @end example\n\
-\n\
-@end deftypefn\n\
-@seealso{horzcat and vertcat}")
+@seealso{horzcat, vertcat}\n\
+@end deftypefn")
 {
   return do_cat (args, "cat");
 }
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv, const std::string& fname)
 {
   octave_value retval;
@@ -892,35 +891,33 @@ do_permute (const octave_value_list& arg
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\n\
 Return the generalized transpose for an N-d array object @var{a}.\n\
 The permutation vector @var{perm} must contain the elements\n\
 @code{1:ndims(a)} (in any order, but each element must appear just once).\n\
-\n\
-@end deftypefn\n\
-@seealso{ipermute}")
+@seealso{ipermute}\n\
+@end deftypefn")
 {
   return do_permute (args, false, "permute");
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
 ipermute (permute (a, perm), perm)\n\
 @end example\n\
 returns the original array @var{a}.\n\
-\n\
-@end deftypefn\n\
-@seealso{permute}")
+@seealso{permute}\n\
+@end deftypefn")
 {
   return do_permute (args, true, "ipermute");
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
 Return the `length' of the object @var{a}.  For matrix objects, the\n\
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -89,19 +89,18 @@ Set a breakpoint in a function\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
 Line you would like the breakpoint to be set on\n\
 @end table\n\
 \n\
 The rline returned is the real line that the breakpoint was set at.\n\
-\n\
-@end deftypefn\n\
-@seealso{dbclear, dbstatus, dbnext}")
+@seealso{dbclear, dbstatus, dbnext}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int result = -1;
   int nargin = args.length ();
 
   string_vector argv = args.make_argv ("dbstop");
 
@@ -158,18 +157,18 @@ Delete a breakpoint in a function\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
 Line where you would like to remove the the breakpoint\n\
 @end table\n\
 No checking is done to make sure that the line you requested is really\n\
 a breakpoint.   If you get the wrong line nothing will happen.\n\
-@end deftypefn\n\
-@seealso{dbstop, dbstatus, dbwhere}")
+@seealso{dbstop, dbstatus, dbwhere}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   std::string symbol_name = "";
   std::string line_number;
 
   int line = -1;
   int nargin = args.length ();
@@ -220,18 +219,18 @@ DEFCMD (dbstatus, args, ,
 @deftypefn {Loadable Function} {lst =} dbstatus ([func])\n\
 Return a vector containing the lines on which a function has \n\
 breakpoints set.\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out.\n\
 @end table\n\
-@end deftypefn\n\
-@seealso{dbclear, dbwhere}")
+@seealso{dbclear, dbwhere}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 0 && nargin != 1)
     {
       error ("dbstatus: only zero or one arguements accepted\n");
@@ -273,18 +272,18 @@ mode this should be left out.\n\
 
   return retval;
 }
 
 DEFCMD (dbwhere, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbwhere ()\n\
 Show where we are in the code\n\
-@end deftypefn\n\
-@seealso{dbclear, dbstatus, dbstop}")
+@seealso{dbclear, dbstatus, dbstop}\n\
+@end deftypefn\")
 {
   octave_value retval;
 
   octave_user_function *dbg_fcn = 0;
 
   if (curr_caller_function && curr_caller_function->is_user_function ())
     dbg_fcn = dynamic_cast<octave_user_function *> (curr_caller_function);
 
@@ -351,18 +350,18 @@ do_dbtype (std::ostream& os, const std::
     os << "dbtype: unkown function";
 
 }
 
 DEFCMD (dbtype, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbtype ()\n\
 List script file with line numbers.\n\
-@end deftypefn\n\
-@seealso{dbclear, dbstatus, dbstop}")
+@seealso{dbclear, dbstatus, dbstop}\n\
+@end deftypefn")
 {
   octave_value retval;
   octave_user_function *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
   if (! error_state)
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -187,18 +187,18 @@ fopen_mode_to_ios_mode (const std::strin
   return retval;
 }
 
 DEFUN (fclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclose (@var{fid})\n\
 Closes the specified file.  If successful, @code{fclose} returns 0,\n\
 otherwise, it returns -1.\n\
-@end deftypefn\n\
-@seealso{fopen, fseek, ftell}")
+@seealso{fopen, fseek, ftell}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = octave_stream_list::remove (args(0), "fclose");
   else
@@ -237,18 +237,18 @@ DEFUN (fflush, args, ,
 @deftypefn {Built-in Function} {} fflush (@var{fid})\n\
 Flush output to @var{fid}.  This is useful for ensuring that all\n\
 pending output makes it to the screen before some other event occurs.\n\
 For example, it is always a good idea to flush the standard output\n\
 stream before calling @code{input}.\n\
 \n\
 @code{fflush} returns 0 on success and an OS dependent error value\n\
 (@minus{}1 on unix) on error.\n\
-@end deftypefn\n\
-@seealso{fopen, fclose}")
+@seealso{fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       // XXX FIXME XXX -- any way to avoid special case for stdout?
@@ -281,18 +281,18 @@ DEFUN (fgetl, args, ,
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, excluding\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgetl} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgetl} returns @minus{}1.\n\
-@end deftypefn\n\
-@seealso{fread, fscanf}")
+@seealso{fread, fscanf}\n\
+@end deftypefn")
 {
   static std::string who = "fgetl";
 
   octave_value_list retval;
 
   retval(1) = 0;
   retval(0) = -1;
 
@@ -330,18 +330,18 @@ DEFUN (fgets, args, ,
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, including\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgets} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgets} returns @minus{}1.\n\
-@end deftypefn\n\
-@seealso{fread, fscanf}")
+@seealso{fread, fscanf}\n\
+@end deftypefn")
 {
   static std::string who = "fgets";
 
   octave_value_list retval;
 
   retval(1) = 0.0;
   retval(0) = -1.0;
 
@@ -555,18 +555,18 @@ VAX G floating format.\n\
 \n\
 @samp{cray}\n\
 Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 however, conversions are currently only supported for @samp{native}\n\
 @samp{ieee-be}, and @samp{ieee-le} formats.\n\
-@end deftypefn\n\
-@seealso{fclose, fread, fseek}")
+@seealso{fclose, fread, fseek}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -697,18 +697,18 @@ Set the file pointer to any location wit
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @code{SEEK_CUR} (current\n\
 position), @code{SEEK_SET} (beginning), or @code{SEEK_END} (end of\n\
 file) or strings \"cof\", \"bof\" or \"eof\". If @var{origin} is omitted,\n\
 @code{SEEK_SET} is assumed.  The offset must be zero, or a value returned\n\
 by @code{ftell} (in which case @var{origin} must be @code{SEEK_SET}).\n\
 \n\
 Return 0 on success and -1 on error.\n\
-@end deftypefn\n\
-@seealso{ftell, fopen, fclose}")
+@seealso{ftell, fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fseek");
@@ -727,18 +727,18 @@ Return 0 on success and -1 on error.\n\
   return retval;
 }
 
 DEFUN (ftell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters\n\
 from the beginning of the file @var{fid}.\n\
-@end deftypefn\n\
-@seealso{fseek, fopen, fclose}")
+@seealso{fseek, fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ftell");
@@ -752,18 +752,18 @@ from the beginning of the file @var{fid}
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
 written to the stream @var{fid} instead of @code{stdout}.\n\
-@end deftypefn\n\
-@seealso{printf, sprintf, fread, fscanf, fopen, fclose}")
+@seealso{printf, sprintf, fread, fscanf, fopen, fclose}\n\
+@end deftypefn")
 {
   static std::string who = "fprintf";
 
   octave_value retval;
 
   int result = -1;
 
   int nargin = args.length ();
@@ -814,18 +814,18 @@ written to the stream @var{fid} instead 
 
 DEFUN (printf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} printf (@var{template}, @dots{})\n\
 Print optional arguments under the control of the template string\n\
 @var{template} to the stream @code{stdout}.\n\
 \n\
 Return the number of characters printed.\n\
-@end deftypefn\n\
-@seealso{fprintf, sprintf, scanf}")
+@seealso{fprintf, sprintf, scanf}\n\
+@end deftypefn")
 {
   static std::string who = "printf";
 
   octave_value retval;
 
   int result = -1;
 
   int nargin = args.length ();
@@ -908,18 +908,18 @@ Return a non-negative number on success 
 DEFUN (sprintf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.  Unlike the C library function, which requires you to provide a\n\
 suitably sized string as an argument, Octave's @code{sprintf} function\n\
 returns the string, automatically sized to hold all of the items\n\
 converted.\n\
-@end deftypefn\n\
-@seealso{printf, fprintf, sscanf}")
+@seealso{printf, fprintf, sscanf}\n\
+@end deftypefn")
 {
   static std::string who = "sprintf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
@@ -998,18 +998,18 @@ conversions.\n\
 \n\
 The number of items successfully read is returned in @var{count}.\n\
 \n\
 In the second form, read from @var{fid} according to @var{template},\n\
 with each conversion specifier in @var{template} corresponding to a\n\
 single scalar return value.  This form is more `C-like', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
 conversions is returned in @var{count}\n\
-@end deftypefn\n\
-@seealso{scanf, sscanf, fread, fprintf}")
+@seealso{scanf, sscanf, fread, fprintf}\n\
+@end deftypefn")
 {
   static std::string who = "fscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
@@ -1064,18 +1064,18 @@ conversions is returned in @var{count}\n
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.\n\
-@end deftypefn\n\
-@seealso{fscanf, scanf, sprintf}")
+@seealso{fscanf, scanf, sprintf}\n\
+@end deftypefn")
 {
   static std::string who = "sscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
@@ -1157,18 +1157,18 @@ string is treated as an end-of-file cond
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}]] = } scanf (@var{template}, \"C\")\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
-@end deftypefn\n\
-@seealso{fscanf, sscanf, printf}")
+@seealso{fscanf, sscanf, printf}\n\
+@end deftypefn")
 {
   int nargin = args.length ();
 
   octave_value_list tmp_args (nargin+1, octave_value ());
 
   tmp_args (0) = 0.0;
   for (int i = 0; i < nargin; i++)
     tmp_args (i+1) = args (i);
@@ -1401,18 +1401,18 @@ Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 Conversions are currently only supported for @code{\"ieee-be\"} and\n\
 @code{\"ieee-le\"} formats.\n\
 \n\
 The data read from the file is returned in @var{val}, and the number of\n\
 values read is returned in @code{count}\n\
-@end deftypefn\n\
-@seealso{fwrite, fopen, fclose}")
+@seealso{fwrite, fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 6)
     {
       retval(1) = -1.0;
@@ -1513,18 +1513,18 @@ file.\n\
 The argument @var{data} is a matrix of values that are to be written to\n\
 the file.  The values are extracted in column-major order.\n\
 \n\
 The remaining arguments @var{precision}, @var{skip}, and @var{arch} are\n\
 optional, and are interpreted as described for @code{fread}.\n\
 \n\
 The behavior of @code{fwrite} is undefined if the values in @var{data}\n\
 are too large to fit in the specified precision.\n\
-@end deftypefn\n\
-@seealso{fread, fopen, fclose}")
+@seealso{fread, fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 6)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
@@ -1555,18 +1555,18 @@ are too large to fit in the specified pr
 
 DEFUN (feof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for a given\n\
 file and 0 otherwise.  Note that it will only return 1 if the end of the\n\
 file has already been encountered, not if the next read operation will\n\
 result in an end-of-file condition.\n\
-@end deftypefn\n\
-@seealso{fread, fopen, fclose}")
+@seealso{fread, fopen, fclose}\n\
+@end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "feof");
@@ -1724,18 +1724,18 @@ DEFUN (tmpnam, args, ,
 Return a unique temporary file name as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @code{\"oct-\"} is used.\n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 is used.  If @var{dir} is provided, it must exist, otherwise the default\n\
 directory for temporary files is used.  Since the named file is not\n\
 opened, by @code{tmpnam}, it is possible (though relatively unlikely)\n\
 that it will not be available by the time your program attempts to open it.\n\
-@end deftypefn\n\
-@seealso{tmpfile, mkstemp, P_tmpdir}")
+@seealso{tmpfile, mkstemp, P_tmpdir}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int len = args.length ();
 
   if (len < 3)
     {
       std::string dir = len > 0 ? args(0).string_value () : std::string ();
@@ -1767,18 +1767,18 @@ DEFUN (tmpfile, args, ,
 Return the file ID corresponding to a new temporary file with a unique\n\
 name.  The file is opened in binary read/write (@code{\"w+b\"}) mode.\n\
 The file will be deleted automatically when it is closed or when Octave\n\
 exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
 system-dependent error message.\n\
-@end deftypefn\n\
-@seealso{tmpnam, mkstemp, P_tmpdir}")
+@seealso{tmpnam, mkstemp, P_tmpdir}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
@@ -1827,18 +1827,18 @@ with the @code{O_EXCL} flag.\n\
 If the optional argument @var{delete} is supplied and is true,\n\
 the file will be deleted automatically when Octave exits, or when\n\
 the function @code{purge_tmp_files} is called.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of\n\
 the file, and and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
 is -1, @var{name} is empty, and @var{msg} contains a system-dependent\n\
 error message.\n\
-@end deftypefn\n\
-@seealso{tmpfile, tmpnam, P_tmpdir}")
+@seealso{tmpfile, tmpnam, P_tmpdir}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = -1;
 
 #if defined (HAVE_MKSTEMP)
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1532,18 +1532,18 @@ functions to the terminal. Otherwise the
 each of their help strings.\n\
 \n\
 Note that the ability of @code{lookfor} to correctly identify the first\n\
 sentence of the help of the functions is dependent on the format of the\n\
 functions help. All of the functions in octave itself will correctly\n\
 find the first sentence, but the same can not be guaranteed for other\n\
 functions. Therefore the use of the '-all' argument might be necessary\n\
 to find related functions that are not part of octave.\n\
-@end deffn\n\
-@seealso{which, help}")
+@seealso{which, help}\n\
+@end deffn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool first_sentence_only = true;
 
   if (nargin != 1 && nargin != 2)
     {
       usage ("lookfor");
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1839,17 +1839,17 @@ void
 symbols_of_load_save (void)
 {
   DEFVAR (crash_dumps_octave_core, true, crash_dumps_octave_core,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} crash_dumps_octave_core\n\
 If this variable is set to a nonzero value, Octave tries to save all\n\
 current variables the the file \"octave-core\" if it crashes or receives a\n\
 hangup, terminate or similar signal.  The default value is 1.\n\
-@seealso{octave_core_file_limit, octave_core_file_name, and octave_core_file_options}\n\
+@seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end defvr");
 
   DEFVAR (default_save_options, "-text", default_save_options,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} default_save_options\n\
 This variable specifies the default options for the @code{save} command,\n\
 and is used to define the default format. Typical values include,\n\
 @code{\"-ascii\"}, @code{\"-ascii -zip\"}. For other possible options\n\
@@ -1862,36 +1862,36 @@ see the @code{save} command. The initial
 @defvr {Built-in Variable} octave_core_file_limit\n\
 The maximum amount of memory (in kilobytes) of the top-level workspace\n\
 that Octave will attempt to write when saving data to the\n\
 @var{octave_core_file_name}.  If @var{octave_core_file_options} flags a\n\
 binary format, then @var{octave_core_file_limit} will be approximately\n\
 the maximum size of the file.  If a text file format is used, then the\n\
 file could be much larger than the limit.\n\
 The default value is -1 (unlimited)\n\
-@seealso{crash_dumps_octave_core, octave_core_file_name, and octave_core_file_options}\n\
+@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end defvr");
 
   DEFVAR (octave_core_file_name, "octave-core", octave_core_file_name,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} octave_core_file_name\n\
 The name of the file used for saving data from the top-level workspace\n\
 when Octave aborts.  The default value is @code{\"octave-core\"}\n\
-@seealso{crash_dumps_octave_core, octave_core_file_name, and octave_core_file_options}\n\
+@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end defvr");
 
   DEFVAR (octave_core_file_options, "-binary", octave_core_file_options,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} octave_core_file_options\n\
 If Octave aborts, it attempts to save the contents of the top-level\n\
 workspace in a file using this variable to define the format. The value of\n\
 @code{octave_core_file_options} should follow the same format as the options\n\
 that may be used with @code{save}. The default value is Octave's binary\n\
 format.\n\
-@seealso{crash_dumps_octave_core, octave_core_file_name, and octave_core_file_limit}\n\
+@seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end defvr");
 
   DEFVAR (save_header_format_string, default_save_header_format (),
 	  save_header_format_string,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} save_header_format_string\n\
 This variable specifies the the format string for the comment line\n\
 that is written at the beginning of text-format data files saved by\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -274,18 +274,18 @@ Return the complex conjugate of @var{z},
 @iftex\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifinfo\n\
-@end deftypefn\n\
-@seealso{real and imag}");
+@seealso{real, imag}\n\
+@end deftypefn\n\");
 
   DEFUN_MAPPER (cos, 0, 0, 0, cos, 0, std::cos, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (cosh, 0, 0, 0, cosh, 0, std::cosh, 0.0, 0.0, 0, 0,
@@ -310,34 +310,33 @@ Computes the error function,\n\
 @smallexample\n\
                          z\n\
                         /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
                         /\n\
                      t=0\n\
 @end smallexample\n\
 @end ifinfo\n\
-@end deftypefn\n\
-@seealso{erfc and erfinv}");
+@seealso{erfc, erfinv}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (erfc, 0, 0, 0, erfc, 0, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Computes the complementary error function,\n\
 @iftex\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifinfo\n\
-@end deftypefn\n\
-\n\
-@seealso{erf and erfinv}");
+@seealso{erf, erfinv}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (exp, 0, 0, 0, exp, 0, std::exp, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute the exponential of @var{x}.  To compute the matrix exponential,\n\
 see @ref{Linear Algebra}.\n\
 @end deftypefn");
 
@@ -385,27 +384,25 @@ Computes the Gamma function,\n\
 @example\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
 @end example\n\
 @end ifinfo\n\
-@end deftypefn\n\
-\n\
-@seealso{gammai and lgamma}");
+@seealso{gammai, lgamma}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (imag, 0, 0, 0, imag, ximag, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
-@end deftypefn\n\
-\n\
-@seealso{real and conj}");
+@seealso{real, conj}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (isalnum, xisalnum, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return 1 for characters that are letters or digits (@code{isalpha\n\
 (@var{s})} or @code{isdigit (@var{s})} is true).\n\
 @end deftypefn");
 
@@ -520,48 +517,48 @@ Return 1 for upper case letters.\n\
 Return 1 for characters that are hexadecimal digits.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (lgamma, 0, 0, 0, xlgamma, 0, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function.\n\
-@end deftypefn\n\
-@seealso{gamma and gammai}");
+@seealso{gamma, gammai}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (log, 0, 0, 0, log, 0, std::log, 0.0, octave_Inf, 0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
-@end deftypefn\n\
-@seealso{log2, log10, logspace, and exp}");
+@seealso{log2, log10, logspace, exp}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (log10, 0, 0, 0, log10, 0, std::log10, 0.0, octave_Inf, 0, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm for each element of @var{x}.\n\
-@end deftypefn\n\
-@seealso{log, log2, logspace, and exp}");
+@seealso{log, log2, logspace, exp}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (real, 0, 0, 0, real, xreal, 0, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
-@end deftypefn\n\
-@seealso{imag and conj}");
+@seealso{imag, conj}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (round, 0, 0, 0, xround, 0, xround, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
-@end deftypefn\n\
-@seealso{rem}");
+@seealso{rem}\n\
+@end deftypefn");
 
   DEFUN_MAPPER (sign, 0, 0, 0, signum, 0, signum, 0.0, 0.0, 0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sign (@var{x})\n\
 Compute the @dfn{signum} function, which is defined as\n\
 @iftex\n\
 @tex\n\
 $$\n\
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1070,18 +1070,18 @@ array @var{string}.\n\
 
 DEFUN (struct2cell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 If @var{f} is the number of fields in the structure, the resulting\n\
 cell array will have a dimension vector corresponding to\n\
 @code{[@var{F} size(@var{S})]}.\n\
-@end deftypefn\n\
-@seealso{cell2struct, fieldnames}")
+@seealso{cell2struct, fieldnames}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       Octave_map m = args(0).map_value ();
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -579,18 +579,18 @@ ambiguity between their use as a variabl
 constant. All arguments followed by a parentheses are considered\n\
 to be functions.\n\
 \n\
 If the second and subsequent arguments are character strings,\n\
 they are the names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
 @code{\"x\"}, @code{\"P1\"}, @dots{}, @code{\"P@var{N}\"}.\n\
-@end deftypefn\n\
-@seealso{argnames, formula, vectorize}")
+@seealso{argnames, formula, vectorize}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       std::string fun = args(0).string_value ();
@@ -732,18 +732,18 @@ If the second argument is an integer @va
 }
 
 DEFUN (formula, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
-@end deftypefn\n\
-@seealso{argnames, inline, vectorize}")
+@seealso{argnames, inline, vectorize}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_fcn_inline* fn = args(0).fcn_inline_value (true);
@@ -759,18 +759,18 @@ Note that @code{char (@var{fun})} is equ
   return retval;
 }
 
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of\n\
 the arguments of the inline function @var{fun}.\n\
-@end deftypefn\n\
-@seealso{argnames, inline, formula, vectorize}")
+@seealso{argnames, inline, formula, vectorize}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_fcn_inline *fn = args(0).fcn_inline_value (true);
@@ -796,18 +796,17 @@ the arguments of the inline function @va
 }
 
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
 by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
 @code{.*}, @code{./}, etc.\n\
-@end deftypefn\n\
-@seealso{argnames, inline, formula, vectorize}")
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string old_func;
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -956,18 +956,18 @@ A(1)\n\
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmfield (@var{s}, @var{f})\n\
 Remove field @var{f} from the structure @var{s}.  If @var{f} is a\n\
 cell array of character strings or a character array, remove the\n\
 named fields.\n\
-@end deftypefn\n\
-@seealso{cellstr, iscellstr, and setfield")
+@seealso{cellstr, iscellstr, setfield}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       Octave_map m = args(0).map_value ();
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -595,18 +595,17 @@ DEFUN (nargin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn_name})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
 Octave.  If called with the optional argument @var{fcn_name}, return the\n\
 maximum number of arguments the named function can accept, or -1 if the\n\
 function accepts a variable number of arguments.\n\
-\n\
-@seealso{nargout, varargin, and varargout}\n\
+@seealso{nargout, varargin, varargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -669,18 +668,17 @@ will cause @code{nargout} to return 0 in
 [s, t] = f ()\n\
 @end example\n\
 \n\
 @noindent\n\
 will cause @code{nargout} to return 2 inside the function\n\
 @code{f}.\n\
 \n\
 At the top level, @code{nargout} is undefined.\n\
-\n\
-@seealso{nargin, varargin, and varargout}\n\
+@seealso{nargin, varargin, varargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2202,18 +2202,18 @@ install_types (void)
   octave_streamoff::register_type ();
 }
 
 #if 0
 DEFUN (cast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cast (@var{val}, @var{type})\n\
 Convert @var{val} to the new data type @var{type}.\n\
-@end deftypefn\n\
-@seealso{class, typeinfo}")
+@seealso{class, typeinfo}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     error ("cast: not implemented");
   else
     print_usage ("cast");
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2535,18 +2535,18 @@ disp (\"The value of pi is:\"), disp (pi
      @print{} 3.1416\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the output from @code{disp} always ends with a newline.\n\
 \n\
 If an output value is requested, @code{disp} prints nothing and\n\
 returns the formatted output in a string.\n\
-@end deftypefn\n\
-@seealso{fdisp}")
+@seealso{fdisp}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && nargout < 2)
     {
       if (nargout == 0)
@@ -2575,18 +2575,18 @@ Display the value of @var{x} on the stre
 fdisp (stdout, \"The value of pi is:\"), fdisp (stdout, pi)\n\
 \n\
      @print{} the value of pi is:\n\
      @print{} 3.1416\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the output from @code{fdisp} always ends with a newline.\n\
-@end deftypefn\n\
-@seealso{disp}")
+@seealso{disp}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       int fid = octave_stream_list::get_file_number (args (0));
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -281,18 +281,18 @@ If no file is found, return an empty mat
 \n\
 If the first argument is a cell array of strings, search each\n\
 directory of the loadpath for element of the cell array and return\n\
 the first that matches.\n\
 \n\
 If the second optional argument @code{\"all\"} is supplied, return\n\
 a cell array containing the list of all files that have the same\n\
 name in the path.  If no files are found, return an empty cell array.\n\
-@end deftypefn\n\
-@seealso{file_in_path, LOADPATH}")
+@seealso{file_in_path, LOADPATH}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       string_vector names = args(0).all_strings ();
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -140,18 +140,18 @@ unmark_command (const std::string& s)
   if (sr)
     sr->unmark_command ();
 }
 
 DEFCMD (mark_as_command, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mark_as_command (@var{name})\n\
 Enter @var{name} into the list of commands.\n\
-@end deftypefn\n\
-@seealso{unmark_command, iscommand}")
+@seealso{unmark_command, iscommand}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
@@ -174,18 +174,18 @@ Enter @var{name} into the list of comman
 
   return retval;
 }
 
 DEFCMD (unmark_command, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} unmark_command (@var{name})\n\
 Remove @var{name} from the list of commands.\n\
-@end deftypefn\n\
-@seealso{mark_as_command, iscommand}")
+@seealso{mark_as_command, iscommand}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
@@ -233,18 +233,18 @@ is_command_name (const std::string& s)
 }
 
 DEFCMD (iscommand, args, ,
 "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscommand (@var{name})\n\
 Return true if @var{name} is a command style function.  If @var{name}\n\
 is omitted, return a list of identifiers which are marked as commands with\n\
 mark_as_command.\n\
-@end deftypefn\n\
-@seealso{mark_as_command, unmark_command}")
+@seealso{mark_as_command, unmark_command}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       string_vector lst (command_set.size ());
@@ -306,18 +306,18 @@ DEFCMD (mark_as_rawcommand, args, ,
 Enter @var{name} into the list of raw input commands and to the list of\n\
 command style functions.\n\
 Raw input commands are like normal command style functions, but they\n\
 receive their input unprocessed (ie. strings still contain the quotes\n\
 and escapes they had when input). However, comments and continuations\n\
 are handled as usual, you cannot pass a token starting with a comment\n\
 character ('#' or '%') to your function, and the last token cannot be\n\
 a continuation token ('\\' or '...').\n\
-@end deftypefn\n\
-@seealso{unmark_rawcommand, israwcommand, iscommand, mark_as_command}")
+@seealso{unmark_rawcommand, israwcommand, iscommand, mark_as_command}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
@@ -342,18 +342,18 @@ a continuation token ('\\' or '...').\n\
 }
 
 DEFCMD (unmark_rawcommand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} unmark_rawcommand (@var{name})\n\
 Remove @var{name} from the list of raw input commands.\n\
 Note that this does not remove @var{name} from the list of command style\n\
 functions.\n\
-@end deftypefn\n\
-@seealso{mark_as_rawcommand, israwcommand, iscommand, unmark_command}")
+@seealso{mark_as_rawcommand, israwcommand, iscommand, unmark_command}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (at_top_level ())
     {
       int nargin = args.length ();
 
       if (nargin > 0)
@@ -401,18 +401,18 @@ is_rawcommand_name (const std::string& s
 }
 
 DEFCMD (israwcommand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} israwcommand (@var{name})\n\
 Return true if @var{name} is a raw input command function.\n\
 If @var{name} is omitted, return a list of identifiers which are marked as\n\
 raw input commands with mark_as_rawcommand.\n\
-@end deftypefn\n\
-@seealso{mark_as_rawcommand, unmark_rawcommand}")
+@seealso{mark_as_rawcommand, unmark_rawcommand}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       string_vector lst (rawcommand_set.size());
@@ -1825,18 +1825,18 @@ mislocked (const std::string& nm)
   return (sr && sr->is_static ());
 }
 
 DEFCMD (mlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mlock (@var{name})\n\
 Lock the named function into memory.  If no function is named\n\
 then lock in the current function.\n\
-@end deftypefn\n\
-@seealso{munlock, mislocked, and persistent}")
+@seealso{munlock, mislocked, persistent}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
@@ -1857,18 +1857,18 @@ then lock in the current function.\n\
   return retval;
 }
 
 DEFCMD (munlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function.  If no function is named\n\
 then unlock the current function.\n\
-@end deftypefn\n\
-@seealso{mlock, mislocked, and persistent}")
+@seealso{mlock, mislocked, persistent}\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
@@ -1890,18 +1890,18 @@ then unlock the current function.\n\
 }
 
 
 DEFCMD (mislocked, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mislocked (@var{fcn})\n\
 Return true if the named function is locked.  If no function is named\n\
 then return true if the current function is locked.\n\
-@end deftypefn\n\
-@seealso{mlock, munlock, and persistent}")
+@seealso{mlock, munlock, persistent}\n\
+@end deftypefn")
 {
   octave_value retval;
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
