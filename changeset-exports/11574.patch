# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1295500325 18000
#      Thu Jan 20 00:12:05 2011 -0500
# Node ID a83bad07f7e3ecfdb81ed13f54d22804f66f634e
# Parent  6f8ffe2c6f76673f910867d0c03e10b01ab05d7c
attempt better backward compatibility for Array resize functions

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -388,17 +388,17 @@ get_elt_idx (const Array<idx_vector>& ra
 
 Array<octave_idx_type>
 get_ra_idx (octave_idx_type idx, const dim_vector& dims)
 {
   Array<octave_idx_type> retval;
 
   int n_dims = dims.length ();
 
-  retval.resize (n_dims, 1);
+  retval.resize (dim_vector (n_dims, 1));
 
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
   for (octave_idx_type i = 0; i < idx; i++)
     increment_index (retval, dims);
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -943,17 +943,17 @@ Array<T>::resize1 (octave_idx_type n, co
         }
     }
   else
     gripe_invalid_resize ();
 }
 
 template <class T>
 void
-Array<T>::resize (octave_idx_type r, octave_idx_type c, const T& rfv)
+Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r >= 0 && c >= 0 && ndims () == 2)
     {
       octave_idx_type rx = rows (), cx = columns ();
       if (r != rx || c != cx)
         {
           Array<T> tmp = Array<T> (dim_vector (r, c));
           T *dest = tmp.fortran_vec ();
@@ -989,17 +989,17 @@ Array<T>::resize (octave_idx_type r, oct
 }
 
 template<class T>
 void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.length ();
   if (dvl == 2)
-    resize (dv(0), dv(1), rfv);
+    resize2 (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
       if (dimensions.length () <= dvl && ! dv.any_neg ())
         {
           Array<T> tmp (dv);
           // Prepare for recursive resizing.
           rec_resize_helper rh (dv, dimensions.redim (dvl));
 
@@ -1046,17 +1046,17 @@ Array<T>::index (const idx_vector& i, co
       dim_vector dv = dimensions.redim (2);
       octave_idx_type r = dv(0), c = dv(1);
       octave_idx_type rx = i.extent (r), cx = j.extent (c);
       if (r != rx || c != cx)
         {
           if (i.is_scalar () && j.is_scalar ())
             return Array<T> (dim_vector (1, 1), rfv);
           else
-            tmp.resize (rx, cx, rfv);
+            tmp.resize2 (rx, cx, rfv);
         }
 
       if (tmp.rows () != rx || tmp.columns () != cx)
         return Array<T> ();
     }
 
   return tmp.index (i, j);  
 }
@@ -2168,34 +2168,34 @@ Array<T>::find (octave_idx_type n, bool 
             {
               for (;l >= 0 && src[l] == zero; l--) ;
               if (l >= 0)
                 retval(k) = l--;
               else
                 break;
             }
           if (k < n)
-            retval.resize (k, 1);
+            retval.resize2 (k, 1);
           octave_idx_type *rdata = retval.fortran_vec ();
           std::reverse (rdata, rdata + k);
         }
       else
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0, l = 0;
           for (; k < n; k++)
             {
               for (;l != nel && src[l] == zero; l++) ;
               if (l != nel)
                 retval(k) = l++;
               else
                 break;
             }
           if (k < n)
-            retval.resize (k, 1);
+            retval.resize2 (k, 1);
         }
     }
 
   // Fixup return dimensions, for Matlab compatibility.
   // find(zeros(0,0)) -> zeros(0,0)
   // find(zeros(1,0)) -> zeros(1,0)
   // find(zeros(0,1)) -> zeros(0,1)
   // find(zeros(0,X)) -> zeros(0,1)
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -447,18 +447,21 @@ public:
 
   // Resizing (with fill).
 
   void resize1 (octave_idx_type n, const T& rfv = resize_fill_value ());
 
   void resize (octave_idx_type n) GCC_ATTR_DEPRECATED
     { resize1 (n); }
 
-  void resize (octave_idx_type nr, octave_idx_type nc, 
-               const T& rfv = resize_fill_value ());
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               const T& rfv = resize_fill_value ()) GCC_ATTR_DEPRECATED
+  {
+    resize2 (nr, nc, rfv);
+  }
 
   void resize (const dim_vector& dv, const T& rfv = resize_fill_value ());
 
   // Indexing with possible resizing and fill
   // FIXME -- this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
   Array<T> index (const idx_vector& i, bool resize_ok,
@@ -654,16 +657,20 @@ public:
   template <class U> friend class Array;
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
 private:
+
+  void resize2 (octave_idx_type nr, octave_idx_type nc, 
+                const T& rfv = resize_fill_value ());
+
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
 // later type derived from it and override the default non-const operator() to
 // not check for the array's uniqueness. It is, however, the user's
 // responsibility to ensure the array is actually unaliased whenever elements
 // are accessed.
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -127,18 +127,21 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
-  void resize (octave_idx_type n, const Complex& rfv = Array<Complex>::resize_fill_value ())
-    { Array<Complex>::resize (n, 1, rfv); }
+  void resize (octave_idx_type n,
+               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  {
+    Array<Complex>::resize (dim_vector (n, 1), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, ComplexColumnVector, Complex)
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1076,17 +1076,17 @@ ComplexMatrix::finverse (MatrixType &mat
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (lwork, 1);
+      z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1442,17 +1442,17 @@ ComplexMatrix::fourier2d (void) const
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1511,17 +1511,17 @@ ComplexMatrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -2704,17 +2704,17 @@ ComplexMatrix::lssolve (const ComplexMat
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
@@ -2863,19 +2863,19 @@ ComplexMatrix::lssolve (const ComplexCol
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork, 1);
-      rwork.resize (static_cast<octave_idx_type> (rwork(0)), 1);
-      iwork.resize (iwork(0), 1);
+      work.resize (dim_vector (lwork, 1));
+      rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
+      iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
@@ -3288,17 +3288,17 @@ ComplexMatrix::row_min (Array<octave_idx
   ComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_min;
@@ -3362,17 +3362,17 @@ ComplexMatrix::row_max (Array<octave_idx
   ComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_max;
@@ -3436,17 +3436,17 @@ ComplexMatrix::column_min (Array<octave_
   ComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_min;
@@ -3510,17 +3510,17 @@ ComplexMatrix::column_max (Array<octave_
   ComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_max;
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -146,16 +146,22 @@ public:
   ComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               const Complex& rfv = resize_fill_value ())
+  {
+    MArray<Complex>::resize (dim_vector (nr, nc), rfv);
+  }
+
 private:
   ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int force, int calc_cond) const;
 
   ComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int force, int calc_cond) const;
 
 public:
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -107,18 +107,21 @@ public:
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
-  void resize (octave_idx_type n, const Complex& rfv = Array<Complex>::resize_fill_value ())
-    { Array<Complex>::resize (1, n, rfv); }
+  void resize (octave_idx_type n,
+               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  {
+    Array<Complex>::resize (dim_vector (1, n), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -325,17 +325,17 @@ SparseComplexMatrix::max (Array<octave_i
               result.xdata (ii) = tmp;
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize (dim_vector (nr, 1), 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -480,17 +480,17 @@ SparseComplexMatrix::min (Array<octave_i
               result.xdata (ii) = tmp;
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize (dim_vector (nr, 1), 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,26 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* Array.h, Array.cc
+	(Array<T>::resize2 (octave_idx_type, octave_idx_type, const T&)):
+	New private function.
+	(Array<T>::resize (octave_idx_type, octave_idx_type, const T&)):
+	Deprecate.  Call resize2 to do the work.  Remove all uses from
+	Octave.
+
+	* CMatrix.h (ComplexMatrix::resize (octave_idx_type,
+	octave_idx_type, const Complex&)): New function.
+	* dMatrix.h (Matrix::resize (octave_idx_type,
+	octave_idx_type, double)): New function.
+	* fCMatrix.h (FloatComplexMatrix::resize (octave_idx_type,
+	octave_idx_type, const FloatComplex&)): New function.
+	* fMatrix.h (FloatMatrix::resize (octave_idx_type,
+	octave_idx_type, const float)): New function.
+
 2011-01-20  David Bateman  <dbateman@free.fr>
 
 	* Sparce.cc (template <class T> Sparse<T>::Sparse (const Array<T>&,
 	const idx_vector&, const idx_vector&, octave_idx_type,
 	octave_idx_type, bool, octave_idx_type): Fix off by one error in the
 	construction of sparse column vectors. Fix indexing issue in
 	construction of sparse row vectors.
 	* boolSparse.cc (SparseBoolMatrix SparseBoolMatrix::any (int) const):
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn, 1);
+  ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   Complex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -161,17 +161,17 @@ ComplexSVD::init (const ComplexMatrix& a
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
@@ -184,17 +184,17 @@ ComplexSVD::init (const ComplexMatrix& a
 
       F77_XFCN (zgesdd, ZGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgesdd, ZGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
     }
   else
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -26,23 +26,23 @@ OPTION
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -62,23 +62,23 @@ The local error test applied at each int
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -162,17 +162,17 @@ Jacobian.  For convergence, the weighted
 where @code{EPCON} = 0.33 is the analogous test constant used in the
 time steps.  The default is @code{EPINIT} = 0.01.
 @end table
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (6, 1);
+    $OPTVAR.resize (dim_vector (6, 1));
     $OPTVAR(0) = 5.0;
     $OPTVAR(1) = 6.0;
     $OPTVAR(2) = 5.0;
     $OPTVAR(3) = 0.0;
     $OPTVAR(4) = ::pow (DBL_EPSILON, 2.0/3.0);
     $OPTVAR(5) = 0.01;
   END_INIT_BODY
   SET_EXPR = "val"
@@ -214,23 +214,23 @@ in the equation set.
 This option is required by the
 @code{compute consistent initial condition\"} and
 @code{\"exclude algebraic variables from error test\"} options.
 
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
     void set_$OPT (int val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = val;
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -283,23 +283,23 @@ Greater than zero.
 
 This option only has an effect if the
 @code{\"enforce inequality constraints\"} option is nonzero.
 
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
     void set_$OPT (octave_idx_type val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = val;
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -161,17 +161,17 @@ DASPK::do_integrate (double tout)
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASPK_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (20, 1);
+      info.resize (dim_vector (20, 1));
 
       for (octave_idx_type i = 0; i < 20; i++)
         info(i) = 0;
 
       octave_idx_type n = size ();
 
       nn = n;
 
@@ -227,18 +227,18 @@ DASPK::do_integrate (double tout)
         liw += n;
       if (ccic == 1 || eavfet == 1)
         liw += n;
 
       lrw = 50 + 9*n + n*n;
       if (eavfet == 1)
         lrw += n;
 
-      iwork.resize (liw, 1);
-      rwork.resize (lrw, 1);
+      iwork.resize (dim_vector (liw, 1));
+      rwork.resize (dim_vector (lrw, 1));
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
       octave_idx_type abs_tol_len = abs_tol.length ();
       octave_idx_type rel_tol_len = rel_tol.length ();
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -26,23 +26,23 @@ OPTION
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -62,23 +62,23 @@ The local error test applied at each int
       rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -161,17 +161,17 @@ DASRT::integrate (double tout)
 
   if (! initialized || restart
       || DAEFunc::reset || DAERTFunc::reset || DASRT_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (15, 1);
+      info.resize (dim_vector (15, 1));
 
       for (octave_idx_type i = 0; i < 15; i++)
         info(i) = 0;
 
       octave_idx_type n = size ();
 
       nn = n;
 
@@ -202,18 +202,18 @@ DASRT::integrate (double tout)
               integration_error = true;
               return;
             }
         }
 
       liw = 21 + n;
       lrw = 50 + 9*n + n*n + 3*ng;
 
-      iwork.resize (liw, 1);
-      rwork.resize (lrw, 1);
+      iwork.resize (dim_vector (liw, 1));
+      rwork.resize (dim_vector (lrw, 1));
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           info(3) = 1;
           rwork(0) = stop_time;
         }
@@ -250,17 +250,17 @@ DASRT::integrate (double tout)
           integration_error = true;
           return;
         }
 
       info(4) = user_jsub ? 1 : 0;
 
       DAEFunc::reset = false;
 
-      jroot.resize (ng, 1, 1);
+      jroot.resize (dim_vector (ng, 1), 1);
 
       DAERTFunc::reset = false;
 
       // DASRT_options
 
       double mss = maximum_step_size ();
       if (mss >= 0.0)
         {
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -26,23 +26,23 @@ OPTION
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -62,23 +62,23 @@ The local error test applied at each int
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -132,30 +132,30 @@ DASSL::do_integrate (double tout)
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASSL_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (15, 1);
+      info.resize (dim_vector (15, 1));
 
       for (octave_idx_type i = 0; i < 15; i++)
         info(i) = 0;
 
       octave_idx_type n = size ();
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
-      iwork.resize (liw, 1);
-      rwork.resize (lrw, 1);
+      iwork.resize (dim_vector (liw, 1));
+      rwork.resize (dim_vector (lrw, 1));
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           rwork(0) = stop_time;
           info(3) = 1;
         }
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -32,22 +32,23 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 
 #include "DiagArray2.h"
 
 #include "lo-error.h"
 
 template <class T>
-DiagArray2<T>::DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
+DiagArray2<T>::DiagArray2 (const Array<T>& a, octave_idx_type r,
+                           octave_idx_type c)
   : Array<T> (a.as_column ()), d1 (r), d2 (c)
 {
   octave_idx_type rcmin = std::min (r, c);
   if (rcmin != a.length ())
-      Array<T>::resize (rcmin, 1);
+    Array<T>::resize (dim_vector (rcmin, 1));
 }
 
 template <class T>
 Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   Array<T> d;
 
@@ -101,17 +102,17 @@ DiagArray2<T>::resize (octave_idx_type r
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
   if (r != dim1 () || c != dim2 ())
     {
-      Array<T>::resize (std::min (r, c), 1, rfv);
+      Array<T>::resize (dim_vector (std::min (r, c), 1), rfv);
       d1 = r; d2 = c;
     }
 }
 
 template <class T>
 Array<T>
 DiagArray2<T>::array_value (void) const
 {
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -25,23 +25,23 @@ OPTION
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector.
 
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1, 1);
+    $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1, 1);
+        $OPTVAR.resize (dim_vector (1, 1));
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -150,22 +150,22 @@ LSODE::do_integrate (double tout)
           method_flag = 10;
 
           liw = 20;
           lrw = 22 + 16 * n;
         }
 
       maxord = maximum_order ();
 
-      iwork.resize (liw, 1);
+      iwork.resize (dim_vector (liw, 1));
 
       for (octave_idx_type i = 4; i < 9; i++)
         iwork(i) = 0;
 
-      rwork.resize (lrw, 1);
+      rwork.resize (dim_vector (lrw, 1));
 
       for (octave_idx_type i = 4; i < 9; i++)
         rwork(i) = 0;
 
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -185,20 +185,20 @@ SparseComplexLU::SparseComplexLU (const 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   Rfact.xridx (i) = i;
                   Rfact.xcidx (i) = i;
                 }
               Rfact.xcidx (nr) = nr;
               double *Rx = Rfact.data ();
 
-              P.resize (nr, 1);
+              P.resize (dim_vector (nr, 1));
               octave_idx_type *p = P.fortran_vec ();
 
-              Q.resize (nc, 1);
+              Q.resize (dim_vector (nc, 1));
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
                                                     reinterpret_cast<double *> (Ltx),
                                                     0, Up, Uj,
                                                     reinterpret_cast <double *> (Ux),
                                                     0, p, q, 0, 0,
@@ -412,20 +412,20 @@ SparseComplexLU::SparseComplexLU (const 
                   for (octave_idx_type i = 0; i < nr; i++)
                     {
                       Rfact.xridx (i) = i;
                       Rfact.xcidx (i) = i;
                     }
                   Rfact.xcidx (nr) = nr;
                   double *Rx = Rfact.data ();
 
-                  P.resize (nr, 1);
+                  P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
-                  Q.resize (nc, 1);
+                  Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = 
                     UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
                                             reinterpret_cast<double *> (Ltx),
                                             0, Up, Uj,
                                             reinterpret_cast<double *> (Ux), 
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -178,20 +178,20 @@ SparseLU::SparseLU (const SparseMatrix& 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   Rfact.xridx (i) = i;
                   Rfact.xcidx (i) = i;
                 }
               Rfact.xcidx (nr) = nr;
               double *Rx = Rfact.data ();
 
-              P.resize (nr, 1);
+              P.resize (dim_vector (nr, 1));
               octave_idx_type *p = P.fortran_vec ();
 
-              Q.resize (nc, 1);
+              Q.resize (dim_vector (nc, 1));
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
                                                Up, Uj, Ux, p, q, 0,
                                                &do_recip, Rx, 
                                                Numeric) ;
 
@@ -394,20 +394,20 @@ SparseLU::SparseLU (const SparseMatrix& 
                   for (octave_idx_type i = 0; i < nr; i++)
                     {
                       Rfact.xridx (i) = i;
                       Rfact.xcidx (i) = i;
                     }
                   Rfact.xcidx (nr) = nr;
                   double *Rx = Rfact.data ();
 
-                  P.resize (nr, 1);
+                  P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
-                  Q.resize (nc, 1);
+                  Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
                                                    Ltx, Up, Uj, Ux, p, q, 
                                                    0, &do_recip, 
                                                    Rx, Numeric) ;
 
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -79,16 +79,22 @@ public:
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               bool rfv = resize_fill_value ())
+  {
+    Array<bool>::resize (dim_vector (nr, nc), rfv);
+  }
+
   static bool resize_fill_value (void) { return false; }
 
 };
 
 MM_BOOL_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 MS_BOOL_OP_DECLS (boolMatrix, bool, OCTAVE_API)
 SM_BOOL_OP_DECLS (bool, boolMatrix, OCTAVE_API)
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -81,16 +81,22 @@ public:
   charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               char rfv = resize_fill_value ())
+  {
+    Array<char>::resize (dim_vector (nr, nc), rfv);
+  }
+
   charMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -94,18 +94,21 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
-  void resize (octave_idx_type n, const double& rfv = Array<double>::resize_fill_value ())
-    { Array<double>::resize (n, 1, rfv); }
+  void resize (octave_idx_type n,
+               const double& rfv = Array<double>::resize_fill_value ())
+  {
+    Array<double>::resize (dim_vector (n, 1), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (n, 1); }
 
 };
 
 // Publish externally used friend functions.
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -750,17 +750,17 @@ Matrix::finverse (MatrixType &mattype, o
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (lwork, 1);
+      z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1111,17 +1111,17 @@ Matrix::fourier2d (void) const
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1180,17 +1180,17 @@ Matrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -2349,17 +2349,17 @@ Matrix::lssolve (const Matrix& b, octave
           octave_idx_type lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
@@ -2503,17 +2503,17 @@ Matrix::lssolve (const ColumnVector& b, 
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         {
@@ -2787,17 +2787,17 @@ Matrix::row_min (Array<octave_idx_type>&
   ColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           double tmp_min = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2842,17 +2842,17 @@ Matrix::row_max (Array<octave_idx_type>&
   ColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           double tmp_max = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2897,17 +2897,17 @@ Matrix::column_min (Array<octave_idx_typ
   RowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           double tmp_min = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
@@ -2952,17 +2952,17 @@ Matrix::column_max (Array<octave_idx_typ
   RowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           double tmp_max = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -120,16 +120,22 @@ public:
   Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               double rfv = resize_fill_value ())
+  {
+    MArray<double>::resize (dim_vector (nr, nc), rfv);
+  }
+
 private:
   Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
                    int force, int calc_cond) const;
 
   Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
                    int force, int calc_cond) const;
 
 public:
@@ -322,17 +328,16 @@ public:
   RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Matrix& a);
 
   static double resize_fill_value (void) { return 0; }
-
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API Matrix real (const ComplexMatrix& a);
 extern OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -87,18 +87,21 @@ public:
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
-  void resize (octave_idx_type n, const double& rfv = Array<double>::resize_fill_value ())
-    { Array<double>::resize (1, n, rfv); }
+  void resize (octave_idx_type n,
+               const double& rfv = Array<double>::resize_fill_value ())
+  {
+    Array<double>::resize (dim_vector (1, n), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -360,17 +360,17 @@ SparseMatrix::max (Array<octave_idx_type
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize (dim_vector  (nr, 1), 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -509,17 +509,17 @@ SparseMatrix::min (Array<octave_idx_type
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize (dim_vector (nr, 1), 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 LU::LU (const Matrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn, 1);
+  ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   double *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (dgetrf, DGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -156,17 +156,17 @@ SVD::init (const Matrix& a, SVD::type sv
       F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -178,17 +178,17 @@ SVD::init (const Matrix& a, SVD::type sv
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (dgesdd, DGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgesdd, DGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
     }
   else
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -129,18 +129,21 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
-  void resize (octave_idx_type n, const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
-    { Array<FloatComplex>::resize (n, 1, rfv); }
+  void resize (octave_idx_type n,
+               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  {
+    Array<FloatComplex>::resize (dim_vector (n, 1), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexColumnVector, FloatComplex)
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1078,17 +1078,17 @@ FloatComplexMatrix::finverse (MatrixType
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (lwork, 1);
+      z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1439,17 +1439,17 @@ FloatComplexMatrix::fourier2d (void) con
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1508,17 +1508,17 @@ FloatComplexMatrix::ifourier2d (void) co
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -2700,17 +2700,17 @@ FloatComplexMatrix::lssolve (const Float
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
@@ -2859,19 +2859,19 @@ FloatComplexMatrix::lssolve (const Float
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork, 1);
-      rwork.resize (static_cast<octave_idx_type> (rwork(0)), 1);
-      iwork.resize (iwork(0), 1);
+      work.resize (dim_vector (lwork, 1));
+      rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
+      iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
@@ -3284,17 +3284,17 @@ FloatComplexMatrix::row_min (Array<octav
   FloatComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_min;
@@ -3358,17 +3358,17 @@ FloatComplexMatrix::row_max (Array<octav
   FloatComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_max;
@@ -3432,17 +3432,17 @@ FloatComplexMatrix::column_min (Array<oc
   FloatComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_min;
@@ -3506,17 +3506,17 @@ FloatComplexMatrix::column_max (Array<oc
   FloatComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_max;
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -151,16 +151,22 @@ public:
   FloatComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               const FloatComplex& rfv = resize_fill_value ())
+  {
+    MArray<FloatComplex>::resize (dim_vector (nr, nc), rfv);
+  }
+
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           float& rcon, int force, int calc_cond) const;
 
   FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
                           float& rcon, int force, int calc_cond) const;
 
 public:
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -111,18 +111,21 @@ public:
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
 
-  void resize (octave_idx_type n, const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
-    { Array<FloatComplex>::resize (1, n, rfv); }
+  void resize (octave_idx_type n,
+               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  {
+    Array<FloatComplex>::resize (dim_vector (1, n), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/fCmplxLU.cc b/liboctave/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/fCmplxLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 FloatComplexLU::FloatComplexLU (const FloatComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn, 1);
+  ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   FloatComplex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -163,17 +163,17 @@ FloatComplexSVD::init (const FloatComple
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
@@ -186,17 +186,17 @@ FloatComplexSVD::init (const FloatComple
 
       F77_XFCN (cgesdd, CGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgesdd, CGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
     }
   else
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -97,18 +97,21 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
-  void resize (octave_idx_type n, const float& rfv = Array<float>::resize_fill_value ())
-    { Array<float>::resize (n, 1, rfv); }
+  void resize (octave_idx_type n,
+               const float& rfv = Array<float>::resize_fill_value ())
+  {
+    Array<float>::resize (dim_vector (n, 1), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (n, 1); }
 
 };
 
 // Publish externally used friend functions.
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -750,17 +750,17 @@ FloatMatrix::finverse (MatrixType &matty
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (lwork, 1);
+      z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1111,17 +1111,17 @@ FloatMatrix::fourier2d (void) const
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1180,17 +1180,17 @@ FloatMatrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn, 1);
+  wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -2349,17 +2349,17 @@ FloatMatrix::lssolve (const FloatMatrix&
           octave_idx_type lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
@@ -2503,17 +2503,17 @@ FloatMatrix::lssolve (const FloatColumnV
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         {
@@ -2787,17 +2787,17 @@ FloatMatrix::row_min (Array<octave_idx_t
   FloatColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           float tmp_min = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2842,17 +2842,17 @@ FloatMatrix::row_max (Array<octave_idx_t
   FloatColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr, 1);
+      idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           float tmp_max = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2897,17 +2897,17 @@ FloatMatrix::column_min (Array<octave_id
   FloatRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           float tmp_min = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
@@ -2952,17 +2952,17 @@ FloatMatrix::column_max (Array<octave_id
   FloatRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (1, nc);
+      idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           float tmp_max = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -121,16 +121,22 @@ public:
   FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               float rfv = resize_fill_value ())
+  {
+    MArray<float>::resize (dim_vector (nr, nc), rfv);
+  }
+
 private:
   FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
                    int force, int calc_cond) const;
 
   FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
                    int force, int calc_cond) const;
 
 public:
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -88,18 +88,21 @@ public:
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
 
-  void resize (octave_idx_type n, const float& rfv = Array<float>::resize_fill_value ())
-    { Array<float>::resize (1, n, rfv); }
+  void resize (octave_idx_type n,
+               const float& rfv = Array<float>::resize_fill_value ())
+  {
+    Array<float>::resize (dim_vector (1, n), rfv);
+  }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/floatLU.cc b/liboctave/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/floatLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 FloatLU::FloatLU (const FloatMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn, 1);
+  ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   float *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (sgetrf, SGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -156,17 +156,17 @@ FloatSVD::init (const FloatMatrix& a, SV
       F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -178,17 +178,17 @@ FloatSVD::init (const FloatMatrix& a, SV
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (sgesdd, SGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork, 1);
+      work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgesdd, SGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
     }
   else
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1044,17 +1044,17 @@ static inline ComplexMatrix
 do_bessel (dptr f, const char *, double alpha, const ComplexMatrix& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   ComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1062,17 +1062,17 @@ static inline ComplexMatrix
 do_bessel (dptr f, const char *, const Matrix& alpha, const Complex& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   ComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1090,17 +1090,17 @@ do_bessel (dptr f, const char *fn, const
 
   if (x_nr == alpha_nr && x_nc == alpha_nc)
     {
       octave_idx_type nr = x_nr;
       octave_idx_type nc = x_nc;
 
       retval.resize (nr, nc);
 
-      ierr.resize (nr, nc);
+      ierr.resize (dim_vector (nr, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
@@ -1168,17 +1168,17 @@ static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
            const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   ComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1641,17 +1641,17 @@ static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, float alpha, const FloatComplexMatrix& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1659,17 +1659,17 @@ static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatMatrix& alpha, const FloatComplex& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1687,17 +1687,17 @@ do_bessel (fptr f, const char *fn, const
 
   if (x_nr == alpha_nr && x_nc == alpha_nc)
     {
       octave_idx_type nr = x_nr;
       octave_idx_type nc = x_nc;
 
       retval.resize (nr, nc);
 
-      ierr.resize (nr, nc);
+      ierr.resize (dim_vector (nr, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
@@ -1765,17 +1765,17 @@ static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
            const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   FloatComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
@@ -1938,34 +1938,34 @@ biry (const Complex& z, bool deriv, bool
 ComplexMatrix
 airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexMatrix
 biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
@@ -2068,34 +2068,34 @@ biry (const FloatComplex& z, bool deriv,
 FloatComplexMatrix
 airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 FloatComplexMatrix
 biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
-  ierr.resize (nr, nc);
+  ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -274,17 +274,17 @@ dmsolve_insert (MSparse<Complex> &a, con
 
 template <class T, class RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   const T *Bx = b.fortran_vec();
-  a.resize(b_nr, b_nc);
+  a.resize (dim_vector (b_nr, b_nc));
   RT *Btx = a.fortran_vec();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
           Btx [p [i] + off] = Bx [ i + off];
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -84,17 +84,19 @@ public:
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
   void resize (octave_idx_type n, const std::string& rfv = resize_fill_value ())
-    { Array<std::string>::resize (n, 1, rfv); }
+  {
+    Array<std::string>::resize (dim_vector (n, 1), rfv);
+  }
 
   std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
 
   string_vector& sort (bool make_uniq = false);
 
   string_vector& uniq (void);
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -515,18 +515,18 @@ Undocumented internal function.\n\
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nnz ();
-      rn.resize (Anz+1, 1);
-      cn.resize (Anz+1, 1);
+      rn.resize (dim_vector (Anz+1, 1));
+      cn.resize (dim_vector (Anz+1, 1));
       a.resize (Anz+1, 0.0);
 
       if (Anc != mrowsc)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
@@ -545,18 +545,18 @@ Undocumented internal function.\n\
 
       if (error_state)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       mrowsA = A.rows ();
-      rn.resize (mrowsA*mrowsc+1, 1);
-      cn.resize (mrowsA*mrowsc+1, 1);
+      rn.resize (dim_vector (mrowsA*mrowsc+1, 1));
+      cn.resize (dim_vector (mrowsA*mrowsc+1, 1));
       a.resize (mrowsA*mrowsc+1, 0.0);
 
       for (int i = 0; i < mrowsA; i++)
         {
           for (int j = 0; j < mrowsc; j++)
             {
               if (A(i,j) != 0)
                 {
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -59,19 +59,19 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 {
   MArray<T> y;
 
   octave_idx_type a_len  = a.length ();
   octave_idx_type b_len  = b.length ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
-  b.resize (ab_len, 1, 0.0);
+  b.resize (dim_vector (ab_len, 1), 0.0);
   if (a_len > 1)
-    a.resize (ab_len, 1, 0.0);
+    a.resize (dim_vector (ab_len, 1), 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T>(0.0))
     {
       error ("filter: the first element of A must be non-zero");
       return y;
     }
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -41,17 +41,17 @@ octave_value_list::octave_value_list (co
       nel += p->length ();
     }
 
   // Optimize single-element case
   if (n == 1)
     data = lst.front ().data;
   else if (nel > 0)
     {
-      data.resize (1, nel);
+      data.resize (dim_vector (1, nel));
       octave_idx_type k = 0;
       for (std::list<octave_value_list>::const_iterator p = lst.begin ();
            p != lst.end (); p++)
         {
           data.assign (idx_vector (k, k + p->length ()), p->data);
           k += p->length ();
         }
       assert (k == nel);
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -108,17 +108,19 @@ public:
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
   octave_idx_type length (void) const { return data.length (); }
 
   bool empty (void) const { return length () == 0; }
 
   void resize (octave_idx_type n, const octave_value& rfv 
                = Array<octave_value>::resize_fill_value ()) 
-    { data.resize (1, n, rfv); }
+  {
+    data.resize (dim_vector (1, n), rfv);
+  }
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -222,17 +222,17 @@ scanf_format_list::scanf_format_list (co
           have_more = false;
           break;
         }
     }
 
   if (have_more)
     add_elt_to_list (width, discard, type, modifier, num_elts);
 
-  list.resize (num_elts, 1);
+  list.resize (dim_vector (num_elts, 1));
 
   delete buf;
 }
 
 scanf_format_list::~scanf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
@@ -254,17 +254,17 @@ scanf_format_list::add_elt_to_list (int 
 
       if (! text.empty ())
         {
           scanf_format_elt *elt
             = new scanf_format_elt (text.c_str (), width, discard, type,
                                     modifier, char_class);
 
           if (num_elts == list.length ())
-            list.resize (2 * num_elts, 1);
+            list.resize (dim_vector (2 * num_elts, 1));
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
 }
@@ -594,17 +594,17 @@ printf_format_list::printf_format_list (
 
   if (n == 0)
     {
       printf_format_elt *elt
         = new printf_format_elt ("", args, fw, prec, flags, type, modifier);
 
       list(num_elts++) = elt;
 
-      list.resize (num_elts, 1);
+      list.resize (dim_vector (num_elts, 1));
     }
   else
     {
       while (i < n)
         {
           have_more = true;
 
           if (! buf)
@@ -649,17 +649,17 @@ printf_format_list::printf_format_list (
               have_more = false;
               break;
             }
         }
 
       if (have_more)
         add_elt_to_list (args, flags, fw, prec, type, modifier, num_elts);
 
-      list.resize (num_elts, 1);
+      list.resize (dim_vector (num_elts, 1));
 
       delete buf;
     }
 }
 
 printf_format_list::~printf_format_list (void)
 {
   octave_idx_type n = list.length ();
@@ -682,17 +682,17 @@ printf_format_list::add_elt_to_list (int
 
       if (! text.empty ())
         {
           printf_format_elt *elt
             = new printf_format_elt (text.c_str (), args, fw, prec, flags,
                                      type, modifier);
 
           if (num_elts == list.length ())
-            list.resize (2 * num_elts, 1);
+            list.resize (dim_vector (2 * num_elts, 1));
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
 }
