# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444093992 14400
#      Mon Oct 05 21:13:12 2015 -0400
# Node ID 1a0a433c8263cd7bdc1379361d9e4729c1ea4ab0
# Parent  b10432a40432297c1c97f39ec1bb410307d0241d
eliminate more simple uses of error_state

* dirfns.cc, oct-map.cc, oct-stream.cc, regexp.cc, ov-base-mat.cc,
ov-cell.cc, pt-idx.cc, pt-mat.cc:
Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -123,19 +123,16 @@ present working directory rather than ch
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("cd");
 
-  if (error_state)
-    return retval;
-
   if (nargout > 0)
     retval = octave_value (octave_env::get_current_directory ());
 
   if (argc > 1)
     {
       std::string dirname = argv[1];
 
       if (dirname.length () > 0)
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -909,49 +909,39 @@ octave_map::index (const octave_value_li
   try
     {
       switch (n_idx)
         {
         case 1:
           {
             idx_vector i = idx(0).index_vector ();
 
-            if (! error_state)
-              retval = index (i, resize_ok);
+            retval = index (i, resize_ok);
           }
           break;
 
         case 2:
           {
             idx_vector i = idx(0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx(1).index_vector ();
+            k = 1;
+            idx_vector j = idx(1).index_vector ();
 
-                retval = index (i, j, resize_ok);
-              }
+            retval = index (i, j, resize_ok);
           }
           break;
 
         default:
           {
             Array<idx_vector> ia (dim_vector (n_idx, 1));
 
             for (k = 0; k < n_idx; k++)
-              {
-                ia(k) = idx(k).index_vector ();
+              ia(k) = idx(k).index_vector ();
 
-                if (error_state)
-                  break;
-              }
-
-            if (! error_state)
-              retval = index (ia, resize_ok);
+            retval = index (ia, resize_ok);
           }
           break;
         }
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
@@ -1119,49 +1109,39 @@ octave_map::assign (const octave_value_l
   try
     {
       switch (n_idx)
         {
         case 1:
           {
             idx_vector i = idx(0).index_vector ();
 
-            if (! error_state)
-              assign (i, rhs);
+            assign (i, rhs);
           }
           break;
 
         case 2:
           {
             idx_vector i = idx(0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx(1).index_vector ();
+            k = 1;
+            idx_vector j = idx(1).index_vector ();
 
-                assign (i, j, rhs);
-              }
+            assign (i, j, rhs);
           }
           break;
 
         default:
           {
             Array<idx_vector> ia (dim_vector (n_idx, 1));
 
             for (k = 0; k < n_idx; k++)
-              {
-                ia(k) = idx(k).index_vector ();
+              ia(k) = idx(k).index_vector ();
 
-                if (error_state)
-                  break;
-              }
-
-            if (! error_state)
-              assign (ia, rhs);
+            assign (ia, rhs);
           }
           break;
         }
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
@@ -1177,31 +1157,31 @@ octave_map::assign (const octave_value_l
   iterator p = seek (k);
   Cell& ref = p != end () ? contents (p) : tmp;
 
   if (&ref == &tmp)
     ref = Cell (dimensions);
 
   ref.assign (idx, rhs);
 
-  if (! error_state && ref.dims () != dimensions)
+  if (ref.dims () != dimensions)
     {
       dimensions = ref.dims ();
 
       octave_idx_type nf = nfields ();
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (&xvals[i] != &ref)
             xvals[i].resize (dimensions, Matrix ());
         }
 
       optimize_dimensions ();
     }
 
-  if (! error_state && &ref == &tmp)
+  if (&ref == &tmp)
     setfield (k, tmp);
 }
 
 /*
 %!test
 %! rhs.b = 1;
 %! a(3) = rhs;
 %! assert ({a.b}, {[], [], 1})
@@ -1281,23 +1261,19 @@ octave_map::delete_elements (const octav
           ia(i) = idx(i).index_vector ();
         }
       catch (index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (n_idx, i+1);
           throw;
         }
-
-      if (error_state)
-        break;
     }
 
-  if (! error_state)
-    delete_elements (ia);
+  delete_elements (ia);
 }
 
 /*
 ## test preservation of key order by indexing
 %!test
 %! x(1, 1).d = 10;  x(4, 6).a = "b";  x(2, 4).f = 27;
 %! assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
 */
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -140,23 +140,20 @@ get_size (const Array<double>& size, oct
       if (! xisinf (dnr))
         dnc = size (1);
       else
         ::error ("%s: invalid size specification", who.c_str ());
     }
   else
     ::error ("%s: invalid size specification", who.c_str ());
 
-  if (! error_state)
-    {
-      nr = get_size (dnr, who);
-
-      if (! error_state && dnc >= 0.0)
-        nc = get_size (dnc, who);
-    }
+  nr = get_size (dnr, who);
+
+  if (dnc >= 0.0)
+    nc = get_size (dnc, who);
 }
 
 scanf_format_list::scanf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), list (dim_vector (16, 1)), buf (0)
 {
   octave_idx_type num_elts = 0;
 
   size_t n = s.length ();
@@ -1914,19 +1911,18 @@ octave_base_stream::scanf (const std::st
         {
           octave_idx_type nr = -1;
           octave_idx_type nc = -1;
 
           bool one_elt_size_spec;
 
           get_size (size, nr, nc, one_elt_size_spec, who);
 
-          if (! error_state)
-            retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-                               conversion_count, who);
+          retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
+                             conversion_count, who);
         }
     }
   else
     invalid_operation (who, "reading");
 
   return retval;
 }
 
@@ -2356,27 +2352,24 @@ printf_value_cache::get_next_value (char
 
 int
 printf_value_cache::int_value (void)
 {
   int retval = 0;
 
   octave_value val = get_next_value ();
 
+  double dval = val.double_value (true);
+
   if (! error_state)
     {
-      double dval = val.double_value (true);
-
-      if (! error_state)
-        {
-          if (D_NINT (dval) == dval)
-            retval = NINT (dval);
-          else
-            curr_state = conversion_error;
-        }
+      if (D_NINT (dval) == dval)
+        retval = NINT (dval);
+      else
+        curr_state = conversion_error;
     }
 
   return retval;
 }
 
 // Ugh again and again.
 
 template <class T>
@@ -2582,19 +2575,18 @@ octave_base_stream::do_numeric_printf_co
                                         tval.value (), who);
             }
           else
             {
               std::string tfmt = switch_to_g_format (elt);
 
               double dval = val.double_value (true);
 
-              if (! error_state)
-                retval += do_printf_conv (os, tfmt.c_str (), nsa,
-                                          sa_1, sa_2, dval, who);
+              retval += do_printf_conv (os, tfmt.c_str (), nsa,
+                                        sa_1, sa_2, dval, who);
             }
           break;
 
         case 'o': case 'x': case 'X': case 'u':
           if (ok_for_unsigned_int_conv (val))
             {
               octave_uint64 tval = val.uint64_scalar_value ();
 
@@ -2606,29 +2598,27 @@ octave_base_stream::do_numeric_printf_co
                                         tval.value (), who);
             }
           else
             {
               std::string tfmt = switch_to_g_format (elt);
 
               double dval = val.double_value (true);
 
-              if (! error_state)
-                retval += do_printf_conv (os, tfmt.c_str (), nsa,
-                                          sa_1, sa_2, dval, who);
+              retval += do_printf_conv (os, tfmt.c_str (), nsa,
+                                        sa_1, sa_2, dval, who);
             }
           break;
 
         case 'f': case 'e': case 'E':
         case 'g': case 'G':
           {
             double dval = val.double_value (true);
 
-            if (! error_state)
-              retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
+            retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
           }
           break;
 
         default:
           error ("%s: invalid format specifier",
                  who.c_str ());
           return -1;
           break;
@@ -2652,19 +2642,16 @@ octave_base_stream::do_printf (printf_fo
   if (osp)
     {
       std::ostream& os = *osp;
 
       const printf_format_elt *elt = fmt_list.first ();
 
       printf_value_cache val_cache (args, who);
 
-      if (error_state)
-        return retval;
-
       for (;;)
         {
           octave_quit ();
 
           if (elt)
             {
               // NSA is the number of 'star' args to convert.
 
@@ -2912,18 +2899,17 @@ octave_stream::getl (const octave_value&
 
       if (conv_err || max_len < 0)
         {
           err = true;
           ::error ("%s: invalid maximum length specified", who.c_str ());
         }
     }
 
-  if (! error_state)
-    retval = getl (max_len, err, who);
+  retval = getl (max_len, err, who);
 
   return retval;
 }
 
 std::string
 octave_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
 {
   std::string retval;
@@ -2952,18 +2938,17 @@ octave_stream::gets (const octave_value&
 
       if (conv_err || max_len < 0)
         {
           err = true;
           ::error ("%s: invalid maximum length specified", who.c_str ());
         }
     }
 
-  if (! error_state)
-    retval = gets (max_len, err, who);
+  retval = gets (max_len, err, who);
 
   return retval;
 }
 
 off_t
 octave_stream::skipl (off_t count, bool& err, const std::string& who)
 {
   off_t retval = -1;
@@ -2997,18 +2982,17 @@ octave_stream::skipl (const octave_value
           if (conv_err || count < 0)
             {
               err = true;
               ::error ("%s: invalid number of lines specified", who.c_str ());
             }
         }
     }
 
-  if (! error_state)
-    retval = skipl (count, err, who);
+  retval = skipl (count, err, who);
 
   return retval;
 }
 
 int
 octave_stream::seek (off_t offset, int origin)
 {
   int status = -1;
@@ -3393,17 +3377,16 @@ octave_stream::read (const Array<double>
       octave_idx_type char_count = 0;
 
       count = 0;
 
       get_size (size, nr, nc, one_elt_size_spec, "fread");
 
       if (! error_state)
         {
-
           octave_idx_type elts_to_read;
 
           if (one_elt_size_spec)
             {
               // If NR == 0, Matlab returns [](0x0).
 
               // If NR > 0, the result will be a column vector with the given
               // number of rows.
@@ -4308,18 +4291,17 @@ octave_stream_list::do_lookup (int fid, 
 octave_stream
 octave_stream_list::do_lookup (const octave_value& fid,
                                const std::string& who) const
 {
   octave_stream retval;
 
   int i = get_file_number (fid);
 
-  if (! error_state)
-    retval = do_lookup (i, who);
+  retval = do_lookup (i, who);
 
   return retval;
 }
 
 int
 octave_stream_list::do_remove (int fid, const std::string& who)
 {
   int retval = -1;
@@ -4365,18 +4347,17 @@ octave_stream_list::do_remove (const oct
       do_clear (false);
 
       retval = 0;
     }
   else
     {
       int i = get_file_number (fid);
 
-      if (! error_state)
-        retval = do_remove (i, who);
+      retval = do_remove (i, who);
     }
 
   return retval;
 }
 
 void
 octave_stream_list::do_clear (bool flush)
 {
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -338,208 +338,200 @@ octregexp (const octave_value_list &args
            const std::string &who, bool case_insensitive = false)
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   // Make sure we have string, pattern
   const std::string buffer = args(0).string_value ();
-  if (error_state)
-    return retval;
 
   std::string pattern = args(1).string_value ();
-  if (error_state)
-    return retval;
+
   // Matlab compatibility.
   if (args(1).is_sq_string ())
     pattern = do_regexp_ptn_string_escapes (pattern);
 
   regexp::opts options;
   options.case_insensitive (case_insensitive);
   bool extra_options = false;
   parse_options (options, args, who, 2, extra_options);
-  if (error_state)
-    return retval;
 
   regexp::match_data rx_lst = regexp_match (pattern, buffer, options, who);
 
   string_vector named_pats = rx_lst.named_patterns ();
 
   size_t sz = rx_lst.size ();
 
-  if (! error_state)
-    {
-      // Converted the linked list in the correct form for the return values
-
-      octave_idx_type i = 0;
-      octave_scalar_map nmap;
+  // Converted the linked list in the correct form for the return values
 
-      retval.resize (7);
-
-      if (sz == 1)
-        {
-          string_vector named_tokens = rx_lst.begin ()->named_tokens ();
-
-          for (int j = 0; j < named_pats.numel (); j++)
-            nmap.assign (named_pats(j), named_tokens(j));
+  octave_idx_type i = 0;
+  octave_scalar_map nmap;
 
-          retval(5) = nmap;
-        }
-      else
-        {
-          for (int j = 0; j < named_pats.numel (); j++)
-            {
-              Cell tmp (dim_vector (1, sz));
+  retval.resize (7);
 
-              i = 0;
-              for (regexp::match_data::const_iterator p = rx_lst.begin ();
-                   p != rx_lst.end (); p++)
-                {
-                  string_vector named_tokens = p->named_tokens ();
-
-                  tmp(i++) = named_tokens(j);
-                }
-
-              nmap.assign (named_pats(j), octave_value (tmp));
-            }
+  if (sz == 1)
+    {
+      string_vector named_tokens = rx_lst.begin ()->named_tokens ();
 
-          retval(5) = nmap;
-        }
-
-      if (options.once ())
-        {
-          regexp::match_data::const_iterator p = rx_lst.begin ();
-
-          retval(4) = sz ? p->tokens () : Cell ();
-          retval(3) = sz ? p->match_string () : std::string ();
-          retval(2) = sz ? p->token_extents () : Matrix ();
-
-          if (sz)
-            {
-              double start = p->start ();
-              double end = p->end ();
-
-              Cell split (dim_vector (1, 2));
-              split(0) = buffer.substr (0, start-1);
-              split(1) = buffer.substr (end);
+      for (int j = 0; j < named_pats.numel (); j++)
+        nmap.assign (named_pats(j), named_tokens(j));
 
-              retval(6) = split;
-              retval(1) = end;
-              retval(0) = start;
-            }
-          else
-            {
-              retval(6) = buffer;
-              retval(1) = Matrix ();
-              retval(0) = Matrix ();
-            }
-        }
-      else
+      retval(5) = nmap;
+    }
+  else
+    {
+      for (int j = 0; j < named_pats.numel (); j++)
         {
-          Cell tokens (dim_vector (1, sz));
-          Cell match_string (dim_vector (1, sz));
-          Cell token_extents (dim_vector (1, sz));
-          NDArray end (dim_vector (1, sz));
-          NDArray start (dim_vector (1, sz));
-          Cell split (dim_vector (1, sz+1));
-          size_t sp_start = 0;
+          Cell tmp (dim_vector (1, sz));
 
           i = 0;
           for (regexp::match_data::const_iterator p = rx_lst.begin ();
                p != rx_lst.end (); p++)
             {
-              double s = p->start ();
-              double e = p->end ();
+              string_vector named_tokens = p->named_tokens ();
 
-              string_vector tmp = p->tokens ();
-              tokens(i) = Cell (dim_vector (1, tmp.numel ()), tmp);
-              match_string(i) = p->match_string ();
-              token_extents(i) = p->token_extents ();
-              end(i) = e;
-              start(i) = s;
-              split(i) = buffer.substr (sp_start, s-sp_start-1);
-              sp_start = e;
-              i++;
+              tmp(i++) = named_tokens(j);
             }
 
-          split(i) = buffer.substr (sp_start);
+          nmap.assign (named_pats(j), octave_value (tmp));
+        }
+
+      retval(5) = nmap;
+    }
+
+  if (options.once ())
+    {
+      regexp::match_data::const_iterator p = rx_lst.begin ();
+
+      retval(4) = sz ? p->tokens () : Cell ();
+      retval(3) = sz ? p->match_string () : std::string ();
+      retval(2) = sz ? p->token_extents () : Matrix ();
+
+      if (sz)
+        {
+          double start = p->start ();
+          double end = p->end ();
+
+          Cell split (dim_vector (1, 2));
+          split(0) = buffer.substr (0, start-1);
+          split(1) = buffer.substr (end);
 
           retval(6) = split;
-          retval(4) = tokens;
-          retval(3) = match_string;
-          retval(2) = token_extents;
           retval(1) = end;
           retval(0) = start;
         }
-
-      // Alter the order of the output arguments
+      else
+        {
+          retval(6) = buffer;
+          retval(1) = Matrix ();
+          retval(0) = Matrix ();
+        }
+    }
+  else
+    {
+      Cell tokens (dim_vector (1, sz));
+      Cell match_string (dim_vector (1, sz));
+      Cell token_extents (dim_vector (1, sz));
+      NDArray end (dim_vector (1, sz));
+      NDArray start (dim_vector (1, sz));
+      Cell split (dim_vector (1, sz+1));
+      size_t sp_start = 0;
 
-      if (extra_options)
+      i = 0;
+      for (regexp::match_data::const_iterator p = rx_lst.begin ();
+           p != rx_lst.end (); p++)
         {
-          int n = 0;
-          octave_value_list new_retval;
-          new_retval.resize (nargout);
+          double s = p->start ();
+          double e = p->end ();
 
-          OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
-          for (int j = 0; j < 6; j++)
-            arg_used[j] = false;
+          string_vector tmp = p->tokens ();
+          tokens(i) = Cell (dim_vector (1, tmp.numel ()), tmp);
+          match_string(i) = p->match_string ();
+          token_extents(i) = p->token_extents ();
+          end(i) = e;
+          start(i) = s;
+          split(i) = buffer.substr (sp_start, s-sp_start-1);
+          sp_start = e;
+          i++;
+        }
+
+      split(i) = buffer.substr (sp_start);
 
-          for (int j = 2; j < nargin; j++)
-            {
-              int k = 0;
-              std::string str = args(j).string_value ();
-              std::transform (str.begin (), str.end (), str.begin (), tolower);
+      retval(6) = split;
+      retval(4) = tokens;
+      retval(3) = match_string;
+      retval(2) = token_extents;
+      retval(1) = end;
+      retval(0) = start;
+    }
+
+  // Alter the order of the output arguments
+
+  if (extra_options)
+    {
+      int n = 0;
+      octave_value_list new_retval;
+      new_retval.resize (nargout);
 
-              if (str.find ("once", 0) == 0
-                  || str.find ("stringanchors", 0) == 0
-                  || str.find ("lineanchors", 0) == 0
-                  || str.find ("matchcase", 0) == 0
-                  || str.find ("ignorecase", 0) == 0
-                  || str.find ("dotall", 0) == 0
-                  || str.find ("dotexceptnewline", 0) == 0
-                  || str.find ("literalspacing", 0) == 0
-                  || str.find ("freespacing", 0) == 0
-                  || str.find ("noemptymatch", 0) == 0
-                  || str.find ("emptymatch", 0) == 0)
-                continue;
-              else if (str.find ("start", 0) == 0)
-                k = 0;
-              else if (str.find ("end", 0) == 0)
-                k = 1;
-              else if (str.find ("tokenextents", 0) == 0)
-                k = 2;
-              else if (str.find ("match", 0) == 0)
-                k = 3;
-              else if (str.find ("tokens", 0) == 0)
-                k = 4;
-              else if (str.find ("names", 0) == 0)
-                k = 5;
-              else if (str.find ("split", 0) == 0)
-                k = 6;
+      OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
+      for (int j = 0; j < 6; j++)
+        arg_used[j] = false;
+
+      for (int j = 2; j < nargin; j++)
+        {
+          int k = 0;
+          std::string str = args(j).string_value ();
+          std::transform (str.begin (), str.end (), str.begin (), tolower);
 
-              new_retval(n++) = retval(k);
-              arg_used[k] = true;
+          if (str.find ("once", 0) == 0
+              || str.find ("stringanchors", 0) == 0
+              || str.find ("lineanchors", 0) == 0
+              || str.find ("matchcase", 0) == 0
+              || str.find ("ignorecase", 0) == 0
+              || str.find ("dotall", 0) == 0
+              || str.find ("dotexceptnewline", 0) == 0
+              || str.find ("literalspacing", 0) == 0
+              || str.find ("freespacing", 0) == 0
+              || str.find ("noemptymatch", 0) == 0
+              || str.find ("emptymatch", 0) == 0)
+            continue;
+          else if (str.find ("start", 0) == 0)
+            k = 0;
+          else if (str.find ("end", 0) == 0)
+            k = 1;
+          else if (str.find ("tokenextents", 0) == 0)
+            k = 2;
+          else if (str.find ("match", 0) == 0)
+            k = 3;
+          else if (str.find ("tokens", 0) == 0)
+            k = 4;
+          else if (str.find ("names", 0) == 0)
+            k = 5;
+          else if (str.find ("split", 0) == 0)
+            k = 6;
 
-              if (n == nargout)
-                break;
-            }
+          new_retval(n++) = retval(k);
+          arg_used[k] = true;
 
-          // Fill in the rest of the arguments
-          if (n < nargout)
+          if (n == nargout)
+            break;
+        }
+
+      // Fill in the rest of the arguments
+      if (n < nargout)
+        {
+          for (int j = 0; j < 6; j++)
             {
-              for (int j = 0; j < 6; j++)
-                {
-                  if (! arg_used[j])
-                    new_retval(n++) = retval(j);
-                }
+              if (! arg_used[j])
+                new_retval(n++) = retval(j);
             }
+        }
 
-          retval = new_retval;
-        }
+      retval = new_retval;
     }
 
   return retval;
 }
 
 static octave_value_list
 octcellregexp (const octave_value_list &args, int nargout,
                const std::string &who, bool case_insensitive = false)
@@ -563,19 +555,16 @@ octcellregexp (const octave_value_list &
               new_args(1) = cellpat(0);
 
               for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 {
                   new_args(0) = cellstr(i);
                   octave_value_list tmp = octregexp (new_args, nargout, who,
                                                      case_insensitive);
 
-                  if (error_state)
-                    break;
-
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
             }
           else if (cellstr.numel () == 1)
             {
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize (cellpat.dims ());
@@ -583,19 +572,16 @@ octcellregexp (const octave_value_list &
               new_args(0) = cellstr(0);
 
               for (octave_idx_type i = 0; i < cellpat.numel (); i++)
                 {
                   new_args(1) = cellpat(i);
                   octave_value_list tmp = octregexp (new_args, nargout, who,
                                                      case_insensitive);
 
-                  if (error_state)
-                    break;
-
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
             }
           else if (cellstr.numel () == cellpat.numel ())
             {
 
               if (cellstr.dims () != cellpat.dims ())
@@ -608,19 +594,16 @@ octcellregexp (const octave_value_list &
                   for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                     {
                       new_args(0) = cellstr(i);
                       new_args(1) = cellpat(i);
 
                       octave_value_list tmp = octregexp (new_args, nargout, who,
                                                          case_insensitive);
 
-                      if (error_state)
-                        break;
-
                       for (int j = 0; j < nargout; j++)
                         newretval[j](i) = tmp(j);
                     }
                 }
             }
           else
             error ("regexp: cell array arguments must be scalar or equal size");
         }
@@ -630,55 +613,45 @@ octcellregexp (const octave_value_list &
             newretval[j].resize (cellstr.dims ());
 
           for (octave_idx_type i = 0; i < cellstr.numel (); i++)
             {
               new_args(0) = cellstr(i);
               octave_value_list tmp = octregexp (new_args, nargout, who,
                                                  case_insensitive);
 
-              if (error_state)
-                break;
-
               for (int j = 0; j < nargout; j++)
                 newretval[j](i) = tmp(j);
             }
         }
 
-      if (!error_state)
-        for (int j = 0; j < nargout; j++)
-          retval(j) = octave_value (newretval[j]);
+      for (int j = 0; j < nargout; j++)
+        retval(j) = octave_value (newretval[j]);
     }
   else if (args(1).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
         newretval[j].resize (cellpat.dims ());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
         {
           new_args(1) = cellpat(i);
           octave_value_list tmp = octregexp (new_args, nargout, who,
                                              case_insensitive);
 
-          if (error_state)
-            break;
-
           for (int j = 0; j < nargout; j++)
             newretval[j](i) = tmp(j);
         }
 
-      if (!error_state)
-        {
-          for (int j = 0; j < nargout; j++)
-            retval(j) = octave_value (newretval[j]);
-        }
+      for (int j = 0; j < nargout; j++)
+        retval(j) = octave_value (newretval[j]);
     }
   else
     retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
@@ -1335,29 +1308,25 @@ static octave_value
 octregexprep (const octave_value_list &args, const std::string &who)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   // Make sure we have string, pattern, replacement
   const std::string buffer = args(0).string_value ();
-  if (error_state)
-    return retval;
 
   std::string pattern = args(1).string_value ();
-  if (error_state)
-    return retval;
+
   // Matlab compatibility.
   if (args(1).is_sq_string ())
     pattern = do_regexp_ptn_string_escapes (pattern);
 
   std::string replacement = args(2).string_value ();
-  if (error_state)
-    return retval;
+
   // Matlab compatibility.
   if (args(2).is_sq_string ())
     replacement = do_regexp_rep_string_escapes (replacement);
 
   // Pack options excluding 'tokenize' and various output
   // reordering strings into regexp arg list
   octave_value_list regexpargs (nargin-3, octave_value ());
 
@@ -1372,18 +1341,16 @@ octregexprep (const octave_value_list &a
           regexpargs(len++) = args(i);
         }
     }
   regexpargs.resize (len);
 
   regexp::opts options;
   bool extra_args = false;
   parse_options (options, regexpargs, who, 0, extra_args);
-  if (error_state)
-    return retval;
 
   return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
 DEFUN (regexprep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
 @deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
@@ -1460,51 +1427,41 @@ function.\n\
         {
           dv1 = pat.dims ();
           if (rep.numel () != 1 && dv1 != rep.dims ())
             error ("regexprep: inconsistent cell array dimensions");
         }
       else if (rep.numel () != 1)
         dv1 = rep.dims ();
 
-      if (!error_state)
-        {
-          Cell ret (dv0);
-          octave_value_list new_args = args;
-
-          for (octave_idx_type i = 0; i < dv0.numel (); i++)
-            {
-              new_args(0) = str(i);
-              if (pat.numel () == 1)
-                new_args(1) = pat(0);
-              if (rep.numel () == 1)
-                new_args(2) = rep(0);
+      Cell ret (dv0);
+      octave_value_list new_args = args;
 
-              for (octave_idx_type j = 0; j < dv1.numel (); j++)
-                {
-                  if (pat.numel () != 1)
-                    new_args(1) = pat(j);
-                  if (rep.numel () != 1)
-                    new_args(2) = rep(j);
-                  new_args(0) = octregexprep (new_args, "regexprep");
+      for (octave_idx_type i = 0; i < dv0.numel (); i++)
+        {
+          new_args(0) = str(i);
+          if (pat.numel () == 1)
+            new_args(1) = pat(0);
+          if (rep.numel () == 1)
+            new_args(2) = rep(0);
 
-                  if (error_state)
-                    break;
-                }
-
-              if (error_state)
-                break;
-
-              ret(i) = new_args(0);
+          for (octave_idx_type j = 0; j < dv1.numel (); j++)
+            {
+              if (pat.numel () != 1)
+                new_args(1) = pat(j);
+              if (rep.numel () != 1)
+                new_args(2) = rep(j);
+              new_args(0) = octregexprep (new_args, "regexprep");
             }
 
-          if (!error_state)
-            retval = args(0).is_cell () ? octave_value (ret)
-                                        : octave_value (ret(0));
+          ret(i) = new_args(0);
         }
+
+      retval = args(0).is_cell () ? octave_value (ret)
+        : octave_value (ret(0));
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -153,71 +153,56 @@ octave_base_matrix<MT>::do_index_op (con
         case 0:
           retval = matrix;
           break;
 
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                // optimize single scalar index.
-                if (! resize_ok && i.is_scalar ())
-                  retval = cmatrix.checkelem (i(0));
-                else
-                  retval = MT (matrix.index (i, resize_ok));
-              }
+            // optimize single scalar index.
+            if (! resize_ok && i.is_scalar ())
+              retval = cmatrix.checkelem (i(0));
+            else
+              retval = MT (matrix.index (i, resize_ok));
           }
           break;
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                k=1;
-                idx_vector j = idx (1).index_vector ();
+            k=1;
+            idx_vector j = idx (1).index_vector ();
 
-                if (! error_state)
-                  {
-                    // optimize two scalar indices.
-                    if (! resize_ok && i.is_scalar () && j.is_scalar ())
-                      retval = cmatrix.checkelem (i(0), j(0));
-                    else
-                      retval = MT (matrix.index (i, j, resize_ok));
-                  }
-              }
+            // optimize two scalar indices.
+            if (! resize_ok && i.is_scalar () && j.is_scalar ())
+              retval = cmatrix.checkelem (i(0), j(0));
+            else
+              retval = MT (matrix.index (i, j, resize_ok));
           }
           break;
 
         default:
           {
             Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
             bool scalar_opt = n_idx == nd && ! resize_ok;
             const dim_vector dv = matrix.dims ();
 
             for (k = 0; k < n_idx; k++)
               {
                 idx_vec(k) = idx(k).index_vector ();
 
-                if (error_state)
-                  break;
-
                 scalar_opt = (scalar_opt && idx_vec(k).is_scalar ());
               }
 
-            if (! error_state)
-              {
-                if (scalar_opt)
-                  retval = cmatrix.checkelem (conv_to_int_array (idx_vec));
-                else
-                  retval = MT (matrix.index (idx_vec, resize_ok));
-              }
+            if (scalar_opt)
+              retval = cmatrix.checkelem (conv_to_int_array (idx_vec));
+            else
+              retval = MT (matrix.index (idx_vec, resize_ok));
           }
           break;
         }
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
@@ -244,52 +229,41 @@ octave_base_matrix<MT>::assign (const oc
       switch (n_idx)
         {
           case 0:
             panic_impossible ();
             break;
 
           case 1:
             {
-                  idx_vector i = idx (0).index_vector ();
+              idx_vector i = idx (0).index_vector ();
 
-                  if (! error_state)
-                    matrix.assign (i, rhs);
+              matrix.assign (i, rhs);
             }
             break;
 
           case 2:
             {
               idx_vector i = idx (0).index_vector ();
 
-              if (! error_state)
-                {
-                  k = 1;
-                  idx_vector j = idx (1).index_vector ();
+              k = 1;
+              idx_vector j = idx (1).index_vector ();
 
-                  if (! error_state)
-                    matrix.assign (i, j, rhs);
-                }
+              matrix.assign (i, j, rhs);
             }
             break;
 
           default:
             {
               Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
 
               for (k = 0; k < n_idx; k++)
-                {
-                  idx_vec(k) = idx(k).index_vector ();
+                idx_vec(k) = idx(k).index_vector ();
 
-                  if (error_state)
-                    break;
-                }
-
-              if (! error_state)
-                matrix.assign (idx_vec, rhs);
+              matrix.assign (idx_vec, rhs);
             }
             break;
         }
     }
   catch (index_exception& e)
     {
       gripe_invalid_index (e.idx(), n_idx, k+1);
     }
@@ -331,84 +305,69 @@ octave_base_matrix<MT>::assign (const oc
         case 0:
           panic_impossible ();
           break;
 
         case 1:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                // optimize single scalar index.
-                if (i.is_scalar () && i(0) < matrix.numel ())
-                  matrix(i(0)) = rhs;
-                else
-                  matrix.assign (i, mrhs);
-              }
+            // optimize single scalar index.
+            if (i.is_scalar () && i(0) < matrix.numel ())
+              matrix(i(0)) = rhs;
+            else
+              matrix.assign (i, mrhs);
           }
           break;
 
         case 2:
           {
             idx_vector i = idx (0).index_vector ();
 
-            if (! error_state)
-              {
-                k = 1;
-                idx_vector j = idx (1).index_vector ();
+            k = 1;
+            idx_vector j = idx (1).index_vector ();
 
-                if (! error_state)
-                  {
-                    // optimize two scalar indices.
-                    if (i.is_scalar () && j.is_scalar () && nd == 2
-                        && i(0) < matrix.rows () && j(0) < matrix.columns ())
-                      matrix(i(0), j(0)) = rhs;
-                    else
-                      matrix.assign (i, j, mrhs);
-                  }
-              }
+            // optimize two scalar indices.
+            if (i.is_scalar () && j.is_scalar () && nd == 2
+                && i(0) < matrix.rows () && j(0) < matrix.columns ())
+              matrix(i(0), j(0)) = rhs;
+            else
+              matrix.assign (i, j, mrhs);
           }
           break;
 
         default:
           {
             Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
             bool scalar_opt = n_idx == nd;
             const dim_vector dv = matrix.dims ().redim (n_idx);
 
             for (k = 0; k < n_idx; k++)
               {
                 idx_vec(k) = idx(k).index_vector ();
 
-                if (error_state)
-                  break;
-
                 scalar_opt = (scalar_opt && idx_vec(k).is_scalar ()
                               && idx_vec(k)(0) < dv(k));
               }
 
-            if (! error_state)
+            if (scalar_opt)
               {
-                if (scalar_opt)
+                // optimize all scalar indices. Don't construct
+                // an index array, but rather calc a scalar index directly.
+                octave_idx_type n = 1;
+                octave_idx_type j = 0;
+                for (octave_idx_type i = 0; i < n_idx; i++)
                   {
-                    // optimize all scalar indices. Don't construct
-                    // an index array, but rather calc a scalar index directly.
-                    octave_idx_type n = 1;
-                    octave_idx_type j = 0;
-                    for (octave_idx_type i = 0; i < n_idx; i++)
-                      {
-                        j += idx_vec(i)(0) * n;
-                        n *= dv (i);
-                      }
-                    matrix(j) = rhs;
+                    j += idx_vec(i)(0) * n;
+                    n *= dv (i);
                   }
-                else
-                  matrix.assign (idx_vec, mrhs);
+                matrix(j) = rhs;
               }
+            else
+              matrix.assign (idx_vec, mrhs);
           }
           break;
         }
     }
   catch (const index_exception& e)
     {
       gripe_invalid_index (e.idx(), n_idx, k+1);
      }
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -147,25 +147,22 @@ octave_cell::subsref (const std::string&
     case '(':
       retval(0) = do_index_op (idx.front ());
       break;
 
     case '{':
       {
         octave_value tmp = do_index_op (idx.front ());
 
-        if (! error_state)
-          {
-            Cell tcell = tmp.cell_value ();
+        Cell tcell = tmp.cell_value ();
 
-            if (tcell.numel () == 1)
-              retval(0) = tcell(0,0);
-            else
-              retval = octave_value (octave_value_list (tcell), true);
-          }
+        if (tcell.numel () == 1)
+          retval(0) = tcell(0,0);
+        else
+          retval = octave_value (octave_value_list (tcell), true);
       }
       break;
 
     case '.':
       {
         std::string nm = type_name ();
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
@@ -199,25 +196,22 @@ octave_cell::subsref (const std::string&
     case '(':
       retval = do_index_op (idx.front (), auto_add);
       break;
 
     case '{':
       {
         octave_value tmp = do_index_op (idx.front (), auto_add);
 
-        if (! error_state)
-          {
-            const Cell tcell = tmp.cell_value ();
+        const Cell tcell = tmp.cell_value ();
 
-            if (tcell.numel () == 1)
-              retval = tcell(0,0);
-            else
-              retval = octave_value (octave_value_list (tcell), true);
-          }
+        if (tcell.numel () == 1)
+          retval = tcell(0,0);
+        else
+          retval = octave_value (octave_value_list (tcell), true);
       }
       break;
 
     case '.':
       {
         std::string nm = type_name ();
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
@@ -275,63 +269,56 @@ octave_cell::subsasgn (const std::string
               }
             else
               {
                 octave_value tmp = do_index_op (idx.front (), true);
 
                 if (! tmp.is_defined ())
                   tmp = octave_value::empty_conv (type.substr (1), rhs);
 
-                if (! error_state)
-                  {
-                    std::list<octave_value_list> next_idx (idx);
+                std::list<octave_value_list> next_idx (idx);
+
+                next_idx.erase (next_idx.begin ());
 
-                    next_idx.erase (next_idx.begin ());
+                tmp.make_unique ();
 
-                    tmp.make_unique ();
-
-                    t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
-                  }
+                t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
               }
           }
           break;
 
         case '{':
           {
             matrix.make_unique ();
             Cell tmpc = matrix.index (idx.front (), true);
 
-            if (! error_state)
-              {
-                std::list<octave_value_list> next_idx (idx);
+            std::list<octave_value_list> next_idx (idx);
+
+            next_idx.erase (next_idx.begin ());
+
+            std::string next_type = type.substr (1);
 
-                next_idx.erase (next_idx.begin ());
+            if (tmpc.numel () == 1)
+              {
+                octave_value tmp = tmpc(0);
+                tmpc = Cell ();
 
-                std::string next_type = type.substr (1);
-
-                if (tmpc.numel () == 1)
+                if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                   {
-                    octave_value tmp = tmpc(0);
-                    tmpc = Cell ();
-
-                    if (! tmp.is_defined () || tmp.is_zero_by_zero ())
-                      {
-                        tmp = octave_value::empty_conv (type.substr (1), rhs);
-                        tmp.make_unique (); // probably a no-op.
-                      }
-                    else
-                      // optimization: ignore copy still stored inside array.
-                      tmp.make_unique (1);
-
-                    if (! error_state)
-                      t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
+                    tmp = octave_value::empty_conv (type.substr (1), rhs);
+                    tmp.make_unique (); // probably a no-op.
                   }
                 else
-                  gripe_indexed_cs_list ();
+                  // optimization: ignore copy still stored inside array.
+                  tmp.make_unique (1);
+
+                t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
               }
+            else
+              gripe_indexed_cs_list ();
           }
           break;
 
         case '.':
           {
             if (is_empty ())
               {
                 // Do nothing; the next branch will handle it.
@@ -344,103 +331,100 @@ octave_cell::subsasgn (const std::string
           }
           break;
 
         default:
           panic_impossible ();
         }
     }
 
-  if (! error_state)
+  switch (type[0])
     {
-      switch (type[0])
-        {
-        case '(':
-          {
-            octave_value_list i = idx.front ();
+    case '(':
+      {
+        octave_value_list i = idx.front ();
 
-            if (t_rhs.is_cell ())
-              octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
-            else if (t_rhs.is_null_value ())
-              octave_base_matrix<Cell>::delete_elements (i);
-            else
-              octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
+        if (t_rhs.is_cell ())
+          octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
+        else if (t_rhs.is_null_value ())
+          octave_base_matrix<Cell>::delete_elements (i);
+        else
+          octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
-            if (! error_state)
-              {
-                count++;
-                retval = octave_value (this);
-              }
-            else
-              gripe_failed_assignment ();
-          }
-          break;
-
-        case '{':
+        if (! error_state)
           {
-            octave_value_list idxf = idx.front ();
+            count++;
+            retval = octave_value (this);
+          }
+        else
+          gripe_failed_assignment ();
+      }
+      break;
 
-            if (t_rhs.is_cs_list ())
-              {
-                Cell tmp_cell = Cell (t_rhs.list_value ());
+    case '{':
+      {
+        octave_value_list idxf = idx.front ();
 
-                // Inquire the proper shape of the RHS.
+        if (t_rhs.is_cs_list ())
+          {
+            Cell tmp_cell = Cell (t_rhs.list_value ());
+
+            // Inquire the proper shape of the RHS.
 
-                dim_vector didx = dims ().redim (idxf.length ());
-                for (octave_idx_type k = 0; k < idxf.length (); k++)
-                  if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
+            dim_vector didx = dims ().redim (idxf.length ());
+            for (octave_idx_type k = 0; k < idxf.length (); k++)
+              if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
 
-                if (didx.numel () == tmp_cell.numel ())
-                  tmp_cell = tmp_cell.reshape (didx);
+            if (didx.numel () == tmp_cell.numel ())
+              tmp_cell = tmp_cell.reshape (didx);
 
 
-                octave_base_matrix<Cell>::assign (idxf, tmp_cell);
-              }
-            else if (idxf.all_scalars ()
-                     || do_index_op (idxf, true).numel () == 1)
-              // Regularize a null matrix if stored into a cell.
-              octave_base_matrix<Cell>::assign (idxf,
-                                                Cell (t_rhs.storable_value ()));
-            else if (! error_state)
-              gripe_nonbraced_cs_list_assignment ();
+            octave_base_matrix<Cell>::assign (idxf, tmp_cell);
+          }
+        else if (idxf.all_scalars ()
+                 || do_index_op (idxf, true).numel () == 1)
+          // Regularize a null matrix if stored into a cell.
+          octave_base_matrix<Cell>::assign (idxf,
+                                            Cell (t_rhs.storable_value ()));
+        else
+          gripe_nonbraced_cs_list_assignment ();
 
-            if (! error_state)
-              {
-                count++;
-                retval = octave_value (this);
-              }
-            else
-              gripe_failed_assignment ();
-          }
-          break;
-
-        case '.':
+        if (! error_state)
           {
-            if (is_empty ())
-              {
-                // Allow conversion of empty cell array to some other
-                // type in cases like
-                //
-                //  x = {}; x.f = rhs
-
-                octave_value tmp = octave_value::empty_conv (type, rhs);
+            count++;
+            retval = octave_value (this);
+          }
+        else
+          gripe_failed_assignment ();
+      }
+      break;
 
-                return tmp.subsasgn (type, idx, rhs);
-              }
-            else
-              {
-                std::string nm = type_name ();
-                error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-              }
+    case '.':
+      {
+        if (is_empty ())
+          {
+            // Allow conversion of empty cell array to some other
+            // type in cases like
+            //
+            //  x = {}; x.f = rhs
+
+            octave_value tmp = octave_value::empty_conv (type, rhs);
+
+            return tmp.subsasgn (type, idx, rhs);
           }
-          break;
+        else
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
+      }
+      break;
 
-        default:
-          panic_impossible ();
-        }
+    default:
+      panic_impossible ();
     }
 
   return retval;
 }
 
 bool
 octave_cell::is_cellstr (void) const
 {
@@ -609,19 +593,16 @@ octave_cell::all_strings (bool pad) cons
   octave_idx_type max_len = 0;
 
   std::queue<string_vector> strvec_queue;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       string_vector s = matrix(i).all_strings ();
 
-      if (error_state)
-        return retval;
-
       octave_idx_type s_len = s.numel ();
 
       n_elts += s_len ? s_len : 1;
 
       octave_idx_type s_max_len = s.max_length ();
 
       if (s_max_len > max_len)
         max_len = s_max_len;
@@ -1336,25 +1317,21 @@ dimensions.\n\
                 error ("cell: expecting scalar arguments");
                 break;
               }
           }
       }
       break;
     }
 
-  if (! error_state)
-    {
-      dims.chop_trailing_singletons ();
+  dims.chop_trailing_singletons ();
 
-      check_dimensions (dims, "cell");
+  check_dimensions (dims, "cell");
 
-      if (! error_state)
-        retval = Cell (dims, Matrix ());
-    }
+  retval = Cell (dims, Matrix ());
 
   return retval;
 }
 
 DEFUN (iscellstr, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscellstr (@var{cell})\n\
 Return true if every element of the cell array @var{cell} is a character\n\
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -152,29 +152,26 @@ make_subs_cell (tree_argument_list *args
 {
   Cell retval;
 
   octave_value_list arg_values;
 
   if (args)
     arg_values = args->convert_to_const_vector ();
 
-  if (! error_state)
-    {
-      int n = arg_values.length ();
+  int n = arg_values.length ();
 
-      if (n > 0)
-        {
-          arg_values.stash_name_tags (arg_nm);
+  if (n > 0)
+    {
+      arg_values.stash_name_tags (arg_nm);
 
-          retval.resize (dim_vector (1, n));
+      retval.resize (dim_vector (1, n));
 
-          for (int i = 0; i < n; i++)
-            retval(0,i) = arg_values(i);
-        }
+      for (int i = 0; i < n; i++)
+        retval(0,i) = arg_values(i);
     }
 
   return retval;
 }
 
 static inline octave_value_list
 make_value_list (tree_argument_list *args, const string_vector& arg_nm,
                  const octave_value *object, bool rvalue = true)
@@ -184,23 +181,20 @@ make_value_list (tree_argument_list *arg
   if (args)
     {
       if (rvalue && object && args->has_magic_end () && object->is_undefined ())
         gripe_invalid_inquiry_subscript ();
       else
         retval = args->convert_to_const_vector (object);
     }
 
-  if (! error_state)
-    {
-      octave_idx_type n = retval.length ();
+  octave_idx_type n = retval.length ();
 
-      if (n > 0)
-        retval.stash_name_tags (arg_nm);
-    }
+  if (n > 0)
+    retval.stash_name_tags (arg_nm);
 
   return retval;
 }
 
 std::string
 tree_index_expression::get_struct_index
   (std::list<string_vector>::const_iterator p_arg_nm,
    std::list<tree_expression *>::const_iterator p_dyn_field) const
@@ -210,23 +204,20 @@ tree_index_expression::get_struct_index
   if (fn.empty ())
     {
       tree_expression *df = *p_dyn_field;
 
       if (df)
         {
           octave_value t = df->rvalue1 ();
 
-          if (! error_state)
-            {
-              if (t.is_string () && t.rows () == 1)
-                fn = t.string_value ();
-              else
-                error ("dynamic structure field names must be strings");
-            }
+          if (t.is_string () && t.rows () == 1)
+            fn = t.string_value ();
+          else
+            error ("dynamic structure field names must be strings");
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
 
@@ -259,19 +250,16 @@ tree_index_expression::make_arg_struct (
         case '.':
           subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
           break;
 
         default:
           panic_impossible ();
         }
 
-      if (error_state)
-        return m;
-
       p_args++;
       p_arg_nm++;
       p_dyn_field++;
     }
 
   m.assign ("type", type_field);
   m.assign ("subs", subs_field);
 
@@ -299,19 +287,16 @@ final_index_error (index_exception& e, c
 }
 
 octave_value_list
 tree_index_expression::rvalue (int nargout,
                                const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   octave_value first_expr_val;
 
   octave_value_list first_args;
 
   bool have_args = false;
 
   if (expr->is_identifier () && type[0] == '(')
     {
@@ -325,166 +310,150 @@ tree_index_expression::rvalue (int nargo
 
           if (n > 0)
             {
               string_vector anm = *(arg_nm.begin ());
               have_args = true;
               first_args = al -> convert_to_const_vector ();
               first_args.stash_name_tags (anm);
 
-              if (! error_state)
-                first_expr_val = id->do_lookup  (first_args);
+              first_expr_val = id->do_lookup  (first_args);
             }
         }
     }
 
-  if (! error_state)
-    {
-      if (first_expr_val.is_undefined ())
-        first_expr_val = expr->rvalue1 ();
+  if (first_expr_val.is_undefined ())
+    first_expr_val = expr->rvalue1 ();
+
+  octave_value tmp = first_expr_val;
+  octave_idx_type tmpi = 0;
+
+  std::list<octave_value_list> idx;
+
+  int n = args.size ();
 
-      octave_value tmp = first_expr_val;
-      octave_idx_type tmpi = 0;
+  std::list<tree_argument_list *>::iterator p_args = args.begin ();
+  std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+  std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
-      std::list<octave_value_list> idx;
-
-      int n = args.size ();
+  for (int i = 0; i < n; i++)
+    {
+      if (i > 0)
+        {
+          tree_argument_list *al = *p_args;
 
-      std::list<tree_argument_list *>::iterator p_args = args.begin ();
-      std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-      std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+          // In Matlab, () can only be followed by . In Octave, we do not
+          // enforce this for rvalue expressions, but we'll split the
+          // evaluation at this point. This will, hopefully, allow Octave's
+          // looser rules apply smoothly for Matlab overloaded subsref
+          // codes.
+          bool force_split = type[i-1] == '(' && type[i] != '.';
 
-      for (int i = 0; i < n; i++)
-        {
-          if (i > 0)
+          if (force_split || (al && al->has_magic_end ()))
             {
-              tree_argument_list *al = *p_args;
+              // (we have force_split, or) we have an expression like
+              //
+              //   x{end}.a(end)
+              //
+              // and we are looking at the argument list that
+              // contains the second (or third, etc.) "end" token,
+              // so we must evaluate everything up to the point of
+              // that argument list so we can pass the appropriate
+              // value to the built-in end function.
 
-              // In Matlab, () can only be followed by . In Octave, we do not
-              // enforce this for rvalue expressions, but we'll split the
-              // evaluation at this point. This will, hopefully, allow Octave's
-              // looser rules apply smoothly for Matlab overloaded subsref
-              // codes.
-              bool force_split = type[i-1] == '(' && type[i] != '.';
-
-              if (force_split || (al && al->has_magic_end ()))
+              try
                 {
-                  // (we have force_split, or) we have an expression like
-                  //
-                  //   x{end}.a(end)
-                  //
-                  // and we are looking at the argument list that
-                  // contains the second (or third, etc.) "end" token,
-                  // so we must evaluate everything up to the point of
-                  // that argument list so we can pass the appropriate
-                  // value to the built-in end function.
+                  octave_value_list tmp_list
+                    =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
 
-                  try
-                    {
-                      octave_value_list tmp_list
-                        =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
+                  tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
+                  tmpi = i;
+                  idx.clear ();
 
-                      tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
-                      tmpi = i;
-                      idx.clear ();
-
-                      if (tmp.is_cs_list ())
-                        gripe_indexed_cs_list ();
+                  if (tmp.is_cs_list ())
+                    gripe_indexed_cs_list ();
 
-                      if (error_state)
-                        break;
-
-                      if (tmp.is_function ())
-                        {
-                          octave_function *fcn = tmp.function_value (true);
-
-                          if (fcn && ! fcn->is_postfix_index_handled (type[i]))
-                            {
-                              octave_value_list empty_args;
+                  if (tmp.is_function ())
+                    {
+                      octave_function *fcn = tmp.function_value (true);
 
-                              tmp_list = tmp.do_multi_index_op (1, empty_args);
-                              tmp = (tmp_list.length ()
-                                     ? tmp_list(0) : octave_value ());
+                      if (fcn && ! fcn->is_postfix_index_handled (type[i]))
+                        {
+                          octave_value_list empty_args;
 
-                              if (tmp.is_cs_list ())
-                                gripe_indexed_cs_list ();
+                          tmp_list = tmp.do_multi_index_op (1, empty_args);
+                          tmp = (tmp_list.length ()
+                                 ? tmp_list(0) : octave_value ());
 
-                              if (error_state)
-                                break;
-                            }
+                          if (tmp.is_cs_list ())
+                            gripe_indexed_cs_list ();
                         }
                     }
-                  catch (index_exception& e)  // problems with index range, type etc.
-                    {
-                      final_index_error (e, expr);
-                    }
+                }
+              catch (index_exception& e)  // problems with index range, type etc.
+                {
+                  final_index_error (e, expr);
                 }
             }
-
-          switch (type[i])
-            {
-            case '(':
-              if (have_args)
-                {
-                  idx.push_back (first_args);
-                  have_args = false;
-                }
-              else
-                idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-              break;
+        }
 
-            case '{':
-              idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-              break;
-
-            case '.':
-              idx.push_back (octave_value (get_struct_index (p_arg_nm,
-                                                             p_dyn_field)));
-              break;
+      switch (type[i])
+        {
+        case '(':
+          if (have_args)
+            {
+              idx.push_back (first_args);
+              have_args = false;
+            }
+          else
+            idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+          break;
 
-            default:
-              panic_impossible ();
-            }
+        case '{':
+          idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+          break;
 
-          if (error_state)
-            break;
+        case '.':
+          idx.push_back (octave_value (get_struct_index (p_arg_nm,
+                                                         p_dyn_field)));
+          break;
 
-          p_args++;
-          p_arg_nm++;
-          p_dyn_field++;
+        default:
+          panic_impossible ();
         }
 
-      if (! error_state)
-        {
-          try
-            {
-              retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
-                                    lvalue_list);
-            }
-          catch (index_exception& e)    // problems with range, invalid index type etc.
-            {
-              final_index_error (e, expr);
-            }
+      p_args++;
+      p_arg_nm++;
+      p_dyn_field++;
+    }
 
-          octave_value val = retval.length () ? retval(0) : octave_value ();
+  try
+    {
+      retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
+                            lvalue_list);
+    }
+  catch (index_exception& e)    // problems with range, invalid index type etc.
+    {
+      final_index_error (e, expr);
+    }
 
-          if (! error_state && val.is_function ())
-            {
-              octave_function *fcn = val.function_value (true);
+  octave_value val = retval.length () ? retval(0) : octave_value ();
+
+  if (val.is_function ())
+    {
+      octave_function *fcn = val.function_value (true);
 
-              if (fcn)
-                {
-                  octave_value_list empty_args;
+      if (fcn)
+        {
+          octave_value_list empty_args;
 
-                  retval = (lvalue_list
-                            ? val.do_multi_index_op (nargout, empty_args,
-                                                     lvalue_list)
-                            : val.do_multi_index_op (nargout, empty_args));
-                }
-            }
+          retval = (lvalue_list
+                    ? val.do_multi_index_op (nargout, empty_args,
+                                             lvalue_list)
+                    : val.do_multi_index_op (nargout, empty_args));
         }
     }
 
   return retval;
 }
 
 octave_value
 tree_index_expression::rvalue1 (int nargout)
@@ -510,168 +479,149 @@ tree_index_expression::lvalue (void)
   int n = args.size ();
 
   std::list<tree_argument_list *>::iterator p_args = args.begin ();
   std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
   std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
   retval = expr->lvalue ();
 
-  if (! error_state)
-    {
-      octave_value tmp = retval.value ();
+  octave_value tmp = retval.value ();
+
+  octave_idx_type tmpi = 0;
+  std::list<octave_value_list> tmpidx;
 
-      octave_idx_type tmpi = 0;
-      std::list<octave_value_list> tmpidx;
-
-      for (int i = 0; i < n; i++)
+  for (int i = 0; i < n; i++)
+    {
+      if (retval.numel () != 1)
+        gripe_indexed_cs_list ();
+      else if (tmpi < i)
         {
-          if (retval.numel () != 1)
-            gripe_indexed_cs_list ();
-          else if (tmpi < i)
+          try
             {
-              try
-                {
-                  tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
-                }
-              catch (index_exception& e)  // problems with range, invalid type etc.
-                {
-                  final_index_error (e, expr);
-                }
-              tmpidx.clear ();
+              tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
+            }
+          catch (index_exception& e)  // problems with range, invalid type etc.
+            {
+              final_index_error (e, expr);
             }
+          tmpidx.clear ();
+        }
 
-          if (error_state)
-            break;
+      switch (type[i])
+        {
+        case '(':
+          {
+            octave_value_list tidx
+              = make_value_list (*p_args, *p_arg_nm, &tmp, false);
+
+            idx.push_back (tidx);
 
-          switch (type[i])
-            {
-            case '(':
+            if (i < n - 1)
               {
-                octave_value_list tidx
-                  = make_value_list (*p_args, *p_arg_nm, &tmp, false);
-
-                idx.push_back (tidx);
-
-                if (i < n - 1)
+                if (type[i+1] == '.')
                   {
-                    if (type[i+1] == '.')
-                      {
-                        tmpidx.push_back (tidx);
-                        tmpi = i+1;
-                      }
-                    else
-                      error ("() must be followed by . or close the index chain");
+                    tmpidx.push_back (tidx);
+                    tmpi = i+1;
                   }
+                else
+                  error ("() must be followed by . or close the index chain");
               }
-              break;
+          }
+          break;
+
+        case '{':
+          {
+            octave_value_list tidx
+              = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
-            case '{':
+            if (tmp.is_undefined ())
+              {
+                if (tidx.has_magic_colon ())
+                  gripe_invalid_inquiry_subscript ();
+                else
+                  tmp = Cell ();
+              }
+            else if (tmp.is_zero_by_zero ()
+                     && (tmp.is_matrix_type () || tmp.is_string ()))
               {
-                octave_value_list tidx
-                  = make_value_list (*p_args, *p_arg_nm, &tmp, false);
+                tmp = Cell ();
+              }
+
+            retval.numel (tmp.numel (tidx));
+
+            idx.push_back (tidx);
+            tmpidx.push_back (tidx);
+            tmpi = i;
+          }
+          break;
 
+        case '.':
+          {
+            octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
+
+            bool autoconv = (tmp.is_zero_by_zero ()
+                             && (tmp.is_matrix_type () || tmp.is_string ()
+                                 || tmp.is_cell ()));
+
+            if (i > 0 && type[i-1] == '(')
+              {
+                octave_value_list pidx = idx.back ();
+
+                // Use octave_map, not octave_scalar_map so that the
+                // dimensions are 0x0, not 1x1.
                 if (tmp.is_undefined ())
                   {
-                    if (tidx.has_magic_colon ())
+                    if (pidx.has_magic_colon ())
                       gripe_invalid_inquiry_subscript ();
                     else
-                      tmp = Cell ();
+                      tmp = octave_map ();
                   }
-                else if (tmp.is_zero_by_zero ()
-                         && (tmp.is_matrix_type () || tmp.is_string ()))
-                  {
-                    tmp = Cell ();
-                  }
-
-                retval.numel (tmp.numel (tidx));
+                else if (autoconv)
+                  tmp = octave_map ();
 
-                if (error_state)
-                  break;
-
-                idx.push_back (tidx);
-                tmpidx.push_back (tidx);
-                tmpi = i;
-              }
-              break;
-
-            case '.':
-              {
-                octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
-                if (error_state)
-                  break;
+                retval.numel (tmp.numel (pidx));
 
-                bool autoconv = (tmp.is_zero_by_zero ()
-                                 && (tmp.is_matrix_type () || tmp.is_string ()
-                                     || tmp.is_cell ()));
-
-                if (i > 0 && type[i-1] == '(')
+                tmpi = i-1;
+                tmpidx.push_back (tidx);
+              }
+            else
+              {
+                if (tmp.is_undefined () || autoconv)
                   {
-                    octave_value_list pidx = idx.back ();
-
-                    // Use octave_map, not octave_scalar_map so that the
-                    // dimensions are 0x0, not 1x1.
-                    if (tmp.is_undefined ())
-                      {
-                        if (pidx.has_magic_colon ())
-                          gripe_invalid_inquiry_subscript ();
-                        else
-                          tmp = octave_map ();
-                      }
-                    else if (autoconv)
-                      tmp = octave_map ();
-
-                    retval.numel (tmp.numel (pidx));
-
-                    tmpi = i-1;
-                    tmpidx.push_back (tidx);
+                    tmpi = i+1;
+                    tmp = octave_value ();
                   }
                 else
                   {
-                    if (tmp.is_undefined () || autoconv)
-                      {
-                        tmpi = i+1;
-                        tmp = octave_value ();
-                      }
-                    else
-                      {
-                        retval.numel (tmp.numel (octave_value_list ()));
+                    retval.numel (tmp.numel (octave_value_list ()));
 
-                        tmpi = i;
-                        tmpidx.push_back (tidx);
-                      }
+                    tmpi = i;
+                    tmpidx.push_back (tidx);
                   }
-
-                if (error_state)
-                  break;
+              }
 
-                idx.push_back (tidx);
-              }
-              break;
-
-            default:
-              panic_impossible ();
-            }
+            idx.push_back (tidx);
+          }
+          break;
 
-          if (idx.back ().empty ())
-            error ("invalid empty index list");
-
-          if (error_state)
-            break;
-
-          p_args++;
-          p_arg_nm++;
-          p_dyn_field++;
+        default:
+          panic_impossible ();
         }
 
-      if (! error_state)
-        retval.set_index (type, idx);
+      if (idx.back ().empty ())
+        error ("invalid empty index list");
 
+      p_args++;
+      p_arg_nm++;
+      p_dyn_field++;
     }
 
+  retval.set_index (type, idx);
+
   return retval;
 }
 
 /*
 %!test
 %! clear x;
 %! clear y;
 %! y = 3;
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -355,19 +355,19 @@ tm_row_const::tm_row_const_rep::init (co
        p++)
     {
       octave_quit ();
 
       tree_expression *elt = *p;
 
       octave_value tmp = elt->rvalue1 ();
 
-      if (error_state || tmp.is_undefined ())
+      if (tmp.is_undefined ())
         {
-          ok = ! error_state;
+          ok = true;
           return;
         }
       else
         {
           if (tmp.is_cs_list ())
             {
               octave_value_list tlst = tmp.list_value ();
 
@@ -383,45 +383,42 @@ tm_row_const::tm_row_const_rep::init (co
         }
     }
 
   if (any_cell && ! any_class && ! first_elem_is_struct)
     cellify ();
 
   first_elem = true;
 
-  if (! error_state)
+  for (iterator p = begin (); p != end (); p++)
     {
-      for (iterator p = begin (); p != end (); p++)
-        {
-          octave_quit ();
+      octave_quit ();
+
+      octave_value val = *p;
 
-          octave_value val = *p;
+      dim_vector this_elt_dv = val.dims ();
 
-          dim_vector this_elt_dv = val.dims ();
+      if (! this_elt_dv.zero_by_zero ())
+        {
+          all_mt = false;
 
-          if (! this_elt_dv.zero_by_zero ())
+          if (first_elem)
             {
-              all_mt = false;
-
-              if (first_elem)
-                {
-                  first_elem = false;
-                  dv = this_elt_dv;
-                }
-              else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
-                {
-                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
-                  break;
-                }
+              first_elem = false;
+              dv = this_elt_dv;
+            }
+          else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
+            {
+              eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+              break;
             }
         }
     }
 
-  ok = ! error_state;
+  ok = true;
 }
 
 void
 tm_row_const::tm_row_const_rep::cellify (void)
 {
   bool elt_changed = false;
 
   for (iterator p = begin (); p != end (); p++)
@@ -601,70 +598,67 @@ tm_const::init (const tree_matrix& tm)
           all_1x1 = all_1x1 && tmp.all_1x1_p ();
 
           append (tmp);
         }
       else
         break;
     }
 
-  if (! error_state)
+  if (any_cell && ! any_class && ! first_elem_is_struct)
     {
-      if (any_cell && ! any_class && ! first_elem_is_struct)
-        {
-          for (iterator q = begin (); q != end (); q++)
-            {
-              octave_quit ();
-
-              q->cellify ();
-            }
-        }
-
-      first_elem = true;
-
       for (iterator q = begin (); q != end (); q++)
         {
           octave_quit ();
 
-          tm_row_const elt = *q;
-
-          octave_idx_type this_elt_nr = elt.rows ();
-          octave_idx_type this_elt_nc = elt.cols ();
-
-          std::string this_elt_class_nm = elt.class_name ();
-          class_nm = get_concat_class (class_nm, this_elt_class_nm);
-
-          dim_vector this_elt_dv = elt.dims ();
-
-          all_mt = false;
-
-          if (first_elem)
-            {
-              first_elem = false;
-
-              dv = this_elt_dv;
-            }
-          else if (all_str && dv.length () == 2
-                   && this_elt_dv.length () == 2)
-            {
-              // FIXME: this is Octave's specialty. Character matrices allow
-              // rows of unequal length.
-              if (this_elt_nc > cols ())
-                dv(1) = this_elt_nc;
-              dv(0) += this_elt_nr;
-            }
-          else if ((!any_class) && (!dv.hvcat (this_elt_dv, 0)))
-            {
-              eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
-              return;
-            }
+          q->cellify ();
         }
     }
 
-  ok = ! error_state;
+  first_elem = true;
+
+  for (iterator q = begin (); q != end (); q++)
+    {
+      octave_quit ();
+
+      tm_row_const elt = *q;
+
+      octave_idx_type this_elt_nr = elt.rows ();
+      octave_idx_type this_elt_nc = elt.cols ();
+
+      std::string this_elt_class_nm = elt.class_name ();
+      class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
+      dim_vector this_elt_dv = elt.dims ();
+
+      all_mt = false;
+
+      if (first_elem)
+        {
+          first_elem = false;
+
+          dv = this_elt_dv;
+        }
+      else if (all_str && dv.length () == 2
+               && this_elt_dv.length () == 2)
+        {
+          // FIXME: this is Octave's specialty. Character matrices allow
+          // rows of unequal length.
+          if (this_elt_nc > cols ())
+            dv(1) = this_elt_nc;
+          dv(0) += this_elt_nr;
+        }
+      else if ((!any_class) && (!dv.hvcat (this_elt_dv, 0)))
+        {
+          eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
+          return;
+        }
+    }
+
+  ok = true;
 }
 
 octave_value_list
 tree_matrix::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
@@ -702,30 +696,23 @@ single_type_concat (Array<T>& result,
            q != row.end ();
            q++)
         {
           octave_quit ();
 
           TYPE ra = octave_value_extract<TYPE> (*q);
 
           // Skip empty arrays to allow looser rules.
-          if (! error_state)
-            {
-              if (! ra.is_empty ())
-                {
-                  result.insert (ra, r, c);
 
-                  if (! error_state)
-                    c += ra.columns ();
-                  else
-                    return;
-                }
+          if (! ra.is_empty ())
+            {
+              result.insert (ra, r, c);
+
+              c += ra.columns ();
             }
-          else
-            return;
         }
 
       r += row.rows ();
       c = 0;
     }
 }
 
 template<class TYPE, class T>
@@ -747,39 +734,35 @@ single_type_concat (Array<T>& result,
       tm_row_const& row = tmp.front ();
       if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
           && row.all_1x1_p ())
         {
           // Optimize all scalars case.
           result.clear (dv);
           assert (static_cast<size_t> (result.numel ()) == row.length ());
           octave_idx_type i = 0;
-          for (tm_row_const::iterator q = row.begin ();
-               q != row.end () && ! error_state; q++)
+          for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
             result(i++) = octave_value_extract<T> (*q);
 
           return;
         }
 
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin ();
-           q != row.end () && ! error_state;
-           q++)
+      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
         {
           octave_quit ();
 
           array_list[i] = octave_value_extract<TYPE> (*q);
           i++;
         }
 
-      if (! error_state)
-        result = Array<T>::cat (-2, ncols, array_list);
+      result = Array<T>::cat (-2, ncols, array_list);
     }
   else
     {
       result = Array<T> (dv);
       single_type_concat<TYPE> (result, tmp);
     }
 }
 
@@ -803,19 +786,17 @@ single_type_concat (Sparse<T>& result,
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin ();
-           q != row.end () && ! error_state;
-           q++)
+      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
         {
           octave_quit ();
 
           sparse_list[i] = octave_value_extract<TYPE> (*q);
           i++;
         }
 
       Sparse<T> stmp = Sparse<T>::cat (-2, ncols, sparse_list);
@@ -843,19 +824,17 @@ single_type_concat (octave_map& result,
   OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin ();
-           q != row.end () && ! error_state;
-           q++)
+      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
         {
           octave_quit ();
 
           map_list[i] = octave_value_extract<MAP> (*q);
           i++;
         }
 
       octave_map mtmp = octave_map::cat (-2, ncols, map_list);
@@ -916,23 +895,20 @@ do_class_concat (tm_const& tmc)
           octave_idx_type i = 0;
           for (tm_row_const::iterator q = tmrc.begin (); q != tmrc.end (); q++)
             row(i++) = *q;
 
           rows(j++) = do_class_concat (row, "horzcat", 1);
         }
     }
 
-  if (! error_state)
-    {
-      if (rows.length () == 1)
-        retval = rows(0);
-      else
-        retval = do_class_concat (rows, "vertcat", 0);
-    }
+  if (rows.length () == 1)
+    retval = rows(0);
+  else
+    retval = do_class_concat (rows, "vertcat", 0);
 
   return retval;
 }
 
 octave_value
 tree_matrix::rvalue1 (int)
 {
   octave_value retval = Matrix ();
@@ -1090,63 +1066,56 @@ tree_matrix::rvalue1 (int)
               ctmp = (*(tmp.begin () -> begin ()));
 
             found_non_empty:
 
               if (! all_empty_p)
                 ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
             }
 
-          if (! error_state)
-            {
-              // Now, extract the values from the individual elements and
-              // insert them in the result matrix.
+          // Now, extract the values from the individual elements and
+          // insert them in the result matrix.
+
+          int dv_len = dv.length ();
+          octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
+          Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
-              int dv_len = dv.length ();
-              octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
-              Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
+          for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+            {
+              octave_quit ();
 
-              for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+              tm_row_const row = *p;
+
+              for (tm_row_const::iterator q = row.begin ();
+                   q != row.end ();
+                   q++)
                 {
                   octave_quit ();
 
-                  tm_row_const row = *p;
-
-                  for (tm_row_const::iterator q = row.begin ();
-                       q != row.end ();
-                       q++)
-                    {
-                      octave_quit ();
-
-                      octave_value elt = *q;
+                  octave_value elt = *q;
 
-                      if (elt.is_empty ())
-                        continue;
-
-                      ctmp = do_cat_op (ctmp, elt, ra_idx);
+                  if (elt.is_empty ())
+                    continue;
 
-                      if (error_state)
-                        goto done;
+                  ctmp = do_cat_op (ctmp, elt, ra_idx);
 
-                      ra_idx (1) += elt.columns ();
-                    }
-
-                  ra_idx (0) += row.rows ();
-                  ra_idx (1) = 0;
+                  ra_idx (1) += elt.columns ();
                 }
 
-              retval = ctmp;
+              ra_idx (0) += row.rows ();
+              ra_idx (1) = 0;
+            }
 
-              if (frc_str_conv && ! retval.is_string ())
-                retval = retval.convert_to_str ();
-            }
+          retval = ctmp;
+
+          if (frc_str_conv && ! retval.is_string ())
+            retval = retval.convert_to_str ();
         }
     }
 
-done:
   return retval;
 }
 
 tree_expression *
 tree_matrix::dup (symbol_table::scope_id scope,
                   symbol_table::context_id context) const
 {
   tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
