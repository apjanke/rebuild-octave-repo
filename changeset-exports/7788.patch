# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1210781396 -7200
#      Wed May 14 18:09:56 2008 +0200
# Node ID 45f5faba05a2311b3fb4478a20dabbe633341aa3
# Parent  6b521b1e36312ad04ab7697876d9e8412ea74192
Add the rcond function

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -978,55 +978,55 @@ ComplexMatrix::column (octave_idx_type i
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (void) const
 {
   octave_idx_type info;
-  double rcond;
+  double rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (octave_idx_type& info) const
 {
-  double rcond;
+  double rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (octave_idx_type& info, double& rcond, int force,
+ComplexMatrix::inverse (octave_idx_type& info, double& rcon, int force,
 			int calc_cond) const
 {
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, force, calc_cond);
+  return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype) const
 {
   octave_idx_type info;
-  double rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  double rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
-  double rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  double rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcond, int force, int calc_cond) const
+			 double& rcon, int force, int calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1040,31 +1040,31 @@ ComplexMatrix::tinverse (MatrixType &mat
 
       F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type ztrcon_info = 0;
 	  char job = '1';
 
 	  OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
 	  OCTAVE_LOCAL_BUFFER (double, rwork, nr);
 
 	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     F77_CONST_CHAR_ARG2 (&uplo, 1),
 				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcond, 
+				     nr, tmp_data, nr, rcon, 
 				     cwork, rwork, ztrcon_info 
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (ztrcon_info != 0) 
 	    info = -1;
 	}
@@ -1073,17 +1073,17 @@ ComplexMatrix::tinverse (MatrixType &mat
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcond, int force, int calc_cond) const
+			 double& rcon, int force, int calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1113,29 +1113,29 @@ ComplexMatrix::finverse (MatrixType &mat
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
 	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  // Now calculate the condition number for non-singular matrix.
 	  octave_idx_type zgecon_info = 0;
 	  char job = '1';
 	  Array<double> rz (2 * nc);
 	  double *prz = rz.fortran_vec ();
 	  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nc, tmp_data, nr, anorm, 
-				     rcond, pz, prz, zgecon_info
+				     rcon, pz, prz, zgecon_info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (zgecon_info != 0) 
 	    info = -1;
 	}
 
       if (info == -1 && ! force)
 	retval = *this;  // Restore contents.
@@ -1154,47 +1154,47 @@ ComplexMatrix::finverse (MatrixType &mat
 	mattype.mark_as_rectangular();
     }
   
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
-			double& rcond, int force, int calc_cond) const
+			double& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   ComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-    ret = tinverse (mattype, info, rcond, force, calc_cond);
+    ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
 	{
 	  ComplexCHOL chol (*this, info, calc_cond);
 	  if (info == 0)
 	    {
 	      if (calc_cond)
-		rcond = chol.rcond();
+		rcon = chol.rcond();
 	      else
-		rcond = 1.0;
+		rcon = 1.0;
 	      ret = chol.inverse ();
 	    }
 	  else
 	    mattype.mark_as_unsymmetric ();
 	}
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcond, force, calc_cond);
-
-      if ((mattype.is_hermitian () || calc_cond) && rcond == 0.)
+	ret = finverse(mattype, info, rcon, force, calc_cond);
+
+      if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
 	ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
     }
 
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
@@ -1548,29 +1548,29 @@ ComplexMatrix::ifourier2d (void) const
 }
 
 #endif
 
 ComplexDET
 ComplexMatrix::determinant (void) const
 {
   octave_idx_type info;
-  double rcond;
-  return determinant (info, rcond, 0);
+  double rcon;
+  return determinant (info, rcon, 0);
 }
 
 ComplexDET
 ComplexMatrix::determinant (octave_idx_type& info) const
 {
-  double rcond;
-  return determinant (info, rcond, 0);
+  double rcon;
+  return determinant (info, rcon, 0);
 }
 
 ComplexDET
-ComplexMatrix::determinant (octave_idx_type& info, double& rcond, int calc_cond) const
+ComplexMatrix::determinant (octave_idx_type& info, double& rcon, int calc_cond) const
 {
   ComplexDET retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
@@ -1589,17 +1589,17 @@ ComplexMatrix::determinant (octave_idx_t
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nr, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	{
 	  info = -1;
 	  retval = ComplexDET ();
 	} 
       else 
 	{
 	  if (calc_cond) 
@@ -1608,17 +1608,17 @@ ComplexMatrix::determinant (octave_idx_t
 	      char job = '1';
 	      Array<Complex> z (2*nr);
 	      Complex *pz = z.fortran_vec ();
 	      Array<double> rz (2*nr);
 	      double *prz = rz.fortran_vec ();
 
 	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info
+					 rcon, pz, prz, info
 					 F77_CHAR_ARG_LEN (1)));
 	    }
 
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = ComplexDET ();
 	    } 
@@ -1653,19 +1653,186 @@ ComplexMatrix::determinant (octave_idx_t
 	      retval = ComplexDET (c, e);
 	    }
 	}
     }
   
   return retval;
 }
 
+double
+ComplexMatrix::rcond (void) const
+{
+  MatrixType mattype (*this);
+  return rcond (mattype);
+}
+
+double
+ComplexMatrix::rcond (MatrixType &mattype) const
+{
+  double rcon;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr != nc)
+    (*current_liboctave_error_handler) ("matrix must be square");
+  else if (nr == 0 || nc == 0)
+    rcon = octave_Inf;
+  else
+    {
+      int typ = mattype.type ();
+
+      if (typ == MatrixType::Unknown)
+	typ = mattype.type (*this);
+
+      // Only calculate the condition number for LU/Cholesky
+      if (typ == MatrixType::Upper)
+	{
+	  const Complex *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'U';
+	  char dia = 'N';
+
+	  Array<Complex> z (2 * nc);
+	  Complex *pz = z.fortran_vec ();
+	  Array<double> rz (nc);
+	  double *prz = rz.fortran_vec ();
+
+	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, prz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0;
+	}
+      else if  (typ == MatrixType::Permuted_Upper)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Lower)
+	{
+	  const Complex *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'L';
+	  char dia = 'N';
+
+	  Array<Complex> z (2 * nc);
+	  Complex *pz = z.fortran_vec ();
+	  Array<double> rz (nc);
+	  double *prz = rz.fortran_vec ();
+
+	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, prz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if (typ == MatrixType::Permuted_Lower)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+	{
+	  double anorm = -1.0;
+	  ComplexMatrix atmp = *this;
+	  Complex *tmp_data = atmp.fortran_vec ();
+
+	  if (typ == MatrixType::Hermitian)
+	    {
+	      octave_idx_type info = 0;
+	      char job = 'L';
+	      anorm = atmp.abs().sum().
+		row(static_cast<octave_idx_type>(0)).max();
+
+	      F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+					 tmp_data, nr, info
+					 F77_CHAR_ARG_LEN (1)));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  Array<Complex> z (2 * nc);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> rz (nc);
+		  double *prz = rz.fortran_vec ();
+
+		  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcon, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+
+
+	  if (typ == MatrixType::Full)
+	    {
+	      octave_idx_type info = 0;
+
+	      Array<octave_idx_type> ipvt (nr);
+	      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	      if(anorm < 0.)
+		anorm = atmp.abs().sum().
+		  row(static_cast<octave_idx_type>(0)).max();
+
+	      Array<Complex> z (2 * nc);
+	      Complex *pz = z.fortran_vec ();
+	      Array<double> rz (2 * nc);
+	      double *prz = rz.fortran_vec ();
+
+	      F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	      if (info != 0) 
+		{ 
+		  rcon = 0.0;
+		  mattype.mark_as_rectangular ();
+		} 
+	      else 
+		{
+		  char job = '1';
+		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcon, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+	}
+      else
+	rcon = 0.0;
+    }
+
+  return rcon;
+}
+
 ComplexMatrix
 ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			octave_idx_type& info, double& rcond, 
+			octave_idx_type& info, double& rcon, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1677,17 +1844,17 @@ ComplexMatrix::utsolve (MatrixType &matt
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1703,37 +1870,37 @@ ComplexMatrix::utsolve (MatrixType &matt
 		  Array<Complex> z (2 * nc);
 		  Complex *pz = z.fortran_vec ();
 		  Array<double> rz (nc);
 		  double *prz = rz.fortran_vec ();
 
 		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
@@ -1756,17 +1923,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
-			octave_idx_type& info, double& rcond, 
+			octave_idx_type& info, double& rcon, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1778,17 +1945,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1804,37 +1971,37 @@ ComplexMatrix::ltsolve (MatrixType &matt
 		  Array<Complex> z (2 * nc);
 		  Complex *pz = z.fortran_vec ();
 		  Array<double> rz (nc);
 		  double *prz = rz.fortran_vec ();
 
 		  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
@@ -1857,17 +2024,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond,
+		       octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1892,17 +2059,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 	  Complex *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Full;
 	    }
 	  else 
@@ -1911,34 +2078,34 @@ ComplexMatrix::fsolve (MatrixType &matty
 		{
 		  Array<Complex> z (2 * nc);
 		  Complex *pz = z.fortran_vec ();
 		  Array<double> rz (nc);
 		  double *prz = rz.fortran_vec ();
 
 		  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, tmp_data, nr, anorm,
-					     rcond, pz, prz, info
+					     rcon, pz, prz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
@@ -1974,56 +2141,56 @@ ComplexMatrix::fsolve (MatrixType &matty
 
 	  // Calculate the norm of the matrix, for later use.
 	  if (anorm < 0.)
 	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    { 
 	      info = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		sing_handler (rcon);
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	      mattype.mark_as_rectangular ();
 	    } 
 	  else 
 	    {
 	      if (calc_cond)
 		{
 		  // Now calculate the condition number for 
 		  // non-singular matrix.
 		  char job = '1';
 		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, prz, info
+					     rcon, pz, prz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
@@ -2043,345 +2210,345 @@ ComplexMatrix::fsolve (MatrixType &matty
   
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, 
 		      octave_idx_type& info) const
 {
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		      double& rcond) const
+		      double& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		      double& rcond, solve_singularity_handler sing_handler,
+		      double& rcon, solve_singularity_handler sing_handler,
 		      bool singular_fallback) const
 {
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler, singular_fallback);
+  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
 		      octave_idx_type& info) const
 {
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
-		      octave_idx_type& info, double& rcond) const
+		      octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-		      octave_idx_type& info, double& rcond,
+		      octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler,
 		      bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+    retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
-      retval = lssolve (b, info, rank, rcond);
+      retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+  double rcon;
+  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info) const
 {
-  double rcond;
-  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+  double rcon;
+  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcond) const
+		      octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, ComplexColumnVector (b), info, rcond, 0);
+  return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcond,
+		      octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const
 {
-  return solve (typ, ComplexColumnVector (b), info, rcond, sing_handler);
+  return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
 		      octave_idx_type& info) const
 {
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
-		      octave_idx_type& info, double& rcond) const
+		      octave_idx_type& info, double& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
-		      octave_idx_type& info, double& rcond,
+		      octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const
 {
 
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcond) const
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcond,
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler);
+  return solve (tmp, info, rcon, sing_handler);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (ComplexColumnVector (b), info, rcond, 0);
+  double rcon;
+  return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (ComplexColumnVector (b), info, rcond, 0);
+  double rcon;
+  return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-		      double& rcond) const
+		      double& rcon) const
 {
-  return solve (ComplexColumnVector (b), info, rcond, 0);
+  return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-		      double& rcond, 
+		      double& rcon, 
 		      solve_singularity_handler sing_handler) const
 {
-  return solve (ComplexColumnVector (b), info, rcond, sing_handler);
+  return solve (ComplexColumnVector (b), info, rcon, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
-		      double& rcond) const
+		      double& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
-		      double& rcond,
+		      double& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (ComplexMatrix (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (ComplexMatrix (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (ComplexMatrix (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcond) const
+			octave_idx_type& rank, double& rcon) const
 {
-  return lssolve (ComplexMatrix (b), info, rank, rcond);
+  return lssolve (ComplexMatrix (b), info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-			octave_idx_type& rank, double& rcond) const
+			octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2389,17 +2556,17 @@ ComplexMatrix::lssolve (const ComplexMat
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m== 0 || n == 0 || b.cols () == 0)
     retval = ComplexMatrix (n, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
 
       if (m != n)
 	{
 	  retval = ComplexMatrix (maxmn, nrhs);
 
 	  for (octave_idx_type j = 0; j < nrhs; j++)
 	    for (octave_idx_type i = 0; i < m; i++)
 	      retval.elem (i, j) = b.elem (i, j);
@@ -2456,17 +2623,17 @@ ComplexMatrix::lssolve (const ComplexMat
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n >= mnthr)
 	{
@@ -2493,97 +2660,97 @@ ComplexMatrix::lssolve (const ComplexMat
 	  if (std::real (work(0)) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 prwork, piwork, info));
 
       if (rank < minmn)
 	(*current_liboctave_warning_handler) 
 	  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	   m, n, rank, rcond);
+	   m, n, rank, rcon);
 
       if (s.elem (0) == 0.0)
-	rcond = 0.0;
+	rcon = 0.0;
       else
-	rcond = s.elem (minmn - 1) / s.elem (0);
+	rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (ComplexColumnVector (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (ComplexColumnVector (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
 			octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (ComplexColumnVector (b), info, rank, rcond);
+  double rcon;
+  return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank, double& rcond) const
+			octave_idx_type& rank, double& rcon) const
 {
-  return lssolve (ComplexColumnVector (b), info, rank, rcond);
+  return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcond) const
+			octave_idx_type& rank, double& rcon) const
 {
   ComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2591,17 +2758,17 @@ ComplexMatrix::lssolve (const ComplexCol
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
 
       if (m != n)
 	{
 	  retval = ComplexColumnVector (maxmn);
 
 	  for (octave_idx_type i = 0; i < m; i++)
 	    retval.elem (i) = b.elem (i);
 	}
@@ -2650,40 +2817,40 @@ ComplexMatrix::lssolve (const ComplexCol
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
       rwork.resize (static_cast<octave_idx_type> (rwork(0)));
       iwork.resize (iwork(0));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 prwork, piwork, info));
 
       if (rank < minmn)
 	{
 	  if (rank < minmn)
 	    (*current_liboctave_warning_handler) 
 	      ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	       m, n, rank, rcond);
+	       m, n, rank, rcon);
 
 	  if (s.elem (0) == 0.0)
-	    rcond = 0.0;
+	    rcon = 0.0;
 	  else
-	    rcond = s.elem (minmn - 1) / s.elem (0);
+	    rcon = s.elem (minmn - 1) / s.elem (0);
 
 	  retval.resize (n, nrhs);
 	}
     }
 
   return retval;
 }
 
@@ -2697,21 +2864,21 @@ static double padec [] =
   1.6025641025641026e-3,
   1.0683760683760684e-4,
   4.8562548562548563e-6,
   1.3875013875013875e-7,
   1.9270852604185938e-9,
 };
 
 static void
-solve_singularity_warning (double rcond)
+solve_singularity_warning (double rcon)
 {
   (*current_liboctave_warning_handler) 
     ("singular matrix encountered in expm calculation, rcond = %g",
-     rcond);
+     rcon);
 }
 
 ComplexMatrix
 ComplexMatrix::expm (void) const
 {
   ComplexMatrix retval;
 
   ComplexMatrix m = *this;
@@ -2828,18 +2995,18 @@ ComplexMatrix::expm (void) const
   for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
 
   // Compute pade approximation = inverse (dpp) * npp.
 
-  double rcond;
-  retval = dpp.solve (npp, info, rcond, solve_singularity_warning);
+  double rcon;
+  retval = dpp.solve (npp, info, rcon, solve_singularity_warning);
 
   if (info < 0)
     return retval;
 
   // Reverse preconditioning step 3: repeated squaring.
 
   while (sqpow)
     {
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 class
 OCTAVE_API
 ComplexMatrix : public MArray2<Complex>
 {
 public:
  
-  typedef void (*solve_singularity_handler) (double rcond);
+  typedef void (*solve_singularity_handler) (double rcon);
 
   ComplexMatrix (void) : MArray2<Complex> () { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<Complex> (r, c) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
 
@@ -137,163 +137,166 @@ public:
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
 private:
   ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
-			  double& rcond, int force, int calc_cond) const;
+			  double& rcon, int force, int calc_cond) const;
 
   ComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
-			  double& rcond, int force, int calc_cond) const;
+			  double& rcon, int force, int calc_cond) const;
 
 public:
   ComplexMatrix inverse (void) const;
   ComplexMatrix inverse (octave_idx_type& info) const;
-  ComplexMatrix inverse (octave_idx_type& info, double& rcond, int force = 0, 
+  ComplexMatrix inverse (octave_idx_type& info, double& rcon, int force = 0, 
 			 int calc_cond = 1) const;
 
   ComplexMatrix inverse (MatrixType &mattype) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcond, int force = 0, 
+			 double& rcon, int force = 0, 
 			 int calc_cond = 1) const;
 
   ComplexMatrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
-  ComplexDET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
+  ComplexDET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
+
+  double rcond (void) const;
+  double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-		  octave_idx_type& info, double& rcond, 
+		  octave_idx_type& info, double& rcon, 
 		  solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-		  octave_idx_type& info, double& rcond, 
+		  octave_idx_type& info, double& rcon, 
 		  solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-		 octave_idx_type& info, double& rcond, 
+		 octave_idx_type& info, double& rcon, 
 		 solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
-		       octave_idx_type& info, double& rcond) const;
+		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		       double& rcond, solve_singularity_handler sing_handler,
+		       double& rcon, solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond) const;
+		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond,
+		       octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info, double& rcond) const;
+			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info, double& rcond,
+			     octave_idx_type& info, double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcond) const;
+			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcond,
+			     octave_idx_type& info, double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
-  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+			     double& rcon) const;
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
+			     double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond,
+			     double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank, double& rcond) const;
+			 octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
 			 octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, double& rcond) const;
+			 octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ColumnVector& b) const;
   ComplexColumnVector lssolve (const ColumnVector& b,
 			       octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
 			       octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank, double& rcond) const;
+			       octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
 			       octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
 			       octave_idx_type& info,
 			       octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
 			       octave_idx_type& info,
-			       octave_idx_type& rank, double& rcond) const;
+			       octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix expm (void) const;
 
   // matrix by diagonal matrix -> matrix operations
 
   ComplexMatrix& operator += (const DiagMatrix& a);
   ComplexMatrix& operator -= (const DiagMatrix& a);
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,31 @@
 2008-05-20  David Bateman  <dbateman@free.fr>
 
+	* CMatrix.cc (double rcond): Replace with double rcon everywhere
+	to avoid shadowed variable warning
+	(double ComplexMatrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(double ComplexMatrix::rcond (MatrixType &mattype) const): ditto.
+	* CMatrix.h (double rcond):  Replace with double rcon everywhere
+	to avoid shadowed variable warning
+	(double ComplexMatrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(double ComplexMatrix::rcond (MatrixType &mattype) const): ditto.
+	* dMatrix.cc (double rcond): Replace with double rcon everywhere
+	to avoid shadowed variable warning
+	(double Matrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(double Matrix::rcond (MatrixType &mattype) const): ditto.
+	* dMatrix.h (double rcond):  Replace with double rcon everywhere
+	to avoid shadowed variable warning
+	(double Matrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(double Matrix::rcond (MatrixType &mattype) const): ditto.
+
 	* regex-match.cc, regex-match.h: New class for simple regular
 	expression matching
 	* Makefile.in (INCLUDES): Add regex-match.h here, and
 	(LIBOCTAVE_CXX_SOURCES): regex-match.cc here.
 
 2008-05-19  David Bateman  <dbateman@free.fr>
 
 	* dSparse.cc: Replace some DGBCON with GPBCON where they are
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -646,54 +646,54 @@ Matrix::column (octave_idx_type i) const
 
   return retval;
 }
 
 Matrix
 Matrix::inverse (void) const
 {
   octave_idx_type info;
-  double rcond;
+  double rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
 Matrix::inverse (octave_idx_type& info) const
 {
-  double rcond;
+  double rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
-Matrix::inverse (octave_idx_type& info, double& rcond, int force,
+Matrix::inverse (octave_idx_type& info, double& rcon, int force,
 		 int calc_cond) const
 {
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, force, calc_cond);
+  return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 Matrix
 Matrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
-  double rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  double rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
-  double rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  double rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
-Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcond, 
+Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
 		  int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -708,31 +708,31 @@ Matrix::tinverse (MatrixType &mattype, o
 
       F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type dtrcon_info = 0;
 	  char job = '1';
 
 	  OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
 
 	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     F77_CONST_CHAR_ARG2 (&uplo, 1),
 				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcond, 
+				     nr, tmp_data, nr, rcon, 
 				     work, iwork, dtrcon_info 
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (dtrcon_info != 0) 
 	    info = -1;
 	}
@@ -741,17 +741,17 @@ Matrix::tinverse (MatrixType &mattype, o
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 Matrix
-Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcond, 
+Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
 		  int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -781,30 +781,30 @@ Matrix::finverse (MatrixType &mattype, o
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type dgecon_info = 0;
 
 	  // Now calculate the condition number for non-singular matrix.
 	  char job = '1';
 	  Array<octave_idx_type> iz (nc);
 	  octave_idx_type *piz = iz.fortran_vec ();
 	  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nc, tmp_data, nr, anorm, 
-				     rcond, pz, piz, dgecon_info
+				     rcon, pz, piz, dgecon_info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (dgecon_info != 0) 
 	    info = -1;
 	}
 
       if (info == -1 && ! force)
 	retval = *this; // Restore matrix contents.
@@ -822,48 +822,48 @@ Matrix::finverse (MatrixType &mattype, o
       if (info != 0)
 	mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 Matrix
-Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcond, 
+Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
 		 int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   Matrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-    ret = tinverse (mattype, info, rcond, force, calc_cond);
+    ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
 	{
 	  CHOL chol (*this, info, calc_cond);
 	  if (info == 0)
 	    {
 	      if (calc_cond)
-		rcond = chol.rcond ();
+		rcon = chol.rcond ();
 	      else
-		rcond = 1.0;
+		rcon = 1.0;
 	      ret = chol.inverse ();
 	    }
 	  else
 	    mattype.mark_as_unsymmetric ();
 	}
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcond, force, calc_cond);
-
-      if ((mattype.is_hermitian () || calc_cond) && rcond == 0.)
+	ret = finverse(mattype, info, rcon, force, calc_cond);
+
+      if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
 	ret = Matrix (rows (), columns (), octave_Inf);
     }
 
   return ret;
 }
 
 Matrix
 Matrix::pseudo_inverse (double tol) const
@@ -1211,29 +1211,29 @@ Matrix::ifourier2d (void) const
 }
 
 #endif
 
 DET
 Matrix::determinant (void) const
 {
   octave_idx_type info;
-  double rcond;
-  return determinant (info, rcond, 0);
+  double rcon;
+  return determinant (info, rcon, 0);
 }
 
 DET
 Matrix::determinant (octave_idx_type& info) const
 {
-  double rcond;
-  return determinant (info, rcond, 0);
+  double rcon;
+  return determinant (info, rcon, 0);
 }
 
 DET
-Matrix::determinant (octave_idx_type& info, double& rcond, int calc_cond) const
+Matrix::determinant (octave_idx_type& info, double& rcon, int calc_cond) const
 {
   DET retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
@@ -1252,17 +1252,17 @@ Matrix::determinant (octave_idx_type& in
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	{
 	  info = -1;
 	  retval = DET ();
 	} 
       else 
 	{
 	  if (calc_cond) 
@@ -1271,17 +1271,17 @@ Matrix::determinant (octave_idx_type& in
 	      char job = '1';
 	      Array<double> z (4 * nc);
 	      double *pz = z.fortran_vec ();
 	      Array<octave_idx_type> iz (nc);
 	      octave_idx_type *piz = iz.fortran_vec ();
 
 	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info
+					 rcon, pz, piz, info
 					 F77_CHAR_ARG_LEN (1)));
 	    }
 
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = DET ();
 	    } 
@@ -1316,19 +1316,184 @@ Matrix::determinant (octave_idx_type& in
 	      retval = DET (c, e);
 	    }
 	}
     }
 
   return retval;
 }
 
+double
+Matrix::rcond (void) const
+{
+  MatrixType mattype (*this);
+  return rcond (mattype);
+}
+
+double
+Matrix::rcond (MatrixType &mattype) const
+{
+  double rcon;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr != nc)
+    (*current_liboctave_error_handler) ("matrix must be square");
+  else if (nr == 0 || nc == 0)
+    rcon = octave_Inf;
+  else
+    {
+      int typ = mattype.type ();
+
+      if (typ == MatrixType::Unknown)
+	typ = mattype.type (*this);
+
+      // Only calculate the condition number for LU/Cholesky
+      if (typ == MatrixType::Upper)
+	{
+	  const double *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'U';
+	  char dia = 'N';
+
+	  Array<double> z (3 * nc);
+	  double *pz = z.fortran_vec ();
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+
+	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, piz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if  (typ == MatrixType::Permuted_Upper)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Lower)
+	{
+	  const double *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'L';
+	  char dia = 'N';
+
+	  Array<double> z (3 * nc);
+	  double *pz = z.fortran_vec ();
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+
+	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, piz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if (typ == MatrixType::Permuted_Lower)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+	{
+	  double anorm = -1.0;
+	  Matrix atmp = *this;
+	  double *tmp_data = atmp.fortran_vec ();
+
+	  if (typ == MatrixType::Hermitian)
+	    {
+	      octave_idx_type info = 0;
+	      char job = 'L';
+	      anorm = atmp.abs().sum().
+		row(static_cast<octave_idx_type>(0)).max();
+
+	      F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+					 tmp_data, nr, info
+					 F77_CHAR_ARG_LEN (1)));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  Array<double> z (3 * nc);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcon, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+
+	  if (typ == MatrixType::Full)
+	    {
+	      octave_idx_type info = 0;
+
+	      Array<octave_idx_type> ipvt (nr);
+	      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	      if(anorm < 0.)
+		anorm = atmp.abs().sum().
+		  row(static_cast<octave_idx_type>(0)).max();
+
+	      Array<double> z (4 * nc);
+	      double *pz = z.fortran_vec ();
+	      Array<octave_idx_type> iz (nc);
+	      octave_idx_type *piz = iz.fortran_vec ();
+
+	      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+		  mattype.mark_as_rectangular ();
+		}
+	      else 
+		{
+		  char job = '1';
+		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcon, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+	}
+      else
+	rcon = 0.0;
+    }
+
+  return rcon;
+}
+
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
+		double& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
@@ -1339,17 +1504,17 @@ Matrix::utsolve (MatrixType &mattype, co
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1365,37 +1530,37 @@ Matrix::utsolve (MatrixType &mattype, co
 		  Array<double> z (3 * nc);
 		  double *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
@@ -1418,17 +1583,17 @@ Matrix::utsolve (MatrixType &mattype, co
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
+		double& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
@@ -1439,17 +1604,17 @@ Matrix::ltsolve (MatrixType &mattype, co
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1465,37 +1630,37 @@ Matrix::ltsolve (MatrixType &mattype, co
 		  Array<double> z (3 * nc);
 		  double *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
@@ -1518,17 +1683,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
+		double& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
@@ -1551,17 +1716,17 @@ Matrix::fsolve (MatrixType &mattype, con
 	  double *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Full;
 	    }
 	  else 
@@ -1570,34 +1735,34 @@ Matrix::fsolve (MatrixType &mattype, con
 		{
 		  Array<double> z (3 * nc);
 		  double *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, tmp_data, nr, anorm,
-					     rcond, pz, piz, info
+					     rcon, pz, piz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
@@ -1631,56 +1796,56 @@ Matrix::fsolve (MatrixType &mattype, con
 	  Array<double> z (4 * nc);
 	  double *pz = z.fortran_vec ();
 	  Array<octave_idx_type> iz (nc);
 	  octave_idx_type *piz = iz.fortran_vec ();
 
 	  F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		sing_handler (rcon);
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	      mattype.mark_as_rectangular ();
 	    }
 	  else 
 	    {
 	      if (calc_cond)
 		{
 		  // Now calculate the condition number for 
 		  // non-singular matrix.
 		  char job = '1';
 		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, piz, info
+					     rcon, pz, piz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile double rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile double rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
@@ -1702,56 +1867,56 @@ Matrix::fsolve (MatrixType &mattype, con
 
   return retval;
 }
 
 Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (typ, b, info, rcond, 0);
+  double rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-	       double& rcond) const
+	       double& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-	       double& rcond, solve_singularity_handler sing_handler,
+	       double& rcon, solve_singularity_handler sing_handler,
 	       bool singular_fallback) const
 {
   Matrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+    retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
-      retval = lssolve (b, info, rank, rcond);
+      retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
@@ -1764,59 +1929,59 @@ Matrix::solve (MatrixType &typ, const Co
   octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-	       double& rcond) const
+	       double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond);
+  return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
-	       double& rcond, solve_singularity_handler sing_handler,
+	       double& rcon, solve_singularity_handler sing_handler,
 	       bool singular_fallback) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond, sing_handler, singular_fallback);
+  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
-  octave_idx_type info; double rcond;
-  return solve (typ, b, info, rcond);
+  octave_idx_type info; double rcon;
+  return solve (typ, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, 
 	       octave_idx_type& info) const
 {
-  double rcond;
-  return solve (typ, b, info, rcond);
+  double rcon;
+  return solve (typ, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-	       double& rcond) const
+	       double& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-	       double& rcond, solve_singularity_handler sing_handler) const
+	       double& rcon, solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -1826,58 +1991,58 @@ Matrix::solve (MatrixType &typ, const Co
 	       octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-	       octave_idx_type& info, double& rcond) const
+	       octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond);
+  return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
-	       octave_idx_type& info, double& rcond,
+	       octave_idx_type& info, double& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcond, sing_handler);
+  return tmp.solve(typ, b, info, rcon, sing_handler);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (b, info, rcond, 0);
+  double rcon;
+  return solve (b, info, rcon, 0);
 }
 
 Matrix
-Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcond) const
+Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info,
-	       double& rcond, solve_singularity_handler sing_handler) const
+	       double& rcon, solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -1885,56 +2050,56 @@ Matrix::solve (const ComplexMatrix& b) c
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond);
+  return tmp.solve (b, info, rcon);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
-  octave_idx_type info; double rcond;
-  return solve (b, info, rcond);
+  octave_idx_type info; double rcon;
+  return solve (b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
-  double rcond;
-  return solve (b, info, rcond);
+  double rcon;
+  return solve (b, info, rcon);
 }
 
 ColumnVector
-Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
+Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 ColumnVector
-Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -1942,58 +2107,58 @@ Matrix::solve (const ComplexColumnVector
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond) const
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond);
+  return tmp.solve (b, info, rcon);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
 		 octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
-		 octave_idx_type& rank, double &rcond) const
+		 octave_idx_type& rank, double &rcon) const
 {
   Matrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2001,17 +2166,17 @@ Matrix::lssolve (const Matrix& b, octave
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = Matrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
       if (m != n)
 	{
 	  retval = Matrix (maxmn, nrhs, 0.0);
 
 	  for (octave_idx_type j = 0; j < nrhs; j++)
 	    for (octave_idx_type i = 0; i < m; i++)
 	      retval.elem (i, j) = b.elem (i, j);
 	}
@@ -2059,17 +2224,17 @@ Matrix::lssolve (const Matrix& b, octave
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n >= mnthr)
 	{
@@ -2103,98 +2268,98 @@ Matrix::lssolve (const Matrix& b, octave
 	  if (work(0) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 piwork, info));
 
       if (rank < minmn)
 	(*current_liboctave_warning_handler) 
 	  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
       if (s.elem (0) == 0.0)
-	rcond = 0.0;
+	rcon = 0.0;
       else
-	rcond = s.elem (minmn - 1) / s.elem (0);
+	rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
 		 octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank, double& rcond) const
+		 octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info, rank, rcond);
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
 		 octave_idx_type& rank) const
 {
-  double rcond;
-  return lssolve (b, info, rank, rcond);
+  double rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank, double &rcond) const
+		 octave_idx_type& rank, double &rcon) const
 {
   ColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2202,17 +2367,17 @@ Matrix::lssolve (const ColumnVector& b, 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
  
       if (m != n)
 	{
 	  retval = ColumnVector (maxmn, 0.0);
 
 	  for (octave_idx_type i = 0; i < m; i++)
 	    retval.elem (i) = b.elem (i);
 	}
@@ -2253,78 +2418,78 @@ Matrix::lssolve (const ColumnVector& b, 
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 piwork, info));
 
       if (rank < minmn)
 	{
 	  if (rank < minmn)
 	    (*current_liboctave_warning_handler) 
 	      ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
 	  if (s.elem (0) == 0.0)
-	    rcond = 0.0;
+	    rcon = 0.0;
 	  else
-	    rcond = s.elem (minmn - 1) / s.elem (0);
+	    rcon = s.elem (minmn - 1) / s.elem (0);
 	}
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   octave_idx_type info;
   octave_idx_type rank;
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
 		 octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
-  double rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  double rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank, double &rcond) const
+		 octave_idx_type& rank, double &rcon) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info, rank, rcond);
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 // Constants for matrix exponential calculation.
 
 static double padec [] =
 {
   5.0000000000000000e-1,
   1.1666666666666667e-1,
@@ -2332,21 +2497,21 @@ static double padec [] =
   1.6025641025641026e-3,
   1.0683760683760684e-4,
   4.8562548562548563e-6,
   1.3875013875013875e-7,
   1.9270852604185938e-9,
 };
 
 static void
-solve_singularity_warning (double rcond)
+solve_singularity_warning (double rcon)
 {
   (*current_liboctave_warning_handler) 
     ("singular matrix encountered in expm calculation, rcond = %g",
-     rcond);
+     rcon);
 }
 
 Matrix
 Matrix::expm (void) const
 {
   Matrix retval;
 
   Matrix m = *this;
@@ -2461,18 +2626,18 @@ Matrix::expm (void) const
   for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
   
   // Compute pade approximation = inverse (dpp) * npp.
 
-  double rcond;
-  retval = dpp.solve (npp, info, rcond, solve_singularity_warning);
+  double rcon;
+  retval = dpp.solve (npp, info, rcon, solve_singularity_warning);
 
   if (info < 0)
     return retval;
 
   // Reverse preconditioning step 3: repeated squaring.
   
   while (sqpow)
     {
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "mx-op-defs.h"
 
 class
 OCTAVE_API
 Matrix : public MArray2<double>
 {
 public:
 
-  typedef void (*solve_singularity_handler) (double rcond);
+  typedef void (*solve_singularity_handler) (double rcon);
 
   Matrix (void) : MArray2<double> () { }
 
   Matrix (octave_idx_type r, octave_idx_type c) : MArray2<double> (r, c) { }
 
   Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray2<double> (r, c, val) { }
 
   Matrix (const dim_vector& dv) : MArray2<double> (dv) { }
@@ -107,158 +107,161 @@ public:
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
 private:
-  Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcond, 
+  Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
 		   int force, int calc_cond) const;
 
-  Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcond, 
+  Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
 		   int force, int calc_cond) const;
 
 public:
   Matrix inverse (void) const;
   Matrix inverse (octave_idx_type& info) const;
-  Matrix inverse (octave_idx_type& info, double& rcond, int force = 0,
+  Matrix inverse (octave_idx_type& info, double& rcon, int force = 0,
 		  int calc_cond = 1) const;
 
   Matrix inverse (MatrixType &mattype) const;
   Matrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  Matrix inverse (MatrixType &mattype, octave_idx_type& info, double& rcond,
+  Matrix inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
 		  int force = 0, int calc_cond = 1) const;
 
   Matrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
-  DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
+  DET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
+
+  double rcond (void) const;
+  double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		  double& rcond, solve_singularity_handler sing_handler,
+		  double& rcon, solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		  double& rcond, solve_singularity_handler sing_handler,
+		  double& rcon, solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Full matrix solvers (lu/cholesky)
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		 double& rcond, solve_singularity_handler sing_handler,
+		 double& rcon, solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcond) const;
+		double& rcon) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
+		double& rcon, solve_singularity_handler sing_handler,
 		bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond) const;
+		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond,
+		       octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcond) const;
+		      octave_idx_type& info, double& rcon) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcond,
+		      octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcond) const;
+			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcond,
+			     octave_idx_type& info, double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
-  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
 		solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
+			     double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond,
+			     double& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank, double& rcond) const;
+		  octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
 			 octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, double &rcond) const;
+			 octave_idx_type& rank, double &rcon) const;
 
   ColumnVector lssolve (const ColumnVector& b) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
 			octave_idx_type& rank) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcond) const;
+			octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, 
 			       octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
 			       octave_idx_type& info,
 			       octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, 
 			       octave_idx_type& info,
-			       octave_idx_type& rank, double& rcond) const;
+			       octave_idx_type& rank, double& rcon) const;
 
   Matrix expm (void) const;
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,13 @@
 2008-05-20  David Bateman  <dbateman@free.fr>
 
+	* DLD-FUNCTIONS/rcond.cc: New function.
+	* Makefile.in (DLD_XSRC): Add it here.
+
 	* debug.cc (Fdbstop): If no line specified assume line 1.
 	(Fdbstep, Fdbcont, Fdbnext): Move debugging functions 
 	to normal commands.
 	(Fdbquit): New command to quit debugging mode and return to the 
 	prompt.
 	(Fdbstep): Modify the dbstep command for compatibility.
 	* input.cc (Vdebugging_current_line): Store current line being
 	debugged for use in DEFCMD versions of debug commands.
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
new file mode 100644
--- /dev/null
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -0,0 +1,70 @@
+/*
+
+Copyright (C) 2008 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "defun-dld.h"
+#include "error.h"
+#include "gripes.h"
+#include "oct-obj.h"
+#include "utils.h"
+
+DEFUN_DLD (rcond, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{c} =} rcond (@var{a})\n\
+Compute the 1-norm estimate of the reciprocal condition as returned\n\
+by LAPACK. If the matrix is well-conditioned then @var{c} will be near\n\
+1 and if the matrix is poorly conditioned it will be close to zero.\n\
+\n\
+The matrix @var{a} must not be sparse. If the matrix is sparse then\n\
+@code{condest (@var{a})} or @code{rcond (full (@var{a}))} should be used\n\
+instead.\n\
+@seealso{inv, mldivide}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 1)
+    print_usage ();
+  else if (args(0).is_sparse_type ())
+    error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
+  else if (args(0).is_complex_type ())
+    {
+      ComplexMatrix m = args(0).complex_matrix_value ();
+      MatrixType mattyp;
+      retval = m.rcond (mattyp);
+      args(0).matrix_type (mattyp);
+    }
+  else
+    {
+      Matrix m = args(0).matrix_value ();
+      MatrixType mattyp;
+      retval = m.rcond (mattyp);
+      args(0).matrix_type (mattyp);
+    }
+
+  return retval;
+}
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -64,17 +64,17 @@ OPT_INC := $(addprefix ../liboctave/, $(
 
 DLD_XSRC := amd.cc balance.cc besselj.cc betainc.cc bsxfun.cc cellfun.cc \
 	chol.cc ccolamd.cc colamd.cc colloc.cc conv2.cc convhulln.cc daspk.cc \
 	dasrt.cc dassl.cc det.cc dispatch.cc dlmread.cc dmperm.cc eig.cc \
 	expm.cc fft.cc fft2.cc fftn.cc fftw.cc filter.cc find.cc fsolve.cc \
 	gammainc.cc gcd.cc getgrent.cc getpwent.cc getrusage.cc \
 	givens.cc hess.cc hex2num.cc inv.cc kron.cc lookup.cc lsode.cc \
 	lu.cc luinc.cc matrix_type.cc max.cc md5sum.cc pinv.cc qr.cc \
-	quad.cc qz.cc rand.cc regexp.cc schur.cc sparse.cc \
+	quad.cc qz.cc rand.cc rcond.cc regexp.cc schur.cc sparse.cc \
 	spparms.cc sqrtm.cc svd.cc syl.cc symrcm.cc symbfact.cc \
 	time.cc tsearch.cc typecast.cc \
 	urlwrite.cc __contourc__.cc __delaunayn__.cc __dsearchn__.cc \
 	__glpk__.cc __lin_interpn__.cc __pchip_deriv__.cc \
 	__qp__.cc __voronoi__.cc __convn__.cc
 
 DLD_SRC := $(addprefix DLD-FUNCTIONS/, $(DLD_XSRC))
 
