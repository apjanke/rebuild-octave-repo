# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493069914 25200
#      Mon Apr 24 14:38:34 2017 -0700
# Node ID e35a5c1233d0486969da6bee04a93a9978b7941e
# Parent  39045e50ea450eda7253c75725b20c6ee721c890
maint: Use convention 'int *x' for naming pointers.

* annotation-dialog.h, files-dock-widget.cc, find-files-dialog.cc,
find-files-dialog.h, file-editor.cc, file-editor.h, main-window.cc,
main-window.h, octave-dock-widget.cc, parser.h, settings-dialog.h,
load-save.cc, mex.cc, pr-output.cc, symtab.cc, __ode15__.cc, ov-bool-sparse.cc,
ov-cx-sparse.cc, ov-fcn-inline.cc, ov-re-sparse.cc, Sparse.cc, idx-vector.cc,
idx-vector.h: Use convention 'int *x' for naming pointers.

diff --git a/libgui/graphics/annotation-dialog.h b/libgui/graphics/annotation-dialog.h
--- a/libgui/graphics/annotation-dialog.h
+++ b/libgui/graphics/annotation-dialog.h
@@ -50,13 +50,13 @@ private slots:
   void prompt_for_color ();
 
 private:
   void init ();
 
   void get_gui_props ();
   void set_gui_props ();
 
-  Ui::annotation_dialog * ui;
+  Ui::annotation_dialog *ui;
   octave_value_list props;
 };
 
 #endif
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -123,19 +123,19 @@ files_dock_widget::files_dock_widget (QW
 
   _sync_octave_directory_action
     = new QAction (resource_manager::icon ("go-last"),
                    tr ("Set Octave directory"), _navigation_tool_bar);
   _sync_octave_directory_action->setToolTip (
     tr ("Set Octave directory to current browser directory"));
   _sync_octave_directory_action->setEnabled ("false");
 
-  QToolButton * popdown_button = new QToolButton ();
+  QToolButton *popdown_button = new QToolButton ();
   popdown_button->setToolTip (tr ("Actions on current directory"));
-  QMenu * popdown_menu = new QMenu ();
+  QMenu *popdown_menu = new QMenu ();
   popdown_menu->addAction (resource_manager::icon ("user-home"),
                            tr ("Show Home Directory"),
                            this, SLOT (popdownmenu_home (bool)));
   popdown_menu->addAction (_sync_browser_directory_action);
   popdown_menu->addAction (_sync_octave_directory_action);
   popdown_button->setMenu (popdown_menu);
   popdown_button->setPopupMode (QToolButton::InstantPopup);
   popdown_button->setDefaultAction (new QAction (
@@ -918,43 +918,43 @@ void
 files_dock_widget::copyClipboard ()
 {
   if (_file_tree_view->hasFocus ())
     contextmenu_copy_selection (true);
   if (_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
 
-      QLineEdit * edit = _current_directory->lineEdit ();
+      QLineEdit *edit = _current_directory->lineEdit ();
       if (edit && edit->hasSelectedText ())
         {
           clipboard->setText (edit->selectedText ());
         }
     }
 }
 
 void
 files_dock_widget::pasteClipboard ()
 {
   if (_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str = clipboard->text ();
-      QLineEdit * edit = _current_directory->lineEdit ();
+      QLineEdit *edit = _current_directory->lineEdit ();
       if (edit && str.length () > 0)
         edit->insert (str);
     }
 }
 
 void
 files_dock_widget::selectAll ()
 {
   if (_file_tree_view->hasFocus ())
     _file_tree_view->selectAll ();
   if (_current_directory->hasFocus ())
     {
-      QLineEdit * edit = _current_directory->lineEdit ();
+      QLineEdit *edit = _current_directory->lineEdit ();
       if (edit)
         {
           edit->selectAll ();
         }
     }
 }
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -54,25 +54,25 @@ find_files_dialog::find_files_dialog (QW
 
   _dir_iterator = 0;
 
   _timer = new QTimer (this);
   connect (_timer, SIGNAL (timeout ()), this, SLOT (look_for_files ()));
 
   QSettings *settings = resource_manager::get_settings ();
 
-  QLabel * file_name_label = new QLabel (tr ("Named:"));
+  QLabel *file_name_label = new QLabel (tr ("Named:"));
   _file_name_edit = new QLineEdit;
   _file_name_edit->setToolTip (tr ("Enter the filename search expression"));
 
   _file_name_edit->setText (settings->value ("findfiles/file_name",
                                              "*").toString ());
   file_name_label->setBuddy (_file_name_edit);
 
-  QLabel * start_dir_label = new QLabel (tr ("Start in:"));
+  QLabel *start_dir_label = new QLabel (tr ("Start in:"));
 
   _start_dir_edit = new QLineEdit;
   _start_dir_edit->setText (settings->value ("findfiles/start_dir",
                             QDir::currentPath ()).toString ());
   _start_dir_edit->setToolTip (tr ("Enter the start directory"));
   start_dir_label->setBuddy (_start_dir_edit);
 
   _browse_button = new QPushButton (tr ("Browse..."));
@@ -106,17 +106,17 @@ find_files_dialog::find_files_dialog (QW
   _contains_text_edit->setText (settings->value ("findfiles/contains_text",
                                                  "").toString ());
 
   _content_case_check = new QCheckBox (tr ("Text case insensitive"));
   _content_case_check->setChecked (settings->value ("findfiles/content_case",
                                                     false).toBool ());
   _content_case_check->setToolTip (tr ("Set text content is case insensitive"));
 
-  find_files_model * model = new find_files_model (this);
+  find_files_model *model = new find_files_model (this);
 
   _file_list = new QTableView;
   _file_list->setWordWrap (false);
   _file_list->setModel (model);
   _file_list->setShowGrid (false);
   _file_list->setSelectionBehavior (QAbstractItemView::SelectRows);
   _file_list->setSelectionMode (QAbstractItemView::SingleSelection);
   _file_list->setAlternatingRowColors (true);
@@ -148,45 +148,45 @@ find_files_dialog::find_files_dialog (QW
   connect (_find_button, SIGNAL (clicked ()), this, SLOT (start_find ()));
 
   _stop_button = new QPushButton (tr ("Stop"));
   _stop_button->setToolTip (tr ("Stop searching"));
   _stop_button->setEnabled (false);
   connect (_stop_button, SIGNAL (clicked ()), this, SLOT (stop_find ()));
 
   // layout everything
-  QDialogButtonBox * button_box = new QDialogButtonBox (Qt::Vertical);
+  QDialogButtonBox *button_box = new QDialogButtonBox (Qt::Vertical);
   button_box->addButton (_find_button, QDialogButtonBox::ActionRole);
   button_box->addButton (_stop_button, QDialogButtonBox::ActionRole);
 
   // add dialog close button
   _close_button = button_box->addButton (QDialogButtonBox::Close);
   connect (button_box,    SIGNAL (rejected ()),
            this,          SLOT (close ()));
 
   // name options
-  QGroupBox * name_group = new QGroupBox (tr ("Filename/location"));
-  QGridLayout * name_layout = new QGridLayout;
+  QGroupBox *name_group = new QGroupBox (tr ("Filename/location"));
+  QGridLayout *name_layout = new QGridLayout;
   name_group->setLayout (name_layout);
 
   name_layout->addWidget (file_name_label,1,1, 1,1);
   name_layout->addWidget (_file_name_edit,1,2, 1,-1);
 
   name_layout->addWidget (start_dir_label,2,1);
   name_layout->addWidget (_start_dir_edit,2,2,1,3);
   name_layout->addWidget (_browse_button,2,5);
   name_layout->setColumnStretch (2,1);
 
   name_layout->addWidget (_recurse_dirs_check,3,1);
   name_layout->addWidget (_include_dirs_check,3,2);
   name_layout->addWidget (_name_case_check,3,3);
 
   // content options
-  QGroupBox * content_group = new QGroupBox (tr ("File contents"));
-  QGridLayout * content_layout = new QGridLayout;
+  QGroupBox *content_group = new QGroupBox (tr ("File contents"));
+  QGridLayout *content_layout = new QGridLayout;
   content_group->setLayout (content_layout);
   content_layout->addWidget (_contains_text_check,4,1);
   content_layout->addWidget (_contains_text_edit,4,2,1,3);
   content_layout->setColumnStretch (2,1);
   content_layout->addWidget (_content_case_check,5,1);
 
   QGridLayout *main_layout = new QGridLayout;
   main_layout->setSizeConstraint (QLayout::SetFixedSize);
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -33,17 +33,17 @@ class QTimer;
 class QDirIterator;
 class QCheckBox;
 class QStatusBar;
 
 class find_files_dialog : public QDialog
 {
   Q_OBJECT
 public:
-  find_files_dialog (QWidget * parent=0);
+  find_files_dialog (QWidget *parent = 0);
   virtual ~find_files_dialog ();
   void save_settings (void);
 
 signals:
   void file_selected (const QString &fileName);
   void dir_selected (const QString &fileName);
 
 public slots:
@@ -53,27 +53,27 @@ private slots:
   void start_find ();
   void stop_find ();
   void browse_folders ();
   void look_for_files ();
   void item_double_clicked (const QModelIndex&);
   void handle_done (int);
 private:
   bool is_match (const QFileInfo &info);
-  QLineEdit * _start_dir_edit;
-  QLineEdit * _file_name_edit;
-  QPushButton * _stop_button;
-  QPushButton * _find_button;
-  QPushButton * _close_button;
-  QPushButton * _browse_button;
-  QTableView   * _file_list;
-  QTimer      * _timer;
-  QCheckBox   * _recurse_dirs_check;
-  QCheckBox   * _include_dirs_check;
-  QCheckBox   * _name_case_check;
-  QCheckBox   * _contains_text_check;
-  QCheckBox   * _content_case_check;
-  QLineEdit * _contains_text_edit;
-  QDirIterator * _dir_iterator;
-  QStatusBar * _status_bar;
+  QLineEdit   *_start_dir_edit;
+  QLineEdit   *_file_name_edit;
+  QPushButton *_stop_button;
+  QPushButton *_find_button;
+  QPushButton *_close_button;
+  QPushButton *_browse_button;
+  QTableView  *_file_list;
+  QTimer      *_timer;
+  QCheckBox   *_recurse_dirs_check;
+  QCheckBox   *_include_dirs_check;
+  QCheckBox   *_name_case_check;
+  QCheckBox   *_contains_text_check;
+  QCheckBox   *_content_case_check;
+  QLineEdit   *_contains_text_edit;
+  QDirIterator *_dir_iterator;
+  QStatusBar  *_status_bar;
 };
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -1938,17 +1938,17 @@ file_editor::add_file_editor_tab (file_e
   _tab_widget->setCurrentWidget (f);
 
   check_actions ();
 }
 
 bool
 file_editor::editor_tab_has_focus ()
 {
-  QWidget * foc_w = focusWidget ();
+  QWidget *foc_w = focusWidget ();
   if (foc_w && foc_w->inherits ("octave_qscintilla"))
     return true;
   return false;
 }
 
 void
 file_editor::set_shortcuts ()
 {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -414,17 +414,17 @@ private:
   QAction *_goto_line_action;
   QAction *_completion_action;
 
   QAction *_move_to_matching_brace;
   QAction *_sel_to_matching_brace;
   QAction *_next_bookmark_action;
   QAction *_previous_bookmark_action;
   QAction *_toggle_bookmark_action;
-  QAction * _remove_bookmark_action;
+  QAction *_remove_bookmark_action;
 
   QAction *_print_action;
   QAction *_run_action;
   QAction *_run_selection_action;
 
   QAction *_edit_function_action;
   QAction *_popdown_mru_action;
   QAction *_save_action;
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1231,50 +1231,50 @@ main_window::connect_visibility_changed 
 #endif
 }
 
 void
 main_window::copyClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
-      QLineEdit * edit = _current_directory_combo_box->lineEdit ();
+      QLineEdit *edit = _current_directory_combo_box->lineEdit ();
       if (edit && edit->hasSelectedText ())
         {
           QClipboard *clipboard = QApplication::clipboard ();
           clipboard->setText (edit->selectedText ());
         }
     }
   else
     emit copyClipboard_signal ();
 }
 
 void
 main_window::pasteClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
-      QLineEdit * edit = _current_directory_combo_box->lineEdit ();
+      QLineEdit *edit = _current_directory_combo_box->lineEdit ();
       QClipboard *clipboard = QApplication::clipboard ();
       QString str = clipboard->text ();
       if (edit && str.length () > 0)
         {
           edit->insert (str);
         }
     }
   else
     emit pasteClipboard_signal ();
 }
 
 void
 main_window::selectAll (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
-      QLineEdit * edit = _current_directory_combo_box->lineEdit ();
+      QLineEdit *edit = _current_directory_combo_box->lineEdit ();
       if (edit)
         {
           edit->selectAll ();
         }
     }
   else
     emit selectAll_signal ();
 }
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -268,17 +268,17 @@ public slots:
 private slots:
 
   void disable_menu_shortcuts (bool disable);
   void restore_create_file_setting ();
   void set_file_encoding (const QString& new_encoding);
   void request_open_files (const QStringList& open_file_names);
 
 protected:
-  void closeEvent (QCloseEvent * closeEvent);
+  void closeEvent (QCloseEvent *closeEvent);
 
 private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
 
   QAction *add_action (QMenu *menu, const QIcon &icon, const QString &text,
@@ -423,22 +423,22 @@ private:
   static const int current_directory_max_visible = 16;
   static const int current_directory_max_count = 16;
   QLineEdit *_current_directory_line_edit;
 
   // settings dialog as guarded pointer (set to 0 when deleted)
   QPointer<settings_dialog> _settings_dlg;
 
   // Find files dialog
-  find_files_dialog * find_files_dlg;
+  find_files_dialog *find_files_dlg;
 
   // release notes window
-  QWidget * release_notes_window;
+  QWidget *release_notes_window;
 
-  QWidget * community_news_window;
+  QWidget *community_news_window;
 
   octave_qt_link *_octave_qt_link;
 
   QClipboard *_clipboard;
 
   // Flag for closing whole application.
   bool _closing;
 
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -310,17 +310,17 @@ octave_dock_widget::change_visibility (b
   setVisible (false);
   emit active_changed (false);
 }
 
 // get focus widget
 QWidget *
 octave_dock_widget::focusWidget ()
 {
-  QWidget * w = QApplication::focusWidget ();
+  QWidget *w = QApplication::focusWidget ();
   if (w && w->focusProxy ()) w = w->focusProxy ();
   return w;
 }
 
 void
 octave_dock_widget::set_style (bool active)
 {
   QString css;
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -87,18 +87,18 @@ private:
   };
 
   struct info_file_item
   {
     QFileInfo file_info;
     int real_size;
   };
 
-  QString search_node (const QString& node, QIODevice * io);
-  QString get_next_node (QIODevice * io);
+  QString search_node (const QString& node, QIODevice *io);
+  QString get_next_node (QIODevice *io);
   QString get_node_name (const QString& text);
   QString get_node_up (const QString& text);
   QString get_node_next (const QString& text);
   QString get_node_prev (const QString& text);
   void append_line (QString *test, const char *line);
 
   /** Parses info files and gets map of node positions.*/
   void parse_info_map ();
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 namespace Ui
 {
   class settings_dialog;
 }
 
 class settings_dialog:public QDialog
 {
   Q_OBJECT public:
-  explicit settings_dialog (QWidget * parent,
+  explicit settings_dialog (QWidget *parent,
                             const QString& desired_tab = QString ());
   ~settings_dialog ();
   void show_tab (const QString&);
 
 signals:
   void apply_new_settings ();
 
 private slots:
@@ -55,17 +55,17 @@ private slots:
   void button_clicked (QAbstractButton *button);
 
   // slots for import/export-buttons of shortcut sets
   void import_shortcut_set ();
   void export_shortcut_set ();
   void default_shortcut_set ();
 
 private:
-  Ui::settings_dialog * ui;
+  Ui::settings_dialog *ui;
 
   void write_changed_settings (bool closing);
 
   void read_workspace_colors (QSettings *settings);
   void write_workspace_colors (QSettings *settings);
 
   void read_terminal_colors (QSettings *settings);
   void write_terminal_colors (QSettings *settings);
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1167,17 +1167,17 @@ write_header (std::ostream& os, load_sav
 
         os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
-        char const * versionmagic;
+        char const *versionmagic;
         int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
         char headertext[128];
         octave::sys::gmtime now;
 
         // ISO 8601 format date
         const char *matlab_format = "MATLAB 5.0 MAT-file, written by Octave "
             OCTAVE_VERSION ", %Y-%m-%d %T UTC";
         std::string comment_string = now.strftime (matlab_format);
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -383,17 +383,17 @@ public:
   // Not allowed.
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/) { request_mutation (); }
 
   double get_scalar (void) const
   {
     if (val.is_sparse_type ())
       {
         // For sparse arrays, return the first non-zero value.
-        void * data = val.mex_get_data ();
+        void *data = val.mex_get_data ();
         if (data == NULL)
           return 0.0;
 
         if (val.is_bool_type ())
           return *static_cast<bool *> (data);
         else if (val.is_real_type ())
           return *static_cast<double *> (data);
         else  // Complex type, only return real part
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2972,17 +2972,17 @@ PRINT_CONV (octave_uint8, octave_uint16)
 
 #undef PRINT_CONV
 
 template <typename T>
 /* static */ inline void
 pr_int (std::ostream& os, const T& d, int fw = 0)
 {
   size_t sz = d.byte_size ();
-  const unsigned char * tmpi = d.iptr ();
+  const unsigned char *tmpi = d.iptr ();
 
   // Unless explicitly asked for, always print in big-endian
   // format for hex and bit formats.
   //
   //   {bit,hex}_format == 1: print big-endian
   //   {bit,hex}_format == 2: print native
 
   if (hex_format)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1111,17 +1111,17 @@ octave_value
 symbol_table::fcn_info::fcn_info_rep::find_package (void)
 {
   // FIXME: implement correct way to check out of date package
   //if (package.is_defined ())
   //  out_of_date_check (package);
 
   if (package.is_undefined ())
     {
-      octave_function * fcn =
+      octave_function *fcn =
         cdef_manager::find_package_symbol (full_name ());
 
       if (fcn)
         package = octave_value (fcn);
     }
 
   return package;
 }
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -230,17 +230,17 @@ namespace octave
 
     void set_initialstep (realtype initialstep);
 
     bool
     interpolate (int& cont, Matrix& output, ColumnVector& tout,
                  int refine, realtype tend, bool haveoutputfcn,
                  bool haveoutputsel, octave_function *output_fcn,
                  ColumnVector& outputsel, bool haveeventfunction,
-                 octave_function * event_fcn, ColumnVector& te,
+                 octave_function *event_fcn, ColumnVector& te,
                  Matrix& ye, ColumnVector& ie, ColumnVector& oldval,
                  ColumnVector& oldisterminal, ColumnVector& olddir,
                  int& temp, ColumnVector& yold);
 
     bool
     outputfun (octave_function *output_fcn, bool haveoutputsel,
                const ColumnVector& output, realtype tout, realtype tend,
                ColumnVector& outputsel, const std::string& flag);
@@ -737,17 +737,17 @@ namespace octave
     return status;
   }
 
   bool
   IDA::interpolate (int& cont, Matrix& output, ColumnVector& tout,
                     int refine, realtype tend, bool haveoutputfcn,
                     bool haveoutputsel, octave_function *output_fcn,
                     ColumnVector& outputsel, bool haveeventfunction,
-                    octave_function * event_fcn, ColumnVector& te,
+                    octave_function *event_fcn, ColumnVector& te,
                     Matrix& ye, ColumnVector& ie, ColumnVector& oldval,
                     ColumnVector& oldisterminal, ColumnVector& olddir,
                     int& temp, ColumnVector& yold)
   {
     realtype h = 0, tcur = 0;
     bool status = 0;
 
     N_Vector dky = N_VNew_Serial (num);
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -463,17 +463,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  octave_idx_type * itmp = m.xcidx ();
+  octave_idx_type *itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -492,17 +492,17 @@ octave_sparse_complex_matrix::save_hdf5 
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  octave_idx_type * itmp = m.xcidx ();
+  octave_idx_type *itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -591,17 +591,17 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   retval = false;
   if (complex_type_hid >= 0)
     {
-      Complex * ctmp = m.xdata ();
+      Complex *ctmp = m.xdata ();
 
       retval = H5Dwrite (data_hid, complex_type_hid, octave_H5S_ALL, octave_H5S_ALL,
                          octave_H5P_DEFAULT, ctmp) >= 0;
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -329,17 +329,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, ifargs.numel () * (len + 1));
 
   // Save the args as a null teminated list
   for (int i = 0; i < ifargs.numel (); i++)
     {
-      const char * cptr = ifargs(i).c_str ();
+      const char *cptr = ifargs(i).c_str ();
       for (size_t j = 0; j < ifargs(i).length (); j++)
         s[i*(len+1)+j] = *cptr++;
       s[ifargs(i).length ()] = '\0';
     }
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, s) >= 0;
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -512,17 +512,17 @@ octave_sparse_matrix::save_hdf5 (octave_
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  octave_idx_type * itmp = m.xcidx ();
+  octave_idx_type *itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -598,17 +598,17 @@ octave_sparse_matrix::save_hdf5 (octave_
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  double * dtmp = m.xdata ();
+  double *dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
   octave_unused_parameter (loc_id);
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -164,23 +164,23 @@ Sparse<T>::SparseRep::change_length (oct
   // We shall skip reallocation if we have less than 1/frac extra elements to
   // discard.
   static const int frac = 5;
   if (nz > nzmx || nz < nzmx - nzmx/frac)
     {
       // Reallocate.
       octave_idx_type min_nzmx = std::min (nz, nzmx);
 
-      octave_idx_type * new_ridx = new octave_idx_type [nz];
+      octave_idx_type *new_ridx = new octave_idx_type [nz];
       std::copy_n (r, min_nzmx, new_ridx);
 
       delete [] r;
       r = new_ridx;
 
-      T * new_data = new T [nz];
+      T *new_data = new T [nz];
       std::copy_n (d, min_nzmx, new_data);
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -810,27 +810,27 @@ idx_vector::maybe_reduce (octave_idx_typ
         case class_colon:
           // (:,:) reduces to (:)
           reduced = true;
           break;
 
         case class_scalar:
           {
             // (i,:) reduces to a range.
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+            idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
             octave_idx_type k = r->get_data ();
             *this = new idx_range_rep (k, nj, n, DIRECT);
             reduced = true;
           }
           break;
 
         case class_range:
           {
             // (i:k:end,:) reduces to a range if i <= k and k divides n.
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+            idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type s = r->get_start ();
             octave_idx_type l = r->length (n);
             octave_idx_type t = r->get_step ();
             if (l*t == n)
               {
                 *this = new idx_range_rep (s, l * nj, t, DIRECT);
                 reduced = true;
               }
@@ -843,50 +843,50 @@ idx_vector::maybe_reduce (octave_idx_typ
       break;
 
     case class_range:
       switch (rep->idx_class ())
         {
         case class_colon:
           {
             // (:,i:j) reduces to a range (the step must be 1)
-            idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
+            idx_range_rep *rj = dynamic_cast<idx_range_rep *> (j.rep);
             if (rj->get_step () == 1)
               {
                 octave_idx_type sj = rj->get_start ();
                 octave_idx_type lj = rj->length (nj);
                 *this = new idx_range_rep (sj * n, lj * n, 1, DIRECT);
                 reduced = true;
               }
           }
           break;
 
         case class_scalar:
           {
             // (k,i:d:j) reduces to a range.
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
+            idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
+            idx_range_rep *rj = dynamic_cast<idx_range_rep *> (j.rep);
             octave_idx_type k = r->get_data ();
             octave_idx_type sj = rj->get_start ();
             octave_idx_type lj = rj->length (nj);
             octave_idx_type tj = rj->get_step ();
             *this = new idx_range_rep (n * sj + k, lj, n * tj, DIRECT);
             reduced = true;
           }
           break;
 
         case class_range:
           {
             // (i:k:end,p:q) reduces to a range if i <= k and k divides n.
             // (ones (1, m), ones (1, n)) reduces to (ones (1, m*n))
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+            idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
             octave_idx_type s = r->get_start ();
             octave_idx_type l = r->length (n);
             octave_idx_type t = r->get_step ();
-            idx_range_rep * rj = dynamic_cast<idx_range_rep *> (j.rep);
+            idx_range_rep *rj = dynamic_cast<idx_range_rep *> (j.rep);
             octave_idx_type sj = rj->get_start ();
             octave_idx_type lj = rj->length (nj);
             octave_idx_type tj = rj->get_step ();
             if ((l*t == n && tj == 1) || (t == 0 && tj == 0))
               {
                 *this = new idx_range_rep (s + n * sj, l * lj, t, DIRECT);
                 reduced = true;
               }
@@ -899,42 +899,42 @@ idx_vector::maybe_reduce (octave_idx_typ
       break;
 
     case class_scalar:
       switch (rep->idx_class ())
         {
         case class_scalar:
           {
             // (i,j) reduces to a single index.
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
+            idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
+            idx_scalar_rep *rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type k = r->get_data () + n * rj->get_data ();
             *this = new idx_scalar_rep (k, DIRECT);
             reduced = true;
           }
           break;
 
         case class_range:
           {
             // (i:d:j,k) reduces to a range.
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
+            idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
+            idx_scalar_rep *rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type s = r->get_start ();
             octave_idx_type l = r->length (nj);
             octave_idx_type t = r->get_step ();
             octave_idx_type k = rj->get_data ();
             *this = new idx_range_rep (n * k + s, l, t, DIRECT);
             reduced = true;
           }
           break;
 
         case class_colon:
           {
             // (:,k) reduces to a range.
-            idx_scalar_rep * rj = dynamic_cast<idx_scalar_rep *> (j.rep);
+            idx_scalar_rep *rj = dynamic_cast<idx_scalar_rep *> (j.rep);
             octave_idx_type k = rj->get_data ();
             *this = new idx_range_rep (n * k, n, 1, DIRECT);
             reduced = true;
           }
           break;
 
         default:
           break;
@@ -958,38 +958,38 @@ idx_vector::is_cont_range (octave_idx_ty
     {
     case class_colon:
       l = 0; u = n;
       res = true;
       break;
 
     case class_range:
       {
-        idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+        idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
         if (r->get_step () == 1)
           {
             l = r->get_start ();
             u = l + r->length (n);
             res = true;
           }
       }
       break;
 
     case class_scalar:
       {
-        idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+        idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
         l = r->get_data ();
         u = l + 1;
         res = true;
       }
       break;
 
     case class_mask:
       {
-        idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+        idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
         octave_idx_type ext = r->extent (0);
         octave_idx_type len = r->length (0);
         if (ext == len)
           {
             l = 0;
             u = len;
             res = true;
           }
@@ -1033,17 +1033,17 @@ idx_vector::increment (void) const
 }
 
 const octave_idx_type *
 idx_vector::raw (void)
 {
   if (rep->idx_class () != class_vector)
     *this = idx_vector (as_array (), extent (0));
 
-  idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+  idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
 
   assert (r != 0);
 
   return r->get_data ();
 }
 
 void
 idx_vector::copy_data (octave_idx_type *data) const
@@ -1053,47 +1053,47 @@ idx_vector::copy_data (octave_idx_type *
   switch (rep->idx_class ())
     {
     case class_colon:
       (*current_liboctave_error_handler) ("colon not allowed");
       break;
 
     case class_range:
       {
-        idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+        idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
         octave_idx_type start = r->get_start ();
         octave_idx_type step = r->get_step ();
         octave_idx_type i, j;
         if (step == 1)
           for (i = start, j = start + len; i < j; i++) *data++ = i;
         else if (step == -1)
           for (i = start, j = start - len; i > j; i--) *data++ = i;
         else
           for (i = 0, j = start; i < len; i++, j += step) *data++ = j;
       }
       break;
 
     case class_scalar:
       {
-        idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+        idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
         *data = r->get_data ();
       }
       break;
 
     case class_vector:
       {
-        idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+        idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
         const octave_idx_type *rdata = r->get_data ();
         std::copy_n (rdata, len, data);
       }
       break;
 
     case class_mask:
       {
-        idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+        idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
         const bool *mask = r->get_data ();
         octave_idx_type ext = r->extent (0);
         for (octave_idx_type i = 0, j = 0; i < ext; i++)
           if (mask[i])
             data[j++] = i;
       }
       break;
 
@@ -1108,17 +1108,17 @@ idx_vector::complement (octave_idx_type 
 {
   idx_vector retval;
   if (extent (n) > n)
     (*current_liboctave_error_handler)
       ("internal error: out of range complement index requested");
 
   if (idx_class () == class_mask)
     {
-      idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+      idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
       octave_idx_type nz = r->length (0);
       octave_idx_type ext = r->extent (0);
       Array<bool> mask (dim_vector (n, 1));
       const bool *data = r->get_data ();
       bool *ndata = mask.fortran_vec ();
       for (octave_idx_type i = 0; i < ext; i++)
         ndata[i] = ! data[i];
       std::fill_n (ndata + ext, n - ext, true);
@@ -1198,17 +1198,17 @@ idx_vector::inverse_permutation (octave_
   return retval;
 }
 
 idx_vector
 idx_vector::unmask (void) const
 {
   if (idx_class () == class_mask)
     {
-      idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+      idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0);
       octave_idx_type len = r->length (0);
       octave_idx_type *idata = new octave_idx_type [len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i])
           idata[j++] = i;
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -631,17 +631,17 @@ public:
     switch (rep->idx_class ())
       {
       case class_colon:
         std::copy_n (src, len, dest);
         break;
 
       case class_range:
         {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           const T *ssrc = src + start;
           if (step == 1)
             std::copy_n (ssrc, len, dest);
           else if (step == -1)
             std::reverse_copy (ssrc - len + 1, ssrc + 1, dest);
           else if (step == 0)
@@ -651,33 +651,33 @@ public:
               for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                 dest[i] = ssrc[j];
             }
         }
         break;
 
       case class_scalar:
         {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
           dest[0] = src[r->get_data ()];
         }
         break;
 
       case class_vector:
         {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           for (octave_idx_type i = 0; i < len; i++)
             dest[i] = src[data[i]];
         }
         break;
 
       case class_mask:
         {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
           const bool *data = r->get_data ();
           octave_idx_type ext = r->extent (0);
           for (octave_idx_type i = 0; i < ext; i++)
             if (data[i]) *dest++ = src[i];
         }
         break;
 
       default:
@@ -705,17 +705,17 @@ public:
     switch (rep->idx_class ())
       {
       case class_colon:
         std::copy_n (src, len, dest);
         break;
 
       case class_range:
         {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           T *sdest = dest + start;
           if (step == 1)
             std::copy_n (src, len, sdest);
           else if (step == -1)
             std::reverse_copy (src, src + len, sdest - len + 1);
           else
@@ -723,33 +723,33 @@ public:
               for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                 sdest[j] = src[i];
             }
         }
         break;
 
       case class_scalar:
         {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
           dest[r->get_data ()] = src[0];
         }
         break;
 
       case class_vector:
         {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           for (octave_idx_type i = 0; i < len; i++)
             dest[data[i]] = src[i];
         }
         break;
 
       case class_mask:
         {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
           const bool *data = r->get_data ();
           octave_idx_type ext = r->extent (0);
           for (octave_idx_type i = 0; i < ext; i++)
             if (data[i]) dest[i] = *src++;
         }
         break;
 
       default:
@@ -777,17 +777,17 @@ public:
     switch (rep->idx_class ())
       {
       case class_colon:
         std::fill_n (dest, len, val);
         break;
 
       case class_range:
         {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           T *sdest = dest + start;
           if (step == 1)
             std::fill_n (sdest, len, val);
           else if (step == -1)
             std::fill (sdest - len + 1, sdest + 1, val);
           else
@@ -795,33 +795,33 @@ public:
               for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
                 sdest[j] = val;
             }
         }
         break;
 
       case class_scalar:
         {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
           dest[r->get_data ()] = val;
         }
         break;
 
       case class_vector:
         {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           for (octave_idx_type i = 0; i < len; i++)
             dest[data[i]] = val;
         }
         break;
 
       case class_mask:
         {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
           const bool *data = r->get_data ();
           octave_idx_type ext = r->extent (0);
           for (octave_idx_type i = 0; i < ext; i++)
             if (data[i]) dest[i] = val;
         }
         break;
 
       default:
@@ -847,47 +847,47 @@ public:
     switch (rep->idx_class ())
       {
       case class_colon:
         for (octave_idx_type i = 0; i < len; i++) body (i);
         break;
 
       case class_range:
         {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           octave_idx_type i, j;
           if (step == 1)
             for (i = start, j = start + len; i < j; i++) body (i);
           else if (step == -1)
             for (i = start, j = start - len; i > j; i--) body (i);
           else
             for (i = 0, j = start; i < len; i++, j += step) body (j);
         }
         break;
 
       case class_scalar:
         {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
           body (r->get_data ());
         }
         break;
 
       case class_vector:
         {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           for (octave_idx_type i = 0; i < len; i++) body (data[i]);
         }
         break;
 
       case class_mask:
         {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
           const bool *data = r->get_data ();
           octave_idx_type ext = r->extent (0);
           for (octave_idx_type i = 0; i < ext; i++)
             if (data[i]) body (i);
         }
         break;
 
       default:
@@ -919,50 +919,50 @@ public:
           octave_idx_type i;
           for (i = 0; i < len && body (i); i++) ;
           ret = i;
         }
         break;
 
       case class_range:
         {
-          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          idx_range_rep *r = dynamic_cast<idx_range_rep *> (rep);
           octave_idx_type start = r->get_start ();
           octave_idx_type step = r->get_step ();
           octave_idx_type i, j;
           if (step == 1)
             for (i = start, j = start + len; i < j && body (i); i++) ;
           else if (step == -1)
             for (i = start, j = start - len; i > j && body (i); i--) ;
           else
             for (i = 0, j = start; i < len && body (j); i++, j += step) ;
           ret = i;
         }
         break;
 
       case class_scalar:
         {
-          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
           ret = body (r->get_data ()) ? 1 : 0;
         }
         break;
 
       case class_vector:
         {
-          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           octave_idx_type i;
           for (i = 0; i < len && body (data[i]); i++) ;
           ret = i;
         }
         break;
 
       case class_mask:
         {
-          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          idx_mask_rep *r = dynamic_cast<idx_mask_rep *> (rep);
           const bool *data = r->get_data ();
           octave_idx_type ext = r->extent (0);
           octave_idx_type j = 0;
           for (octave_idx_type i = 0; i < ext; i++)
             {
               if (data[i])
                 {
                   if (body (i))
