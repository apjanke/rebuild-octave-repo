# HG changeset patch
# User dbateman
# Date 1142531336 0
#      Thu Mar 16 17:48:56 2006 +0000
# Node ID 233d98d956595b9abd4014359fef1b1198d76d05
# Parent  cc6a965ae4ca6581c255e9ff34e4442fbd0126db
[project @ 2006-03-16 17:48:55 by dbateman]

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,14 @@
+2006-03-16  David Bateman  <dbateman@free.fr>
+
+	* interpreter/images/sparseimages.m: set terminal type to dummy to
+	direct output to terminal rather than X11.
+	* interpreter/sparse.txi: Update docs for new QR solvers.
+	
 2006-03-09  David Bateman  <dbateman@free.fr>
 
 	* interpreter/Makefile.in: Change order of commands in HTML/index.html
 	target. Respawn make for stamp-pdf target so that $(wildcard *.eps) is
 	reinterpreted.
 	* interpreter/sparse.txi: Isolate conditionally built targets in
 	"@ifset ... @end ifset".
 
diff --git a/doc/interpreter/images/sparseimages.m b/doc/interpreter/images/sparseimages.m
--- a/doc/interpreter/images/sparseimages.m
+++ b/doc/interpreter/images/sparseimages.m
@@ -1,9 +1,18 @@
 function sparseimages(dirc,typ)
+  ## XXX FIXME XXX 
+  ## How do we set terminal and direct the output to /dev/null without
+  ## gnuplot? Note that due to replot in print.m, the redirection to
+  ## /dev/null effectively doesn't work at the moment.
+  __gnuplot_set__ term dumb
+  [status, dummy] = fileattrib("/dev/null");
+  if (status)
+    __gnuplot_set__ output '/dev/null'
+  endif
   plot(1) # FIXME bypass 2.9.4 bug!!
   if (strcmp(typ,"txt"))
     txtimages(15,dirc,typ);
   else
     otherimages(200,dirc,typ);
     gplotimages("gplot",dirc,typ);
     femimages("grid",dirc,typ);
   endif
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -740,26 +740,33 @@ CXSPARSE@footnote{CHOLMOD, UMFPACK and C
 and are available at http://www.cise.ufl.edu/research/sparse/}.
 @end enumerate
 
 The band density is defined as the number of non-zero values in the matrix
 divided by the number of non-zero values in the matrix. The banded matrix
 solvers can be entirely disabled by using @dfn{spparms} to set @code{bandden}
 to 1 (i.e. @code{spparms ("bandden", 1)}).
 
-All of the solvers above, expect the banded solvers, calculate an
-estimate of the condition number. This can be used to detect numerical
-stability problems in the solution and force a minimum norm solution
-to be used. However, for narrow banded matrices, the cost of
-calculating the condition number is significant, and can in fact exceed
-the cost of factoring the matrix. Therefore the condition number is
-not calculated for banded matrices, and therefore unless the factorization
-is exactly singular, these numerical instabilities won't be detected.
-In cases where, this might be a problem the user is recommended to disable
-the banded solvers as above, at a significant cost in terms of speed.
+The QR solver factorizes the problem with a Dulmage-Mendhelsohn, to
+seperate the problem into blocks that can be treated as over-determined,
+multiple well determined blocks, and a final over-determined block. For
+matrices with blocks of strongly connectted nodes this is a big win as
+LU decomposition can be used for many blocks. It also significantly
+improves the chance of finding a solution to over-determined problems
+rather than just returning a vector of @dfn{NaN}'s.
+
+All of the solvers above, can calculate an estimate of the condition
+number. This can be used to detect numerical stability problems in the
+solution and force a minimum norm solution to be used. However, for
+narrow banded, triangular or diagonal matrices, the cost of
+calculating the condition number is significant, and can in fact
+exceed the cost of factoring the matrix. Therefore the condition
+number is not calculated in these case, and octave relies on simplier
+techniques to detect sinular matrices or the underlying LAPACK code in
+the case of banded matrices.
 
 The user can force the type of the matrix with the @code{matrix_type}
 function. This overcomes the cost of discovering the type of the matrix.
 However, it should be noted incorrectly identifying the type of the matrix
 will lead to unpredictable results, and so @code{matrix_type} should be
 used with care.
 
 @node Iterative Techniques, Real Life Example, Sparse Linear Algebra, Sparse Matrices
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -42,16 +42,23 @@ Boston, MA 02110-1301, USA.
 #include "SparseCmplxLU.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
 #include "SparseCmplxCHOL.h"
 #include "SparseCmplxQR.h"
 
 #include "oct-sort.h"
 
+// Define whether to use a basic QR solver or one that uses a Dulmange
+// Mendelsohn factorization to seperate the problem into under-determined,
+// well-determined and over-determined parts and solves them seperately
+#ifndef USE_QRSOLVE
+#include "sparse-dmsolve.cc"
+#endif
+
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgbtrf, ZGBTRF) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
 			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
@@ -77,17 +84,17 @@ extern "C"
   F77_FUNC (zpbtrs, ZPBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
 			     const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&, 
 			     Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpbcon, ZPBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
 			     const octave_idx_type&, Complex*, const octave_idx_type&, 
-			     const double&, double&, Complex*, octave_idx_type*, octave_idx_type&
+			     const double&, double&, Complex*, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgttrf, ZGTTRF) (const octave_idx_type&, Complex*, Complex*, Complex*,
 			     Complex*, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgttrs, ZGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
@@ -101,56 +108,56 @@ extern "C"
 			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseMatrix& a)
-  : MSparse<Complex> (a.rows (), a.cols (), a.nzmax ())
+  : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = a.nnz ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      data (i) = a.data (i);
+      data (i) = Complex (a.data (i));
       ridx (i) = a.ridx (i);
     }
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseBoolMatrix& a)
-  : MSparse<Complex> (a.rows (), a.cols (), a.nzmax ())
+  : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = a.nnz ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      data (i) = a.data (i);
+      data (i) = Complex (a.data (i));
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseComplexMatrix::operator == (const SparseComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
-  octave_idx_type nz_a = a.nzmax ();
+  octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
@@ -541,17 +548,17 @@ SparseComplexMatrix::matrix_value (void)
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   SparseComplexMatrix retval (nc, nr, nz);
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr + 1);
   for (octave_idx_type i = 0; i < nr; i++)
     w[i] = 0;
   for (octave_idx_type i = 0; i < nz; i++)
     w[ridx(i)]++;
   nz = 0;
@@ -575,17 +582,17 @@ SparseComplexMatrix::hermitian (void) co
   return retval;
 }
 
 SparseComplexMatrix
 conj (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
+  octave_idx_type nz = a.nnz ();
   SparseComplexMatrix retval (nc, nr, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = conj (a.data (i));
@@ -708,17 +715,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
 	  if (typ == SparseType::Upper || typ == SparseType::Lower)
 	    {
-	      octave_idx_type nz = nzmax ();
+	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  OCTAVE_QUIT;
 		  // place the 1 in the identity position
@@ -793,17 +800,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 		    for (octave_idx_type j = cx_colstart; j < cx; j++)
 		      retval.xdata(j) /= pivot;
 		}
 	      retval.xcidx(nr) = cx;
 	      retval.maybe_compress ();
 	    }
 	  else
 	    {
-	      octave_idx_type nz = nzmax ();
+	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
@@ -1113,18 +1120,18 @@ SparseComplexMatrix::determinant (octave
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b,
-			     octave_idx_type& err, 
-			     double& rcond, solve_singularity_handler) const
+			     octave_idx_type& err, double& rcond, 
+			     solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1146,38 +1153,44 @@ SparseComplexMatrix::dsolve (SparseType 
 		for (octave_idx_type i = 0; i < nm; i++)
 		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = std::abs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = std::abs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.0;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseMatrix& b,
 			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler) const
+			     solve_singularity_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1189,26 +1202,28 @@ SparseComplexMatrix::dsolve (SparseType 
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
+		    if (b.ridx(i) >= nm)
+		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
@@ -1227,38 +1242,44 @@ SparseComplexMatrix::dsolve (SparseType 
 			{
 			  retval.xridx (ii) = l;
 			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
 		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = std::abs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = std::abs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.0;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
 			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler) const
+			     solve_singularity_handler,
+			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1280,38 +1301,44 @@ SparseComplexMatrix::dsolve (SparseType 
 	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      double tmp = std::abs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nr; i++)
+		{
+		  double tmp = std::abs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.0;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
 			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler) const
+			     solve_singularity_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1323,26 +1350,28 @@ SparseComplexMatrix::dsolve (SparseType 
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
+		    if (b.ridx(i) >= nm)
+		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
@@ -1361,38 +1390,44 @@ SparseComplexMatrix::dsolve (SparseType 
 			{
 			  retval.xridx (ii) = l;
 			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
 		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = std::abs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = std::abs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.0;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b,
 			      octave_idx_type& err, double& rcond,
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1406,48 +1441,52 @@ SparseComplexMatrix::utsolve (SparseType
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -1458,48 +1497,52 @@ SparseComplexMatrix::utsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (perm[i], j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); 
-			       i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -1508,17 +1551,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -1528,86 +1572,96 @@ SparseComplexMatrix::utsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1620,30 +1674,33 @@ SparseComplexMatrix::utsolve (SparseType
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -1661,17 +1718,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -1704,48 +1762,52 @@ SparseComplexMatrix::utsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); 
-			       i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -1753,17 +1815,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -1795,85 +1858,95 @@ SparseComplexMatrix::utsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1887,26 +1960,29 @@ SparseComplexMatrix::utsolve (SparseType
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
@@ -1918,17 +1994,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -1939,48 +2016,52 @@ SparseComplexMatrix::utsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (perm[i], j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); 
-			       i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -1989,17 +2070,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -2009,86 +2091,96 @@ SparseComplexMatrix::utsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2101,30 +2193,33 @@ SparseComplexMatrix::utsolve (SparseType
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2142,17 +2237,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -2185,48 +2281,52 @@ SparseComplexMatrix::utsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); 
-			       i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -2234,17 +2334,18 @@ SparseComplexMatrix::utsolve (SparseType
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -2276,86 +2377,96 @@ SparseComplexMatrix::utsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, 
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2369,26 +2480,29 @@ SparseComplexMatrix::ltsolve (SparseType
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
@@ -2408,17 +2522,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data (mini) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -2431,59 +2545,65 @@ SparseComplexMatrix::ltsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      Complex tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      retval.resize (nc, b_nc, 0.);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -2491,17 +2611,18 @@ SparseComplexMatrix::ltsolve (SparseType
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -2510,87 +2631,96 @@ SparseComplexMatrix::ltsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
-
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
 
   err = 0;
@@ -2604,30 +2734,33 @@ SparseComplexMatrix::ltsolve (SparseType
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
@@ -2649,17 +2782,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data (mini) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -2694,59 +2827,65 @@ SparseComplexMatrix::ltsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      Complex tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -2754,17 +2893,18 @@ SparseComplexMatrix::ltsolve (SparseType
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -2796,88 +2936,97 @@ SparseComplexMatrix::ltsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b,
 			      octave_idx_type& err, double& rcond,
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2891,26 +3040,29 @@ SparseComplexMatrix::ltsolve (SparseType
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
@@ -2930,17 +3082,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data (mini) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -2953,59 +3105,65 @@ SparseComplexMatrix::ltsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      Complex tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      retval.resize (nc, b_nc, 0.);
 
 
@@ -3015,17 +3173,18 @@ SparseComplexMatrix::ltsolve (SparseType
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -3035,88 +3194,97 @@ SparseComplexMatrix::ltsolve (SparseType
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
 			      octave_idx_type& err, double& rcond, 
-			      solve_singularity_handler sing_handler) const
+			      solve_singularity_handler sing_handler,
+			      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3129,30 +3297,33 @@ SparseComplexMatrix::ltsolve (SparseType
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += std::abs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
@@ -3174,17 +3345,17 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data (mini) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -3219,59 +3390,65 @@ SparseComplexMatrix::ltsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  Complex tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      Complex tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -3279,17 +3456,18 @@ SparseComplexMatrix::ltsolve (SparseType
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -3321,98 +3499,110 @@ SparseComplexMatrix::ltsolve (SparseType
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      Complex tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += std::abs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += std::abs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-			       double& rcond,
-			       solve_singularity_handler sing_handler) const
+SparseComplexMatrix::trisolve (SparseType &mattype, const Matrix& b,
+			       octave_idx_type& err, double& rcond,
+			       solve_singularity_handler sing_handler,
+			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
@@ -3521,17 +3711,20 @@ SparseComplexMatrix::trisolve (SparseTyp
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgtsv");
 	  else if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    rcond = 1.;
 	}
@@ -3539,28 +3732,32 @@ SparseComplexMatrix::trisolve (SparseTyp
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, const SparseMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			       octave_idx_type& err, double& rcond, 
+			       solve_singularity_handler sing_handler,
+			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
@@ -3609,36 +3806,40 @@ SparseComplexMatrix::trisolve (SparseTyp
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgttrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
+		  volatile octave_idx_type x_nz = b.nnz ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
+		  rcond = 1.0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 		      for (octave_idx_type i = 0; i < nr; i++)
 			work[i] = 0.;
 		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
@@ -3690,27 +3891,31 @@ SparseComplexMatrix::trisolve (SparseTyp
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b,
 			       octave_idx_type& err, double& rcond, 
-			       solve_singularity_handler sing_handler) const
+			       solve_singularity_handler sing_handler,
+			       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
@@ -3829,43 +4034,51 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      err = -1;
 	    }
 	  else if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 		      
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 	    }
 	}
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, 
-		     const SparseComplexMatrix& b, octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			       const SparseComplexMatrix& b, 
+			       octave_idx_type& err, double& rcond, 
+			       solve_singularity_handler sing_handler,
+			       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
@@ -3914,38 +4127,41 @@ SparseComplexMatrix::trisolve (SparseTyp
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgttrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 		} 
 	      else 
 		{	
 		  rcond = 1.;
 		  char job = 'N';
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
+		  volatile octave_idx_type x_nz = b.nnz ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -4005,19 +4221,20 @@ SparseComplexMatrix::trisolve (SparseTyp
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const
+SparseComplexMatrix::bsolve (SparseType &mattype, const Matrix& b,
+			     octave_idx_type& err, double& rcond,
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4049,101 +4266,104 @@ SparseComplexMatrix::bsolve (SparseType 
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  // Calculate the norm of the matrix, for later use.
-	  // double anorm = m_band.abs().sum().row(0).max();
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
-		  // Unfortunately, the time to calculate the condition
-		  // number is dominant for narrow banded matrices and
-		  // so we rely on the "err" flag from xPBTRF to flag
-		  // singularity. The commented code below is left here
-		  // for reference
-
-		  //Array<double> z (3 * nr);
-		  //Complex *pz = z.fortran_vec ();
-		  //Array<octave_idx_type> iz (nr);
-		  //octave_idx_type *piz = iz.fortran_vec ();
-		  //
-		  //F77_XFCN (zpbcon, ZGBCON, 
-		  //	(F77_CONST_CHAR_ARG2 (&job, 1),
-		  //	 nr, n_lower, tmp_data, ldm,
-		  //	 anorm, rcond, pz, piz, err
-		  //	 F77_CHAR_ARG_LEN (1)));
-		  //
-		  //
-		  //if (f77_exception_encountered)
-		  //	(*current_liboctave_error_handler) 
-		  //	  ("unrecoverable error in zpbcon");
-		  //
-		  //if (err != 0) 
-		  //	err = -2;
-		  //
-		  //volatile double rcond_plus_one = rcond + 1.0;
-		  //
-		  //if (rcond_plus_one == 1.0 || xisnan (rcond))
-		  //  {
-		  //    err = -2;
-		  //
-		  //    if (sing_handler)
-		  //      sing_handler (rcond);
-		  //    else
-		  //      (*current_liboctave_error_handler)
-		  //        ("matrix singular to machine precision, rcond = %g",
-		  //         rcond);
-		  //  }
-		  //else
-		  //    REST OF CODE, EXCEPT rcond=1
-
-		  rcond = 1.;
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (zpbtrs, ZPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zpbcon, ZPBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in zpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.0;
+
+		  if (err == 0)
+		    {
+		      retval = ComplexMatrix (b);
+		      Complex *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      F77_XFCN (zpbtrs, ZPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, b_nc, tmp_data,
+				 ldm, result, b.rows(), err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in zpbtrs");
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-		      err = -1;
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in zpbtrs");
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			}
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4162,110 +4382,133 @@ SparseComplexMatrix::bsolve (SparseType 
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
 	    {
 	      // Throw-away extra info LAPACK gives so as to not 
 	      // change output.
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
-
 		} 
 	      else 
 		{
-		  char job = '1';
-
-		  // Unfortunately, the time to calculate the condition
-		  // number is dominant for narrow banded matrices and
-		  // so we rely on the "err" flag from xPBTRF to flag
-		  // singularity. The commented code below is left here
-		  // for reference
-
-		  //F77_XFCN (zgbcon, ZGBCON, 
-		  //	(F77_CONST_CHAR_ARG2 (&job, 1),
-		  //	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		  //	 anorm, rcond, pz, piz, err
-		  //	 F77_CHAR_ARG_LEN (1)));
-		  //
-		  //if (f77_exception_encountered)
-		  //  (*current_liboctave_error_handler) 
-		  //    ("unrecoverable error in zgbcon");
-		  //
-		  // if (err != 0) 
-		  //  err = -2;
-		  //
-		  //volatile double rcond_plus_one = rcond + 1.0;
-		  //
-		  //if (rcond_plus_one == 1.0 || xisnan (rcond))
-		  //  {
-		  //    err = -2;
-		  //
-		  //    if (sing_handler)
-		  //      sing_handler (rcond);
-		  //    else
-		  //      (*current_liboctave_error_handler)
-		  //        ("matrix singular to machine precision, rcond = %g",
-		  //         rcond);
-		  //  }
-		  //else
-		  //  REST OF CODE, EXCEPT rcond=1
-
-		  rcond = 1.;
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  job = 'N';
-		  F77_XFCN (zgbtrs, ZGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      char job = '1';
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zgbcon, ZGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in zgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      retval = ComplexMatrix (b);
+		      Complex *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      char job = 'N';
+		      F77_XFCN (zgbtrs, ZGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, b_nc, tmp_data,
+				 ldm, pipvt, result, b.rows(), err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in zgbtrs");
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in zgbtrs");
+		    }
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const SparseMatrix& b,
 			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler sing_handler) const
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4297,95 +4540,143 @@ SparseComplexMatrix::bsolve (SparseType 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
+		    {
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zpbcon, ZPBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in zpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.0;
+
+		  if (err == 0)
 		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b.elem (i, j);
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+		      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+		      // Take a first guess that the number of non-zero terms
+		      // will be as many as in b
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      volatile octave_idx_type ii = 0;
+		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		      retval.xcidx(0) = 0;
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+			{
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    Bx[i] = b.elem (i, j);
+
+			  F77_XFCN (zpbtrs, ZPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bx, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseComplexMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    {
+			      Complex tmp = Bx[i];
+			      if (tmp != 0.0)
+				{
+				  if (ii == x_nz)
+				    {
+				      // Resize the sparse matrix
+				      octave_idx_type sz = x_nz * 
+					(b_nc - j) / b_nc;
+				      sz = (sz > 10 ? sz : 10) + x_nz;
+				      retval.change_capacity (sz);
+				      x_nz = sz;
+				    }
+				  retval.xdata(ii) = tmp;
+				  retval.xridx(ii++) = i;
+				}
+			    }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseComplexMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  Complex tmp = Bx[i];
-			  if (tmp != 0.0)
-			    {
-			      if (ii == x_nz)
-				{
-				  // Resize the sparse matrix
-				  octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-				  sz = (sz > 10 ? sz : 10) + x_nz;
-				  retval.change_capacity (sz);
-				  x_nz = sz;
-				}
-			      retval.xdata(ii) = tmp;
-			      retval.xridx(ii++) = i;
-			    }
-			}
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -4403,109 +4694,172 @@ SparseComplexMatrix::bsolve (SparseType 
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  err = -2;
 
 		  if (sing_handler)
+		    {
 		    sing_handler (rcond);
+		    mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
+		      char job = '1';
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zgbcon, ZGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
 		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in zgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      octave_idx_type b_nc = b.cols ();
+		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		      retval.xcidx(0) = 0;
+		      volatile octave_idx_type ii = 0;
+
+		      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in zgbtrs");
-			  break;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    work[i] = 0.;
+			  for (octave_idx_type i = b.cidx(j); 
+			       i < b.cidx(j+1); i++)
+			    work[b.ridx(i)] = b.data(i);
+
+			  F77_XFCN (zgbtrs, ZGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, work, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in zgbtrs");
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (work[i] != 0.)
+			      new_nnz++;
+
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
+
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (work[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = work[i];
+			      }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, 
 			     octave_idx_type& err, double& rcond, 
-			     solve_singularity_handler sing_handler) const
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4537,61 +4891,108 @@ SparseComplexMatrix::bsolve (SparseType 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
+		  rcond = 0.0;
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  F77_XFCN (zpbtrs, ZPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b_nr, err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zpbcon, ZPBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in zpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.0;
+
+		  if (err == 0)
+		    {
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+		      retval = ComplexMatrix (b);
+		      Complex *result = retval.fortran_vec ();
+
+		      F77_XFCN (zpbtrs, ZPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, b_nc, tmp_data,
+				 ldm, result, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    {
-		      (*current_liboctave_error_handler)
-			("unrecoverable error in zpbtrs");
-		      err = -1;
-		    }
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseComplexMatrix::solve solve failed");
-		      err = -1;
+		      if (f77_exception_encountered)
+			{
+			  (*current_liboctave_error_handler)
+			    ("unrecoverable error in zpbtrs");
+			  err = -1;
+			}
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseComplexMatrix::solve solve failed");
+			  err = -1;
+			}
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4610,71 +5011,132 @@ SparseComplexMatrix::bsolve (SparseType 
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
-
 		} 
 	      else 
 		{
-		  char job = 'N';
-		  octave_idx_type b_nc = b.cols ();
-		  retval = ComplexMatrix (b);
-		  Complex *result = retval.fortran_vec ();
-
-		  F77_XFCN (zgbtrs, ZGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows (), err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      char job = '1';
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zgbcon, ZGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in zgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      octave_idx_type b_nc = b.cols ();
+		      retval = ComplexMatrix (b);
+		      Complex *result = retval.fortran_vec ();
+
+		      F77_XFCN (zgbtrs, ZGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, b_nc, tmp_data,
+				 ldm, pipvt, result, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    {
-		      (*current_liboctave_error_handler)
-			("unrecoverable error in dgbtrs");
+		      if (f77_exception_encountered)
+			{
+			  (*current_liboctave_error_handler)
+			    ("unrecoverable error in dgbtrs");
+			}
 		    }
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			     octave_idx_type& err, double& rcond, 
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4706,105 +5168,151 @@ SparseComplexMatrix::bsolve (SparseType 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 
+		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b (i,j);
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zpbcon, ZPBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
 		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in zpbtrs");
-			  err = -1;
-			  break;
-			}
-
-		      if (err != 0)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in zpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.0;
+
+		  if (err == 0)
+		    {
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+		      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+		      // Take a first guess that the number of non-zero terms
+		      // will be as many as in b
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      volatile octave_idx_type ii = 0;
+		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		      retval.xcidx(0) = 0;
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  new_nnz++;
+
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    Bx[i] = b (i,j);
+
+			  F77_XFCN (zpbtrs, ZPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bx, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in zpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0.)
+			      new_nnz++;
 			  
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
 			  
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = Bx[i];
-			  }
-
-		      retval.xcidx(j+1) = ii;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = Bx[i];
+			      }
+
+			  retval.xcidx(j+1) = ii;
+			}
+
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -4822,110 +5330,173 @@ SparseComplexMatrix::bsolve (SparseType 
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += std::abs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in xgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		}
 	      else 
 		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			Bx[i] = 0.;
-
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			Bx[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
+		      char job = '1';
+		      Array<Complex> z (2 * nr);
+		      Complex *pz = z.fortran_vec ();
+		      Array<double> iz (nr);
+		      double *piz = iz.fortran_vec ();
+
+		      F77_XFCN (zgbcon, ZGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
 		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in zgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      octave_idx_type b_nc = b.cols ();
+		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		      retval.xcidx(0) = 0;
+		      volatile octave_idx_type ii = 0;
+
+		      OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
+
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    Bx[i] = 0.;
+
+			  for (octave_idx_type i = b.cidx(j); 
+			       i < b.cidx(j+1); i++)
+			    Bx[b.ridx(i)] = b.data(i);
+
+			  F77_XFCN (zgbtrs, ZGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, Bx, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0.)
+			      new_nnz++;
+
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
+
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = Bx[i]; 
+			      }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = Bx[i]; 
-			  }
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
-SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
-				Matrix &Info,
-				solve_singularity_handler sing_handler) const
+SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond,
+				Matrix &Control, Matrix &Info,
+				solve_singularity_handler sing_handler,
+				bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
@@ -4980,17 +5551,20 @@ SparseComplexMatrix::factorize (octave_i
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
 				   X_CAST (const double *, Ax), NULL, 
 				   Symbolic, &Numeric, control, info) ;
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
-      rcond = Info (UMFPACK_RCOND);
+      if (calc_cond)
+	rcond = Info (UMFPACK_RCOND);
+      else
+	rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
 	  rcond_plus_one == 1.0 || xisnan (rcond))
 	{
 	  UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
 	  err = -2;
@@ -5024,19 +5598,20 @@ SparseComplexMatrix::factorize (octave_i
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const
+SparseComplexMatrix::fsolve (SparseType &mattype, const Matrix& b,
+			     octave_idx_type& err, double& rcond,
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5134,17 +5709,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    // We won't alter it, honest :-)
 	    B->x = const_cast<double *>(b.fortran_vec());
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5152,17 +5730,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5195,17 +5776,17 @@ SparseComplexMatrix::fsolve (SparseType 
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler);
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -5259,31 +5840,35 @@ SparseComplexMatrix::fsolve (SparseType 
 		      break;
 		    }
 		}
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, 
 			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler) const
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5392,17 +5977,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    B->x = &dummy;
 	  else
 	    B->x = b.data();
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5410,17 +5998,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5458,17 +6049,18 @@ SparseComplexMatrix::fsolve (SparseType 
 	  typ = SparseType::Full;
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
+	  void *Numeric = factorize (err, rcond, Control, Info, 
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -5482,17 +6074,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	      for (octave_idx_type i = 0; i < b_nr; i++)
 		Bz[i] = 0.;
 #else
 	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nzmax ();
+	      octave_idx_type x_nz = b.nnz ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -5552,31 +6144,35 @@ SparseComplexMatrix::fsolve (SparseType 
 		}
 
 	      retval.maybe_compress ();
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, 
 			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler) const
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5675,17 +6271,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	  else
 	    // We won't alter it, honest :-)
 	    B->x = const_cast<Complex *>(b.fortran_vec());
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5693,17 +6292,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5735,17 +6337,18 @@ SparseComplexMatrix::fsolve (SparseType 
 	  typ = SparseType::Full;
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
+	  void *Numeric = factorize (err, rcond, Control, Info,
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -5778,31 +6381,35 @@ SparseComplexMatrix::fsolve (SparseType 
 		      break;
 		    }
 		}
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b,
 			     octave_idx_type& err, double& rcond,
-			     solve_singularity_handler sing_handler) const
+			     solve_singularity_handler sing_handler,
+			     bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5911,17 +6518,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    B->x = &dummy;
 	  else
 	    B->x = b.data();
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5929,17 +6539,20 @@ SparseComplexMatrix::fsolve (SparseType 
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5977,34 +6590,35 @@ SparseComplexMatrix::fsolve (SparseType 
 	  typ = SparseType::Full;
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
-	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
+	  void *Numeric = factorize (err, rcond, Control, Info,
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
 	      const octave_idx_type *Ap = cidx ();
 	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nzmax ();
+	      octave_idx_type x_nz = b.nnz ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -6067,16 +6681,19 @@ SparseComplexMatrix::fsolve (SparseType 
 		       rcond);
 
 		}
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
@@ -6106,40 +6723,53 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			    double& rcond, 
 			    solve_singularity_handler sing_handler) const
 {
+  ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
+	Matrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
@@ -6160,40 +6790,53 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
+  SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
+	SparseMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
@@ -6214,40 +6857,53 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
+  ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
+	ComplexMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, 
 			    const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -6269,40 +6925,53 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
+  SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
+	SparseComplexMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
@@ -6538,155 +7207,23 @@ ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
 			    double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
-ComplexMatrix
-SparseComplexMatrix::lssolve (const Matrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info, 
-			      octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-ComplexMatrix
-SparseComplexMatrix::lssolve (const ComplexMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
-			      octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseComplexMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info, 
-			      octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ColumnVector& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
-{
-  Matrix tmp (b);
-  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ComplexColumnVector& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank) const
-{
-  ComplexMatrix tmp (b);
-  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
-}
-
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz1 = nzmax ();
+  octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
@@ -6750,17 +7287,17 @@ SparseComplexMatrix::ipermute (const Arr
 
 // other operations
 
 SparseComplexMatrix
 SparseComplexMatrix::map (c_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6800,17 +7337,17 @@ SparseComplexMatrix::map (c_c_Mapper f) 
   return retval;
 }
 
 SparseMatrix
 SparseComplexMatrix::map (d_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6850,17 +7387,17 @@ SparseComplexMatrix::map (d_c_Mapper f) 
   return retval;
 }
 
 SparseBoolMatrix
 SparseComplexMatrix::map (b_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6905,34 +7442,34 @@ SparseComplexMatrix::apply (c_c_Mapper f
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 SparseComplexMatrix::all_elements_are_real (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double ip = std::imag (data (i));
       
       if (ip != 0.0 || lo_ieee_signbit (ip))
 	return false;
     }
@@ -6942,17 +7479,17 @@ SparseComplexMatrix::all_elements_are_re
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL. 
 
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
   max_val = std::real(data (0));
   min_val = std::real(data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -6979,17 +7516,17 @@ SparseComplexMatrix::all_integers (doubl
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
 	Complex val = data (i);
 
 	double r_val = std::real (val);
 	double i_val = std::imag (val);
 
@@ -7057,17 +7594,17 @@ SparseComplexMatrix::sumsq (int dim) con
 			    COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   octave_idx_type nc = cols ();
 
   SparseMatrix retval (rows(), nc, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
@@ -7232,84 +7769,65 @@ operator >> (std::istream& is, SparseCom
  done:
 
   return is;
 }
 
 SparseComplexMatrix
 operator * (const SparseComplexMatrix& m, const SparseMatrix& a)
 {
-  SparseComplexMatrix tmp (a);
-  return m * tmp;
+  SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex, double);
 }
 
 SparseComplexMatrix
 operator * (const SparseMatrix& m, const SparseComplexMatrix& a)
 {
-  SparseComplexMatrix tmp (m);
-  return tmp * a;
+  SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex, Complex);
 }
 
 SparseComplexMatrix
 operator * (const SparseComplexMatrix& m, const SparseComplexMatrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ??
-#else
-  // Use Andy's sparse matrix multiply function
-  SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex);
-#endif
+  SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex, Complex);
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const SparseMatrix& a)
 {
-  SparseComplexMatrix tmp (a);
-  return m * tmp;
+  FULL_SPARSE_MUL (ComplexMatrix, double, Complex (0.,0.));
 }
 
 ComplexMatrix
 operator * (const Matrix& m, const SparseComplexMatrix& a)
 {
-  ComplexMatrix tmp (m);
-  return tmp * a;
+  FULL_SPARSE_MUL (ComplexMatrix, Complex, Complex (0.,0.));
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const SparseComplexMatrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ??
-#else
-  FULL_SPARSE_MUL (ComplexMatrix, Complex);
-#endif
+  FULL_SPARSE_MUL (ComplexMatrix, Complex, Complex (0.,0.));
 }
 
 ComplexMatrix
 operator * (const SparseComplexMatrix& m, const Matrix& a)
 {
-  ComplexMatrix tmp (a);
-  return m * tmp;
+  SPARSE_FULL_MUL (ComplexMatrix, double, Complex (0.,0.));
 }
 
 ComplexMatrix
 operator * (const SparseMatrix& m, const ComplexMatrix& a)
 {
-  SparseComplexMatrix tmp (m);
-  return tmp * a;
+  SPARSE_FULL_MUL (ComplexMatrix, Complex, Complex (0.,0.));
 }
 
 ComplexMatrix
 operator * (const SparseComplexMatrix& m, const ComplexMatrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ??
-#else
-  SPARSE_FULL_MUL (ComplexMatrix, Complex);
-#endif
+  SPARSE_FULL_MUL (ComplexMatrix, Complex, Complex (0.,0.));
 }
 
 // XXX FIXME XXX -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
@@ -7352,24 +7870,24 @@ min (const SparseComplexMatrix& a, const
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
-      if (a_nr == 0 || b_nc == 0 || a.nzmax () == 0 || b.nzmax () == 0)
+      if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -7474,26 +7992,26 @@ max (const SparseComplexMatrix& a, const
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
-      if (a.nzmax () == 0)
+      if (a.nnz () == 0)
 	return SparseComplexMatrix (b);
-      if (b.nzmax () == 0)
+      if (b.nnz () == 0)
 	return SparseComplexMatrix (a);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -141,100 +141,139 @@ public:
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond, 
 				int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   ComplexMatrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
-	        double& rcond, solve_singularity_handler sing_handler) const;
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler, 
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix dsolve (SparseType &typ, const SparseMatrix& b, 
+		octave_idx_type& info, double& rcond,
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler) const;
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix utsolve (SparseType &typ, const SparseMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
-	       double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix ltsolve (SparseType &typ, const Matrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix ltsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b, 
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  ComplexMatrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
-	       double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix trisolve (SparseType &typ, const Matrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix trisolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix trisolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   ComplexMatrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler) const;
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix bsolve (SparseType &typ, const SparseMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
-		    solve_singularity_handler sing_handler) const;
+  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
+		Matrix &Info, solve_singularity_handler sing_handler,
+		bool calc_cond) const;
 
   ComplexMatrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseComplexMatrix fsolve (SparseType &typ, const SparseMatrix& b, 
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (SparseType &typ, const Matrix& b) const;
   ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond) const;
   ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
@@ -323,46 +362,16 @@ public:
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix lssolve (const Matrix& b) const;
-  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
-  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
-
-  ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
-
-  SparseComplexMatrix lssolve (const SparseMatrix& b) const;
-  SparseComplexMatrix lssolve (const SparseMatrix& b, octave_idx_type& info) const;
-  SparseComplexMatrix lssolve (const SparseMatrix& b, octave_idx_type& info, 
-			       octave_idx_type& rank) const;
-
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, 
-			       octave_idx_type& info) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
-
-  ComplexColumnVector lssolve (const ColumnVector& b) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
-
-  ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
-
   SparseComplexMatrix squeeze (void) const;
 
   SparseComplexMatrix index (idx_vector& i, int resize_ok) const;
 
   SparseComplexMatrix index (idx_vector& i, idx_vector& j, int resize_ok) const;
   
   SparseComplexMatrix index (Array<idx_vector>& ra_idx, int resize_ok) const;
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,58 @@
+2006-03-16  David Bateman  <dbateman@free.fr>
+
+	* CSparse.cc: Change use of nzmax to nnz to allow automatic
+	reduction of matrix size, except for a couple of cases where nzmax
+	is needed.
+	(zpbcon): Correct declaration of lapack zpbcon function.
+	(dsolve, utsolve, ltsolve, trisolve, bsolve, factorize, fsolve): Add
+	an argument to allow the calculation of condition number to be
+	optional.
+	(bsolve): Add code for the calculation of the condition number
+	using zpbcon and zgbcon.
+	(dsolve): Bug fix for rectangular matrices with sparse RHS.
+	(utsolve, ltsolve, trisolve, bsolve, fsolve): Mark matrix type as
+	singular if singularity is detected.
+	(solve): Use optional argument to disable calculation of
+	condition number for all but fsolve, for speed. Add code to 
+	allow rectnagular matrices or matrices identified as singular
+	to be treated.
+	(lssolve): delete.
+	(operator *): Don't recast real matrices as complex, but
+	rather use the macro directly on the real data.
+	* dSparse.cc: ditto.
+	* CSparse.h (dsolve, utsolve, ltsolve, trisolve, bsolve,
+	fsolve, factorize): Update declaration for new argument to
+	calculate the condition number.
+	(lssolve): delete.
+	* dSparse.h: ditto.
+	* Msparse.h: Change use of nxmax to nnz to allow automatic
+	reduction of matrix size, except for a couple of cases where
+	nzmax is needed.
+	* Sparse.cc: Change use of nxmax to nnz to allow automatic
+	reduction of matrix size, except for a couple of cases where
+	nzmax is needed.
+	(Sparse<T>::index (idx_vector&, idx_vector&, int) const):
+	Special case strict permutations for speed.
+	* Sparse-op-defs.h: Change use of nxmax to nnz to allow automatic
+	reduction of matrix size, except for a couple of cases where
+	nzmax is needed.
+	(SPARSE_SPARSE_MUL, SPARSE_FULL_MUL, FULL_SPARSE_MUL): Update
+	macros to allow mixed complex/real arguments.
+	* SparseCmplxQR.cc (OCTAVE_C99_ZERO): New macro for C99 zero
+        value.
+	(qrsolve): Use it to zero temporary buffers used bt CXSPARSE.
+	* SparseType.cc (SparseType::SparseType ()): Correct detection
+	of permutated triangular matrices to avoid seg-faults. Disable
+	detection of underdetermined lower and over-determined upper
+	matrix due to problems with non minimum norm solutions.
+	* sparse-dmsolve.cc: New file for Dulmage-Mendelsohn solver.
+	* Makefile.in: add sparse-dmsolve.cc to targets.
+
 2006-03-15  William Poetra Yoga Hadisoeseno  <williampoetra@gmail.com>
 
 	* oct-time.cc (octave_strptime::init): Return useful character count.
 
 2006-03-08  David Bateman  <dbateman@free.fr>
 
 	* SparseCmplxQR.cc: Updates for new upstream CXSPARSE release. Fix for
 	g++ 4.x stl_vector.h issue with C99 double _Complex type.
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -47,17 +47,17 @@ operator += (MSparse<T>& a, const MSpars
 
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator +=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
-        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
@@ -120,17 +120,17 @@ operator -= (MSparse<T>& a, const MSpars
 
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator -=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
-        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
@@ -202,17 +202,17 @@ operator -= (MSparse<T>& a, const MSpars
 
 #define SPARSE_A2S_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
-    octave_idx_type nz = a.nzmax (); \
+    octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = a.data(i) OP s; \
 	r.ridx(i) = a.ridx(i); \
       } \
@@ -248,17 +248,17 @@ SPARSE_A2S_OP_2 (/)
 
 #define SPARSE_SA2_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
-    octave_idx_type nz = a.nzmax (); \
+    octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP a.data(i); \
 	r.ridx(i) = a.ridx(i); \
       } \
@@ -287,17 +287,17 @@ SPARSE_SA2_OP_2 (/)
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
-        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ())); \
+        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -362,17 +362,17 @@ SPARSE_SA2_OP_2 (/)
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
-        r = MSparse<T> (a_nr, a_nc, (a.nzmax () > b.nzmax () ? a.nzmax () : b.nzmax ())); \
+        r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -489,17 +489,17 @@ operator + (const MSparse<T>& a)
   return a;
 }
 
 template <class T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
-  octave_idx_type nz = a.nzmax ();
+  octave_idx_type nz = a.nnz ();
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = - retval.data(i);
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -32,18 +32,19 @@ MATRIX_INC := Array.h Array2.h Array3.h 
 	CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxDET.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
 	CmplxSCHUR.h CmplxSVD.h EIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h dbleDET.h \
 	dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h dbleSVD.h \
 	boolSparse.h CSparse.h dSparse.h MSparse-defs.h MSparse.h \
 	Sparse.h sparse-base-lu.h SparseCmplxLU.h SparsedbleLU.h \
-	sparse-base-chol.h SparseCmplxCHOL.h SparsedbleCHOL.h \
-	SparseCmplxQR.h SparseQR.h Sparse-op-defs.h SparseType.h \
+	sparse-base-chol.h sparse-dmsolve.cc SparseCmplxCHOL.h \
+	SparsedbleCHOL.h SparseCmplxQR.h SparseQR.h Sparse-op-defs.h \
+	SparseType.h \
 	int8NDArray.h uint8NDArray.h int16NDArray.h uint16NDArray.h \
 	int32NDArray.h uint32NDArray.h int64NDArray.h uint64NDArray.h \
 	intNDArray.h
 
 MX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=mx list_h_files=1 $(srcdir)/mx-ops)
 
 VX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=vx list_h_files=1 $(srcdir)/vx-ops)
 
@@ -74,17 +75,18 @@ INCLUDES := Bounds.h CollocWt.h DAE.h DA
 	$(OPTS_INC) \
 	$(MATRIX_INC) \
 	$(MX_OP_INC) \
 	$(VX_OP_INC) \
 	$(SPARSE_MX_OP_INC)
 
 TEMPLATE_SRC := Array.cc ArrayN.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MArrayN.cc MDiagArray2.cc \
-	base-lu.cc oct-sort.cc sparse-base-lu.cc sparse-base-chol.cc
+	base-lu.cc oct-sort.cc sparse-base-lu.cc sparse-base-chol.cc \
+	sparse-dmsolve.cc
 
 TI_SRC := Array-C.cc Array-b.cc Array-ch.cc Array-i.cc Array-d.cc \
 	Array-s.cc Array-so.cc Array-str.cc Array-idx-vec.cc \
 	MArray-C.cc MArray-ch.cc MArray-i.cc MArray-d.cc MArray-s.cc \
 	MSparse-C.cc MSparse-d.cc Sparse-C.cc Sparse-b.cc Sparse-d.cc \
 	oct-inttypes.cc
 
 MATRIX_SRC := Array-flags.cc Array-util.cc CColVector.cc \
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -58,17 +58,17 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SMS_BIN_OP_2(R, F, OP, M, S)	\
   R \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = m.data(i) OP s; \
 	r.ridx(i) = m.ridx(i); \
       } \
@@ -98,17 +98,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S);
 
 #define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
     if (MC (MZ) OP SC (s))   \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if (MC (m.data (i)) OP SC (s)) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -173,17 +173,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_BOOL_OP_DECL (mx_el_or,  M, S);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
     if (LHS_ZERO OP (s != RHS_ZERO)) \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))\
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -268,17 +268,17 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SSM_BIN_OP_2(R, F, OP, S, M) \
   R \
   F (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP m.data(i); \
 	r.ridx(i) = m.ridx(i); \
       } \
@@ -308,17 +308,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M);
 
 #define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
     if (SC (s) OP MC (MZ))   \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if (SC (s) OP MC (m.data (i))) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -383,17 +383,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_BOOL_OP_DECL (mx_el_or,  S, M); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nzmax (); \
+    octave_idx_type nz = m.nnz (); \
     if ((s != LHS_ZERO) OP  RHS_ZERO) \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if ((s != LHS_ZERO) OP m.data(i) != RHS_ZERO) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -472,17 +472,17 @@ Boston, MA 02110-1301, USA.
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-	r = R (m1_nr, m1_nc, (m1.nzmax () + m2.nzmax ())); \
+	r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -546,17 +546,17 @@ Boston, MA 02110-1301, USA.
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-        r = R (m1_nr, m1_nc, (m1.nzmax () > m2.nzmax () ? m1.nzmax () : m2.nzmax ())); \
+        r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -1528,17 +1528,17 @@ Boston, MA 02110-1301, USA.
 			SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
 			SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
 			INIT_VAL, INIT_VAL)
 
 #define SPARSE_ALL_OP(DIM) SPARSE_ANY_ALL_OP (DIM, true, ==, false)
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, !=, true)
 
-#define SPARSE_SPARSE_MUL( RET_TYPE, EL_TYPE ) \
+#define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nc != a_nr) \
     { \
@@ -1572,17 +1572,17 @@ Boston, MA 02110-1301, USA.
       \
       if (nel == 0) \
 	return RET_TYPE (nr, a_nc); \
       else \
 	{  \
           for (octave_idx_type i = 0; i < nr; i++) \
 	    w[i] = 0; \
 	  \
-          OCTAVE_LOCAL_BUFFER (EL_TYPE, Xcol, nr); \
+          OCTAVE_LOCAL_BUFFER (RET_EL_TYPE, Xcol, nr); \
           \
 	  RET_TYPE retval (nr, a_nc, nel); \
 	  octave_idx_type ii = 0; \
 	  /* The optimal break-point as estimated from simulations */ \
 	  /* Note that Mergesort is O(nz log(nz)) while searching all */ \
 	  /* values is O(nr), where nz here is non-zero per row of */ \
 	  /* length nr. The test itself was then derived from the */ \
 	  /* simulation with random square matrices and the observation */ \
@@ -1658,61 +1658,61 @@ Boston, MA 02110-1301, USA.
 		  retval.xcidx(i+1) = ii; \
 		}  \
 	      retval.maybe_compress ();\
 	    } \
 	  return retval; \
 	} \
     }
 
-#define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE ) \
+#define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
-      RET_TYPE retval (nr, a_nc, EL_TYPE ()); \
+      RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
 	{ \
 	  for (octave_idx_type j = 0; j < a_nr; j++) \
 	    { \
               OCTAVE_QUIT; \
 	      \
               EL_TYPE tmpval = a.elem(j,i); \
 	      for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
 	        retval.elem (m.ridx(k),i) += tmpval * m.data(k); \
 	    } \
         } \
       return retval; \
     }
 
-#define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE ) \
+#define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
-      RET_TYPE retval (nr, a_nc, EL_TYPE ()); \
+      RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
 	{ \
 	   for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
 	     { \
 	        octave_idx_type col = a.ridx(j); \
 	        EL_TYPE tmpval = a.data(j); \
                 OCTAVE_QUIT; \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -197,23 +197,23 @@ Sparse<T>::SparseRep::change_length (oct
     }
 }
 
 template <class T>
 template <class U>
 Sparse<T>::Sparse (const Sparse<U>& a)
   : dimensions (a.dimensions), idx (0), idx_count (0)
 {
-  if (a.nzmax () == 0)
+  if (a.nnz () == 0)
     rep = new typename Sparse<T>::SparseRep (rows (), cols());
   else
     {
-      rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nzmax ());
+      rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nnz ());
       
-      octave_idx_type nz = nzmax ();
+      octave_idx_type nz = a.nnz ();
       octave_idx_type nc = cols ();
       for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  xdata (i) = T (a.data (i));
 	  xridx (i) = a.ridx (i);
 	}
       for (octave_idx_type i = 0; i < nc + 1; i++)
 	xcidx (i) = a.cidx (i);
@@ -271,17 +271,17 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
     static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
       dim_vector old_dims = a.dims();
-      octave_idx_type new_nzmx = a.nzmax ();
+      octave_idx_type new_nzmx = a.nnz ();
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
@@ -735,39 +735,39 @@ Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
 
   if (dimensions != new_dims)
     {
       if (dimensions.numel () == new_dims.numel ())
 	{
-	  octave_idx_type new_nzmx = nzmax ();
+	  octave_idx_type new_nnz = nnz ();
 	  octave_idx_type new_nr = new_dims (0);
 	  octave_idx_type new_nc = new_dims (1);
 	  octave_idx_type old_nr = rows ();
 	  octave_idx_type old_nc = cols ();
-	  retval = Sparse<T> (new_nr, new_nc, new_nzmx);
+	  retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
 	  octave_idx_type kk = 0;
 	  retval.xcidx(0) = 0;
 	  for (octave_idx_type i = 0; i < old_nc; i++)
 	    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	      {
 		octave_idx_type tmp = i * old_nr + ridx(j);
 		octave_idx_type ii = tmp % new_nr;
 		octave_idx_type jj = (tmp - ii) / new_nr; 
 		for (octave_idx_type k = kk; k < jj; k++)
 		  retval.xcidx(k+1) = j;
 		kk = jj;
 		retval.xdata(j) = data(j);
 		retval.xridx(j) = ii;
 	      }
 	  for (octave_idx_type k = kk; k < new_nc; k++)
-	    retval.xcidx(k+1) = new_nzmx;
+	    retval.xcidx(k+1) = new_nnz;
 	}
       else
 	(*current_liboctave_error_handler) ("reshape: size mismatch");
     }
   else
     retval = *this;
 
   return retval;
@@ -850,17 +850,17 @@ Sparse<T>::resize_no_fill (octave_idx_ty
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   typename Sparse<T>::SparseRep *old_rep = Sparse<T>::rep;
   octave_idx_type nc = cols ();
   octave_idx_type nr = rows ();
 
-  if (nzmax () == 0 || r == 0 || c == 0)
+  if (nnz () == 0 || r == 0 || c == 0)
     // Special case of redimensioning to/from a sparse matrix with 
     // no elements
     rep = new typename Sparse<T>::SparseRep (r, c);
   else
     {
       octave_idx_type n = 0;
       Sparse<T> tmpval;
       if (r >= nr)
@@ -939,17 +939,17 @@ Sparse<T>::insert (const Sparse<T>& a, o
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   // First count the number of elements in the final array
-  octave_idx_type nel = cidx(c) + a.nzmax ();
+  octave_idx_type nel = cidx(c) + a.nnz ();
 
   if (c + a_cols < nc)
     nel += cidx(nc) - cidx(c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
       if (ridx(j) < r || ridx(j) >= r + a_rows)
 	nel++;
@@ -1137,47 +1137,47 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
   idx_arg.sort (true);
 
   octave_idx_type num_to_delete = idx_arg.length (n);
 
   if (num_to_delete != 0)
     {
       octave_idx_type new_n = n;
-      octave_idx_type new_nzmx = nzmax ();
+      octave_idx_type new_nnz = nnz ();
 
       octave_idx_type iidx = 0;
 
       const Sparse<T> tmp (*this);
 
       for (octave_idx_type i = 0; i < n; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  if (i == idx_arg.elem (iidx))
 	    {
 	      iidx++;
 	      new_n--;
 
 	      if (tmp.elem (i) != T ())
-		new_nzmx--;
+		new_nnz--;
 
 	      if (iidx == num_to_delete)
 		break;
 	    }
 	}
 
       if (new_n > 0)
 	{
 	  rep->count--;
 
 	  if (nr == 1)
-	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nzmx);
+	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nnz);
 	  else
-	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nzmx);
+	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  iidx = 0;
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
@@ -1210,17 +1210,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		}
 
 	      dimensions(0) = 1;
 	      dimensions(1) = new_n;
 	    }
 	  else
 	    {
 	      cidx(0) = 0;
-	      cidx(1) = new_nzmx;
+	      cidx(1) = new_nnz;
 	      dimensions(0) = new_n;
 	      dimensions(1) = 1;
 	    }
 	}
       else
 	(*current_liboctave_error_handler)
 	  ("A(idx) = []: index out of range");
     }
@@ -1282,42 +1282,42 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nr == 1 && num_to_delete == nc)
 		resize_no_fill (0, 0);
 	      else
 		{
 		  octave_idx_type new_nc = nc;
-		  octave_idx_type new_nzmx = nzmax ();
+		  octave_idx_type new_nnz = nnz ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (j == idx_j.elem (iidx))
 			{
 			  iidx++;
 			  new_nc--;
 			  
-			  new_nzmx -= cidx(j+1) - cidx(j);
+			  new_nnz -= cidx(j+1) - cidx(j);
 
 			  if (iidx == num_to_delete)
 			    break;
 			}
 		    }
 
 		  if (new_nc > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
-							       new_nzmx);
+							       new_nnz);
 		      octave_idx_type ii = 0;
 		      octave_idx_type jj = 0;
 		      iidx = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < nc; j++)
 			{
 			  OCTAVE_QUIT;
 
@@ -1357,44 +1357,44 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nc == 1 && num_to_delete == nr)
 		resize_no_fill (0, 0);
 	      else
 		{
 		  octave_idx_type new_nr = nr;
-		  octave_idx_type new_nzmx = nzmax ();
+		  octave_idx_type new_nnz = nnz ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (i == idx_i.elem (iidx))
 			{
 			  iidx++;
 			  new_nr--;
 			  
-			  for (octave_idx_type j = 0; j < nzmax (); j++)
+			  for (octave_idx_type j = 0; j < nnz (); j++)
 			    if (ridx(j) == i)
-			      new_nzmx--;
+			      new_nnz--;
 
 			  if (iidx == num_to_delete)
 			    break;
 			}
 		    }
 
 		  if (new_nr > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (new_nr, nc, 
-							       new_nzmx);
+							       new_nnz);
 
 		      octave_idx_type jj = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type i = 0; i < nc; i++)
 			{
 			  iidx = 0;
 			  for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 			    {
@@ -1478,17 +1478,17 @@ Sparse<T>
 Sparse<T>::index (idx_vector& idx_arg, int resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
 
   octave_idx_type orig_len = nr * nc;
 
   dim_vector idx_orig_dims = idx_arg.orig_dimensions ();
 
   octave_idx_type idx_orig_rows = idx_arg.orig_rows ();
   octave_idx_type idx_orig_columns = idx_arg.orig_columns ();
 
@@ -1833,76 +1833,161 @@ Sparse<T>::index (idx_vector& idx_i, idx
   octave_idx_type m = idx_j.freeze (nc, "column", resize_ok);
 
   if (idx_i && idx_j)
     {
       if (idx_i.orig_empty () || idx_j.orig_empty () || n == 0 || m == 0)
 	{
 	  retval.resize_no_fill (n, m);
 	}
-      else if (idx_i.is_colon_equiv (nr) && idx_j.is_colon_equiv (nc))
-	{
-	  retval = *this;
-	}
-      else
+      else 
 	{
-	  // First count the number of non-zero elements
-	  octave_idx_type new_nzmx = 0;
-	  for (octave_idx_type j = 0; j < m; j++)
+	  int idx_i_colon = idx_i.is_colon_equiv (nr);
+	  int idx_j_colon = idx_j.is_colon_equiv (nc);
+
+	  if (idx_i_colon && idx_j_colon)
+	    {
+	      retval = *this;
+	    }
+	  else
 	    {
-	      octave_idx_type jj = idx_j.elem (j);
-	      for (octave_idx_type i = 0; i < n; i++)
+	      // Identify if the indices have any repeated values
+	      bool permutation = true;
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, itmp, 
+				   (nr > nc ? nr : nc));
+	      octave_sort<octave_idx_type> sort;
+
+	      if (n > nr || m > nc)
+		permutation = false;
+
+	      if (permutation && ! idx_i_colon)
+		{
+		  // Can't use something like
+		  //   idx_vector tmp_idx = idx_i;
+		  //   tmp_idx.sort (true);
+		  //   if (tmp_idx.length(nr) != n)
+		  //       permutation = false;
+		  // here as there is no make_unique function 
+		  // for idx_vector type.
+		  for (octave_idx_type i = 0; i < n; i++)
+		    itmp [i] = idx_i.elem (i);
+		  sort.sort (itmp, n);
+		  for (octave_idx_type i = 1; i < n; i++)
+		    if (itmp[i-1] == itmp[i])
+		      {
+			permutation = false;
+			break;
+		      }
+		}
+	      if (permutation && ! idx_j_colon)
+		{
+		  for (octave_idx_type i = 0; i < m; i++)
+		    itmp [i] = idx_j.elem (i);
+		  sort.sort (itmp, m);
+		  for (octave_idx_type i = 1; i < m; i++)
+		    if (itmp[i-1] == itmp[i])
+		      {
+			permutation = false;
+			break;
+		      }
+		}
+
+	      if (permutation)
 		{
-		  OCTAVE_QUIT;
-
-		  octave_idx_type ii = idx_i.elem (i);
-		  if (ii < nr && jj < nc)
+		  // Special case permutation like indexing for speed
+		  retval = Sparse<T> (n, m, nnz ());
+		  octave_idx_type *ri = retval.xridx ();
+	      
+		  // Can't use OCTAVE_LOCAL_BUFFER with bool, and so 
+		  // can't with T either
+		  T X [n];
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    itmp [i] = -1;
+		  for (octave_idx_type i = 0; i < n; i++)
+		    itmp[idx_i.elem(i)] = i;
+
+		  octave_idx_type kk = 0;
+		  retval.xcidx(0) = 0;
+		  for (octave_idx_type j = 0; j < m; j++)
+		    {
+		      octave_idx_type jj = idx_j.elem (j);
+		      for (octave_idx_type i = cidx(jj); i < cidx(jj+1); i++)
+			{
+			  octave_idx_type ii = itmp [ridx(i)];
+			  if (ii >= 0)
+			    {
+			      X [ii] = data (i);
+			      retval.xridx (kk++) = ii;
+			    }
+			}
+		      sort.sort (ri + retval.xcidx (j), kk - retval.xcidx (j));
+		      for (octave_idx_type p = retval.xcidx (j); p < kk; p++)
+			retval.xdata (p) = X [retval.xridx (p)]; 
+		      retval.xcidx(j+1) = kk;
+		    }
+		  retval.maybe_compress ();
+		}
+	      else
+		{
+		  // First count the number of non-zero elements
+		  octave_idx_type new_nzmx = 0;
+		  for (octave_idx_type j = 0; j < m; j++)
 		    {
-		      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
+		      octave_idx_type jj = idx_j.elem (j);
+		      for (octave_idx_type i = 0; i < n; i++)
 			{
-			  if (ridx(k) == ii)
-			    new_nzmx++;
-			  if (ridx(k) >= ii)
-			    break;
+			  OCTAVE_QUIT;
+
+			  octave_idx_type ii = idx_i.elem (i);
+			  if (ii < nr && jj < nc)
+			    {
+			      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
+				{
+				  if (ridx(k) == ii)
+				    new_nzmx++;
+				  if (ridx(k) >= ii)
+				    break;
+				}
+			    }
 			}
 		    }
+
+		  retval = Sparse<T> (n, m, new_nzmx);
+
+		  octave_idx_type kk = 0;
+		  retval.xcidx(0) = 0;
+		  for (octave_idx_type j = 0; j < m; j++)
+		    {
+		      octave_idx_type jj = idx_j.elem (j);
+		      for (octave_idx_type i = 0; i < n; i++)
+			{
+			  OCTAVE_QUIT;
+
+			  octave_idx_type ii = idx_i.elem (i);
+			  if (ii < nr && jj < nc)
+			    {
+			      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
+				{
+				  if (ridx(k) == ii)
+				    {
+				      retval.xdata(kk) = data(k);
+				      retval.xridx(kk++) = i;
+				    }
+				  if (ridx(k) >= ii)
+				    break;
+				}
+			    }
+			}
+		      retval.xcidx(j+1) = kk;
+		    }
 		}
 	    }
-
-	  retval = Sparse<T> (n, m, new_nzmx);
-
-	  octave_idx_type kk = 0;
-	  retval.xcidx(0) = 0;
-	  for (octave_idx_type j = 0; j < m; j++)
-	    {
-	      octave_idx_type jj = idx_j.elem (j);
-	      for (octave_idx_type i = 0; i < n; i++)
-		{
-		  OCTAVE_QUIT;
-
-		  octave_idx_type ii = idx_i.elem (i);
-		  if (ii < nr && jj < nc)
-		    {
-		      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
-			{
-			  if (ridx(k) == ii)
-			    {
-			      retval.xdata(kk) = data(k);
-			      retval.xridx(kk++) = i;
-			    }
-			  if (ridx(k) >= ii)
-			    break;
-			}
-		    }
-		}
-	      retval.xcidx(j+1) = kk;
-	    }
 	}
     }
-
   // idx_vector::freeze() printed an error message for us.
 
   return retval;
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::index (Array<idx_vector>& ra_idx, int resize_ok) const
@@ -1950,33 +2035,33 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	 "in the future.");
 
       lhs.clear_index ();
       return 0;
     }
 
   octave_idx_type nr = lhs.rows ();
   octave_idx_type nc = lhs.cols ();
-  octave_idx_type nz = lhs.nzmax ();
+  octave_idx_type nz = lhs.nnz ();
 
   octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, 
 				      liboctave_wrore_flag);
 
   if (n != 0)
     {
       octave_idx_type max_idx = lhs_idx.max () + 1;
       max_idx = max_idx < lhs_len ? lhs_len : max_idx;
 
       // Take a constant copy of lhs. This means that elem won't 
       // create missing elements.
       const Sparse<LT> c_lhs (lhs);
 
       if (rhs_len == n)
 	{
-	  octave_idx_type new_nzmx = lhs.nzmax ();
+	  octave_idx_type new_nzmx = lhs.nnz ();
 
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, n);
 	  if (! lhs_idx.is_colon ())
 	    {
 	      // Ok here we have to be careful with the indexing,
 	      // to treat cases like "a([3,2,1]) = b", and still 
 	      // handle the need for strict sorting of the sparse 
 	      // elements.
@@ -2021,17 +2106,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	      if (rhs.elem(rhs_idx[i]) != RT ())
 		new_nzmx++;
 	    }
 
 	  if (nr > 1)
 	    {
 	      Sparse<LT> tmp (max_idx, 1, new_nzmx);
 	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = tmp.nzmax ();
+	      tmp.cidx(1) = new_nzmx;
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2119,17 +2204,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
 		tmp.xcidx(iidx) = kk;
 
 	      lhs = tmp;
 	    }
 	}
       else if (rhs_len == 1)
 	{
-	  octave_idx_type new_nzmx = lhs.nzmax ();
+	  octave_idx_type new_nzmx = lhs.nnz ();
 	  RT scalar = rhs.elem (0);
 	  bool scalar_non_zero = (scalar != RT ());
 	  lhs_idx.sort (true);
 
 	  // First count the number of non-zero elements
 	  if (scalar != RT ())
 	    new_nzmx += n;
 	  for (octave_idx_type i = 0; i < n; i++)
@@ -2140,17 +2225,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 		new_nzmx--;
 	    }
 
 	  if (nr > 1)
 	    {
 	      Sparse<LT> tmp (max_idx, 1, new_nzmx);
 	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = tmp.nzmax ();
+	      tmp.cidx(1) = new_nzmx;
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2243,17 +2328,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	  retval = 0;
 	}
     }
   else if (lhs_idx.is_colon ())
     {
       if (lhs_len == 0)
 	{
 
-	  octave_idx_type new_nzmx = rhs.nzmax ();
+	  octave_idx_type new_nzmx = rhs.nnz ();
 	  Sparse<LT> tmp (1, rhs_len, new_nzmx);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  for (octave_idx_type i = 0; i < rhs.cols(); i++)
 	    for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
 	      {
 		OCTAVE_QUIT;
@@ -2291,17 +2376,17 @@ int
 assign (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
 
   int n_idx = lhs.index_count ();
 
   octave_idx_type lhs_nr = lhs.rows ();
   octave_idx_type lhs_nc = lhs.cols ();
-  octave_idx_type lhs_nz = lhs.nzmax ();
+  octave_idx_type lhs_nz = lhs.nnz ();
 
   octave_idx_type rhs_nr = rhs.rows ();
   octave_idx_type rhs_nc = rhs.cols ();
 
   idx_vector *tmp = lhs.get_idx ();
 
   idx_vector idx_i;
   idx_vector idx_j;
@@ -2359,17 +2444,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			idx_j.max () + 1;
 		      octave_idx_type new_nr = max_row_idx > lhs_nr ? 
 			max_row_idx : lhs_nr;
 		      octave_idx_type new_nc = max_col_idx > lhs_nc ? 
 			max_col_idx : lhs_nc;
 		      RT scalar = rhs.elem (0, 0);
 
 		      // Count the number of non-zero terms
-		      octave_idx_type new_nzmx = lhs.nzmax ();
+		      octave_idx_type new_nzmx = lhs.nnz ();
 		      for (octave_idx_type j = 0; j < m; j++)
 			{
 			  octave_idx_type jj = idx_j.elem (j);
 			  if (jj < lhs_nc)
 			    {
 			      for (octave_idx_type i = 0; i < n; i++)
 				{
 				  OCTAVE_QUIT;
@@ -2540,17 +2625,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
 			  idx_j = idx_vector (new_idx);
 			}
 		      else
 			for (octave_idx_type i = 0; i < m; i++)
 			  rhs_idx_j[i] = i;
 
 		      // Count the number of non-zero terms
-		      octave_idx_type new_nzmx = lhs.nzmax ();
+		      octave_idx_type new_nzmx = lhs.nnz ();
 		      for (octave_idx_type j = 0; j < m; j++)
 			{
 			  octave_idx_type jj = idx_j.elem (j);
 			  for (octave_idx_type i = 0; i < n; i++)
 			    {
 			      OCTAVE_QUIT;
 
 			      if (jj < lhs_nc)
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -29,16 +29,18 @@ Boston, MA 02110-1301, USA.
 
 // Why did g++ 4.x stl_vector.h make
 //   OCTAVE_LOCAL_BUFFER (double _Complex, buf, n)
 // an error ?
 #define OCTAVE_C99_COMPLEX(buf, n) \
   OCTAVE_LOCAL_BUFFER (double, buf ## tmp, (2 * (n))); \
   double _Complex *buf = reinterpret_cast<double _Complex *> (buf ## tmp);
 
+#define OCTAVE_C99_ZERO (0. + 0.iF);
+
 SparseComplexQR::SparseComplexQR_rep::SparseComplexQR_rep 
 (const SparseComplexMatrix& a, int order)
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME () A;
   A.nzmax = a.nnz ();
   A.m = a.rows ();
   A.n = a.cols ();
@@ -228,16 +230,18 @@ qrsolve(const SparseComplexMatrix&a, con
 	(x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -257,26 +261,29 @@ qrsolve(const SparseComplexMatrix&a, con
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
@@ -327,16 +334,18 @@ qrsolve(const SparseComplexMatrix&a, con
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -377,26 +386,29 @@ qrsolve(const SparseComplexMatrix&a, con
 	{
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
@@ -465,16 +477,18 @@ qrsolve(const SparseComplexMatrix&a, con
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
@@ -493,24 +507,27 @@ qrsolve(const SparseComplexMatrix&a, con
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       double _Complex *vec = reinterpret_cast<double _Complex *>
 	(x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -559,16 +576,18 @@ qrsolve(const SparseComplexMatrix&a, con
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_ipvec) 
 	    (nr, q.S()->Pinv, reinterpret_cast<double _Complex *>(Xx), buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -609,26 +628,29 @@ qrsolve(const SparseComplexMatrix&a, con
 	{
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = OCTAVE_C99_ZERO;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_ZNAME (_pvec)
 	    (nr, q.S()->Q, reinterpret_cast<double _Complex *>(Xx), buf);
 	  CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
@@ -670,9 +692,8 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
-
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -165,16 +165,18 @@ SparseQR::SparseQR_rep::C (const Matrix 
   if (nr < 1 || nc < 1 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
 	{
 	  OCTAVE_QUIT;
+	  for (octave_idx_type i = nr; i < S->m2; i++)
+	    buf[i] = 0.;
 	  volatile octave_idx_type nm = (nr < nc ? nr : nc);
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  for (volatile octave_idx_type i = 0; i < nm; i++)
 	    {
 	      OCTAVE_QUIT;
@@ -217,16 +219,18 @@ qrsolve(const SparseMatrix&a, const Matr
 	}
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
@@ -244,21 +248,24 @@ qrsolve(const SparseMatrix&a, const Matr
       SparseQR q (at, 2);
       if (! q.ok ())
 	{
 	  info = -1;
 	  return Matrix();
 	}
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
-      OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
 	   i++, idx+=nc, bidx+=b_nr)
 	{
 	  OCTAVE_QUIT;
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -306,16 +313,18 @@ qrsolve(const SparseMatrix&a, const Spar
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
@@ -354,23 +363,26 @@ qrsolve(const SparseMatrix&a, const Spar
 	{
 	  info = -1;
 	  return SparseMatrix();
 	}
       x = SparseMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    Xx[j] = b.xelem(j,i);
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -440,30 +452,34 @@ qrsolve(const SparseMatrix&a, const Comp
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
 
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -482,41 +498,48 @@ qrsolve(const SparseMatrix&a, const Comp
       SparseQR q (at, 2);
       if (! q.ok ())
 	{
 	  info = -1;
 	  return ComplexMatrix();
 	}
       x.resize(nc, b_nc);
       Complex *vec = x.fortran_vec();
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
+	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
@@ -570,29 +593,35 @@ qrsolve(const SparseMatrix&a, const Spar
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
 	  CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+	  for (octave_idx_type j = nr; j < q.S()->m2; j++)
+	    buf[j] = 0.;
+	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -630,41 +659,48 @@ qrsolve(const SparseMatrix&a, const Spar
 	{
 	  info = -1;
 	  return SparseComplexMatrix();
 	}
       x = SparseComplexMatrix (nc, b_nc, b.nzmax());
       x.xcidx(0) = 0;
       x_nz = b.nzmax();
       ii = 0;
+      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, nc > q.S()->m2 ? nc : q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
 	{
 	  OCTAVE_QUIT;
 	  for (octave_idx_type j = 0; j < b_nr; j++)
 	    {
 	      Complex c = b.xelem (j,i);
 	      Xx[j] = std::real (c);
 	      Xz[j] = std::imag (c);
 	    }
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
 	      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	    }
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+	  for (octave_idx_type j = nr; j < nbuf; j++)
+	    buf[j] = 0.;
+	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
 	  CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  for (volatile octave_idx_type j = nr-1; j >= 0; j--)
 	    {
 	      OCTAVE_QUIT;
 	      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	      CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -187,85 +187,129 @@ SparseType::SparseType (const SparseMatr
 	  // Search for a permuted triangular matrix, and test if
 	  // permutation is singular
 
 	  // XXX FIXME XXX
 	  // Perhaps this should be based on a dmperm algorithm
 	  bool found = false;
 
 	  nperm = ncols;
-	  perm = new octave_idx_type [nperm];
+	  perm = new octave_idx_type [ncols];
+
+	  for (octave_idx_type i = 0; i < ncols; i++)
+	    perm [i] = -1;
 
 	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      found = false;
 
 	      for (octave_idx_type j = 0; j < ncols; j++)
 		{
-
 		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      a.ridx(a.cidx(j+1)-1) == i)
+		      (a.ridx(a.cidx(j+1)-1) == i))
 		    {
 		      perm [i] = j;
 		      found = true;
 		      break;
 		    }
 		}
 
 	      if (!found)
 		break;
 	    }
 
 	  if (found)
-	    typ = SparseType::Permuted_Upper;
-	  else
 	    {
-	      delete [] perm;
+	      typ = SparseType::Permuted_Upper;
+	      if (ncols > nrows)
+		{
+		  octave_idx_type k = nrows;
+		  for (octave_idx_type i = 0; i < ncols; i++)
+		    if (perm [i] == -1)
+		      perm[i] = k++;
+		}
+	    }
+	  else if (a.cidx(nm) == a.cidx(ncols))
+	    {
 	      nperm = nrows;
-	      perm = new octave_idx_type [nperm];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
+	      delete [] perm;
+	      perm = new octave_idx_type [nrows];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
-	      for (octave_idx_type i = 0; i < nperm; i++)
+	      for (octave_idx_type i = 0; i < nrows; i++)
 		{
 		  perm [i] = -1;
 		  tmp [i] = -1;
 		}
 
 	      for (octave_idx_type j = 0; j < ncols; j++)
 		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		  perm [a.ridx(i)] = j;
-  
+		    perm [a.ridx(i)] = j;
+
 	      found = true;
-	      for (octave_idx_type i = 0; i < nperm; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		if (perm[i] == -1)
 		  {
 		    found = false;
 		    break;
 		  }
 		else
 		  {
 		    tmp[perm[i]] = 1;
 		  }
 
 	      if (found)
-		for (octave_idx_type i = 0; i < nm; i++)
-		  if (tmp[i] == -1)
+		{
+		  octave_idx_type k = ncols;
+		  for (octave_idx_type i = 0; i < nrows; i++)
 		    {
-		      found = false;
-		      break;
+		      if (tmp[i] == -1)
+			{
+			  if (k < nrows)
+			    {
+			      perm[k++] = i;
+			    }
+			  else
+			    {
+			      found = false;
+			      break;
+			    }
+			}
 		    }
+		}
 
 	      if (found)
 		typ = SparseType::Permuted_Lower;
 	      else
 		{
 		  delete [] perm;
 		  nperm = 0;
 		}
 	    }
+	  else
+	    {
+	      delete [] perm;
+	      nperm = 0;
+	    }
+	}
+
+      // XXX FIXME XXX
+      // Disable lower under-determined and upper over-determined problems
+      // as being detected, and force to treat as singular. As this seems
+      // to cause issues
+      if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+	   && nrows > ncols) ||
+	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+	   && nrows < ncols))
+	{
+	  typ = SparseType::Rectangular;
+	  if (typ == SparseType::Permuted_Upper ||
+	      typ == SparseType::Permuted_Lower)
+	    delete [] perm;
+	  nperm = 0;
 	}
 
       if (typ == SparseType::Full && ncols != nrows)
 	typ = SparseType::Rectangular;
 
       if (maybe_hermitian && (typ == SparseType::Full || 
 			      typ == SparseType::Tridiagonal || 
 			      typ == SparseType::Banded))
@@ -468,85 +512,129 @@ SparseType::SparseType (const SparseComp
 	  // Search for a permuted triangular matrix, and test if
 	  // permutation is singular
 
 	  // XXX FIXME XXX
 	  // Perhaps this should be based on a dmperm algorithm
 	  bool found = false;
 
 	  nperm = ncols;
-	  perm = new octave_idx_type [nperm];
+	  perm = new octave_idx_type [ncols];
+
+	  for (octave_idx_type i = 0; i < ncols; i++)
+	    perm [i] = -1;
 
 	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      found = false;
 
 	      for (octave_idx_type j = 0; j < ncols; j++)
 		{
-
 		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-		      a.ridx(a.cidx(j+1)-1) == i)
+		      (a.ridx(a.cidx(j+1)-1) == i))
 		    {
 		      perm [i] = j;
 		      found = true;
 		      break;
 		    }
 		}
 
 	      if (!found)
 		break;
 	    }
 
 	  if (found)
-	    typ = SparseType::Permuted_Upper;
-	  else
 	    {
-	      delete [] perm;
+	      typ = SparseType::Permuted_Upper;
+	      if (ncols > nrows)
+		{
+		  octave_idx_type k = nrows;
+		  for (octave_idx_type i = 0; i < ncols; i++)
+		    if (perm [i] == -1)
+		      perm[i] = k++;
+		}
+	    }
+	  else if (a.cidx(nm) == a.cidx(ncols))
+	    {
 	      nperm = nrows;
-	      perm = new octave_idx_type [nperm];
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
+	      delete [] perm;
+	      perm = new octave_idx_type [nrows];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
-	      for (octave_idx_type i = 0; i < nperm; i++)
+	      for (octave_idx_type i = 0; i < nrows; i++)
 		{
 		  perm [i] = -1;
 		  tmp [i] = -1;
 		}
 
 	      for (octave_idx_type j = 0; j < ncols; j++)
 		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		  perm [a.ridx(i)] = j;
-  
+		    perm [a.ridx(i)] = j;
+
 	      found = true;
-	      for (octave_idx_type i = 0; i < nperm; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		if (perm[i] == -1)
 		  {
 		    found = false;
 		    break;
 		  }
 		else
 		  {
 		    tmp[perm[i]] = 1;
 		  }
 
 	      if (found)
-		for (octave_idx_type i = 0; i < nm; i++)
-		  if (tmp[i] == -1)
+		{
+		  octave_idx_type k = ncols;
+		  for (octave_idx_type i = 0; i < nrows; i++)
 		    {
-		      found = false;
-		      break;
+		      if (tmp[i] == -1)
+			{
+			  if (k < nrows)
+			    {
+			      perm[k++] = i;
+			    }
+			  else
+			    {
+			      found = false;
+			      break;
+			    }
+			}
 		    }
+		}
 
 	      if (found)
 		typ = SparseType::Permuted_Lower;
 	      else
 		{
 		  delete [] perm;
 		  nperm = 0;
 		}
 	    }
+	  else
+	    {
+	      delete [] perm;
+	      nperm = 0;
+	    }
+	}
+
+      // XXX FIXME XXX
+      // Disable lower under-determined and upper over-determined problems
+      // as being detected, and force to treat as singular. As this seems
+      // to cause issues
+      if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
+	   && nrows > ncols) ||
+	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
+	   && nrows < ncols))
+	{
+	  typ = SparseType::Rectangular;
+	  if (typ == SparseType::Permuted_Upper ||
+	      typ == SparseType::Permuted_Lower)
+	    delete [] perm;
+	  nperm = 0;
 	}
 
       if (typ == SparseType::Full && ncols != nrows)
 	typ = SparseType::Rectangular;
 
       if (maybe_hermitian && (typ == SparseType::Full || 
 			      typ == SparseType::Tridiagonal || 
 			      typ == SparseType::Banded))
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -43,16 +43,23 @@ Boston, MA 02110-1301, USA.
 #include "SparseType.h"
 #include "oct-sparse.h"
 #include "sparse-util.h"
 #include "SparsedbleCHOL.h"
 #include "SparseQR.h"
 
 #include "oct-sort.h"
 
+// Define whether to use a basic QR solver or one that uses a Dulmange
+// Mendelsohn factorization to seperate the problem into under-determined,
+// well-determined and over-determined parts and solves them seperately
+#ifndef USE_QRSOLVE
+#include "sparse-dmsolve.cc"
+#endif
+
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgbtrf, DGBTRF) (const octave_idx_type&, const int&, const octave_idx_type&, 
 			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
@@ -110,40 +117,40 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 
 }
 
 SparseMatrix::SparseMatrix (const SparseBoolMatrix &a)
-  : MSparse<double> (a.rows (), a.cols (), a.nzmax ())
+  : MSparse<double> (a.rows (), a.cols (), a.nnz ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = a.nnz ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
-  octave_idx_type nz_a = a.nzmax ();
+  octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
@@ -493,17 +500,17 @@ SparseMatrix::concat (const SparseComple
   return retval;
 }
 
 SparseMatrix
 real (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
+  octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::real (a.data(i));
@@ -513,17 +520,17 @@ real (const SparseComplexMatrix& a)
   return r;
 }
 
 SparseMatrix
 imag (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
+  octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::imag (a.data(i));
@@ -555,17 +562,17 @@ atan2 (const double& x, const SparseMatr
     }
 }
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const double& y)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
-  octave_idx_type nz = x.nzmax ();
+  octave_idx_type nz = x.nnz ();
 
   SparseMatrix retval (nr, nc, nz);
 
   octave_idx_type ii = 0;
   retval.xcidx(0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
@@ -608,17 +615,17 @@ atan2 (const SparseMatrix& x, const Spar
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
 	gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
 	{
-	  r = SparseMatrix (x_nr, x_nc, (x.nzmax () + y.nzmax ()));
+	  r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < x_nc ; i++)
 	    {
 	      octave_idx_type  ja = x.cidx(i);
 	      octave_idx_type  ja_max = x.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -785,17 +792,17 @@ SparseMatrix::tinverse (SparseType &matt
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
 	  if (typ == SparseType::Upper || typ == SparseType::Lower)
 	    {
-	      octave_idx_type nz = nzmax ();
+	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  OCTAVE_QUIT;
 		  // place the 1 in the identity position
@@ -870,17 +877,17 @@ SparseMatrix::tinverse (SparseType &matt
 		    for (octave_idx_type j = cx_colstart; j < cx; j++)
 		      retval.xdata(j) /= pivot;
 		}
 	      retval.xcidx(nr) = cx;
 	      retval.maybe_compress ();
 	    }
 	  else
 	    {
-	      octave_idx_type nz = nzmax ();
+	      octave_idx_type nz = nnz ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
@@ -1182,18 +1189,19 @@ SparseMatrix::determinant (octave_idx_ty
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
-SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		      double& rcond, solve_singularity_handler) const
+SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err,
+		      double& rcond, solve_singularity_handler, 
+		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1215,38 +1223,43 @@ SparseMatrix::dsolve (SparseType &mattyp
 	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
 
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = fabs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = fabs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, 
-		      octave_idx_type& err, 
-		      double& rcond, solve_singularity_handler) const
+		      octave_idx_type& err, double& rcond, 
+		      solve_singularity_handler, bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1258,33 +1271,35 @@ SparseMatrix::dsolve (SparseType &mattyp
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b_nc; j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
+		    if (b.ridx(i) >= nm)
+		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
-	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b_nc; j++)
 	      {
 		for (octave_idx_type l = 0; l < nc; l++)
 		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
 		    {
 		      bool found = false;
 		      octave_idx_type k;
 		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
 			if (ridx(i) == b.ridx(k))
@@ -1296,38 +1311,43 @@ SparseMatrix::dsolve (SparseType &mattyp
 			{
 			  retval.xridx (ii) = l;
 			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
 		    }
 		retval.xcidx(j+1) = ii;
 	      }
 
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = fabs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = fabs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
-		      octave_idx_type& err, 
-		      double& rcond, solve_singularity_handler) const
+		      octave_idx_type& err, double& rcond,
+		      solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1349,38 +1369,43 @@ SparseMatrix::dsolve (SparseType &mattyp
 		for (octave_idx_type i = 0; i < nm; i++)
 		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      for (octave_idx_type k = 0; k < nc; k++)
 		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = fabs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = fabs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
 		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler) const
+		     solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -1392,26 +1417,28 @@ SparseMatrix::dsolve (SparseType &mattyp
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
+		    if (b.ridx(i) >= nm)
+		      break;
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
@@ -1430,38 +1457,44 @@ SparseMatrix::dsolve (SparseType &mattyp
 			{
 			  retval.xridx (ii) = l;
 			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
 		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
-	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nm; i++)
-	    {
-	      double tmp = fabs(data(i));
-	      if (tmp > dmax)
-		dmax = tmp;
-	      if (tmp < dmin)
-		dmin = tmp;
-	    }
-	  rcond = dmin / dmax;
+	  if (calc_cond)
+	    {
+	      double dmax = 0., dmin = octave_Inf; 
+	      for (octave_idx_type i = 0; i < nm; i++)
+		{
+		  double tmp = fabs(data(i));
+		  if (tmp > dmax)
+		    dmax = tmp;
+		  if (tmp < dmin)
+		    dmin = tmp;
+		}
+	      rcond = dmin / dmax;
+	    }
+	  else
+	    rcond = 1.;
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::utsolve (SparseType &mattype, const Matrix& b,
 		       octave_idx_type& err, double& rcond,
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler, 
+		       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1475,26 +1508,29 @@ SparseMatrix::utsolve (SparseType &matty
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
@@ -1506,17 +1542,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -1527,47 +1564,52 @@ SparseMatrix::utsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (perm[i], j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -1576,17 +1618,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -1596,86 +1639,95 @@ SparseMatrix::utsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1688,30 +1740,33 @@ SparseMatrix::utsolve (SparseType &matty
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -1729,17 +1784,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(kidx+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -1772,47 +1828,52 @@ SparseMatrix::utsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -1820,17 +1881,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -1862,85 +1924,95 @@ SparseMatrix::utsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -1954,26 +2026,29 @@ SparseMatrix::utsolve (SparseType &matty
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
@@ -1985,17 +2060,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    cwork[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -2006,48 +2082,53 @@ SparseMatrix::utsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (perm[i], j) = cwork[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -2056,17 +2137,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    cwork[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    cwork[i] = 0.;
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -2076,87 +2158,97 @@ SparseMatrix::utsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = cwork[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2169,30 +2261,33 @@ SparseMatrix::utsolve (SparseType &matty
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2210,17 +2305,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    cwork[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(kidx+1)-1) != k)
+			  if (ridx(cidx(kidx+1)-1) != k ||
+			      data(cidx(kidx+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(kidx); 
@@ -2253,48 +2349,53 @@ SparseMatrix::utsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      octave_idx_type iidx = perm[k];
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(iidx+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  octave_idx_type iidx = perm[k];
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type idx2 = ridx(i);
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(iidx+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(iidx); 
+				   i < cidx(iidx+1)-1; i++)
+				{
+				  octave_idx_type idx2 = ridx(i);
+				  work[idx2] = work[idx2] - tmp * data(i);
+				}
 			    }
 			}
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -2302,17 +2403,18 @@ SparseMatrix::utsolve (SparseType &matty
 		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    cwork[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(k+1)-1) != k)
+			  if (ridx(cidx(k+1)-1) != k ||
+			      data(cidx(k+1)-1) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
@@ -2344,87 +2446,97 @@ SparseMatrix::utsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k >= 0; k--)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k >= 0; k--)
 			{
-			  double tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k+1)-1);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1)-1; i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = 0; i < j+1; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b,
 		       octave_idx_type& err, double& rcond,
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2438,26 +2550,29 @@ SparseMatrix::ltsolve (SparseType &matty
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
@@ -2478,17 +2593,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data(mini) == 0)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -2501,59 +2616,65 @@ SparseMatrix::ltsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      double tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      retval.resize (nc, b_nc, 0.);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -2561,17 +2682,18 @@ SparseMatrix::ltsolve (SparseType &matty
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; 
@@ -2582,88 +2704,97 @@ SparseMatrix::ltsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = work[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2676,39 +2807,41 @@ SparseMatrix::ltsolve (SparseType &matty
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
-	    }
-
-	  octave_idx_type b_nr = b.rows ();
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseMatrix (b_nr, b_nc, b_nz);
+	  octave_idx_type b_nz = b.nnz ();
+	  retval = SparseMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[perm[b.ridx(i)]] = b.data(i);
@@ -2722,17 +2855,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data(mini) == 0)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(mini);
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -2767,77 +2900,84 @@ SparseMatrix::ltsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      double tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nr; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -2869,88 +3009,97 @@ SparseMatrix::ltsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, 
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -2964,32 +3113,35 @@ SparseMatrix::ltsolve (SparseType &matty
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (nc, b_nc);
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nm; i++)
 		    cwork[i] = 0.;
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    cwork[perm[i]] = b(i,j);
@@ -3003,17 +3155,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data(mini) == 0)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(mini);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -3026,60 +3178,66 @@ SparseMatrix::ltsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = cwork[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      double tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      retval.resize (nc, b_nc, 0.);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -3088,17 +3246,18 @@ SparseMatrix::ltsolve (SparseType &matty
 		    cwork[i] = b(i,j);
 		  for (octave_idx_type i = nr; i < nc; i++)
 		    cwork[i] = 0.;
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(k));
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -3108,89 +3267,98 @@ SparseMatrix::ltsolve (SparseType &matty
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval.xelem (i, j) = cwork[i];
 		}
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
 		       octave_idx_type& err, double& rcond, 
-		       solve_singularity_handler sing_handler) const
+		       solve_singularity_handler sing_handler,
+		       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
@@ -3203,30 +3371,33 @@ SparseMatrix::ltsolve (SparseType &matty
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  rcond = 0.;
-
-	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      double atmp = 0.;
-	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-		atmp += fabs(data(i));
-	      if (atmp > anorm)
-		anorm = atmp;
+	  rcond = 1.;
+
+	  if (calc_cond)
+	    {
+	      // Calculate the 1-norm of matrix for rcond calculation
+	      for (octave_idx_type j = 0; j < nc; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
 	    }
 
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nzmax ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
@@ -3248,17 +3419,17 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
 			      {
 				minr = perm[ridx(i)];
 				mini = i;
 			      }
 
-			  if (minr != k)
+			  if (minr != k || data(mini) == 0)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(mini);
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
@@ -3293,60 +3464,66 @@ SparseMatrix::ltsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = 0; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = 0; k < nc; k++)
 			{
-			  octave_idx_type minr = nr;
-			  octave_idx_type mini = 0;
-
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-			    if (perm[ridx(i)] < minr)
-			      {
-				minr = perm[ridx(i)];
-				mini = i;
-			      }
-
-			  double tmp = work[k] / data(mini);
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			  if (work[k] != 0.)
 			    {
-			      if (i == mini)
-				continue;
-
-			      octave_idx_type iidx = perm[ridx(i)];
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      octave_idx_type minr = nr;
+			      octave_idx_type mini = 0;
+
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				if (perm[ridx(i)] < minr)
+				  {
+				    minr = perm[ridx(i)];
+				    mini = i;
+				  }
+
+			      double tmp = work[k] / data(mini);
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k); 
+				   i < cidx(k+1); i++)
+				{
+				  if (i == mini)
+				    continue;
+
+				  octave_idx_type iidx = perm[ridx(i)];
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
+
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
-		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
+		  rcond = 1. / ainvnorm / anorm;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -3354,17 +3531,18 @@ SparseMatrix::ltsolve (SparseType &matty
 		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    cwork[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(k)) != k)
+			  if (ridx(cidx(k)) != k ||
+			      data(cidx(k)) == 0.)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = cwork[k] / data(cidx(k));
 			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
@@ -3396,99 +3574,111 @@ SparseMatrix::ltsolve (SparseType &matty
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nm);
-	      for (octave_idx_type i = 0; i < nm; i++)
-		work[i] = 0.;
-
-	      for (octave_idx_type j = 0; j < nr; j++)
-		{
-		  work[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nc; k++)
+	      if (calc_cond)
+		{
+		  // Calculation of 1-norm of inv(*this)
+		  OCTAVE_LOCAL_BUFFER (double, work, nm);
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type j = 0; j < nr; j++)
 		    {
-
-		      if (work[k] != 0.)
+		      work[j] = 1.;
+
+		      for (octave_idx_type k = j; k < nc; k++)
 			{
-			  double tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+
+			  if (work[k] != 0.)
 			    {
-			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      double tmp = work[k] / data(cidx(k));
+			      work[k] = tmp;
+			      for (octave_idx_type i = cidx(k)+1; 
+				   i < cidx(k+1); i++)
+				{
+				  octave_idx_type iidx = ridx(i);
+				  work[iidx] = work[iidx] - tmp * data(i);
+				}
 			    }
 			}
-		    }
-		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nc; i++)
-		    {
-		      atmp += fabs(work[i]);
-		      work[i] = 0.;
+		      double atmp = 0;
+		      for (octave_idx_type i = j; i < nc; i++)
+			{
+			  atmp += fabs(work[i]);
+			  work[i] = 0.;
+			}
+		      if (atmp > ainvnorm)
+			ainvnorm = atmp;
 		    }
-		  if (atmp > ainvnorm)
-		    ainvnorm = atmp;
-		}
-
-	    }
-
-	  rcond = 1. / ainvnorm / anorm;
+		  rcond = 1. / ainvnorm / anorm;
+		}
+	    }
 
 	triangular_error:
 	  if (err != 0)
 	    {
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 
 	  volatile double rcond_plus_one = rcond + 1.0;
 
 	  if (rcond_plus_one == 1.0 || xisnan (rcond))
 	    {
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision, rcond = %g",
 		   rcond);
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::trisolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		       double& rcond,
-		       solve_singularity_handler sing_handler) const
+SparseMatrix::trisolve (SparseType &mattype, const Matrix& b,
+			octave_idx_type& err, double& rcond,
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
@@ -3597,45 +3787,53 @@ SparseMatrix::trisolve (SparseType &matt
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgtsv");
 	  else if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	    } 
 	  else 
 	    rcond = 1.;
 	}
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::trisolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::trisolve (SparseType &mattype, const SparseMatrix& b, 
+			octave_idx_type& err, double& rcond, 
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
@@ -3684,32 +3882,36 @@ SparseMatrix::trisolve (SparseType &matt
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgttrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
+		  rcond = 1.0;
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
+		  volatile octave_idx_type x_nz = b.nnz ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -3763,28 +3965,33 @@ SparseMatrix::trisolve (SparseType &matt
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b, 
+			octave_idx_type& err, double& rcond, 
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
@@ -3903,43 +4110,50 @@ SparseMatrix::trisolve (SparseType &matt
 	      err = -1;
 	    }
 	  else if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 		      
 	      if (sing_handler)
-		sing_handler (rcond);
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 	    }
 	}
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::trisolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			octave_idx_type& err, double& rcond, 
+			solve_singularity_handler sing_handler,
+			bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
+  else if (calc_cond)
+    (*current_liboctave_error_handler) 
+      ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
@@ -3988,39 +4202,42 @@ SparseMatrix::trisolve (SparseType &matt
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgttrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
+		  rcond = 0.0;
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 		} 
 	      else 
 		{	
 		  rcond = 1.;
 		  char job = 'N';
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
+		  volatile octave_idx_type x_nz = b.nnz ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -4107,19 +4324,20 @@ SparseMatrix::trisolve (SparseType &matt
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::bsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		       double& rcond,
-		       solve_singularity_handler sing_handler) const
+SparseMatrix::bsolve (SparseType &mattype, const Matrix& b,
+		      octave_idx_type& err, double& rcond,
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4151,101 +4369,104 @@ SparseMatrix::bsolve (SparseType &mattyp
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  // Calculate the norm of the matrix, for later use.
-	  // double anorm = m_band.abs().sum().row(0).max();
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
+		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
-		  // Unfortunately, the time to calculate the condition
-		  // number is dominant for narrow banded matrices and
-		  // so we rely on the "err" flag from xPBTRF to flag
-		  // singularity. The commented code below is left here
-		  // for reference
-
-		  //Array<double> z (3 * nr);
-		  //double *pz = z.fortran_vec ();
-		  //Array<int> iz (nr);
-		  //int *piz = iz.fortran_vec ();
-		  //
-		  //F77_XFCN (dpbcon, DGBCON, 
-		  //	(F77_CONST_CHAR_ARG2 (&job, 1),
-		  //	 nr, n_lower, tmp_data, ldm,
-		  //	 anorm, rcond, pz, piz, err
-		  //	 F77_CHAR_ARG_LEN (1)));
-		  //
-		  //
-		  //if (f77_exception_encountered)
-		  //	(*current_liboctave_error_handler) 
-		  //	  ("unrecoverable error in dpbcon");
-		  //
-		  //if (err != 0) 
-		  //	err = -2;
-		  //
-		  //volatile double rcond_plus_one = rcond + 1.0;
-		  //
-		  //if (rcond_plus_one == 1.0 || xisnan (rcond))
-		  //  {
-		  //    err = -2;
-		  //
-		  //    if (sing_handler)
-		  //      sing_handler (rcond);
-		  //    else
-		  //      (*current_liboctave_error_handler)
-		  //        ("matrix singular to machine precision, rcond = %g",
-		  //         rcond);
-		  //  }
-		  //else
-		  //    REST OF CODE, EXCEPT rcond=1
-
-		  rcond = 1.;
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  F77_XFCN (dpbtrs, DPBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, b_nc, tmp_data,
-			     ldm, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in dpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      retval = b;
+		      double *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, b_nc, tmp_data,
+				 ldm, result, b.rows(), err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in dpbtrs");
-
-		  if (err != 0)
-		    {
-		      (*current_liboctave_error_handler) 
-			("SparseMatrix::solve solve failed");
-		      err = -1;
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in dpbtrs");
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			}
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4264,109 +4485,134 @@ SparseMatrix::bsolve (SparseType &mattyp
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
 	    {
 	      // Throw-away extra info LAPACK gives so as to not 
 	      // change output.
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
-		  char job = '1';
-
-		  // Unfortunately, the time to calculate the condition
-		  // number is dominant for narrow banded matrices and
-		  // so we rely on the "err" flag from xPBTRF to flag
-		  // singularity. The commented code below is left here
-		  // for reference
-
-		  //F77_XFCN (dgbcon, DGBCON, 
-		  //	(F77_CONST_CHAR_ARG2 (&job, 1),
-		  //	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		  //	 anorm, rcond, pz, piz, err
-		  //	 F77_CHAR_ARG_LEN (1)));
-		  //
-		  //if (f77_exception_encountered)
-		  //  (*current_liboctave_error_handler) 
-		  //    ("unrecoverable error in dgbcon");
-		  //
-		  // if (err != 0) 
-		  //  err = -2;
-		  //
-		  //volatile double rcond_plus_one = rcond + 1.0;
-		  //
-		  //if (rcond_plus_one == 1.0 || xisnan (rcond))
-		  //  {
-		  //    err = -2;
-		  //
-		  //    if (sing_handler)
-		  //      sing_handler (rcond);
-		  //    else
-		  //      (*current_liboctave_error_handler)
-		  //        ("matrix singular to machine precision, rcond = %g",
-		  //         rcond);
-		  //  }
-		  //else
-		  //  REST OF CODE, EXCEPT rcond=1
-
-		  rcond = 1.;
-		  retval = b;
-		  double *result = retval.fortran_vec ();
-
-		  octave_idx_type b_nc = b.cols ();
-
-		  job = 'N';
-		  F77_XFCN (dgbtrs, DGBTRS, 
-			    (F77_CONST_CHAR_ARG2 (&job, 1),
-			     nr, n_lower, n_upper, b_nc, tmp_data,
-			     ldm, pipvt, result, b.rows(), err
-			     F77_CHAR_ARG_LEN (1)));
+		  if (calc_cond)
+		    {
+		      char job = '1';
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dgbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in dgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      retval = b;
+		      double *result = retval.fortran_vec ();
+
+		      octave_idx_type b_nc = b.cols ();
+
+		      char job = 'N';
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, b_nc, tmp_data,
+				 ldm, pipvt, result, b.rows(), err
+				 F77_CHAR_ARG_LEN (1)));
 		    
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in dgbtrs");
+		      if (f77_exception_encountered)
+			(*current_liboctave_error_handler)
+			  ("unrecoverable error in dgbtrs");
+		    }
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::bsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::bsolve (SparseType &mattype, const SparseMatrix& b,
+		      octave_idx_type& err, double& rcond, 
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4398,95 +4644,143 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
+		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
+		    {
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in dpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
 		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b.elem (i, j);
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+
+		      // Take a first guess that the number of non-zero terms
+		      // will be as many as in b
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      volatile octave_idx_type ii = 0;
+		      retval = SparseMatrix (b_nr, b_nc, x_nz);
+
+		      retval.xcidx(0) = 0;
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+			{
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    Bx[i] = b.elem (i, j);
+
+			  F77_XFCN (dpbtrs, DPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bx, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    {
+			      double tmp = Bx[i];
+			      if (tmp != 0.0)
+				{
+				  if (ii == x_nz)
+				    {
+				      // Resize the sparse matrix
+				      octave_idx_type sz = x_nz * 
+					(b_nc - j) / b_nc;
+				      sz = (sz > 10 ? sz : 10) + x_nz;
+				      retval.change_capacity (sz);
+				      x_nz = sz;
+				    }
+				  retval.xdata(ii) = tmp;
+				  retval.xridx(ii++) = i;
+				}
+			    }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  double tmp = Bx[i];
-			  if (tmp != 0.0)
-			    {
-			      if (ii == x_nz)
-				{
-				  // Resize the sparse matrix
-				  octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
-				  sz = (sz > 10 ? sz : 10) + x_nz;
-				  retval.change_capacity (sz);
-				  x_nz = sz;
-				}
-			      retval.xdata(ii) = tmp;
-			      retval.xridx(ii++) = i;
-			    }
-			}
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -4504,108 +4798,172 @@ SparseMatrix::bsolve (SparseType &mattyp
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
+		      char job = '1';
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dgbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
 		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in dgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      octave_idx_type b_nc = b.cols ();
+		      retval = SparseMatrix (nr, b_nc, x_nz);
+		      retval.xcidx(0) = 0;
+		      volatile octave_idx_type ii = 0;
+
+		      OCTAVE_LOCAL_BUFFER (double, work, nr);
+
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    work[i] = 0.;
+			  for (octave_idx_type i = b.cidx(j); 
+			       i < b.cidx(j+1); i++)
+			    work[b.ridx(i)] = b.data(i);
+
+			  F77_XFCN (dgbtrs, DGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, work, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (work[i] != 0.)
+			      new_nnz++;
+
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
+
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (work[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = work[i];
+			      }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, 
+		      octave_idx_type& err, double& rcond, 
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4637,101 +4995,148 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
+		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		  retval.resize (b_nr, b_nc);
+		  if (calc_cond)
+		    {
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in dpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+
+		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+		      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+		      retval.resize (b_nr, b_nc);
 	      
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < b_nr; i++)
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  Complex c = b (i,j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag (c);
-			}
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    {
+			      Complex c = b (i,j);
+			      Bx[i] = std::real (c);
+			      Bz[i] = std::imag (c);
+			    }
 			  
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
+			  F77_XFCN (dpbtrs, DPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bx, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  F77_XFCN (dpbtrs, DPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bz, b.rows(), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    retval (i, j) = Complex (Bx[i], Bz[i]);
 			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bz, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4750,100 +5155,162 @@ SparseMatrix::bsolve (SparseType &mattyp
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
+		    {
 		    sing_handler (rcond);
+		    mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
-		  char job = 'N';
-		  octave_idx_type b_nc = b.cols ();
-		  retval.resize (nr,b_nc);
-
-		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
+		      char job = '1';
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in dpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+		            sing_handler (rcond);
+			    mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      octave_idx_type b_nc = b.cols ();
+		      retval.resize (nr,b_nc);
+
+		      OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+		      OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  Complex c = b (i, j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag  (c);
-			}
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    {
+			      Complex c = b (i, j);
+			      Bx[i] = std::real (c);
+			      Bz[i] = std::imag  (c);
+			    }
+
+			  F77_XFCN (dgbtrs, DGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, Bx, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  F77_XFCN (dgbtrs, DGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, Bz, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    retval (i, j) = Complex (Bx[i], Bz[i]);
 			}
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bz, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+		      octave_idx_type& err, double& rcond, 
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -4875,133 +5342,180 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
 		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    anorm = m_band.abs().sum().row(0).max();
+
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dpbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  // Matrix is not positive definite!! Fall through to
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 
+		  rcond = 0.0;
 		  err = 0;
 		} 
 	      else 
 		{
-		  rcond = 1.;
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dpbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nr, n_lower, tmp_data, ldm,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		      	(*current_liboctave_error_handler) 
+		      	  ("unrecoverable error in dpbcon");
+
+		      if (err != 0) 
+		      	err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      octave_idx_type b_nr = b.rows ();
+		      octave_idx_type b_nc = b.cols ();
+		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+		      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+		      // Take a first guess that the number of non-zero terms
+		      // will be as many as in b
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      volatile octave_idx_type ii = 0;
+		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		      retval.xcidx(0) = 0;
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  Complex c = b (i,j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag (c);
-			}
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
+
+			  for (octave_idx_type i = 0; i < b_nr; i++)
+			    {
+			      Complex c = b (i,j);
+			      Bx[i] = std::real (c);
+			      Bz[i] = std::imag (c);
+			    }
+
+			  F77_XFCN (dpbtrs, DPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bx, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler) 
+				("SparseMatrix::solve solve failed");
+			      err = -1;
+			      break;
+			    }
+
+			  F77_XFCN (dpbtrs, DPBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, 1, tmp_data,
+				     ldm, Bz, b_nr, err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dpbtrs");
+			      err = -1;
+			      break;
+			    }
+
+			  if (err != 0)
+			    {
+			      (*current_liboctave_error_handler)
+				("SparseMatrix::solve solve failed");
+
+			      err = -1;
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0. || Bz[i] != 0.)
+			      new_nnz++;
+			  
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
+			  
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0. || Bz[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = 
+				  Complex (Bx[i], Bz[i]);
+			      }
+
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, 1, tmp_data,
-				 ldm, Bz, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dpbtrs");
-			  err = -1;
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler)
-			    ("SparseMatrix::solve solve failed");
-
-			  err = -1;
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  new_nnz++;
-			  
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-			  
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = 
-			      Complex (Bx[i], Bz[i]);
-			  }
-
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  int n_upper = mattype.nupper ();
@@ -5019,130 +5533,193 @@ SparseMatrix::bsolve (SparseType &mattyp
 		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
+	  // Calculate the norm of the matrix, for later use.
+	  double anorm;
+	  if (calc_cond)
+	    {
+	      for (octave_idx_type j = 0; j < nr; j++)
+		{
+		  double atmp = 0.;
+		  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		    atmp += fabs(data(i));
+		  if (atmp > anorm)
+		    anorm = atmp;
+		}
+	    }
+
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
 	    {
-	      rcond = 0.0;
 	      if (err != 0) 
 		{
 		  err = -2;
+		  rcond = 0.0;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nzmax ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		  if (calc_cond)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
+		      char job = '1';
+		      Array<double> z (3 * nr);
+		      double *pz = z.fortran_vec ();
+		      Array<octave_idx_type> iz (nr);
+		      int *piz = iz.fortran_vec ();
+
+		      F77_XFCN (dgbcon, DGBCON, 
+		      	(F77_CONST_CHAR_ARG2 (&job, 1),
+		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		      	 anorm, rcond, pz, piz, err
+		      	 F77_CHAR_ARG_LEN (1)));
+
+		      if (f77_exception_encountered)
+		        (*current_liboctave_error_handler) 
+		          ("unrecoverable error in dgbcon");
+
+		       if (err != 0) 
+		        err = -2;
+
+		      volatile double rcond_plus_one = rcond + 1.0;
+
+		      if (rcond_plus_one == 1.0 || xisnan (rcond))
+		        {
+		          err = -2;
+
+		          if (sing_handler)
+			    {
+			      sing_handler (rcond);
+			      mattype.mark_as_rectangular ();
+			    }
+		          else
+		            (*current_liboctave_error_handler)
+		              ("matrix singular to machine precision, rcond = %g",
+		               rcond);
+		        }
+		    }
+		  else
+		    rcond = 1.;
+
+		  if (err == 0)
+		    {
+		      char job = 'N';
+		      volatile octave_idx_type x_nz = b.nnz ();
+		      octave_idx_type b_nc = b.cols ();
+		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		      retval.xcidx(0) = 0;
+		      volatile octave_idx_type ii = 0;
+
+		      OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+		      OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+
+		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
 			{
-			  Bx[i] = 0.;
-			  Bz[i] = 0.;
-			}
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			{
-			  Complex c = b.data(i);
-			  Bx[b.ridx(i)] = std::real (c);
-			  Bz[b.ridx(i)] = std::imag (c);
-			}
-
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bx, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    {
+			      Bx[i] = 0.;
+			      Bz[i] = 0.;
+			    }
+			  for (octave_idx_type i = b.cidx(j); 
+			       i < b.cidx(j+1); i++)
+			    {
+			      Complex c = b.data(i);
+			      Bx[b.ridx(i)] = std::real (c);
+			      Bz[b.ridx(i)] = std::imag (c);
+			    }
+
+			  F77_XFCN (dgbtrs, DGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, Bx, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
 		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  F77_XFCN (dgbtrs, DGBTRS, 
+				    (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nr, n_lower, n_upper, 1, tmp_data,
+				     ldm, pipvt, Bz, b.rows (), err
+				     F77_CHAR_ARG_LEN (1)));
+		    
+			  if (f77_exception_encountered)
+			    {
+			      (*current_liboctave_error_handler)
+				("unrecoverable error in dgbtrs");
+			      break;
+			    }
+
+			  // Count non-zeros in work vector and adjust 
+			  // space in retval if needed
+			  octave_idx_type new_nnz = 0;
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0. || Bz[i] != 0.)
+			      new_nnz++;
+
+			  if (ii + new_nnz > x_nz)
+			    {
+			      // Resize the sparse matrix
+			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			      retval.change_capacity (sz);
+			      x_nz = sz;
+			    }
+
+			  for (octave_idx_type i = 0; i < nr; i++)
+			    if (Bx[i] != 0. || Bz[i] != 0.)
+			      {
+				retval.xridx(ii) = i;
+				retval.xdata(ii++) = 
+				  Complex (Bx[i], Bz[i]);
+			      }
+			  retval.xcidx(j+1) = ii;
 			}
 
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, 1, tmp_data,
-				 ldm, pipvt, Bz, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = 
-			      Complex (Bx[i], Bz[i]);
-			  }
-		      retval.xcidx(j+1) = ii;
+		      retval.maybe_compress ();
 		    }
-
-		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
-SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
-			 solve_singularity_handler sing_handler) const
+SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control,
+			 Matrix &Info, solve_singularity_handler sing_handler,
+			 bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
@@ -5194,17 +5771,20 @@ SparseMatrix::factorize (octave_idx_type
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
 				   &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
-      rcond = Info (UMFPACK_RCOND);
+      if (calc_cond)
+	rcond = Info (UMFPACK_RCOND);
+      else
+	rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
 	  rcond_plus_one == 1.0 || xisnan (rcond))
 	{
 	  UMFPACK_DNAME (report_numeric) (Numeric, control);
 
 	  err = -2;
@@ -5239,19 +5819,20 @@ SparseMatrix::factorize (octave_idx_type
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 Matrix
-SparseMatrix::fsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		     double& rcond, 
-		     solve_singularity_handler sing_handler) const
+SparseMatrix::fsolve (SparseType &mattype, const Matrix& b,
+		      octave_idx_type& err, double& rcond, 
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5350,17 +5931,21 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  else
 	    // We won't alter it, honest :-)
 	    B->x = const_cast<double *>(b.fortran_vec());
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.0;
+
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5368,17 +5953,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5411,17 +5999,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = 
-	    factorize (err, rcond, Control, Info, sing_handler);
+	    factorize (err, rcond, Control, Info, sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      const double *Bx = b.fortran_vec ();
 	      retval.resize (b.rows (), b.cols());
 	      double *result = retval.fortran_vec ();
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
@@ -5449,30 +6037,35 @@ SparseMatrix::fsolve (SparseType &mattyp
 		      break;
 		    }
 		}
 
 	      UMFPACK_DNAME (report_info) (control, info);
 		
 	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+SparseMatrix::fsolve (SparseType &mattype, const SparseMatrix& b,
+		      octave_idx_type& err, double& rcond,
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5581,17 +6174,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    B->x = &dummy;
 	  else
 	    B->x = b.data();
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5599,17 +6195,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5647,17 +6246,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler);
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -5665,17 +6264,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nzmax ();
+	      octave_idx_type x_nz = b.nnz ();
 	      octave_idx_type ii = 0;
 	      retval = SparseMatrix (b_nr, b_nc, x_nz);
 
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
@@ -5717,30 +6316,35 @@ SparseMatrix::fsolve (SparseType &mattyp
 		}
 
 	      retval.maybe_compress ();
 
 	      UMFPACK_DNAME (report_info) (control, info);
 
 	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, double& rcond,
-		     solve_singularity_handler sing_handler) const
+SparseMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, 
+		      octave_idx_type& err, double& rcond,
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -5839,17 +6443,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  else
 	    // We won't alter it, honest :-)
 	    B->x = const_cast<Complex *>(b.fortran_vec());
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.0;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -5857,17 +6464,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -5900,17 +6510,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler);
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -5957,31 +6567,35 @@ SparseMatrix::fsolve (SparseType &mattyp
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    retval (i, j) = Complex (Xx[i], Xz[i]);
 		}
 
 	      UMFPACK_DNAME (report_info) (control, info);
 
 	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
+
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b, 
 		      octave_idx_type& err, double& rcond,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler,
+		      bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
@@ -6090,17 +6704,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    B->x = &dummy;
 	  else
 	    B->x = b.data();
 
 	  cholmod_factor *L;
 	  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 	  L = CHOLMOD_NAME(analyze) (A, cm);
 	  CHOLMOD_NAME(factorize) (A, L, cm);
-	  rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  if (calc_cond)
+	    rcond = CHOLMOD_NAME(rcond)(L, cm);
+	  else
+	    rcond = 1.0;
 	  END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 	  if (rcond == 0.0)
 	    {
 	      // Either its indefinite or singular. Try UMFPACK
 	      mattype.mark_as_unsymmetric ();
 	      typ = SparseType::Full;
 	    }
@@ -6108,17 +6725,20 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    {
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (rcond_plus_one == 1.0 || xisnan (rcond))
 		{
 		  err = -2;
 
 		  if (sing_handler)
-		    sing_handler (rcond);
+		    {
+		      sing_handler (rcond);
+		      mattype.mark_as_rectangular ();
+		    }
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		  return retval;
 		}
 
@@ -6157,17 +6777,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 #endif
 	}
 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
-				     sing_handler);
+				     sing_handler, calc_cond);
 
 	  if (err == 0)
 	    {
 	      octave_idx_type b_nr = b.rows ();
 	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
@@ -6175,17 +6795,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nzmax ();
+	      octave_idx_type x_nz = b.nnz ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -6237,16 +6857,18 @@ SparseMatrix::fsolve (SparseType &mattyp
 		}
 
 	      retval.maybe_compress ();
 
 	      UMFPACK_DNAME (report_info) (control, info);
 
 	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
+	  else
+	    mattype.mark_as_rectangular ();
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
@@ -6275,40 +6897,54 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
+  Matrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
+  // Only calculate the condition number for CHOLMOD/UMFPACK
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
+
+  // Rectangular or one of the above solvers flags a singular matrix
+  if (mattype.type (false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<Matrix, SparseMatrix, Matrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
@@ -6329,40 +6965,53 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
+  SparseMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseMatrix ();
     }
+
+  if (mattype.type (false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<SparseMatrix, SparseMatrix, 
+	SparseMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
@@ -6383,40 +7032,53 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
+  ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<ComplexMatrix, SparseMatrix, 
+	ComplexMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
@@ -6437,40 +7099,53 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
+  SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
-    return dsolve (mattype, b, err, rcond, sing_handler);
+    retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
-    return utsolve (mattype, b, err, rcond, sing_handler);
+    retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
-    return ltsolve (mattype, b, err, rcond, sing_handler);
+    retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Banded || typ == SparseType::Banded_Hermitian)
-    return bsolve (mattype, b, err, rcond, sing_handler);
+    retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Tridiagonal || 
 	   typ == SparseType::Tridiagonal_Hermitian)
-    return trisolve (mattype, b, err, rcond, sing_handler);
+    retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == SparseType::Full || typ == SparseType::Hermitian)
-    return fsolve (mattype, b, err, rcond, sing_handler);
-  else
+    retval = fsolve (mattype, b, err, rcond, sing_handler, true);
+  else if (typ != SparseType::Rectangular)
     {
-      (*current_liboctave_error_handler) 
-	("matrix dimension mismatch solution of linear equations");
+      (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
+
+  if (mattype.type(false) == SparseType::Rectangular)
+    {
+      rcond = 1.;
+#ifdef USE_QRSOLVE
+      retval = qrsolve (*this, b, err);
+#else
+      retval = dmsolve<SparseComplexMatrix, SparseMatrix, 
+	SparseComplexMatrix> (*this, b, err);
+#endif
+    }
+
+  return retval;
 }
 
 ColumnVector
 SparseMatrix::solve (SparseType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
@@ -6698,154 +7373,24 @@ SparseMatrix::solve (const ComplexColumn
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
-Matrix
-SparseMatrix::lssolve (const Matrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-Matrix
-SparseMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-Matrix
-SparseMatrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-SparseMatrix
-SparseMatrix::lssolve (const SparseMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseMatrix
-SparseMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseMatrix
-SparseMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info, octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-ComplexMatrix
-SparseMatrix::lssolve (const ComplexMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-SparseMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-SparseComplexMatrix
-SparseMatrix::lssolve (const SparseComplexMatrix& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-SparseComplexMatrix
-SparseMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info, 
-		       octave_idx_type&) const
-{
-  return qrsolve (*this, b, info);
-}
-
-ColumnVector
-SparseMatrix::lssolve (const ColumnVector& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ColumnVector
-SparseMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ColumnVector
-SparseMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
-{
-  Matrix tmp (b);
-  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
-}
-
-ComplexColumnVector
-SparseMatrix::lssolve (const ComplexColumnVector& b) const
-{
-  octave_idx_type info;
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
-{
-  octave_idx_type rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-SparseMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
-		       octave_idx_type& rank) const
-{
-  ComplexMatrix tmp (b);
-  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
-}
-
 // other operations.
 
 SparseMatrix
 SparseMatrix::map (d_d_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6885,17 +7430,17 @@ SparseMatrix::map (d_d_Mapper f) const
   return retval;
 }
 
 SparseBoolMatrix
 SparseMatrix::map (b_d_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6940,17 +7485,17 @@ SparseMatrix::apply (d_d_Mapper f)
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
 	if (lo_ieee_signbit (data (i)))
 	  return true;
     }
   else
@@ -6961,32 +7506,32 @@ SparseMatrix::any_element_is_negative (b
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_inf_or_nan (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisnan (val) || D_NINT (val) == val)
 	continue;
       else
 	return false;
@@ -6996,17 +7541,17 @@ SparseMatrix::all_elements_are_int_or_in
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 SparseMatrix::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
   max_val = data (0);
   min_val = data (0);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -7024,17 +7569,17 @@ SparseMatrix::all_integers (double& max_
     }
 
   return true;
 }
 
 bool
 SparseMatrix::too_large_for_float (void) const
 {
-  octave_idx_type nel = nzmax ();
+  octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
 	return true;
     }
@@ -7042,17 +7587,17 @@ SparseMatrix::too_large_for_float (void)
   return false;
 }
 
 SparseBoolMatrix 
 SparseMatrix::operator ! (void) const 
 { 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz1 = nzmax ();
+  octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
@@ -7128,17 +7673,17 @@ SparseMatrix::sumsq (int dim) const
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix
 SparseMatrix::abs (void) const
 {
-  octave_idx_type nz = nzmax ();
+  octave_idx_type nz = nnz ();
 
   SparseMatrix retval (*this);
 
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = fabs(retval.data(i));
 
   return retval;
 }
@@ -7354,42 +7899,29 @@ SparseMatrix::ipermute (const Array<octa
   return MSparse<double>::ipermute (vec);
 }
 
 // matrix by matrix -> matrix operations
 
 SparseMatrix
 operator * (const SparseMatrix& m, const SparseMatrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ?? Is it faster??
-#else
-  // Use Andy's sparse matrix multiply function
-  SPARSE_SPARSE_MUL (SparseMatrix, double);
-#endif
+  SPARSE_SPARSE_MUL (SparseMatrix, double, double);
 }
 
 Matrix
 operator * (const Matrix& m, const SparseMatrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ?? Is it faster??
-#else
-  FULL_SPARSE_MUL (Matrix, double);
-#endif
+  FULL_SPARSE_MUL (Matrix, double, 0.);
 }
 
 Matrix
 operator * (const SparseMatrix& m, const Matrix& a)
 {
-#ifdef HAVE_SPARSE_BLAS
-  // XXX FIXME XXX Isn't there a sparse BLAS ?? Is it faster??
-#else
-  SPARSE_FULL_MUL (Matrix, double);
-#endif
+  SPARSE_FULL_MUL (Matrix, double, 0.);
 }
 
 // XXX FIXME XXX -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
@@ -7469,17 +8001,17 @@ min (const SparseMatrix& a, const Sparse
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -7619,17 +8151,17 @@ max (const SparseMatrix& a, const Sparse
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
+	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -131,101 +131,138 @@ public:
 		        double& rcond, int force = 0, int calc_cond = 1) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  Matrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler, 
+		bool calc_cond = false) const;
 
-  SparseMatrix dsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix dsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  Matrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseMatrix utsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix utsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond,
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  Matrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseMatrix ltsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix ltsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
-  Matrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseMatrix trisolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix trisolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond,
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  Matrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseMatrix bsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix bsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
 		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
-		    solve_singularity_handler sing_handler) const;
+  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
+		    Matrix &Info, solve_singularity_handler sing_handler,
+		    bool calc_cond = false) const;
 
-  Matrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+  Matrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
+		double& rcond, solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
-  SparseMatrix fsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler) const;
+  SparseMatrix fsolve (SparseType &typ, const SparseMatrix& b,
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+		octave_idx_type& info, double& rcond, 
+		solve_singularity_handler sing_handler,
+		bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (SparseType &typ, const Matrix& b) const;
   Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond) const;
   Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
@@ -312,45 +349,16 @@ public:
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
-  // Minimum-norm solvers
-  Matrix lssolve (const Matrix& b) const;
-  Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
-  Matrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
-
-  ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
-
-  SparseMatrix lssolve (const SparseMatrix& b) const;
-  SparseMatrix lssolve (const SparseMatrix& b, octave_idx_type& info) const;
-  SparseMatrix lssolve (const SparseMatrix& b, octave_idx_type& info, octave_idx_type& rank) const;
-
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, 
-			       octave_idx_type& info) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
-
-  ColumnVector lssolve (const ColumnVector& b) const;
-  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
-  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const;
-
-  ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
-
   // other operations
   SparseMatrix map (d_d_Mapper f) const;
   SparseBoolMatrix map (b_d_Mapper f) const;
 
   SparseMatrix& apply (d_d_Mapper f);
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_inf_or_nan (void) const;
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,16 @@
+2006-03-16  David Bateman  <dbateman@free.fr>
+
+	* testfun/test.m: Clear last warning before warning test to avoid
+	issues with previously set warnings.
+	* build_sparse_test.sh: Tests for multiple RHS for rectanguar
+	sparse matrices. Force matrix type from spqr solution to be
+	singular to force QR solvers to be used for assert.
+
 2006-03-16  William Poetra Yoga Hadisoeseno  <williampoetra@gmail.com>
 
 	* strings/strfind.m: New file.
 
 2006-03-16  John W. Eaton  <jwe@octave.org>
 
 	* general/rows.m, general/columns.m: Delete.
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -602,16 +602,19 @@ endfunction
 
 %!error <usage.*test> test                     # no args, generates usage()
 %!error <usage.*test> test(1,2,3,4)            # too many args, generates usage()
 %!error <unknown flag> test("test", 'bogus');  # incorrect args, generates error()
 %!error <garbage' undefined> garbage           # usage on nonexistent function should be
 
 %!error test("test", 'bogus');           # test without pattern
 
+%!test
+%! lastwarn();            # clear last warning just in case
+
 %!warning <warning message> warning('warning message')
 
 %!## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
 %!test   assert(a,3)      # variable should equal 3    
 %!shared b,c              # replace shared variables
 %!test assert (!exist("a"));   # a no longer exists
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,23 @@
+2006-03-16  David Bateman  <dbateman@free.fr>
+
+	* sparse-xdiv.cc (result_ok): delete.
+	(xdiv, xleftdiv): Simplify to use version of SpareMatrix::solve
+	and SparseComplexMatrix::solve which internally treats rectangular
+	and singular matrices.
+	* DLD-FUNCTIONS/luinc.cc: Remove error test for singular matrix as
+	QR solver now implemented.
+	* DLD-FUNCTIONS/matrix_type.cc (Fmatrix_type): Paranoid check on 
+	error_state. Disable tests for the detection of underdetermined 
+	lower and over-determined upper matrix due to problems with 
+	non minimum norm solutions.
+	* DLD-FUNCTIONS/spqr.cc: Warning for issue of use of Fspqr for
+	under-determined problems.
+
 2006-03-16  John W. Eaton  <jwe@octave.org>
 
 	* __gnuplot_raw__.l: Move here from DLD-FUNCTIONS/__gnuplot_raw__.l.
 	* Makefile.in (DLD_XSRC): Delete __gnuplot_raw__.l from the list.
 	(DIST_SRC): Include __gnuplot_raw__.l in the list.
 	(__gnuplot_raw__.cc): Depend on __gnuplot_raw__.l, not
 	DLD-FUNCTIONS/__gnuplot_raw__.l
 
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -291,17 +291,15 @@ are the same as for @dfn{lu}.\n\
 %!test
 %! a=sparse([1i,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
 %! [l,u]=luinc(a,1e-10);
 %! assert(l*u, sparse([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
 %! opts.droptol=1e-10;
 %! [l,u]=luinc(a,opts);
 %! assert(l*u, sparse([1i,2,0,0;0,1,2,0;0,0,3,0;0,0,0,1]),1e-10);
 
-%!error splu(sparse([1i,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]));
-
 */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -113,28 +113,37 @@ matrix type.\n\
 
 	      if (args(0).type_name () == "sparse complex matrix" ) 
 		{
 		  mattyp = 
 		    ((const octave_sparse_complex_matrix &)rep).sparse_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
-		      mattyp = SparseType (args(0).sparse_complex_matrix_value ());
-		      ((octave_sparse_complex_matrix &)rep).sparse_type (mattyp);
+		      SparseComplexMatrix m = 
+			args(0).sparse_complex_matrix_value ();
+		      if (!error_state)
+			{
+			  mattyp = SparseType (m);
+			    ((octave_sparse_complex_matrix &)rep).sparse_type (mattyp);
+			}
 		    }
 		}
 	      else
 		{
 		  mattyp = ((const octave_sparse_matrix &)rep).sparse_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
-		      mattyp = SparseType (args(0).sparse_matrix_value ());
-		      ((octave_sparse_matrix &)rep).sparse_type (mattyp);
+		      SparseMatrix m = args(0).sparse_matrix_value ();
+		      if (!error_state)
+			{
+			  mattyp = SparseType (m);
+			  ((octave_sparse_matrix &)rep).sparse_type (mattyp);
+			}
 		    }
 		}
 
 	      int typ = mattyp.type ();
 
 	      if (typ == SparseType::Diagonal)
 		retval = octave_value ("Diagonal");
 	      else if (typ == SparseType::Permuted_Diagonal)
@@ -286,16 +295,21 @@ matrix type.\n\
       else
 	error ("matrix_type: Only sparse matrices treated at the moment");
     }
 
   return retval;
 }
 
 /*
+
+## XXX FIXME XXX
+## Disable tests for lower under-determined and upper over-determined 
+## matrices and this detection is disabled in SparseType due to issues
+## of non minimum norm solution being found.
  
 %!assert(matrix_type(speye(10,10)),"Diagonal");
 %!assert(matrix_type(speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]),"Lower");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
 %!test
@@ -315,22 +329,22 @@ matrix type.\n\
 %!test
 %! a=[speye(10,10),[sparse(9,1);1];-1,sparse(1,9),1];
 %! assert(matrix_type(a),"Full");
 %! assert(matrix_type(a'*a),"Positive Definite");
 %!assert(matrix_type(speye(10,11)),"Diagonal");
 %!assert(matrix_type(speye(10,11)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type(speye(11,10)),"Diagonal");
 %!assert(matrix_type(speye(11,10)([2:11,1],:)),"Permuted Diagonal");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]]),"Upper");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]](:,[2,1,3:12])),"Permuted Upper");
+%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]]),"Upper");
+%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]](:,[2,1,3:12])),"Permuted Upper");
 %!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]]),"Upper");
 %!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]](:,[2,1,3:10])),"Permuted Upper");
-%!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]),"Lower");
-%!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]([2,1,3:12],:)),"Permuted Lower");
+%#!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]),"Lower");
+%#!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]([2,1,3:12],:)),"Permuted Lower");
 %!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]),"Lower");
 %!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]([2,1,3:10],:)),"Permuted Lower");
 %!assert(matrix_type(spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
 
 %!assert(matrix_type(1i*speye(10,10)),"Diagonal");
 %!assert(matrix_type(1i*speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
@@ -353,22 +367,22 @@ matrix type.\n\
 %!test
 %! a=[speye(10,10),[sparse(9,1);1i];-1,sparse(1,9),1];
 %! assert(matrix_type(a),"Full");
 %! assert(matrix_type(a'*a),"Positive Definite");
 %!assert(matrix_type(1i*speye(10,11)),"Diagonal");
 %!assert(matrix_type(1i*speye(10,11)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type(1i*speye(11,10)),"Diagonal");
 %!assert(matrix_type(1i*speye(11,10)([2:11,1],:)),"Permuted Diagonal");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]]),"Upper");
-%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]](:,[2,1,3:12])),"Permuted Upper");
+%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]]),"Upper");
+%#!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]](:,[2,1,3:12])),"Permuted Upper");
 %!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]]),"Upper");
 %!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]](:,[2,1,3:10])),"Permuted Upper");
-%!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]),"Lower");
-%!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]([2,1,3:12],:)),"Permuted Lower");
+%#!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]),"Lower");
+%#!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]([2,1,3:12],:)),"Permuted Lower");
 %!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]),"Lower");
 %!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]([2,1,3:10],:)),"Permuted Lower");
 %!assert(matrix_type(1i*spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
 
 %!test
 %! a = matrix_type(spdiags(randn(10,3),[-1,0,1],10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
diff --git a/src/DLD-FUNCTIONS/spqr.cc b/src/DLD-FUNCTIONS/spqr.cc
--- a/src/DLD-FUNCTIONS/spqr.cc
+++ b/src/DLD-FUNCTIONS/spqr.cc
@@ -109,30 +109,34 @@ as\n\
 	    {
 	      SparseComplexQR q (args(0).sparse_complex_matrix_value ());
 	      if (!error_state)
 		{
 		  if (have_b)
 		    {
 		      retval(1) = q.R (economy);
 		      retval(0) = q.C (args(1).complex_matrix_value ());
+		      if (args(0).rows() < args(0).columns())
+			warning ("spqr: non minimum norm solution for under-determined problem");
 		    }
 		  else
 		    retval(0) = q.R (economy);
 		}
 	    }
 	  else
 	    {
 	      SparseQR q (args(0).sparse_matrix_value ());
 	      if (!error_state)
 		{
 		  if (have_b)
 		    {
 		      retval(1) = q.R (economy);
 		      retval(0) = q.C (args(1).matrix_value ());
+		      if (args(0).rows() < args(0).columns())
+			warning ("spqr: non minimum norm solution for under-determined problem");
 		    }
 		  else
 		    retval(0) = q.R (economy);
 		}
 	    }
 	}
     }
   return retval;
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -31,22 +31,16 @@ Boston, MA 02110-1301, USA.
 #include "quit.h"
 #include "error.h"
 
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
-static inline bool
-result_ok (octave_idx_type info)
-{
-  return (info != -2 && info != -1);
-}
-
 static void
 solve_singularity_warning (double rcond)
 {
   warning ("matrix singular to machine precision, rcond = %g", rcond);
   warning ("attempting to find minimum norm solution");
 }
 
 template <class T1, class T2>
@@ -127,265 +121,161 @@ xdiv (const Matrix& a, const SparseMatri
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      Matrix result = btmp.solve (btyp, atmp, info, rcond, 
-				  solve_singularity_warning);
+  double rcond = 0.0;
+  Matrix result = btmp.solve (btyp, atmp, info, rcond, 
+			      solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return Matrix (result.transpose ());
-	}
-    }
-
-  octave_idx_type rank;
-  Matrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  ComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  ComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // -*- 5 -*-
 SparseMatrix
 xdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
-					solve_singularity_warning);
+  double rcond = 0.0;
+  SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
+				    solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return SparseMatrix (result.transpose ());
-	}
-    }
-
-  octave_idx_type rank;
-  SparseMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
 xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  SparseComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
 xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  SparseComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
   SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
-  if (btmp.rows () == btmp.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  double rcond = 0.0;
+  SparseComplexMatrix result
+    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
-      if (result_ok (info))
-	{
-	  typ = btyp.transpose ();
-	  return result.hermitian ();
-	}
-    }
-
-  octave_idx_type rank;
-  SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
   typ = btyp.transpose ();
-
   return result.hermitian ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
@@ -488,190 +378,102 @@ x_el_div (const Complex a, const SparseC
 // -*- 1 -*-
 Matrix
 xleftdiv (const SparseMatrix& a, const Matrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      Matrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 3 -*-
 SparseMatrix
 xleftdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 4 -*-
 SparseComplexMatrix
 xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 5 -*-
 ComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const Matrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 6 -*-
 ComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      ComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, 
 	  SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
-  if (a.rows () == a.columns ())
-    {
-      double rcond = 0.0;
-
-      SparseComplexMatrix result
-	= a.solve (typ, b, info, rcond, solve_singularity_warning);
-
-      if (result_ok (info))
-	return result;
-    }
-
-  octave_idx_type rank;
-  return a.lssolve (b, info, rank);
+  double rcond = 0.0;
+  return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -930,29 +930,29 @@ cat >>$TESTS <<EOF
 %! a = alpha*sprandn(10,10,0.2)+speye(10,10); matrix_type(a, "Singular");
 %! f(a,[10,2],1e-10);
 
 %% Rectanguar solver tests that don't use QR
 
 %!test
 %! ds = alpha * spdiags([1:11]',0,10,11);
 %! df = full(ds);
-%! xf = beta * ones(10,1);
+%! xf = beta * ones(10,2);
 %! xs = speye(10,10);
 %!assert(ds\xf,df\xf,100*eps)
 %!assert(ds\xs,sparse(df\xs,true),100*eps)
 %!test
 %! pds = ds([2,1,3:10],:);
 %! pdf = full(pds);
 %!assert(pds\xf,pdf\xf,100*eps)
 %!assert(pds\xs,sparse(pdf\xs,true),100*eps)
 %!test
 %! ds = alpha * spdiags([1:11]',0,11,10);
 %! df = full(ds);
-%! xf = beta * ones(11,1);
+%! xf = beta * ones(11,2);
 %! xs = speye(11,11);
 %!assert(ds\xf,df\xf,100*eps)
 %!assert(ds\xs,sparse(df\xs,true),100*eps)
 %!test
 %! pds = ds([2,1,3:11],:);
 %! pdf = full(pds);
 %!assert(pds\xf,pdf\xf,100*eps)
 %!assert(pds\xs,sparse(pdf\xs,true),100*eps)
@@ -966,52 +966,58 @@ cat >>$TESTS <<EOF
 %!assert(pus*(pus\xs),xs,100*eps)
 %!test
 %! us = alpha*[speye(11,9),[1;sparse(8,1);1;0]];
 %!test
 %! [c,r] = spqr (us, xf);
 %! assert(us\xf,r\c,100*eps)
 %!test
 %! [c,r] = spqr (us, xs);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(us\xs,r\c,100*eps)
 %!test
 %! pus = us(:,[1:8,10,9]);
 %!test
 %! [c,r] = spqr (pus, xf);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(pus\xf,r\c,100*eps)
 %!test
 %! [c,r] = spqr (pus, xs);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(pus\xs,r\c,100*eps)
 %!test
 %! ls = alpha*[speye(9,11);[1,sparse(1,8),1,0]];
-%! xf = beta * ones(10,1);
+%! xf = beta * ones(10,2);
 %! xs = speye(10,10);
 %!assert(ls*(ls\xf),xf,100*eps)
 %!assert(ls*(ls\xs),xs,100*eps)
 %!test
 %! pls = ls([1:8,10,9],:);
 %!assert(pls*(pls\xf),xf,100*eps)
 %!assert(pls*(pls\xs),xs,100*eps)
 %!test
 %! ls = alpha*[speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]];
-%! xf = beta * ones(12,1);
+%! xf = beta * ones(12,2);
 %! xs = speye(12,12);
 %!test
 %! [c,r] = spqr (ls, xf);
 %! assert(ls\xf,r\c,100*eps)
 %!test
 %! [c,r] = spqr (ls, xs);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(ls\xs,r\c,100*eps)
 %!test
 %! pls = ls(:,[1:8,10,9]);
 %!test
 %! [c,r] = spqr (pls, xf);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(pls\xf,r\c,100*eps)
 %!test
 %! [c,r] = spqr (pls, xs);
+%! r = matrix_type(r,"Singular"); ## Force Matrix Type
 %! assert(pls\xs,r\c,100*eps)
 
 EOF
 }
 
 
 # =============================================================
 # Putting it all together: defining the combined tests
