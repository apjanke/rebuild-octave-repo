# HG changeset patch
# User Rik <rik@octave.org>
# Date 1418750489 28800
#      Tue Dec 16 09:21:29 2014 -0800
# Node ID 03067dab10ca55db6369f103a42612335ee2a87e
# Parent  5cd83b466a3ed6946072d56d3eb8b77d5d8b3078
Use stricter input validation when looking for a string as input (bug #42651).

* data.cc (get_sort_mode_option, Fissorted): Use is_string() to check string
input.

* debug.cc (Fdbstep): use "string" rather than "character string" in error
messages.

* error.cc (Flasterr, Flastwarn): use "string" rather than "character string"
in error messages.

* file-io.cc (do_stream_open, do_fread, do_fwrite, Fpopen, Ftempname,
Fmkstemp): Use is_string() to check string input.

* graphics.cc (Fgraphics_toolkit): Use is_string() to check string input.
Rephrase error message.

* help.cc (F__list_functions): Use is_string() to check string input.

* input.cc (Fyes_or_no): Use is_string() to check string input.  Rephrase
error message.
* input.cc (Fadd_input_event_hook): Rephrase error message.

* load-path.cc (Fgenpath, Faddpath): Rephrase error message.

* matrix_type.cc (Fmatrix_type): Use is_string() to check string input.

* qz.cc (Fqz): Follow Octave coding convention for space after '!'.

* regexp.cc (parse_options): Use is_string() to check string input.
Rephrase error message.

* schur.cc (Fschur): Use is_string() to check string input.

* strfns.cc (Flist_in_columns): Use is_string() to check string input.
Rephrase error message.

* symtab.cc (Fignore_function_time_stamp): Use is_string() to check string
input.  Rephrase error message.

* syscalls.cc (Fexec, Fpopen2, Fcanonicalize_file_name): Use is_string() to
check string input.  Rephrase error message.

* sysdep.cc (Fsetenv): Use is_string() to check string input.

* time.cc (Fstrftime, Fstrptime): Use is_string() to check string input.

* toplev.cc (Fsystem, Fatexit): Use is_string() to check string input.

* urlwrite.cc (Furlwrite, Furlread): Rephrase error message.

* utils.cc (Ffile_in_path): Use is_string() to check string input.  Rephrase
error message.

* variables.cc (extract_function): Add FIXME about potentially using is_string.
* variables.cc (do_isglobal, Fmunlock, Fmislocked): Use is_string() to check
string input.
* variables.cc (set_internal_variable): Rephrase error message.

* ov-base.cc (make_idx_args): Rephrase error message.

* ov-class.cc (octave_class::all_strings, Fclass): Rephrase error message.

* ov-fcn-handle.cc (Fstr2func): Use is_string() to check string input

* ov-java.cc (FjavaObject, FjavaMethod, F__java_get__, F__java_set__):
Use is_string() to check string input.

* ov.cc (Fdecode_subscripts): Use is_string() to check string input.
Rephrase error message.

* pt-idx.cc (tree_index_expression::get_struct_index): Rephrase error message.

* io.tst: Change %!warning test to %!error test to match stricter checking.

* system.tst: Change %!warning test for setenv to %!error test to match
stricter checking.

diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6850,28 +6850,30 @@ Undocumented internal function.\n\
 static sortmode
 get_sort_mode_option (const octave_value& arg, const char *argn)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   // about possibly using sortmode uninitialized.
   // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
-  std::string mode = arg.string_value ();
-
-  if (error_state)
-    error ("issorted: expecting %s argument to be a character string", argn);
-  else if (mode == "ascending")
-    smode = ASCENDING;
-  else if (mode == "descending")
-    smode = DESCENDING;
-  else if (mode == "either")
-    smode = UNSORTED;
+  if (arg.is_string ())
+    {
+      std::string mode = arg.string_value ();
+      if (mode == "ascending")
+        smode = ASCENDING;
+      else if (mode == "descending")
+        smode = DESCENDING;
+      else if (mode == "either")
+        smode = UNSORTED;
+      else
+        error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
+    }
   else
-    error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
+    error ("issorted: expecting %s argument to be a string", argn);
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} issorted (@var{a})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
@@ -6905,27 +6907,26 @@ This function does not support sparse ma
 
   if (nargin > 1)
     {
       octave_value mode_arg;
 
       if (nargin == 3)
         smode = get_sort_mode_option (args(2), "third");
 
-      std::string tmp = args(1).string_value ();
-
-      if (! error_state)
+      if (args(1).is_string ())
         {
+          std::string tmp = args(1).string_value ();
           if (tmp == "rows")
             by_rows = true;
           else
             smode = get_sort_mode_option (args(1), "second");
         }
       else
-        error ("expecting second argument to be character string");
+        error ("issorted: second argument must be a string");
 
       if (error_state)
         return retval;
     }
 
   octave_value arg = args(0);
 
   if (by_rows)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1457,17 +1457,17 @@ execution to continue until the current 
                           tree_evaluator::dbstep_flag = n;
                         }
                       else
                         error ("dbstep: invalid argument");
                     }
                 }
             }
           else
-            error ("dbstep: input argument must be a character string");
+            error ("dbstep: input argument must be a string");
         }
       else
         {
           Vdebugging = false;
 
           tree_evaluator::dbstep_flag = 1;
         }
     }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1861,17 +1861,17 @@ also set the last message identifier.\n\
 
           if (argc == 1 || nargout > 0)
             {
               retval(1) = prev_error_id;
               retval(0) = prev_error_message;
             }
         }
       else
-        error ("lasterr: expecting arguments to be character strings");
+        error ("lasterr: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lastwarn, args, nargout,
@@ -1908,17 +1908,17 @@ also set the last message identifier.\n\
           if (argc == 1 || nargout > 0)
             {
               warning_state = 0;
               retval(1) = prev_warning_id;
               retval(0) = prev_warning_message;
             }
         }
       else
-        error ("lastwarn: expecting arguments to be character strings");
+        error ("lastwarn: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__usage__, args, ,
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -552,28 +552,30 @@ do_stream_open (const std::string& name,
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
-  std::string name = tc_name.string_value ();
-
-  if (! error_state)
+  if (tc_name.is_string ())
     {
-      std::string mode = tc_mode.string_value ();
+      std::string name = tc_name.string_value ();
 
-      if (! error_state)
+      if (tc_mode.is_string ())
         {
-          std::string arch = tc_arch.string_value ();
+          std::string mode = tc_mode.string_value ();
 
-          if (! error_state)
-            retval = do_stream_open (name, mode, arch, fid);
+          if (tc_arch.is_string ())
+            {
+              std::string arch = tc_arch.string_value ();
+
+              retval = do_stream_open (name, mode, arch, fid);
+            }
           else
             ::error ("%s: architecture type must be a string", fcn);
         }
       else
         ::error ("%s: file mode must be a string", fcn);
     }
   else
     ::error ("%s: file name must be a string", fcn);
@@ -1366,37 +1368,37 @@ do_fread (octave_stream& os, const octav
   octave_value retval;
 
   count = -1;
 
   Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
     {
-      std::string prec = prec_arg.string_value ();
+      if (prec_arg.is_string ())
+        {
+          std::string prec = prec_arg.string_value ();
 
-      if (! error_state)
-        {
           int block_size = 1;
           oct_data_conv::data_type input_type;
           oct_data_conv::data_type output_type;
 
           oct_data_conv::string_to_data_type (prec, block_size,
                                               input_type, output_type);
 
           if (! error_state)
             {
               int skip = skip_arg.int_value (true);
 
               if (! error_state)
                 {
-                  std::string arch = arch_arg.string_value ();
+                  if (arch_arg.is_string ())
+                    {
+                      std::string arch = arch_arg.string_value ();
 
-                  if (! error_state)
-                    {
                       oct_mach_info::float_format flt_fmt
                         = oct_mach_info::string_to_float_format (arch);
 
                       if (! error_state)
                         retval = os.read (size, block_size, input_type,
                                           output_type, skip, flt_fmt, count);
                     }
                   else
@@ -1636,35 +1638,35 @@ The optional return value @var{count} co
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
   int retval = -1;
 
-  std::string prec = prec_arg.string_value ();
+  if (prec_arg.is_string ())
+    {
+      std::string prec = prec_arg.string_value ();
 
-  if (! error_state)
-    {
       int block_size = 1;
       oct_data_conv::data_type output_type;
 
       oct_data_conv::string_to_data_type (prec, block_size, output_type);
 
       if (! error_state)
         {
           int skip = skip_arg.int_value (true);
 
           if (! error_state)
             {
-              std::string arch = arch_arg.string_value ();
+              if (arch_arg.is_string ())
+                {
+                  std::string arch = arch_arg.string_value ();
 
-              if (! error_state)
-                {
                   oct_mach_info::float_format flt_fmt
                     = oct_mach_info::string_to_float_format (arch);
 
                   if (! error_state)
                     retval = os.write (data, block_size, output_type,
                                        skip, flt_fmt);
                 }
               else
@@ -1869,24 +1871,24 @@ endwhile\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
-          std::string mode = args(1).string_value ();
+          std::string name = args(0).string_value ();
 
-          if (! error_state)
+          if (args(1).is_string ())
             {
+              std::string mode = args(1).string_value ();
+
               if (mode == "r")
                 {
                   octave_stream ips = octave_iprocstream::create (name);
 
                   retval = octave_stream_list::insert (ips);
                 }
               else if (mode == "w")
                 {
@@ -1950,30 +1952,35 @@ see @code{tmpfile}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int len = args.length ();
 
   if (len < 3)
     {
-      std::string dir = len > 0 ? args(0).string_value () : std::string ();
-
-      if (! error_state)
+      std::string dir;
+      if (len > 0)
         {
-          std::string pfx
-            = len > 1 ? args(1).string_value () : std::string ("oct-");
+          if (args(0).is_string ())
+            dir = args(0).string_value ();
+          else
+            ::error ("DIR must be a string");
+        }
 
-          if (! error_state)
-            retval = octave_tempnam (dir, pfx);
+      std::string pfx ("oct-");
+      if (len > 1)
+        {
+          if (args(1).is_string ())
+            pfx = args(1).string_value ();
           else
             ::error ("PREFIX must be a string");
         }
-      else
-        ::error ("DIR argument must be a string");
+
+      retval = octave_tempnam (dir, pfx);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (tmpfile, args, ,
@@ -2056,20 +2063,20 @@ file, and @var{msg} is an empty string. 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string tmpl8 = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string tmpl8 = args(0).string_value ();
 
-      if (! error_state)
-        {
           OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
           strcpy (tmp, tmpl8.c_str ());
 
           int fd = gnulib::mkostemp (tmp, O_BINARY);
 
           if (fd < 0)
             {
               retval(2) = gnulib::strerror (errno);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -10741,22 +10741,23 @@ List @var{toolkit} as an available graph
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-        gtk_manager::register_toolkit (name);
+      if (args(0).is_string ())
+        {
+          std::string name = args(0).string_value ();
+          gtk_manager::register_toolkit (name);
+        }
       else
-        error ("register_graphics_toolkit: expecting character string");
+        error ("register_graphics_toolkit: TOOLKIT must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1361,37 +1361,34 @@ Undocumented internal function.\n\
   octave_value retval;
 
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
 
   if (args.length () == 0)
     retval = Cell (ffl.append (afl));
-  else
+  else if (args(0).is_string ())
     {
       std::string dir = args(0).string_value ();
 
+      string_vector fl = load_path::files (dir, true);
+
       if (! error_state)
         {
-          string_vector fl = load_path::files (dir, true);
+          // Return a sorted list with unique entries (in case of
+          // .m and .oct versions of the same function in a given
+          // directory, for example).
+          fl.sort (true);
 
-          if (! error_state)
-            {
-              // Return a sorted list with unique entries (in case of
-              // .m and .oct versions of the same function in a given
-              // directory, for example).
-              fl.sort (true);
-
-              retval = Cell (fl);
-            }
+          retval = Cell (fl);
         }
-      else
-        error ("__list_functions__: DIRECTORY argument must be a string");
     }
+  else
+    error ("__list_functions__: DIRECTORY argument must be a string");
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -832,21 +832,21 @@ string @samp{(yes or no) } to it.  The u
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       std::string prompt;
 
       if (nargin == 1)
         {
-          prompt = args(0).string_value ();
-
-          if (error_state)
+          if (args(0).is_string ())
+            prompt = args(0).string_value ();
+          else
             {
-              error ("yes_or_no: PROMPT must be a character string");
+              error ("yes_or_no: PROMPT must be a string");
               return retval;
             }
         }
 
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
@@ -1205,17 +1205,17 @@ the list of input hook functions.\n\
           if (input_event_hook_functions.empty ())
             command_editor::add_event_hook (internal_input_event_hook_fcn);
 
           input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
 
           retval = hook_fcn.id ();
         }
       else
-        error ("add_input_event_hook: expecting function handle or character string as first argument");
+        error ("add_input_event_hook: FCN must be a function handle or string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (remove_input_event_hook, args, ,
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2208,17 +2208,17 @@ exclude directories with those names.\n\
 
   if (nargin == 1)
     {
       std::string dirname = args(0).string_value ();
 
       if (! error_state)
         retval = genpath (dirname);
       else
-        error ("genpath: DIR must be a character string");
+        error ("genpath: DIR must be a string");
     }
   else if (nargin > 1)
     {
       std::string dirname = args(0).string_value ();
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
@@ -2227,17 +2227,17 @@ exclude directories with those names.\n\
 
           if (error_state)
             break;
         }
 
       if (! error_state)
         retval = genpath (dirname, skip);
       else
-        error ("genpath: all arguments must be character strings");
+        error ("genpath: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
@@ -2459,17 +2459,17 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
                     load_path::append (dir, true);
                   else
                     load_path::prepend (dir, true);
 
                   need_to_update = true;
                 }
             }
           else
-            error ("addpath: all arguments must be character strings");
+            error ("addpath: all arguments must be strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
@@ -2523,17 +2523,17 @@ rmpath (\"dir1:/dir2:~/dir3\")\n\
 
                   if (! load_path::remove (dir))
                     warning ("rmpath: %s: not found", dir.c_str ());
                   else
                     need_to_update = true;
                 }
             }
           else
-            error ("addpath: all arguments must be character strings");
+            error ("addpath: all arguments must be strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -208,28 +208,28 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
-              std::string str_typ = args(1).string_value ();
-
-              // FIXME: why do I have to explicitly call the constructor?
-              MatrixType mattyp = MatrixType ();
-
-              octave_idx_type nl = 0;
-              octave_idx_type nu = 0;
-
-              if (error_state)
+              if (! args(1).is_string ())
                 error ("matrix_type: TYPE must be a string");
               else
                 {
+                  std::string str_typ = args(1).string_value ();
+
+                  // FIXME: why do I have to explicitly call the constructor?
+                  MatrixType mattyp = MatrixType ();
+
+                  octave_idx_type nl = 0;
+                  octave_idx_type nu = 0;
+
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
                                   str_typ.begin (), tolower);
 
                   if (str_typ == "diagonal")
                     mattyp.mark_as_diagonal ();
                   if (str_typ == "permuted diagonal")
                     mattyp.mark_as_permuted_diagonal ();
@@ -411,25 +411,25 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
-              std::string str_typ = args(1).string_value ();
-
-              // FIXME: why do I have to explicitly call the constructor?
-              MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
-
-              if (error_state)
+              if (! args(1).is_string ())
                 error ("matrix_type: TYPE must be a string");
               else
                 {
+                  std::string str_typ = args(1).string_value ();
+
+                  // FIXME: why do I have to explicitly call the constructor?
+                  MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
                                   str_typ.begin (), tolower);
 
                   if (str_typ == "upper")
                     mattyp.mark_as_upper_triangular ();
                   else if (str_typ == "lower")
                     mattyp.mark_as_lower_triangular ();
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -397,17 +397,17 @@ compatibility with @sc{matlab}.\n\
 #endif
 
   // Determine ordering option.
   volatile char ord_job = 0;
   static double safmin;
 
   if (nargin == 2)
     ord_job = 'N';
-  else if (!args(2).is_string ())
+  else if (! args(2).is_string ())
     {
       error ("qz: OPT must be a string");
       return retval;
     }
   else
     {
       std::string tmp = args(2).string_value ();
 
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -184,22 +184,23 @@ parse_options (regexp::opts& options, co
                const std::string& who, int skip, bool& extra_args)
 {
   int nargin = args.length ();
 
   extra_args = false;
 
   for (int i = skip; i < nargin; i++)
     {
-      std::string str = args(i).string_value ();
+      std::string str;
 
-      if (error_state)
+      if (args(i).is_string ())
+        str = args(i).string_value ();
+      else
         {
-          error ("%s: optional arguments must be character strings",
-                 who.c_str ());
+          error ("%s: optional arguments must be strings", who.c_str ());
           break;
         }
 
       std::transform (str.begin (), str.end (), str.begin (), tolower);
 
       if (str.find ("once", 0) == 0)
         options.once (true);
       else if (str.find ("matchcase", 0) == 0)
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -138,19 +138,19 @@ Riccati equations in control (see @code{
     }
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
     {
-      ord = args(1).string_value ();
-
-      if (error_state)
+      if (args(1).is_string ())
+        ord = args(1).string_value ();
+      else
         {
           error ("schur: second argument must be a string");
           return retval;
         }
     }
 
   bool force_complex = false;
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -911,17 +911,17 @@ whos ans\n\
       print_usage ();
       return retval;
     }
 
   string_vector s = args(0).all_strings ();
 
   if (error_state)
     {
-      error ("list_in_columns: expecting cellstr or char array");
+      error ("list_in_columns: ARG must be a cellstr or char array");
       return retval;
     }
 
   int width = -1;
 
   if (nargin > 1 && ! args(1).is_empty ())
     {
       width = args(1).int_value ();
@@ -933,28 +933,20 @@ whos ans\n\
         }
     }
 
   std::string prefix;
 
   if (nargin > 2)
     {
       if (args(2).is_string ())
-        {
-          prefix = args(2).string_value ();
-
-          if (error_state)
-            {
-              error ("list_in_columns: PREFIX must be a character string");
-              return retval;
-            }
-        }
+        prefix = args(2).string_value ();
       else
         {
-          error ("list_in_columns: PREFIX must be a character string");
+          error ("list_in_columns: PREFIX must be a string");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
   s.list_in_columns (buf, width, prefix);
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1671,28 +1671,27 @@ need to recompiled.\n\
         default:
           retval = "none";
           break;
         }
     }
 
   if (nargin == 1)
     {
-      std::string sval = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
+          std::string sval = args(0).string_value ();
           if (sval == "all")
             Vignore_function_time_stamp = 2;
           else if (sval == "system")
             Vignore_function_time_stamp = 1;
           else if (sval == "none")
             Vignore_function_time_stamp = 0;
           else
-            error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
+            error ("ignore_function_time_stamp: argument must be \"all\", \"system\", or \"none\"");
         }
       else
         error ("ignore_function_time_stamp: expecting argument to be character string");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -185,20 +185,20 @@ error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string exec_file = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string exec_file = args(0).string_value ();
 
-      if (! error_state)
-        {
           string_vector exec_args;
 
           if (nargin == 2)
             {
               string_vector tmp = args(1).all_strings ();
 
               if (! error_state)
                 {
@@ -207,17 +207,17 @@ error message.\n\
                   exec_args.resize (len + 1);
 
                   exec_args[0] = exec_file;
 
                   for (int i = 0; i < len; i++)
                     exec_args[i+1] = tmp[i];
                 }
               else
-                error ("exec: arguments must be character strings");
+                error ("exec: all arguments must be strings");
             }
           else
             {
               exec_args.resize (1);
 
               exec_args[0] = exec_file;
             }
 
@@ -295,20 +295,20 @@ exit status, it will linger until Octave
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
-      std::string exec_file = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string exec_file = args(0).string_value ();
 
-      if (! error_state)
-        {
           string_vector arg_list;
 
           if (nargin >= 2)
             {
               string_vector tmp = args(1).all_strings ();
 
               if (! error_state)
                 {
@@ -317,17 +317,17 @@ exit status, it will linger until Octave
                   arg_list.resize (len + 1);
 
                   arg_list[0] = exec_file;
 
                   for (int i = 0; i < len; i++)
                     arg_list[i+1] = tmp[i];
                 }
               else
-                error ("popen2: arguments must be character strings");
+                error ("popen2: all arguments must be strings");
             }
           else
             {
               arg_list.resize (1);
 
               arg_list[0] = exec_file;
             }
 
@@ -362,17 +362,17 @@ exit status, it will linger until Octave
                       retval(1) = octave_stream_list::insert (is);
                       retval(0) = octave_stream_list::insert (os);
                     }
                   else
                     error (msg.c_str ());
                 }
             }
           else
-            error ("popen2: arguments must be character strings");
+            error ("popen2: all arguments must be strings");
         }
       else
         error ("popen2: COMMAND argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
@@ -1620,30 +1620,29 @@ Return the canonical name of file @var{f
 the empty string (\"\") is returned.\n\
 @seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
+          std::string name = args(0).string_value ();
           std::string msg;
 
           std::string result = octave_canonicalize_file_name (name, msg);
 
           retval(2) = msg;
           retval(1) = msg.empty () ? 0 : -1;
           retval(0) = result;
         }
       else
-        error ("canonicalize_file_name: NAME must be a character string");
+        error ("canonicalize_file_name: NAME must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static octave_value
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -631,20 +631,20 @@ string.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 1)
     {
-      std::string var = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string var = args(0).string_value ();
 
-      if (! error_state)
-        {
           std::string val = (nargin == 2
                              ? args(1).string_value () : std::string ());
 
           if (! error_state)
             octave_env::putenv (var, val);
           else
             error ("setenv: VALUE must be a string");
         }
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -458,20 +458,20 @@ Year (1970-).\n\
 @end table\n\
 @seealso{strptime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      std::string fmt = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string fmt = args(0).string_value ();
 
-      if (! error_state)
-        {
           octave_scalar_map map = args(1).scalar_map_value ();
 
           if (! error_state)
             {
               octave_base_tm tm = extract_tm (map);
 
               if (! error_state)
                 retval = tm.strftime (fmt);
@@ -514,24 +514,24 @@ position of last matched character plus 
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
-      std::string str = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
-          std::string fmt = args(1).string_value ();
+          std::string str = args(0).string_value ();
 
-          if (! error_state)
+          if (args(1).is_string ())
             {
+              std::string fmt = args(1).string_value ();
+
               octave_strptime t (str, fmt);
 
               retval(1) = t.characters_converted ();
               retval(0) = octave_value (mk_tm_map (t));
             }
           else
             error ("strptime: FMT must be a string");
         }
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1001,33 +1001,33 @@ command shell that is started to run the
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargin == 1 && nargout > 1);
 
       system_exec_type type = et_sync;
 
       if (nargin == 3)
         {
-          std::string type_str = args(2).string_value ();
+          if (args(2).is_string ())
+            {
+              std::string type_str = args(2).string_value ();
 
-          if (! error_state)
-            {
               if (type_str == "sync")
                 type = et_sync;
               else if (type_str == "async")
                 type = et_async;
               else
                 {
                   error ("system: TYPE must be \"sync\" or \"async\"");
                   return retval;
                 }
             }
           else
             {
-              error ("system: TYPE must be a character string");
+              error ("system: TYPE must be a string");
               return retval;
             }
         }
 
       if (nargin > 1)
         {
           return_output = args(1).is_true ();
 
@@ -1200,20 +1200,20 @@ multiple times.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string arg = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string arg = args(0).string_value ();
 
-      if (! error_state)
-        {
           bool add_mode = true;
 
           if (nargin == 2)
             {
               add_mode = args(1).bool_value ();
 
               if (error_state)
                 error ("atexit: FLAG argument must be a logical value");
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -345,57 +345,51 @@ urlwrite (\"http://www.google.com/search
       print_usage ();
       return retval;
     }
 
   std::string url = args(0).string_value ();
 
   if (error_state)
     {
-      error ("urlwrite: URL must be a character string");
+      error ("urlwrite: URL must be a string");
       return retval;
     }
 
   // name to store the file if download is succesful
+  // FIXME: Maybe use is_string () for better input validation.
   std::string filename = args(1).string_value ();
 
   if (error_state)
     {
-      error ("urlwrite: LOCALFILE must be a character string");
+      error ("urlwrite: LOCALFILE must be a string");
       return retval;
     }
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
       method = args(2).string_value ();
 
-      if (error_state)
-        {
-          error ("urlwrite: METHOD must be \"get\" or \"post\"");
-          return retval;
-        }
-
-      if (method != "get" && method != "post")
+      if (error_state || (method != "get" && method != "post"))
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       param = args(3).cellstr_value ();
 
       if (error_state)
         {
-          error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
+          error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of strings");
           return retval;
         }
 
-
       if (param.numel () % 2 == 1)
         {
           error ("urlwrite: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   // The file should only be deleted if it doesn't initially exist, we
@@ -493,54 +487,50 @@ s = urlread (\"http://www.google.com/sea
 @end deftypefn")
 {
   // Octave's return value
   octave_value_list retval;
 
   int nargin = args.length ();
 
   // verify arguments
-  if (nargin != 1  && nargin != 3)
+  if (nargin != 1 && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
+  // FIXME: Maybe use is_string () for better input validation.
   std::string url = args(0).string_value ();
 
   if (error_state)
     {
-      error ("urlread: URL must be a character string");
+      error ("urlread: URL must be a string");
       return retval;
     }
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 3)
     {
+      // FIXME: Maybe use is_string () for better input validation.
       method = args(1).string_value ();
 
-      if (error_state)
-        {
-          error ("urlread: METHOD must be \"get\" or \"post\"");
-          return retval;
-        }
-
-      if (method != "get" && method != "post")
+      if (error_state || (method != "get" && method != "post"))
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       param = args(2).cellstr_value ();
 
       if (error_state)
         {
-          error ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
+          error ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of strings");
           return retval;
         }
 
       if (param.numel () % 2 == 1)
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -387,20 +387,20 @@ name in the path.  If no files are found
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
-      std::string path = args(0).string_value ();
+      if (args(0).is_string ())
+        {
+          std::string path = args(0).string_value ();
 
-      if (! error_state)
-        {
           string_vector names = args(1).all_strings ();
 
           if (! error_state && names.length () > 0)
             {
               if (nargin == 2)
                 retval = search_path_for_file (path, names);
               else if (nargin == 3)
                 {
@@ -1033,17 +1033,17 @@ if @var{name} is not found.\n\
     {
       if (args(0).is_string ())
         {
           std::string nm = args(0).string_value ();
 
           if (! error_state)
             retval = octave_errno::lookup (nm);
           else
-            error ("errno: expecting character string argument");
+            error ("errno: expecting string argument");
         }
       else
         {
           int val = args(0).int_value ();
 
           if (! error_state)
             retval = octave_errno::set (val);
           else
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -145,16 +145,18 @@ extract_function (const octave_value& ar
                   const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
+      // FIXME: Should is_string () be used instead which will warn more
+      //        broadly about incorrect input?
       std::string s = arg.string_value ();
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       if (! error_state)
         {
@@ -336,24 +338,24 @@ do_isglobal (const octave_value_list& ar
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
-  std::string name = args(0).string_value ();
-
-  if (error_state)
+  if (! args(0).is_string ())
     {
       error ("isglobal: NAME must be a string");
       return retval;
     }
 
+  std::string name = args(0).string_value ();
+
   return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isglobal (@var{name})\n\
 Return true if @var{name} is a globally visible variable.\n\
 For example:\n\
@@ -941,17 +943,17 @@ set_internal_variable (std::string& var,
       if (! error_state)
         {
           if (empty_ok || ! sval.empty ())
             var = sval;
           else
             error ("%s: value must not be empty", nm);
         }
       else
-        error ("%s: expecting arg to be a character string", nm);
+        error ("%s: expecting arg to be a string", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -989,17 +991,17 @@ set_internal_variable (int& var, const o
                   var = i;
                   break;
                 }
             }
           if (i == nchoices)
             error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
         }
       else
-        error ("%s: expecting arg to be a character string", nm);
+        error ("%s: expecting arg to be a string", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 struct
@@ -2071,20 +2073,21 @@ Unlock the named function @var{fcn}.  If
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-        munlock (name);
+      if (args(0).is_string ())
+        {
+          std::string name = args(0).string_value ();
+          munlock (name);
+        }
       else
         error ("munlock: FCN must be a string");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
@@ -2107,20 +2110,21 @@ Return true if the named function @var{f
 named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
-
-      if (! error_state)
-        retval = mislocked (name);
+      if (args(0).is_string ())
+        {
+          std::string name = args(0).string_value ();
+          retval = mislocked (name);
+        }
       else
         error ("mislocked: FCN must be a string");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1592,23 +1592,23 @@ make_idx_args (const std::string& type,
                 if (vlist.length () == 1)
                   {
                     octave_value val = vlist(0);
 
                     if (val.is_string ())
                       subs_field(i) = val;
                     else
                       {
-                        error ("expecting character string argument for '.' index");
+                        error ("string argument required for '.' index");
                         return retval;
                       }
                   }
                 else
                   {
-                    error ("expecting single argument for '.' index");
+                    error ("only single argument permitted for '.' index");
                     return retval;
                   }
               }
               break;
 
             default:
               panic_impossible ();
               break;
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1058,17 +1058,17 @@ octave_class::all_strings (bool pad) con
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
           if (tmp(0).is_string ())
             retval = tmp(0).all_strings (pad);
           else
-            error ("cname/char method did not return a character string");
+            error ("cname/char method did not return a string");
         }
     }
   else
     error ("no char method defined for class %s", class_name ().c_str ());
 
   return retval;
 }
 
@@ -1918,17 +1918,17 @@ derived.\n\
               else
                 error ("class: '%s' is invalid as a class name in this context",
                        id.c_str ());
             }
           else
             error ("class: invalid call from outside class constructor or method");
         }
       else
-        error ("class: ID (class name) must be a character string");
+        error ("class: ID (class name) must be a string");
     }
 
   return retval;
 }
 
 /*
 %!assert (class (1.1), "double");
 %!assert (class (single (1.1)), "single");
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1845,20 +1845,21 @@ functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string nm = args(0).string_value ();
-
-      if (! error_state)
-        retval = make_fcn_handle (nm, nargin != 2);
+      if (args(0).is_string ())
+        {
+          std::string nm = args(0).string_value ();
+          retval = make_fcn_handle (nm, nargin != 2);
+        }
       else
         error ("str2func: FCN_NAME must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2045,19 +2045,20 @@ x = javaObject (\"java.lang.StringBuffer
   initialize_java ();
 
   if (! error_state)
     {
       JNIEnv *current_env = octave_java::thread_jni_env ();
 
       if (args.length () > 0)
         {
-          std::string classname = args(0).string_value ();
-          if (! error_state)
+          if (args(0).is_string ())
             {
+              std::string classname = args(0).string_value ();
+
               octave_value_list tmp;
               for (int i=1; i<args.length (); i++)
                 tmp(i-1) = args(i);
               retval = octave_java::do_javaObject (current_env, classname, tmp);
             }
           else
             error ("javaObject: CLASSNAME must be a string");
         }
@@ -2109,19 +2110,20 @@ equivalent\n\
   initialize_java ();
 
   if (! error_state)
     {
       JNIEnv *current_env = octave_java::thread_jni_env ();
 
       if (args.length () > 1)
         {
-          std::string methodname = args(0).string_value ();
-          if (! error_state)
+          if (args(0).is_string ())
             {
+              std::string methodname = args(0).string_value ();
+
               octave_value_list tmp;
               for (int i=2; i<args.length (); i++)
                 tmp(i-2) = args(i);
 
               if (args(1).is_java ())
                 {
                   octave_java *jobj = TO_JAVA (args(1));
                   retval = jobj->do_javaMethod (current_env, methodname, tmp);
@@ -2182,19 +2184,20 @@ equivalent\n\
   initialize_java ();
 
   if (! error_state)
     {
       JNIEnv *current_env = octave_java::thread_jni_env ();
 
       if (args.length () == 2)
         {
-          std::string name = args(1).string_value ();
-          if (! error_state)
+          if (args(1).is_string ())
             {
+              std::string name = args(1).string_value ();
+
               if (args(0).is_java ())
                 {
                   octave_java *jobj = TO_JAVA (args(0));
                   retval = jobj->do_java_get (current_env, name);
                 }
               else if (args(0).is_string ())
                 {
                   std::string cls = args(0).string_value ();
@@ -2244,19 +2247,20 @@ equivalent\n\
   initialize_java ();
 
   if (! error_state)
     {
       JNIEnv *current_env = octave_java::thread_jni_env ();
 
       if (args.length () == 3)
         {
-          std::string name = args(1).string_value ();
-          if (! error_state)
+          if (args(1).is_string ())
             {
+              std::string name = args(1).string_value ();
+
               if (args(0).is_java ())
                 {
                   octave_java *jobj = TO_JAVA (args(0));
                   retval = jobj->do_java_set (current_env, name, args(2));
                 }
               else if (args(0).is_string ())
                 {
                   std::string cls = args(0).string_value ();
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2869,36 +2869,34 @@ decode_subscripts (const char* name, con
       if (nel == 0)
         return;
 
       const Cell type = m.contents ("type");
       const Cell subs = m.contents ("subs");
 
       for (int k = 0; k < nel; k++)
         {
-          std::string item = type(k).string_value ();
-
-          if (! error_state)
+          if (type(k).is_string ())
             {
+              std::string item = type(k).string_value ();
               if (item == "{}")
                 type_string[k] = '{';
               else if (item == "()")
                 type_string[k] = '(';
               else if (item == ".")
                 type_string[k] = '.';
               else
                 {
                   error ("%s: invalid indexing type '%s'", name, item.c_str ());
                   return;
                 }
             }
           else
             {
-              error ("%s: expecting type(%d) to be a character string",
-                     name, k+1);
+              error ("%s: type(%d) must be a string", name, k+1);
               return;
             }
 
           octave_value_list idx_item;
 
           if (subs(k).is_string ())
             idx_item(0) = subs(k);
           else if (subs(k).is_cell ())
@@ -2911,18 +2909,17 @@ decode_subscripts (const char* name, con
                       && subs_cell(n).string_value () == ":")
                     idx_item(n) = octave_value(octave_value::magic_colon_t);
                   else
                     idx_item(n) = subs_cell(n);
                 }
             }
           else
             {
-              error ("%s: expecting subs(%d) to be a character string or cell array",
-                     name, k+1);
+              error ("%s: subs(%d) must be a string or cell array", name, k+1);
               return;
             }
 
           idx.push_back (idx_item);
         }
     }
   else
     error ("%s: second argument must be a structure with fields 'type' and 'subs'",
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -215,17 +215,17 @@ tree_index_expression::get_struct_index
         {
           octave_value t = df->rvalue1 ();
 
           if (! error_state)
             {
               if (t.is_string () && t.rows () == 1)
                 fn = t.string_value ();
               else
-                error ("dynamic structure field names must be character strings");
+                error ("dynamic structure field names must be strings");
             }
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -394,18 +394,18 @@
 %!error <Invalid call to fopen> fopen ()
 %!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1)
 
 %!error fclose (0)
 %!error <Invalid call to fclose> fclose (1, 2)
 
 %!assert (ischar (tempname ()))
 
-%!warning tempname (1);
-%!warning tempname ("foo", 1);
+%!error <DIR must be a string> tempname (1);
+%!error <PREFIX must be a string> tempname ("foo", 1);
 
 %!error <Invalid call to tempname> tempname (1, 2, 3)
 
 %!test
 %! type_list = ["char"; "char*1"; "integer*1"; "int8";
 %! "schar"; "signed char"; "uchar"; "unsigned char";
 %! "short"; "ushort"; "unsigned short"; "int";
 %! "uint"; "unsigned int"; "long"; "ulong"; "unsigned long";
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -281,21 +281,17 @@
 
 %!test
 %! setenv ("foobar", "baz");
 %! assert (getenv ("foobar"), "baz");
 
 %!error <Invalid call to setenv> setenv ()
 %!error <Invalid call to setenv> setenv ("foo", "bar", 1)
 
-%!test
-%! wns = warning ("query", "Octave:num-to-str");
-%! warning ("on", "Octave:num-to-str");
-%! fail ("setenv (1, 2)","warning");
-%! warning (wns.state, "Octave:num-to-str");
+%!error <VAR must be a string> setenv (1, 2)
 
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! if (ispc () && ! isunix ())
 %!   ## should be a drive letter
