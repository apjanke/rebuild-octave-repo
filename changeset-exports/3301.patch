# HG changeset patch
# User jwe
# Date 940392653 0
#      Wed Oct 20 04:10:53 1999 +0000
# Node ID 02866242d3aee76ea754534195827c719ccd33a8
# Parent  cfbe664b5ebfea687972ad4e3364ac131952422e
[project @ 1999-10-20 04:10:46 by jwe]

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,10 +1,13 @@
 1999-10-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* interpreter/munge-texi.cc: Strip the "-*- texinfo -*-" marker
+	when including help text.
+
 	* interpreter/Makefile.in ($(TEXINFO)): Depend on $(DOCSTRINGS).
 	($(DOCSTRINGS)): New rule.
 
 	* Makefile.in (dist, bin-dist): Use `$(MAKE) -C dir' instead of
 	`cd dir; $(MAKE); cd ..'.
 	(../BUGS, ../INSTALL.OCTAVE, $(SUBDIRS)) Likewise.
 
 	* interpreter/*.txi: Rename from *.txi.
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
--- a/doc/interpreter/munge-texi.cc
+++ b/doc/interpreter/munge-texi.cc
@@ -1,11 +1,12 @@
 #include <iostream.h>
 #include <fstream.h>
 #include <string>
+#include <cctype>
 #include <map>
 
 static const char doc_delim = '';
 
 static map<string, string> help_text;
 
 static void
 fatal (const string& msg)
@@ -109,17 +110,35 @@ process_texi_input_file (istream& is, os
 		  && (buf[i++] = (char) is.get ()) == '(')
 		{
 		  while ((c = is.get ()) != EOF && c != ')')
 		    symbol_name += (char) c;
 
 		  if (is.eof ())
 		    fatal ("end of file while reading @DOCSTRING command");
 		  else
-		    os << help_text[symbol_name];
+		    {
+		      string doc_string = help_text[symbol_name];
+
+		      int i = 0;
+		      while (doc_string[i] == ' ')
+			i++;
+
+		      if (doc_string.substr (i, 15) == "-*- texinfo -*-")
+			{
+			  i += 15;
+
+			  while (isspace (doc_string[i]))
+			    i++;
+
+			  os << doc_string.substr (i);
+			}
+		      else
+			os << doc_string;
+		    }
 		}
 	      else
 		{
 		  buf[i] = '\0';
 		  os << buf;
 
 		  if (buf[i - 1] == '\n')
 		    bol = true;
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -66,824 +66,153 @@ Daylight Savings Time flag.
 @item zone
 Time zone.
 @end table
 
 @noindent
 In the descriptions of the following functions, this structure is
 referred to as a @var{tm_struct}.
 
-@deftypefn {Loadable Function} {} time ()
-Return the current time as the number of seconds since the epoch.  The
-epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan
-1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the
-value returned by @code{time} was 856163706.
-@end deftypefn
+@DOCSTRING(time)
 
 @DOCSTRING(ctime)
 
-@deftypefn {Loadable Function} {} gmtime (@var{t})
-Given a value returned from time (or any nonnegative integer),
-return a time structure corresponding to CUT.  For example,
+@DOCSTRING(gmtime)
 
-@example
-@group
-gmtime (time ())
-     @result{} @{
-           usec = 0
-           year = 97
-           mon = 1
-           mday = 17
-           sec = 6
-           zone = CST
-           min = 15
-           wday = 1
-           hour = 7
-           isdst = 0
-           yday = 47
-         @}
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Loadable Function} {} localtime (@var{t})
-Given a value returned from time (or any nonnegative integer),
-return a time structure corresponding to the local time zone.
+@DOCSTRING(localtime)
 
-@example
-@group
-localtime (time ())
-     @result{} @{
-           usec = 0
-           year = 97
-           mon = 1
-           mday = 17
-           sec = 6
-           zone = CST
-           min = 15
-           wday = 1
-           hour = 1
-           isdst = 0
-           yday = 47
-         @}
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(mktime)
 
-@deftypefn {Loadable Function} {} mktime (@var{tm_struct})
-Convert a time structure corresponding to the local time to the number
-of seconds since the epoch.  For example,
-
-@example
-@group
-mktime (localtime (time ())
-     @result{} 856163706
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Function File} {} asctime (@var{tm_struct})
-Convert a time structure to a string using the following five-field
-format: Thu Mar 28 08:40:14 1996.  For example,
-
-@example
-@group
-asctime (localtime (time ())
-     @result{} "Mon Feb 17 01:15:06 1997\n"
-@end group
-@end example
-
-This is equivalent to @code{ctime (time ())}.
-@end deftypefn
+@DOCSTRING(asctime)
 
 @DOCSTRING(strftime)
 
 Most of the remaining functions described in this section are not
 patterned after the standard C library.  Some are available for
 compatiblity with @sc{Matlab} and others are provided because they are
 useful.
 
-@deftypefn {Function File} {} clock ()
-Return a vector containing the current year, month (1-12), day (1-31),
-hour (0-23), minute (0-59) and second (0-61).  For example,
-
-@example
-@group
-clock ()
-     @result{} [ 1993, 8, 20, 4, 56, 1 ]
-@end group
-@end example
+@DOCSTRING(clock)
 
-The function clock is more accurate on systems that have the
-@code{gettimeofday} function.
-@end deftypefn
-
-@deftypefn {Function File} {} date ()
-Return the date as a character string in the form DD-MMM-YY.  For
-example,
-
-@example
-@group
-date ()
-     @result{} "20-Aug-93"
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(date)
 
-@deftypefn {Function File} {} etime (@var{t1}, @var{t2})
-Return the difference (in seconds) between two time values returned from
-@code{clock}.  For example:
-
-@example
-t0 = clock ();
-# many computations later...
-elapsed_time = etime (clock (), t0);
-@end example
-
-@noindent
-will set the variable @code{elapsed_time} to the number of seconds since
-the variable @code{t0} was set.
-@end deftypefn
+@DOCSTRING(etime)
 
-@deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();
-Return the CPU time used by your Octave session.  The first output is
-the total time spent executing your process and is equal to the sum of
-second and third outputs, which are the number of CPU seconds spent
-executing in user mode and the number of CPU seconds spent executing in
-system mode, respectively.  If your system does not have a way to report
-CPU time usage, @code{cputime} returns 0 for each of its output values.
-Note that because Octave used some CPU time to start, it is reasonable
-to check to see if @code{cputime} works by checking to see if the total
-CPU time used is nonzero.
-@end deftypefn
-
-@deftypefn {Function File} {} is_leap_year (@var{year})
-Return 1 if the given year is a leap year and 0 otherwise.  If no
-arguments are provided, @code{is_leap_year} will use the current year.
-For example,
+@DOCSTRING(cputime)
 
-@example
-@group
-is_leap_year (2000)
-     @result{} 1
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Function File} {} tic ()
-@deftypefnx {Function File} {} toc ()
-These functions set and check a wall-clock timer.  For example,
+@DOCSTRING(is_leap_year)
 
-@example
-tic ();
-# many computations later...
-elapsed_time = toc ();
-@end example
-
-@noindent
-will set the variable @code{elapsed_time} to the number of seconds since
-the most recent call to the function @code{tic}.
-
-If you are more interested in the CPU time that your process used, you
-should use the @code{cputime} function instead.  The @code{tic} and
-@code{toc} functions report the actual wall clock time that elapsed
-between the calls.  This may include time spent processing other jobs or
-doing nothing at all.  For example,
+@DOCSTRING(tic)
 
-@example
-@group
-tic (); sleep (5); toc ()
-     @result{} 5
-t = cputime (); sleep (5); cputime () - t
-     @result{} 0
-@end group
-@end example
-
-@noindent
-(This example also illustrates that the CPU timer may have a fairly
-coarse resolution.)
-@end deftypefn
+@DOCSTRING(pause)
 
-@deftypefn {Built-in Function} {} pause (@var{seconds})
-Suspend the execution of the program.  If invoked without any arguments,
-Octave waits until you type a character.  With a numeric argument, it
-pauses for the given number of seconds.  For example, the following
-statement prints a message and then waits 5 seconds before clearing the
-screen.
+@DOCSTRING(sleep)
 
-@example
-@group
-fprintf (stderr, "wait please...\n");
-pause (5);
-clc;
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Built-in Function} {} sleep (@var{seconds})
-Suspend the execution of the program for the given number of seconds.
-@end deftypefn
-
-@deftypefn {Built-in Function} {} usleep (@var{microseconds})
-Suspend the execution of the program for the given number of
-microseconds.  On systems where it is not possible to sleep for periods
-of time less than one second, @code{usleep} will pause the execution for
-@code{round (@var{microseconds} / 1e6)} seconds.
-@end deftypefn
+@DOCSTRING(usleep)
 
 @node Filesystem Utilities, Controlling Subprocesses, Timing Utilities, System Utilities
 @section Filesystem Utilities
 
 Octave includes the following functions for renaming and deleting files,
 creating, deleting, and reading directories, and for getting information
 about the status of files.
 
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})
-Change the name of file @var{old} to @var{new}.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} unlink (@var{file})
-Delete @var{file}.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})
-Return names of the files in the directory @var{dir} as an array of
-strings.  If an error occurs, return an empty matrix in @var{files}.
+@DOCSTRING(rename)
 
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} mkdir (@var{dir})
-Create a directory named @var{dir}.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rmdir (@var{dir})
-Remove the directory named @var{dir}.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name})
-Create a FIFO special file.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
+@DOCSTRING(unlink)
 
-@c XXX FIXME XXX -- this needs to be explained, but I don't feel up to
-@c it just now...
-
-@deftypefn {Built-in Function} {} umask (@var{mask})
-Set the permission mask for file creation.  The parameter @var{mask} is
-interpreted as an octal number.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})
-@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})
-Return a structure @var{s} containing the following information about
-@var{file}.
-
-@table @code
-@item dev
-ID of device containing a directory entry for this file.
-
-@item ino
-File number of the file.
-
-@item modestr
-File mode, as a string of ten letters or dashes as would be returned by
-@kbd{ls -l}.
-
-@item nlink
-Number of links.
+@DOCSTRING(readdir)
 
-@item uid
-User ID of file's owner.
-
-@item gid
-Group ID of file's group.
-
-@item rdev
-ID of device for block or character special files.
-
-@item size
-Size in bytes.
+@DOCSTRING(mkdir)
 
-@item atime
-Time of last access in the same form as time values returned from
-@code{time}.  @xref{Timing Utilities}.
-
-@item mtime
-Time of last modification in the same form as time values returned from
-@code{time}.  @xref{Timing Utilities}.
-
-@item ctime
-Time of last file status change in the same form as time values returned from
-@code{time}.  @xref{Timing Utilities}.
-
-@item blksize
-Size of blocks in the file.
+@DOCSTRING(rmdir)
 
-@item blocks
-Number of blocks allocated for file.
-@end table
-
-If the call is successful @var{err} is 0 and @var{msg} is an empty
-string.  If the file does not exist, or some other error occurs, @var{s}
-is an empty matrix, @var{err} is @minus{}1, and @var{msg} contains the
-corresponding system error message.
-
-If @var{file} is a symbolic link, @code{stat} will return information
-about the actual file the is referenced by the link.  Use @code{lstat}
-if you want information about the symbolic link itself.
-
-For example,
+@DOCSTRING(mkfifo)
 
-@example
-@group
-[s, err, msg] = stat ("/vmlinuz")
-     @result{} s =
-        @{
-          atime = 855399756
-          rdev = 0
-          ctime = 847219094
-          uid = 0
-          size = 389218
-          blksize = 4096
-          mtime = 847219094
-          gid = 6
-          nlink = 1
-          blocks = 768
-          modestr = -rw-r--r--
-          ino = 9316
-          dev = 2049
-        @}
-     @result{} err = 0
-     @result{} msg = 
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(umask)
 
-@deftypefn {Built-in Function} {} glob (@var{pattern})
-Given an array of strings in @var{pattern}, return the list of file
-names that any of them, or an empty string if no patterns match.  Tilde
-expansion is performed on each of the patterns before looking for
-matching file names.  For example,
+@DOCSTRING(stat)
 
-@example
-@group
-glob ("/vm*")
-     @result{} "/vmlinuz"
-@end group
-@end example
-
-Note that multiple values are returned in a string matrix with the fill
-character set to ASCII NUL.
-@end deftypefn
-
-@deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})
-Return 1 or zero for each element of @var{string} that matches any of
-the elements of the string array @var{pattern}, using the rules of
-filename pattern matching.  For example,
-
-@example
-@group
-fnmatch ("a*b", ["ab"; "axyzb"; "xyzab"])
-     @result{} [ 1; 1; 0 ]
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(glob)
 
-@deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})
-Return the absolute name name of @var{file} if it can be found in
-@var{path}.  The value of @var{path} should be a colon-separated list of
-directories in the format described for the built-in variable
-@code{LOADPATH}.
-
-If the file cannot be found in the path, an empty matrix is returned.
-For example,
-
-@example
-file_in_path (LOADPATH, "nargchk.m")
-     @result{} "@value{OCTAVEHOME}/share/octave/2.0/m/general/nargchk.m"
-@end example
-@end deftypefn
+@DOCSTRING(file_in_path)
 
-@deftypefn {Built-in Function} {} tilde_expand (@var{string})
-Performs tilde expansion on @var{string}.  If @var{string} begins with a
-tilde character, (@samp{~}), all of the characters preceding the first
-slash (or all characters, if there is no slash) are treated as a
-possible user name, and the tilde and the following characters up to the
-slash are replaced by the home directory of the named user.  If the
-tilde is followed immediately by a slash, the tilde is replaced by the
-home directory of the user running Octave.  For example,
-
-@example
-@group
-tilde_expand ("~joeuser/bin")
-     @result{} "/home/joeuser/bin"
-tilde_expand ("~/bin")
-     @result{} "/home/jwe/bin"
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(tilde_expand)
 
 @node Controlling Subprocesses, Process ID Information, Filesystem Utilities, System Utilities
 @section Controlling Subprocesses
 
 Octave includes some high-level commands like @code{system} and
 @code{popen} for starting subprocesses.  If you want to run another
 program to perform some task and then look at its output, you will
 probably want to use these functions.
 
 Octave also provides several very low-level Unix-like functions which
 can also be used for starting subprocesses, but you should probably only
 use them if you can't find any way to do what you need with the
 higher-level functions.
 
-@deftypefn {Built-in Function} {} system (@var{string}, @var{return_output}, @var{type})
-Execute a shell command specified by @var{string}.  The second argument is optional.
-If @var{type} is @code{"async"}, the process is started in the
-background and the process id of the child process is returned
-immediately.  Otherwise, the process is started, and Octave waits until
-it exits.  If @var{type} argument is omitted, a value of @code{"sync"}
-is assumed.
-
-If two input arguments are given (the actual value of
-@var{return_output} is irrelevant) and the subprocess is started
-synchronously, or if @var{system} is called with one input argument and
-one or more output arguments, the output from the command is returned.
-Otherwise, if the subprocess is executed synchronously, it's output is
-sent to the standard output.  To send the output of a command executed
-with @var{system} through the pager, use a command like
-
-@example
-disp (system (cmd, 1));
-@end example
-
-@noindent
-or
-
-@example
-printf ("%s\n", system (cmd, 1));
-@end example
+@DOCSTRING(system)
 
-The @code{system} function can return two values.  The first is any
-output from the command that was written to the standard output stream,
-and the second is the output status of the command.  For example,
-
-@example
-[output, status] = system ("echo foo; exit 2");
-@end example
-
-@noindent
-will set the variable @code{output} to the string @samp{foo}, and the
-variable @code{status} to the integer @samp{2}.
-@end deftypefn
-
-@deftypefn {Built-in Function} {fid =} popen (@var{command}, @var{mode})
-Start a process and create a pipe.  The name of the command to run is
-given by @var{command}.  The file identifier corresponding to the input
-or output stream of the process is returned in @var{fid}.  The argument
-@var{mode} may be
-
-@table @code
-@item "r"
-The pipe will be connected to the standard output of the process, and
-open for reading.
-
-@item "w"
-The pipe will be connected to the standard input of the process, and
-open for writing.
-@end table
-
-For example,
+@DOCSTRING(popen)
 
-@example
-@group
-fid = popen ("ls -ltr / | tail -3", "r");
-while (isstr (s = fgets (fid)))
-  fputs (stdout, s);
-endwhile
-     @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
-     @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
-     @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Built-in Function} {} pclose (@var{fid})
-Close a file identifier that was opened by @code{popen}.  You may also
-use @code{fclose} for the same purpose.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})
-Start a subprocess with two-way communication.  The name of the process
-is given by @var{command}, and @var{args} is an array of strings
-containing options for the command.  The file identifiers for the input
-and output streams of the subprocess are returned in @var{in} and
-@var{out}.  If execution of the command is successful, @var{pid}
-contains the process ID of the subprocess.  Otherwise, @var{pid} is
-@minus{}1.
-
-For example,
+@DOCSTRING(pclose)
 
-@example
-@group
-[in, out, pid] = popen2 ("sort", "-nr");
-fputs (in, "these\nare\nsome\nstrings\n");
-fclose (in);
-while (isstr (s = fgets (out)))
-  fputs (stdout, s);
-endwhile
-fclose (out);
-     @print{} are
-     @print{} some
-     @print{} strings
-     @print{} these
-@end group
-@end example
-@end deftypefn
+@DOCSTRING(popen2)
 
-@defvr {Built-in Variable} EXEC_PATH
-The variable @code{EXEC_PATH} is a colon separated list of directories
-to search when executing subprograms.  Its initial value is taken from
-the environment variable @code{OCTAVE_EXEC_PATH} (if it exists) or
-@code{PATH}, but that value can be overridden by the command line
-argument @code{--exec-path PATH}, or by setting the value of
-@code{EXEC_PATH} in a startup script.  If the value of @code{EXEC_PATH}
-begins (ends) with a colon, the directories
-
-@example
-@group
-@var{octave-home}/libexec/octave/site/exec/@var{arch}
-@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}
-@end group
-@end example
-
-@noindent
-are prepended (appended) to @code{EXEC_PATH}, where @var{octave-home}
-is the top-level directory where all of Octave is installed
-(the default value is @file{@value{OCTAVEHOME}}).  If you don't specify
-a value for @code{EXEC_PATH} explicitly, these special directories are
-prepended to your shell path.
-@end defvr
+@DOCSTRING(EXEC_PATH)
 
 In most cases, the following functions simply decode their arguments and
 make the corresponding Unix system calls.  For a complete example of how
 they can be used, look at the definition of the function @code{popen2}.
 
-@deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()
-Create a copy of the current process.
-
-Fork can return one of the following values:
-
-@table @asis
-@item > 0
-You are in the parent process.  The value returned from @code{fork} is
-the process id of the child process.  You should probably arrange to
-wait for any child processes to exit.
-
-@item 0
-You are in the child process.  You can call @code{exec} to start another
-process.  If that fails, you should probably call @code{exit}.
-
-@item < 0
-The call to @code{fork} failed for some reason.  You must take evasive
-action.  A system dependent error message will be waiting in @var{msg}.
-@end table
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})
-Replace current process with a new process.  Calling @code{exec} without
-first calling @code{fork} will terminate your current Octave process and
-replace it with the program named by @var{file}.  For example,
-
-@example
-exec ("ls" "-l")
-@end example
-
-@noindent
-will run @code{ls} and return you to your shell prompt.
+@DOCSTRING(fork)
 
-If successful, @code{exec} does not return.  If @code{exec} does return,
-@var{err} will be nonzero, and @var{msg} will contain a system-dependent
-error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{file_ids}, @var{err}, @var{msg}] =} pipe ()
-Create a pipe and return the vector @var{file_ids}, which corresponding
-to the reading and writing ends of the pipe.
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})
-Duplicate a file descriptor.
+@DOCSTRING(exec)
 
-If successful, @var{fid} is greater than zero and contains the new file
-ID.  Otherwise, @var{fid} is negative and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} waitpid (@var{pid}, @var{options})
-Wait for process @var{pid} to terminate.  The @var{pid} argument can be:
-
-@table @asis
-@item @minus{}1
-Wait for any child process.
-
-@item 0
-Wait for any child process whose process group ID is equal to that of
-the Octave interpreter process.
-
-@item > 0
-Wait for termination of the child process with ID @var{pid}.
-@end table
-
-The @var{options} argument can be:
+@DOCSTRING(pipe)
 
-@table @asis
-@item 0
-Wait until signal is received or a child process exits (this is the
-default if the @var{options} argument is missing).
-
-@item 1
-Do not hang if status is not immediately available.
-
-@item 2
-Report the status of any child processes that are stopped, and whose
-status has not yet been reported since they stopped.
-
-@item 3
-Implies both 1 and 2.
-@end table
-
-If the returned value of @var{pid} is greater than 0, it is the process
-ID of the child process that exited.  If an error occurs, @var{pid} will
-be less than zero and @var{msg} will contain a system-dependent error
-message.
-@end deftypefn
-
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})
-Change the properties of the open file @var{fid}.  The following values
-may be passed as @var{request}:
-
-@vtable @code
-@item F_DUPFD
-Return a duplicate file descriptor.
-
-@item F_GETFD
-Return the file descriptor flags for @var{fid}.
-
-@item F_SETFD
-Set the file descriptor flags for @var{fid}.
+@DOCSTRING(dup2)
 
-@item F_GETFL
-Return the file status flags for @var{fid}.  The following codes may be
-returned (some of the flags may be undefined on some systems).
-
-@vtable @code
-@item O_RDONLY
-Open for reading only.
-
-@item O_WRONLY
-Open for writing only.
-
-@item O_RDWR
-Open for reading and writing.
-
-@item O_APPEND
-Append on each write.
+@DOCSTRING(waitpid)
 
-@item O_NONBLOCK
-Nonblocking mode.
-
-@item O_SYNC
-Wait for writes to complete.
-
-@item O_ASYNC
-Asynchronous I/O.
-@end vtable
-
-@item F_SETFL
-Set the file status flags for @var{fid} to the value specified by
-@var{arg}.  The only flags that can be changed are @code{O_APPEND} and
-@code{O_NONBLOCK}.
-@end vtable
-
-If successful, @var{err} is 0 and @var{msg} is an empty string.
-Otherwise, @var{err} is nonzero and @var{msg} contains a
-system-dependent error message.
-@end deftypefn
+@DOCSTRING(fcntl)
 
 @node Process ID Information, Environment Variables, Controlling Subprocesses, System Utilities
 @section Process, Group, and User IDs
 
-@deftypefn {Built-in Function} {} getpgrp ()
-Return the process group id of the current process.
-@end deftypefn
+@DOCSTRING(getpgrp)
 
-@deftypefn {Built-in Function} {} getpid ()
-Return the process id of the current process.
-@end deftypefn
+@DOCSTRING(getpid)
 
-@deftypefn {Built-in Function} {} getppid ()
-Return the process id of the parent process.
-@end deftypefn
+@DOCSTRING(getppid)
 
-@deftypefn {Built-in Function} {} geteuid ()
-Return the effective user id of the current process.
-@end deftypefn
+@DOCSTRING(geteuid)
 
-@deftypefn {Built-in Function} {} getuid ()
-Return the real user id of the current process.
-@end deftypefn
+@DOCSTRING(getuid)
 
-@deftypefn {Built-in Function} {} getegid ()
-Return the effective group id of the current process.
-@end deftypefn
+@DOCSTRING(getegid)
 
-@deftypefn {Built-in Function} {} getgid ()
-Return the real group id of the current process.
-@end deftypefn
+@DOCSTRING(getgid)
 
 @node Environment Variables, Current Working Directory, Process ID Information, System Utilities
 @section Environment Variables
 
-@deftypefn {Built-in Function} {} getenv (@var{var})
-Return the value of the environment variable @var{var}.  For example,
-
-@example
-getenv ("PATH")
-@end example
+@DOCSTRING(getenv)
 
-@noindent
-returns a string containing the value of your path.
-@end deftypefn
-
-@deftypefn {Built-in Function} {} putenv (@var{var}, @var{value})
-Set the value of the environment variable @var{var} to @var{value}.
-@end deftypefn
+@DOCSTRING(putenv)
 
 @node Current Working Directory, Password Database Functions, Environment Variables, System Utilities
 @section Current Working Directory
 
-@deffn {Command} cd dir
-@deffnx {Command} chdir dir
-Change the current working directory to @var{dir}.  For example,
-
-@example
-cd ~/octave
-@end example
-
-@noindent
-Changes the current working directory to @file{~/octave}.  If the
-directory does not exist, an error message is printed and the working
-directory is not changed.
-@end deffn
+@DOCSTRING(cd)
 
-@deftypefn {Built-in Function} {} pwd ()
-Return the current working directory.
-@end deftypefn
-
-@deffn {Command} ls options
-@deffnx {Command} dir options
-List directory contents.  For example,
+@DOCSTRING(ls)
 
-@example
-ls -l
-     @print{} total 12
-     @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
-     @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m
-@end example
-
-The @code{dir} and @code{ls} commands are implemented by calling your
-system's directory listing command, so the available options may vary
-from system to system.
-@end deffn
+@DOCSTRING(pwd)
 
 @node Password Database Functions, Group Database Functions, Current Working Directory, System Utilities
 @section Password Database Functions
 
 Octave's password database functions return information in a structure
 with the following fields.
 
 @table @code
@@ -907,41 +236,25 @@ The home directory.
 
 @item shell
 The initial shell.
 @end table
 
 In the descriptions of the following functions, this data structure is
 referred to as a @var{pw_struct}.
 
-@deftypefn {Loadable Function} {@var{pw_struct} = } getpwent ()
-Return a structure containing an entry from the password database,
-opening it if necessary. Once the end of the data has been reached,
-@code{getpwent} returns 0.
-@end deftypefn
+@DOCSTRING(getpwent)
 
-@deftypefn {Loadable Function} {@var{pw_struct} = } getpwuid (@var{uid}).
-Return a structure containing the first entry from the password database
-with the user ID @var{uid}.  If the user ID does not exist in the
-database, @code{getpwuid} returns 0.
-@end deftypefn
+@DOCSTRING(getpwuid)
 
-@deftypefn {Loadable Function} {@var{pw_struct} = } getpwnam (@var{name})
-Return a structure containing the first entry from the password database
-with the user name @var{name}.  If the user name does not exist in the
-database, @code{getpwname} returns 0.
-@end deftypefn
+@DOCSTRING(getpwnam)
 
-@deftypefn {Loadable Function} {} setpwent ()
-Return the internal pointer to the beginning of the password database.
-@end deftypefn
+@DOCSTRING(setpwent)
 
-@deftypefn {Loadable Function} {} endpwent ()
-Close the password database.
-@end deftypefn
+@DOCSTRING(endpwent)
 
 @node Group Database Functions, System Information, Password Database Functions, System Utilities
 @section Group Database Functions
 
 Octave's group database functions return information in a structure
 with the following fields.
 
 @table @code
@@ -956,133 +269,30 @@ The numeric group id.
 
 @item mem
 The members of the group.
 @end table
 
 In the descriptions of the following functions, this data structure is
 referred to as a @var{grp_struct}.
 
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()
-Return an entry from the group database, opening it if necessary.
-Once the end of the data has been reached, @code{getgrent} returns 0.
-@end deftypefn
-
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).
-Return the first entry from the group database with the group ID
-@var{gid}.  If the group ID does not exist in the database,
-@code{getgrgid} returns 0.
-@end deftypefn
+@DOCSTRING(getgrent)
 
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})
-Return the first entry from the group database with the group name
-@var{name}.  If the group name does not exist in the database,
-@code{getgrname} returns 0.
-@end deftypefn
+@DOCSTRING(getgrgid)
+         
+@DOCSTRING(getgrnam)
 
-@deftypefn {Loadable Function} {} setgrent ()
-Return the internal pointer to the beginning of the group database.
-@end deftypefn
+@DOCSTRING(setgrent)
 
-@deftypefn {Loadable Function} {} endgrent ()
-Close the group database.
-@end deftypefn
+@DOCSTRING(endgrent)
 
 @node System Information,  , Group Database Functions, System Utilities
 @section System Information
 
-@deftypefn {Built-in Function} {} computer ()
-Print or return a string of the form @var{cpu}-@var{vendor}-@var{os}
-that identifies the kind of computer Octave is running on.  If invoked
-with an output argument, the value is returned instead of printed.  For
-example,
-
-@example
-@group
-computer ()
-     @print{} i586-pc-linux-gnu
-
-x = computer ()
-     @result{} x = "i586-pc-linux-gnu"
-@end group
-@end example
-@end deftypefn
-
-@deftypefn {Built-in Function} {} isieee ()
-Return 1 if your computer claims to conform to the IEEE standard for
-floating point calculations.
-@end deftypefn
+@DOCSTRING(computer)
 
-@deftypefn {Built-in Function} {} version ()
-Return Octave's version number as a string.  This is also the value of
-the built-in variable @code{OCTAVE_VERSION}.
-@end deftypefn
-
-@defvr {Built-in Variable} OCTAVE_VERSION
-The version number of Octave, as a string.
-@end defvr
-
-@deftypefn {Built-in Function} {} octave_config_info ()
-Return a structure containing configuration and installation
-information.
-@end deftypefn
-
-@deftypefn {Loadable Function} {} getrusage ()
-Return a structure containing a number of statistics about the current
-Octave process.  Not all fields are available on all systems.  If it is
-not possible to get CPU time statistics, the CPU time slots are set to
-zero.  Other missing data are replaced by NaN.  Here is a list of all
-the possible fields that can be present in the structure returned by
-@code{getrusage}:
-
-@table @code
-@item 
-@item idrss
-Unshared data size.
+@DOCSTRING(isieee)
 
-@item inblock
-Number of block input operations.
-
-@item isrss
-Unshared stack size.
-
-@item ixrss
-Shared memory size.
-
-@item majflt
-Number of major page faults.
-
-@item maxrss
-Maximum data size.
-
-@item minflt
-Number of minor page faults.
-
-@item msgrcv
-Number of messages received.
-
-@item msgsnd
-Number of messages sent.
+@DOCSTRING(OCTAVE_VERSION)
 
-@item nivcsw
-Number of involuntary context switches.
-
-@item nsignals
-Number of signals received.
-
-@item nswap
-Number of swaps.
-
-@item nvcsw
-Number of voluntary context switches.
+@DOCSTRING(octave_config_info)
 
-@item oublock
-Number of block output operations.
-
-@item stime
-A structure containing the system CPU time used.  The structure has the
-elements @code{sec} (seconds) @code{usec} (microseconds).
-
-@item utime
-A structure containing the user CPU time used.  The structure has the
-elements @code{sec} (seconds) @code{usec} (microseconds).
-@end table
-@end deftypefn
+@DOCSTRING(getrusage)
diff --git a/examples/make_int.cc b/examples/make_int.cc
--- a/examples/make_int.cc
+++ b/examples/make_int.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996, 1997 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -23,24 +23,24 @@ Software Foundation, 59 Temple Place - S
 #include <octave/config.h>
 
 #include <cstdlib>
 
 #include <string>
 
 class ostream;
 
+#include <octave/lo-mappers.h>
 #include <octave/lo-utils.h>
 #include <octave/mx-base.h>
 #include <octave/str-vec.h>
 
 #include <octave/defun-dld.h>
 #include <octave/error.h>
 #include <octave/gripes.h>
-#include <octave/lo-mappers.h>
 #include <octave/oct-obj.h>
 #include <octave/ops.h>
 #include <octave/ov-base.h>
 #include <octave/ov-typeinfo.h>
 #include <octave/ov.h>
 #include <octave/ov-scalar.h>
 #include <octave/pager.h>
 #include <octave/pr-output.h>
@@ -80,18 +80,18 @@ public:
   idx_vector index_vector (void) const { return idx_vector ((double) scalar); }
 
   int rows (void) const { return 1; }
   int columns (void) const { return 1; }
 
   bool is_defined (void) const { return true; }
   bool is_real_scalar (void) const { return true; }
 
-  octave_value all (void) const { return (scalar != 0); }
-  octave_value any (void) const { return (scalar != 0); }
+  octave_value all (void) const { return (double) (scalar != 0); }
+  octave_value any (void) const { return (double) (scalar != 0); }
 
   bool is_real_type (void) const { return true; }
   bool is_scalar_type (void) const { return true; }
   bool is_numeric_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const
     { return scalar == 1; }
 
@@ -106,220 +106,135 @@ public:
 
   Matrix matrix_value (bool = false) const { return Matrix (1, 1, scalar); }
 
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
-  octave_value not (void) const { return octave_value (! scalar); }
+  octave_value not (void) const { return octave_value ((double) ! scalar); }
 
-  octave_value uminus (void) const { return octave_value (- scalar); }
+  octave_value uminus (void) const { return new octave_integer (- scalar); }
 
-  octave_value transpose (void) const { return octave_value (scalar); }
+  octave_value transpose (void) const { return new octave_integer (scalar); }
 
-  octave_value hermitian (void) const { return octave_value (scalar); }
+  octave_value hermitian (void) const { return new octave_integer (scalar); }
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
-  void print (ostream& os);
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
+  void print (ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   int scalar;
 
-  static int t_id;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
-int octave_integer::t_id = -1;
-
-const string octave_integer::t_name ("integer");
+void
+octave_integer::print (ostream& os, bool pr_as_read_syntax) const
+{
+  octave_print_internal (os, scalar, pr_as_read_syntax);
+}
 
-void
-octave_integer::print (ostream& os)
-{
-  octave_print_internal (os, scalar, false);
-}
+#ifdef DEFBINOP_OP
+#undef DEFBINOP_OP
+#endif
+
+#define DEFBINOP_OP(name, t1, t2, op) \
+  BINOPDECL (name, a1, a2) \
+  { \
+    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    return octave_value \
+      (new octave_integer (v1.t1 ## _value () op v2.t2 ## _value ())); \
+  }
 
 // integer by integer ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () + v2.integer_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+DEFBINOP_OP (add, integer, integer, +)
+DEFBINOP_OP (sub, integer, integer, -)
+DEFBINOP_OP (mul, integer, integer, *)
 
-  return new octave_integer (v1.integer_value () - v2.integer_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () * v2.integer_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, integer, integer)
 {
   CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
 
   int d = v2.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v1.integer_value () / d);
 }
 
-static octave_value
-i_s_div (const octave_value& a1, const octave_value& a2)
+
+DEFBINOP (i_s_div, integer, scalar)
 {
   CAST_BINOP_ARGS (const octave_integer&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return new octave_scalar (v1.double_value () / d);
 }
 
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, integer, integer)
 {
   CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
 
   int d = v1.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v2.integer_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () < v2.integer_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () <= v2.integer_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () == v2.integer_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+DEFBINOP_OP (lt, integer, integer, <)
+DEFBINOP_OP (le, integer, integer, <=)
+DEFBINOP_OP (eq, integer, integer, ==)
+DEFBINOP_OP (ge, integer, integer, >=)
+DEFBINOP_OP (gt, integer, integer, >)
+DEFBINOP_OP (ne, integer, integer, !=)
 
-  return new octave_integer (v1.integer_value () >= v2.integer_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () > v2.integer_value ());
-}
+DEFBINOP_OP (el_mul, integer, integer, !=)
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () != v2.integer_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () * v2.integer_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, integer, integer)
 {
   CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
 
   int d = v2.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v1.integer_value () / d);
 }
 
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, integer, integer)
 {
   CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
 
   int d = v1.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v2.integer_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () && v2.integer_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
-
-  return new octave_integer (v1.integer_value () || v2.integer_value ());
-}
+DEFBINOP_OP (el_and, integer, integer, &&)
+DEFBINOP_OP (el_or, integer, integer, ||)
 
 DEFUN_DLD (make_int, args, ,
   "int_val = make_int (val)\n\
 \n\
 Creates an integer variable from VAL.")
 {
   static bool type_loaded = false;
 
@@ -360,13 +275,40 @@ Creates an integer variable from VAL.")
 	retval = octave_value (new octave_integer (NINT (d)));
     }
   else
     usage ("make_int");
 
   return retval;
 }
 
+DEFUN_DLD (doit, args, ,
+  "doit (I)")
+{
+  octave_value_list retval;
+
+  if (args(0).type_name () == "integer")
+    {
+      // At this point, we know we have a handle for an octave_integer
+      // object, so we can peek at the representation and extract the
+      // data.
+
+      const octave_value& rep = args(0).get_rep ();
+
+      int my_value = ((const octave_integer&) rep) . integer_value ();
+
+      message ("doit", "your lucky number is: %d", my_value);
+    }
+  else
+    gripe_wrong_type_arg ("doit", args(0));
+
+  return retval;
+}
+
+DEFINE_OCTAVE_ALLOCATOR (octave_integer);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_integer, "integer");
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,21 @@
 1999-10-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* time/asctime.m: Texinfoize help text.
+	* time/clock.m: Ditto.
+	* time/date.m: Ditto.
+	* miscellaneous/cputime.m: Ditto.
+	* miscellaneous/etime.m: Ditto.
+	* miscellaneous/is_leap_year.m: Ditto.
+	* miscellaneous/popen2.m: Ditto.
+	* miscellaneous/version.m: Ditto.
+	* miscellaneous/tic.m: Ditto.
+	* miscellaneous/toc.m: Just refer to tic.m.
+
 	* Makefile.in (dist, bin-dist): Use `$(MAKE) -C dir' instead of
 	`cd dir; $(MAKE); cd ..'.
 	($(SUBDIRS)): Likewise.
 
 	* statistics/Makefile.in ($(SUBDIRS)): Likewise.
 
 	* statistics/Makefile.in (bin-dist): Use `$(MAKE) -C dir' instead
 	of `cd dir; $(MAKE)'.
diff --git a/scripts/miscellaneous/cputime.m b/scripts/miscellaneous/cputime.m
--- a/scripts/miscellaneous/cputime.m
+++ b/scripts/miscellaneous/cputime.m
@@ -12,19 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: cputime
-##
-## Get CPU time statistics.
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{total}, @var{user}, @var{system}] =} cputime ();
+## Return the CPU time used by your Octave session.  The first output is
+## the total time spent executing your process and is equal to the sum of
+## second and third outputs, which are the number of CPU seconds spent
+## executing in user mode and the number of CPU seconds spent executing in
+## system mode, respectively.  If your system does not have a way to report
+## CPU time usage, @code{cputime} returns 0 for each of its output values.
+## Note that because Octave used some CPU time to start, it is reasonable
+## to check to see if @code{cputime} works by checking to see if the total
+## CPU time used is nonzero.
+## @end deftypefn
 
 ## Author: jwe
 
 function [total, user, system] = cputime ()
 
   if (nargin != 0)
     warning ("cputime: ignoring extra arguments");
   endif
diff --git a/scripts/miscellaneous/etime.m b/scripts/miscellaneous/etime.m
--- a/scripts/miscellaneous/etime.m
+++ b/scripts/miscellaneous/etime.m
@@ -12,21 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: etime (t1, t0)
-##
-## Return the difference between t1 and t0 in seconds.  The arguments
-## are expected to be vectors in the form returned by clock ().
-##
+## -*- texinfo -*-
+## @deftypefn {Function File} {} etime (@var{t1}, @var{t2})
+## Return the difference (in seconds) between two time values returned from
+## @code{clock}.  For example:
+## 
+## @example
+## t0 = clock ();
+## # many computations later...
+## elapsed_time = etime (clock (), t0);
+## @end example
+## 
+## @noindent
+## will set the variable @code{elapsed_time} to the number of seconds since
+## the variable @code{t0} was set.
+## @end deftypefn
+
 ## See also: tic, toc, clock, cputime
 
 ## Author: jwe
 
 function secs = etime (t1, t0)
 
   if (nargin != 2)
     usage ("etime (t1, t0)");
diff --git a/scripts/miscellaneous/is_leap_year.m b/scripts/miscellaneous/is_leap_year.m
--- a/scripts/miscellaneous/is_leap_year.m
+++ b/scripts/miscellaneous/is_leap_year.m
@@ -12,20 +12,29 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: is_leap_year (year)
-##
-## Return 1 if the given year is a leap year; otherwise, return 0.
-## With no arguments, use the current year.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} is_leap_year (@var{year})
+## Return 1 if the given year is a leap year and 0 otherwise.  If no
+## arguments are provided, @code{is_leap_year} will use the current year.
+## For example,
+## 
+## @example
+## @group
+## is_leap_year (2000)
+##      @result{} 1
+## @end group
+## @end example
+## @end deftypefn
 
 ## Author: jwe
 
 function retval = is_leap_year (year)
 
   if (nargin > 1)
     usage ("is_leap_year (year)");
   endif
diff --git a/scripts/miscellaneous/popen2.m b/scripts/miscellaneous/popen2.m
--- a/scripts/miscellaneous/popen2.m
+++ b/scripts/miscellaneous/popen2.m
@@ -12,36 +12,44 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
-##
-## Start a subprocess with two-way communication.  COMMAND specifies
-## the name of the command to start.  ARGS is an array of strings
-## containing options for COMMAND.  IN and out are the file ids of the
-## input and streams for the subprocess, and PID is the process id of
-## the subprocess, or -1 if COMMAND could not be executed.
-##
-## Example:
-##
-##  [in, out, pid] = popen2 ("sort", "-nr");
-##  fputs (in, "these\n");
-##  fputs (in, "are\n");
-##  fputs (in, "some\n");
-##  fputs (in, "strings\n");
-##  fclose (in);
-##  while (isstr (s = fgets (out)))
-##    fputs (stdout, s);
-##  endwhile
-##  fclose (out);
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})
+## Start a subprocess with two-way communication.  The name of the process
+## is given by @var{command}, and @var{args} is an array of strings
+## containing options for the command.  The file identifiers for the input
+## and output streams of the subprocess are returned in @var{in} and
+## @var{out}.  If execution of the command is successful, @var{pid}
+## contains the process ID of the subprocess.  Otherwise, @var{pid} is
+## @minus{}1.
+## 
+## For example,
+## 
+## @example
+## @group
+## [in, out, pid] = popen2 ("sort", "-nr");
+## fputs (in, "these\nare\nsome\nstrings\n");
+## fclose (in);
+## while (isstr (s = fgets (out)))
+##   fputs (stdout, s);
+## endwhile
+## fclose (out);
+##      @print{} are
+##      @print{} some
+##      @print{} strings
+##      @print{} these
+## @end group
+## @end example
+## @end deftypefn
 
 ## Author: jwe
 
 function [in, out, pid] = popen2 (command, args)
 
   in = -1;
   out = -1;
   pid = -1;
diff --git a/scripts/miscellaneous/tic.m b/scripts/miscellaneous/tic.m
--- a/scripts/miscellaneous/tic.m
+++ b/scripts/miscellaneous/tic.m
@@ -12,21 +12,49 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: tic
-##
-## Set a wall-clock timer.
-##
-## See also: toc, clock, etime, cputime
+## @deftypefn {Function File} {} tic ()
+## @deftypefnx {Function File} {} toc ()
+## These functions set and check a wall-clock timer.  For example,
+## 
+## @example
+## tic ();
+## # many computations later...
+## elapsed_time = toc ();
+## @end example
+## 
+## @noindent
+## will set the variable @code{elapsed_time} to the number of seconds since
+## the most recent call to the function @code{tic}.
+## 
+## If you are more interested in the CPU time that your process used, you
+## should use the @code{cputime} function instead.  The @code{tic} and
+## @code{toc} functions report the actual wall clock time that elapsed
+## between the calls.  This may include time spent processing other jobs or
+## doing nothing at all.  For example,
+## 
+## @example
+## @group
+## tic (); sleep (5); toc ()
+##      @result{} 5
+## t = cputime (); sleep (5); cputime () - t
+##      @result{} 0
+## @end group
+## @end example
+## 
+## @noindent
+## (This example also illustrates that the CPU timer may have a fairly
+## coarse resolution.)
+## @end deftypefn
 
 ## Author: jwe
 
 function tic ()
 
   if (nargin != 0)
     warning ("tic: ignoring extra arguments");
   endif
diff --git a/scripts/miscellaneous/toc.m b/scripts/miscellaneous/toc.m
--- a/scripts/miscellaneous/toc.m
+++ b/scripts/miscellaneous/toc.m
@@ -12,22 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: toc
-##
-## Return the difference between the current wall-clock time and the
-## time that the function tic () was last called, in seconds.
-##
-## See also: tic, clock, etime, cputime
+## See tic.
 
 ## Author: jwe
 
 function secs = toc ()
 
   if (nargin != 0)
     warning ("toc: ignoring extra arguments");
   endif
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: version
-##
-## Return the Octave version number as a string.
-##
-## See also: OCTAVE_VERSION
+## -*- texinfo -*-
+## @deftypefn {Function File} {} version ()
+## Return Octave's version number as a string.  This is also the value of
+## the built-in variable @code{OCTAVE_VERSION}.
+## @end deftypefn
 
 ## Author: jwe
 
 function vs = version ()
 
   if (nargin != 0)
     warning ("version: ignoring extra arguments");
   endif
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -12,17 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: asctime (TMSTRUCT)
+## -*- texinfo -*-
+## @deftypefn {Function File} {} asctime (@var{tm_struct})
+## Convert a time structure to a string using the following five-field
+## format: Thu Mar 28 08:40:14 1996.  For example,
+## 
+## @example
+## @group
+## asctime (localtime (time ())
+##      @result{} "Mon Feb 17 01:15:06 1997\n"
+## @end group
+## @end example
+## 
+## This is equivalent to @code{ctime (time ())}.
+## @end deftypefn
 
 ## Author: jwe
 
 function retval = asctime (t)
 
   if (nargin == 1)
     retval = strftime ("%a %b %d %H:%M:%S %Y\n", t);
   else
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -12,21 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: clock ()
-##
-## Return current date and time in vector with elements
-##
-##   [ year, month, day-of-month, hour, minute, second ]
+## -*- texinfo -*-
+## @deftypefn {Function File} {} clock ()
+## Return a vector containing the current year, month (1-12), day (1-31),
+## hour (0-23), minute (0-59) and second (0-61).  For example,
+## 
+## @example
+## @group
+## clock ()
+##      @result{} [ 1993, 8, 20, 4, 56, 1 ]
+## @end group
+## @end example
+## 
+## The function clock is more accurate on systems that have the
+## @code{gettimeofday} function.
+## @end deftypefn
 
 ## Author: jwe
 
 function retval = clock ()
 
   tm = localtime (time ());
 
   retval = zeros (1, 6);
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -12,19 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: date ()
-##
-## Return current date in a string, in the form `18-Jul-94'.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} date ()
+## Return the date as a character string in the form DD-MMM-YY.  For
+## example,
+## 
+## @example
+## @group
+## date ()
+##      @result{} "20-Aug-93"
+## @end group
+## @end example
+## @end deftypefn
 
 ## Author: jwe
 
 function retval = date ()
 
   retval = strftime ("%d-%b-%Y", localtime (time ()));
 
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,37 @@
 1999-10-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* Makefile.in (stmp-pic): New target.
+	($(PICOBJS)): Depend on stmp-pic, not pic.
+
+	* ov.h (get_rep): New function.
+
+	* help.cc (display_help_text): Pass definitions for VERSION,
+	OCTAVE_HOME, and TARGETHOSTTYPE to makeinfo.
+
+	* DLD-FUNCTIONS/getgrent.cc: Texinfoize all doc strings.
+	* DLD-FUNCTIONS/getpwent.cc: Ditto.
+	* DLD-FUNCTIONS/getrusage.cc: Ditto.
+	* DLD-FUNCTIONS/time.cc: Ditto.
+
+	* defaults.cc (EXEC_PATH, OCTAVE_VERSION): Texinfoize doc strings.
+	* dirfns.cc (Fcd, Fls, Fpwd, Freaddir, Fmkdir, Frmdir, Frename,
+	Fglob, Ffnmatch): Ditto.
+	* file-io.cc (Fpopen, Fpclose, Fumask): Ditto.
+	* sysdep.cc (Fgetenv, Fputenv, Fpause, Fsleep, Fusleep, Fisieee,
+	Ftilde_expand): Ditto.
+	* toplev.cc (Fcomputer, Fsystem, Foctave_config_info): Ditto.
+	* utils.cc (Ffile_in_path): Ditto.
+	* syscalls.cc (Fdup2, Fexec, Ffcntl, Ffork, Fgetpgrp, Fgetpid,
+	Fgetppid, Fgetegid, Fgetgid, Fgeteuid, Fgetuid, Fmkfifo, Fpipe,
+	Fstat, Funlink, Fwaitpid, F): Ditto.
+	(Flstat): Refer to stat for doc.
+
+
 	* help.cc (looks_like_texinfo): New function.
 	(display_help_text): Use it to see if the doc string looks like
 	Texinfo source.  If so, use makeinfo to format the text before
 	displaying it.
 
 	* mkgendoc: New script.
 	* Makefile.in: Use it to create gendoc.cc, which is compiled and
 	run to create DOCSTRINGS file from sources.
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -60,19 +60,21 @@ mk_gr_map (const octave_group& gr)
     }
   else
     retval = 0.0;
 
   return retval;
 }
 
 DEFUN_DLD (getgrent, args, ,
- "getgrent ()\n\
-\n\
-Read an entry from the group-file stream, opening it if necessary.")
+ "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
+Return an entry from the group database, opening it if necessary.\n\
+Once the end of the data has been reached, @code{getgrent} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -85,19 +87,22 @@ Read an entry from the group-file stream
     }
   else
     print_usage ("getgrent");
 
   return retval;
 }
 
 DEFUN_DLD (getgrgid, args, ,
-  "getgrgid (GID)\n\
-\n\
-Search for a group entry with a matching group ID.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
+Return the first entry from the group database with the group ID\n\
+@var{gid}.  If the group ID does not exist in the database,\n\
+@code{getgrgid} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -122,19 +127,22 @@ Search for a group entry with a matching
     }
   else
     print_usage ("getgrgid");
 
   return retval;
 }
 
 DEFUN_DLD (getgrnam, args, ,
-  "getgrnam (NAME)\n\
-\n\
-Search for group entry with a matching group name.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
+Return the first entry from the group database with the group name\n\
+@var{name}.  If the group name does not exist in the database,\n\
+@code{getgrname} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -152,19 +160,20 @@ Search for group entry with a matching g
     }
   else
     print_usage ("getgrnam");
 
   return retval;
 }
 
 DEFUN_DLD (setgrent, args, ,
-  "setgrent ()\n\
-\n\
-Rewind the group-file stream.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} setgrent ()\n\
+Return the internal pointer to the beginning of the group database.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -177,19 +186,20 @@ Rewind the group-file stream.")
     }
   else
     print_usage ("setgrent");
 
   return retval;
 }
 
 DEFUN_DLD (endgrent, args, ,
-  "endgrent ()\n\
-\n\
-Close the group-file stream.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} endgrent ()\n\
+Close the group database.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -63,19 +63,22 @@ mk_pw_map (const octave_passwd& pw)
     }
   else
     retval = 0.0;
 
   return retval;
 }
 
 DEFUN_DLD (getpwent, args, ,
- "getpwent ()\n\
-\n\
-Read an entry from the password-file stream, opening it if necessary.")
+ "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{pw_struct} = } getpwent ()\n\
+Return a structure containing an entry from the password database,\n\
+opening it if necessary. Once the end of the data has been reached,\n\
+@code{getpwent} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -88,19 +91,22 @@ Read an entry from the password-file str
     }
   else
     print_usage ("getpwent");
 
   return retval;
 }
 
 DEFUN_DLD (getpwuid, args, ,
-  "getpwuid (UID)\n\
-\n\
-Search for a password entry with a matching user ID.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{pw_struct} = } getpwuid (@var{uid}).\n\
+Return a structure containing the first entry from the password database\n\
+with the user ID @var{uid}.  If the user ID does not exist in the\n\
+database, @code{getpwuid} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -125,19 +131,22 @@ Search for a password entry with a match
     }
   else
     print_usage ("getpwuid");
 
   return retval;
 }
 
 DEFUN_DLD (getpwnam, args, ,
-  "getpwnam (NAME)\n\
-\n\
-Search for password entry with a matching username.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{pw_struct} = } getpwnam (@var{name})\n\
+Return a structure containing the first entry from the password database\n\
+with the user name @var{name}.  If the user name does not exist in the\n\
+database, @code{getpwname} returns 0.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
@@ -155,19 +164,20 @@ Search for password entry with a matchin
     }
   else
     print_usage ("getpwnam");
 
   return retval;
 }
 
 DEFUN_DLD (setpwent, args, ,
-  "setpwent ()\n\
-\n\
-Rewind the password-file stream.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} setpwent ()\n\
+Return the internal pointer to the beginning of the password database.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -180,19 +190,20 @@ Rewind the password-file stream.")
     }
   else
     print_usage ("setpwent");
 
   return retval;
 }
 
 DEFUN_DLD (endpwent, args, ,
-  "endpwent ()\n\
-\n\
-Close the password-file stream.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} endpwent ()\n\
+Close the password database.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -62,19 +62,77 @@ Software Foundation, 59 Temple Place - S
 
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
 DEFUN_DLD (getrusage, , ,
-  "getrusage ()\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} getrusage ()\n\
+Return a structure containing a number of statistics about the current\n\
+Octave process.  Not all fields are available on all systems.  If it is\n\
+not possible to get CPU time statistics, the CPU time slots are set to\n\
+zero.  Other missing data are replaced by NaN.  Here is a list of all\n\
+the possible fields that can be present in the structure returned by\n\
+@code{getrusage}:\n\
+\n\
+@table @code\n\
+@item idrss\n\
+Unshared data size.\n\
+\n\
+@item inblock\n\
+Number of block input operations.\n\
+\n\
+@item isrss\n\
+Unshared stack size.\n\
+\n\
+@item ixrss\n\
+Shared memory size.\n\
+\n\
+@item majflt\n\
+Number of major page faults.\n\
+\n\
+@item maxrss\n\
+Maximum data size.\n\
+\n\
+@item minflt\n\
+Number of minor page faults.\n\
 \n\
-Return system resource statistics.")
+@item msgrcv\n\
+Number of messages received.\n\
+\n\
+@item msgsnd\n\
+Number of messages sent.\n\
+\n\
+@item nivcsw\n\
+Number of involuntary context switches.\n\
+\n\
+@item nsignals\n\
+Number of signals received.\n\
+\n\
+@item nswap\n\
+Number of swaps.\n\
+\n\
+@item nvcsw\n\
+Number of voluntary context switches.\n\
+\n\
+@item oublock\n\
+Number of block output operations.\n\
+\n\
+@item stime\n\
+A structure containing the system CPU time used.  The structure has the\n\
+elements @code{sec} (seconds) @code{usec} (microseconds).\n\
+\n\
+@item utime\n\
+A structure containing the user CPU time used.  The structure has the\n\
+elements @code{sec} (seconds) @code{usec} (microseconds).\n\
+@end table\n\
+@end deftypefn")
 {
   Octave_map m;
   Octave_map tv_tmp;
 
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -71,37 +71,59 @@ extract_tm (Octave_map &m)
   tm.yday (static_cast<int> (m ["yday"] . double_value ()));
   tm.isdst (static_cast<int> (m ["isdst"] . double_value ()));
   tm.zone (m ["zone"] . string_value ());
 
   return tm;
 }
 
 DEFUN_DLD (time, args, ,
-  "time ()\n\
-\n\
-Return current time.  On Unix systems, this is the number of\n\
-seconds since the epoch.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} time ()\n\
+Return the current time as the number of seconds since the epoch.  The\n\
+epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
+1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the\n\
+value returned by @code{time} was 856163706.\n\
+@end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = static_cast<double> (octave_time ());
   else
     print_usage ("time");
 
   return retval;
 }
 
 DEFUN_DLD (gmtime, args, ,
-  "gmtime (TIME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} gmtime (@var{t})\n\
+Given a value returned from time (or any nonnegative integer),\n\
+return a time structure corresponding to CUT.  For example,\n\
 \n\
-Given a value returned from time(), return a structure like that\n\
-returned from localtime() but with values corresponding to\n\
-Coordinated Universal Time (UTC).")
+@example\n\
+@group\n\
+gmtime (time ())\n\
+     @result{} @{\n\
+           usec = 0\n\
+           year = 97\n\
+           mon = 1\n\
+           mday = 17\n\
+           sec = 6\n\
+           zone = CST\n\
+           min = 15\n\
+           wday = 1\n\
+           hour = 7\n\
+           isdst = 0\n\
+           yday = 47\n\
+         @}\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
@@ -109,32 +131,40 @@ Coordinated Universal Time (UTC).")
     }
   else
     print_usage ("gmtime");
 
   return retval;
 }
 
 DEFUN_DLD (localtime, args, ,
-  "localtime (TIME)\n\
-\n\
-Given a value returned from time(), return a structure with\n\
-the following elements:\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} localtime (@var{t})\n\
+Given a value returned from time (or any nonnegative integer),\n\
+return a time structure corresponding to the local time zone.\n\
 \n\
-  usec  : microseconds after the second (0, 999999)\n\
-  sec   : seconds after the minute (0, 61)\n\
-  min   : minutes after the hour (0, 59)\n\
-  hour  : hours since midnight (0, 23)\n\
-  mday  : day of the month (1, 31)\n\
-  mon   : months since January (0, 11)\n\
-  year  : years since 1900\n\
-  wday  : days since Sunday (0, 6)\n\
-  yday  : days since January 1 (0, 365)\n\
-  isdst : daylight savings time flag\n\
-  zone  : time zone")
+@example\n\
+@group\n\
+localtime (time ())\n\
+     @result{} @{\n\
+           usec = 0\n\
+           year = 97\n\
+           mon = 1\n\
+           mday = 17\n\
+           sec = 6\n\
+           zone = CST\n\
+           min = 15\n\
+           wday = 1\n\
+           hour = 1\n\
+           isdst = 0\n\
+           yday = 47\n\
+         @}\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
@@ -142,17 +172,28 @@ the following elements:\n\
     }
   else
     print_usage ("localtime");
 
   return retval;
 }
 
 DEFUN_DLD (mktime, args, ,
-  "mktime (TMSTRUCT)")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} mktime (@var{tm_struct})\n\
+Convert a time structure corresponding to the local time to the number\n\
+of seconds since the epoch.  For example,\n\
+\n\
+@example\n\
+@group\n\
+mktime (localtime (time ())\n\
+     @result{} 856163706\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       Octave_map map = args(0).map_value ();
 
       if (! error_state)
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -218,16 +218,24 @@ stamp-prereq: defaults.h oct-conf.h
 octave: octave.o builtins.o ops.o $(DLD_STATIC_OBJ) libraries
 	$(CXX) $(CPPFLAGS) $(ALL_CXXFLAGS) $(RDYNAMIC_FLAG) \
 	$(ALL_LDFLAGS) -o octave \
 	octave.o builtins.o ops.o $(DLD_STATIC_OBJ) \
 	$(OCTAVE_LFLAGS) \
 	$(OCTAVE_LIBS) \
 	$(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS)
 
+stmp-pic: pic
+	@if [ -f stmp-pic ]; then \
+	  true; \
+	else \
+	  echo "touch stmp-pic"; \
+	  touch stmp-pic; \
+	fi
+
 pic:
 	@if [ -d pic ]; then \
 	  true; \
 	else \
 	  echo "mkdir pic"; \
 	  mkdir pic; \
 	fi
 
@@ -252,17 +260,17 @@ liboctinterp.$(LIBEXT): $(OBJECTS)
 
 liboctinterp.$(SHLEXT): liboctinterp.$(SHLEXT_VER)
 	rm -f $@
 	$(LN_S) $< $@
 
 liboctinterp.$(SHLEXT_VER): $(PICOBJ)
 	$(SH_LD) $(SH_LDFLAGS) $(SONAME_FLAGS) -o $@ $^
 
-$(PICOBJ): pic
+$(PICOBJ): stmp-pic
 
 builtins.cc: $(DEF_FILES) mkbuiltins
 	@echo making $@
 	@echo DEF_FILES = $(DEF_FILES)
 	@echo VAR_FILES = $(VAR_FILES)
 	@echo $(DEF_FILES) > def-files
 	@echo $(VAR_FILES) > var-files
 	@$(srcdir)/mkbuiltins def-files var-files > $@.t
@@ -367,25 +375,23 @@ uninstall:
 
 tags: $(SOURCES) $(DLD_SRC)
 	ctags $(SOURCES) $(DLD_SRC)
 
 TAGS: $(SOURCES) $(DLD_SRC)
 	etags $(SOURCES) $(DLD_SRC)
 
 clean:
-	rm -f *.$(LIBEXT) *.o *.d *.df *.oct pic/*.o
+	rm -f *.$(LIBEXT) *.o *.d *.df *.oct pic/*.o stmp-pic
 	rm -f builtins.cc ops.cc defaults.h oct-conf.h def-files var-files
 	-rmdir pic
 	if $(SHARED_LIBS); then rm -f *.$(SHLEXT_VER) *.$(SHLEXT); fi
 .PHONY: clean
 
-mostlyclean:
-	rm -f *.o pic/*.o
-	-rmdir pic
+mostlyclean: clean
 .PHONY: mostlyclean
 
 distclean: clean
 	rm -f Makefile octave .fname so_locations
 	rm -f stamp-prereq stamp-oct-links
 .PHONY: distclean
 
 maintainer-clean: distclean
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -414,17 +414,40 @@ loadpath (void)
 
 void
 symbols_of_defaults (void)
 {
   DEFVAR (EDITOR, Veditor, editor,
     "name of the editor to be invoked by the edit_history command");
 
   DEFVAR (EXEC_PATH, Vexec_path, exec_path,
-    "colon separated list of directories to search for programs to run");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} EXEC_PATH\n\
+The variable @code{EXEC_PATH} is a colon separated list of directories\n\
+to search when executing subprograms.  Its initial value is taken from\n\
+the environment variable @code{OCTAVE_EXEC_PATH} (if it exists) or\n\
+@code{PATH}, but that value can be overridden by the command line\n\
+argument @code{--exec-path PATH}, or by setting the value of\n\
+@code{EXEC_PATH} in a startup script.  If the value of @code{EXEC_PATH}\n\
+begins (ends) with a colon, the directories\n\
+\n\
+@example\n\
+@group\n\
+@var{octave-home}/libexec/octave/site/exec/@var{arch}\n\
+@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}\n\
+@end group\n\
+@end example\n\
+\n\
+@noindent\n\
+are prepended (appended) to @code{EXEC_PATH}, where @var{octave-home}\n\
+is the top-level directory where all of Octave is installed\n\
+(the default value is @file{@value{OCTAVEHOME}}).  If you don't specify\n\
+a value for @code{EXEC_PATH} explicitly, these special directories are\n\
+prepended to your shell path.\n\
+@end defvr");
 
   DEFVAR (LOADPATH, Vload_path, loadpath,
     "colon separated list of directories to search for scripts.\n\
 The default value is \":\", which means to search the default list\n\
 of directories.  The default list of directories may be found in\n\
 the built-in constant DEFAULT_LOADPATH");
 
   DEFCONST (DEFAULT_LOADPATH, Vdefault_load_path,
@@ -432,17 +455,20 @@ the built-in constant DEFAULT_LOADPATH")
   
   DEFVAR (IMAGEPATH, OCTAVE_IMAGEPATH, imagepath,
     "colon separated list of directories to search for image files");
 
   DEFCONST (OCTAVE_HOME, Voctave_home,
     "top-level Octave installation directory");
 
   DEFCONSTX ("OCTAVE_VERSION", SBV_OCTAVE_VERSION, OCTAVE_VERSION,
-    "Octave version");
+    "-*- texinfo -*-\n\
+@defvr\n\
+The version number of Octave, as a string.\n\
+@end defvr");
 }
 
 DEFUN (rehash, , ,
   "rehash (): reinitialize LOADPATH directory cache")
 {
   octave_value_list retval;
 
   Vload_path_dir_path.rehash ();
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -75,21 +75,32 @@ octave_change_to_directory (const string
     do_external_plotter_cd (newdir);
   else
     error ("%s: %s", newdir.c_str (), strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN_TEXT (cd, args, ,
-  "cd [dir]\n\
+  "-*- texinfo -*-\n\
+@deffn {Command} cd dir\n\
+@deffnx {Command} chdir dir\n\
+Change the current working directory to @var{dir}.  If @var{dir} is\n\
+omitted, the current directory is changed to the users home\n\
+directory.  For example,\n\
 \n\
-change current working directory\n\
-if no arguments are given, the current directory is changed to the\n\
-users home directory")
+@example\n\
+cd ~/octave\n\
+@end example\n\
+\n\
+@noindent\n\
+Changes the current working directory to @file{~/octave}.  If the\n\
+directory does not exist, an error message is printed and the working\n\
+directory is not changed.\n\
+@end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("cd");
 
   if (error_state)
@@ -122,19 +133,32 @@ DEFALIAS (chdir, cd);
 
 static void
 cleanup_iprocstream (void *p)
 {
   delete static_cast <iprocstream *> (p);
 }
 
 DEFUN_TEXT (ls, args, ,
-  "ls [options]\n\
+  "-*- texinfo -*-\n\
+@deffn {Command} ls options\n\
+@deffnx {Command} dir options\n\
+List directory contents.  For example,\n\
 \n\
-print a directory listing")
+@example\n\
+ls -l\n\
+     @print{} total 12\n\
+     @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m\n\
+     @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m\n\
+@end example\n\
+\n\
+The @code{dir} and @code{ls} commands are implemented by calling your\n\
+system's directory listing command, so the available options may vary\n\
+from system to system.\n\
+@end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("ls");
 
   if (error_state)
@@ -189,17 +213,20 @@ print a directory listing")
   unwind_protect::run ();
 
   return retval;
 }
 
 DEFALIAS (dir, ls);
 
 DEFUN (pwd, , nargout,
-  "pwd (): print current working directory")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} pwd ()\n\
+Return the current working directory.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   string directory = octave_env::getcwd ();
 
   if (directory.empty ())
     warning ("pwd: can't find working directory!");
   else
@@ -209,23 +236,25 @@ DEFUN (pwd, , nargout,
       else
 	retval = directory;
     }
 
   return retval;
 }
 
 DEFUN (readdir, args, ,
-  "[FILES, STATUS, MSG] = readdir (NAME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
+Return names of the files in the directory @var{dir} as an array of\n\
+strings.  If an error occurs, return an empty matrix in @var{files}.\n\
 \n\
-Return an array of strings containing the list of all files in the\n\
-named directory in FILES, or an empty matrix if an error occurs\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = string ();
   retval(1) = -1.0;
   retval(0) = Matrix ();
 
   if (args.length () == 1)
@@ -255,22 +284,24 @@ STATUS is nonzero and MSG contains a sys
 
   return retval;
 }
 
 // XXX FIXME XXX -- should probably also allow second arg to specify
 // mode.
 
 DEFUN (mkdir, args, ,
-  "[STATUS, MSG] = mkdir (NAME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} mkdir (@var{dir})\\n\
+Create a directory named @var{dir}.\n\
 \n\
-Create the directory named by NAME.\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   if (args.length () == 1)
     {
@@ -293,22 +324,24 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("mkdir");
 
   return retval;
 }
 
 DEFUN (rmdir, args, ,
-  "[STATUS, MSG] = rmdir (NAME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rmdir (@var{dir})\n\
+Remove the directory named @var{dir}.\n\
 \n\
-Remove the directory named by NAME.\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   if (args.length () == 1)
     {
@@ -330,22 +363,24 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("rmdir");
 
   return retval;
 }
 
 DEFUN (rename, args, ,
-  "[STATUS, MSG] = rename (FROM, TO)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
+Change the name of file @var{old} to @var{new}.\n\
 \n\
-Rename a file.\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
@@ -374,22 +409,33 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("rename");
 
   return retval;
 }
 
 DEFUN (glob, args, ,
-  "glob (PATTERN)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} glob (@var{pattern})\n\
+Given an array of strings in @var{pattern}, return the list of file\n\
+names that any of them, or an empty string if no patterns match.  Tilde\n\
+expansion is performed on each of the patterns before looking for\n\
+matching file names.  For example,\n\
 \n\
-Given an array of strings in PATTERN, return the list of file names\n\
-that any of them, or an empty string if no patterns match.  Tilde\n\
-expansion is performed on each of the patterns before looking for\n\
-matching file names.")
+@example\n\
+@group\n\
+glob (\"/vm*\")\n\
+     @result{} \"/vmlinuz\"\n\
+@end group\n\
+@end example\n\
+\n\
+Note that multiple values are returned in a string matrix with the fill\n\
+character set to ASCII NUL.\n\
+@end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       string_vector pat = args(0).all_strings ();
 
       if (error_state)
@@ -408,21 +454,29 @@ matching file names.")
     }
   else
     print_usage ("glob");
 
   return retval;
 }
 
 DEFUN (fnmatch, args, ,
-  "fnmatch (PATTERN, STRING)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
+Return 1 or zero for each element of @var{string} that matches any of\n\
+the elements of the string array @var{pattern}, using the rules of\n\
+filename pattern matching.  For example,\n\
 \n\
-Return 1 or zero for each element of STRING that matches any of the\n\
-elements of the string array PATTERN, using the rules of filename\n\
-pattern matching.")
+@example\n\
+@group\n\
+fnmatch (\"a*b\", [\"ab\"; \"axyzb\"; \"xyzab\"])\n\
+     @result{} [ 1; 1; 0 ]\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       string_vector pat = args(0).all_strings ();
       string_vector str = args(1).all_strings ();
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1200,22 +1200,47 @@ DEFUN (ferror, args, ,
     }
   else
     print_usage ("ferror");
 
   return retval;
 }
 
 DEFUN (popen, args, ,
-  "FILENUM = popen (FILENAME, MODE)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {fid =} popen (@var{command}, @var{mode})\n\
+Start a process and create a pipe.  The name of the command to run is\n\
+given by @var{command}.  The file identifier corresponding to the input\n\
+or output stream of the process is returned in @var{fid}.  The argument\n\
+@var{mode} may be\n\
+\n\
+@table @code\n\
+@item \"r\"\n\
+The pipe will be connected to the standard output of the process, and\n\
+open for reading.\n\
 \n\
-  start a process and create a pipe.  Valid values for mode are:\n\
+@item \"w\"\n\
+The pipe will be connected to the standard input of the process, and\n\
+open for writing.\n\
+@end table\n\
+\n\
+For example,\n\
 \n\
-  \"r\" : connect stdout of process to pipe\n\
-  \"w\" : connect stdin of process to pipe")
+@example\n\
+@group\n\
+fid = popen (\"ls -ltr / | tail -3\", \"r\");\n\
+while (isstr (s = fgets (fid)))\n\
+  fputs (stdout, s);\n\
+endwhile\n\
+     @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
+     @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
+     @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       string name = args(0).string_value ();
@@ -1249,19 +1274,21 @@ DEFUN (popen, args, ,
     }
   else
     print_usage ("popen");
 
   return retval;
 }
 
 DEFUN (pclose, args, ,
-  "pclose (FILENUM)\n\
-\n\
-  Close a pipe and terminate the associated process")
+  "-*- texifno -*-\n\
+@deftypefn {Built-in Function} {} pclose (@var{fid})\n\
+Close a file identifier that was opened by @code{popen}.  You may also\n\
+use @code{fclose} for the same purpose.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       retval = static_cast<double> (octave_stream_list::remove (args(0)));
@@ -1324,23 +1351,23 @@ convert (int x, int ibase, int obase)
 	  mult *= ibase;
 	}
     }
 
   return retval;
 }
 
 DEFUN (umask, args, ,
-  "umask (MASK)\n\
-\n\
-Change the file permission mask for file creation for the current\n\
-process.  MASK is an integer, interpreted as an octal number.  If\n\
-successful, returns the previous value of the mask (as an integer to\n\
-be interpreted as an octal number); otherwise an error message is\n\
-printed.")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} umask (@var{mask})\n\
+Set the permission mask for file creation.  The parameter @var{mask}\n\
+ is an integer, interpreted as an octal number.  If successful,\n\
+ returns the previous value of the mask (as an integer to be\n\
+ interpreted as an octal number); otherwise an error message is printed.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
       int mask = args(0).int_value (true);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -63,16 +63,17 @@ Software Foundation, 59 Temple Place - S
 #include "pt-pr-code.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
+#include "version.h"
 
 // Name of the info file specified on command line.
 // (--info-file file)
 string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 string Vinfo_prog;
@@ -699,20 +700,26 @@ display_help_text (ostream& os, const st
 
       if (cols > 64)
 	cols -= 7;
 
       if (cols > 80)
 	cols = 72;
 
       ostrstream buf;
-      buf << "sed 's/^[#%]+ *//'"
-	  << " | makeinfo --fill-column " << cols
-	  << " --no-warn --no-validate --no-headers --force --output "
-	  << tmp_file_name
+      buf << "sed 's/^[#%]+ *//' | makeinfo"
+	  << " -D VERSION \"" << OCTAVE_VERSION << "\""
+	  << " -D OCTAVE_HOME \"" << OCTAVE_PREFIX << "\""
+	  << " -D TARGETHOSTTYPE \"" << CANONICAL_HOST_TYPE << "\""
+	  << " --fill-column " << cols
+	  << " --no-warn"
+	  << " --no-validate"
+	  << " --no-headers"
+	  << " --force"
+	  << " --output " << tmp_file_name
 	  << ends;
 
       char *cmd = buf.str ();
 
       oprocstream filter (cmd);
 
       delete [] cmd;
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -472,16 +472,18 @@ public:
 
   void do_non_const_unary_op (octave_value::unary_op,
 			      const octave_value_list& idx);
 
   friend octave_value do_binary_op (octave_value::binary_op,
 				    const octave_value&,
 				    const octave_value&);
 
+  const octave_value& get_rep (void) const { return *rep; }
+
 protected:
 
   octave_value (const octave_xvalue&) : rep (0) { }
 
   void reset_indent_level (void) const
     { curr_print_indent_level = 0; }
 
   void increment_indent_level (void) const
@@ -604,26 +606,26 @@ OV_BINOP_FN (el_or)
 OV_BINOP_FN (struct_ref)
 
 // T_ID is the type id of struct objects, set by register_type().
 // T_NAME is the type name of struct objects.
 #define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
   public: \
     int type_id (void) const { return t_id; } \
     string type_name (void) const { return t_name; } \
-    static int static_type_id (void) { return t_id; } \
+    static volatile int static_type_id (void) { return t_id; } \
     static void register_type (void) \
       { t_id = octave_value_typeinfo::register_type (t_name); } \
  \
   private: \
-    static int t_id; \
+    static volatile int t_id; \
     static const string t_name;
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n) \
-  int t::t_id (-1); \
+  volatile int t::t_id (-1); \
   const string t::t_name (n)
 
 // If TRUE, allow assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 extern bool Vdo_fortran_indexing;
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -85,22 +85,24 @@ mk_stat_map (const file_stat& fs)
 #if defined (HAVE_ST_BLOCKS)
   m["blocks"] = static_cast<double> (fs.blocks ());
 #endif
 
   return m;
 }
 
 DEFUN (dup2, args, ,
- "[FID, MSG] = dup2 (OLD, NEW)\n\
-\n\
+ "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
 Duplicate a file descriptor.\n\
 \n\
-If successful, FID is greater than zero and contains the new file ID.\n\
-Otherwise, FID is negative and MSG contains a system-dependent error message.")
+If successful, @var{fid} is greater than zero and contains the new file\n\
+ID.  Otherwise, @var{fid} is negative and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -131,22 +133,33 @@ Otherwise, FID is negative and MSG conta
     }
   else
     print_usage ("dup2");
 
   return retval;
 }
 
 DEFUN (exec, args, ,
- "[STATUS, MSG] = exec (FILE, ARGS)\n\
+ "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
+Replace current process with a new process.  Calling @code{exec} without\n\
+first calling @code{fork} will terminate your current Octave process and\n\
+replace it with the program named by @var{file}.  For example,\n\
 \n\
-Replace current process with a new process.\n\
+@example\n\
+exec (\"ls\" \"-l\")\n\
+@end example\n\
 \n\
-If successful, exec does not return.  If exec does return, status will\n\
-be nonzero, and MSG will contain a system-dependent error message.")
+@noindent\n\
+will run @code{ls} and return you to your shell prompt.\n\
+\n\
+If successful, @code{exec} does not return.  If @code{exec} does return,\n\
+@var{err} will be nonzero, and @var{msg} will contain a system-dependent\n\
+error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -198,22 +211,68 @@ be nonzero, and MSG will contain a syste
     }
   else
     print_usage ("exec");
 
   return retval;
 }
 
 DEFUN (fcntl, args, ,
- "[STATUS, MSG] = fcntl (FID, REQUEST, ARGUMENT)\n\
+ "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
+Change the properties of the open file @var{fid}.  The following values\n\
+may be passed as @var{request}:\n\
+\n\
+@vtable @code\n\
+@item F_DUPFD\n\
+Return a duplicate file descriptor.\n\
+\n\
+@item F_GETFD\n\
+Return the file descriptor flags for @var{fid}.\n\
+\n\
+@item F_SETFD\n\
+Set the file descriptor flags for @var{fid}.\n\
+\n\
+@item F_GETFL\n\
+Return the file status flags for @var{fid}.  The following codes may be\n\
+returned (some of the flags may be undefined on some systems).\n\
+\n\
+@vtable @code\n\
+@item O_RDONLY\n\
+Open for reading only.\n\
+\n\
+@item O_WRONLY\n\
+Open for writing only.\n\
 \n\
-Control open file descriptors.\n\
+@item O_RDWR\n\
+Open for reading and writing.\n\
+\n\
+@item O_APPEND\n\
+Append on each write.\n\
+\n\
+@item O_NONBLOCK\n\
+Nonblocking mode.\n\
+\n\
+@item O_SYNC\n\
+Wait for writes to complete.\n\
 \n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+@item O_ASYNC\n\
+Asynchronous I/O.\n\
+@end vtable\n\
+\n\
+@item F_SETFL\n\
+Set the file status flags for @var{fid} to the value specified by\n\
+@var{arg}.  The only flags that can be changed are @code{O_APPEND} and\n\
+@code{O_NONBLOCK}.\n\
+@end vtable\n\
+\n\
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -243,23 +302,37 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("fcntl");
 
   return retval;
 }
 
 DEFUN (fork, args, ,
- "[PID, MSG] = fork ()\n\
-\n\
+ "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()\n\
 Create a copy of the current process.\n\
 \n\
-If successful, PID is either the process ID and you are in the parent,\n\
-or 0, and you are in the child.  If PID is less than zero, an error\n\
-has occured, and MSG contains a system-dependent error message.")
+Fork can return one of the following values:\n\
+\n\
+@table @asis\n\
+@item > 0\n\
+You are in the parent process.  The value returned from @code{fork} is\n\
+the process id of the child process.  You should probably arrange to\n\
+wait for any child processes to exit.\n\
+\n\
+@item 0\n\
+You are in the child process.  You can call @code{exec} to start another\n\
+process.  If that fails, you should probably call @code{exit}.\n\
+\n\
+@item < 0\n\
+The call to @code{fork} failed for some reason.  You must take evasive\n\
+action.  A system dependent error message will be waiting in @var{msg}.\n\
+@end table\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -274,17 +347,20 @@ has occured, and MSG contains a system-d
     }
   else
     print_usage ("fork");
 
   return retval;
 }
 
 DEFUN (getpgrp, args, ,
-  "pgid = getpgrp (): return the process group id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
+Return the process group id of the current process.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -297,111 +373,125 @@ DEFUN (getpgrp, args, ,
     }
   else
     print_usage ("getpgrp");
 
   return retval;
 }
 
 DEFUN (getpid, args, ,
-  "pid = getpid (): return the process id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {pid =} getpid ()\n\
+Return the process id of the current process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getpid ();
   else
     print_usage ("getpid");
 
   return retval;
 }
 
 DEFUN (getppid, args, ,
-  "pid = getppid (): return the process id of the parent process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {pid =} getppid ()\n\
+Return the process id of the parent process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getppid ();
   else
     print_usage ("getppid");
 
   return retval;
 }
 
 DEFUN (getegid, args, ,
-  "gid = getegid (): return the effective group id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {egid =} getegid ()\n\
+Return the effective group id of the current process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getegid ();
   else
     print_usage ("getegid");
 
   return retval;
 }
 
 DEFUN (getgid, args, ,
-  "gid = getgid (): return the real group id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {gid =} getgid ()\n\
+Return the real group id of the current process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getgid ();
   else
     print_usage ("getgid");
 
   return retval;
 }
 
 DEFUN (geteuid, args, ,
-  "uid = geteuid (): return the effective user id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {euid =} geteuid ()\n\
+Return the effective user id of the current process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::geteuid ();
   else
     print_usage ("geteuid");
 
   return retval;
 }
 
 DEFUN (getuid, args, ,
-  "uid = getuid (): return the real user id of the current process")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {uid =} getuid ()\n\
+Return the real user id of the current process.\n\
+@end deftypefn")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = octave_syscalls::getuid ();
   else
     print_usage ("getuid");
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
-  "[S, ERR, MSG] = lstat (NAME)\n\
-\n\
-Like [S, ERR, MSG] = stat (NAME), but if NAME refers to a symbolic\n\
-link, returns information about the link itself, not the file that it\n\
-points to.")
+  "See stat.")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       string fname = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
@@ -423,23 +513,26 @@ points to.")
 	}
     }
   else
     print_usage ("lstat");
 
   return retval;
 }
 
+
+
 DEFUN (mkfifo, args, ,
-  "[STATUS, MSG] = mkfifo (NAME, MODE)\n\
+  "@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name})\n\
+Create a @var{fifo} special file named @var{name} with file mode @var{mode}\n\\n\
 \n\
-Create a FIFO special file named NAME with file mode MODE\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -470,23 +563,25 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("mkfifo");
 
   return retval;
 }
 
 DEFUN (pipe, args, ,
-  "[FILE_LIST, STATUS, MSG] = pipe (): create an interprocess channel.\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{file_ids}, @var{err}, @var{msg}] =} pipe ()\n\
+Create a pipe and return the vector @var{file_ids}, which corresponding\n\
+to the reading and writing ends of the pipe.\n\
 \n\
-Return the file objects corresponding to the reading and writing ends of\n\
-the pipe, as a two-element list.\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = string ();
   retval(1) = -1.0;
   retval(0) = Matrix ();
 
   int nargin = args.length ();
@@ -523,40 +618,102 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("pipe");
 
   return retval;
 }
 
 DEFUN (stat, args, ,
-  "[S, ERR, MSG] = stat (NAME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
+@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
+Return a structure @var{s} containing the following information about\n\
+@var{file}.\n\
+\n\
+@table @code\n\
+@item dev\n\
+ID of device containing a directory entry for this file.\n\
+\n\
+@item ino\n\
+File number of the file.\n\
+\n\
+@item modestr\n\
+File mode, as a string of ten letters or dashes as would be returned by\n\
+@kbd{ls -l}.\n\
+\n\
+@item nlink\n\
+Number of links.\n\
 \n\
-  Given the name of a file, return a structure S with the following\n\
-  elements:\n\
+@item uid\n\
+User ID of file's owner.\n\
+\n\
+@item gid\n\
+Group ID of file's group.\n\
+\n\
+@item rdev\n\
+ID of device for block or character special files.\n\
+\n\
+@item size\n\
+Size in bytes.\n\
+\n\
+@item atime\n\
+Time of last access in the same form as time values returned from\n\
+@code{time}.  @xref{Timing Utilities}.\n\
+\n\
+@item mtime\n\
+Time of last modification in the same form as time values returned from\n\
+@code{time}.  @xref{Timing Utilities}.\n\
 \n\
-    dev     : id of device containing a directory entry for this file\n\
-    ino     : file number of the file\n\
-    modestr : file mode, as a string of ten letters or dashes as in ls -l\n\
-    nlink   : number of links\n\
-    uid     : user id of file's owner\n\
-    gid     : group id of file's group \n\
-    rdev    : id of device for block or character special files\n\
-    size    : size in bytes\n\
-    atime   : time of last access\n\
-    mtime   : time of last modification\n\
-    ctime   : time of last file status change\n\
-    blksize : size of blocks in the file\n\
-    blocks  : number of blocks allocated for file\n\
+@item ctime\n\
+Time of last file status change in the same form as time values\n\
+returned from @code{time}.  @xref{Timing Utilities}.\n\
+\n\
+@item blksize\n\
+Size of blocks in the file.\n\
+\n\
+@item blocks\n\
+Number of blocks allocated for file.\n\
+@end table\n\
+\n\
+If the call is successful @var{err} is 0 and @var{msg} is an empty\n\
+string.  If the file does not exist, or some other error occurs, @var{s}\n\
+is an empty matrix, @var{err} is @minus{}1, and @var{msg} contains the\n\
+corresponding system error message.\n\
+\n\
+If @var{file} is a symbolic link, @code{stat} will return information\n\
+about the actual file the is referenced by the link.  Use @code{lstat}\n\
+if you want information about the symbolic link itself.\n\
+\n\
+For example,\n\
 \n\
-  If the call is successful, ERR is 0 and MSG is an empty string.\n\
-\n\
-  If the file does not exist, or some other error occurs, S is an\n\
-  empty matrix, ERR is -1, and MSG contains the corresponding\n\
-  system error message.")
+@example\n\
+@group\n\
+[s, err, msg] = stat (\"/vmlinuz\")\n\
+      @result{} s =\n\
+        @{\n\
+          atime = 855399756\n\
+          rdev = 0\n\
+          ctime = 847219094\n\
+          uid = 0\n\
+          size = 389218\n\
+          blksize = 4096\n\
+          mtime = 847219094\n\
+          gid = 6\n\
+          nlink = 1\n\
+          blocks = 768\n\
+          modestr = -rw-r--r--\n\
+          ino = 9316\n\
+          dev = 2049\n\
+        @}\n\
+     @result{} err = 0\n\
+     @result{} msg = \n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       string fname = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
@@ -579,22 +736,24 @@ DEFUN (stat, args, ,
     }
   else
     print_usage ("stat");
 
   return retval;
 }
 
 DEFUN (unlink, args, ,
-  "[STATUS, MSG] = unlink (NAME)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} unlink (@var{file})\n\
+Delete the file named @var{file}.\n\
 \n\
-Delete the file NAME\n\
-\n\
-If successful, STATUS is 0 and MSG is an empty string.  Otherwise,\n\
-STATUS is nonzero and MSG contains a system-dependent error message.")
+If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
+system-dependent error message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -616,41 +775,55 @@ STATUS is nonzero and MSG contains a sys
     }
   else
     print_usage ("unlink");
 
   return retval;
 }
 
 DEFUN (waitpid, args, ,
-  "[PID, MSG] = waitpid (PID, OPTIONS)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
+Wait for process @var{pid} to terminate.  The @var{pid} argument can be:\n\
 \n\
-Wait for process PID to terminate\n\
-\n\
-  PID can be:\n\
+@table @asis\n\
+@item @minus{}1\n\
+Wait for any child process.\n\
 \n\
-     -1 : wait for any child process\n\
-      0 : wait for any child process whose process group ID is equal to\n\
-          that of the Octave interpreter process.\n\
-    > 0 : wait for termination of the child process with ID PID.\n\
+@item 0\n\
+Wait for any child process whose process group ID is equal to that of\n\
+the Octave interpreter process.\n\
 \n\
-  OPTIONS is:\n\
+@item > 0\n\
+Wait for termination of the child process with ID @var{pid}.\n\
+@end table\n\
+\n\
+The @var{options} argument can be:\n\
 \n\
-     0 : wait until signal is received or a child process exits (this\n\
-         is the default if the OPTIONS argument is missing) \n\
-     1 : do not hang if status is not immediately available\n\
-     2 : report the status of any child processes that are\n\
-         stopped, and whose status has not yet been reported\n\
-         since they stopped\n\
-     3 : implies both 1 and 2\n\
+@table @asis\n\
+@item 0\n\
+Wait until signal is received or a child process exits (this is the\n\
+default if the @var{options} argument is missing).\n\
+\n\
+@item 1\n\
+Do not hang if status is not immediately available.\n\
 \n\
-If successful, PID is greater than 0 and contains the process ID of\n\
-the child process that exited and MSG is an empty string.\n\
-Otherwise, PID is less than zero and MSG contains a system-dependent\n\
-error message.")
+@item 2\n\
+Report the status of any child processes that are stopped, and whose\n\
+status has not yet been reported since they stopped.\n\
+\n\
+@item 3\n\
+Implies both 1 and 2.\n\
+@end table\n\
+\n\
+If the returned value of @var{pid} is greater than 0, it is the process\n\
+ID of the child process that exited.  If an error occurs, @var{pid} will\n\
+be less than zero and @var{msg} will contain a system-dependent error\n\
+message.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -325,17 +325,27 @@ DEFUN (clc, , ,
   command_editor::clear_screen ();
 
   return octave_value_list ();
 }
 
 DEFALIAS (home, clc);
 
 DEFUN (getenv, args, ,
-  "getenv (STRING): get environment variable values")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} getenv (@var{var})\n\
+Return the value of the environment variable @var{var}.  For example,\n\
+\n\
+@example\n\
+getenv (\"PATH\")\n\
+@end example\n\
+\n\
+@noindent\n\
+returns a string containing the value of your path.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       string name = args(0).string_value ();
@@ -345,17 +355,20 @@ DEFUN (getenv, args, ,
     }
   else
     print_usage ("getenv");
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
-  "putenv (VAR, VALUE): define environment variable VAR=VALUE")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} putenv (@var{var}, @var{value})\n\
+Set the value of the environment variable @var{var} to @var{value}.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       string var = args(0).string_value (); 
@@ -393,17 +406,32 @@ DEFUN (kbhit, , ,
       s[1] = '\0';
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
-  "pause (seconds): suspend program execution")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} pause (@var{seconds})\n\
+Suspend the execution of the program.  If invoked without any arguments,\n\
+Octave waits until you type a character.  With a numeric argument, it\n\
+pauses for the given number of seconds.  For example, the following\n\
+statement prints a message and then waits 5 seconds before clearing the\n\
+screen.\n\
+\n\
+@example\n\
+@group\n\
+fprintf (stderr, \"wait please...\n\");\n\
+pause (5);\n\
+clc;\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (! (nargin == 0 || nargin == 1))
     {
       print_usage ("pause");
@@ -436,17 +464,20 @@ DEFUN (pause, args, ,
       flush_octave_stdout ();
       kbhit ();
     }
 
   return retval;
 }
 
 DEFUN (sleep, args, ,
-  "sleep (seconds): suspend program execution")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
+Suspend the execution of the program for the given number of seconds.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
@@ -463,17 +494,23 @@ DEFUN (sleep, args, ,
     }
   else
     print_usage ("sleep");
 
   return retval;
 }
 
 DEFUN (usleep, args, ,
-  "usleep (microseconds): suspend program execution")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
+Suspend the execution of the program for the given number of\n\
+microseconds.  On systems where it is not possible to sleep for periods\n\
+of time less than one second, @code{usleep} will pause the execution for\n\
+@code{round (@var{microseconds} / 1e6)} seconds.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
@@ -501,27 +538,49 @@ DEFUN (usleep, args, ,
 
   return retval;
 }
 
 // XXX FIXME XXX -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
-  "isieee (): return 1 if host uses IEEE floating point")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} isieee ()\n\
+Return 1 if your computer claims to conform to the IEEE standard for\n\
+floating point calculations.\n\
+@end deftypefn")
 {
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();
 
   return static_cast<double> (flt_fmt == oct_mach_info::ieee_little_endian
 			      || flt_fmt == oct_mach_info::ieee_big_endian);
 }
 
 DEFUN (tilde_expand, args, ,
-  "tilde_expand (STRING): perform tilde expansion on STRING")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
+Performs tilde expansion on @var{string}.  If @var{string} begins with a\n\
+tilde character, (@samp{~}), all of the characters preceding the first\n\
+slash (or all characters, if there is no slash) are treated as a\n\
+possible user name, and the tilde and the following characters up to the\n\
+slash are replaced by the home directory of the named user.  If the\n\
+tilde is followed immediately by a slash, the tilde is replaced by the\n\
+home directory of the user running Octave.  For example,\n\
+\n\
+@example\n\
+@group\n\
+tilde_expand (\"~joeuser/bin\")\n\
+     @result{} \"/home/joeuser/bin\"\n\
+tilde_expand (\"~/bin\")\n\
+     @result{} \"/home/jwe/bin\"\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = file_ops::tilde_expand (args(0).all_strings ());
   else
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -191,19 +191,33 @@ DEFUN_TEXT (casesen, args, ,
     ; // ok.
   else
     print_usage ("casesen");
 
   return retval;
 }
 
 DEFUN (computer, args, nargout,
-  "computer ():\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} computer ()\n\
+Print or return a string of the form @var{cpu}-@var{vendor}-@var{os}\n\
+that identifies the kind of computer Octave is running on.  If invoked\n\
+with an output argument, the value is returned instead of printed.  For\n\
+example,\n\
 \n\
-Have Octave ask the system, \"What kind of computer are you?\"")
+@example\n\
+@group\n\
+computer ()\n\
+     @print{} i586-pc-linux-gnu\n\
+\n\
+x = computer ()\n\
+     @result{} x = \"i586-pc-linux-gnu\"\n\
+@end group\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("computer: ignoring extra arguments");
 
@@ -352,37 +366,56 @@ run_command_and_return_output (const str
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 DEFUN (system, args, nargout,
-  "system (STRING [, RETURN_OUTPUT] [, TYPE])\n\
-\n\
-Execute the shell command specified by STRING.\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} system (@var{string}, @var{return_output}, @var{type})\n\
+Execute a shell command specified by @var{string}.  The second\n\
+argument is optional.  If @var{type} is @code{\"async\"}, the process\n\
+is started in the background and the process id of the child process\n\
+is returned immediately.  Otherwise, the process is started, and\n\
+Octave waits until it exits.  If @var{type} argument is omitted, a\n\
+value of @code{\"sync\"} is assumed.\n\
 \n\
-If TYPE is \"async\", the process is started in the background and the\n\
-pid of the child proces is returned immediately.  Otherwise, the\n\
-process is started, and Octave waits until it exits.  If TYPE argument\n\
-is omitted, a value of \"sync\" is assumed.\n\
-\n\
-If NARGIN == 2 (the actual value of RETURN_OUTPUT is irrelevant) and\n\
-the subprocess is started synchronously, or if system() is called with\n\
-NARGIN == 1 and NARGOUT > 0, the output from the command is returned.\n\
+If two input arguments are given (the actual value of\n\
+@var{return_output} is irrelevant) and the subprocess is started\n\
+synchronously, or if @var{system} is called with one input argument and\n\
+one or more output arguments, the output from the command is returned.\n\
 Otherwise, if the subprocess is executed synchronously, it's output is\n\
 sent to the standard output.  To send the output of a command executed\n\
-with system() through the pager, use a command like\n\
+with @var{system} through the pager, use a command like\n\
 \n\
-   disp (system (CMD, 1));\n\
+@example\n\
+disp (system (cmd, 1));\n\
+@end example\n\
 \n\
+@noindent\n\
 or\n\
 \n\
-   printf (\"%s\\n\", system (CMD, 1));")
+@example\n\
+printf (\"%s\n\", system (cmd, 1));\n\
+@end example\n\
+\n\
+The @code{system} function can return two values.  The first is any\n\
+output from the command that was written to the standard output stream,\n\
+and the second is the output status of the command.  For example,\n\
+\n\
+@example\n\
+[output, status] = system (\"echo foo; exit 2\");\n\
+@end example\n\
+\n\
+@noindent\n\
+will set the variable @code{output} to the string @samp{foo}, and the\n\
+variable @code{status} to the integer @samp{2}.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargout > 0 || nargin > 1);
@@ -528,23 +561,25 @@ which they were registered with atexit()
     }
   else
     print_usage ("atexit");
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
-  "octave_config_info (OPTION)\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} octave_config_info (@var{option})\n\
+Return a structure containing configuration and installation\n\
+information for Octave.\n\
 \n\
-If OPTION is a string, return the configuration information for the\n\
+if @var{option} is a string, return the configuration information for the\n\
 specified option.\n\
 \n\
-With no arguments, return a structure containing configuration\n\
-information.")
+@end deftypefn")
 {
   octave_value retval;
 
 #if defined (WITH_DYNAMIC_LINKING) && (defined (WITH_DL) || defined (WITH_SHL))
   bool octave_supports_dynamic_linking = true;
 #else
   bool octave_supports_dynamic_linking = false;
 #endif
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -254,17 +254,31 @@ Look up NAME in LOADPATH.  See also file
 					octave_env::getcwd ());
   else
     print_usage ("file_in_loadpath");
 
   return retval;
 }
 
 DEFUN (file_in_path, args, ,
-  "file_in_path (PATH, NAME)")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
+Return the absolute name name of @var{file} if it can be found in\n\
+@var{path}.  The value of @var{path} should be a colon-separated list of\n\
+directories in the format described for the built-in variable\n\
+@code{LOADPATH}.\n\
+\n\
+If the file cannot be found in the path, an empty matrix is returned.\n\
+For example,\n\
+\n\
+@example\n\
+file_in_path (LOADPATH, \"nargchk.m\")\n\
+     @result{} \"@value{OCTAVEHOME}/share/octave/2.0/m/general/nargchk.m\"\n\
+@end example\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("file_in_path");
 
   if (error_state)
