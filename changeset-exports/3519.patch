# HG changeset patch
# User jwe
# Date 949471259 0
#      Wed Feb 02 06:00:59 2000 +0000
# Node ID 957d7d6ab0e0be468799f220d1ba687afab6a95b
# Parent  2dcc5f58ca0c6bc6f017f403b4fcd831808e5fe5
[project @ 2000-02-02 06:00:09 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,18 @@
 2000-02-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* oct-rl-edit.c, oct-rl-edit.h: New files for interface to GNU
+	readline library.
+	* Makefile.in: Add them to the appropriate lists.
+
+	* oct-rl-hist.c, oct-rl-hist.h: New files for interface to GNU
+	readline history library.
+	* Makefile.in: Add them to the appropriate lists.
+
 	* data-conv.cc (LS_DO_WRITE): Cast arg to ostream::write to char*.
 	(LS_DO_READ): Likewise, for istream::read.
 	(write_doubles): Likewise.
 	(read_doubles): Likewise.
 
 	* oct-env.cc (octave_env::do_polite_directory_format):
 	Use operator== and substr method to do limited-length string
 	comparison.
@@ -19,18 +27,20 @@ 2000-02-01  John W. Eaton  <jwe@bevo.che
 	* DAE.h, DAE.cc: Likewise, also xx for x.
 
 	* DASSL.cc (dassl_fcn_ptr, dassl_jac_ptr): New typedefs.
 	* LSODE.cc: lsode_fcn_ptr, lsode_jac_ptr): Ditto.
 	* Quad.cc (quad_fcn_ptr): Ditto.
 	* NLEqn.cc (hybrd1_fcn_ptr, hybrj1_fcn_ptr): Ditto.
 
 	* oct-getopt.h, oct-getopt.c: New files for interface to getopt.
+	* Makefile.in: Add them to the appropriate lists.
 
 	* oct-kpse.h, oct-kpse.c: New files for interface to kpathsearch.
+	* Makefile.in: Add them to the appropriate lists.
 
 	* dMatrix.cc (write_int, read_int): No longer declared static.
 
 	* CDiagMatrix.h: Delete decls for friend operators that are
 	handled by MDiagArray2 class.  Move others outside class decl and
 	strip friend status.
 	* dDiagMatrix.h: Likewise.
 
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -364,16 +364,23 @@ DASSL::integrate (const ColumnVector& to
 	    }
 	}
     }
 
   return retval;
 }
 
 Matrix
+DASSL::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
+{
+  Matrix dummy;
+  return integrate (tout, dummy, tcrit);
+}
+
+Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
 		  const ColumnVector& tcrit) 
 {
   Matrix retval;
   int n_out = tout.capacity ();
 
   if (n_out > 0 && n > 0)
     {
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -124,16 +124,18 @@ public:
 
   void set_stop_time (double t);
   void clear_stop_time (void);
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
+  Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
+
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out,
 		    const ColumnVector& tcrit); 
 
 private:
 
   double stop_time;
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -42,20 +42,20 @@ MX_OP_INC := mx-cdm-cm.h mx-cdm-cs.h mx-
 
 INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DASSL.h FEGrid.h \
 	LinConst.h LP.h LPsolve.h LSODE.h NLConst.h NLEqn.h NLFunc.h \
 	NLP.h ODE.h ODEFunc.h Objective.h QP.h Quad.h Range.h base-de.h \
 	base-min.h byte-swap.h cmd-edit.h cmd-hist.h data-conv.h \
 	dir-ops.h file-ops.h file-stat.h getopt.h glob-match.h \
 	idx-vector.h lo-ieee.h lo-mappers.h lo-specfun.h lo-sysdep.h \
 	lo-utils.h mach-info.h oct-alloc.h oct-cmplx.h oct-env.h \
-	oct-getopt.h oct-group.h oct-kpse.h oct-passwd.h \
-	oct-shlib.h oct-syscalls.h oct-time.h pathlen.h pathsearch.h \
-	prog-args.h statdefs.h str-vec.h sun-utils.h sysdir.h systime.h \
-	syswait.h \
+	oct-getopt.h oct-group.h oct-kpse.h oct-passwd.h oct-rl-edit.h \
+	oct-rl-hist.h oct-shlib.h oct-syscalls.h oct-time.h pathlen.h \
+	pathsearch.h prog-args.h statdefs.h str-vec.h sun-utils.h \
+	sysdir.h systime.h syswait.h \
 	$(MATRIX_INC) \
 	$(MX_OP_INC)
 
 TEMPLATE_SRC := Array.cc Array2.cc Array3.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MDiagArray2.cc base-lu.cc
 
 TI_SRC := Array-C.cc Array-b.cc Array-ch.cc Array-i.cc Array-d.cc \
 	Array-s.cc Array-str.cc \
@@ -77,19 +77,19 @@ MX_OP_SRC := mx-cdm-cm.cc mx-cdm-cs.cc m
 
 SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc LinConst.cc \
 	LPsolve.cc LSODE.cc NLEqn.cc Quad.cc Range.cc cmd-edit.cc \
 	cmd-hist.cc data-conv.cc dir-ops.cc f2c-main.c file-ops.cc \
 	file-stat.cc filemode.c getopt.c getopt1.c glob-match.cc \
 	idx-vector.cc lo-ieee.cc lo-mappers.cc lo-specfun.cc \
 	lo-sysdep.cc lo-utils.cc mach-info.cc mkdir.c oct-alloc.cc \
 	oct-env.cc oct-getopt.c oct-group.cc oct-kpse.c oct-passwd.cc \
-	oct-shlib.cc oct-syscalls.cc oct-time.cc \
-	pathsearch.cc prog-args.cc rename.c rmdir.c strftime.c \
-	strptime.c str-vec.cc tempname.c tempnam.c \
+	oct-rl-edit.c oct-rl-hist.c oct-shlib.cc oct-syscalls.cc \
+	oct-time.cc pathsearch.cc prog-args.cc rename.c rmdir.c \
+	strftime.c strptime.c str-vec.cc tempname.c tempnam.c \
 	$(TEMPLATE_SRC) \
 	$(TI_SRC) \
 	$(MATRIX_SRC) \
 	$(MX_OP_SRC)
 
 EXTRAS := mx-inlines.cc
 
 INCLUDES_FOR_INSTALL := $(INCLUDES) $(TEMPLATE_SRC) $(EXTRAS)
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -45,32 +45,26 @@ Software Foundation, 59 Temple Place - S
 
 command_editor *command_editor::instance = 0;
 
 #if defined (USE_READLINE)
 
 #include <cstdio>
 #include <cstdlib>
 
-#include <readline/readline.h>
-
-// It would be nice if readline.h declared these, I think.
-
-extern int rl_blink_matching_paren;
-
-extern int screenheight;
-
-extern int screenwidth;
+#include "oct-rl-edit.h"
 
 class
 gnu_readline : public command_editor
 {
 public:
 
-  typedef command_editor::fcn fcn;
+  typedef command_editor::startup_hook_fcn startup_hook_fcn;
+
+  typedef command_editor::event_hook_fcn event_hook_hook_fcn;
 
   typedef command_editor::completion_fcn completion_fcn;
 
   gnu_readline (void);
 
   ~gnu_readline (void) { }
 
   void do_set_name (const std::string& n);
@@ -108,274 +102,260 @@ public:
   completion_fcn do_get_completion_function (void) const;
 
   void do_insert_text (const std::string& text);
 
   void do_newline (void);
 
   void do_clear_undo_list (void);
 
-  void do_set_startup_hook (fcn f);
+  void do_set_startup_hook (startup_hook_fcn f);
 
   void do_restore_startup_hook (void);
 
-  void do_set_event_hook (fcn f);
+  void do_set_event_hook (event_hook_fcn f);
 
   void do_restore_event_hook (void);
 
   void do_read_init_file (const std::string& file);
 
-  static void operate_and_get_next (int, int);
+  static int operate_and_get_next (int, int);
 
 private:
 
-  fcn previous_startup_hook;
+  startup_hook_fcn previous_startup_hook;
 
-  fcn previous_event_hook;
+  event_hook_fcn previous_event_hook;
 
   completion_fcn completion_function;
 
   static char *command_generator (const char *text, int state);
 
-  static char **command_completer (char *text, int start, int end);
+  static char **command_completer (const char *text, int start, int end);
 };
 
 gnu_readline::gnu_readline ()
   : command_editor (), previous_startup_hook (0),
     previous_event_hook (0), completion_function (0)
 {
-  rl_terminal_name = ::getenv ("TERM");
+  // XXX FIXME XXX -- need interface to rl_add_defun, rl_initialize, and
+  // a function to set rl_terminal_name
 
-  rl_initialize ();
+  string term = octave_env::getenv ("TERM");
+
+  octave_rl_set_terminal_name (term.c_str ());
+
+  octave_rl_initialize ();
 
   do_blink_matching_paren (true);
 
-  // Bind operate-and-get-next.
+  /* Bind operate-and-get-next. */
 
-  rl_add_defun ("operate-and-get-next",
-		gnu_readline::operate_and_get_next, CTRL ('O'));
+  octave_rl_add_defun ("operate-and-get-next",
+		       gnu_readline::operate_and_get_next,
+		       octave_rl_ctrl ('O'));
 
-  // And the history search functions.
+  /* And the history search functions. */
 
-  rl_add_defun ("history-search-backward",
-		rl_history_search_backward, META ('p'));
+  octave_rl_add_defun ("history-search-backward",
+		       octave_rl_history_search_backward,
+		       octave_rl_meta ('P'));
 
-  rl_add_defun ("history-search-forward",
-		rl_history_search_forward, META ('n'));
+  octave_rl_add_defun ("history-search-forward",
+		       octave_rl_history_search_forward,
+		       octave_rl_meta ('N'));
 }
 
+
+
 void
-gnu_readline::do_set_name (const std::string& n)
+gnu_readline::do_set_name (const std::string& nm)
 {
-  static char *nm = 0;
-
-  delete [] nm;
-
-  nm = strsave (n.c_str ());
-
-  rl_readline_name = nm;
-
-  // Since we've already called rl_initialize, we need to re-read the
-  // init file to take advantage of the conditional parsing feature
-  // based on rl_readline_name;
-
-  rl_re_read_init_file ();
+  ::octave_rl_set_name (nm.c_str ());
 }
 
 std::string
 gnu_readline::do_readline (const std::string& prompt, bool& eof)
 {
   std::string retval;
 
   eof = false;
 
-  char *line = ::readline (prompt.c_str ());
+  char *line = ::octave_rl_readline (prompt.c_str ());
 
   if (line)
     {
       retval = line;
 
       free (line);
     }
   else
     eof = true;
 
   return retval;
 }
 
 void
 gnu_readline::do_set_input_stream (FILE *f)
 {
-  rl_instream = f;
+  ::octave_rl_set_input_stream (f);
 }
 
 FILE *
 gnu_readline::do_get_input_stream (void)
 {
-  return rl_instream;
+  return ::octave_rl_get_input_stream ();
 }
 
 void
 gnu_readline::do_set_output_stream (FILE *f)
 {
-  rl_outstream = f;
+  ::octave_rl_set_output_stream (f);
 }
 
 FILE *
 gnu_readline::do_get_output_stream (void)
 {
-  return rl_outstream;
+  return ::octave_rl_get_output_stream ();
 }
 
 // GNU readline handles SIGWINCH, so these values have a good chance
 // of being correct even if the window changes size (they may be
 // wrong if, for example, the luser changes the window size while the
 // pager is running, and the signal is handled by the pager instead of
 // us.
 
 int
 gnu_readline::do_terminal_rows (void)
 {
-  return screenheight > 0 ? screenheight : 24;
+  int sh = ::octave_rl_screen_height ();
+
+  return sh > 0 ? sh : 24;
 }
 
 int
 gnu_readline::do_terminal_cols (void)
 {
-  return screenwidth > 0 ? screenwidth : 80;
+  int sw = ::octave_rl_screen_width ();
+
+  return sw > 0 ? sw : 80;
 }
 
 void
 gnu_readline::do_clear_screen (void)
 {
-  rl_clear_screen ();
+  ::octave_rl_clear_screen ();
 }
 
 void
 gnu_readline::do_resize_terminal (void)
 {
-  rl_resize_terminal ();
+  ::octave_rl_resize_terminal ();
 }
 
 std::string
 gnu_readline::newline_chars (void)
 {
   return "\r\n";
 }
 
 void
 gnu_readline::do_restore_terminal_state (void)
 {
-  if (rl_deprep_term_function)
-    rl_deprep_term_function ();
+  ::octave_rl_restore_terminal_state ();
 }
 
 void
 gnu_readline::do_blink_matching_paren (bool flag)
 {
-  rl_blink_matching_paren = flag ? 1 : 0;
+  ::octave_set_rl_blink_matching_paren_flag (flag ? 1 : 0);
 }
 
 void
 gnu_readline::do_set_basic_quote_characters (const std::string& s)
 {
-  static char *ss = 0;
-
-  delete [] ss;
-
-  ss = strsave (s.c_str ());
-
-  rl_basic_quote_characters = ss;
+  ::octave_rl_set_basic_quote_characters (s.c_str ());
 }
 
 void
 gnu_readline::do_set_completion_append_character (char c)
 {
-  rl_completion_append_character = c;
+  ::octave_rl_set_completion_append_character (c);
 }
 
 void
 gnu_readline::do_set_completion_function (completion_fcn f)
 {
   completion_function = f;
 
-  typedef char** (*foo) (...);
+  rl_attempted_completion_fcn_ptr fp
+    = f ? gnu_readline::command_completer : 0;
 
-  rl_attempted_completion_function
-    = completion_function
-    ? reinterpret_cast<foo> (gnu_readline::command_completer) : 0;
+  ::octave_rl_set_completion_function (fp);
 }
 
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
 {
   return completion_function;
 }
 
 void
 gnu_readline::do_insert_text (const std::string& text)
 {
-  rl_insert_text (text.c_str ());
+  ::octave_rl_insert_text (text.c_str ());
 }
 
 void
 gnu_readline::do_newline (void)
 {
-  rl_newline ();
+  ::octave_rl_newline ();
 }
 
 void
 gnu_readline::do_clear_undo_list ()
 {
-  if (rl_undo_list)
-    {
-      free_undo_list ();
-
-      rl_undo_list = 0;
-    }
+  ::octave_rl_clear_undo_list ();
 }
 
 void
-gnu_readline::do_set_startup_hook (fcn f)
+gnu_readline::do_set_startup_hook (startup_hook_fcn f)
 {
-  previous_startup_hook = rl_startup_hook;
+  previous_startup_hook = ::octave_rl_get_startup_hook ();
 
-  rl_startup_hook = f;
+  ::octave_rl_set_startup_hook (f);
 }
 
 void
 gnu_readline::do_restore_startup_hook (void)
 {
-  rl_startup_hook = previous_startup_hook;
+  ::octave_rl_set_startup_hook (previous_startup_hook);
 }
 
 void
-gnu_readline::do_set_event_hook (fcn f)
+gnu_readline::do_set_event_hook (event_hook_fcn f)
 {
-  previous_event_hook = rl_event_hook;
+  previous_event_hook = octave_rl_get_event_hook ();
 
-  rl_event_hook = f;
+  ::octave_rl_set_event_hook (f);
 }
 
 void
 gnu_readline::do_restore_event_hook (void)
 {
-  rl_event_hook = previous_event_hook;
+  ::octave_rl_set_event_hook (previous_event_hook);
 }
 
 void
 gnu_readline::do_read_init_file (const std::string& file)
 {
-  if (file.empty ())
-    rl_re_read_init_file ();
-  else
-    rl_read_init_file (file.c_str ());
+  ::octave_rl_read_init_file (file.c_str ());
 }
 
-void
+int
 gnu_readline::operate_and_get_next (int /* count */, int /* c */)
 {
   // Accept the current line.
 
   command_editor::newline ();
 
   // Find the current line, and find the next line to use.
 
@@ -386,16 +366,18 @@ gnu_readline::operate_and_get_next (int 
   if ((command_history::is_stifled ()
        && (x_length >= command_history::max_input_history ()))
       || (x_where >= x_length - 1))
     command_history::set_mark (x_where);
   else
     command_history::set_mark (x_where + 1);
 
   command_editor::set_startup_hook (command_history::goto_mark);
+
+  return 0;
 }
 
 char *
 gnu_readline::command_generator (const char *text, int state)
 {
   char *retval = 0;
 
   completion_fcn f = command_editor::get_completion_function ();
@@ -410,20 +392,21 @@ gnu_readline::command_generator (const c
 
       strcpy (retval, tmp.c_str ());
     }
 
   return retval;
 }
 
 char **
-gnu_readline::command_completer (char *text, int /* start */, int /* end */)
+gnu_readline::command_completer (const char *text, int, int)
 {
   char **matches = 0;
-  matches = completion_matches (text, gnu_readline::command_generator);
+  matches
+    = ::octave_rl_completion_matches (text, gnu_readline::command_generator);
   return matches;
 }
 
 #endif
 
 class
 default_command_editor : public command_editor
 {
@@ -696,31 +679,31 @@ command_editor::newline (void)
 void
 command_editor::clear_undo_list (void)
 {
   if (instance_ok ())
     instance->do_clear_undo_list ();
 }
 
 void
-command_editor::set_startup_hook (fcn f)
+command_editor::set_startup_hook (startup_hook_fcn f)
 {
   if (instance_ok ())
     instance->do_set_startup_hook (f);
 }
 
 void
 command_editor::restore_startup_hook (void)
 {
   if (instance_ok ())
     instance->do_restore_startup_hook ();
 }
 
 void
-command_editor::set_event_hook (fcn f)
+command_editor::set_event_hook (event_hook_fcn f)
 {
   if (instance_ok ())
     instance->do_set_event_hook (f);
 }
 
 void
 command_editor::restore_event_hook (void)
 {
@@ -907,18 +890,18 @@ command_editor::do_decode_prompt_string 
 #if defined (USE_READLINE)
 	    case '[':
 	    case ']':
 	      {
 		temp.resize (2);
 
 		temp[0] = '\001';
 		temp[1] = ((c == '[')
-			   ? RL_PROMPT_START_IGNORE
-			   : RL_PROMPT_END_IGNORE);
+			   ? ::octave_rl_prompt_start_ignore ()
+			   : ::octave_rl_prompt_end_ignore ());
 
 		goto add_string;
 	      }
 #endif
 
 	    case '\\':
 	      {
 		temp = "\\";
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -32,17 +32,19 @@ command_editor
 {
 protected:
 
   command_editor (void)
     : command_number (0) { }
 
 public:
 
-  typedef int (*fcn) (...);
+  typedef void (*startup_hook_fcn) (void);
+
+  typedef void (*event_hook_fcn) (void);
 
   typedef std::string (*completion_fcn) (const std::string&, int);
 
   virtual ~command_editor (void) { }
 
   static void set_name (const std::string& n);
 
   static std::string readline (const std::string& prompt);
@@ -80,21 +82,21 @@ public:
   static completion_fcn get_completion_function (void);
 
   static void insert_text (const std::string& text);
 
   static void newline (void);
 
   static void clear_undo_list (void);
 
-  static void set_startup_hook (fcn f);
+  static void set_startup_hook (startup_hook_fcn f);
 
   static void restore_startup_hook (void);
 
-  static void set_event_hook (fcn f);
+  static void set_event_hook (event_hook_fcn f);
 
   static void restore_event_hook (void);
 
   static void read_init_file (const std::string& file = std::string ());
 
   static int current_command_number (void);
 
   static void reset_current_command_number (int n);
@@ -166,21 +168,21 @@ protected:
   virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
   virtual void do_insert_text (const std::string&) = 0;
 
   virtual void do_newline (void) = 0;
 
   virtual void do_clear_undo_list (void) { }
 
-  virtual void do_set_startup_hook (fcn) { }
+  virtual void do_set_startup_hook (startup_hook_fcn) { }
 
   virtual void do_restore_startup_hook (void) { }
 
-  virtual void do_set_event_hook (fcn) { }
+  virtual void do_set_event_hook (event_hook_fcn) { }
 
   virtual void do_restore_event_hook (void) { }
 
   virtual void do_read_init_file (const std::string&) { }
 
   int read_octal (const std::string& s);
 
   void error (int);
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -49,17 +49,17 @@ command_history *command_history::instan
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
-#include <readline/history.h>
+#include "oct-rl-hist.h"
 
 #include "file-stat.h"
 
 class
 gnu_history : public command_history
 {
 public:
 
@@ -119,171 +119,158 @@ void
 gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
 	  || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
 	return;
 
-      ::add_history (s.c_str ());
+      ::octave_add_history (s.c_str ());
 
       lines_this_session++;
     }
 }
 
 void
 gnu_history::do_remove (int n)
 {
-  HIST_ENTRY *discard = ::remove_history (n);
-
-  if (discard)
-    {
-      if (discard->line)
-	::free (discard->line);
-
-      ::free (discard);
-    }
+  ::octave_remove_history (n);
 }
 
 int
 gnu_history::do_where (void)
 {
-  return ::where_history ();
+  return ::octave_where_history ();
 }
 
 int
 gnu_history::do_length (void)
 {
-  return ::history_length;
+  return ::octave_history_length ();
 }
 
 int
 gnu_history::do_max_input_history (void)
 {
-  return ::max_input_history;
+  return ::octave_max_input_history ();
 }
 
 int
 gnu_history::do_base (void)
 {
-  return ::history_base;
+  return ::octave_history_base ();
 }
 
 int
 gnu_history::do_current_number (void)
 {
   return (xsize > 0) ? do_base () + do_where () : -1;
 }
 
 void
 gnu_history::do_stifle (int n)
 {
-  ::stifle_history (n);
+  ::octave_stifle_history (n);
 }
 
 int
 gnu_history::do_unstifle (void)
 {
-  return ::unstifle_history ();
+  return ::octave_unstifle_history ();
 }
 
 int
 gnu_history::do_is_stifled (void)
 {
-  return ::history_is_stifled ();
+  return ::octave_history_is_stifled ();
 }
 
 void
 gnu_history::do_set_mark (int n)
 {
   mark = n;
 }
 
 void
 gnu_history::do_goto_mark (void)
 {
-  HIST_ENTRY *h;
-
   if (mark)
     {
-      if (history_set_pos (mark))
-	{
-	  h = ::current_history ();
+      char *line = ::octave_history_goto_mark (mark);
 
-	  if (h)
-	    {
-	      command_editor::insert_text (h->line);
+      if (line)
+	{
+	  command_editor::insert_text (line);
 
-	      command_editor::clear_undo_list ();
-	    }
+	  command_editor::clear_undo_list ();
 	}
     }
 
   mark = 0;
 
   // XXX FIXME XXX -- for operate_and_get_next.
   command_editor::restore_startup_hook ();
 }
 
 void
 gnu_history::do_read (const std::string& f, bool must_exist)
 {
   if (! f.empty ())
     {
-      int status = ::read_history (f.c_str ());
+      int status = ::octave_read_history (f.c_str ());
 
       if (status != 0 && must_exist)
 	error (status);
       else
 	{
 	  lines_in_file = do_where ();
 
-	  ::using_history ();
+	  ::octave_using_history ();
 	}
     }
   else
     error ("gnu_history::read: missing file name");
 }
 
 void
 gnu_history::do_read_range (const std::string& f, int from, int to,
 			    bool must_exist)
 {
   if (from < 0)
     from = lines_in_file;
 
   if (! f.empty ())
     {
-      int status = ::read_history_range (f.c_str (), from, to);
+      int status = ::octave_read_history_range (f.c_str (), from, to);
 
       if (status != 0 && must_exist)
 	error (status);
       else
 	{
 	  lines_in_file = do_where ();
 
-	  ::using_history ();
+	  ::octave_using_history ();
 	}
     }
   else
     error ("gnu_history::read_range: missing file name");
 }
 
 void
 gnu_history::do_write (const std::string& f_arg)
 {
   std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     {
-      int status = ::write_history (f.c_str ());
+      int status = ::octave_write_history (f.c_str ());
 
       if (status != 0)
 	error (status);
     }
   else
     error ("gnu_history::write: missing file name");
 }
 
@@ -308,17 +295,18 @@ gnu_history::do_append (const std::strin
 	      if (! fs)
 		{
 		  int tem;
 
 		  tem = open (f.c_str (), O_CREAT, 0666);
 		  close (tem);
 		}
 
-	      int status = ::append_history (lines_this_session, f.c_str ());
+	      int status
+		= ::octave_append_history (lines_this_session, f.c_str ());
 
 	      if (status != 0)
 		error (status);
 	      else
 		lines_in_file += lines_this_session;
 
 	      lines_this_session = 0;
 	    }
@@ -332,88 +320,49 @@ void
 gnu_history::do_truncate_file (const std::string& f_arg, int n)
 {
   std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
-    ::history_truncate_file (f.c_str (), n);
+    ::octave_history_truncate_file (f.c_str (), n);
   else
     error ("gnu_history::truncate_file: missing file name");
 }
 
 string_vector
 gnu_history::do_list (int limit, bool number_lines)
 {
   string_vector retval;
 
   if (limit)
-    {
-      HIST_ENTRY **hlist = ::history_list ();
-
-      if (hlist)
-	{
-	  int end = 0;
-	  while (hlist[end])
-	    end++;
-
-	  int beg = (limit < 0 || end < limit) ? 0 : (end - limit);
-
-	  retval.resize (end - beg);
-
-	  int k = 0;
-	  for (int i = beg; i < end; i++)
-	    {
-	      std::ostrstream output_buf;
-
-	      if (number_lines)
-		output_buf.form ("%5d%c", i + do_base (),
-				 hlist[i]->data ? '*' : ' '); 
-
-	      output_buf << hlist[i]->line << std::ends;
-
-	      const char *tmp = output_buf.str ();
-
-	      retval[k++] = tmp;
-
-	      delete [] tmp;  
-	    }
-	}
-    }
+    retval = ::octave_history_list (limit, number_lines);
 
   return retval;
 }
 
 std::string
 gnu_history::do_get_entry (int n)
 {
   std::string retval;
 
-  HIST_ENTRY *entry = ::history_get (do_base () + n);
+  char *line = ::octave_history_get (do_base () + n);
 
-  if (entry && entry->line)
-    retval = entry->line;
+  if (line)
+    retval = line;
 
   return retval;
 }
 
 void
 gnu_history::do_replace_entry (int which, const std::string& line)
 {
-  HIST_ENTRY *discard = ::replace_history_entry (which, line.c_str (), 0);
-
-  if (discard)
-    {
-      if (discard->line)
-	::free (discard->line);
-
-      ::free (discard);
-    }
+  ::octave_replace_history_entry (which, line.c_str ());
 }
 
 void
 gnu_history::do_clean_up_and_save (const std::string& f_arg, int n)
 {
   std::string f = f_arg;
 
   if (f.empty ())
@@ -577,23 +526,21 @@ command_history::is_stifled (void)
 
 void
 command_history::set_mark (int n)
 {
   if (instance_ok ())
     instance->do_set_mark (n);
 }
 
-int
-command_history::goto_mark (...)
+void
+command_history::goto_mark (void)
 {
   if (instance_ok ())
     instance->do_goto_mark ();
-
-  return 0;
 }
 
 void
 command_history::read (bool must_exist)
 {
   if (instance_ok ())
     instance->do_read (must_exist);
 }
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -72,17 +72,17 @@ public:
 
   static int is_stifled (void);
 
   static void set_mark (int n);
 
   // Gag.  This declaration has to match the Function typedef in
   // readline.h.
 
-  static int goto_mark (...);
+  static void goto_mark (void);
 
   static void read (bool = true);
 
   static void read (const std::string&, bool = true);
 
   static void read_range (int = -1, int = -1, bool = true);
 
   static void read_range (const std::string&, int = -1, int = -1,
diff --git a/liboctave/oct-getopt.h b/liboctave/oct-getopt.h
--- a/liboctave/oct-getopt.h
+++ b/liboctave/oct-getopt.h
@@ -18,26 +18,35 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_getopt_h)
 #define octave_getopt_h 1
 
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
 extern int
 octave_getopt (int, char *const *, const char *);
 
 extern int
 octave_getopt_long (int, char *const *, const char *,
 		    const struct option *, int *);
 
 extern char *optarg;
 
 extern int optind;
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-rl-edit.c
@@ -0,0 +1,293 @@
+/*
+
+Copyright (C) 2000 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#if defined (USE_READLINE)
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <readline/readline.h>
+
+#include "oct-rl-edit.h"
+
+// It would be nice if readline.h declared these, I think.
+
+extern int rl_blink_matching_paren;
+
+extern int screenheight;
+
+extern int screenwidth;
+
+int
+octave_rl_screen_height (void)
+{
+  return screenheight;
+}
+
+int
+octave_rl_screen_width (void)
+{
+  return screenwidth;
+}
+
+void
+octave_set_rl_blink_matching_paren_flag (int val)
+{
+  rl_blink_matching_paren = val;
+}
+
+int
+octave_get_rl_blink_matching_paren_flag (void)
+{
+  return rl_blink_matching_paren;
+}
+
+void
+octave_rl_clear_screen (void)
+{
+  rl_clear_screen ();
+}
+
+void
+octave_rl_resize_terminal (void)
+{
+  rl_resize_terminal ();
+}
+
+void
+octave_rl_restore_terminal_state ()
+{
+  if (rl_deprep_term_function)
+    rl_deprep_term_function ();
+}
+
+void
+octave_rl_insert_text (const char *s)
+{
+  rl_insert_text (s);
+}
+
+void
+octave_rl_newline (void)
+{
+  rl_newline ();
+}
+
+void
+octave_rl_clear_undo_list (void)
+{
+  if (rl_undo_list)
+    {
+      free_undo_list ();
+
+      rl_undo_list = 0;
+    }
+}
+
+void
+octave_rl_set_name (const char *n)
+{
+  static char *nm = 0;
+
+  if (nm)
+    {
+      free (nm);
+      nm = 0;
+    }
+
+  nm = malloc (strlen (n + 1));
+
+  strcpy (nm, n);
+
+  rl_readline_name = nm;
+
+  /* Since we've already called rl_initialize, we need to re-read the
+     init file to take advantage of the conditional parsing feature
+     based on rl_readline_name; */
+
+  rl_re_read_init_file ();
+}
+
+char *
+octave_rl_readline (const char *prompt)
+{
+  return readline (prompt);
+}
+
+void
+octave_rl_set_input_stream (FILE *f)
+{
+  rl_instream = f;
+}
+
+FILE *
+octave_rl_get_input_stream (void)
+{
+  return rl_instream;
+}
+
+void
+octave_rl_set_output_stream (FILE *f)
+{
+  rl_outstream = f;
+}
+
+FILE *
+octave_rl_get_output_stream (void)
+{
+  return rl_outstream;
+}
+
+void
+octave_rl_read_init_file (const char *f)
+{
+  if (f && *f)
+    rl_read_init_file (f);
+  else
+    rl_re_read_init_file ();
+}
+
+void
+octave_rl_set_basic_quote_characters (const char *s)
+{
+  static char *ss = 0;
+
+  if (ss)
+    {
+      free (ss);
+      ss = 0;
+    }
+
+  ss = malloc (strlen (s) + 1);
+
+  strcpy (ss, s);
+
+  rl_basic_quote_characters = ss;
+}
+
+void
+octave_rl_set_completion_append_character (char c)
+{
+  rl_completion_append_character = c;
+}
+
+void
+octave_rl_set_completion_function (rl_attempted_completion_fcn_ptr f)
+{
+  rl_attempted_completion_function = f;
+}
+
+void
+octave_rl_set_startup_hook (rl_startup_hook_fcn_ptr f)
+{
+  rl_startup_hook = (void *) f;
+}
+
+rl_startup_hook_fcn_ptr
+octave_rl_get_startup_hook (void)
+{
+  return (void *) rl_startup_hook;
+}
+
+void
+octave_rl_set_event_hook (rl_event_hook_fcn_ptr f)
+{
+  rl_event_hook = (void *) f;
+}
+
+rl_event_hook_fcn_ptr
+octave_rl_get_event_hook (void)
+{
+  return (void *) rl_event_hook;
+}
+
+char **
+octave_rl_completion_matches (const char *text, rl_completer_fcn_ptr f)
+{
+  return completion_matches (text, f);
+}
+
+char
+octave_rl_prompt_start_ignore (void)
+{
+  return RL_PROMPT_START_IGNORE;
+}
+
+char
+octave_rl_prompt_end_ignore (void)
+{
+  return RL_PROMPT_END_IGNORE;
+}
+
+void
+octave_rl_add_defun (const char *name, rl_fcn_ptr f, char key)
+{
+  rl_add_defun (name, f, key);
+}
+
+void
+octave_rl_set_terminal_name (const char *term)
+{
+  rl_terminal_name = (char *) term;
+}
+
+void
+octave_rl_initialize (void)
+{
+  rl_initialize ();
+}
+
+int
+octave_rl_history_search_forward (int count, int ignore)
+{
+  return rl_history_search_forward (count, ignore);
+}
+
+int
+octave_rl_history_search_backward (int count, int ignore)
+{
+  return rl_history_search_backward (count, ignore);
+}
+
+char
+octave_rl_ctrl (char c)
+{
+  return CTRL (c);
+}
+
+char
+octave_rl_meta (char c)
+{
+  return META (c);
+}
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-rl-edit.h
@@ -0,0 +1,123 @@
+/*
+
+Copyright (C) 2000 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_rl_edit_h)
+#define octave_rl_edit_h 1
+
+typedef void (*rl_startup_hook_fcn_ptr) (void);
+
+typedef void (*rl_event_hook_fcn_ptr) (void);
+
+typedef int (*rl_fcn_ptr) (int, int);
+
+typedef char ** (*rl_attempted_completion_fcn_ptr) (const char *, int, int);
+
+typedef char * (*rl_completer_fcn_ptr) (const char *, int);
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+extern int octave_rl_screen_height (void);
+
+extern int octave_rl_screen_width (void);
+
+extern void octave_set_rl_blink_matching_paren_flag (int);
+
+extern int octave_get_rl_blink_matching_paren_flag (void);
+
+extern void octave_rl_init (void);
+
+extern void octave_rl_clear_screen (void);
+
+extern void octave_rl_resize_terminal (void);
+
+extern void octave_rl_restore_terminal_state (void);
+
+extern void octave_rl_insert_text (const char *);
+
+extern void octave_rl_newline (void);
+
+extern void octave_rl_clear_undo_list (void);
+
+extern void octave_rl_set_name (const char *);
+
+extern char *octave_rl_readline (const char *);
+
+extern void octave_rl_set_input_stream (FILE *);
+
+extern FILE *octave_rl_get_input_stream (void);
+
+extern void octave_rl_set_output_stream (FILE *);
+
+extern FILE *octave_rl_get_output_stream (void);
+
+extern void octave_rl_read_init_file (const char *);
+
+extern void octave_rl_set_basic_quote_characters (const char *);
+
+extern void octave_rl_set_completion_append_character (char);
+
+extern void
+octave_rl_set_completion_function (rl_attempted_completion_fcn_ptr);
+
+extern void octave_rl_set_startup_hook (rl_startup_hook_fcn_ptr);
+
+extern rl_startup_hook_fcn_ptr octave_rl_get_startup_hook (void);
+
+extern void octave_rl_set_event_hook (rl_event_hook_fcn_ptr f);
+
+extern rl_event_hook_fcn_ptr octave_rl_get_event_hook (void);
+
+extern char **
+octave_rl_completion_matches (const char *, rl_completer_fcn_ptr);
+
+extern char octave_rl_prompt_start_ignore (void);
+
+extern char octave_rl_prompt_end_ignore (void);
+
+extern void octave_rl_add_defun (const char *, rl_fcn_ptr, char);
+
+extern void octave_rl_set_terminal_name (const char *);
+
+extern void octave_rl_initialize (void);
+
+extern int octave_rl_history_search_forward (int, int);
+
+extern int octave_rl_history_search_backward (int, int);
+
+extern char octave_rl_ctrl (char);
+
+extern char octave_rl_meta (char);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-rl-hist.c
@@ -0,0 +1,249 @@
+/*
+
+Copyright (C) 2000 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#if defined (USE_READLINE)
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <readline/history.h>
+
+void
+octave_add_history (const char *line)
+{
+  return add_history (line);
+}
+
+int
+octave_where_history (void)
+{
+  return where_history ();
+}
+
+int
+octave_history_length (void)
+{
+  return history_length;
+}
+
+int
+octave_max_input_history (void)
+{
+  return max_input_history;
+}
+
+int
+octave_history_base (void)
+{
+  return history_base;
+}
+
+void
+octave_stifle_history (int n)
+{
+  return stifle_history (n);
+}
+
+int
+octave_unstifle_history (void)
+{
+  return unstifle_history ();
+}
+
+int
+octave_history_is_stifled (void)
+{
+  return history_is_stifled ();
+}
+
+int
+octave_history_set_pos (int n)
+{
+  return history_set_pos (n);
+}
+
+int
+octave_read_history (const char *f)
+{
+  return read_history (f);
+}
+
+void
+octave_using_history (void)
+{
+  return using_history ();
+}
+
+int
+octave_read_history_range (const char *f, int b, int e)
+{
+  return read_history_range (f, b, e);
+}
+
+int
+octave_write_history (const char *f)
+{
+  return write_history (f);
+}
+
+int
+octave_append_history (int n, const char *f)
+{
+  return append_history (n, f);
+}
+
+int
+octave_history_truncate_file (const char *f, int n)
+{
+  return history_truncate_file (f, n);
+}
+
+void
+octave_remove_history (int n)
+{
+  HIST_ENTRY *discard = remove_history (n);
+
+  if (discard)
+    {
+      if (discard->line)
+	free (discard->line);
+
+      free (discard);
+    }
+}
+
+char *
+octave_history_goto_mark (int n)
+{
+  HIST_ENTRY *h;
+
+  char *retval = 0;
+
+  if (history_set_pos (n))
+    {
+      h = current_history ();
+
+      if (h)
+	retval = h->line;
+    }
+
+  return retval;
+}
+
+char *
+octave_history_get (int n)
+{
+  char *retval = 0;
+
+  HIST_ENTRY *h = history_get (n);
+
+  if (h)
+    retval = h->line;
+
+  return retval;
+}
+
+char **
+octave_history_list (int limit, int number_lines)
+{
+  static char **retval = 0;
+
+  HIST_ENTRY **hlist = 0;
+
+  if (retval)
+    {
+      char **p = retval;
+
+      while (p)
+	{
+	  if (*p)
+	    free (*p++);
+	}
+
+      free (retval);
+
+      retval = 0;
+    }
+
+  hlist = history_list ();
+
+  if (hlist)
+    {
+      int i, k;
+
+      int beg = 0;
+      int end = 0;
+      while (hlist[end])
+	end++;
+
+      beg = (limit < 0 || end < limit) ? 0 : (end - limit);
+
+      retval = malloc ((end - beg + 1) * sizeof (char **));
+
+      k = 0;
+      for (i = beg; i < end; i++)
+	{
+	  char *tmp = 0;
+	  char buf[64];
+
+	  if (number_lines)
+	    sprintf (buf, "%5d%c", i + history_base,
+		     hlist[i]->data ? '*' : ' '); 
+
+	  tmp = malloc (strlen (buf) + 1);
+
+	  strcpy (tmp, buf);
+
+	  retval[k++] = tmp;
+	}
+
+      retval[k] = 0;
+    }
+
+  return retval;
+}
+
+void
+octave_replace_history_entry (int which, const char *line)
+{
+  HIST_ENTRY *discard = replace_history_entry (which, line, 0);
+
+  if (discard)
+    {
+      if (discard->line)
+	free (discard->line);
+
+      free (discard);
+    }
+}
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-rl-hist.h b/liboctave/oct-rl-hist.h
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-rl-hist.h
@@ -0,0 +1,81 @@
+/*
+
+Copyright (C) 2000 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_rl_hist_h)
+#define octave_rl_hist_h 1
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+extern void octave_add_history (const char *);
+
+extern int octave_where_history (void);
+
+extern int octave_history_length (void);
+
+extern int octave_max_input_history (void);
+
+extern int octave_history_base (void);
+
+extern void octave_stifle_history (int);
+
+extern int octave_unstifle_history (void);
+
+extern int octave_history_is_stifled (void);
+
+extern int octave_history_set_pos (int);
+
+extern int octave_read_history (const char *);
+
+extern void octave_using_history (void);
+
+extern int octave_read_history_range (const char *, int, int);
+
+extern int octave_write_history (const char *);
+
+extern int octave_append_history (int, const char *);
+
+extern int octave_history_truncate_file (const char *, int);
+
+extern void octave_remove_history (int);
+
+extern char *octave_history_goto_mark (int n);
+
+extern char *octave_history_get (int n);
+
+extern char **octave_history_list (int, int);
+
+extern void octave_replace_history_entry (int, const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -877,25 +877,23 @@ Read the readline library initialiazatio
     print_usage ("read_readline_init_file");
 
   return retval;
 }
 
 static string hook_fcn;
 static octave_value user_data;
 
-static int
-input_event_hook (...)
+static void
+input_event_hook (void)
 {
   if (user_data.is_defined ())
     feval (hook_fcn, user_data, 0);
   else
     feval (hook_fcn, octave_value_list (), 0);
-
-  return 0;
 }
 
 DEFUN (input_event_hook, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{ofcn}, @var{odata}] =} input_event_hook (@var{fcn}, @var{data})\n\
 Given the name of a function as a string and any Octave value object,\n\
 install @var{fcn} as a function to call periodically, when Octave is\n\
 waiting for input.  The function should have the form\n\
