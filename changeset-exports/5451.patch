# HG changeset patch
# User jwe
# Date 1126813970 0
#      Thu Sep 15 19:52:50 2005 +0000
# Node ID ed08548b90549423df77a4207c1782bbdba6a364
# Parent  6b42c78c77d3a408ed8c4c2a5f76987042c683ec
[project @ 2005-09-15 19:52:50 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,41 @@
+2005-09-15  John W. Eaton  <jwe@octave.org>
+
+	* oct-sparse.h.in: Move to liboctave.
+	* octMakefile.in (CONF_DISTFILES): Delete it from the list.
+	(maintainer-clean, distclean, install, install-strip, uninstall):
+	Omit rules for oct-sparse.h.
+	* configure.in: Substitute liboctave/oct-sparse.h, not oct-sparse.h.
+
+2005-09-15  David Bateman  <dbateman@free.fr>
+
+	* acx_include_dirs.m4 (AC_CHECK_HEADER_IN_DIRS): Define new macro.
+	* oct-sparse.h.in: New AC_CONFIG_FILE.
+	* configure.in: (AC_CHECK_HEADER_IN_DIRS): Use macro.
+	(AMD_LIBS, COLAMD_LIBS, CCOLAMD_LIBS, CHOLMOD_LIBS): Probe for
+	these sparse library in addition to UMFPACK.
+	(UMFPACK_INCLUDE, AMD_INCLUDE, COLAMD_INCLUDE, CCOLAMD_INCLUDE):
+	AC_SUBST into oct-sparse.h.
+	(LIBGLOB): Probe for external glob/fnmatch, define LIBGLOB.
+	(sepchar): Define path seperation character in system dependent 
+	manner. Use it with OCTAVE_SET_DEFAULT.
+	(SEPCHAR, SEPCHAR_STR): Dpend on sepchar.
+	(DL_LDFLAGS): Define for cygwin and mingw.
+	(-lwsock32): Add to LIBS.
+	(loadlibrary_api): Set for mingw/cygwin and autoconf test appears
+	broken.
+	* Makeconf.in: Don't use ";" as sed seperation to avoid confusion
+	with sepchar.
+	(LIBGLOB, AMD_LIBS, COLAMD_LIBS, CCOLAMD_LIBS, CHOLMOD_LIBS, 
+	sepchar): Substitute.
+	* octMakefile.in: (CONF_DISTFILES): Add acx_include_dirs.m4 and
+	oct-sparse.h.in
+	(oct-sparse.h): Include in install and clean directives
+
 2005-08-31  Pascal A. Dupuis  <Pascal.Dupuis@esat.kuleuven.be>
 
 	* emacs/octave-inf.el (inferior-octave-startup): Call
 	inferior-octave-resync-dirs here.
 
 2005-07-14  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (SH_LDFLAGS): Add -Wl,--enable-auto-image-base for
diff --git a/Makeconf.in b/Makeconf.in
--- a/Makeconf.in
+++ b/Makeconf.in
@@ -172,27 +172,32 @@ SONAME_FLAGS = @SONAME_FLAGS@
 
 RDYNAMIC_FLAG = @RDYNAMIC_FLAG@
 
 RLD_FLAG = @RLD_FLAG@
 
 FLIBS = @FLIBS@
 
 LIBDLFCN = @LIBDLFCN@
+LIBGLOB = @LIBGLOB@
 LIBPLPLOT = @LIBPLPLOT@
 LIBOCTINTERP = @LIBOCTINTERP@
 LIBOCTAVE = @LIBOCTAVE@
 LIBCRUFT = @LIBCRUFT@
 LIBREADLINE = @LIBREADLINE@
 TERMLIBS = @TERMLIBS@
 
 BLAS_LIBS = @BLAS_LIBS@
 FFTW_LIBS = @FFTW_LIBS@
 GLPK_LIBS = @GLPK_LIBS@
+AMD_LIBS = @AMD_LIBS@
 UMFPACK_LIBS = @UMFPACK_LIBS@
+COLAMD_LIBS = @COLAMD_LIBS@
+CCOLAMD_LIBS = @CCOLAMD_LIBS@
+CHOLMOD_LIBS = @CHOLMOD_LIBS@
 LIBS = @LIBS@
 
 USE_64_BIT_IDX_T = @USE_64_BIT_IDX_T@
 
 # The arguments passed to configure.
 config_opts = @config_opts@
 
 # ==================== Where To Install Things ====================
@@ -244,16 +249,19 @@ infodir = @infodir@
 # The fill path to the default info file.
 infofile = @infofile@
 
 # ==================== Octave-specific directories ====================
 
 # These variables hold the values specific to Octave.  They are
 # based on the values of the standard Make variables above.
 
+# What is the path separation character
+sepchar = @sepchar@
+
 # Where to install Octave's include files (they will actually be
 # installed in a subdirectory called octave).  The default is
 # ${includedir}/octave-${version}
 octincludedir = @octincludedir@
 
 # Where to install the function file distributed with
 # Octave.  This includes the Octave version, so that the
 # function files for different versions of Octave will install
@@ -392,137 +400,138 @@ endef
 
 # Yes, the second sed command near the end is needed, to avoid limits
 # in command lengths for some versions of sed.  UGLY_DEFS is often
 # quite large, so it makes sense to split this command there.
 
 define do-subst-config-vals
 echo "making $@ from $<"
 $(SED) < $< \
-  -e "s;%NO_OCT_FILE_STRIP%;${NO_OCT_FILE_STRIP};" \
-  -e "s;%OCTAVE_BINDIR%;\"${bindir}\";" \
-  -e "s;%OCTAVE_CONF_ALL_CFLAGS%;\"${ALL_CFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_ALL_CXXFLAGS%;\"${ALL_CXXFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_ALL_FFLAGS%;\"${ALL_FFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_ALL_LDFLAGS%;\"${ALL_LDFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_AR%;\"${AR}\";" \
-  -e "s;%OCTAVE_CONF_ARFLAGS%;\"${ARFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_BLAS_LIBS%;\"${BLAS_LIBS}\";" \
-  -e "s;%OCTAVE_CONF_CANONICAL_HOST_TYPE%;\"${canonical_host_type}\";" \
-  -e "s;%OCTAVE_CONF_CC%;\"${CC}\";" \
-  -e "s;%OCTAVE_CONF_CC_VERSION%;\"${CC_VERSION}\";" \
-  -e "s;%OCTAVE_CONF_CFLAGS%;\"${CFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_CPICFLAG%;\"${CPICFLAG}\";" \
-  -e "s;%OCTAVE_CONF_CPPFLAGS%;\"${CPPFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_CXX%;\"${CXX}\";" \
-  -e "s;%OCTAVE_CONF_CXXCPP%;\"${CXXCPP}\";" \
-  -e "s;%OCTAVE_CONF_CXXFLAGS%;\"${CXXFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_CXXPICFLAG%;\"${CXXPICFLAG}\";" \
-  -e "s;%OCTAVE_CONF_CXX_VERSION%;\"${CXX_VERSION}\";" \
-  -e "s;%OCTAVE_CONF_DEFAULT_PAGER%;\"${DEFAULT_PAGER}\";" \
-  -e "s;%OCTAVE_CONF_DEPEND_FLAGS%;\"${DEPEND_FLAGS}\";" \
-  -e "s;%OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%;\"${DEPEND_EXTRA_SED_PATTERN}\";" \
-  -e "s;%OCTAVE_CONF_DLFCN_INCFLAGS%;\"${DLFCN_INCFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_DL_LD%;\"${DL_LD}\";" \
-  -e "s;%OCTAVE_CONF_DL_LDFLAGS%;\"${DL_LDFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_EXEEXT%;\"${EXEEXT}\";" \
-  -e "s;%OCTAVE_CONF_F2C%;\"${F2C}\";" \
-  -e "s;%OCTAVE_CONF_F2CFLAGS%;\"${F2CFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_F77%;\"${F77}\";" \
-  -e "s;%OCTAVE_CONF_FC%;\"${FC}\";" \
-  -e "s;%OCTAVE_CONF_FFLAGS%;\"${FFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_FFTW_LIBS%;\"${FFTW_LIBS}\";" \
-  -e "s;%OCTAVE_CONF_FLIBS%;\"${FLIBS}\";" \
-  -e "s;%OCTAVE_CONF_FPICFLAG%;\"${FPICFLAG}\";" \
-  -e "s;%OCTAVE_CONF_GLPK_LIBS%;\"${GLPK_LIBS}\";" \
-  -e "s;%OCTAVE_CONF_INCFLAGS%;\"${INCFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_LD_CXX%;\"${LD_CXX}\";" \
-  -e "s;%OCTAVE_CONF_LDFLAGS%;\"${LDFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_LD_STATIC_FLAG%;\"${LD_STATIC_FLAG}\";" \
-  -e "s;%OCTAVE_CONF_LEX%;\"${LEX}\";" \
-  -e "s;%OCTAVE_CONF_LEXLIB%;\"${LEXLIB}\";" \
-  -e "s;%OCTAVE_CONF_LFLAGS%;\"${LFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_LIBCRUFT%;\"${LIBCRUFT}\";" \
-  -e "s;%OCTAVE_CONF_LIBDLFCN%;\"${LIBDLFCN}\";" \
-  -e "s;%OCTAVE_CONF_LIBEXT%;\"${LIBEXT}\";" \
-  -e "s;%OCTAVE_CONF_LIBFLAGS%;\"${LIBFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_LIBOCTAVE%;\"${LIBOCTAVE}\";" \
-  -e "s;%OCTAVE_CONF_LIBOCTINTERP%;\"${LIBOCTINTERP}\";" \
-  -e "s;%OCTAVE_CONF_LIBPLPLOT%;\"${LIBPLPLOT}\";" \
-  -e "s;%OCTAVE_CONF_LIBREADLINE%;\"${LIBREADLINE}\";" \
-  -e "s;%OCTAVE_CONF_LIBS%;\"${LIBS}\";" \
-  -e "s;%OCTAVE_CONF_LN_S%;\"${LN_S}\";" \
-  -e "s;%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%;\"${MKOCTFILE_DL_LDFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_MKOCTFILE_INCFLAGS%;\"${MKOCTFILE_INCFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_MKOCTFILE_LFLAGS%;\"${MKOCTFILE_LFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_RANLIB%;\"${RANLIB}\";" \
-  -e "s;%OCTAVE_CONF_RDYNAMIC_FLAG%;\"${RDYNAMIC_FLAG}\";" \
-  -e "s;%OCTAVE_CONF_RLD_FLAG%;\"${RLD_FLAG}\";" \
-  -e "s;%OCTAVE_CONF_RUNTEST%;\"${RUNTEST}\";" \
-  -e "s;%OCTAVE_CONF_SED%;\"${SED}\";" \
-  -e "s;%OCTAVE_CONF_SHARED_LIBS%;\"${SHARED_LIBS}\";" \
-  -e "s;%OCTAVE_CONF_SHLEXT%;\"${SHLEXT}\";" \
-  -e "s;%OCTAVE_CONF_SHLLINKEXT%;\"${SHLLINKEXT}\";" \
-  -e "s;%OCTAVE_CONF_SHLEXT_VER%;\"${SHLEXT_VER}\";" \
-  -e "s;%OCTAVE_CONF_SH_LD%;\"${SH_LD}\";" \
-  -e "s;%OCTAVE_CONF_SH_LDFLAGS%;\"${SH_LDFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_SONAME_FLAGS%;\"${SONAME_FLAGS}\";" \
-  -e "s;%OCTAVE_CONF_STATIC_LIBS%;\"${STATIC_LIBS}\";" \
-  -e "s;%OCTAVE_CONF_UGLY_DEFS%;\"${UGLY_DEFS}\";" \
-  -e "s;%OCTAVE_CONF_USE_64_BIT_IDX_T%;\"${USE_64_BIT_IDX_T}\";" \
-  -e "s;%OCTAVE_CONF_VERSION%;\"${version}\";" \
-  -e "s;%OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%;\"${ENABLE_DYNAMIC_LINKING}\";" \
-  -e "s;%OCTAVE_CONF_XTRA_CFLAGS%;\"${XTRA_CFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_XTRA_CXXFLAGS%;\"${XTRA_CXXFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_YACC%;\"${YACC}\";" \
-  -e "s;%OCTAVE_CONF_YFLAGS%;\"${YFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_config_opts%;\"${config_opts}\";" | \
-  $(SED)  -e "s;%OCTAVE_CONF_DEFS%;\"${UGLY_DEFS}\";" > $@-t
+  -e "s|%NO_OCT_FILE_STRIP%|${NO_OCT_FILE_STRIP}|" \
+  -e "s|%OCTAVE_BINDIR%|\"${bindir}\"|" \
+  -e "s|%OCTAVE_CONF_ALL_CFLAGS%|\"${ALL_CFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ALL_CXXFLAGS%|\"${ALL_CXXFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ALL_FFLAGS%|\"${ALL_FFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ALL_LDFLAGS%|\"${ALL_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_AR%|\"${AR}\"|" \
+  -e "s|%OCTAVE_CONF_ARFLAGS%|\"${ARFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_BLAS_LIBS%|\"${BLAS_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_CANONICAL_HOST_TYPE%|\"${canonical_host_type}\"|" \
+  -e "s|%OCTAVE_CONF_CC%|\"${CC}\"|" \
+  -e "s|%OCTAVE_CONF_CC_VERSION%|\"${CC_VERSION}\"|" \
+  -e "s|%OCTAVE_CONF_CFLAGS%|\"${CFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_CPICFLAG%|\"${CPICFLAG}\"|" \
+  -e "s|%OCTAVE_CONF_CPPFLAGS%|\"${CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_CXX%|\"${CXX}\"|" \
+  -e "s|%OCTAVE_CONF_CXXCPP%|\"${CXXCPP}\"|" \
+  -e "s|%OCTAVE_CONF_CXXFLAGS%|\"${CXXFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_CXXPICFLAG%|\"${CXXPICFLAG}\"|" \
+  -e "s|%OCTAVE_CONF_CXX_VERSION%|\"${CXX_VERSION}\"|" \
+  -e "s|%OCTAVE_CONF_DEFAULT_PAGER%|\"${DEFAULT_PAGER}\"|" \
+  -e "s|%OCTAVE_CONF_DEPEND_FLAGS%|\"${DEPEND_FLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%|\"${DEPEND_EXTRA_SED_PATTERN}\"|" \
+  -e "s|%OCTAVE_CONF_DLFCN_INCFLAGS%|\"${DLFCN_INCFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_DL_LD%|\"${DL_LD}\"|" \
+  -e "s|%OCTAVE_CONF_DL_LDFLAGS%|\"${DL_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_EXEEXT%|\"${EXEEXT}\"|" \
+  -e "s|%OCTAVE_CONF_F2C%|\"${F2C}\"|" \
+  -e "s|%OCTAVE_CONF_F2CFLAGS%|\"${F2CFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_F77%|\"${F77}\"|" \
+  -e "s|%OCTAVE_CONF_FC%|\"${FC}\"|" \
+  -e "s|%OCTAVE_CONF_FFLAGS%|\"${FFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_FFTW_LIBS%|\"${FFTW_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_FLIBS%|\"${FLIBS}\"|" \
+  -e "s|%OCTAVE_CONF_FPICFLAG%|\"${FPICFLAG}\"|" \
+  -e "s|%OCTAVE_CONF_GLPK_LIBS%|\"${GLPK_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_INCFLAGS%|\"${INCFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LD_CXX%|\"${LD_CXX}\"|" \
+  -e "s|%OCTAVE_CONF_LDFLAGS%|\"${LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LD_STATIC_FLAG%|\"${LD_STATIC_FLAG}\"|" \
+  -e "s|%OCTAVE_CONF_LEX%|\"${LEX}\"|" \
+  -e "s|%OCTAVE_CONF_LEXLIB%|\"${LEXLIB}\"|" \
+  -e "s|%OCTAVE_CONF_LFLAGS%|\"${LFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LIBCRUFT%|\"${LIBCRUFT}\"|" \
+  -e "s|%OCTAVE_CONF_LIBDLFCN%|\"${LIBDLFCN}\"|" \
+  -e "s|%OCTAVE_CONF_LIBEXT%|\"${LIBEXT}\"|" \
+  -e "s|%OCTAVE_CONF_LIBFLAGS%|\"${LIBFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LIBGLOB%|\"${LIBGLOB}\"|" \
+  -e "s|%OCTAVE_CONF_LIBOCTAVE%|\"${LIBOCTAVE}\"|" \
+  -e "s|%OCTAVE_CONF_LIBOCTINTERP%|\"${LIBOCTINTERP}\"|" \
+  -e "s|%OCTAVE_CONF_LIBPLPLOT%|\"${LIBPLPLOT}\"|" \
+  -e "s|%OCTAVE_CONF_LIBREADLINE%|\"${LIBREADLINE}\"|" \
+  -e "s|%OCTAVE_CONF_LIBS%|\"${LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_LN_S%|\"${LN_S}\"|" \
+  -e "s|%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%|\"${MKOCTFILE_DL_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_MKOCTFILE_INCFLAGS%|\"${MKOCTFILE_INCFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_MKOCTFILE_LFLAGS%|\"${MKOCTFILE_LFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_RANLIB%|\"${RANLIB}\"|" \
+  -e "s|%OCTAVE_CONF_RDYNAMIC_FLAG%|\"${RDYNAMIC_FLAG}\"|" \
+  -e "s|%OCTAVE_CONF_RLD_FLAG%|\"${RLD_FLAG}\"|" \
+  -e "s|%OCTAVE_CONF_RUNTEST%|\"${RUNTEST}\"|" \
+  -e "s|%OCTAVE_CONF_SED%|\"${SED}\"|" \
+  -e "s|%OCTAVE_CONF_SHARED_LIBS%|\"${SHARED_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_SHLEXT%|\"${SHLEXT}\"|" \
+  -e "s|%OCTAVE_CONF_SHLLINKEXT%|\"${SHLLINKEXT}\"|" \
+  -e "s|%OCTAVE_CONF_SHLEXT_VER%|\"${SHLEXT_VER}\"|" \
+  -e "s|%OCTAVE_CONF_SH_LD%|\"${SH_LD}\"|" \
+  -e "s|%OCTAVE_CONF_SH_LDFLAGS%|\"${SH_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_SONAME_FLAGS%|\"${SONAME_FLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_STATIC_LIBS%|\"${STATIC_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_UGLY_DEFS%|\"${UGLY_DEFS}\"|" \
+  -e "s|%OCTAVE_CONF_USE_64_BIT_IDX_T%|\"${USE_64_BIT_IDX_T}\"|" \
+  -e "s|%OCTAVE_CONF_VERSION%|\"${version}\"|" \
+  -e "s|%OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%|\"${ENABLE_DYNAMIC_LINKING}\"|" \
+  -e "s|%OCTAVE_CONF_XTRA_CFLAGS%|\"${XTRA_CFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_XTRA_CXXFLAGS%|\"${XTRA_CXXFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_YACC%|\"${YACC}\"|" \
+  -e "s|%OCTAVE_CONF_YFLAGS%|\"${YFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_config_opts%|\"${config_opts}\"|" | \
+  $(SED)  -e "s|%OCTAVE_CONF_DEFS%|\"${UGLY_DEFS}\"|" > $@-t
 $(top_srcdir)/move-if-change $@-t $@
 endef
 
 define do-subst-default-vals
 echo "making $@ from $<"
 $(SED) < $< > $@-t \
-  -e "s;%OCTAVE_ARCHLIBDIR%;\"${archlibdir}\";" \
-  -e "s;%OCTAVE_BINDIR%;\"${bindir}\";" \
-  -e "s;%OCTAVE_CANONICAL_HOST_TYPE%;\"${canonical_host_type}\";" \
-  -e "s;%OCTAVE_DATADIR%;\"${datadir}\";" \
-  -e "s;%OCTAVE_DEFAULT_PAGER%;\"${DEFAULT_PAGER}\";" \
-  -e "s;%OCTAVE_EXEC_PREFIX%;\"${exec_prefix}\";" \
-  -e "s;%OCTAVE_FCNFILEDIR%;\"${fcnfiledir}\";" \
-  -e "s;%OCTAVE_FCNFILEPATH%;\"${fcnfilepath}\";" \
-  -e "s;%OCTAVE_IMAGEDIR%;\"${imagedir}\";" \
-  -e "s;%OCTAVE_IMAGEPATH%;\"${imagepath}\";" \
-  -e "s;%OCTAVE_INCLUDEDIR%;\"${includedir}\";" \
-  -e "s;%OCTAVE_INFODIR%;\"${infodir}\";" \
-  -e "s;%OCTAVE_INFOFILE%;\"${infofile}\";" \
-  -e "s;%OCTAVE_LIBDIR%;\"${libdir}\";" \
-  -e "s;%OCTAVE_LIBEXECDIR%;\"${libexecdir}\";" \
-  -e "s;%OCTAVE_LOCALAPIFCNFILEDIR%;\"${localapifcnfiledir}\";" \
-  -e "s;%OCTAVE_LOCALAPIOCTFILEDIR%;\"${localapioctfiledir}\";" \
-  -e "s;%OCTAVE_LOCALARCHLIBDIR%;\"${localarchlibdir}\";" \
-  -e "s;%OCTAVE_LOCALFCNFILEDIR%;\"${localfcnfiledir}\";" \
-  -e "s;%OCTAVE_LOCALFCNFILEPATH%;\"${localfcnfilepath}\";" \
-  -e "s;%OCTAVE_LOCALOCTFILEDIR%;\"${localoctfiledir}\";" \
-  -e "s;%OCTAVE_LOCALOCTFILEPATH%;\"${localoctfilepath}\";" \
-  -e "s;%OCTAVE_LOCALSTARTUPFILEDIR%;\"${localstartupfiledir}\";" \
-  -e "s;%OCTAVE_LOCALVERARCHLIBDIR%;\"${localverarchlibdir}\";" \
-  -e "s;%OCTAVE_LOCALVERFCNFILEDIR%;\"${localverfcnfiledir}\";" \
-  -e "s;%OCTAVE_LOCALVEROCTFILEDIR%;\"${localveroctfiledir}\";" \
-  -e "s;%OCTAVE_MAN1DIR%;\"${man1dir}\";" \
-  -e "s;%OCTAVE_MAN1EXT%;\"${man1ext}\";" \
-  -e "s;%OCTAVE_MANDIR%;\"${mandir}\";" \
-  -e "s;%OCTAVE_OCTFILEDIR%;\"${octfiledir}\";" \
-  -e "s;%OCTAVE_OCTINCLUDEDIR%;\"${octincludedir}\";" \
-  -e "s;%OCTAVE_OCTLIBDIR%;\"${octlibdir}\";" \
-  -e "s;%OCTAVE_STARTUPFILEDIR%;\"${startupfiledir}\";" \
-  -e "s;%OCTAVE_PREFIX%;\"${prefix}\";" \
-  -e "s;%OCTAVE_API_VERSION%;\"${apiversion}\";" \
-  -e "s;%OCTAVE_VERSION%;\"${version}\";"
+  -e "s|%OCTAVE_ARCHLIBDIR%|\"${archlibdir}\"|" \
+  -e "s|%OCTAVE_BINDIR%|\"${bindir}\"|" \
+  -e "s|%OCTAVE_CANONICAL_HOST_TYPE%|\"${canonical_host_type}\"|" \
+  -e "s|%OCTAVE_DATADIR%|\"${datadir}\"|" \
+  -e "s|%OCTAVE_DEFAULT_PAGER%|\"${DEFAULT_PAGER}\"|" \
+  -e "s|%OCTAVE_EXEC_PREFIX%|\"${exec_prefix}\"|" \
+  -e "s|%OCTAVE_FCNFILEDIR%|\"${fcnfiledir}\"|" \
+  -e "s|%OCTAVE_FCNFILEPATH%|\"${fcnfilepath}\"|" \
+  -e "s|%OCTAVE_IMAGEDIR%|\"${imagedir}\"|" \
+  -e "s|%OCTAVE_IMAGEPATH%|\"${imagepath}\"|" \
+  -e "s|%OCTAVE_INCLUDEDIR%|\"${includedir}\"|" \
+  -e "s|%OCTAVE_INFODIR%|\"${infodir}\"|" \
+  -e "s|%OCTAVE_INFOFILE%|\"${infofile}\"|" \
+  -e "s|%OCTAVE_LIBDIR%|\"${libdir}\"|" \
+  -e "s|%OCTAVE_LIBEXECDIR%|\"${libexecdir}\"|" \
+  -e "s|%OCTAVE_LOCALAPIFCNFILEDIR%|\"${localapifcnfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALAPIOCTFILEDIR%|\"${localapioctfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALARCHLIBDIR%|\"${localarchlibdir}\"|" \
+  -e "s|%OCTAVE_LOCALFCNFILEDIR%|\"${localfcnfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALFCNFILEPATH%|\"${localfcnfilepath}\"|" \
+  -e "s|%OCTAVE_LOCALOCTFILEDIR%|\"${localoctfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALOCTFILEPATH%|\"${localoctfilepath}\"|" \
+  -e "s|%OCTAVE_LOCALSTARTUPFILEDIR%|\"${localstartupfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALVERARCHLIBDIR%|\"${localverarchlibdir}\"|" \
+  -e "s|%OCTAVE_LOCALVERFCNFILEDIR%|\"${localverfcnfiledir}\"|" \
+  -e "s|%OCTAVE_LOCALVEROCTFILEDIR%|\"${localveroctfiledir}\"|" \
+  -e "s|%OCTAVE_MAN1DIR%|\"${man1dir}\"|" \
+  -e "s|%OCTAVE_MAN1EXT%|\"${man1ext}\"|" \
+  -e "s|%OCTAVE_MANDIR%|\"${mandir}\"|" \
+  -e "s|%OCTAVE_OCTFILEDIR%|\"${octfiledir}\"|" \
+  -e "s|%OCTAVE_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
+  -e "s|%OCTAVE_OCTLIBDIR%|\"${octlibdir}\"|" \
+  -e "s|%OCTAVE_STARTUPFILEDIR%|\"${startupfiledir}\"|" \
+  -e "s|%OCTAVE_PREFIX%|\"${prefix}\"|" \
+  -e "s|%OCTAVE_API_VERSION%|\"${apiversion}\"|" \
+  -e "s|%OCTAVE_VERSION%|\"${version}\"|"
 $(top_srcdir)/move-if-change $@-t $@
 endef
 
 define do-script-install
 $(top_srcdir)/mkinstalldirs \
   $(addprefix $(DESTDIR), $(fcnfiledir)/$(script_sub_dir))
 for f in $(FCN_FILES_NO_DIR); do \
   rm -f $(DESTDIR)$(fcnfiledir)/$(script_sub_dir)/$$f; \
diff --git a/acx_include_dirs.m4 b/acx_include_dirs.m4
new file mode 100644
--- /dev/null
+++ b/acx_include_dirs.m4
@@ -0,0 +1,35 @@
+dnl @synopsis ACX_CHECK_HEADER_IN_DIRS (HEADER, DIR-LIST, [
+dnl			ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND[, MESSAGE]]])
+dnl
+dnl This macro looks for a header file in the include directories
+dnl and in the sub-directories specified by DIR-LIST.
+dnl
+dnl This macro requires autoconf 2.50 or later.
+dnl
+dnl @version $Id: acx_include_dirs.m4,v 1.2 2005-09-15 19:52:50 jwe Exp $
+dnl @author David Bateman <dbateman@free.fr>
+dnl
+AC_DEFUN([ACX_CHECK_HEADER_IN_DIRS], [
+AC_PREREQ(2.50)
+acx_include_ok=no
+acx_include_dir=
+
+# First check the header in the base directory
+AC_CHECK_HEADER($1, [acx_include_ok=yes])
+
+# Now check the other directories
+if test x"$acx_include_ok" = xno; then
+  for dir in $2; do
+    AC_CHECK_HEADER(${dir}/$1, [acx_include_ok=yes; acx_include_dir=${dir}; break])
+  done
+fi
+
+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
+if test x"$acx_include_ok" = xyes; then
+  acx_header=HEADER_`echo $1 | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  ifelse([$3],,AC_DEFINE(${acx_header},$acx_include_dir/$1,[$5]),[$3])
+else
+  $4
+fi
+])dnl ACX_CHECK_HEADER_IN_DIRS
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,76 +24,95 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.480 $)
+AC_REVISION($Revision: 1.481 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
 AC_GNU_SOURCE
 
 AC_AIX
 AC_MINIX
 AC_ISC_POSIX
 
+### Path separator.
+sepchar=:
+AC_ARG_WITH(sepchar,
+  [AC_HELP_STRING([--with-sepchar=<char>],
+	[use <char> as the path separation character])])
+case $with_sepchar in
+  yes | "")
+    case "$canonical_host_type" in
+      *-*-mingw*)
+	sepchar=';'
+        ;;
+      esac
+    ;;
+  no)
+    AC_MSG_ERROR([You are required to define a path separation character])
+    ;;
+  *)
+    sepchar=$with_sepchar
+    ;;
+esac
+AC_SUBST(sepchar)
+AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'], [Define this to be the path separator for your system, as a character constant.])
+AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"], [Define this to the path separator, as a string.])
+
 ### some defaults
 
 OCTAVE_SET_DEFAULT(man1dir, '$(mandir)/man1')
 OCTAVE_SET_DEFAULT(man1ext, '.1')
 OCTAVE_SET_DEFAULT(infofile, '$(infodir)/octave.info')
 OCTAVE_SET_DEFAULT(octincludedir, '$(includedir)/octave-$(version)')
 OCTAVE_SET_DEFAULT(fcnfiledir, '$(datadir)/octave/$(version)/m')
 OCTAVE_SET_DEFAULT(localfcnfiledir, '$(datadir)/octave/site/m')
 OCTAVE_SET_DEFAULT(localapifcnfiledir,
   '$(datadir)/octave/site/$(apiversion)/m')
 OCTAVE_SET_DEFAULT(localverfcnfiledir, '$(datadir)/octave/$(version)/site/m')
 OCTAVE_SET_DEFAULT(localfcnfilepath,
-  '$(localverfcnfiledir)//:$(localapifcnfiledir)//:$(localfcnfiledir)//')
+  '$(localverfcnfiledir)//$(sepchar)$(localapifcnfiledir)//$(sepchar)$(localfcnfiledir)//')
 OCTAVE_SET_DEFAULT(octlibdir, '$(libdir)/octave-$(version)')
 OCTAVE_SET_DEFAULT(archlibdir,
   '$(libexecdir)/octave/$(version)/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localarchlibdir,
   '$(libexecdir)/octave/site/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localverarchlibdir,
   '$(libexecdir)/octave/$(version)/site/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(octfiledir,
   '$(libexecdir)/octave/$(version)/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localoctfiledir,
   '$(libexecdir)/octave/site/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localapioctfiledir,
   '$(libexecdir)/octave/site/oct/$(apiversion)/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localveroctfiledir,
   '$(libexecdir)/octave/$(version)/site/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT(localoctfilepath,
-  '$(localveroctfiledir)//:$(localapioctfiledir)//:$(localoctfiledir)//')
+  '$(localveroctfiledir)//$(sepchar)$(localapioctfiledir)//$(sepchar)$(localoctfiledir)//')
 OCTAVE_SET_DEFAULT(fcnfilepath,
-  '.:$(localoctfilepath):$(localfcnfilepath):$(octfiledir)//:$(fcnfiledir)//')
+  '.$(sepchar)$(localoctfilepath)$(sepchar)$(localfcnfilepath)$(sepchar)$(octfiledir)//$(sepchar)$(fcnfiledir)//')
 OCTAVE_SET_DEFAULT(imagedir, '$(datadir)/octave/$(version)/imagelib')
-OCTAVE_SET_DEFAULT(imagepath, '.:$(imagedir)//')
+OCTAVE_SET_DEFAULT(imagepath, '.$(sepchar)$(imagedir)//')
 
 ### Make configure args available for other uses.
 
 config_opts=$ac_configure_args
 AC_SUBST(config_opts)
 
-### Path separator.
-
-AC_DEFINE(SEPCHAR, [':'], Define this to be the path separator for your system, as a character constant.])
-AC_DEFINE(SEPCHAR_STR, [":"], [Define this to the path separator, as a string.])
-
 ### Allow the user to force us to use f2c.
 
 AC_ARG_WITH(f2c,
   [  --with-f2c              use f2c even if Fortran compiler is available],
   [if test "$withval" = no; then use_f2c=false; else use_f2c=true; fi],
   use_f2c=false)
 
 ### Allow the user to force us to use f77.
@@ -687,65 +706,156 @@ FC=$F77
 AC_SUBST(FC)
 AC_SUBST_FILE(f77_rules_frag)
 
 ### Checks for BLAS and LAPACK libraries:
 # (Build subdirectories of libcruft if they aren't found on the system.)
 
 sinclude(acx_blas.m4)
 sinclude(acx_lapack.m4)
+sinclude(acx_include_dirs.m4)
 ACX_BLAS([], [BLAS_DIR="blas"])
 ACX_LAPACK([BLAS_LIBS="$LAPACK_LIBS $BLAS_LIBS"], [LAPACK_DIR="lapack"])
 AC_SUBST(BLAS_DIR)
 AC_SUBST(LAPACK_DIR)
 
+# Check for AMD library
+AMD_LIBS=
+AC_SUBST(AMD_LIBS)
+AC_CHECK_LIB(amd, amd_postorder, [AMD_LIBS="-lamd"; with_amd=yes],[with_amd=no])
+
 # Check for UMFPACK library.
 
 UMFPACK_LIBS=
 AC_SUBST(UMFPACK_LIBS)
+UMFPACK_INCLUDE=umfpack.h
+AC_SUBST(UMFPACK_INCLUDE)
 
 AC_ARG_WITH(umfpack,
   [  --without-umfpack       don't use UMFPACK, disable some sparse functionality],
   with_umfpack=$withval, with_umfpack=yes)
 
-if test "$with_umfpack" = "yes"; then
-  have_umfpack_header=no
+if test "$with_umfpack" = "yes" && test "$with_amd" = "yes"; then
   with_umfpack=no
-  AC_CHECK_HEADER(umfpack/umfpack.h, [have_umfpack_header=yes; break])
-  if test "$have_umfpack_header" = yes; then
-    AC_CHECK_LIB(amd, amd_postorder, [
+  ACX_CHECK_HEADER_IN_DIRS(umfpack.h, [umfpack ufsparse],[
       AC_CHECK_LIB(umfpack, umfpack_zi_get_determinant, [
-        UMFPACK_LIBS="-lumfpack -lamd"; with_umfpack=yes], [
+        UMFPACK_LIBS="-lumfpack"; with_umfpack=yes], [
 	  ## Invalidate the cache.
 	  $as_unset ac_cv_lib_umfpack_umfpack_zi_get_determinant
 	  AC_CHECK_LIB(umfpack, umfpack_zi_get_determinant, [
-            UMFPACK_LIBS="-lumfpack -lamd"; with_umfpack=yes], [
+            UMFPACK_LIBS="-lumfpack"; with_umfpack=yes], [
 
 	    ## Invalidate the cache.
 	    $as_unset ac_cv_lib_umfpack_umfpack_zi_get_determinant
 	    AC_CHECK_LIB(umfpack, umfpack_zi_get_determinant, [
-              UMFPACK_LIBS="-lumfpack -lamd -lcblas"; with_umfpack=yes], [], -lamd -lcblas $BLAS_LIBS)], -lamd $BLAS_LIBS $FLIBS)]), -lamd])
+              UMFPACK_LIBS="-lumfpack -lcblas"; with_umfpack=yes], [], $AMD_LIBS -lcblas $BLAS_LIBS)], $AMD_LIBS $BLAS_LIBS $FLIBS)], $AMD_LIBS)
+
     if test "$with_umfpack" = yes; then
       # For now the code needed for this is not in umfpack, will add
       # a test later that will probably have to be based on version
       # numbers as there is no interface changes that are visible at
       # compile time.
       with_umfpack_split=no
     fi
-  fi
+
+    if test "$with_umfpack" = yes; then
+      AC_DEFINE(HAVE_UMFPACK, 1, [Define if the UMFPACK library is used.])
+      if test x"$acx_include_dir" != x; then
+	UMFPACK_INCLUDE=$acx_include_dir/umfpack.h
+      fi
+      if test "$with_umfpack_split" = yes; then
+        AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, [Define if the UMFPACK Complex solver allow matrix and RHS to be split independently])
+      fi
+    else
+      warn_umfpack="UMFPACK not found.  This will result in some lack of functionality for sparse matrices."
+    fi],[
+  warn_umfpack="UMFPACK not found.  This will result in some lack of functionality for sparse matrices."])
 fi
 
-if test "$with_umfpack" = yes; then
-  AC_DEFINE(HAVE_UMFPACK, 1, [Define if the UMFPACK library is used.])
-  if test "$with_umfpack_split" = yes; then
-    AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, [Define if the UMFPACK Complex solver allow matrix and RHS to be split independently])
-  fi
-else
-  warn_umfpack="UMFPACK not found.  This will result in some lack of functionality for sparse matrices."
-fi
+COLAMD_LIBS=
+AC_SUBST(COLAMD_LIBS)
+COLAMD_INCLUDE=colamd.h
+AC_SUBST(COLAMD_INCLUDE)
+
+AC_ARG_WITH(colamd,
+  [  --without-colamd       don't use COLAMD, disable some sparse functionality],
+  with_colamd=$withval, with_colamd=yes)
+
+if test "$with_colamd" = "yes"; then
+  with_colamd=no
+  ACX_CHECK_HEADER_IN_DIRS(colamd.h, [umfpack ufsparse],[
+    AC_CHECK_LIB(colamd, colamd, [COLAMD_LIBS="-lcolamd"; with_colamd=yes])
+
+    if test "$with_colamd" = yes; then
+      if test x"$acx_include_dir" != x; then
+        COLAMD_INCLUDE=$acx_include_dir/colamd.h
+      fi
+      AC_DEFINE(HAVE_COLAMD, 1, [Define if the COLAMD library is used.])
+    else
+      warn_colamd="COLAMD not found. This will result in some lack of functionality for sparse matrices."
+    fi],[
+      warn_colamd="COLAMD not found. This will result in some lack of functionality for sparse matrices."])
+fi 
+
+CCOLAMD_LIBS=
+AC_SUBST(CCOLAMD_LIBS)
+CCOLAMD_INCLUDE=ccolamd.h
+AC_SUBST(CCOLAMD_INCLUDE)
+
+AC_ARG_WITH(ccolamd,
+  [  --without-ccolamd       don't use CCOLAMD, disable some sparse functionality],
+  with_ccolamd=$withval, with_ccolamd=yes)
+
+if test "$with_ccolamd" = "yes"; then
+  with_ccolamd=no
+  ACX_CHECK_HEADER_IN_DIRS(ccolamd.h, [umfpack ufsparse],[
+    AC_CHECK_LIB(ccolamd, ccolamd, [CCOLAMD_LIBS="-lccolamd"; with_ccolamd=yes])
+
+    if test "$with_ccolamd" = yes; then
+      if test x"$acx_include_dir" != x; then
+        CCOLAMD_INCLUDE=$acx_include_dir/ccolamd.h
+      fi
+      AC_DEFINE(HAVE_CCOLAMD, 1, [Define if the CCOLAMD library is used.])
+    else
+      warn_ccolamd="CCOLAMD not found. This will result in some lack of functionality for sparse matrices."
+    fi],[
+      warn_colamd="CCOLAMD not found. This will result in some lack of functionality for sparse matrices."])
+fi 
+
+CHOLMOD_LIBS=
+AC_SUBST(CHOLMOD_LIBS)
+CHOLMOD_INCLUDE=cholmod.h
+AC_SUBST(CHOLMOD_INCLUDE)
+
+AC_ARG_WITH(cholmod,
+  [  --without-cholmod       don't use CHOLMOD, disable some sparse functionality],
+  with_cholmod=$withval, with_cholmod=yes)
+
+if test "$with_cholmod" = "yes" && test "$with_colamd" = "yes" &&
+	test "$with_ccolamd" = "yes" && test "$with_amd" = "yes"; then
+  with_cholmod=no
+  ACX_CHECK_HEADER_IN_DIRS(cholmod.h, [umfpack ufsparse],[
+    AC_CHECK_LIB(metis, METIS_NodeND, [
+      AC_CHECK_LIB(cholmod, cholmod_start, [CHOLMOD_LIBS="-lcholmod -lmetis"; 
+	with_cholmod=yes], [
+        AC_CHECK_LIB(cholmod_start, cholmod, [CHOLMOD_LIBS="-lcholmod -cblas -lmetis"; 
+	  with_cholmod=yes], [],
+          AMD_LIBS $COLAMD_LIBS $CCOLAMD_LIBS $BLAS_LIBS $FLIBS -lmetis)],
+	$AMD_LIBS $COLAMD_LIBS $CCOLAMD_LIBS $BLAS_LIBS $FLIBS -lmetis)])
+
+    if test "$with_cholmod" = yes; then
+      if test x"$acx_include_dir" != x; then
+        CHOLMOD_INCLUDE=$acx_include_dir/cholmod.h
+      fi
+      AC_DEFINE(HAVE_CHOLMOD, 1, [Define if the CHOLMOD library is used.])
+    else
+      warn_cholmod="CHOLMOD not found. This will result in some lack of functionality for sparse matrices."
+    fi],[
+      warn_colamd="CHOLMOD not found. This will result in some lack of functionality for sparse matrices."])
+fi 
 
 ### Handle shared library options.
 
 ### Enable creation of static libraries.
 
 AC_ARG_ENABLE(static,
   [  --enable-static         create static libraries],
   [if test "$enableval" = no; then STATIC_LIBS=false;
@@ -839,16 +949,17 @@ case "$canonical_host_type" in
     SHLLIB='$(SHLEXT)'
     SHLEXT_VER='$(version).$(SHLEXT)'
     SHLLIB_VER='$(version).$(SHLLIB)'
     NO_OCT_FILE_STRIP=true
     SONAME_FLAGS='-install_name $(octlibdir)/$@'
     library_path_var=DYLD_LIBRARY_PATH	
   ;;
   *-*-cygwin* | *-*-mingw*)
+    DL_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-runtime-pseudo-reloc"
     CXXPICFLAG=
     CPICFLAG=
     FPICFLAG=
     SHLEXT=dll
     SHLLIB=dll.a
     SHLBIN=dll
     SH_LDFLAGS="-shared -Wl,--export-all-symbols -Wl,--enable-auto-import -Wl,--enable-auto-image-base"
     SHLLINKEXT=.dll
@@ -985,16 +1096,17 @@ AC_SUBST(library_path_var)
 ### functions like gethostname and gettimeofday is in libsocket.
 
 AC_CHECK_FUNCS(gethostname, [], [AC_CHECK_LIB(socket, gethostname)])
 AC_CHECK_FUNCS(getpwnam, [], [AC_CHECK_LIB(sun, getpwnam)])
 
 case "$canonical_host_type" in
   *-*-cygwin* | *-*-mingw*)
    AC_CHECK_LIB(wsock32, gethostname)
+   LIBS="$LIBS -lwsock32"
   ;;
 esac
 
 ### Type stuff.
 
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_PID_T
@@ -1050,16 +1162,18 @@ AC_CHECK_HEADERS(assert.h curses.h direc
 AC_LANG_PUSH(C++)
 AC_CHECK_HEADERS(sstream)
 AC_LANG_POP(C++)
 
 have_termios_h=no
 AC_CHECK_HEADERS($TERMIOS_H, have_termios_h=yes)
 AC_CHECK_HEADERS(termio.h, have_termio_h=yes, have_termio_h=no)
 AC_CHECK_HEADERS(sgtty.h, have_sgtty_h=yes, have_sgtty_h=no)
+AC_CHECK_HEADERS(glob.h, have_glob_h=yes, have_glob_h=no)
+AC_CHECK_HEADERS(fnmatch.h, have_fnmatch_h=yes, have_fnmatch_h=no)
 AC_CHECK_HEADERS(conio.h, have_conio_h=yes, have_conio_h=no)
 
 ### I'm told that termios.h is broken on NeXT systems.
 
 case "$canonical_host_type" in
   *-*-nextstep*)
     if test "$have_termios_h" = yes; then
       AC_MSG_WARN([Ignoring termios.h on NeXT systems.])
@@ -1071,16 +1185,33 @@ esac
 if test "$have_termios_h" = yes \
     || test "$have_termio_h" = yes \
     || test "$have_sgtty_h" = yes; then
   true
 else
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
+LIBGLOB=
+AC_SUBST(LIBGLOB)
+if test "$have_fnmatch_h" = yes && test "$have_glob_h" = yes; then
+  AC_CHECK_FUNCS(fnmatch, have_fnmatch=yes, [
+    AC_CHECK_LIB(glob, fnmatch, [have_fnmatch=yes; LIBGLOB=-lglob],
+      have_fnmatch=no)])
+  AC_CHECK_FUNCS(glob, have_glob=yes, [
+    AC_CHECK_LIB(glob, glob, [have_glob=yes; LIBGLOB=-lglob],
+      have_glob=no)])
+
+  if test "$have_fnmatch" != yes || test "$have_glob" != yes; then
+    AC_MSG_ERROR([You are required to have fnmatch and glob])
+  fi
+else
+  AC_MSG_ERROR([You are required to have fnmatch.h and glob.h])
+fi
+
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(atexit basename bcopy bzero canonicalize_file_name \
   dup2 endgrent endpwent execvp fcntl fork getcwd getegid geteuid \
   getgid getgrent getgrgid getgrnam getpgrp getpid getppid getpwent \
   getpwuid gettimeofday getuid getwd _kbhit kill link localtime_r \
   lstat memmove mkdir mkfifo mkstemp on_exit pipe poll putenv raise \
   readlink rename resolvepath rindex rmdir round select setgrent \
@@ -1142,16 +1273,25 @@ if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKI
 	      dlopen_api=true
 	    ;;
 	  esac
 	fi
       fi
     fi
   fi
 
+  ## autoconf test for LoadLibrary appears broken. Bypass for cygwin/mingw 
+  if !($dlopen_api || $shl_load_api || $loadlibrary_api || $dyld_api); then
+    case "$canonical_host_type" in
+      *-*-cygwin* | *-*-mingw*)
+       loadlibrary_api=true;
+      ;;
+    esac
+  fi
+
   if $dlopen_api; then
     DL_API_MSG="(dlopen)"
     AC_DEFINE(HAVE_DLOPEN_API, 1, [Define if your system has dlopen, dlsym, dlerror, and dlclose for dynamic linking])
     OCTAVE_CXX_FLAG(-rdynamic, [RDYNAMIC_FLAG=-rdynamic])
   elif $shl_load_api; then
     DL_API_MSG="(shl_load)"
     AC_DEFINE(HAVE_SHL_LOAD_API, 1, [Define if your system has shl_load and shl_findsym for dynamic linking])
   elif $loadlibrary_api; then
@@ -1580,21 +1720,21 @@ typedef int sig_atomic_t;
 #define SIZEOF_OCTAVE_IDX_TYPE SIZEOF_INT
 #endif
 
 #include "oct-types.h"
 ])
 
 ### Do the substitutions in all the Makefiles.
 
-AC_CONFIG_FILES([Makefile octMakefile Makeconf \
-  test/Makefile dlfcn/Makefile \
-  doc/Makefile doc/faq/Makefile doc/interpreter/Makefile \
-  doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
-  examples/Makefile liboctave/Makefile liboctave/oct-types.h \
+AC_CONFIG_FILES([Makefile octMakefile Makeconf test/Makefile \
+  dlfcn/Makefile doc/Makefile doc/faq/Makefile \
+  doc/interpreter/Makefile doc/liboctave/Makefile \
+  doc/refcard/Makefile emacs/Makefile examples/Makefile \
+  liboctave/Makefile liboctave/oct-sparse.h liboctave/oct-types.h \
   src/Makefile libcruft/Makefile libcruft/Makerules \
   libcruft/amos/Makefile libcruft/blas/Makefile \
   libcruft/daspk/Makefile libcruft/dasrt/Makefile 
   libcruft/dassl/Makefile libcruft/fftpack/Makefile \
   libcruft/lapack/Makefile libcruft/minpack/Makefile \
   libcruft/misc/Makefile libcruft/odepack/Makefile \
   libcruft/ordered-qz/Makefile libcruft/quadpack/Makefile \
   libcruft/ranlib/Makefile libcruft/slatec-fn/Makefile \
@@ -1621,16 +1761,19 @@ Octave is now configured for $canonical_
   C compiler:           $CC $XTRA_CFLAGS $WARN_CFLAGS $CFLAGS
   C++ compiler:         $CXX $XTRA_CXXFLAGS $WARN_CXXFLAGS $CXXFLAGS
   Fortran compiler:     $FORT
   Fortran libraries:    $FLIBS
   BLAS libraries:       $BLAS_LIBS
   FFTW libraries:       $FFTW_LIBS
   GLPK libraries:       $GLPK_LIBS
   UMFPACK libraries:    $UMFPACK_LIBS
+  COLAMD libraries:     $COLAMD_LIBS
+  CCOLAMD libraries:    $CCOLAMD_LIBS
+  CHOLMOD libraries:    $CHOLMOD_LIBS
   HDF5 libraries:       $HDF5_LIBS
   MPI libraries:        $MPI_LIBS
   LIBS:                 $LIBS
   Default pager:        $DEFAULT_PAGER
   gnuplot:              $GNUPLOT_BINARY
 
   Do internal array bounds checking:  $BOUNDS_CHECKING
   Build static libraries:             $STATIC_LIBS
@@ -1712,16 +1855,31 @@ if test -n "$warn_runtest"; then
   warn_msg_printed=true
 fi
 
 if test -n "$warn_umfpack"; then
   AC_MSG_WARN($warn_umfpack)
   warn_msg_printed=true
 fi
 
+if test -n "$warn_colamd"; then
+  AC_MSG_WARN($warn_colamd)
+  warn_msg_printed=true
+fi
+
+if test -n "$warn_ccolamd"; then
+  AC_MSG_WARN($warn_ccolamd)
+  warn_msg_printed=true
+fi
+
+if test -n "$warn_cholmod"; then
+  AC_MSG_WARN($warn_cholmod)
+  warn_msg_printed=true
+fi
+
 if test -n "$warn_hdf5"; then
   AC_MSG_WARN($warn_hdf5)
   warn_msg_printed=true
 fi
 
 if test -n "$warn_zlib"; then
   AC_MSG_WARN($warn_zlib)
   warn_msg_printed=true
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,28 @@
+2005-09-15  John W. Eaton  <jwe@octave.org>
+
+	* misc/quit.h Rename all win32_ symbols to w32.  Change all uses.
+
+2005-09-15  David Bateman  <dbateman@free.fr>
+
+	* Makefile.in (LN_S): Change to DESTDIR before LN_S to avoid
+	lack of symlinks under mingw.
+	* misc/cquit.c (w32_thread_setjmp_mutex, win32_signal_context,
+	win32_signal_to_raise, win32_main_thread_id, win32_main_thread,
+	win32_restore_thread): New static variables.
+	(win32_in_main_thread): Returns 1 if in main thread for win32.
+	(win32_reset_context): Reset context (longjmp style) for win32.
+	(win32_raise_in_main): Raise signal in main thread for win32.
+	(win32_raise): Raise signal for win32.
+	(win32_raise_final): Clean up win32 signalling.
+	(win32_sigint_init): Initialize win32 signalling.
+	* quit.h (win32_sigint_init, win32_raise_final, win32_raise,
+	win32_in_main_thread): Declaration.
+	
 2005-09-14  Daniel  <durbano@shbano.com>
 
 	* lapack/zbdsqr.f: Fix typo in docs.
 	From Jorge Barros de Abreu <ficmatin01@solar.com.br>.
 
 2005-05-06  John W. Eaton  <jwe@octave.org>
 
 	* lapack/dpotri.f, lapack/dlauum.f, lapack/dlauu2.f,
diff --git a/libcruft/Makefile.in b/libcruft/Makefile.in
--- a/libcruft/Makefile.in
+++ b/libcruft/Makefile.in
@@ -123,17 +123,18 @@ install::
 	    $(DESTDIR)$(octlibdir)/libcruft.$(LIBEXT) ; \
 	  $(RANLIB) $(DESTDIR)$(octlibdir)/libcruft.$(LIBEXT) ; \
 	fi
 	if $(SHARED_LIBS); then \
 	  rm -f $(DESTDIR)$(octlibdir)/libcruft.$(SHLLIB_VER); \
 	  $(INSTALL) \
 	    libcruft.$(SHLLIB) $(DESTDIR)$(octlibdir)/libcruft.$(SHLLIB_VER); \
 	  rm -f $(DESTDIR)$(octlibdir)/libcruft.$(SHLLIB); \
-	  $(LN_S) libcruft.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/libcruft.$(SHLLIB); \
+	  (cd $(DESTDIR)$(octlibdir); \
+	  $(LN_S) libcruft.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/libcruft.$(SHLLIB)); \
 	  if  test x$(SHLBIN) != x ; then \
 	    rm -f $(DESTDIR)$(bindir)/libcruft.$(SHLBIN); \
 	    $(INSTALL_PROGRAM) \
 	      libcruft.$(SHLBIN) $(DESTDIR)$(bindir)/libcruft.$(SHLBIN); \
 	  fi; \
 	fi
 
 install-strip::
diff --git a/libcruft/misc/cquit.c b/libcruft/misc/cquit.c
--- a/libcruft/misc/cquit.c
+++ b/libcruft/misc/cquit.c
@@ -39,16 +39,186 @@ octave_save_current_context (void *save_
 }
 
 void
 octave_restore_current_context (void *save_buf)
 {
   memcpy (current_context, save_buf, sizeof (octave_jmp_buf));
 }
 
+#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+
+/* XXX FIXME XXX -- eventually remove the debugging */
+#if defined (DEBUG)
+
+#define PRINT_CURRENT_THREAD() printf ("%lx: ", GetCurrentThreadId ())
+
+#define DEBUGs(s) \
+  do \
+    { \
+      PRINT_CURRENT_THREAD (); \
+      printf (s "\n"); \
+      fflush (stdout); \
+    } \
+  while (0)
+
+#define DEBUGd(s, d) \
+  do \
+    { \
+      PRINT_CURRENT_THREAD (); \
+      printf (s "\n", d); \
+      fflush (stdout); \
+    } \
+  while (0)
+
+#else
+#define DEBUGs(s)
+#define DEBUGd(s, d)
+#endif
+
+CRITICAL_SECTION w32_thread_setjmp_mutex;
+static CONTEXT w32_signal_context;
+static int w32_signal_to_raise = 0;
+static DWORD w32_main_thread_id;
+static HANDLE w32_main_thread;
+static HANDLE w32_restore_thread = NULL;
+
+int
+w32_in_main_thread(void)
+{
+  return (GetCurrentThreadId () == w32_main_thread_id);
+}
+
+static DWORD WINAPI
+w32_reset_context (LPVOID v)
+{
+  PCONTEXT context = (PCONTEXT)v;
+  int ret;
+
+  /* Mutex the setjmp/longjmp */
+  EnterCriticalSection (&w32_thread_setjmp_mutex);
+
+  DEBUGs ("enter w32_set_context");
+  SuspendThread (w32_main_thread);
+  DEBUGs ("main suspended");
+  if (! SetThreadContext (w32_main_thread, context)) 
+    {
+      fprintf (stderr, "%lx: context failed: ctrl-c won't work\n",
+	       GetCurrentThreadId ()); 
+      fflush (stderr);
+    }
+  DEBUGs ("context captured (or not)");
+  ret = ResumeThread (w32_main_thread);
+  DEBUGd ("main resumed with %d", ret);
+
+  LeaveCriticalSection (&w32_thread_setjmp_mutex);
+  return 0;
+}
+
+static void 
+w32_raise_in_main (void)
+{
+  DWORD threadid;
+
+  DEBUGd ("w32_raise_in_main with signal %d", w32_signal_to_raise);
+  raise (w32_signal_to_raise);
+  DEBUGd ("w32_raise_in_main signal %d returned a value",
+	  w32_signal_to_raise);
+
+  DEBUGs ("attempting to restore main to pre-signal configuration");
+  if (w32_restore_thread != NULL) /* Catch leaky threads */
+    CloseHandle (w32_restore_thread);
+  w32_restore_thread = CreateThread (NULL, 10000, w32_reset_context,
+				     &w32_signal_context, 0, &threadid);
+  if (w32_restore_thread == NULL) 
+    {
+      fprintf (stderr, "w32_raise_in_main couldn't create thread\n"); 
+      fflush (stderr);
+    } 
+  else 
+    {
+      DEBUGs ("waiting to restore raise context");
+      WaitForSingleObject (w32_restore_thread, INFINITE);
+      fprintf (stderr, "w32_raise_in_main couldn't restore context\n"); 
+      fflush (stderr);
+    }
+}
+
+void
+w32_raise_final (void)
+{
+  CloseHandle (w32_main_thread);
+  if (w32_restore_thread != NULL) /* Catch leaky threads */
+    CloseHandle (w32_restore_thread);
+  w32_main_thread = w32_restore_thread = NULL;
+}
+
+/* Raise the given signal in the main thread.  w32_raise_init ()
+   must have been called from the main thread already.  */
+void
+w32_raise (int sig)
+{
+  int ret;
+
+  if (w32_in_main_thread ()) 
+    {
+      /* Called from main thread -- a simple raise () should work.  */
+      DEBUGd ("raising signal %d within main", signal);
+      raise (sig);
+      DEBUGd ("returning from signal %d within main", signal);
+    } 
+  else 
+    {
+      /* Called from alternate thread -- call w32_raise_in_main in the
+         main thread with w32_signal_to_raise set to the signal */
+      CONTEXT raise_context;
+      DEBUGd ("raising signal %d from separate thread", signal);
+
+      /* Suspend main and remember the context.  */
+      SuspendThread (w32_main_thread);
+      /* X86 code */
+      w32_signal_context.ContextFlags 
+	= CONTEXT_FULL|CONTEXT_FLOATING_POINT|CONTEXT_DEBUG_REGISTERS;
+      GetThreadContext (w32_main_thread, &w32_signal_context);
+
+      /* Change the context to w32_raise_in_main.  The
+	 context.Eip=&fn trick for setting the program counter is
+	 courtesy of
+
+	   http://fit.c2.com/files/LispPlatform/lisp/clisp-2.28/src/win32aux.d
+
+         Auxiliary functions for CLISP on Win32, Bruno Haible
+	 1997-1999.  */
+
+      memcpy (&raise_context, &w32_signal_context, sizeof (CONTEXT));
+      raise_context.Eip = (DWORD)&w32_raise_in_main; /* X86 code */
+      w32_signal_to_raise = sig;
+      SetThreadContext (w32_main_thread, &raise_context);
+
+      /* Resume main at w32_raise_in_main */
+      ret = ResumeThread (w32_main_thread);
+      DEBUGd ("main resumed at w32_raise_in_main with suspend count %d",
+	      ret);
+    }
+}
+
+void
+w32_sigint_init (void)
+{
+  /* Capture main context */
+  w32_main_thread_id = GetCurrentThreadId ();
+  DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
+		   GetCurrentProcess (), &w32_main_thread,
+		   0, FALSE, DUPLICATE_SAME_ACCESS);
+
+  InitializeCriticalSectionAndSpinCount (&w32_thread_setjmp_mutex, 0);
+}
+
+#endif /* #if defined (__WIN32__) && ! defined (_POSIX_VERSION) */
+
 void
 octave_jump_to_enclosing_context (void)
 {
 #if defined (OCTAVE_HAVE_SIG_JUMP)
   siglongjmp (current_context, 1);
 #else
   longjmp (current_context, 1);
 #endif
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
--- a/libcruft/misc/quit.h
+++ b/libcruft/misc/quit.h
@@ -29,16 +29,27 @@ 02110-1301, USA.
 extern "C" {
 #endif
 
 #include <stdio.h>
 
 #include <signal.h>
 #include <setjmp.h>
 
+#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+
+#include <windows.h>
+
+extern void w32_sigint_init (void);   /* setup */
+extern void w32_raise_final (void);   /* tear down */
+extern void w32_raise (int sig);      /* raise signal in main thread */
+extern int w32_in_main_thread (void); /* return true if in main thread */
+
+#endif
+
 #if defined (OCTAVE_HAVE_SIG_JUMP)
 
 typedef sigjmp_buf octave_jmp_buf;
 
 #define octave_set_current_context sigsetjmp (current_context, 1)
 
 #else
 
diff --git a/liboctave/COLAMD.README b/liboctave/COLAMD.README
deleted file mode 100644
--- a/liboctave/COLAMD.README
+++ /dev/null
@@ -1,25 +0,0 @@
-This directory contains an unmodified copy of COLAMD version 2.4 in
-the subdirectory COLAMD.  COLAMD was written by Stefan I. Larimore and
-Timothy A. Davis (davis@cise.ufl.edu), University of Florida.  The
-algorithm was developed in collaboration with John Gilbert, Xerox
-PARC, and Esmond Ng, Oak Ridge National Laboratory.  COLAMD is
-distributed under the following terms:
-
-  Copyright (c) 1998-2003 by the University of Florida.
-  All Rights Reserved.
-
-  THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
-  EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
-
-  Permission is hereby granted to use, copy, modify, and/or distribute
-  this program, provided that the Copyright, this License, and the
-  Availability of the original version is retained on all copies and made
-  accessible to the end-user of any code or package that includes COLAMD
-  or any modified version of COLAMD. 
-
-John W. Eaton
-jwe@bevo.che.wisc.edu
-University of Wisconsin-Madison
-Department of Chemical & Biological Engineering
-
-Wed Dec 29 20:20:56 2004
diff --git a/liboctave/COLAMD.files b/liboctave/COLAMD.files
deleted file mode 100644
--- a/liboctave/COLAMD.files
+++ /dev/null
@@ -1,19 +0,0 @@
-
-COLAMD_SRC := colamd_global.c colamd.c
-
-COLAMD_VIRTUAL_SRC := colamd_l.c
-
-COLAMD_OBJ := $(COLAMD_SRC:.c=.o) $(COLAMD_VIRTUAL_SRC:.c=.o)
-
-COLAMD_DEP := $(COLAMD_SRC:.c=.d)
-
-$(COLAMD_OBJ) $(COLAMD_DEP) := INCFLAGS += -I$(top_srcdir)/liboctave/COLAMD
-
-COLAMD_EXTRAS := COLAMD.files COLAMD.README
-
-# Special rules for long version of colamd
-colamd_l.o : colamd.c
-	$(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) -DDLONG $< -o $@
-
-pic/colamd_l.o : colamd.c
-	$(CC) -c $(CPPFLAGS) $(CPICFLAGS) $(ALL_CFLAGS) -DDLONG $< -o $@
diff --git a/liboctave/COLAMD/colamdtestmex.c b/liboctave/COLAMD/colamdtestmex.c
deleted file mode 100644
--- a/liboctave/COLAMD/colamdtestmex.c
+++ /dev/null
@@ -1,569 +0,0 @@
-/* ========================================================================== */
-/* === colamdtest mexFunction =============================================== */
-/* ========================================================================== */
-
-/* COLAMD Version 2.4.
- 
-    This MATLAB mexFunction is for testing only.  It is not meant for
-    production use.  See colamdmex.c instead.
-
-    Usage:
-
-	[ P, stats ] = colamdtest (A, knobs) ;
-
-    See colamd.m for a description.  knobs is required.
-
-	knobs (1)	dense row control
-	knobs (2)	dense column control
-	knobs (3)	spumoni
-	knobs (4)	for testing only.  Controls the workspace used by
-			colamd.
-
-	knobs (5)	for testing only.  Controls how the input matrix is
-			jumbled prior to calling colamd, to test its error
-			handling capability.
-
-    Authors:
-
-	The authors of the code itself are Stefan I. Larimore and Timothy A.
-	Davis (davis at cise.ufl.edu), University of Florida.  The algorithm was
-	developed in collaboration with John Gilbert, Xerox PARC, and Esmond
-	Ng, Oak Ridge National Laboratory.
-
-    Acknowledgements:
-
-	This work was supported by the National Science Foundation, under
-	grants DMS-9504974 and DMS-9803599.
-
-    Notice:
-
-	Copyright (c) 1998-2005, Timothy A. Davis, All Rights Reserved.
-
-	See http://www.cise.ufl.edu/research/sparse/colamd (the colamd.c
-	file) for the License.
-
-    Availability:
-
-	The colamd/symamd library is available at
-
-	    http://www.cise.ufl.edu/research/sparse/colamd/
-
-	This is the
-	http://www.cise.ufl.edu/research/sparse/colamd/colamdtestmex.c
-       	file.  It requires the colamd.c and colamd.h files.
-
-*/
-
-/* ========================================================================== */
-/* === Include files ======================================================== */
-/* ========================================================================== */
-
-#include "colamd.h"
-#include "mex.h"
-#include "matrix.h"
-#include <stdlib.h>
-#include <string.h>
-
-static void dump_matrix
-(
-    int A [ ],
-    int p [ ],
-    int n_row,
-    int n_col,
-    int Alen,
-    int limit
-) ;
-
-/* ========================================================================== */
-/* === colamd mexFunction =================================================== */
-/* ========================================================================== */
-
-void mexFunction
-(
-    /* === Parameters ======================================================= */
-
-    int nlhs,			/* number of left-hand sides */
-    mxArray *plhs [],		/* left-hand side matrices */
-    int nrhs,			/* number of right--hand sides */
-    const mxArray *prhs []	/* right-hand side matrices */
-)
-{
-    /* === Local variables ================================================== */
-
-    int *A ;			/* colamd's copy of the matrix, and workspace */
-    int *p ;			/* colamd's copy of the column pointers */
-    int Alen ;			/* size of A */
-    int n_col ;			/* number of columns of A */
-    int n_row ;			/* number of rows of A */
-    int nnz ;			/* number of entries in A */
-    int full ;			/* TRUE if input matrix full, FALSE if sparse */
-    double knobs [COLAMD_KNOBS] ; /* colamd user-controllable parameters */
-    double *out_perm ;		/* output permutation vector */
-    double *out_stats ;		/* output stats vector */
-    double *in_knobs ;		/* input knobs vector */
-    int i ;			/* loop counter */
-    mxArray *Ainput ;		/* input matrix handle */
-    int spumoni ;		/* verbosity variable */
-    int stats2 [COLAMD_STATS] ;	/* stats for colamd */
-
-    int *cp, *cp_end, result, col, length ;
-    int *stats ;
-    stats = stats2 ;
-
-    colamd_printf = mexPrintf ;	/* COLAMD printf routine */
-
-    /* === Check inputs ===================================================== */
-
-    if (nrhs < 1 || nrhs > 2 || nlhs < 0 || nlhs > 2)
-    {
-	mexErrMsgTxt (
-	"colamd: incorrect number of input and/or output arguments") ;
-    }
-
-    if (nrhs != 2)
-    {
-	mexErrMsgTxt ("colamdtest: knobs are required") ;
-    }
-    /* for testing we require all 5 knobs */
-    if (mxGetNumberOfElements (prhs [1]) != 5)
-    {
-	mexErrMsgTxt ("colamd: must have all 5 knobs for testing") ;
-    }
-
-    /* === Get knobs ======================================================== */
-
-    colamd_set_defaults (knobs) ;
-    spumoni = 0 ;
-
-    /* check for user-passed knobs */
-    if (nrhs == 2)
-    {
-	in_knobs = mxGetPr (prhs [1]) ;
-	i = mxGetNumberOfElements (prhs [1]) ;
-	if (i > 0) knobs [COLAMD_DENSE_ROW] = in_knobs [0] ;
-	if (i > 1) knobs [COLAMD_DENSE_COL] = in_knobs [1] ;
-	if (i > 2) spumoni = (int) in_knobs [2] ;
-    }
-
-    /* print knob settings if spumoni is set */
-    if (spumoni)
-    {
-	mexPrintf ("\ncolamd version %d.%d, %s:\n",
-	    COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION, COLAMD_DATE) ;
-	if (knobs [COLAMD_DENSE_ROW] >= 0)
-	{
-	    mexPrintf ("knobs(1): %g, rows with > max(16,%g*sqrt(size(A,2)))"
-		" entries removed\n", in_knobs [0], knobs [COLAMD_DENSE_ROW]) ;
-	}
-	else
-	{
-	    mexPrintf ("knobs(1): %g, only completely dense rows removed\n",
-		in_knobs [0]) ;
-	}
-	if (knobs [COLAMD_DENSE_COL] >= 0)
-	{
-	    mexPrintf ("knobs(2): %g, cols with > max(16,%g*sqrt(min(size(A)))"
-		" entries removed\n", in_knobs [1], knobs [COLAMD_DENSE_COL]) ;
-	}
-	else
-	{
-	    mexPrintf ("knobs(2): %g, only completely dense columns removed\n",
-		in_knobs [1]) ;
-	}
-	mexPrintf ("knobs(3): %g, statistics and knobs printed\n",
-	    in_knobs [2]) ;
-    }
-
-    /* === If A is full, convert to a sparse matrix ========================= */
-
-    Ainput = (mxArray *) prhs [0] ;
-    if (mxGetNumberOfDimensions (Ainput) != 2)
-    {
-	mexErrMsgTxt ("colamd: input matrix must be 2-dimensional") ;
-    }
-    full = !mxIsSparse (Ainput) ;
-    if (full)
-    {
-	mexCallMATLAB (1, &Ainput, 1, (mxArray **) prhs, "sparse") ;
-    }
-
-    /* === Allocate workspace for colamd ==================================== */
-
-    /* get size of matrix */
-    n_row = mxGetM (Ainput) ;
-    n_col = mxGetN (Ainput) ;
-
-    /* get column pointer vector so we can find nnz */
-    p = (int *) mxCalloc (n_col+1, sizeof (int)) ;
-    (void) memcpy (p, mxGetJc (Ainput), (n_col+1)*sizeof (int)) ;
-    nnz = p [n_col] ;
-    Alen = colamd_recommended (nnz, n_row, n_col) ;
-
-
-/* === Modify size of Alen if testing ======================================= */
-
-/*
-	knobs [3]	amount of workspace given to colamd.
-			<  0 : TIGHT memory
-			>  0 : MIN + knob [3] - 1
-			== 0 : RECOMMENDED memory
-*/
-
-/* Here only for testing */
-#ifdef MIN
-#undef MIN
-#endif
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-#define COLAMD_MIN_MEMORY(nnz,n_row,n_col) \
-    (2 * (nnz) + COLAMD_C (n_col) + COLAMD_R (n_row))
-
-    /* get knob [3], if negative */
-    if (in_knobs [3] < 0)
-    {
-	Alen = COLAMD_MIN_MEMORY (nnz, n_row, n_col) + n_col ;
-    }
-    else if (in_knobs [3] > 0)
-    {
-	Alen = COLAMD_MIN_MEMORY (nnz, n_row, n_col) + in_knobs [3] - 1 ;
-    }
-
-    /* otherwise, we use the recommended amount set above */
-
-    /* === Copy input matrix into workspace ================================= */
-
-    A = (int *) mxCalloc (Alen, sizeof (int)) ;
-    (void) memcpy (A, mxGetIr (Ainput), nnz*sizeof (int)) ;
-
-    if (full)
-    {
-	mxDestroyArray (Ainput) ;
-    }
-
-
-/* === Jumble matrix ======================================================== */
-
-/*
-	knobs [4]	FOR TESTING ONLY: Specifies how to jumble matrix
-			0 : No jumbling
-			1 : Make n_row less than zero
-			2 : Make first pointer non-zero
-			3 : Make column pointers not non-decreasing
-			4 : Make a column pointer greater or equal to Alen
-			5 : Make row indices not strictly increasing
-			6 : Make a row index greater or equal to n_row
-			7 : Set A = NULL
-			8 : Set p = NULL
-			9 : Repeat row index
-			10: make row indices not sorted
-			11: jumble columns massively (note this changes
-				the pattern of the matrix A.)
-			12: Set stats = NULL
-			13: Make n_col less than zero
-*/
-
-    /* jumble appropriately */
-    switch ((int) in_knobs [4])
-    {
-
-	case 0 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: no errors expected\n") ;
-	    }
-	    result = 1 ;		/* no errors */
-	    break ;
-
-	case 1 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: nrow out of range\n") ;
-	    }
-	    result = 0 ;		/* nrow out of range */
-	    n_row = -1 ;
-	    break ;
-
-	case 2 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: p [0] nonzero\n") ;
-	    }
-	    result = 0 ;		/* p [0] must be zero */
-	    p [0] = 1 ;
-	    break ;
-
-	case 3 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: negative length last column\n") ;
-	    }
-	    result = (n_col == 0) ;	/* p must be monotonically inc. */
-	    p [n_col] = p [0] ;
-	    break ;
-
-	case 4 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: Alen too small\n") ;
-	    }
-	    result = 0 ;		/* out of memory */
-	    p [n_col] = Alen ;
-	    break ;
-
-	case 5 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: row index out of range (-1)\n") ;
-	    }
-	    if (nnz > 0)		/* row index out of range */
-	    {
-		result = 0 ;
-		A [nnz-1] = -1 ;
-	    }
-	    else
-	    {
-	        if (spumoni > 0)
-		{
-		    mexPrintf ("Note: no row indices to put out of range\n") ;
-		}
-		result = 1 ;
-	    }
-	    break ;
-
-	case 6 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: row index out of range (n_row)\n") ;
-	    }
-	    if (nnz > 0)		/* row index out of range */
-	    {
-		if (spumoni > 0)
-		{
-		    mexPrintf ("Changing A[nnz-1] from %d to %d\n",
-			    A [nnz-1], n_row) ; 
-		}
-		result = 0 ;
-		A [nnz-1] = n_row ;
-	    }
-	    else
-	    {
-	        if (spumoni > 0)
-		{
-		    mexPrintf ("Note: no row indices to put out of range\n") ;
-		}
-		result = 1 ;
-	    }
-	    break ;
-
-	case 7 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: A not present\n") ;
-	    }
-	    result = 0 ;		/* A not present */
-	    A = (int *) NULL ;
-	    break ;
-
-	case 8 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: p not present\n") ;
-	    }
-	    result = 0 ;		/* p not present */
-	    p = (int *) NULL ;
-	    break ;
-
-	case 9 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: duplicate row index\n") ;
-	    }
-	    result = 1 ;		/* duplicate row index */
-
-	    for (col = 0 ; col < n_col ; col++)
-	    {
-		length = p [col+1] - p [col] ;
-	    	if (length > 1)
-		{
-		    A [p [col]] = A [p [col] + 1] ;
-		    if (spumoni > 0)
-		    {
-			mexPrintf ("Made duplicate row %d in col %d\n",
-		    	 A [p [col] + 1], col) ;
-		    }
-		    break ;
-		}
-	    }
-
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, Alen, col+2) ;
-	    }
-	    break ;
-
-	case 10 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: unsorted column\n") ;
-	    }
-	    result = 1 ;		/* jumbled columns */
-
-	    for (col = 0 ; col < n_col ; col++)
-	    {
-		length = p [col+1] - p [col] ;
-	    	if (length > 1)
-		{
-		    i = A[p [col]] ;
-		    A [p [col]] = A[p [col] + 1] ;
-		    A [p [col] + 1] = i ;
-		    if (spumoni > 0)
-		    {
-			mexPrintf ("Unsorted column %d \n", col) ;
-		    }
-		    break ;
-		}
-	    }
-
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, Alen, col+2) ;
-	    }
-	    break ;
-
-	case 11 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: massive jumbling\n") ;
-	    }
-	    result = 1 ;		/* massive jumbling, but no errors */
-	    srand (1) ;
-	    for (i = 0 ; i < n_col ; i++)
-	    {
-		cp = &A [p [i]] ;
-		cp_end = &A [p [i+1]] ;
-		while (cp < cp_end)
-		{
-		    *cp++ = rand() % n_row ;
-		}
-	    }
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, Alen, n_col) ;
-	    }
-	    break ;
-
-	case 12 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: stats not present\n") ;
-	    }
-	    result = 0 ;		/* stats not present */
-	    stats = (int *) NULL ;
-	    break ;
-
-	case 13 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("colamdtest: ncol out of range\n") ;
-	    }
-	    result = 0 ;		/* ncol out of range */
-	    n_col = -1 ;
-	    break ;
-
-    }
-
-
-    /* === Order the columns (destroys A) =================================== */
-
-    if (!colamd (n_row, n_col, Alen, A, p, knobs, stats))
-    {
-
-	/* return p = -1 if colamd failed */
-	plhs [0] = mxCreateDoubleMatrix (1, 1, mxREAL) ;
-	out_perm = mxGetPr (plhs [0]) ;
-	out_perm [0] = -1 ;
-	mxFree (p) ;
-	mxFree (A) ;
-
-	if (spumoni > 0 || result)
-	{
-	    colamd_report (stats) ;
-	}
-
-	if (result)
-	{
-	    mexErrMsgTxt ("colamd should have returned TRUE\n") ;
-	}
-
-	return ;
-	/* mexErrMsgTxt ("colamd error!") ; */
-    }
-
-    if (!result)
-    {
-	colamd_report (stats) ;
-	mexErrMsgTxt ("colamd should have returned FALSE\n") ;
-    }
-    mxFree (A) ;
-
-    /* === Return the permutation vector ==================================== */
-
-    plhs [0] = mxCreateDoubleMatrix (1, n_col, mxREAL) ;
-    out_perm = mxGetPr (plhs [0]) ;
-    for (i = 0 ; i < n_col ; i++)
-    {
-	/* colamd is 0-based, but MATLAB expects this to be 1-based */
-	out_perm [i] = p [i] + 1 ;
-    }
-    mxFree (p) ;
-
-    /* === Return the stats vector ========================================== */
-
-    /* print stats if spumoni > 0 */
-    if (spumoni > 0)
-    {
-	colamd_report (stats) ;
-    }
-
-    if (nlhs == 2)
-    {
-	plhs [1] = mxCreateDoubleMatrix (1, COLAMD_STATS, mxREAL) ;
-	out_stats = mxGetPr (plhs [1]) ;
-	for (i = 0 ; i < COLAMD_STATS ; i++)
-	{
-	    out_stats [i] = stats [i] ;
-	}
-
-	/* fix stats (5) and (6), for 1-based information on jumbled matrix. */
-	/* note that this correction doesn't occur if symamd returns FALSE */
-	out_stats [COLAMD_INFO1] ++ ; 
-	out_stats [COLAMD_INFO2] ++ ; 
-    }
-}
-
-
-static void dump_matrix
-(
-    int A [ ],
-    int p [ ],
-    int n_row,
-    int n_col,
-    int Alen,
-    int limit
-)
-{
-    int col, k, row ;
-
-    mexPrintf ("dump matrix: nrow %d ncol %d Alen %d\n", n_row, n_col, Alen) ;
-
-    for (col = 0 ; col < MIN (n_col, limit) ; col++)
-    {
-	mexPrintf ("column %d, p[col] %d, p [col+1] %d, length %d\n",
-		col, p [col], p [col+1], p [col+1] - p [col]) ;
-    	for (k = p [col] ; k < p [col+1] ; k++)
-	{
-	    row = A [k] ;
-	    mexPrintf (" %d", row) ;
-	}
-	mexPrintf ("\n") ;
-    }
-}
diff --git a/liboctave/COLAMD/lesser.txt b/liboctave/COLAMD/lesser.txt
deleted file mode 100644
--- a/liboctave/COLAMD/lesser.txt
+++ /dev/null
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-
diff --git a/liboctave/COLAMD/luflops.m b/liboctave/COLAMD/luflops.m
deleted file mode 100644
--- a/liboctave/COLAMD/luflops.m
+++ /dev/null
@@ -1,29 +0,0 @@
-function fl = luflops (L, U)
-%
-%  fl = luflops (L,U)
-%
-%  Given a sparse LU factorization (L and U), return the flop count required
-%  by a conventional LU factorization algorithm to compute it.   L and U can
-%  be either sparse or full matrices.  L must be lower triangular and U must
-%  be upper triangular.  Do not attempt to use this on the permuted L from
-%  [L,U] = lu (A).  Instead, use [L,U,P] = lu (A) or [L,U,P,Q] = lu (A).
-%
-%  Note that there is a subtle undercount in this estimate.  Suppose A is
-%  completely dense, but during LU factorization exact cancellation occurs,
-%  causing some of the entries in L and U to become identically zero.  The
-%  flop count returned by this routine is an undercount.  There is a simple
-%  way to fix this (L = spones (L) + spones (tril (A))), but the fix is partial.
-%  It can also occur that some entry in L is a "symbolic" fill-in (zero in
-%  A, but a fill-in entry and thus must be computed), but numerically
-%  zero.  The only way to get a reliable LU factorization would be to do a
-%  purely symbolic factorization of A.  This cannot be done with
-%  symbfact (A, 'col').
-%
-%  See NA Digest, Vol 00, #50, Tuesday, Dec. 5, 2000
-%
-%  Tim Davis, Sept. 23, 2002.  Written for MATLAB 6.5.
-
-Lnz = full (sum (spones (L))) - 1 ;	% off diagonal nz in cols of L
-Unz = full (sum (spones (U')))' - 1 ;	% off diagonal nz in rows of U
-fl = 2*Lnz*Unz + sum (Lnz) ;
-
diff --git a/liboctave/COLAMD/symamd.m b/liboctave/COLAMD/symamd.m
deleted file mode 100644
--- a/liboctave/COLAMD/symamd.m
+++ /dev/null
@@ -1,98 +0,0 @@
-function [p, stats] = symamd (S, knobs)
-%SYMAMD Symmetric approximate minimum degree permutation.
-%    P = SYMAMD(S) for a symmetric positive definite matrix S, returns the
-%    permutation vector p such that S(p,p) tends to have a sparser Cholesky
-%    factor than S.  Sometimes SYMAMD works well for symmetric indefinite
-%    matrices too.  The matrix S is assumed to be symmetric; only the
-%    strictly lower triangular part is referenced.   S must be square.
-%    Note that p = amd(S) is much faster and generates comparable orderings.
-%    The ordering is followed by an elimination tree post-ordering.
-%
-%    See also AMD, CCOLAMD, CSYMAMD, COLAMD, COLPERM, SYMRCM.
-%
-%    Usage:  P = symamd (S)
-%            [P, stats] = symamd (S, knobs)
-%
-%    knobs is an optional one- to two-element input vector.  If S is n-by-n,
-%    then rows and columns with more than max(16,knobs(1)*sqrt(n)) entries are
-%    removed prior to ordering, and ordered last in the output permutation P.
-%    No rows/columns are removed if knobs(1)<0.  If knobs(2) is nonzero, stats
-%    and knobs are printed.  The default is knobs = [10 0].  Note that knobs
-%    differs from earlier versions of symamd.
-%
-%    Type the command "type symamd" for a description of the optional stats
-%    output and for the copyright information.
-%
-%    Authors: S. Larimore and T. Davis, University of Florida.  Developed in
-%       collaboration with J. Gilbert and E. Ng.  Version 2.4.
-%
-%    Acknowledgements: This work was supported by the National Science
-%       Foundation, under grants DMS-9504974 and DMS-9803599.
-
-%    Notice:
-%
-%	Copyright (c) 1998-2005, Timothy A. Davis, All Rights Reserved.
-%
-%       See http://www.cise.ufl.edu/research/sparse/colamd (the colamd.c
-%       file) for the License.
-%
-%    Availability:
-%
-%       The colamd, symamd, amd, ccolamd, and csymamd are available at
-%       http://www.cise.ufl.edu/research/sparse
-
-%-------------------------------------------------------------------------------
-% perform the symamd ordering:
-%-------------------------------------------------------------------------------
-
-if (nargout <= 1 && nargin == 1)
-    p = symamdmex (S) ;
-elseif (nargout <= 1 && nargin == 2)
-    p = symamdmex (S, knobs) ;
-elseif (nargout == 2 && nargin == 1)
-    [p, stats] = symamdmex (S) ;
-elseif (nargout == 2 && nargin == 2)
-    [p, stats] = symamdmex (S, knobs) ;
-else
-    error('MATLAB:symamd:WrongInputOrOutputNumber',...
-           'symamd:  incorrect number of input and/or output arguments.') ;
-end
-
-%-------------------------------------------------------------------------------
-% symmetric elimination tree post-ordering:
-%-------------------------------------------------------------------------------
-
-[ignore, q] = sparsfun ('symetree', S (p,p)) ;
-p = p (q) ;
-
-
-%    stats is an optional 20-element output vector that provides data about the
-%    ordering and the validity of the input matrix S.  Ordering statistics are
-%    in stats (1:3).  stats (1) = stats (2) is the number of dense or empty
-%    rows and columns ignored by SYMAMD and stats (3) is the number of
-%    garbage collections performed on the internal data structure used by
-%    SYMAMD (roughly of size 8.4*nnz(tril(S,-1)) + 9*n integers).
-%
-%    MATLAB built-in functions are intended to generate valid sparse matrices,
-%    with no duplicate entries, with ascending row indices of the nonzeros
-%    in each column, with a non-negative number of entries in each column (!)
-%    and so on.  If a matrix is invalid, then SYMAMD may or may not be able
-%    to continue.  If there are duplicate entries (a row index appears two or
-%    more times in the same column) or if the row indices in a column are out
-%    of order, then SYMAMD can correct these errors by ignoring the duplicate
-%    entries and sorting each column of its internal copy of the matrix S (the
-%    input matrix S is not repaired, however).  If a matrix is invalid in other
-%    ways then SYMAMD cannot continue, an error message is printed, and no
-%    output arguments (P or stats) are returned.  SYMAMD is thus a simple way
-%    to check a sparse matrix to see if it's valid.
-%
-%    stats (4:7) provide information if SYMAMD was able to continue.  The
-%    matrix is OK if stats (4) is zero, or 1 if invalid.  stats (5) is the
-%    rightmost column index that is unsorted or contains duplicate entries,
-%    or zero if no such column exists.  stats (6) is the last seen duplicate
-%    or out-of-order row index in the column index given by stats (5), or zero
-%    if no such row index exists.  stats (7) is the number of duplicate or
-%    out-of-order row indices.
-%
-%    stats (8:20) is always zero in the current version of SYMAMD (reserved
-%    for future use).
diff --git a/liboctave/COLAMD/symamdmex.c b/liboctave/COLAMD/symamdmex.c
deleted file mode 100644
--- a/liboctave/COLAMD/symamdmex.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/* ========================================================================== */
-/* === symamd mexFunction =================================================== */
-/* ========================================================================== */
-
-/* COLAMD Version 2.4.
-
-    Usage:
-
-	P = symamd (A) ;
-	[ P, stats ] = symamd (A, knobs) ;
-
-    See symamd.m for a description.
-
-    Authors:
-
-	The authors of the code itself are Stefan I. Larimore and Timothy A.
-	Davis (davis at cise.ufl.edu), University of Florida.  The algorithm was
-	developed in collaboration with John Gilbert, Xerox PARC, and Esmond
-	Ng, Oak Ridge National Laboratory.
-
-    Acknowledgements:
-
-	This work was supported by the National Science Foundation, under
-	grants DMS-9504974 and DMS-9803599.
-
-    Notice:
-
-	Copyright (c) 1998-2005, Timothy A. Davis.  All Rights Reserved.
-
-	See http://www.cise.ufl.edu/research/sparse/colamd (the colamd.c
-	file) for the License.
-
-    Availability:
-
-	The colamd/symamd library is available at
-
-	    http://www.cise.ufl.edu/research/sparse/colamd/
-
-	This is the http://www.cise.ufl.edu/research/sparse/colamd/symamdmex.c
-	file.  It requires the colamd.c and colamd.h files.
-
-*/
-
-/* ========================================================================== */
-/* === Include files ======================================================== */
-/* ========================================================================== */
-
-#include "colamd.h"
-#include "mex.h"
-#include "matrix.h"
-#include <stdlib.h>
-
-/* ========================================================================== */
-/* === symamd mexFunction =================================================== */
-/* ========================================================================== */
-
-void mexFunction
-(
-    /* === Parameters ======================================================= */
-
-    int nlhs,			/* number of left-hand sides */
-    mxArray *plhs [],		/* left-hand side matrices */
-    int nrhs,			/* number of right--hand sides */
-    const mxArray *prhs []	/* right-hand side matrices */
-)
-{
-    /* === Local variables ================================================== */
-
-    int *perm ;			/* column ordering of M and ordering of A */
-    int *A ;			/* row indices of input matrix A */
-    int *p ;			/* column pointers of input matrix A */
-    int n_col ;			/* number of columns of A */
-    int n_row ;			/* number of rows of A */
-    int full ;			/* TRUE if input matrix full, FALSE if sparse */
-    double knobs [COLAMD_KNOBS] ; /* colamd user-controllable parameters */
-    double *out_perm ;		/* output permutation vector */
-    double *out_stats ;		/* output stats vector */
-    double *in_knobs ;		/* input knobs vector */
-    int i ;			/* loop counter */
-    mxArray *Ainput ;		/* input matrix handle */
-    int spumoni ;		/* verbosity variable */
-    int stats [COLAMD_STATS] ;	/* stats for symamd */
-
-    colamd_printf = mexPrintf ;	/* COLAMD printf routine */
-
-    /* === Check inputs ===================================================== */
-
-    if (nrhs < 1 || nrhs > 2 || nlhs < 0 || nlhs > 2)
-    {
-	mexErrMsgTxt (
-	"symamd: incorrect number of input and/or output arguments.") ;
-    }
-
-    /* === Get knobs ======================================================== */
-
-    colamd_set_defaults (knobs) ;
-    spumoni = 0 ;
-
-    /* check for user-passed knobs */
-    if (nrhs == 2)
-    {
-	in_knobs = mxGetPr (prhs [1]) ;
-	i = mxGetNumberOfElements (prhs [1]) ;
-	if (i > 0) knobs [COLAMD_DENSE_ROW] = in_knobs [0] ;
-	if (i > 1) spumoni = (int) (in_knobs [1] != 0) ;
-    }
-
-    /* print knob settings if spumoni is set */
-    if (spumoni)
-    {
-	mexPrintf ("\nsymamd version %d.%d, %s:\n",
-	    COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION, COLAMD_DATE) ;
-	if (knobs [COLAMD_DENSE_ROW] >= 0)
-	{
-	    mexPrintf ("knobs(1): %g, rows/cols with > "
-		"max(16,%g*sqrt(size(A,2))) entries removed\n",
-		in_knobs [0], knobs [COLAMD_DENSE_ROW]) ;
-	}
-	else
-	{
-	    mexPrintf ("knobs(1): %g, no dense rows removed\n", in_knobs [0]) ;
-	}
-	mexPrintf ("knobs(2): %g, statistics and knobs printed\n",
-	    in_knobs [1]) ;
-    }
-
-    /* === If A is full, convert to a sparse matrix ========================= */
-
-    Ainput = (mxArray *) prhs [0] ;
-    if (mxGetNumberOfDimensions (Ainput) != 2)
-    {
-	mexErrMsgTxt ("symamd: input matrix must be 2-dimensional.") ;
-    }
-    full = !mxIsSparse (Ainput) ;
-    if (full)
-    {
-	mexCallMATLAB (1, &Ainput, 1, (mxArray **) prhs, "sparse") ;
-    }
-
-    /* === Allocate workspace for symamd ==================================== */
-
-    /* get size of matrix */
-    n_row = mxGetM (Ainput) ;
-    n_col = mxGetN (Ainput) ;
-    if (n_col != n_row)
-    {
-	mexErrMsgTxt ("symamd: matrix must be square.") ;
-    }
-
-    A = mxGetIr (Ainput) ;
-    p = mxGetJc (Ainput) ;
-    perm = (int *) mxCalloc (n_col+1, sizeof (int)) ;
-
-    /* === Order the rows and columns of A (does not destroy A) ============= */
-
-    if (!symamd (n_col, A, p, perm, knobs, stats, &mxCalloc, &mxFree))
-    {
-	symamd_report (stats) ;
-	mexErrMsgTxt ("symamd error!") ;
-    }
-
-    if (full)
-    {
-	mxDestroyArray (Ainput) ;
-    }
-
-    /* === Return the permutation vector ==================================== */
-
-    plhs [0] = mxCreateDoubleMatrix (1, n_col, mxREAL) ;
-    out_perm = mxGetPr (plhs [0]) ;
-    for (i = 0 ; i < n_col ; i++)
-    {
-	/* symamd is 0-based, but MATLAB expects this to be 1-based */
-	out_perm [i] = perm [i] + 1 ;
-    }
-    mxFree (perm) ;
-
-    /* === Return the stats vector ========================================== */
-
-    /* print stats if spumoni is set */
-    if (spumoni)
-    {
-	symamd_report (stats) ;
-    }
-
-    if (nlhs == 2)
-    {
-	plhs [1] = mxCreateDoubleMatrix (1, COLAMD_STATS, mxREAL) ;
-	out_stats = mxGetPr (plhs [1]) ;
-	for (i = 0 ; i < COLAMD_STATS ; i++)
-	{
-	    out_stats [i] = stats [i] ;
-	}
-
-	/* fix stats (5) and (6), for 1-based information on jumbled matrix. */
-	/* note that this correction doesn't occur if symamd returns FALSE */
-	out_stats [COLAMD_INFO1] ++ ; 
-	out_stats [COLAMD_INFO2] ++ ; 
-    }
-}
diff --git a/liboctave/COLAMD/symamdtestmex.c b/liboctave/COLAMD/symamdtestmex.c
deleted file mode 100644
--- a/liboctave/COLAMD/symamdtestmex.c
+++ /dev/null
@@ -1,542 +0,0 @@
-/* ========================================================================== */
-/* === symamdtest mexFunction =============================================== */
-/* ========================================================================== */
-
-/* COLAMD Version 2.4.
-
-    This MATLAB mexFunction is for testing only.  It is not meant for
-    production use.  See symamdmex.c instead.
-
-    Usage:
-
-	[ P, stats ] = symamdtest (A, knobs) ;
-
-    See symamd.m for a description.  knobs is required.
-
-	knobs (1)	dense row control
-	knobs (2)	spumoni
-	knobs (3)	for testing only.  Controls how the input matrix is
-			jumbled prior to calling symamd, to test its error
-			handling capability.
-
-    Authors:
-
-	The authors of the code itself are Stefan I. Larimore and Timothy A.
-	Davis (davis at cise.ufl.edu), University of Florida.  The algorithm was
-	developed in collaboration with John Gilbert, Xerox PARC, and Esmond
-	Ng, Oak Ridge National Laboratory.
-
-    Acknowledgements:
-
-	This work was supported by the National Science Foundation, under
-	grants DMS-9504974 and DMS-9803599.
-
-    Notice:
-
-	Copyright (c) 1998-2005, Timothy A. Davis.  All Rights Reserved.
-
-	See http://www.cise.ufl.edu/research/sparse/colamd (the colamd.c
-	file) for the License.
-
-    Availability:
-
-	The colamd/symamd library is available at
-
-	    http://www.cise.ufl.edu/research/sparse/colamd/
-
-	This is the
-	http://www.cise.ufl.edu/research/sparse/colamd/symamdtestmex.c
-       	file.  It requires the colamd.c and colamd.h files.
-
-*/
-
-/* ========================================================================== */
-/* === Include files ======================================================== */
-/* ========================================================================== */
-
-#include "colamd.h"
-#include "mex.h"
-#include "matrix.h"
-#include <stdlib.h>
-#include <string.h>
-
-static void dump_matrix
-(
-    int A [ ],
-    int p [ ],
-    int n_row,
-    int n_col,
-    int Alen,
-    int limit
-) ;
-
-/* ========================================================================== */
-/* === symamd mexFunction =================================================== */
-/* ========================================================================== */
-
-void mexFunction
-(
-    /* === Parameters ======================================================= */
-
-    int nlhs,			/* number of left-hand sides */
-    mxArray *plhs [],		/* left-hand side matrices */
-    int nrhs,			/* number of right--hand sides */
-    const mxArray *prhs []	/* right-hand side matrices */
-)
-{
-    /* === Local variables ================================================== */
-
-    int *perm ;			/* column ordering of M and ordering of A */
-    int *A ;			/* row indices of input matrix A */
-    int *p ;			/* column pointers of input matrix A */
-    int n_col ;			/* number of columns of A */
-    int n_row ;			/* number of rows of A */
-    int full ;			/* TRUE if input matrix full, FALSE if sparse */
-    double knobs [COLAMD_KNOBS] ; /* colamd user-controllable parameters */
-    double *out_perm ;		/* output permutation vector */
-    double *out_stats ;		/* output stats vector */
-    double *in_knobs ;		/* input knobs vector */
-    int i ;			/* loop counter */
-    mxArray *Ainput ;		/* input matrix handle */
-    int spumoni ;		/* verbosity variable */
-    int stats2 [COLAMD_STATS] ;	/* stats for symamd */
-
-    int *cp, *cp_end, result, nnz, col, length ;
-    int *stats ;
-    stats = stats2 ;
-
-    colamd_printf = mexPrintf ;	/* COLAMD printf routine */
-
-    /* === Check inputs ===================================================== */
-
-    if (nrhs < 1 || nrhs > 2 || nlhs < 0 || nlhs > 2)
-    {
-	mexErrMsgTxt (
-	"symamd: incorrect number of input and/or output arguments.") ;
-    }
-
-    if (nrhs != 2)
-    {
-	mexErrMsgTxt ("symamdtest: knobs are required") ;
-    }
-    /* for testing we require all 3 knobs */
-    if (mxGetNumberOfElements (prhs [1]) != 3)
-    {
-	mexErrMsgTxt ("symamdtest: must have all 3 knobs for testing") ;
-    }
-
-    /* === Get knobs ======================================================== */
-
-    colamd_set_defaults (knobs) ;
-    spumoni = 0 ;
-
-    /* check for user-passed knobs */
-    if (nrhs == 2)
-    {
-	in_knobs = mxGetPr (prhs [1]) ;
-	i = mxGetNumberOfElements (prhs [1]) ;
-	if (i > 0) knobs [COLAMD_DENSE_ROW] = in_knobs [0] ;
-	if (i > 1) spumoni = (int) in_knobs [1] ;
-    }
-
-    /* print knob settings if spumoni is set */
-    if (spumoni)
-    {
-	mexPrintf ("\nsymamd version %d.%d, %s:\n",
-	    COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION, COLAMD_DATE) ;
-	if (knobs [COLAMD_DENSE_ROW] >= 0)
-	{
-	    mexPrintf ("knobs(1): %g, rows/cols with > "
-		"max(16,%g*sqrt(size(A,2))) entries removed\n",
-		in_knobs [0], knobs [COLAMD_DENSE_ROW]) ;
-	}
-	else
-	{
-	    mexPrintf ("knobs(1): %g, no dense rows removed\n", in_knobs [0]) ;
-	}
-	mexPrintf ("knobs(2): %g, statistics and knobs printed\n",
-	    in_knobs [1]) ;
-	mexPrintf ("Testing %d\n", in_knobs [2]) ;
-    }
-
-    /* === If A is full, convert to a sparse matrix ========================= */
-
-    Ainput = (mxArray *) prhs [0] ;
-    if (mxGetNumberOfDimensions (Ainput) != 2)
-    {
-	mexErrMsgTxt ("symamd: input matrix must be 2-dimensional.") ;
-    }
-    full = !mxIsSparse (Ainput) ;
-    if (full)
-    {
-	mexCallMATLAB (1, &Ainput, 1, (mxArray **) prhs, "sparse") ;
-    }
-
-    /* === Allocate workspace for symamd ==================================== */
-
-    /* get size of matrix */
-    n_row = mxGetM (Ainput) ;
-    n_col = mxGetN (Ainput) ;
-    if (n_col != n_row)
-    {
-	mexErrMsgTxt ("symamd: matrix must be square.") ;
-    }
-
-    /* p = mxGetJc (Ainput) ; */
-    p = (int *) mxCalloc (n_col+1, sizeof (int)) ;
-    (void) memcpy (p, mxGetJc (Ainput), (n_col+1)*sizeof (int)) ;
-
-    nnz = p [n_col] ;
-    if (spumoni > 0)
-    {
-	mexPrintf ("symamdtest: nnz %d\n", nnz) ;
-    }
-
-    /* A = mxGetIr (Ainput) ; */
-    A = (int *) mxCalloc (nnz+1, sizeof (int)) ;
-    (void) memcpy (A, mxGetIr (Ainput), nnz*sizeof (int)) ;
-
-    perm = (int *) mxCalloc (n_col+1, sizeof (int)) ;
-
-/* === Jumble matrix ======================================================== */
-
-
-/*
-	knobs [2]	FOR TESTING ONLY: Specifies how to jumble matrix
-			0 : No jumbling
-			1 : (no errors)
-			2 : Make first pointer non-zero
-			3 : Make column pointers not non-decreasing
-			4 : (no errors)
-			5 : Make row indices not strictly increasing
-			6 : Make a row index greater or equal to n_row
-			7 : Set A = NULL
-			8 : Set p = NULL
-			9 : Repeat row index
-			10: make row indices not sorted
-			11: jumble columns massively (note this changes
-				the pattern of the matrix A.)
-			12: Set stats = NULL
-			13: Make n_col less than zero
-*/
-
-    /* jumble appropriately */
-    switch ((int) in_knobs [2])
-    {
-
-	case 0 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: no errors expected\n") ;
-	    }
-	    result = 1 ;		/* no errors */
-	    break ;
-
-	case 1 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: no errors expected (1)\n") ;
-	    }
-	    result = 1 ;
-	    break ;
-
-	case 2 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: p [0] nonzero\n") ;
-	    }
-	    result = 0 ;		/* p [0] must be zero */
-	    p [0] = 1 ;
-	    break ;
-
-	case 3 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: negative length last column\n") ;
-	    }
-	    result = (n_col == 0) ;	/* p must be monotonically inc. */
-	    p [n_col] = p [0] ;
-	    break ;
-
-	case 4 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: no errors expected (4)\n") ;
-	    }
-	    result = 1 ;
-	    break ;
-
-	case 5 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: row index out of range (-1)\n") ;
-	    }
-	    if (nnz > 0)		/* row index out of range */
-	    {
-		result = 0 ;
-		A [nnz-1] = -1 ;
-	    }
-	    else
-	    {
-	        if (spumoni > 0)
-		{
-		    mexPrintf ("Note: no row indices to put out of range\n") ;
-		}
-		result = 1 ;
-	    }
-	    break ;
-
-	case 6 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: row index out of range (ncol)\n") ;
-	    }
-	    if (nnz > 0)		/* row index out of range */
-	    {
-		result = 0 ;
-		A [nnz-1] = n_col ;
-	    }
-	    else
-	    {
-	        if (spumoni > 0)
-		{
-		    mexPrintf ("Note: no row indices to put out of range\n") ;
-		}
-		result = 1 ;
-	    }
-	    break ;
-
-	case 7 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: A not present\n") ;
-	    }
-	    result = 0 ;		/* A not present */
-	    A = (int *) NULL ;
-	    break ;
-
-	case 8 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: p not present\n") ;
-	    }
-	    result = 0 ;		/* p not present */
-	    p = (int *) NULL ;
-	    break ;
-
-	case 9 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: duplicate row index\n") ;
-	    }
-	    result = 1 ;		/* duplicate row index */
-
-	    for (col = 0 ; col < n_col ; col++)
-	    {
-		length = p [col+1] - p [col] ;
-	    	if (length > 1)
-		{
-		    A [p [col+1]-2] = A [p [col+1] - 1] ;
-		    if (spumoni > 0)
-		    {
-			mexPrintf ("Made duplicate row %d in col %d\n",
-		    	 A [p [col+1] - 1], col) ;
-		    }
-		    break ;
-		}
-	    }
-
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, nnz, col+2) ;
-	    }
-	    break ;
-
-	case 10 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: unsorted column\n") ;
-	    }
-	    result = 1 ;		/* jumbled columns */
-
-	    for (col = 0 ; col < n_col ; col++)
-	    {
-		length = p [col+1] - p [col] ;
-	    	if (length > 1)
-		{
-		    i = A[p [col]] ;
-		    A [p [col]] = A[p [col] + 1] ;
-		    A [p [col] + 1] = i ;
-		    if (spumoni > 0)
-		    {
-			mexPrintf ("Unsorted column %d \n", col) ;
-		    }
-		    break ;
-		}
-	    }
-
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, nnz, col+2) ;
-	    }
-	    break ;
-
-	case 11 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: massive jumbling\n") ;
-	    }
-	    result = 1 ;		/* massive jumbling, but no errors */
-	    srand (1) ;
-	    for (i = 0 ; i < n_col ; i++)
-	    {
-		cp = &A [p [i]] ;
-		cp_end = &A [p [i+1]] ;
-		while (cp < cp_end)
-		{
-		    *cp++ = rand() % n_row ;
-		}
-	    }
-	    if (spumoni > 1)
-	    {
-		dump_matrix (A, p, n_row, n_col, nnz, n_col) ;
-	    }
-	    break ;
-
-	case 12 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: stats not present\n") ;
-	    }
-	    result = 0 ;		/* stats not present */
-	    stats = (int *) NULL ;
-	    break ;
-
-	case 13 :
-	    if (spumoni > 0)
-	    {
-		mexPrintf ("symamdtest: ncol out of range\n") ;
-	    }
-	    result = 0 ;		/* ncol out of range */
-	    n_col = -1 ;
-	    break ;
-
-    }
-
-    /* === Order the rows and columns of A (does not destroy A) ============= */
-
-    if (!symamd (n_col, A, p, perm, knobs, stats, &mxCalloc, &mxFree))
-    {
-
-	/* return p = -1 if colamd failed */
-	plhs [0] = mxCreateDoubleMatrix (1, 1, mxREAL) ;
-	out_perm = mxGetPr (plhs [0]) ;
-	out_perm [0] = -1 ;
-	mxFree (p) ;
-	mxFree (A) ;
-
-	if (spumoni > 0 || result)
-	{
-	    symamd_report (stats) ;
-	}
-
-	if (result)
-	{
-	    mexErrMsgTxt ("symamd should have returned TRUE\n") ;
-	}
-
-	return ;
-	/* mexErrMsgTxt ("symamd error!") ; */
-    }
-
-    if (!result)
-    {
-	symamd_report (stats) ;
-	mexErrMsgTxt ("symamd should have returned FALSE\n") ;
-    }
-
-    if (full)
-    {
-	mxDestroyArray (Ainput) ;
-    }
-
-    /* === Return the permutation vector ==================================== */
-
-    plhs [0] = mxCreateDoubleMatrix (1, n_col, mxREAL) ;
-    out_perm = mxGetPr (plhs [0]) ;
-    for (i = 0 ; i < n_col ; i++)
-    {
-	/* symamd is 0-based, but MATLAB expects this to be 1-based */
-	out_perm [i] = perm [i] + 1 ;
-    }
-    mxFree (perm) ;
-
-    /* === Return the stats vector ========================================== */
-
-    /* print stats if spumoni > 0 */
-    if (spumoni > 0)
-    {
-	symamd_report (stats) ;
-    }
-
-    if (nlhs == 2)
-    {
-	plhs [1] = mxCreateDoubleMatrix (1, COLAMD_STATS, mxREAL) ;
-	out_stats = mxGetPr (plhs [1]) ;
-	for (i = 0 ; i < COLAMD_STATS ; i++)
-	{
-	    out_stats [i] = stats [i] ;
-	}
-
-	/* fix stats (5) and (6), for 1-based information on jumbled matrix. */
-	/* note that this correction doesn't occur if symamd returns FALSE */
-	out_stats [COLAMD_INFO1] ++ ; 
-	out_stats [COLAMD_INFO2] ++ ; 
-    }
-}
-
-
-#ifdef MIN
-#undef MIN
-#endif
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-
-
-static void dump_matrix
-(
-    int A [ ],
-    int p [ ],
-    int n_row,
-    int n_col,
-    int Alen,
-    int limit
-)
-{
-    int col, k, row ;
-
-    mexPrintf ("dump matrix: nrow %d ncol %d Alen %d\n", n_row, n_col, Alen) ;
-
-    if (!A)
-    {
-    	mexPrintf ("A not present\n") ;
-	return ;
-    }
-
-    if (!p)
-    {
-    	mexPrintf ("p not present\n") ;
-	return ;
-    }
-
-    for (col = 0 ; col < MIN (n_col, limit) ; col++)
-    {
-	mexPrintf ("column %d, p[col] %d, p [col+1] %d, length %d\n",
-		col, p [col], p [col+1], p [col+1] - p [col]) ;
-    	for (k = p [col] ; k < p [col+1] ; k++)
-	{
-	    row = A [k] ;
-	    mexPrintf (" %d", row) ;
-	}
-	mexPrintf ("\n") ;
-    }
-}
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -35,23 +35,17 @@ Boston, MA 02110-1301, USA.
 #include "f77-fcn.h"
 #include "dRowVector.h"
 
 #include "CSparse.h"
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "oct-spparms.h"
 #include "SparseCmplxLU.h"
-
-#ifdef HAVE_UMFPACK
-// External UMFPACK functions in C
-extern "C" {
-#include <umfpack/umfpack.h>
-}
-#endif
+#include "oct-sparse.h"
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgbtrf, ZGBTRF) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
 			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,39 @@
+2005-09-15  John W. Eaton  <jwe@octave.org>
+
+	* Makefile.in (MAKEDEPS_2): Omit unnecessary variable.
+
+	* oct-sparse.h.in: New file.
+	* Makefile.in (DISTFILES): Include it in the list.
+	(INCLUDES): Add oct-sparse.h to the list.
+
+2005-09-15  David Bateman  <dbateman@free.fr>
+
+	* dSparse.cc : Include oct-sparse.h for probed umfpack, colamd etc 
+	headers. Remove include of umfpack.h.
+	* CSparse.cc : ditto.
+	* SparsedbleLU.cc : ditto.
+	* SparseCmplxLU.cc : ditto.
+
+	* COLAMD : Remove colamd files from octave.
+	* COLAMD.files : delete.
+	* COLAMD.README : delete.
+	* Makefile.in: Remove COLAMD. Add LIBGLOB.
+	(LN_S): Change to DESTDIR before LN_S to avoid lack of symlinks 
+	under mingw.
+
+	* kpse.cc (ENV_SEP, ENV_SEP_STRING): Use SEPCHAR and SEPCHAR_STR
+	in definition.
+	* lo-cutils.c (octave_w32_library_search): Call GetProcAddress with
+	change of cast not allowed under g++ 3.x.
+	* lo-utils.h (octave_w32_library_search): Declaration.
+	* oct-env.cc (do_get_home_directory): Also check HOMEPATH under mingw.
+	* oct-shlib.cc (octave_w32_shlib::search): Use octave_w32_library_search.
+
 2005-09-07  John W. Eaton  <jwe@octave.org>
 
 	* cmd-edit.cc (command_editor::do_decode_prompt_string):  Update
 	based on current code in Bash.  Handle a few more escape
 	sequences.  Do a better job of decoding \W.
 
 2005-09-04  David Bateman <dbateman@free.fr>
 
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -5,30 +5,28 @@
 # jwe@bevo.che.wisc.edu
 # University of Wisconsin-Madison
 # Department of Chemical Engineering
 
 TOPDIR = ..
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
-VPATH = @srcdir@:@srcdir@/COLAMD
+VPATH = @srcdir@
 
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 LINK_DEPS = \
-  -L../libcruft -L../glob -L. $(RLD_FLAG) \
+  -L../libcruft -L. $(RLD_FLAG) \
   $(LIBCRUFT) $(UMFPACK_LIBS) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBREADLINE) \
-  $(LIBS) $(FLIBS)
-
-include $(srcdir)/COLAMD.files
+  $(LIBGLOB) $(LIBS) $(FLIBS)
 
 MATRIX_INC := Array.h Array2.h Array3.h ArrayN.h DiagArray2.h \
 	Array-flags.h Array-util.h ArrayN-idx.h MArray-defs.h \
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
 	base-lu.h dim-vector.h mx-base.h mx-op-defs.h mx-ops.h \
 	mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h CMatrix.h \
 	CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxDET.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
@@ -62,19 +60,19 @@ INCLUDES := Bounds.h CollocWt.h DAE.h DA
 	base-de.h base-min.h byte-swap.h cmd-edit.h cmd-hist.h \
 	data-conv.h dir-ops.h file-ops.h file-stat.h getopt.h \
 	glob-match.h idx-vector.h kpse-xfns.h \
 	lo-ieee.h lo-mappers.h lo-specfun.h lo-sstream.h \
 	lo-sysdep.h lo-utils.h mach-info.h oct-alloc.h oct-cmplx.h \
 	oct-env.h oct-fftw.h oct-getopt.h oct-group.h oct-inttypes.h \
 	oct-passwd.h oct-rand.h oct-rl-edit.h oct-rl-hist.h \
 	oct-shlib.h oct-sort.h oct-spparms.h oct-syscalls.h \
-	oct-time.h oct-types.h pathlen.h pathsearch.h prog-args.h \
-	so-array.h sparse-sort.h statdefs.h str-vec.h sun-utils.h \
-	sysdir.h systime.h syswait.h \
+	oct-sparse.h oct-time.h oct-types.h pathlen.h pathsearch.h \
+	 prog-args.h so-array.h sparse-sort.h statdefs.h str-vec.h \
+	sun-utils.h sysdir.h systime.h syswait.h \
 	$(OPTS_INC) \
 	$(MATRIX_INC) \
 	$(MX_OP_INC) \
 	$(VX_OP_INC) \
 	$(SPARSE_MX_OP_INC)
 
 TEMPLATE_SRC := Array.cc ArrayN.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MArrayN.cc MDiagArray2.cc \
@@ -147,29 +145,26 @@ SOURCES := \
 	$(LIBOCT_READLINE_SOURCES) \
 	$(LIBOCT_PATHSEARCH_SOURCES)
 
 EXTRAS := mx-inlines.cc kpse.cc intNDArray.cc
 
 INCLUDES_FOR_INSTALL := $(INCLUDES) $(TEMPLATE_SRC) $(EXTRAS)
 
 DISTFILES := Makefile.in ChangeLog mk-ops.awk mx-ops vx-ops \
-	sparse-mk-ops.awk sparse-mx-ops oct-types.h.in \
-	$(SOURCES) $(INCLUDES) $(EXTRAS) $(OPTS_INC_DATA) \
-	$(COLAMD_EXTRAS)
+	sparse-mk-ops.awk sparse-mx-ops oct-sparse.h.in oct-types.h.in \
+	$(SOURCES) $(INCLUDES) $(EXTRAS) $(OPTS_INC_DATA)
 
 # Complete directory trees to distribute.
-DISTDIRS := COLAMD
+DISTDIRS :=
 
-MAKEDEPS_2 := $(SOURCES) $(COLAMD_SRC)
-MAKEDEPS_1 := $(patsubst %.cc, %.d, $(MAKEDEPS_2))
+MAKEDEPS_1 := $(patsubst %.cc, %.d, $(SOURCES))
 MAKEDEPS := $(patsubst %.c, %.d, $(MAKEDEPS_1))
 
 LIBOCTAVE_OBJECTS := \
-	$(COLAMD_OBJ) \
 	$(LIBOCTAVE_CXX_SOURCES:.cc=.o) \
 	$(LIBOCTAVE_C_SOURCES:.c=.o) \
 	$(LIBOCT_READLINE_CXX_SOURCES:.cc=.o) \
 	$(LIBOCT_READLINE_C_SOURCES:.c=.o) \
 	$(LIBOCT_PATHSEARCH_CXX_SOURCES:.cc=.o) \
 	$(LIBOCT_PATHSEARCH_C_SOURCES:.c=.o)
 
 ifeq ($(SHARED_LIBS), true)
@@ -261,17 +256,17 @@ install-lib:
 	    $(DESTDIR)$(octlibdir)/liboctave.$(LIBEXT); \
 	  $(RANLIB) $(DESTDIR)$(octlibdir)/liboctave.$(LIBEXT); \
 	fi
 	if $(SHARED_LIBS); then \
 	  rm -f $(DESTDIR)$(octlibdir)/liboctave.$(SHLLIB_VER); \
 	  $(INSTALL) \
 	    liboctave.$(SHLLIB) $(DESTDIR)$(octlibdir)/liboctave.$(SHLLIB_VER); \
 	  rm -f $(DESTDIR)$(octlibdir)/liboctave.$(SHLLIB); \
-	  $(LN_S) liboctave.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/liboctave.$(SHLLIB); \
+	  (cd $(DESTDIR)$(octlibdir) ; $(LN_S) liboctave.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/liboctave.$(SHLLIB)); \
 	  if  test x$(SHLBIN) != x ; then \
 	    rm -f $(DESTDIR)$(bindir)/liboctave.$(SHLBIN); \
 	    $(INSTALL_PROGRAM) \
 	      liboctave.$(SHLBIN) $(DESTDIR)$(bindir)/liboctave.$(SHLBIN); \
 	  fi; \
 	fi
 .PHONY: install-lib
 
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -33,22 +33,17 @@ Boston, MA 02110-1301, USA.
 
 // Instantiate the base LU class for the types we need.
 
 #include "sparse-base-lu.h"
 #include "sparse-base-lu.cc"
 
 template class sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>;
 
-#ifdef HAVE_UMFPACK
-// Include the UMFPACK functions
-extern "C" {
-#include <umfpack/umfpack.h>
-}
-#endif
+#include "oct-sparse.h"
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
 				  double piv_thres)
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -33,22 +33,17 @@ Boston, MA 02110-1301, USA.
 
 // Instantiate the base LU class for the types we need.
 
 #include "sparse-base-lu.h"
 #include "sparse-base-lu.cc"
 
 template class sparse_base_lu <SparseMatrix, double, SparseMatrix, double>;
 
-#ifdef HAVE_UMFPACK
-// Include the UMFPACK functions
-extern "C" {
-#include <umfpack/umfpack.h>
-}
-#endif
+#include "oct-sparse.h"
 
 SparseLU::SparseLU (const SparseMatrix& a, double piv_thres)
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -36,23 +36,17 @@ Boston, MA 02110-1301, USA.
 #include "dRowVector.h"
 
 #include "CSparse.h"
 #include "boolSparse.h"
 #include "dSparse.h"
 #include "oct-spparms.h"
 #include "SparsedbleLU.h"
 #include "SparseType.h"
-
-#ifdef HAVE_UMFPACK
-// External UMFPACK functions in C
-extern "C" {
-#include <umfpack/umfpack.h>
-}
-#endif
+#include "oct-sparse.h"
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgbtrf, DGBTRF) (const octave_idx_type&, const int&, const octave_idx_type&, 
 			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -127,17 +127,20 @@ extern "C" {
 #ifndef NAME_MAX
 #define NAME_MAX _POSIX_NAME_MAX
 #endif
 
 #include <cctype>
 
 /* What separates elements in environment variable path lists?  */
 #ifndef ENV_SEP
-#ifdef DOSISH
+#if defined (SEPCHAR) && defined (SEPCHAR_STR)
+#define ENV_SEP SEPCHAR
+#define ENV_SEP_STRING SEPCHAR_STR
+#elif defined (DOSISH)
 #define ENV_SEP ';'
 #define ENV_SEP_STRING ";"
 #else
 #define ENV_SEP ':'
 #define ENV_SEP_STRING ":"
 #endif /* not DOS */
 #endif /* not ENV_SEP */
 
diff --git a/liboctave/lo-cutils.c b/liboctave/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/lo-cutils.c
@@ -91,13 +91,23 @@ gethostname (char *name, int namelen)
 #endif
 
 int
 octave_gethostname (char *name, int namelen)
 {
   return gethostname (name, namelen);
 }
 
+#ifdef HAVE_LOADLIBRARY_API
+#include <windows.h>
+
+/* Need this since in C++ can't cast from int(*)() to void* */
+void * octave_w32_library_search (HINSTANCE handle, const char * name)
+{
+  return (GetProcAddress (handle, name));
+}
+#endif
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -55,15 +55,19 @@ extern "C" char *oct_strptime (const cha
 			       struct tm *tm);
 
 extern double octave_read_double (std::istream& is);
 extern Complex octave_read_complex (std::istream& is);
 
 extern void octave_write_double (std::ostream& os, double dval);
 extern void octave_write_complex (std::ostream& os, const Complex& cval);
 
+#ifdef HAVE_LOADLIBRARY_API
+#include <windows.h>
+extern "C" void * octave_w32_library_search (HINSTANCE handle, const char *name);
+#endif
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -362,16 +362,22 @@ octave_env::do_getcwd () const
 // This value is not cached because it can change while Octave is
 // running.
 
 std::string
 octave_env::do_get_home_directory (void) const
 {
   std::string hd = do_getenv ("HOME");
 
+#if defined (__MINGW32__)
+  // Maybe we are started directly from cmd.exe
+  if (hd.empty ())
+    hd = do_getenv ("HOMEPATH");
+#endif
+
   if (hd.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (octave_syscalls::getuid ());
 
       hd = pw ? pw.dir () : std::string (file_ops::dir_sep_str);
     }
 
   return hd;
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -42,16 +42,18 @@ extern "C"
 #else
 extern void *dlopen (const char *, int);
 extern const char *dlerror (void);
 extern void *dlsym (void *, const char *);
 extern int dlclose (void *);
 #endif
 #elif defined (HAVE_SHL_LOAD_API)
 #include <dl.h>
+#elif defined (HAVE_LOADLIBRARY_API)
+#include <windows.h>
 #endif
 }
 
 #include "file-stat.h"
 #include "lo-error.h"
 #include "oct-shlib.h"
 #include "str-vec.h"
 
@@ -490,31 +492,35 @@ octave_w32_shlib::open (const std::strin
 	  (*current_liboctave_error_handler) ("%s: %s", msg, file.c_str ());
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is already open", file.c_str ());
 }
 
+extern "C"
+{
+  void * octave_w32_search (HINSTANCE handle, const char * name);
+}
+
 void *
 octave_w32_shlib::search (const std::string& name,
 			  octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
 	sym_name = mangler (name);
 
-      function
-	= static_cast<void *> (GetProcAddress (handle, sym_name.c_str ()));
+      function = octave_w32_library_search (handle, sym_name.c_str ());
 
       if (function)
 	add_to_fcn_names (name);
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
diff --git a/liboctave/oct-sparse.h.in b/liboctave/oct-sparse.h.in
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-sparse.h.in
@@ -0,0 +1,54 @@
+/*
+
+Copyright (C) 2005 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.
+
+*/
+
+#if !defined (oct_sparse_h)
+#define oct_sparse_h 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef HAVE_UMFPACK
+/* External UMFPACK functions in C */
+#include <@UMFPACK_INCLUDE@>
+#endif
+
+#ifdef HAVE_COLAMD
+/* External COLAMD functions in C */
+#include <@COLAMD_INCLUDE@>
+#endif
+
+#ifdef HAVE_CCOLAMD
+/* External COLAMD functions in C */
+#include <@CCOLAMD_INCLUDE@>
+#endif
+
+#ifdef HAVE_CHOLMOD
+/* External CHOLMOD functions in C */
+#include <@CHOLMOD_INCLUDE@>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/octMakefile.in b/octMakefile.in
--- a/octMakefile.in
+++ b/octMakefile.in
@@ -16,17 +16,18 @@ include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_DATA = @INSTALL_DATA@
 
 CONF_DISTFILES = Makefile Makefile.in octMakefile.in Makeconf.in \
 	configure configure.in config.guess config.sub aclocal.m4 \
-	acx_blas.m4 acx_lapack.m4 config.h.in install-sh autogen.sh
+	acx_blas.m4 acx_lapack.m4 acx_include_dirs.m4 config.h.in \
+	install-sh autogen.sh
 
 DISTFILES = $(CONF_DISTFILES) \
 	BUGS COPYING FLEX.patch INSTALL INSTALL.OCTAVE NEWS \
 	NEWS.[0-9] PROJECTS README README.Linux README.Windows \
 	README.MachTen README.kpathsea ROADMAP SENDING-PATCHES \
 	THANKS move-if-change octave-sh octave-bug.in \
 	octave-config.in mk-opts.pl mkinstalldirs \
 	mkoctfile.in ChangeLog ChangeLog.[0-9]
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,58 @@
+2005-09-15  John W. Eaton  <jwe@octave.org>
+
+	* sysdep.h [__MINGW32__]: Move to definition of waitpid sysdep.h.
+
+	* sysdep.cc, sighandlers.cc: Rename all win32_ symbols to w32.
+
+	* sysdep.cc (w32_set_quiet_shutdown): New function.
+	* sysdep.h: Provide decl.
+	* sysdep.cc (MINGW_signal_cleanup): Use it.
+	* sighandlers.cc (octave_catch_interrupts): Use it.
+
+	* sysdep.h: Provide decl.
+	(MINGW_SIGNAL_CLEANUP): New macro.
+	(USE_W32_SIGINT): Move definition here.
+	* sighandlers.cc: From here.
+
+	* DLD-FUNCTIONS/cellfun.cc (Fnum2cell): Use print_usage, not usage.
+	* DLD-FUNCTIONS/colamd.cc (Fcolamd, Fsymamd, Fetree): Likewise.
+	(Fcolamd, Fsymamd) [! HAVE_COLAMD]: Return empty octave_value_list
+	object.
+
+	* sysdep.cc (sysdep_cleanup): New function.
+	Move w32 clean up code here.
+	* toplev.cc (clean_up_and_exit): From here.
+	Call sysdep_cleanup here.
+
+2005-09-15  David Bateman  <dbateman@free.fr>
+
+	* Makefile.in (DLD_XSRC): Add ccolamd.cc
+	(OCTAVE_LIBS): Add LIBGLOB.
+	(OCT_LINK_DEPST, octave): Add AMD, COLAMD, CCOLAMD and CHOLMOD 
+	libraries.
+	* default.cc (set_default_exec_path, set_default_path,
+	maybe_add_default_load_path, LOADPATH): Use SEPCHAR_STR and SEPCHAR.
+	* help.cc (display_help_text): Exclude /dev/null on mingw.
+	* oct-procbuf.cc (W32POPEN, W32PCLOSE): Macros for cygwin/mingw.
+	(octave_procbuf::open, octave_probuf::close): Use them.
+	* sighandler.cc (user_abort): New function with core of old
+	sigint_handler.
+	(sigint_handler): Simplify and specialize for w32.
+	(w32_sigint_handler): W32 version of sigint handler.
+	(octave_catch_interrupts): Initialize w32 siginit handler.
+	* sysdep.cc (MINGW_init): New function.
+	(sysdep_init): Use it.
+	* toplev.cc (clean_up_and_exit): Clean w32 signalling shutdown.
+	* DLD-FUNCTIONS/cellfun.cc (Fnum2cell): New function.
+	* DLD-FUNCTIONS/colamd.cc (Fcolamd, Fsymamd): Allow conditional build.
+	Include oct-sparse.h rather than colamd.h.
+	* DLD-FUNCTIONS/ccolamd.cc: New file with Fccolamd a Fcsymamd.
+	
 2005-09-14  John W. Eaton  <jwe@octave.org>
 
 	* ov-complex.cc (octave_complex::try_narrowing_conversion):
 	Don't drop -0i.
 	* ov-cx-mat.cc (octave_complex_matrix::try_narrowing_conversion):
 	Likewise.
 
 2005-09-14  Daniel  <durbano@shbano.com>
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
new file mode 100644
--- /dev/null
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -0,0 +1,580 @@
+/*
+
+Copyright (C) 2005 David Bateman
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.
+
+*/
+
+// This is the octave interface to ccolamd, which bore the copyright given
+// in the help of the functions.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <cstdlib>
+
+#include <string>
+#include <vector>
+
+#include "ov.h"
+#include "defun-dld.h"
+#include "pager.h"
+#include "ov-re-mat.h"
+
+#include "ov-re-sparse.h"
+#include "ov-cx-sparse.h"
+
+#include "oct-sparse.h"
+
+#ifdef IDX_TYPE_LONG
+#define CCOLAMD_NAME(name) ccolamd_l ## name
+#define CSYMAMD_NAME(name) csymamd_l ## name
+#else
+#define CCOLAMD_NAME(name) ccolamd ## name
+#define CSYMAMD_NAME(name) csymamd ## name
+#endif
+
+DEFUN_DLD (ccolamd, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
+@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
+\n\
+Constrained column approximate minimum degree permutation. @code{@var{p} =\n\
+ccolamd (@var{s})} returns the column approximate minimum degree permutation\n\
+vector for the sparse matrix @var{s}. For a non-symmetric matrix @var{s},\n\
+@code{@var{s}(:,@var{p})} tends to have sparser LU factors than @var{s}.\n\
+@code{chol (@var{s}(:,@var{p})'*@var{s}(:,@var{p}))} also tends to be\n\
+sparser than @code{chol (@var{s}'*@var{s})}. @code{@var{p} = ccolamd\n\
+(@var{s},1)} optimizes the ordering for @code{lu (@var{s}(:,@var{p}))}.\n\
+The ordering is followed by a column elimination tree post-ordering.\n\
+\n\
+@var{knobs} is an optional one- to five-element input vector, with a default\n\
+value of @code{[0 10 10 1 0]} if not present or empty.  Entries not present\n\
+are set to their defaults.\n\
+\n\
+@table @code\n\
+@item @var{knobs}(1)\n\
+if nonzero, the ordering is optimized for @code{lu(S(:,p)).  It will be a\n\
+poor ordering for @code{chol(@var{s}(:,@var{p})'*@var{s}(:,@var{p}))}. This\n\
+is the most important knob for ccolamd.\n\
+\n\
+@item @var{knob}(2)\n\
+if @var{s} is m-by-n, rows with more than @code{max(16,@var{knobs}(2)*\n\
+sqrt(n))} entries are ignored.\n\
+\n\
+@item @var{knob}(3)\n\
+columns with more than @code{max(16,@var{knobs}(3)*sqrt(min(m,n)))}\n\
+entries are ignored and ordered last in the output permutation (subject\n\
+to the cmember constraints).\n\
+\n\
+@item @var{knob}(4)\n\
+if nonzero, aggressive absorption is performed.\n\
+\n\
+@item @var{knob}(5)\n\
+if nonzero, statistics and knobs are printed.\n\
+\n\
+@end table\n\
+\n\
+@var{cmember} is an optional vector of length n.  It defines the constraints\n\
+on the column ordering.  If @code{@var{cmember}(j) = @var{c}}, then column j\n\
+is in constraint set @var{c} (@var{c} must be in the range 1 to n).  In\n\
+the output permutation @var{p}, all columns in set 1 appear first, followed\n\
+by all columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)} if\n\
+not present or empty.  @code{ccolamd (@var{s},[],1:n)} returns @code{1:n}\n\
+\n\
+@code{@var{p} = ccolamd(@var{s})} is about the same as @code{@var{p} =\n\
+colamd(@var{s}). @var{knobs} and its default values differ. @code{colamd}\n\
+always does aggressive absorption, and it finds an ordering suitable for\n\
+both @code{lu(@var{s}(:,@var{p}))} and @code{chol(@var{S}(:,@var{p})'*\n\
+@var{s}(:,@var{p}))}; it cannot optimize its ordering for @code{lu(@var{s}\n\
+(:,@var{p}))} to the extent that @code{ccolamd(@var{s},1)} can.\n\
+\n\
+@var{stats} is an optional 20-element output vector that provides data\n\
+about the ordering and the validity of the input matrix @var{s}. Ordering\n\
+statistics are in @code{@var{stats} (1:3)}. @code{@var{stats} (1)} and\n\
+@code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
+ignored by CCOLAMD and @code{@var{stats} (3)} is the number of garbage\n\
+collections performed on the internal data structure used by CCOLAMD\n\
+(roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
+integers).\n\
+\n\
+@code{@var{stats} (4:7)} provide information if CCOLAMD was able to\n\
+continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
+invalid. @code{@var{stats} (5)} is the rightmost column index that is\n\
+unsorted or contains duplicate entries, or zero if no such column exists.\n\
+@code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
+index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
+such row index exists. @code{@var{stats} (7)} is the number of duplicate\n\
+or out-of-order row indices. @code{@var{stats} (8:20)} is always zero in\n\
+the current version of CCOLAMD (reserved for future use).\n\
+\n\
+The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
+and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
+by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
+and a grant from Sandia National Lab.  See\n\
+@url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
+colamd, symamd, and other related orderings.\n\
+\n\
+@end deftypefn\n\
+@seealso{colamd, csymamd}")
+{
+#ifdef HAVE_CCOLAMD
+  octave_value_list retval;
+  int nargin = args.length ();
+  int spumoni = 0;
+ 
+  if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 3)
+    usage ("ccolamd: incorrect number of input and/or output arguments");
+  else
+    {
+      // Get knobs
+      OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);      
+      CCOLAMD_NAME (_set_defaults) (knobs);
+
+      // Check for user-passed knobs
+      if (nargin > 1)
+	{
+	  NDArray User_knobs = args(1).array_value ();
+	  int nel_User_knobs = User_knobs.length ();
+
+	  if (nel_User_knobs > 0) 
+	    knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
+	  if (nel_User_knobs > 1) 
+	    knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
+	  if (nel_User_knobs > 2) 
+	    knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
+	  if (nel_User_knobs > 3) 
+	    knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
+	  if (nel_User_knobs > 4) 
+	    spumoni = (User_knobs (4) != 0);
+
+	  // print knob settings if spumoni is set
+	  if (spumoni)
+	    {
+	      octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
+			    <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE 
+			    << ":\nknobs(1): " << User_knobs (0) << ", order for ";
+	      if ( knobs [CCOLAMD_LU] != 0)
+		octave_stdout << "lu(A)\n";
+	      else
+		octave_stdout << "chol(A'*A)\n";
+
+	      if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+		octave_stdout << "knobs(2): " << User_knobs (1) 
+			      << ", rows with > max(16,"
+			      << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+			      << " entries removed\n";
+	      else
+		octave_stdout << "knobs(2): " << User_knobs (1)
+			      << ", no dense rows removed\n";
+
+	      if (knobs [CCOLAMD_DENSE_COL] >= 0)
+		octave_stdout << "knobs(3): " << User_knobs (2) 
+			      << ", cols with > max(16,"
+			      << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
+			      << " entries removed\n";
+	      else
+		octave_stdout << "knobs(3): " << User_knobs (2)
+			      << ", no dense columns removed\n";
+
+	      if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+		octave_stdout << "knobs(4): " << User_knobs(3) 
+			      << ", aggressive absorption: yes";
+	      else
+		octave_stdout << "knobs(4): " << User_knobs(3) 
+			      << ", aggressive absorption: no";
+ 
+	      octave_stdout << "knobs(5): " << User_knobs (4) 
+			    << ", statistics and knobs printed\n";
+	    }
+	}
+      
+      octave_idx_type n_row, n_col, nnz;
+      octave_idx_type *ridx, *cidx;
+      SparseComplexMatrix scm;
+      SparseMatrix sm;
+
+      if (args(0).class_name () == "sparse")
+	{
+	  if (args(0).is_complex_type ())
+	    {
+	      scm = args(0). sparse_complex_matrix_value ();
+	      n_row = scm.rows ();
+	      n_col = scm.cols ();
+	      nnz = scm.nnz ();
+	      ridx = scm.xridx ();
+	      cidx = scm.xcidx ();
+	    }
+	  else
+	    {
+	      sm = args(0).sparse_matrix_value ();
+
+	      n_row = sm.rows ();
+	      n_col = sm.cols ();
+	      nnz = sm.nnz ();
+	      ridx = sm.xridx ();
+	      cidx = sm.xcidx ();
+	    }
+	}
+      else
+	{
+	  if (args(0).is_complex_type ())
+	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+	  else
+	    sm = SparseMatrix (args(0).matrix_value ());
+
+	  n_row = sm.rows ();
+	  n_col = sm.cols ();
+	  nnz = sm.nnz ();
+	  ridx = sm.xridx ();
+	  cidx = sm.xcidx ();
+	}
+
+      // Allocate workspace for ccolamd
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
+      for (octave_idx_type i = 0; i < n_col+1; i++)
+	p[i] = cidx [i];
+
+      octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
+      for (octave_idx_type i = 0; i < nnz; i++)
+	A[i] = ridx [i];
+
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
+
+      if (nargin > 2)
+	{
+	  NDArray in_cmember = args(2).array_value();
+	  octave_idx_type cslen = in_cmember.length();
+	  OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+	  for (octave_idx_type i = 0; i < cslen; i++)
+	    // convert cmember from 1-based to 0-based
+	    cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+	  
+	  if (cslen != n_col)
+	    error ("ccolamd: cmember must be of length equal to #cols of A");
+	  else
+	    // Order the columns (destroys A)
+	    if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
+	      {
+		CCOLAMD_NAME (_report) (stats) ;
+		error ("ccolamd: internal error!");
+		return retval;
+	      }
+	}
+      else
+	{
+	  // Order the columns (destroys A)
+	  if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, NULL))
+	    {
+	      CCOLAMD_NAME (_report) (stats) ;
+	      error ("ccolamd: internal error!");
+	      return retval;
+	    }
+	}
+
+      // return the permutation vector
+      NDArray out_perm (dim_vector (1, n_col));
+      for (octave_idx_type i = 0; i < n_col; i++)
+	out_perm(i) = p [i] + 1;
+
+      retval (0) = out_perm;
+
+      // print stats if spumoni > 0
+      if (spumoni > 0)
+	CCOLAMD_NAME (_report) (stats) ;
+
+      // Return the stats vector
+      if (nargout == 2)
+	{
+	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+	    out_stats (i) = stats [i] ;
+	  retval(1) = out_stats;
+
+	  // fix stats (5) and (6), for 1-based information on 
+	  // jumbled matrix.  note that this correction doesn't 
+	  // occur if symamd returns FALSE
+	  out_stats (CCOLAMD_INFO1) ++ ; 
+	  out_stats (CCOLAMD_INFO2) ++ ; 
+	}
+    }
+
+  return retval;
+#else
+
+  error ("ccolamd: not available in this version of Octave");
+
+#endif
+}
+
+DEFUN_DLD (csymamd, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{p} =} csymamd (@var{s})\n\
+@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs}, @var{cmember})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
+\n\
+For a symmetric positive definite matrix @var{s}, returns the permutation\n\
+vector @var{p} such that @code{@var{s}(@var{p},@var{p})} tends to have a\n\
+sparser Cholesky factor than @var{s}. Sometimes @code{csymamd} works well\n\
+for symmetric indefinite matrices too. The matrix @var{s} is assumed to\n\
+be symmetric; only the strictly lower triangular part is referenced.\n\
+@var{s} must be square. The ordering is followed by an elimination tree\n\
+post-ordering.\n\
+\n\
+@var{knobs} is an optional one- to three-element input vector, with a\n\
+default value of @code{[10 1 0]} if present or empty.  Entries not\n\
+present are set to their defaults.\n\
+\n\
+@table @code\n\
+@item @var{knobs}(1)\n\
+If @var{s} is n-by-n, then rows and columns with more than\n\
+@code{max(16,@var{knobs}(1)*sqrt(n))} entries are ignored, and ordered\n\
+last in the output permutation (subject to the cmember constraints).\n\
+\n\
+@item @var{knobs}(2)\n\
+If nonzero, aggressive absorption is performed.\n\
+\n\
+@item @var{knobs}(3)\n\
+If nonzero, statistics and knobs are printed.\n\
+\n\
+@end table\n\
+\n\
+@var{cmember} is an optional vector of length n. It defines the constraints\n\
+on the ordering. If @code{@var{cmember}(j) = @var{s}}, then row/column j is\n\
+in constraint set @var{c} (@var{c} must be in the range 1 to n). In the\n\
+output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
+by all rows/columns in set 2, and so on. @code{@var{cmember} = ones(1,n)}\n\
+if not present or empty. @code{csymamd(@var{s},[],1:n)} returns @code{1:n}.\n\
+\n\
+@code{@var{p} = csymamd(@var{s})} is about the same as @code{@var{p} =\n\
+symamd(@var{s})}. @var{knobs} and its default values differ.\n\
+\n\
+@code{@var{stats} (4:7)} provide information if CCOLAMD was able to\n\
+continue. The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
+invalid. @code{@var{stats} (5)} is the rightmost column index that is\n\
+unsorted or contains duplicate entries, or zero if no such column exists.\n\
+@code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
+index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
+such row index exists. @code{@var{stats} (7)} is the number of duplicate\n\
+or out-of-order row indices. @code{@var{stats} (8:20)} is always zero in\n\
+the current version of CCOLAMD (reserved for future use).\n\
+\n\
+The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
+and S. Rajamanickam in collaboration with J. Bilbert and E. Ng. Supported\n\
+by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
+and a grant from Sandia National Lab.  See\n\
+@url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
+colamd, symamd, and other related orderings.\n\
+\n\
+@end deftypefn\n\
+@seealso{symamd, ccolamd}")
+{
+#if HAVE_CCOLAMD
+  octave_value_list retval;
+  int nargin = args.length ();
+  int spumoni = 0;
+ 
+  if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 3)
+    usage ("ccolamd: incorrect number of input and/or output arguments");
+  else
+    {
+      // Get knobs
+      OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
+      CCOLAMD_NAME (_set_defaults) (knobs);
+
+      // Check for user-passed knobs
+      if (nargin > 1)
+	{
+	  NDArray User_knobs = args(1).array_value ();
+	  int nel_User_knobs = User_knobs.length ();
+	  
+	  if (nel_User_knobs > 0) 
+	    knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
+	  if (nel_User_knobs > 0) 
+	    knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
+	  if (nel_User_knobs > 1) 
+	    spumoni = (int) User_knobs (2);
+
+	  // print knob settings if spumoni is set
+	  if (spumoni)
+	    {
+	      octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
+			    <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
+
+	      if (knobs [CCOLAMD_DENSE_ROW] >= 0)
+		octave_stdout << "knobs(1): " << User_knobs (0) 
+			      << ", rows/cols with > max(16,"
+			      << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+			      << " entries removed\n";
+	      else
+		octave_stdout << "knobs(1): " << User_knobs (0)
+			      << ", no dense rows/cols removed\n";
+
+	      if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+		octave_stdout << "knobs(2): " << User_knobs(1) 
+			      << ", aggressive absorption: yes";
+	      else
+		octave_stdout << "knobs(2): " << User_knobs(1) 
+			      << ", aggressive absorption: no";
+ 
+
+	      octave_stdout << "knobs(3): " << User_knobs (2) 
+			    << ", statistics and knobs printed\n";
+	    }
+	}
+      
+      octave_idx_type n_row, n_col, nnz;
+      octave_idx_type *ridx, *cidx;
+      SparseMatrix sm;
+      SparseComplexMatrix scm;
+
+      if (args(0).class_name () == "sparse")
+	{
+	  if (args(0).is_complex_type ())
+	    {
+	      scm = args(0).sparse_complex_matrix_value ();
+	      n_row = scm.rows ();
+	      n_col = scm.cols ();
+	      nnz = scm.nnz ();
+	      ridx = scm.xridx ();
+	      cidx = scm.xcidx ();
+	    }
+	  else
+	    {
+	      sm = args(0).sparse_matrix_value ();
+	      n_row = sm.rows ();
+	      n_col = sm.cols ();
+	      nnz = sm.nnz ();
+	      ridx = sm.xridx ();
+	      cidx = sm.xcidx ();
+	    }
+	}
+      else
+	{
+	  if (args(0).is_complex_type ())
+	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
+	  else
+	    sm = SparseMatrix (args(0).matrix_value ());
+	  
+	  n_row = sm.rows ();
+	  n_col = sm.cols ();
+	  nnz = sm.nnz ();
+	  ridx = sm.xridx ();
+	  cidx = sm.xcidx ();
+	}
+
+      if (n_row != n_col)
+	{
+	  error ("symamd: matrix must be square");
+	  return retval;
+	}
+
+      // Allocate workspace for symamd
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
+
+      if (nargin > 2)
+	{
+	  NDArray in_cmember = args(2).array_value();
+	  octave_idx_type cslen = in_cmember.length();
+	  OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+	  for (octave_idx_type i = 0; i < cslen; i++)
+	    // convert cmember from 1-based to 0-based
+	    cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+	  
+	  if (cslen != n_col)
+	    error ("ccolamd: cmember must be of length equal to #cols of A");
+	  else
+	    if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+				  &calloc, &free, cmember, -1))
+	      {
+		CSYMAMD_NAME (_report) (stats) ;
+		error ("symamd: internal error!") ;
+		return retval;
+	      }
+	}
+      else
+	{
+	  if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+				&calloc, &free, NULL, -1))
+	    {
+	      CSYMAMD_NAME (_report) (stats) ;
+	      error ("symamd: internal error!") ;
+	      return retval;
+	    }
+	}
+
+      // return the permutation vector
+      NDArray out_perm (dim_vector (1, n_col));
+      for (octave_idx_type i = 0; i < n_col; i++)
+	out_perm(i) = perm [i] + 1;
+
+      retval (0) = out_perm;
+
+      // Return the stats vector
+      if (nargout == 2)
+	{
+	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+	    out_stats (i) = stats [i] ;
+	  retval(1) = out_stats;
+
+	  // fix stats (5) and (6), for 1-based information on 
+	  // jumbled matrix.  note that this correction doesn't 
+	  // occur if symamd returns FALSE
+	  out_stats (CCOLAMD_INFO1) ++ ; 
+	  out_stats (CCOLAMD_INFO2) ++ ; 
+	}
+
+      // print stats if spumoni > 0
+      if (spumoni > 0)
+	CSYMAMD_NAME (_report) (stats) ;
+
+      // Return the stats vector
+      if (nargout == 2)
+	{
+	  NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
+	  for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
+	    out_stats (i) = stats [i] ;
+	  retval(1) = out_stats;
+
+	  // fix stats (5) and (6), for 1-based information on 
+	  // jumbled matrix.  note that this correction doesn't 
+	  // occur if symamd returns FALSE
+	  out_stats (CCOLAMD_INFO1) ++ ; 
+	  out_stats (CCOLAMD_INFO2) ++ ; 
+	}
+    }
+
+  return retval;
+#else
+
+  error ("csymamd: not available in this version of Octave");
+
+#endif
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -28,16 +28,17 @@ 02110-1301, USA.
 #include <string>
 
 #include "lo-mappers.h"
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "parse.h"
 #include "variables.h"
+#include "ov-colon.h"
 
 DEFUN_DLD (cellfun, args, ,
   " -*- texinfo -*-\n\
 @deftypefn {Lodable Function} {} cellfun (@var{name}, @var{c})\n\
 @deftypefnx {Lodable Function} {} cellfun (\"isclass\", @var{c}, @var{class})\n\
 @deftypefnx {Lodable Function} {} cellfun (\"size\", @var{c}, @var{k})\n\
 @deftypefnx {Lodable Function} {} cellfun (@var{func}, @var{c})\n\
 \n\
@@ -238,13 +239,101 @@ cellfun (\"tolower(x)\", @{\"Foo\", \"Ba
 	  if (! fcn_name.empty ())
 	    clear_function (fcn_name);
 	}
     }
 
   return retval;
 }
 
+DEFUN_DLD (num2cell, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{c} =} num2cell (@var{m})\n\
+@deftypefnx {Loadable Function} {@var{c} =} num2cell (@var{m}, @var{d})\n\
+Convert to matrix @var{m} into a cell array. If @var{d} is defined the\n\
+value @var{c} is of dimension 1 in this dimension and the elements of\n\
+@var{m} are placed in slices in @var{c}.\n\
+@end deftypefn\n\
+@seealso{mat2cell}") 
+{
+  int nargin =  args.length();
+  octave_value retval;
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ("num2cell");
+  else
+    {
+      dim_vector dv = args(0).dims ();
+      Array<int> sings;
+
+      if (nargin == 2)
+	{
+	  ColumnVector dsings = ColumnVector (args(1).vector_value 
+						  (false, true));
+	  sings.resize (dsings.length());
+
+	  if (!error_state)
+	    for (int i = 0; i < dsings.length(); i++)
+	      if (dsings(i) > dv.length() || dsings(i) < 1 ||
+		  D_NINT(dsings(i)) != dsings(i))
+		{
+		  error ("invalid dimension specified");
+		  break;
+		}
+	      else
+		sings(i) = NINT(dsings(i)) - 1;
+	}
+
+      if (! error_state)
+	{
+	  Array<bool> idx_colon (dv.length());
+	  dim_vector new_dv (dv);
+	  octave_value_list lst (new_dv.length(), octave_value());
+
+	  for (int i = 0; i < dv.length(); i++)
+	    {
+	      idx_colon(i) = false;
+	      for (int j = 0; j < sings.length(); j++)
+		{
+		  if (sings(j) == i)
+		    {
+		      new_dv(i) = 1;
+		      idx_colon(i) = true;
+		      lst(i) = octave_value (octave_value::magic_colon_t); 
+		      break;
+		    }
+		}
+	    }
+
+	  Cell ret (new_dv);
+	  octave_idx_type nel = new_dv.numel();
+	  octave_idx_type ntot = 1;
+
+	  for (int j = 0; j < new_dv.length()-1; j++)
+	    ntot *= new_dv(j);
+
+	  for (octave_idx_type i = 0; i <  nel; i++)
+	    {
+	      octave_idx_type n = ntot;
+	      octave_idx_type ii = i;
+	      for (int j = new_dv.length() - 1; j >= 0 ; j--)
+		{
+		  if (! idx_colon(j))
+		    lst (j) = ii/n + 1;
+		  ii = ii % n;
+		  if (j != 0)
+		    n /= new_dv(j-1);
+		}
+	      ret(i) = args(0).do_index_op(lst, 0);
+	    }
+
+	  retval = ret;
+	}
+    }
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -35,20 +35,17 @@ Boston, MA 02110-1301, USA.
 #include "ov.h"
 #include "defun-dld.h"
 #include "pager.h"
 #include "ov-re-mat.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-// External COLAMD functions in C
-extern "C" {
-#include "COLAMD/colamd.h"
-}
+#include "oct-sparse.h"
 
 #ifdef IDX_TYPE_LONG
 #define COLAMD_NAME(name) colamd_l ## name
 #define SYMAMD_NAME(name) symamd_l ## name
 #else
 #define COLAMD_NAME(name) colamd ## name
 #define SYMAMD_NAME(name) symamd ## name
 #endif
@@ -265,21 +262,24 @@ The authors of the code itself are Stefa
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory. (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @end deftypefn\n\
 @seealso{colperm, symamd}")
 {
   octave_value_list retval;
+
+#ifdef HAVE_COLAMD
+
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    usage ("colamd: incorrect number of input and/or output arguments");
+    print_usage ("colamd");
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);      
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
@@ -423,16 +423,22 @@ Ng, Oak Ridge National Laboratory. (see\
 	  // fix stats (5) and (6), for 1-based information on 
 	  // jumbled matrix.  note that this correction doesn't 
 	  // occur if symamd returns FALSE
 	  out_stats (COLAMD_INFO1) ++ ; 
 	  out_stats (COLAMD_INFO2) ++ ; 
 	}
     }
 
+#else
+
+  error ("colamd: not available in this version of Octave");
+
+#endif
+
   return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s})\n\
@@ -492,21 +498,24 @@ The authors of the code itself are Stefa
 Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory. (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @end deftypefn\n\
 @seealso{colperm, colamd}")
 {
   octave_value_list retval;
+
+#ifdef HAVE_COLAMD
+
   int nargin = args.length ();
   int spumoni = 0;
  
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    usage ("symamd: incorrect number of input and/or output arguments");
+    print_usage ("symamd");
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
@@ -611,16 +620,22 @@ Ng, Oak Ridge National Laboratory. (see\
 	  // fix stats (5) and (6), for 1-based information on 
 	  // jumbled matrix.  note that this correction doesn't 
 	  // occur if symamd returns FALSE
 	  out_stats (COLAMD_INFO1) ++ ; 
 	  out_stats (COLAMD_INFO2) ++ ; 
 	}
     }
 
+#else
+
+  error ("symamd: not available in this version of Octave");
+
+#endif
+
   return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} etree (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{s}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{s}, @var{typ})\n\
@@ -635,17 +650,17 @@ Called with a second argument, @dfn{etre
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargout < 0 || nargout > 2 || nargin < 0 || nargin > 2)
-    usage ("etree: incorrect number of input and/or output arguments");
+    print_usage ("etree");
   else
     {
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       bool is_sym = true;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -37,18 +37,18 @@ ifeq ($(ENABLE_DYNAMIC_LINKING), true)
     %.oct : %.o octave$(EXEEXT)
 	  $(DL_LD) $(DL_LDFLAGS) -o $@ $< $(OCT_LINK_DEPS)
   endif
 endif
 
 OPT_HANDLERS := DASPK-opts.cc DASRT-opts.cc DASSL-opts.cc \
 	LSODE-opts.cc NLEqn-opts.cc Quad-opts.cc
 
-DLD_XSRC := balance.cc besselj.cc betainc.cc cellfun.cc chol.cc colamd.cc \
-	colloc.cc daspk.cc dasrt.cc dassl.cc det.cc dispatch.cc \
+DLD_XSRC := balance.cc besselj.cc betainc.cc cellfun.cc chol.cc ccolamd.cc \
+	colamd.cc colloc.cc daspk.cc dasrt.cc dassl.cc det.cc dispatch.cc \
 	eig.cc expm.cc fft.cc fft2.cc fftn.cc fftw_wisdom.cc \
 	filter.cc find.cc fsolve.cc gammainc.cc gcd.cc getgrent.cc \
 	getpwent.cc getrusage.cc givens.cc hess.cc inv.cc kron.cc \
 	lpsolve.cc lsode.cc lu.cc luinc.cc matrix_type.cc minmax.cc \
 	pinv.cc qr.cc quad.cc qz.cc rand.cc schur.cc sort.cc sparse.cc \
 	spdet.cc spkron.cc splu.cc spparms.cc sqrtm.cc svd.cc syl.cc \
 	time.cc gplot.l __glpk__.cc __qp__.cc
 
@@ -230,29 +230,30 @@ VAR_FILES := $(patsubst %.cc, %.df, $(VA
 DOC_FILES := $(sort $(DEF_FILES) $(VAR_FILES))
 
 OCTAVE_LFLAGS = -L$(TOPDIR)/liboctave -L$(TOPDIR)/libcruft \
   -L$(TOPDIR)/src $(RLD_FLAG)
 
 ifeq ($(ENABLE_DYNAMIC_LINKING), true)
   OCTAVE_LIBS = $(LIBOCTINTERP) $(LIBOCTAVE) \
     $(SPECIAL_MATH_LIB) $(LIBCRUFT) \
-    $(LIBPLPLOT) $(LIBDLFCN)
+    $(LIBPLPLOT) $(LIBGLOB) $(LIBDLFCN)
 else
   OCTAVE_LIBS = $(LIBOCTINTERP) $(LIBOCTAVE) \
     $(GLPK_LIBS) $(SPECIAL_MATH_LIB) $(LIBCRUFT) \
-    $(LIBPLPLOT) $(LIBDLFCN)
+    $(LIBPLPLOT) $(LIBGLOB) $(LIBDLFCN)
 endif
 
 OCTINTERP_LINK_DEPS = \
   -L../liboctave $(LIBOCTAVE) -L../libcruft $(LIBCRUFT) $(LIBS) $(FLIBS)
 
 OCT_LINK_DEPS = \
   -L../libcruft $(LIBCRUFT) -L../liboctave $(LIBOCTAVE) \
-  -L. $(LIBOCTINTERP) $(UMFPACK_LIBS) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBS) $(FLIBS)
+  -L. $(LIBOCTINTERP) $(UMFPACK_LIBS) $(AMD_LIBS) $(COLAMD_LIBS) \
+   $(CHOLMOD_LIBS) $(CCOLAMD_LIBS) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBS) $(FLIBS)
 
 DISTFILES = Makefile.in ChangeLog mkdefs mkops mkgendoc \
 	DOCSTRINGS mkbuiltins mk-oct-links \
 	defaults.h.in oct-conf.h.in octave.gperf oct-gperf.h \
 	octave.cc parse.cc lex.cc y.tab.h gplot.cc \
 	$(INCLUDES) $(DIST_SRC) $(OPT_HANDLERS) $(EXTRAS)
 
 all: octave$(EXEEXT) stamp-oct-links PKG_ADD DOCSTRINGS
@@ -308,17 +309,19 @@ stamp-prereq: defaults.h oct-conf.h oct-
 	touch stamp-prereq
 
 octave$(EXEEXT): stamp-prereq $(LIBRARIES) main.o $(DLD_STATIC_OBJ)
 	$(LD_CXX) $(CPPFLAGS) $(ALL_CXXFLAGS) $(RDYNAMIC_FLAG) \
 	$(ALL_LDFLAGS) -o $@ \
 	main.o $(DLD_STATIC_OBJ) \
 	$(OCTAVE_LFLAGS) \
 	$(OCTAVE_LIBS) \
-	$(LEXLIB) $(UMFPACK_LIBS) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBS) $(FLIBS)
+	$(LEXLIB) $(UMFPACK_LIBS) $(AMD_LIBS) $(COLAMD_LIBS) \
+	$(CHOLMOD_LIBS) $(CCOLAMD_LIBS) $(BLAS_LIBS) \
+	$(FFTW_LIBS) $(LIBS) $(FLIBS)
 
 stmp-pic: pic
 	@if [ -f stmp-pic ]; then \
 	  true; \
 	else \
 	  echo "touch stmp-pic"; \
 	  touch stmp-pic; \
 	fi
@@ -390,17 +393,17 @@ install: install-bin install-oct install
 install-strip:
 	$(MAKE) INSTALL_PROGRAM="$(INSTALL_PROGRAM) -s" install
 .PHONY: install-strip
 
 install-bin:
 	$(top_srcdir)/mkinstalldirs $(DESTDIR)$(bindir)
 	rm -f $(DESTDIR)$(bindir)/octave$(EXEEXT)
 	$(INSTALL_PROGRAM) octave$(EXEEXT) $(DESTDIR)$(bindir)/octave-$(version)$(EXEEXT)
-	$(LN_S) octave-$(version)$(EXEEXT) $(DESTDIR)$(bindir)/octave$(EXEEXT)
+	cd $(DESTDIR)$(bindir) ; $(LN_S) octave-$(version)$(EXEEXT) octave$(EXEEXT)
 .PHONY: install-bin
 
 install-oct: PKG_ADD
 	$(top_srcdir)/mkinstalldirs $(DESTDIR)$(octfiledir)
 	$(INSTALL_DATA) PKG_ADD $(DESTDIR)$(octfiledir)/PKG_ADD
 	if [ -n "$(OCT_FILES)" ]; then \
 	  xfiles="$(OCT_FILES)"; \
 	  for f in $$xfiles; do \
@@ -418,17 +421,17 @@ install-lib:
 	    $(DESTDIR)$(octlibdir)/liboctinterp.$(LIBEXT); \
 	  $(RANLIB) $(DESTDIR)$(octlibdir)/liboctinterp.$(LIBEXT); \
 	fi
 	if $(SHARED_LIBS); then \
 	  rm -f $(DESTDIR)$(octlibdir)/liboctinterp.$(SHLEXT_VER); \
 	  $(INSTALL) liboctinterp.$(SHLLIB) \
 	    $(DESTDIR)$(octlibdir)/liboctinterp.$(SHLLIB_VER); \
 	  rm -f $(DESTDIR)$(octlibdir)/liboctinterp.$(SHLLIB); \
-	  $(LN_S) liboctinterp.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/liboctinterp.$(SHLLIB); \
+	  (cd $(DESTDIR)$(octlibdir) ; $(LN_S) liboctinterp.$(SHLLIB_VER) $(DESTDIR)$(octlibdir)/liboctinterp.$(SHLLIB)); \
 	  if  test x$(SHLBIN) != x ; then \
 	    rm -f $(DESTDIR)$(bindir)/liboctinterp.$(SHLBIN); \
 	    $(INSTALL_PROGRAM) \
 	      liboctinterp.$(SHLBIN) $(DESTDIR)$(bindir)/liboctinterp.$(SHLBIN); \
 	  fi; \
 	fi
 .PHONY: install-lib
 
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -276,32 +276,32 @@ set_default_exec_path (void)
   std::string octave_exec_path = octave_env::getenv ("OCTAVE_EXEC_PATH");
 
   if (octave_exec_path.empty ())
     {
       std::string shell_path = octave_env::getenv ("PATH");
 
       if (! shell_path.empty ())
 	{
-	  Vexec_path = std::string (":");
+	  Vexec_path = std::string (SEPCHAR_STR);
 	  Vexec_path.append (shell_path);
 	}
     }
   else
     Vexec_path = std::string (octave_exec_path);
 }
 
 static void
 set_default_path (void)
 {
   Vdefault_load_path = subst_octave_home (OCTAVE_FCNFILEPATH);
 
   std::string oct_path = octave_env::getenv ("OCTAVE_PATH");
 
-  Vload_path = oct_path.empty () ? std::string (":") : oct_path;
+  Vload_path = oct_path.empty () ? std::string (SEPCHAR_STR) : oct_path;
 
   update_load_path_dir_path ();
 }
 
 static void
 set_default_info_file (void)
 {
   std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
@@ -374,17 +374,18 @@ maybe_add_default_load_path (const std::
 	retval = pathstring;
 
       if (pathstring[pathstring.length () - 1] == SEPCHAR)
 	retval.append (Vdefault_load_path);
 
       size_t pos = 0;
       do
 	{
-	  pos = retval.find ("::");
+	  pos = retval.find (std::string (SEPCHAR_STR) + 
+			     std::string (SEPCHAR_STR));
 
 	  if (pos != NPOS)
 	    retval.insert (pos+1, Vdefault_load_path);
 	}
       while (pos != NPOS);
     }
 
   return retval;
@@ -582,17 +583,18 @@ loadpath (void)
       gripe_invalid_value_specified ("LOADPATH");
       status = -1;
     }
   else if (Vload_path != s)
     {
       // I'm not sure whether this causes more problems that it
       // solves...
       //      if (! (s[0] == ':' || s[s.length () - 1] == ':'
-      //	     || s.find ("::") != NPOS))
+      //	     || s.find (std::string (SEPCHAR_STR) + 
+      //                        std::string (SEPCHAR_STR)) != NPOS))
       //	warning ("LOADPATH will ignore default load path");
 
       Vload_path = s;
 
       // By resetting the last prompt time variable, we will force
       // checks for out of date symbols even if the change to LOADPATH
       // and subsequent function calls happen between prompts.
 
@@ -692,18 +694,20 @@ built-in variable @code{EXEC_PATH}.\n\
 @defvr {Built-in Variable} LOADPATH\n\
 A colon separated list of directories in which to search for function\n\
 files.  @xref{Functions and Scripts}.  The value of @code{LOADPATH}\n\
 overrides the environment variable @code{OCTAVE_PATH}.  @xref{Installation}.\n\
 \n\
 @code{LOADPATH} is now handled in the same way as @TeX{} handles\n\
 @code{TEXINPUTS}.  Leading, trailing, or doubled colons that appear in\n\
 @code{LOADPATH} are replaced by the value of @code{DEFAULT_LOADPATH}.\n\
-The default value of @code{LOADPATH} is @code{\":\"}, which tells Octave\n\
-to search in the directories specified by @code{DEFAULT_LOADPATH}.\n\
+The default value of @code{LOADPATH} is @code{\"\n"
+SEPCHAR_STR
+"\"}, which tells Octave to search in the directories specified by\n\
+@code{DEFAULT_LOADPATH}.\n\
 \n\
 In addition, if any path element ends in @samp{//}, that directory and\n\
 all subdirectories it contains are searched recursively for function\n\
 files.  This can result in a slight delay as Octave caches the lists of\n\
 files found in the @code{LOADPATH} the first time Octave searches for a\n\
 function.  After that, searching is usually much faster because Octave\n\
 normally only needs to search its internal cache for files.\n\
 \n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -667,17 +667,19 @@ display_help_text (std::ostream& os, con
 	  << " -D \"OCTAVEHOME " << OCTAVE_PREFIX << "\""
 	  << " -D \"TARGETHOSTTYPE " << OCTAVE_CANONICAL_HOST_TYPE << "\""
 	  << " --fill-column " << cols
 	  << " --no-warn"
 	  << " --no-validate"
 	  << " --no-headers"
 	  << " --force"
 	  << " --output \"" << tmp_file_name << "\""
+#if !defined (__MINGW32__)
 	  << " > /dev/null 2>&1"
+#endif
 	  << OSSTREAM_ENDS;
 
       oprocstream filter (OSSTREAM_STR (buf));
 
       OSSTREAM_FREEZE (buf);
 
       if (filter && filter.is_open ())
 	{
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -49,25 +49,33 @@ 02110-1301, USA.
 // Number of microseconds to delay in the parent after forking.
 static int Vkluge_procbuf_delay = 0;
 
 // This class is based on the procbuf class from libg++, written by
 // Per Bothner, Copyright (C) 1993 Free Software Foundation.
 
 static octave_procbuf *octave_procbuf_list = 0;
 
+#if defined (__CYGWIN32__)
+#define W32POPEN popen
+#define W32PCLOSE pclose
+#elif defined (__MINGW32__)
+#define W32POPEN _popen
+#define W32PCLOSE _pclose
+#endif
+
 octave_procbuf *
 octave_procbuf::open (const char *command, int mode)
 {
-#if defined (__CYGWIN32__)
+#if defined (__CYGWIN32__) || defined (__MINGW32__)
 
   if (is_open ()) 
     return 0;
 
-  f = popen (command, (mode & std::ios::in) ? "r" : "w");
+  f = ::W32POPEN (command, (mode & std::ios::in) ? "r" : "w");
 
   if (! f)
     return 0;
 
   // Oops... popen doesn't return the associated pid, so fake it for now
 
   proc_pid = 1;
 
@@ -161,21 +169,23 @@ octave_procbuf::open (const char *comman
   return 0;
 
 #endif
 }
 
 octave_procbuf *
 octave_procbuf::close (void)
 {
-#if defined (__CYGWIN32__)
+
+
+#if defined (__CYGWIN32__) || defined (__MINGW32__)
 
   if (f)
     {
-      wstatus = ::pclose (f);
+      wstatus = ::W32PCLOSE (f);
       f = 0;
     }
 
   open_p = false;
 
   return this;
   
 #elif defined (HAVE_SYS_WAIT_H)
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -109,27 +109,31 @@ octave_signal_handler (void)
   for (int i = 0; i < NSIG; i++)
     {
       if (octave_signals_caught[i])
 	{
 	  octave_signals_caught[i] = false;
 
 	  switch (i)
 	    {
+#ifdef SIGCHLD
 	    case SIGCHLD:
 	      octave_child_list::reap ();
 	      break;
+#endif
 
 	    case SIGFPE:
 	      std::cerr << "warning: floating point exception -- trying to return to prompt" << std::endl;
 	      break;
 
+#ifdef SIGPIPE
 	    case SIGPIPE:
 	      std::cerr << "warning: broken pipe -- some output may be lost" << std::endl;
 	      break;
+#endif
 	    }
 	}
     }
 }
 
 static void
 my_friendly_exit (const char *sig_name, int sig_number,
 		  bool save_vars = true)
@@ -138,29 +142,36 @@ my_friendly_exit (const char *sig_name, 
 
   if (been_there_done_that)
     {
 #if defined (SIGABRT)
       octave_set_signal_handler (SIGABRT, SIG_DFL);
 #endif
 
       std::cerr << "panic: attempted clean up apparently failed -- aborting...\n";
+
+      MINGW_SIGNAL_CLEANUP ();
+
       abort ();
     }
   else
     {
       been_there_done_that = true;
 
       std::cerr << "panic: " << sig_name << " -- stopping myself...\n";
 
       if (save_vars)
 	dump_octave_core ();
 
       if (sig_number < 0)
-	exit (1);
+	{
+	  MINGW_SIGNAL_CLEANUP ();
+
+	  exit (1);
+	}
       else
 	{
 	  octave_set_signal_handler (sig_number, SIG_DFL);
 
 #if defined (HAVE_RAISE)
 	  raise (sig_number);
 #elif defined (HAVE_KILL)
 	  kill (getpid (), sig_number);
@@ -338,35 +349,31 @@ sigwinch_handler (int /* sig */)
 #endif
 
 // Handle SIGINT by restarting the parser (see octave.cc).
 //
 // This also has to work for SIGBREAK (on systems that have it), so we
 // use the value of sig, instead of just assuming that it is called
 // for SIGINT only.
 
-static RETSIGTYPE
-sigint_handler (int sig)
+static
+void user_abort(const char *sig_name, int sig_number)
 {
-  MAYBE_ACK_SIGNAL (sig);
-
-  MAYBE_REINSTALL_SIGHANDLER (sig, sigint_handler);
-
   if (! octave_initialized)
     exit (1);
 
   if (can_interrupt)
     {
       if (Vdebug_on_interrupt)
 	{
 	  if (! octave_debug_on_interrupt_state)
 	    {
 	      octave_debug_on_interrupt_state = true;
 
-	      SIGHANDLER_RETURN (0);
+	      return;
 	    }
 	  else
 	    // Clear the flag and do normal interrupt stuff.
 	    octave_debug_on_interrupt_state = false;
 	}
 
       if (octave_interrupt_immediately)
 	octave_jump_to_enclosing_context ();
@@ -381,20 +388,38 @@ sigint_handler (int sig)
 
 	  octave_signal_caught = 1;
 	  octave_interrupt_state++;
 
 	  if (interactive && octave_interrupt_state == 2)
 	    std::cerr << "Press Control-C again to abort." << std::endl;
 
 	  if (octave_interrupt_state >= 3)
-	    my_friendly_exit (sys_siglist[sig], sig, true);
+	    my_friendly_exit (sig_name, sig_number, true);
 	}
     }
 
+}
+
+static RETSIGTYPE
+sigint_handler (int sig)
+{
+  MAYBE_ACK_SIGNAL (sig);
+
+  MAYBE_REINSTALL_SIGHANDLER (sig, sigint_handler);
+
+#ifdef USE_W32_SIGINT
+  if (w32_in_main_thread ())
+    user_abort (sys_siglist[sig], sig);
+  else
+    w32_raise (sig);
+#else
+  user_abort (sys_siglist[sig], sig);
+#endif
+
   SIGHANDLER_RETURN (0);
 }
 
 #ifdef SIGPIPE
 static RETSIGTYPE
 sigpipe_handler (int /* sig */)
 {
   MAYBE_ACK_SIGNAL (SIGPIPE);
@@ -409,29 +434,99 @@ sigpipe_handler (int /* sig */)
 
   if (pipe_handler_error_count++ > 100 && octave_interrupt_state >= 0)
     octave_interrupt_state++;
 
   SIGHANDLER_RETURN (0);
 }
 #endif /* defined(SIGPIPE) */
 
+#ifdef USE_W32_SIGINT
+static BOOL CALLBACK
+w32_sigint_handler (DWORD sig)
+{
+  const char *sig_name;
+
+  switch(sig)
+    {
+      case CTRL_BREAK_EVENT:   
+	sig_name = "Ctrl-Break"; 
+	break;
+      case CTRL_C_EVENT:
+	sig_name = "Ctrl-C";
+	break;
+      case CTRL_CLOSE_EVENT:
+	sig_name = "close console";
+	break;
+      case CTRL_LOGOFF_EVENT:
+	sig_name = "logoff";
+	break;
+      case CTRL_SHUTDOWN_EVENT:
+	sig_name = "shutdown";
+	break;
+      default:
+	sig_name = "unknown console event";
+	break;
+    }
+
+  switch(sig)
+    {
+      case CTRL_BREAK_EVENT:
+      case CTRL_C_EVENT:
+	w32_raise (SIGINT);
+        break;
+
+      case CTRL_CLOSE_EVENT:
+      case CTRL_LOGOFF_EVENT:
+      case CTRL_SHUTDOWN_EVENT:
+      default:
+        // We should do the following:
+        //    clean_up_and_exit (0);
+        // We can't because we aren't running in the normal Octave thread.
+	user_abort(sig_name, sig);
+        break;
+    }
+
+  // Return TRUE if the event was handled, or FALSE if another handler 
+  // should be called.
+  // XXX FIXME XXX check that windows terminates the thread.
+  return TRUE;
+}
+#endif /* w32_sigint_handler */
+
+
 octave_interrupt_handler
 octave_catch_interrupts (void)
 {
   octave_interrupt_handler retval;
 
 #ifdef SIGINT
   retval.int_handler = octave_set_signal_handler (SIGINT, sigint_handler);
 #endif
 
 #ifdef SIGBREAK
   retval.brk_handler = octave_set_signal_handler (SIGBREAK, sigint_handler);
 #endif
 
+#ifdef USE_W32_SIGINT
+
+  // Intercept windows console control events.
+  // Note that the windows console signal handlers chain, so if 
+  // install_signal_handlers is called more than once in the same program,
+  // then first call the following to avoid duplicates:
+  //
+  //   SetConsoleCtrlHandler (w32_sigint_handler, FALSE);
+
+  if (! SetConsoleCtrlHandler (w32_sigint_handler, TRUE))
+    error ("SetConsoleCtrlHandler failed with %ld\n", GetLastError ());
+
+  w32_set_quiet_shutdown ();
+
+#endif
+
   return retval;
 }
 
 octave_interrupt_handler
 octave_ignore_interrupts (void)
 {
   octave_interrupt_handler retval;
 
@@ -587,16 +682,17 @@ install_signal_handlers (void)
 
 #ifdef SIGXCPU
   octave_set_signal_handler (SIGXCPU, generic_sig_handler);
 #endif
 
 #ifdef SIGXFSZ
   octave_set_signal_handler (SIGXFSZ, generic_sig_handler);
 #endif
+
 }
 
 static Octave_map
 make_sig_struct (void)
 {
   Octave_map m;
 
 #ifdef SIGABRT
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -70,16 +70,17 @@ 02110-1301, USA.
 #include <sys/utsname.h>
 #endif
 
 #include "cmd-edit.h"
 #include "file-ops.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "oct-env.h"
+#include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "pager.h"
 #include "sysdep.h"
@@ -99,16 +100,49 @@ BSD_init (void)
 #ifndef FP_X_DNML
 #define FP_X_DNML 0
 #endif
   fpsetmask (~(FP_X_OFL|FP_X_INV|FP_X_DZ|FP_X_DNML|FP_X_UFL|FP_X_IMP));
 #endif
 }
 #endif
 
+void
+w32_set_quiet_shutdown (void)
+{
+#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+  // Let the user close the console window or shutdown without the
+  // pesky dialog.
+  //
+  // XXX FIXME XXX -- should this be user configurable?
+  SetProcessShutdownParameters (0x280, SHUTDOWN_NORETRY);
+#endif
+}
+
+#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+void
+MINGW_signal_cleanup (void)
+{
+  w32_set_quiet_shutdown (void);
+
+  w32_raise_final ():
+}
+#endif
+
+#if defined (__MINGW32__)
+static void
+MINGW_init (void)
+{
+  // Init mutex to protect setjmp/longjmp and get main thread context
+  w32_sigint_init ();
+
+  w32_set_quiet_shutdown ();
+}
+#endif
+
 #if defined (__CYGWIN__)
 
 #include <limits.h>
 #include <sys/cygwin.h>
 
 static void
 CYGWIN_init (void)
 {
@@ -194,27 +228,35 @@ SCO_init (void)
 
 void
 sysdep_init (void)
 {
 #if defined (__386BSD__) || defined (__FreeBSD__)
   BSD_init ();
 #elif defined (__CYGWIN__)
   CYGWIN_init ();
+#elif defined (__MINGW32__)
+  MINGW_init ();
 #elif defined (NeXT)
   NeXT_init ();
 #elif defined (__EMX__)
   OS2_init ();
 #elif defined (SCO)
   SCO_init ();
 #endif
 
   octave_ieee_init ();
 }
 
+void
+sysdep_cleanup (void)
+{
+  MINGW_SIGNAL_CLEANUP ();
+}
+
 // Set terminal in raw mode.  From less-177.
 //
 // Change terminal to "raw mode", or restore to "normal" mode.
 // "Raw mode" means 
 //	1. An outstanding read will complete on receipt of a single keystroke.
 //	2. Input is not echoed.  
 //	3. On output, \n is mapped to \r\n.
 //	4. \t is NOT expanded into spaces.
diff --git a/src/sysdep.h b/src/sysdep.h
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -26,19 +26,38 @@ 02110-1301, USA.
 
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-sysdep.h"
 
 extern void sysdep_init (void);
 
+extern void sysdep_cleanup (void);
+
 extern void raw_mode (bool, bool wait = true);
 
 extern int octave_kbhit (bool wait = true);
 
+extern void w32_set_quiet_shutdown (void);
+
+#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+extern void MINGW_signal_cleanup (void);
+#define USE_W32_SIGINT 1
+#define MINGW_SIGNAL_CLEANUP() MINGW_signal_cleanup ()
+#else
+#define MINGW_SIGNAL_CLEANUP() do { } while (0)
+#endif
+
+#if defined (__MINGW32__)
+#include <process.h>
+#define waitpid(a, b, c) _cwait (b, a, c)
+// action argument is ignored for _cwait, so arbitrary definition
+#define WNOHANG 0
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -209,16 +209,18 @@ main_loop (void)
 
 // Fix up things before exiting.
 
 void
 clean_up_and_exit (int retval)
 {
   do_octave_atexit ();
 
+  sysdep_cleanup ();
+
   exit (retval == EOF ? 0 : retval);
 }
 
 DEFCMD (casesen, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} casesen arg\n\
 Provided for compatibility with Matlab, but does nothing.\n\
 @end deffn")
