# HG changeset patch
# User jwe
# Date 945296932 0
#      Wed Dec 15 22:28:52 1999 +0000
# Node ID 10f21f7ccc7f458531d395a21fb2913783c502da
# Parent  6735e4c759a2bc8431195bcb897689bd42335654
[project @ 1999-12-15 22:28:26 by jwe]

diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -37,17 +37,17 @@
 ## @end example
 ## Command examples are interactively run for users to observe the use
 ## of OCST functions.
 ## @end deftypefn
 
 ## Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 ## Written by David Clem August 15, 1994
 
-function DEMOcontrol()
+function DEMOcontrol ()
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/abcddims.m b/scripts/control/abcddims.m
--- a/scripts/control/abcddims.m
+++ b/scripts/control/abcddims.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
 ## 
 ## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix, 
 ## both dimensions are set to 0 in @var{y}.  
 ## @var{my} and @var{ny} are the row and column dimensions of the result.
 ## @end deftypefn
 
-function [y,my,ny] = abcddims (x)
+function [y, my, ny] = abcddims (x)
 ## Written by A. S. Hodel (scotte@eng.auburn.edu) Feb 1997
 
   y = x;
   if(isempty(y))
     y = [];
   endif
   [my,ny] = size(y);
 endfunction
diff --git a/scripts/control/analdemo.m b/scripts/control/analdemo.m
--- a/scripts/control/analdemo.m
+++ b/scripts/control/analdemo.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { } analdemo ( ) 
 ##  Octave Controls toolbox demo: State Space analysis demo
 ## @end deftypefn
 
-function analdemo()
+function analdemo ()
 ## Written by David Clem August 15, 1994
 ## Updated by John Ingram December 1996
   
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
diff --git a/scripts/control/axis2dlim.m b/scripts/control/axis2dlim.m
--- a/scripts/control/axis2dlim.m
+++ b/scripts/control/axis2dlim.m
@@ -24,17 +24,17 @@
 ## 
 ## @strong{Inputs}
 ##    @var{axdata} nx2 matrix of data [x,y]
 ## 
 ## @strong{Outputs}
 ##    @var{axvec} vector of axis limits appropriate for call to axis() function
 ## @end deftypefn
 
-function axvec = axis2dlim(axdata)
+function axvec = axis2dlim (axdata)
 
   if(isempty(axdata))
     axdata = 0;
   endif
 
   ## compute axis limits
   minv = min(axdata);
   maxv = max(axdata);
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} bddemo ( inputs ) 
 ##  Octave Controls toolbox demo: Block Diagram Manipulations demo
 ## @end deftypefn
  
-function bddemo()
+function bddemo ()
 
   ## Written by David Clem August 15, 1994
   ## Modified by A S Hodel Summer-Fall 1996
 
   sav_page = page_screen_output;
   page_screen_output = 1;
 
   while (1)
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -85,17 +85,17 @@
 ## being printed to the screen (@code{ans = []}).
 ## 
 ## @item If the requested plot is for an MIMO system, mag is set to
 ##  @math{||G(jw)||} or @math{||G(@code{exp}(jwT))||}
 ## and phase information is not computed.
 ## @end enumerate
 ## @end deftypefn 
 
-function [mag_r,phase_r,w_r] = bode(sys,w,outputs,inputs,plot_style)
+function [mag_r, phase_r, w_r] = bode (sys, w, outputs, inputs, plot_style)
 
   ## Written by John Ingram  July 10th, 1996
   ## Based on previous code
   ## By R. Bruce Tenison, July 13, 1994
   ## Modified by David Clem November 13, 1994
   ## again by A. S. Hodel July 1995 (smart plot range, etc.)
   ## Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
 
diff --git a/scripts/control/bode_bounds.m b/scripts/control/bode_bounds.m
--- a/scripts/control/bode_bounds.m
+++ b/scripts/control/bode_bounds.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}@{, @var{tsam} @})
 ## Get default range of frequencies based on cutoff frequencies of system
 ## poles and zeros.
 ## Frequency range is the interval [10^wmin,10^wmax]
 ## 
 ## Used internally in freqresp (@code{bode}, @code{nyquist})
 ## @end deftypefn
  
-function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,tsam)
+function [wmin, wmax] = bode_bounds (zer, pol, DIGITAL, tsam)
 
   ## make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
   ## check for natural frequencies away from omega = 0
   if (DIGITAL)
     ## The 2nd conditions prevents log(0) in the next log command
diff --git a/scripts/control/bodquist.m b/scripts/control/bodquist.m
--- a/scripts/control/bodquist.m
+++ b/scripts/control/bodquist.m
@@ -45,17 +45,17 @@
 ##
 ## Both bode and nyquist share the same introduction, so the common parts are 
 ## in bodquist.  It contains the part that finds the number of arguments, 
 ## determines whether or not the system is SISO, and computes the frequency 
 ## response.  Only the way the response is plotted is different between the 
 ## two functions.
 ## @end deftypefn
  
-function [f,w] = bodquist(sys,w,outputs,inputs,rname)
+function [f, w] = bodquist (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
     usage("[f,w] = bodquist(sys,w,outputs,inputs,rname)");
   endif
 
   ## check each argument to see if it's in the correct form
   if (!is_struct(sys))
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[@var{sys}] =} buildssic(@var{Clst}, @var{Ulst}, @var{Olst}, @var{Ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
+## @deftypefn {Function File } {@var{sys} =} buildssic(@var{Clst}, @var{Ulst}, @var{Olst}, @var{Ilst}, @var{s1}, @var{s2}, @var{s3}, @var{s4}, @var{s5}, @var{s6}, @var{s7}, @var{s8})
 ## 
 ## Contributed by Kai Mueller.
 ## 
 ##  Form an arbitrary complex (open or closed loop) system in
 ##  state-space form from several systems. "@code{buildssic}" can
 ##  easily (despite it's cryptic syntax) integrate transfer functions
 ##  from a complex block diagram into a single system with one call.
 ##  This function is especially useful for building open loop
@@ -81,17 +81,17 @@
 ##      |  +-------------------------|---> e
 ##      |                            |
 ##      +----------------------------+
 ## @end group
 ## @end example
 ## 
 ## The closed loop system GW can be optained by
 ## @example
-## GW = buildssic([1 2; 2 -1], [2], [1 2 3], [2], G, K);
+## GW = buildssic([1 2; 2 -1], 2, [1 2 3], 2, G, K);
 ## @end example
 ## @table @var
 ## @item Clst
 ## (1. row) connect input 1 (G) with output 2 (K).
 ## (2. row) connect input 2 (K) with neg. output 1 (G).
 ## @item Ulst
 ## append input of (2) K to the number of outputs.
 ## @item Olst
@@ -115,28 +115,29 @@
 ##     |                v
 ##    u                  y
 ## @end group
 ## @end example
 ## 
 ## The closed loop system GW from [z; u]' to [v1; v2; y]' can be
 ## obtained by (all SISO systems):
 ## @example
-## GW = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],G,W1,W2,One);
+## GW = buildssic([1, 4; 2, 4; 3, 1], 3, [2, 3, 5],
+##                [3, 4], G, W1, W2, One);
 ## @end example
 ## where "One" is a unity gain (auxillary) function with order 0.
 ## (e.g. @code{One = ugain(1);})
 ## @end deftypefn
  
-function [sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)
+function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
   ## Written by Kai Mueller April 1998
 
   if((nargin < 5) || (nargin > 12))
-    usage("[sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
+    usage("sys = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
   endif
   if (nargin >= 5)
     if (!is_struct(s1))
       error("---> s1 must be a structed system.");
     endif
     s1 = sysupdate(s1, "ss");
     [n, nz, m, p] = sysdimensions(s1);
     if (!n && !nz)
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -19,17 +19,17 @@
 ## usage retval = com2str(zz{,flg})
 ##  
 ## convert complex number to a string
 ## zz: complex number
 ## flg: format flag
 ##      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
 ##      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 
-function retval = com2str(zz,flg)
+function retval = com2str (zz, flg)
 
   if (nargin < 1 | nargin > 2)
     usage("com2str(zz{,flg})");
   endif
   if(nargin == 1)
     flg = 0;
   endif
  
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-function DEMOcontrol()
+function DEMOcontrol ()
 ## Controls toolbox demo.
 ## Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 ##  
 ## Written by David Clem August 15, 1994
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
diff --git a/scripts/control/ctrb.m b/scripts/control/ctrb.m
--- a/scripts/control/ctrb.m
+++ b/scripts/control/ctrb.m
@@ -27,17 +27,17 @@
 ## 
 ##  of a system data structure or the pair (@var{A}, @var{B}).
 ## 
 ## @strong{Note} @code{ctrb} forms the controllability matrix.
 ##        The numerical properties of @code{is_controllable}
 ##        are much better for controllability tests.
 ## @end deftypefn
 
-function Qs = ctrb(sys, b)
+function Qs = ctrb (sys, b)
 
   ## Written by Kai P. Mueller November 4, 1997
   ## based on is_controllable.m of Scottedward Hodel
   ## modified by
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -51,17 +51,17 @@
 ## @end table
 ## @end table
 ## @strong{Outputs} @var{csys} continuous time system (same dimensions and
 ## signal names as in @var{sys}).
 ## @end deftypefn
 ## 
 
  
-function csys = d2c(sys,opt)
+function csys = d2c (sys, opt)
 
   ## Written by R. Bruce Tenison August 23, 1994
   ## Updated by John Ingram for system data structure  August 1996
   ## SYS_INTERNAL accesses members of system data structure
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
   elseif (!is_struct(sys))
diff --git a/scripts/control/damp.m b/scripts/control/damp.m
--- a/scripts/control/damp.m
+++ b/scripts/control/damp.m
@@ -23,17 +23,17 @@
 ##       system @var{p}, respectively.
 ##       If @var{p} is a system, @var{tsam} must not be specified.
 ##       If @var{p} is a matrix and @var{tsam} is specified, eigenvalues
 ##       of @var{p} are assumed to be in @var{z}-domain.
 ## 
 ## See also: @code{eig}
 ## @end deftypefn
 
-function damp(p, tsam)
+function damp (p, tsam)
 
   ## Written by Kai P. Mueller September 29, 1997.
   ## Update
 
   ## assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
     usage("damp(p,[ tsamp])")
diff --git a/scripts/control/dcgain.m b/scripts/control/dcgain.m
--- a/scripts/control/dcgain.m
+++ b/scripts/control/dcgain.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{gm} =} dcgain(@var{sys}@{, tol@})
 ##       Returns dc-gain matrix. If dc-gain is infinite
 ##       an empty matrix is returned.
 ##       The argument @var{tol} is an optional tolerance for the condition
 ##       number of @var{A}-Matrix in @var{sys} (default @var{tol} = 1.0e-10)
 ## @end deftypefn
 
-function gm = dcgain(sys, tol)
+function gm = dcgain (sys, tol)
 ## Written by Kai P Mueller (mueller@ifr.ing.tu-bs.de) October 1, 1997
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
     usage("[gm, ok] = dcgain(sys[, tol])");
   endif
   if(!is_struct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { } dgkfdemo ( ) 
 ## Octave Controls toolbox demo: H2/Hinfinity options demos
 ##@end deftypefn
  
-function dgkfdemo()
+function dgkfdemo ()
 ## Written by A. S. Hodel June 1995
  
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
     menuopt=0;
     while(menuopt > 10 || menuopt < 1)
diff --git a/scripts/control/dgram.m b/scripts/control/dgram.m
--- a/scripts/control/dgram.m
+++ b/scripts/control/dgram.m
@@ -34,15 +34,15 @@
 ## @strong{Outputs}
 ## @var{m} (@var{n} by @var{n}) satisfies
 ## @example
 ##  a m a' - m + b*b' = 0 
 ## @end example
 ## 
 ## @end deftypefn
 
-function m = dgram(a,b)
+function m = dgram (a, b)
 
   ## Written by A. S. Hodel July 1995
 
   ## let dlyap do the error checking...
   m = dlyap(a,b*b');
 endfunction
diff --git a/scripts/control/dlqg.m b/scripts/control/dlqg.m
--- a/scripts/control/dlqg.m
+++ b/scripts/control/dlqg.m
@@ -38,17 +38,17 @@
 ## inputs:
 ##  A,B,C,G, or Sys: state space representation of system.  
 ##  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
 ##      (as above)
 ##  Q, R: state, control weighting matrices for dlqr call respectively.  
 ##
 ## See also: lqg, dlqe, dlqr
 
-function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Sigw, Sigv,Q,R)
+function [K, Q, P, Ee, Er] = dlqg (A, B, C, G, Sigw, Sigv, Q, R)
 
   ## Written by A. S. Hodel August 1995
 
   warning("dlqg: obsolete. use lqg instead (system data structure format)");
 
   if (nargin == 5)
     ## system data structure format
 
diff --git a/scripts/control/dmr2d.m b/scripts/control/dmr2d.m
--- a/scripts/control/dmr2d.m
+++ b/scripts/control/dmr2d.m
@@ -65,17 +65,17 @@
 ## indices of "formerly fast" states specified by @var{idx} and @var{sprefix};
 ## these states are updated to the new (slower) sampling interval @var{Ts2}.
 ## @end table
 ## 
 ## @strong{WARNING} Not thoroughly tested yet; especially when @var{cuflg} == 0.
 ## 
 ## @end deftypefn
 
-function [dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2,cuflg)
+function [dsys, fidx] = dmr2d (sys, idx, sprefix, Ts2, cuflg)
 
   ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
   ## parse input arguments
   if(nargin != 4 | nargout > 2)
     usage("[dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})");
 
   elseif (!is_struct(sys))
diff --git a/scripts/control/dre.m b/scripts/control/dre.m
--- a/scripts/control/dre.m
+++ b/scripts/control/dre.m
@@ -35,17 +35,17 @@
 ##   max number of refinement iterations (default=10)
 ## outputs:
 ##   tvals: time values at which P(t) is computed
 ##   Plist: list values of P(t); nth(Plist,ii) is P(tvals(ii)).
 ##
 ##   tvals is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
 ##     for ii=2:length(tvals)
 
-function [tvals,Plist] = dre(sys,Q,R,Qf,t0,tf,Ptol,maxits)
+function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
     usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
   elseif(!is_struct(sys))
     error("sys must be a system data structure")
   elseif(is_digital(sys))
     error("sys must be a continuous time system")
   elseif(!is_matrix(Q) | !is_matrix(R) | !is_matrix(Qf))
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -62,17 +62,17 @@
 ## Sampling interval: 0.342
 ## transfer function form:
 ## 1*z^3 - 1*z^2 + 2*z^1 + 4
 ## -------------------------
 ## 1*z^3 + 0*z^2 + 0*z^1 + 0
 ## @end example
 ## @end deftypefn
  
-function sys = fir2sys (num,tsam,inname,outname)
+function sys = fir2sys (num, tsam, inname, outname)
 
   ## Written by R. Bruce Tenison  July 29, 1994
   ## Name changed to TF2SYS July 1995
   ## updated for new system data structure format July 1996
   ## adapted from tf2sys july 1996
 
   ## Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { } frdemo ( ) 
 ## Octave Controls toolbox demo: Frequency Response demo
 ## @end deftypefn
 
-function frdemo()
+function frdemo ()
 
   ## Written by David Clem August 15, 1994 
 
   ## a s hodel: updated to match new order of ss2zp outputs
   ## J Ingram:  updated for system data structure format August 1996
 
   disp("")
   clc
diff --git a/scripts/control/freqchkw.m b/scripts/control/freqchkw.m
--- a/scripts/control/freqchkw.m
+++ b/scripts/control/freqchkw.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} freqchkw ( @var{w} ) 
 ## Used by @code{freqresp} to check that input frequency vector @var{w} is legal.
 ## Returns boolean value.
 ## @end deftypefn
 
-function USEW = freqchkw(w)
+function USEW = freqchkw (w)
 
   ## A S Hodel July 1996
 
   if(isempty(w))
     USEW = 0;
   elseif(!is_vector(w))
     error(["w (",num2str(rows(w)),"x",num2str(columns(w)), ...
       "): must be [], a vector or a scalar"]);
diff --git a/scripts/control/freqresp.m b/scripts/control/freqresp.m
--- a/scripts/control/freqresp.m
+++ b/scripts/control/freqresp.m
@@ -34,17 +34,17 @@
 ## @table @var
 ## @item @var{out} 
 ## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for MIMO)
 ## @item w 
 ## vector of corresponding frequencies 
 ## @end table
 ## @end deftypefn
 
-function [ff,w] = freqresp(sys,USEW,w);
+function [ff, w] = freqresp (sys, USEW, w);
 
   ## Written by: R. Bruce Tenison July 11, 1994
   ## SYS_INTERNAL accesses members of system data structure
 
   save_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   ## Check Args
diff --git a/scripts/control/gram.m b/scripts/control/gram.m
--- a/scripts/control/gram.m
+++ b/scripts/control/gram.m
@@ -19,15 +19,15 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{m} =} gram (@var{a}, @var{b})
 ##  Return controllability grammian @var{m} of the continuous time system
 ## @math{ dx/dt = a x + b u}.  
 ## 
 ## @var{m} satisfies @math{ a m + m a' + b b' = 0 }.
 ## @end deftypefn
 
-function m = gram(a,b)
+function m = gram (a, b)
 
   ## Written by A. S. Hodel 
 
   ## let lyap do the error checking...
   m = lyap(a,b*b');
 endfunction
diff --git a/scripts/control/h2norm.m b/scripts/control/h2norm.m
--- a/scripts/control/h2norm.m
+++ b/scripts/control/h2norm.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } {@var{retval} =} h2norm(@var{sys})
 ## Computes the H2 norm of a system data structure (continuous time only)
 ## 
 ## Reference:
 ##  Doyle, Glover, Khargonekar, Francis, ``State Space Solutions to Standard
 ##  H2 and Hinf Control Problems", IEEE TAC August 1989
 ## @end deftypefn
 
-function h2gain = h2norm(sys)
+function h2gain = h2norm (sys)
 
   ## A. S. Hodel Aug 1995
   ## updated for system data structure by John Ingram November 1996
 
   if((nargin != 1))
     usage("h2gain = h2norm(sys)");
   elseif(!is_struct(sys))
     error("Sys must be in system data structure");
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -53,17 +53,17 @@
 ## state estimator (packed)
 ## @item    Pc
 ## ARE solution matrix for regulator subproblem
 ## @item    Pf
 ## ARE solution matrix for filter subproblem
 ## @end table
 ## @end deftypefn
  
-function [K,gain, Kc, Kf, Pc,  Pf] = h2syn(Asys,nu,ny,tol)
+function [K, gain, Kc, Kf, Pc, Pf] = h2syn (Asys, nu, ny, tol)
 
   ## Updated for System structure December 1996 by John Ingram
 
   if ((nargin < 3) | (nargin > 4))
     usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
   elseif(nargin == 4)
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -30,17 +30,17 @@
 ## final gamma value
 ## @end table
 ## @strong{Outputs}
 ## controller K (system data structure)
 ## 
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn
   
-function K = hinf_ctr(dgs,F,H,Z,g)
+function K = hinf_ctr (dgs, F, H, Z, g)
 
   ## A. S. Hodel August 1995
   ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
   ## problem using unitary transformations Q (on w and z)
   ## and non-singular transformations R (on u and y).
 
   nw = dgs.nw;
   nu = dgs.nu;
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -58,17 +58,17 @@
 ##  Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
 ##     H2 and Hinf control problems", IEEE TAC August 1989
 ##  Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
 ##     Int. J. Control, vol 54, #5, 1991
 ##  Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
 ##  $Revision: 1.9 $
 ## @end deftypefn
  
-function [g, gmin, gmax] = hinfnorm(sys,tol,gmin,gmax,ptol)
+function [g, gmin, gmax] = hinfnorm (sys, tol, gmin, gmax, ptol)
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!is_struct(sys))
     error("Sys must be a system data structure");
   endif
 
   ## set defaults where applicable
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -70,17 +70,17 @@
 ## 
 ## @item Keith Glover and John C. Doyle, "State-space formulae for all
 ##      stabilizing controllers that satisfy and h-infinity-norm bound
 ##      and relations to risk sensitivity,"
 ##      Systems & Control Letters 11, Oct. 1988, pp 167-172.
 ## @end enumerate
 ## @end deftypefn
  
-function [K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)
+function [K, g, GW, Xinf, Yinf] = hinfsyn (Asys, nu, ny, gmin, gmax, gtol, ptol, tol)
 
   ## A. S. Hodel August 1995
   ## Updated for Packed system structures December 1996 by John Ingram
   ## 
   ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
   ## problem using unitary transformations Q (on w and z)
   ## and non-singular transformations R (on u and y).
 
diff --git a/scripts/control/hinfsyn_chk.m b/scripts/control/hinfsyn_chk.m
--- a/scripts/control/hinfsyn_chk.m
+++ b/scripts/control/hinfsyn_chk.m
@@ -40,17 +40,17 @@
 ## @item Pc
 ##  solution of "regulator" H-inf ARE
 ## @item Pf
 ##  solution of "filter" H-inf ARE
 ## @end table
 ## Do not attempt to use this at home; no argument checking performed.
 ## @end deftypefn 
 
-function [retval,Pc,Pf] = hinfsyn_chk(A,B1,B2,C1,C2,D12,D21,g,ptol)
+function [retval, Pc, Pf] = hinfsyn_chk (A, B1, B2, C1, C2, D12, D21, g, ptol)
 
   ## A. S. Hodel August 1995
 
   Pc = Pf = [];
 
   ## Construct the two Hamiltonians
   g2 = 1/(g*g);
   Hc = [ A ,  g2*B1*B1' - B2*B2'; -C1'*C1 , -A'];
diff --git a/scripts/control/hinfsyn_ric.m b/scripts/control/hinfsyn_ric.m
--- a/scripts/control/hinfsyn_ric.m
+++ b/scripts/control/hinfsyn_ric.m
@@ -27,17 +27,17 @@
 ##    0: successful
 ##    1: Xinf has imaginary eigenvalues
 ##    2: Hx not Hamiltonian
 ##    3: Xinf has inf. eigenvalues (numerical overflow)
 ##    4: Xinf not symmetric
 ##    5: Xinf not positive definite
 ##    6: R is singular
 
-function [Xinf,x_ha_err] = hinfsyn_ric(A,BB,C1,d1dot,R,ptol)
+function [Xinf, x_ha_err] = hinfsyn_ric (A, BB, C1, d1dot, R, ptol)
 
   x_ha_err = 0;        # assume success
   Xinf = [];		     # default return value
   n = is_square(A);
   nw = is_square(R);
   if(rank(R) != nw)    x_ha_err = 6;
   else                 # build hamiltonian Ha for X_inf
     xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -39,17 +39,17 @@
 ##  computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## @end deftypefn
  
 ## See also:  step, stepimp
 
-function [y, t] = impulse(sys, inp, tstop, n)
+function [y, t] = impulse (sys, inp, tstop, n)
 
 ## Written by Kai P. Mueller October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/is_abcd.m b/scripts/control/is_abcd.m
--- a/scripts/control/is_abcd.m
+++ b/scripts/control/is_abcd.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } { @var{retval} =} is_abcd( @var{a}@{, @var{b}, @var{c}, @var{d}@})
 ##  Returns @var{retval} = 1 if the dimensions of @var{a}, @var{b}, @var{c}, @var{d}
 ##  are compatible, otherwise @var{retval} = 0 with an appropriate diagnostic
 ##  message printed to the screen.  The matrices b, c, or d may be omitted.
 ## @end deftypefn
 
 ## See also: abcddim
 
-function retval = is_abcd(a, b, c, d)
+function retval = is_abcd (a, b, c, d)
 
   ## Written by Kai P. Mueller November 4, 1997
   ## based on is_controllable.m of Scottedward Hodel
   ## modified by
 
   retval = 0;
   switch (nargin)
     case (1)
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -53,17 +53,17 @@
 ## @code{is_observable}, @code{is_stabilizable}, @code{is_detectable}, 
 ## 	@code{krylov}, @code{krylovb}
 ## 
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 ##     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
-function [retval,U] = is_controllable (a, b, tol)
+function [retval, U] = is_controllable (a, b, tol)
 
   ## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
   ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
   ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
     usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -28,17 +28,17 @@
 ## computational method.
 ## 
 ##  Default: tol = 10*norm(a,'fro')*eps 
 ## 
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
-function [retval,U] = is_detectable (a,c,tol)
+function [retval, U] = is_detectable (a, c, tol)
 
   ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
   ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
   if( nargin < 1) 
     usage("[retval,U] = is_detectable(a , c {, tol})");
   elseif(is_struct(a))
     ## system form
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -89,17 +89,17 @@
 ##  Doyle, Glover, Khargonekar, Francis, "State Space Solutions
 ##      to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
 ## @item [2]
 ##  Maciejowksi, J.M.: "Multivariable feedback design,"
 ## @end table
 ## 
 ## @end deftypefn
  
-function [retval,dgkf_struct] = is_dgkf(Asys,nu,ny,tol)
+function [retval, dgkf_struct] = is_dgkf (Asys, nu, ny, tol)
 
   ## Written by A. S. Hodel
   ## Updated by John Ingram July 1996 to accept structured systems
 
   ## Revised by Kai P Mueller April 1998 to solve the general H_infinity
   ## problem using unitary transformations Q (on w and z)
   ## and non-singular transformations R (on u and y) such
   ## that the Dzu and Dyw matrices of the transformed plant
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -27,17 +27,17 @@
 ##        : 2 silent operation
 ##  outputs:
 ##    DIGITAL:  0: system is purely continuous
 ##           :  1: system is purely discrete
 ##           : -1: system is mixed continuous and discrete
 ## Exits with an error of sys is a mixed (continuous and discrete) system
 ## @end deftypefn
 
-function DIGITAL = is_digital(sys,eflg)
+function DIGITAL = is_digital (sys, eflg)
 
   ## a s hodel July 1996
 
   switch(nargin)
   case(1),  eflg = 0;
   case(2),  
     if( isempty(find(eflg == [0, 1, 2])) )
       error("Illegal value of eflg=%d (%e)",eflg,eflg);
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -27,17 +27,17 @@
 ##  observable, 0 if not.
 ## 
 ## @strong{See} @code{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
-function [retval,U] = is_observable (a,c,tol)
+function [retval, U] = is_observable (a, c, tol)
 
   ## Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
   ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
   if( nargin < 1) 
     usage("[retval,U] = is_observable(a , c {, tol})");
   elseif(is_struct(a))
     ## system form
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -17,14 +17,14 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_sample (@var{Ts}) 
 ##  return true if @var{Ts} is a legal sampling time
 ##  (real,scalar, > 0)
 ## @end deftypefn
  
-function out = is_sample(Ts)
+function out = is_sample (Ts)
 ## A. S. Hodel July 1995
 
 out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/is_signal_list.m b/scripts/control/is_signal_list.m
--- a/scripts/control/is_signal_list.m
+++ b/scripts/control/is_signal_list.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {@var{flg} =} is_signal_list (@var{mylist})
 ## Returns true if mylist is a list of individual strings (legal for input
 ## to @var{syssetsignals}).
 ## @end deftypefn
 
-function flg = is_signal_list(mylist)
+function flg = is_signal_list (mylist)
 flg = is_list(mylist);
 if(flg)
   for ii=1:length(mylist)
     if(!(isstr(nth(mylist,ii)) & rows(nth(mylist,ii)) ==1) )
       flg = 0;
     endif
   endfor
 endif
diff --git a/scripts/control/is_siso.m b/scripts/control/is_siso.m
--- a/scripts/control/is_siso.m
+++ b/scripts/control/is_siso.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{retval} =} is_siso (@var{sys}) 
 ## return nonzero if the system data structure 
 ## @var{sys} is single-input, single-output.
 ## @end deftypefn
  
-function  SISO = is_siso(sys)
+function  SISO = is_siso (sys)
 ## function SISO = is_siso(sys)
 ## return nonzero if the system sys is single-input, single-output.
 
 ## a s hodel July 1996, 1998
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
   elseif( !is_struct(sys))
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -36,17 +36,17 @@
 ##   span ([b,a*b,...,a^   b]).
 ## @end example
 ## tol is a roundoff paramter, set to 200*eps if omitted.
 ## @end deftypefn
 
 ## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 ##     is_observable, is_stabilizable, is_detectable
 
-function [retval,U] = is_stabilizable (a, b, tol)
+function [retval, U] = is_stabilizable (a, b, tol)
 
   ## Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
   ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
   ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
   if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
   elseif(is_struct(a))
     ## sustem passed.
diff --git a/scripts/control/jet707.m b/scripts/control/jet707.m
--- a/scripts/control/jet707.m
+++ b/scripts/control/jet707.m
@@ -24,17 +24,17 @@
 ##  System outputs:  (1) airspeed and (2) pitch angle
 ##  Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
 ## 
 ##  see also: ord2
 ## 
 ## Contributed by Kai Mueller
 ## @end deftypefn
  
-function outsys = jet707()
+function outsys = jet707 ()
 
   ## Written by Kai P. Mueller September 28, 1997
   ## Updates
 
   if (nargin != 0)
     usage("outsys = jet707()")
   endif
   if (nargin > 1)
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -56,17 +56,17 @@
 ## estimator poles
 ## @item    Es
 ## controller poles
 ## @end table
 ## @end deftypefn
 
 ## See also:  h2syn, lqe, lqr
 
-function [K,Q1,P1,Ee,Er] = lqg(sys,Sigw,Sigv,Q,R,input_list)
+function [K, Q1, P1, Ee, Er] = lqg (sys, Sigw, Sigv, Q, R, input_list)
 
   ## Written by A. S. Hodel August 1995; revised for new system format
   ## August 1996
 
   if ( (nargin < 5) | (nargin > 6))
     usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
 
   elseif(!is_struct(sys) )
diff --git a/scripts/control/lsim.m b/scripts/control/lsim.m
--- a/scripts/control/lsim.m
+++ b/scripts/control/lsim.m
@@ -29,17 +29,17 @@
 ## on the system, the x0 vector should be added to the argument list.
 ## 
 ## When the lsim function is invoked with output parameters:
 ## [y,x] = lsim(sys,u,t,[x0])
 ## a plot is not displayed, however, the data is returned in y = system output
 ## and x = system states.
 ## @end deftypefn
  
-function [y,x] = lsim(sys,u,t,x0)
+function [y, x] = lsim (sys, u, t, x0)
 
   ## Written by David Clem, A. S. Hodel July 1995
   ## modified by John Ingram for system format August 1996
 
   if((nargin < 3)||(nargin > 4))
     usage("[y,x] = lsim(sys,u,t[,x0])");
   endif
 
diff --git a/scripts/control/ltifr.m b/scripts/control/ltifr.m
--- a/scripts/control/ltifr.m
+++ b/scripts/control/ltifr.m
@@ -33,17 +33,17 @@
 ## @var{out}
 ## @example
 ##                            -1
 ##             G(s) = (jw I-A) B
 ## @end example
 ## for complex frequencies @math{s = jw}.
 ## @end deftypefn
 
-function out = ltifr(a,b,w)
+function out = ltifr (a, b, w)
 
   ## R. B. Tenison, D. Clem, A. S. Hodel, July 1995
   ## updated by John Ingram August 1996 for system format
   
   if ((nargin < 2) || (nargin > 3))
     error("incorrect number of input arguments");
   endif
 
diff --git a/scripts/control/minfo.m b/scripts/control/minfo.m
--- a/scripts/control/minfo.m
+++ b/scripts/control/minfo.m
@@ -24,17 +24,17 @@
 ##    Returns:
 ##      systype can be one of:
 ##            varying, system, constant, and empty
 ##      nout is the number of outputs of the system
 ##      nin is the number of inputs of the system
 ##      ncstates is the number of continuous states of the system
 ##	 ndstates is the number of discrete states of the system
 
-function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)
+function [systype, nout, nin, ncstates, ndstates] = minfo (inmat)
 
   ## Written by R. Bruce Tenison July 29, 1994
   ## Modified by David Clem November 13, 1994
   ## Modified by A. S. Hodel July 1995
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
     
   if (nargin ~= 1 )
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } { outputs =} moddemo ( inputs ) 
 ## @format
 ##  Octave Controls toolbox demo: Model Manipulations demo
 ##  Written by David Clem August 15, 1994
 ## 
 ## @end format
 ## @end deftypefn
  
-function moddemo()
+function moddemo ()
 ## Written by David Clem August 15, 1994
 ## a s hodel: updated to reflect updated output order in ss2zp
 
   while (1)
     clc
     disp('Octave Model Manipulations Demo')
     disp('=======================================')
     disp('  1)  Perform continuous to discrete time conversion (c2d)')
diff --git a/scripts/control/nichols.m b/scripts/control/nichols.m
--- a/scripts/control/nichols.m
+++ b/scripts/control/nichols.m
@@ -45,17 +45,17 @@
 ##    w: the vector of frequency values used
 ## If no output arguments are given, nichols plots the results to the screen.
 ## Descriptive labels are automatically placed.  See xlabel, ylable, title,
 ## and replot.
 ##
 ## Note: if the requested plot is for an MIMO system, mag is set to
 ## ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
 
-function [mag,phase,w] = nichols(sys,w,outputs,inputs)
+function [mag, phase, w] = nichols (sys, w, outputs, inputs)
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 4)
     usage("[mag,phase,w] = nichols(sys[,w,outputs,inputs])");
   endif
   if(nargin < 2)
     w = [];
   endif
diff --git a/scripts/control/nyquist.m b/scripts/control/nyquist.m
--- a/scripts/control/nyquist.m
+++ b/scripts/control/nyquist.m
@@ -79,17 +79,17 @@
 ##  Descriptive labels are automatically placed.
 ## 
 ##  Note: if the requested plot is for an MIMO system, a warning message is
 ##  presented; the returned information is of the magnitude 
 ##  ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
 ## 
 ## @end deftypefn
  
-function [realp,imagp,w] = nyquist(sys,w,outputs,inputs,atol)
+function [realp, imagp, w] = nyquist (sys, w, outputs, inputs, atol)
    
   ## By R. Bruce Tenison, July 13, 1994
   ## A. S. Hodel July 1995 (adaptive frequency spacing, 
   ##     remove acura parameter, etc.)
   ## Revised by John Ingram July 1996 for system format
 
   ## Both bode and nyquist share the same introduction, so the common
   ## parts are in a file called bodquist.m.  It contains the part that
diff --git a/scripts/control/obsv.m b/scripts/control/obsv.m
--- a/scripts/control/obsv.m
+++ b/scripts/control/obsv.m
@@ -31,17 +31,17 @@
 ## of a system data structure or the pair (A, C).
 ## 
 ## Note: @code{obsv()} forms the observability matrix.
 ## 
 ##        The numerical properties of is_observable()
 ##        are much better for observability tests.
 ## @end deftypefn
 
-function Qb = obsv(sys, c)
+function Qb = obsv (sys, c)
 
   ## Written by Kai P. Mueller November 4, 1997
   ## modified by
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
diff --git a/scripts/control/ord2.m b/scripts/control/ord2.m
--- a/scripts/control/ord2.m
+++ b/scripts/control/ord2.m
@@ -37,17 +37,17 @@
 ##     | \   w       0 /  \ 0 /                 |
 ##     \                                        /
 ## @end example
 ## @strong{See also} @code{jet707} (MIMO example, Boeing 707-321 aircraft model)
 ## @end deftypefn
 
 ## See also: jet707 (MIMO example, Boeing 707-321 aircraft model)
 
-function outsys = ord2(nfreq, damp, gain)
+function outsys = ord2 (nfreq, damp, gain)
 
   ## Written by Kai P. Mueller September 28, 1997
   ## Updates
 
   if(nargin != 2 & nargin != 3)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargout > 1)
diff --git a/scripts/control/outlist.m b/scripts/control/outlist.m
--- a/scripts/control/outlist.m
+++ b/scripts/control/outlist.m
@@ -37,17 +37,17 @@
 ## default: @code{1:rows(lmat)}
 ## @end table
 ## 
 ## @strong{Outputs}
 ##    prints the list to the screen, numbering each string in order.
 ## 
 ## @end deftypefn
 
-function str_val = outlist(name_list,tabchar,yd,ilist)
+function str_val = outlist (name_list, tabchar, yd, ilist)
 
   ## A. S. Hodel Dec. 1995, 1998
 
   ## save for restore later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if( nargin < 1 | nargin > 4 )
diff --git a/scripts/control/packsys.m b/scripts/control/packsys.m
--- a/scripts/control/packsys.m
+++ b/scripts/control/packsys.m
@@ -22,17 +22,17 @@
 ##   dflg: 0 for continuous time system, 1 for discrete-time system.
 ## 
 ## defaults:
 ##      D: 0 matrix of appropriate dimension.
 ##   dflg: 0 (continuous time)
 ## 
 ## Note: discrete-state sampling time is not included!
 
-function Asys = packsys(a,b,c,d,dflg)
+function Asys = packsys (a, b, c, d, dflg)
 
   
   ## Written by R. Bruce Tenison  July 29, 1994
   ## Modified by David Clem November 13, 1994
   ## Modified by A. S. Hodel April 1995
 
   warning("packsys is obsolete!  Use ss2sys instead.");
   
diff --git a/scripts/control/parallel.m b/scripts/control/parallel.m
--- a/scripts/control/parallel.m
+++ b/scripts/control/parallel.m
@@ -24,17 +24,17 @@
 ##     u  ----->|----> | Asys |--->|----> y1
 ##         |    |      --------    |
 ##         |    |      ________    |
 ##         |--->|----> | Bsys |--->|----> y2
 ##              |      --------    |
 ##              --------------------
 ##                   Ksys
 
-function sysp = parallel(Asys,Bsys)
+function sysp = parallel (Asys, Bsys)
 
   ## Written by David Clem August 15, 1994
   ## completely rewritten Oct 1996 a s hodel
   ## SYS_INTERNAL accesses members of system structure
 
   if(nargin != 2)
     usage("sysp = parallel(Asys,Bsys)");
   endif
diff --git a/scripts/control/place.m b/scripts/control/place.m
--- a/scripts/control/place.m
+++ b/scripts/control/place.m
@@ -23,17 +23,17 @@
 ## system (i.e. A-BK) are those specified in the vector P.
 ## 
 ## Version: Beta (May-1997): If you have any comments, please let me know.
 ## 			    (see the file place.m for my address)
 ## 
 ## Written by: Jose Daniel Munoz Frias.
 ## @end deftypefn
  
-function K = place(sys, P) 
+function K = place (sys, P) 
 
   ## Universidad Pontificia Comillas
   ## ICAIdea
   ## Alberto Aguilera, 23
   ## 28015 Madrid, Spain
   ##
   ## E-Mail: daniel@dea.icai.upco.es
   ##
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -24,17 +24,17 @@
 ## @end example
 ##  to string @var{y} or to the screen (if @var{y} is omitted)
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg
 
-function y = polyout(c,x)
+function y = polyout (c, x)
 
 ## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) May 1995)
 ## Nov 1998: Correctly handles complex coefficients
   
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
     usage("[y = ] polyout(c,[x])");
   endif
 
diff --git a/scripts/control/prompt.m b/scripts/control/prompt.m
--- a/scripts/control/prompt.m
+++ b/scripts/control/prompt.m
@@ -24,17 +24,17 @@
 ##  str: input string. Default value: "\n ---- Press a key to continue ---"
 ##  Written by David Clem August 15, 1994
 ##  Modified A. S. Hodel June 1995
 ## 
 ## 
 ## @end format
 ## @end deftypefn
  
-function prompt(str)
+function prompt (str)
 
 if(nargin > 1)
   usage("prompt([str])");
 elseif(nargin == 0)
   str = "\n ---- Press a key to continue ---";
 elseif ( !isstr(str) )
   error("prompt: input must be a string");
 endif
diff --git a/scripts/control/pzmap.m b/scripts/control/pzmap.m
--- a/scripts/control/pzmap.m
+++ b/scripts/control/pzmap.m
@@ -23,17 +23,17 @@
 ##  @var{sys} system data structure
 ## 
 ## @strong{Outputs}
 ## if omitted, the poles and zeros are plotted on the screen.
 ##           otherwise, pol, zer are returned as the system poles and zeros.
 ##           (see sys2zp for a preferable function call)
 ## @end deftypefn
  
-function [zer,pol]=pzmap(sys)
+function [zer, pol]=pzmap (sys)
 
   save_emp = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
 
   if(nargin != 1)
     usage("pzmap(sys) or [zer,pol] = pzmap(sys)"); 
   elseif (!is_struct(sys));
diff --git a/scripts/control/qzval.m b/scripts/control/qzval.m
--- a/scripts/control/qzval.m
+++ b/scripts/control/qzval.m
@@ -30,15 +30,15 @@
 ## @end tex
 ## @end iftex
 ## 
 ## @var{A} and @var{B} must be real matrices.
 ##  
 ## @strong{Note} @code{qzval} is obsolete; use @code{qz} instead.
 ## @end deftypefn
  
-function lam = qzval(A,B)
+function lam = qzval (A, B)
 ## A. S. Hodel July 1998
 
   warning("qzval is obsolete; calling qz instead")
   lam = qz(A,B);
 endfunction
 
diff --git a/scripts/control/rldemo.m b/scripts/control/rldemo.m
--- a/scripts/control/rldemo.m
+++ b/scripts/control/rldemo.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File } { outputs =} rldemo ( inputs ) 
 ##Octave Controls toolbox demo: Root Locus demo
 ##@end deftypefn
  
-function rldemo()
+function rldemo ()
 ## Written by David Clem August 15, 1994
 ## Updated by John Ingram December 1996
 
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
     	"Display continuous system's open loop poles and zeros (pzmap)", ...
     	"Display discrete system's open loop poles and zeros (pzmap)", ...
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -35,17 +35,17 @@
 ##    rldata: Data points plotted column 1: real values, column 2: imaginary
 ##            values)
 ##    k: gains for real axis break points.
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
-function [rldata,k_break,rlpol,gvec,real_ax_pts] = rlocus(sys,increment,min_k,max_k)
+function [rldata, k_break, rlpol, gvec, real_ax_pts] = rlocus (sys, increment, min_k, max_k)
 
   ## Convert the input to a transfer function if necessary
   ## Written by Clem and Tenison
   ## Updated by Kristi McGowan July 1996 for intelligent gain selection
   ## Updated by John Ingram July 1996 for systems
   
   if (nargin < 1) | (nargin > 4)
     usage("rlocus(sys[,inc,mink,maxk])");
diff --git a/scripts/control/rotg.m b/scripts/control/rotg.m
--- a/scripts/control/rotg.m
+++ b/scripts/control/rotg.m
@@ -16,12 +16,12 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## function [c,s] = rotg(a,b)
 ## givens rotation calculation
 ##
 ## NOTE: Use [c,s] = givens(a,b) instead.
 
-function [c,s] = rotg(a,b)
+function [c, s] = rotg (a, b)
 
   [c,s] = givens(a,b);
 endfunction
diff --git a/scripts/control/series.m b/scripts/control/series.m
--- a/scripts/control/series.m
+++ b/scripts/control/series.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-function [a,b,c,d] = series(a1,b1,c1,d1,a2,b2,c2,d2)
+function [a, b, c, d] = series (a1, b1, c1, d1, a2, b2, c2, d2)
 ## Forms the series connection of two systems.
 ##
 ## Superseded by sysmult.  Do not use this routine!
 ## used internally in zp2ss
 ##
 ## Type of input: Transfer functions
 ## Command:       [num,den]=series(num1,den1,num2,den2)
 ## Forms the series representation of the two transfer functions.
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -30,17 +30,17 @@
 ##      a - jb followed by a + jb.
 ##  yy: sorted values
 ##  idx: permutation vector: yy = xx(idx)
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
-function [yy,idx] = sortcom(xx,opt)
+function [yy, idx] = sortcom (xx, opt)
 
   ## Written by A. S. Hodel June 1995
 
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
   elseif( !(is_vector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -182,17 +182,17 @@
 ##   0  0
 ## @end example
 ## Notice that the @var{D} matrix is constructed  by default to the 
 ## correct dimensions.  Default input and output signals names were assigned
 ## since none were given.
 ## 
 ## @end deftypefn
 
-function  retsys = ss2sys  (a,b,c,d,tsam,n,nz,stname,inname,outname,outlist)
+function  retsys = ss2sys (a, b, c, d, tsam, n, nz, stname, inname, outname, outlist)
 
   ## Written by John Ingram (ingraje@eng.auburn.edu)  July 20, 1996
 
   ## Test for correct number of inputs
   if ((nargin < 3) | (nargin > 11))
     usage("retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
   endif
 
diff --git a/scripts/control/ss2tf.m b/scripts/control/ss2tf.m
--- a/scripts/control/ss2tf.m
+++ b/scripts/control/ss2tf.m
@@ -33,17 +33,17 @@
 ##                 den(s)
 ## 
 ##  used internally in system data structure format manipulations
 ## 
 ## 
 ## @end format
 ## @end deftypefn
  
-function [num,den] = ss2tf(a,b,c,d)
+function [num, den] = ss2tf (a, b, c, d)
 
   ## Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
   ## a s hodel: modified to allow for pure gain blocks Aug 1996
 
   ## Check args
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     num = [];
diff --git a/scripts/control/ss2zp.m b/scripts/control/ss2zp.m
--- a/scripts/control/ss2zp.m
+++ b/scripts/control/ss2zp.m
@@ -26,17 +26,17 @@
 ## 
 ##  used internally in system data structure format manipulations
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
  
-function [zer,pol,k] = ss2zp(a,b,c,d)
+function [zer, pol, k] = ss2zp (a, b, c, d)
 
   ## Written by David Clem August 15, 1994
   ## Hodel: changed order of output arguments to zer, pol, k. July 1996
   ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
   if(nargin != 4)
     usage("[zer,pol,k] = ss2zp(a,b,c,d)");
   endif
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} starp ( inputs ) 
 ## @format
 ## 
-##  [sys] = starp(P, K, ny, nu)
+##  sys = starp(P, K, ny, nu)
 ## 
 ##  Redheffer star product or upper/lower LFT, respectively.
 ## 
 ## 
 ##                +-------+
 ##      --------->|       |---------> 
 ##                |   P   |
 ##           +--->|       |---+  ny
@@ -44,22 +44,22 @@
 ##  is a lower fractional transformation. If ny and nu "consume" all
 ##  inputs and outputs of P then the result is an upper fractional
 ##  transformation.
 ## 
 ##  ny and/or nu may be negative (= negative feedback)
 ## @end format
 ## @end deftypefn
 
-function [sys] = starp(P, K, ny, nu);
+function sys = starp (P, K, ny, nu);
 
   ## Written by Kai Mueller May 1998
 
   if((nargin != 2) && (nargin != 4))
-    usage("[sys] = starp(P, K, ny, nu)");
+    usage("sys = starp(P, K, ny, nu)");
   endif
   if (!is_struct(P))
     error("---> P must be in system data structure");
   endif
   if (!is_struct(K))
     error("---> K must be in system data structure");
   endif
 
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -57,17 +57,17 @@
 ## Both parameters tstop and n can be ommitted and will be
 ## computed from the eigenvalues of the A-Matrix.
 ##
 ## When the step function is invoked with the output parameter y
 ## a plot is not displayed.
 ##
 ## See also: impulse, stepimp
 
-function [y, t] = step(sys, inp, tstop, n)
+function [y, t] = step (sys, inp, tstop, n)
 ## Written by Kai P. Mueller September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
 
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -27,17 +27,17 @@
 ## Limited argument checking; "do not attempt to do this at home".
 ## Used internally in @code{impulse}, @code{step}. Use @code{step}
 ## or @code{impulse} instead.
 ## 
 ## @end deftypefn
 
 ## See also: step, impulse
 
-function [y, t] = stepimp(sitype, sys, inp, tstop, n)
+function [y, t] = stepimp (sitype, sys, inp, tstop, n)
 
   ## Written by Kai P. Mueller October 2, 1997
   ## based on lsim.m of Scottedward Hodel
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
   else		   	   error("stepimp: illegal sitype argument.")
   endif
diff --git a/scripts/control/strappend.m b/scripts/control/strappend.m
--- a/scripts/control/strappend.m
+++ b/scripts/control/strappend.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-function retval = strappend(strlist,suffix);
+function retval = strappend (strlist, suffix);
 
   ## retval = strappend(strlist,suffix);
   ## append string suffix to each string in the list of strings strlist
   
   if(nargin != 2 | nargout > 1)
     usage(" retval = strappend(strlist,suffix)");
   elseif(!is_signal_list(strlist))
     strlist
diff --git a/scripts/control/susball.m b/scripts/control/susball.m
--- a/scripts/control/susball.m
+++ b/scripts/control/susball.m
@@ -14,113 +14,88 @@
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { outputs =} susball ( inputs ) 
 ## @format
-## 
-## @end format
-## @end deftypefn
-## @deftypefn {Function File } { outputs =} swap ( inputs ) 
-## @format
-##  [a1,b1] = swap(a,b)
-##  interchange a and b
-## 
-## 
-## @end format
-## @end deftypefn
-## @deftypefn {Function File } { outputs =} swapcols ( inputs ) 
-## @format
-##  function B = swapcols(A)
-##  permute columns of A into reverse order
-## 
-## 
-## @end format
-## @end deftypefn
-## @deftypefn {Function File } { outputs =} swaprows ( inputs ) 
-## @format
-##  function B = swaprows(A)
-##  permute rows of A into reverse order
-## 
-## 
 ## @end format
 ## @end deftypefn
 
-    cmd = "ballsys = margetsys(""disc"")";
-    eval(cmd);
-    
-    disp("Design LQG controller");
-    cmd = "sysout(ballsys)";
-    run_cmd
-    disp("add noise inputs to system...")
- 
-    disp("discrete system:")
-    [nn,nz,mm,pp] = sysdimensions(ballsys);
-    cmd = "ballsys = sysappend(ballsys,nz);";
-    run_cmd 
+cmd = "ballsys = margetsys(""disc"")";
+eval(cmd);
+
+disp("Design LQG controller");
+cmd = "sysout(ballsys)";
+run_cmd
+disp("add noise inputs to system...")
 
-    cmd = "sysout(ballsys)";
-    run_cmd
+disp("discrete system:")
+[nn,nz,mm,pp] = sysdimensions(ballsys);
+cmd = "ballsys = sysappend(ballsys,nz);";
+run_cmd 
+
+cmd = "sysout(ballsys)";
+run_cmd
 
-    disp("Notice the two additional inputs, u_2, and u_3.  These are the ");
-    disp("""entry points"" for the gaussian noise disturbance.");
-    disp(" ");
-    disp("We'll design the controller to use only position feedback:")
+disp("Notice the two additional inputs, u_2, and u_3.  These are the ");
+disp("""entry points"" for the gaussian noise disturbance.");
+disp(" ");
+disp("We'll design the controller to use only position feedback:")
 
-    cmd = "ballsys=sysprune(ballsys,1,[]);";
-    run_cmd
-    cmd = "sysout(ballsys)";
-    run_cmd
+cmd = "ballsys=sysprune(ballsys,1,[]);";
+run_cmd
+cmd = "sysout(ballsys)";
+run_cmd
 
-    disp("Now design an LQG controller: Sigw: input noise")
-    Sigw = eye(2)
-    disp("Now design an LQG controller: Sigv: measurement noise")
-    Sigv = eye(pp);
+disp("Now design an LQG controller: Sigw: input noise")
+Sigw = eye(2)
+disp("Now design an LQG controller: Sigv: measurement noise")
+Sigv = eye(pp);
 
-    disp("State and input penalties:")
-    Q = eye(2)
-    R = 1
-    disp("Controlled input is input 1");
+disp("State and input penalties:")
+Q = eye(2)
+R = 1
+disp("Controlled input is input 1");
 
-    cmd="Ksys = lqg(ballsys,Sigw,Sigv,Q,R,1);";
-    run_cmd
+cmd="Ksys = lqg(ballsys,Sigw,Sigv,Q,R,1);";
+run_cmd
 
-    disp("sysout(Ksys);");
-    sysout(Ksys);
+disp("sysout(Ksys);");
+sysout(Ksys);
 
-    disp("\nGet rid of the disturbance inputs");
-    cmd = "ballsys = sysprune(ballsys,1,1);"
-    run_cmd;
-    sysout(ballsys);
-    sysout(ballsys,"zp");
+disp("\nGet rid of the disturbance inputs");
+cmd = "ballsys = sysprune(ballsys,1,1);"
+run_cmd;
+sysout(ballsys);
+sysout(ballsys,"zp");
 
-    disp("\nGrouping the plant and the controller");
-    cmd = "closed_loop = sysgroup(ballsys,Ksys);"
-    run_cmd;
-    sysout(closed_loop);
+disp("\nGrouping the plant and the controller");
+cmd = "closed_loop = sysgroup(ballsys,Ksys);"
+run_cmd;
+sysout(closed_loop);
 
-    disp("\nduplicating the plant input");
-    cmd = "closed_loop = sysdup(closed_loop,[],1);"
-    run_cmd;
-    sysout(closed_loop);
+disp("\nduplicating the plant input");
+cmd = "closed_loop = sysdup(closed_loop,[],1);"
+run_cmd;
+sysout(closed_loop);
 
-##    disp("\nscaling the duplicated input by -1");
-##    cmd = "closed_loop = sysscale(closed_loop,[],diag([1,1,1]));"
-##    run_cmd;
-##    sysout(closed_loop);
+## disp("\nscaling the duplicated input by -1");
+## cmd = "closed_loop = sysscale(closed_loop,[],diag([1,1,1]));"
+## run_cmd;
+## sysout(closed_loop);
 
-    disp("\nconnecting plant output to controller input and controller output");
-    disp("to the duplicated plant input");
-    cmd = "closed_loop = sysconnect(closed_loop,[1 2],[2 3]);"
-    run_cmd;
-    sysout(closed_loop);
+disp("\nconnecting plant output to controller input and controller output");
+disp("to the duplicated plant input");
+cmd = "closed_loop = sysconnect(closed_loop,[1 2],[2 3]);"
+run_cmd;
+sysout(closed_loop);
 
-    disp("\nkeeping only the original plant input and plant output");
-    cmd = "closed_loop = sysprune(closed_loop,1,1);"
-    run_cmd;
-    sysout(closed_loop);
+disp("\nkeeping only the original plant input and plant output");
+cmd = "closed_loop = sysprune(closed_loop,1,1);"
+run_cmd;
+sysout(closed_loop);
 
-    sysout(closed_loop,"zp");
+sysout(closed_loop,"zp");
 
- 
+
diff --git a/scripts/control/swap.m b/scripts/control/swap.m
--- a/scripts/control/swap.m
+++ b/scripts/control/swap.m
@@ -10,21 +10,26 @@
 ## Octave is distributed in the hope that it will be useful, but WITHOUT 
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
-## usage: [a1,b1] = swap(a,b)
-## interchange a and b
 
-function [a1,b1] = swap(a,b)
+## -*- texinfo -*-
+## @deftypefn {Function File } { outputs =} swap ( inputs ) 
+## @format
+##  [a1,b1] = swap(a,b)
+##  interchange a and b
+## @end format
+## @end deftypefn
+
+function [a1, b1] = swap (a, b)
 
   ## A. S. Hodel July 24 1992
   ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
   a1 = b;
   b1 = a;
 endfunction
 
diff --git a/scripts/control/swapcols.m b/scripts/control/swapcols.m
--- a/scripts/control/swapcols.m
+++ b/scripts/control/swapcols.m
@@ -11,20 +11,25 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-## usage: B = swapcols(A)
-## permute columns of A into reverse order
+## -*- texinfo -*-
+## @deftypefn {Function File } { outputs =} swapcols ( inputs ) 
+## @format
+##  function B = swapcols(A)
+##  permute columns of A into reverse order
+## @end format
+## @end deftypefn
 
-function B = swapcols(A)
+function B = swapcols (A)
   
   ## A. S. Hodel July 23, 1992
   ## Conversion to Octave R. Bruce Tenison July 4, 1994
 
   m = length(A(1,:));
   idx = m:-1:1;
   B = A(:,idx);
 endfunction
diff --git a/scripts/control/swaprows.m b/scripts/control/swaprows.m
--- a/scripts/control/swaprows.m
+++ b/scripts/control/swaprows.m
@@ -10,21 +10,26 @@
 ## Octave is distributed in the hope that it will be useful, but WITHOUT 
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
- 
-## usage: B = swaprows(A)
-## permute rows of A into reverse order
 
-function B = swaprows(A)
+## -*- texinfo -*-
+## @deftypefn {Function File } { outputs =} swaprows ( inputs ) 
+## @format
+##  function B = swaprows(A)
+##  permute rows of A into reverse order
+## @end format
+## @end deftypefn
+
+function B = swaprows (A)
 
   ## A. S. Hodel July 23, 1992
   ## Conversion to Octave R. Bruce Tenison July 4, 1994
   
   m = rows(A);
   idx = m:-1:1;
   B = A(idx,:);
 endfunction
diff --git a/scripts/control/sys2fir.m b/scripts/control/sys2fir.m
--- a/scripts/control/sys2fir.m
+++ b/scripts/control/sys2fir.m
@@ -21,17 +21,17 @@
 ## 
 ## Extract FIR data from system data structure; see @ref{fir2sys} for
 ## parameter descriptions.
 ## 
 ## @end deftypefn
 
 ## See also: fir2sys
  
-function [c,tsam,inname,outname] = sys2fir(sys)
+function [c, tsam, inname, outname] = sys2fir (sys)
 
   ## a s hodel July 1996
 
   ## let sys2tf do most of the work
 
   [num,den,tsam,inname,outname] = sys2tf(sys);
 
   alph = den(1);			# scale to get monic denominator
diff --git a/scripts/control/sys2ss.m b/scripts/control/sys2ss.m
--- a/scripts/control/sys2ss.m
+++ b/scripts/control/sys2ss.m
@@ -57,17 +57,17 @@
 ## b =
 ##   0
 ##   1
 ## c = 0.66667  0.33333
 ## d = 0
 ## @end example
 ## @end deftypefn
  
-function [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)
+function [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys)
 
   ## Written by David Clem August 19, 1994
   ## Updates by John Ingram July 14, 1996
 
   if(nargin != 1)
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
diff --git a/scripts/control/sys2tf.m b/scripts/control/sys2tf.m
--- a/scripts/control/sys2tf.m
+++ b/scripts/control/sys2tf.m
@@ -26,17 +26,17 @@
 ## @example
 ## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [num,den] = sys2tf(sys)
 ## num = 1.0000  -3.0000
 ## den = 1.0000   1.1000  -4.3000
 ## @end example
 ## @end deftypefn
 
-function [num,den,tsam,inname,outname] = sys2tf(Asys)
+function [num, den, tsam, inname, outname] = sys2tf (Asys)
 ## Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
 ## modified to make sys2tf by A. S. Hodel Aug 1995
 ## modified again for updated system format by John Ingram July 1996
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
diff --git a/scripts/control/sys2zp.m b/scripts/control/sys2zp.m
--- a/scripts/control/sys2zp.m
+++ b/scripts/control/sys2zp.m
@@ -30,17 +30,17 @@
 ## zer = 3.0000
 ## pol =
 ##   -2.6953
 ##    1.5953
 ## k = 1
 ## @end example
 ## @end deftypefn
  
-function [zer,pol,k,tsam,inname,outname] = sys2zp(sys)
+function [zer, pol, k, tsam, inname, outname] = sys2zp (sys)
 
   ## Created by John Ingram July 15 1996
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
   elseif( !is_struct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -34,17 +34,17 @@
 ## -----                (_)----> y
 ##     |     ________   +|
 ##      ----|  Hsys  |---
 ##           --------
 ## @end group
 ## @end example
 ## @end deftypefn
  
-function sys = sysadd(...)
+function sys = sysadd (...)
 
   ## Written by John Ingram July 1996
   ## Updated for variable number of arguments July 1999 A. S. Hodel
 
   if(nargin < 1)
     usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
   endif
 
diff --git a/scripts/control/sysappend.m b/scripts/control/sysappend.m
--- a/scripts/control/sysappend.m
+++ b/scripts/control/sysappend.m
@@ -69,17 +69,17 @@
 ## 
 ## @item @var{sys} = discrete
 ## @var{yd} = @code{ones(1,rows(c))}
 ## 
 ## @end itemize
 ## 
 ## @end deftypefn
 
-function retsys = sysappend(sys,b,c,d,outname,inname,yd)
+function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   ## written by John Ingram August 1996
   
   sav_empty_list_elements_ok = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
   
   ## check input arguments
diff --git a/scripts/control/syschnames.m b/scripts/control/syschnames.m
--- a/scripts/control/syschnames.m
+++ b/scripts/control/syschnames.m
@@ -16,14 +16,14 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } {@var{retsys} =} syschnames (@var{sys}, @var{opt}, @var{list}, @var{names})
 ## Superseded by @code{syssetsignals}
 ## @end deftypefn
 
-function retsys = syschnames(sys,opt,list,names)
+function retsys = syschnames (sys, opt, list, names)
 ## Written by John Ingram August 1996; updated by A. S. Hodel 1998
 
   retsys = syssetsignals(sys,opt,names,list);
 
 endfunction
diff --git a/scripts/control/syschnamesl.m b/scripts/control/syschnamesl.m
--- a/scripts/control/syschnamesl.m
+++ b/scripts/control/syschnamesl.m
@@ -22,17 +22,17 @@
 ##  item olist: index list 
 ##  old_names: original list names
 ##  inames: new names
 ##  listname: name of index list
 ## 
 ##  combines the two string lists old_names and inames
 ## @end deftypefn
  
-function old_names = syschnamesl(olist,old_names,inames,listname)
+function old_names = syschnamesl (olist, old_names, inames, listname)
   ## $Revision: 2.1.14.5 $
   ## $Log: syschnamesl.m,v $
   ## Revision 2.1.14.5  1999/09/22  21:55:46  scotte
   ## Auburn copyright fixed; krylov.m patched to fix bug
   ##
   ## Revision 2.1.14.4  1999/07/21  19:49:21  scotte
   ## sysgroup, sysadd, sysmult, syssub accept variable # of input args
   ##
diff --git a/scripts/control/syschtsam.m b/scripts/control/syschtsam.m
--- a/scripts/control/syschtsam.m
+++ b/scripts/control/syschtsam.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { retsys =} syschtsam ( sys,tsam ) 
 ## This function changes the sampling time (tsam) of the system.  Exits with
 ## an error if sys is purely continuous time.
 ## @end deftypefn
  
-function retsys = syschtsam(sys,tsam)
+function retsys = syschtsam (sys, tsam)
 ## Written by John Ingram August 1996
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   elseif(!is_scalar(tsam))
     disp("syschtsam:")
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -58,17 +58,17 @@
 ##            -------------------------------
 ## @end group
 ## @end example
 ## The input that has the summing junction added to it has an * added to the end 
 ## of the input name.
 ## 
 ## @end deftypefn
 
-function sys = sysconnect(sys,output_list,input_list,order,tol)
+function sys = sysconnect (sys, output_list, input_list, order, tol)
 
   ## A. S. Hodel August 1995
   ## modified by John Ingram July 1996
 
   if( (nargin < 3) | (nargin > 5) )
     usage("retsys = sysconnect(sys,output_list,input_list[,order,tol])");
   endif
 
diff --git a/scripts/control/syscont.m b/scripts/control/syscont.m
--- a/scripts/control/syscont.m
+++ b/scripts/control/syscont.m
@@ -31,17 +31,17 @@
 ##  connections from discrete states to continuous states,
 ##                discrete states to continuous outputs, respectively.
 ## 
 ##  returns @var{csys} empty if no continuous/continous path exists
 ## @end table
 ## 
 ## @end deftypefn
  
-function [csys,Acd,Ccd] = syscont(sys)
+function [csys, Acd, Ccd] = syscont (sys)
 
   ## Written by John Ingram August 1996
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
diff --git a/scripts/control/syscont_disc.m b/scripts/control/syscont_disc.m
--- a/scripts/control/syscont_disc.m
+++ b/scripts/control/syscont_disc.m
@@ -34,17 +34,17 @@
 ## @item y_c
 ## vector of continuous output indices
 ## @item y_d
 ## vector of discrete output indices
 ## @end table
 ## 
 ## @end deftypefn
  
-function [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys)
+function [n_tot, st_c, st_d, y_c, y_d] = syscont_disc (sys)
 
   ## Written by A. S. Hodel (a.s.hodel@eng.auburn.edu) Feb 1997
 
   ## get ranges for discrete/continuous states and outputs
   [nn,nz,mm,pp,yd] = sysdimensions(sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
diff --git a/scripts/control/sysdefioname.m b/scripts/control/sysdefioname.m
--- a/scripts/control/sysdefioname.m
+++ b/scripts/control/sysdefioname.m
@@ -31,17 +31,17 @@
 ## (
 ##   [1] = u_3
 ##   [2] = u_4
 ##   [3] = u_5
 ## )
 ## @end example
 ## @end deftypefn
  
-function ioname = sysdefioname(n,str,m)
+function ioname = sysdefioname (n, str, m)
 
   if (nargin < 2 | nargin > 3)
     usage("ioname = sysdefioname(n,str[,m])");
   endif
 
   if (nargin == 2)           m = min(1,n);            endif
 
   ioname = list();
diff --git a/scripts/control/sysdefstname.m b/scripts/control/sysdefstname.m
--- a/scripts/control/sysdefstname.m
+++ b/scripts/control/sysdefstname.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*- 
 ## @deftypefn {Function File } { @var{stname} =} sysdefstname (@var{n}, @var{nz}) 
 ##  return default state names given @var{n}, @var{nz}
 ## 
 ##  used internally, minimal argument checking
 ## @end deftypefn
 
-function stname = sysdefstname(n,nz)
+function stname = sysdefstname (n, nz)
 
   stname = list();
   if(n > 0)
     for ii = 1:n
       stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
  
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -61,17 +61,17 @@
 ## discrete.
 ## @math{yd(ii) = 0} if output @var{ii} is continous
 ## @end table
 ## 
 ## @end deftypefn
 
 ## See also: sysgetsignals, sysgettsam
 
-function [n,nz,m,p,yd] = sysdimensions(sys,opt)
+function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 if(nargout > 5 | nargin < 1 | nargin > 2)
   usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
 elseif(!is_struct(sys))
   usage("[n,nz,m,p] = sysdimensions(sys)");
 elseif(nargin == 1)
   opt = "all";
 endif
 
diff --git a/scripts/control/sysdisc.m b/scripts/control/sysdisc.m
--- a/scripts/control/sysdisc.m
+++ b/scripts/control/sysdisc.m
@@ -29,17 +29,17 @@
 ##           no purely discrete path from inputs to outputs)
 ## @item    Adc, Cdc
 ##  connections from continuous states to discrete states and discrete
 ##     outputs, respectively.
 ## @end table
 ## 
 ## @end deftypefn
  
-function [dsys,Adc,Cdc] = sysdisc(sys)
+function [dsys, Adc, Cdc] = sysdisc (sys)
 
   ## function [dsys,Adc,Cdc] = sysdisc(sys)
   ## inputs: sys = system data structure
   ## outputs:
   ##    dsys: purely discrete portion of sys (returned empty if there is
   ##          no purely discrete path from inputs to outputs)
   ##    Adc, Cdc: connections from continuous states to discrete states/discrete
   ##    outputs, respectively.
diff --git a/scripts/control/sysdup.m b/scripts/control/sysdup.m
--- a/scripts/control/sysdup.m
+++ b/scripts/control/sysdup.m
@@ -46,17 +46,17 @@
 ##           |       Asys       |
 ## u2 ------>|                  |----->y2 
 ## (in_idx)  -------------------| (out_idx)
 ## @end group
 ## @end example
 ## 
 ## @end deftypefn
 
-function retsys = sysdup(Asys,output_list,input_list)
+function retsys = sysdup (Asys, output_list, input_list)
 
   ## A. S. Hodel August 1995
   ## modified by John Ingram July 1996
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
diff --git a/scripts/control/sysgetsignals.m b/scripts/control/sysgetsignals.m
--- a/scripts/control/sysgetsignals.m
+++ b/scripts/control/sysgetsignals.m
@@ -130,17 +130,17 @@
 ##   [1] = y_2
 ## )
 ## octave> Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
 ## Aout = y_2
 ## @end example
 ## 
 ## @end deftypefn
 
-function [stname,inname,outname,yd] = sysgetsignals(sys,sigid,signum,strflg)
+function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss2sys
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
     usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
   elseif(nargin > 1 & nargout > 1)
     usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
   elseif( ! is_struct(sys) )
diff --git a/scripts/control/sysgettsam.m b/scripts/control/sysgettsam.m
--- a/scripts/control/sysgettsam.m
+++ b/scripts/control/sysgettsam.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-function T = sysgettsam(sys)
+function T = sysgettsam (sys)
 ## T = sysgettsam(sys)
 ## return the sampling time of the system
 
 if(!is_struct(sys))
   usage("T = sysgettsam(sys)");
 endif
 
 T = sys.tsam;
diff --git a/scripts/control/sysgettype.m b/scripts/control/sysgettype.m
--- a/scripts/control/sysgettype.m
+++ b/scripts/control/sysgettype.m
@@ -28,17 +28,17 @@
 ##             constructed:
 ##       values: @code{"ss"}, @code{"zp"}, or @code{"tf"}
 ## 
 ## @strong{Note} FIR initialized systems return @code{systype="tf"}.
 ## 
 ## 
 ## @end deftypefn 
 
-function systype = sysgettype(sys)
+function systype = sysgettype (sys)
 
   if(!is_struct(sys))
     error("sysgettype: input sys is not a structure");
   endif
 
   typestr = list("tf","zp","ss");
   systype = nth(typestr,sys.sys(1) + 1);
 endfunction
diff --git a/scripts/control/sysgroup.m b/scripts/control/sysgroup.m
--- a/scripts/control/sysgroup.m
+++ b/scripts/control/sysgroup.m
@@ -41,17 +41,17 @@
 ## The function also rearranges the internal state-space realization of @var{sys}
 ## so that the
 ##  continuous states come first and the discrete states come last.
 ##  If there are duplicate names, the second name has a unique suffix appended
 ##  on to the end of the name.
 ## 
 ## @end deftypefn
  
-function sys = sysgroup(...)
+function sys = sysgroup (...)
 
   ## A. S. Hodel August 1995
   ## modified by John Ingram July 1996
   ## A. S. Hodel: modified for variable number of arguments 1999
 
   save_emp = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
diff --git a/scripts/control/sysgroupn.m b/scripts/control/sysgroupn.m
--- a/scripts/control/sysgroupn.m
+++ b/scripts/control/sysgroupn.m
@@ -26,17 +26,17 @@
 ## outputs:
 ##   returns names with unique suffixes added; diagnostic warning
 ##      message is printed to inform the user of the new signal name
 ##
 ##  used internally in sysgroup and elsewhere. 
 ## 
 ## @end deftypefn
  
-function names = sysgroupn(names,kind)
+function names = sysgroupn (names, kind)
 
   ## check for duplicate names
   l = length(names);
   ii = 1;
   while(ii <= l-1)
     st1 = nth(names,ii);
     jj = ii+1;
     while ( jj <= l)
diff --git a/scripts/control/sysidx.m b/scripts/control/sysidx.m
--- a/scripts/control/sysidx.m
+++ b/scripts/control/sysidx.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 ##
 ## Written by A. S. Hodel, a.s.hodel@eng.auburn.edu
 
 
-function idxvec = sysidx(sys,sigtype,signamelist)
+function idxvec = sysidx (sys, sigtype, signamelist)
 
   ## idxvec = sysidx(sys,sigtype,signamelist)
   ## return indices of signals with specified signal names
   ## inputs:
   ##   sys:         OCST system data structure
   ##   sigtype:     signal type to be selected: "in", "out", "st"
   ##   signamelist: list of desired signal names
   ## outputs:
diff --git a/scripts/control/sysmin.m b/scripts/control/sysmin.m
--- a/scripts/control/sysmin.m
+++ b/scripts/control/sysmin.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 ##
 ## Written by A. S. Hodel a.s.hodel@eng.auburn.edu
 
-function [retsys,nc,no,cflg,oflg] = sysmin(sys,flg);
+function [retsys, nc, no, cflg, oflg] = sysmin (sys, flg);
 
   ## [retsys,nc,no] = sysmin(sys{,flg});
   ## return a minimal (or reduced order) system
   ## inputs:
   ##   sys: system data structure
   ##   flg: 0 [default] return minimal system; state names lost
   ##      : 1           return system with physical states removed that
   ##                    are either uncontrollable or unobservable
diff --git a/scripts/control/sysmult.m b/scripts/control/sysmult.m
--- a/scripts/control/sysmult.m
+++ b/scripts/control/sysmult.m
@@ -27,17 +27,17 @@
 ## @end group
 ## @end example
 ## A warning occurs if there is direct feed-through
 ## from an input of Bsys or a continuous state of Bsys through a discrete 
 ## output of Bsys to a continuous state or output in Asys (system data structure
 ## does not recognize discrete inputs).
 ## @end deftypefn
 
-function sys = sysmult(...)
+function sys = sysmult (...)
 
   ## Written by John Ingram July 1996
   ## updated for variable number of arguments by A. S. Hodel July 1999
 
   if(nargin < 1)
     usage("sysmult: sys = sysmult(Asys{,Bsys,...})");
   endif
 
diff --git a/scripts/control/sysout.m b/scripts/control/sysout.m
--- a/scripts/control/sysout.m
+++ b/scripts/control/sysout.m
@@ -34,17 +34,17 @@
 ## @item      "zp"
 ##  zero-pole form
 ## @item      "all"
 ##  all of the above
 ## @end table
 ## @end table
 ## @end deftypefn
  
-function retsys = sysout(sys,opt)
+function retsys = sysout (sys, opt)
 
   ## Written by A S Hodel: 1995-1996
 
   if( (nargin < 1) || (nargin > 2) )
     usage("sysout(sys[,opt])");
   endif
 
   if(isempty(sys))
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -40,17 +40,17 @@
 ## u2 ------->|                  |----| y2
 ##   (deleted)-------------------- (deleted)   
 ## @end group
 ## @end example
 ## 
 ## @end deftypefn
 ## 
  
-function sys = sysprune(sys,output_idx,input_idx,state_idx)
+function sys = sysprune (sys, output_idx, input_idx, state_idx)
 
   ## A. S. Hodel August 1995
   ## Updated by John Ingram 7-15-96
 
   if( nargin < 3 | nargin > 4  )
     usage("retsys = sysprune(sys,output_idx,input_idx{,state_idx})");
   elseif(nargin < 4)
     state_idx = [];
diff --git a/scripts/control/sysreorder.m b/scripts/control/sysreorder.m
--- a/scripts/control/sysreorder.m
+++ b/scripts/control/sysreorder.m
@@ -25,17 +25,17 @@
 ## @strong{Outputs}
 ##  @var{pv}: a permutation vector to order elements of @code{[1:vlen]} in 
 ## @code{list} to the end of a vector.
 ## 
 ##  Used internally by @code{sysconnect} to permute vector elements to their
 ##  desired locations.  
 ## @end deftypefn
  
-function pv = sysreorder(vlen,list)
+function pv = sysreorder (vlen, list)
 
   ## A. S. Hodel, Aug 1995
   
   ## disp('sysreorder: entry')
   
   pv = 1:vlen;
   ## make it a row vector
   list = reshape(list,1,length(list));
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {} sysrepdemo 
 ## Tutorial for the use of the system data structure functions.
 ## @end deftypefn
 
 ## Octave Controls toolbox demo: System representation
 ## Written by A. S. Hodel June 1995
 ## Revised Aug 1995 for system data structure format
-function sysrepdemo()
+function sysrepdemo ()
 
 
 
   save_val = page_screen_output;
   page_screen_output = 1;
 
   disp('System representation demo:')
   num = [5 -1];
diff --git a/scripts/control/sysscale.m b/scripts/control/sysscale.m
--- a/scripts/control/sysscale.m
+++ b/scripts/control/sysscale.m
@@ -36,17 +36,17 @@
 ##  are not square, then default names will be given to the inputs and/or
 ##  outputs.
 ## 
 ## A warning message is printed if outscale attempts to add continuous
 ## system outputs to discrete system outputs; otherwise @var{yd} is 
 ## set appropriately in the returned value of @var{sys}.
 ## @end deftypefn
 
-function sys = sysscale(sys,outscale,inscale,outname,inname)
+function sys = sysscale (sys, outscale, inscale, outname, inname)
 
   ## A. S. Hodel August 1995
   ## modified by John Ingram 7-15-96
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
   elseif (!is_struct(sys))
     error("sys must be a structured system");
diff --git a/scripts/control/syssetsignals.m b/scripts/control/syssetsignals.m
--- a/scripts/control/syssetsignals.m
+++ b/scripts/control/syssetsignals.m
@@ -81,17 +81,17 @@
 ## C matrix: 1 x 2
 ##   7  8
 ## D matrix: 1 x 1
 ## 0
 ## @end example
 ## 
 ## @end deftypefn
 
-function retsys = syssetsignals(sys,opt,names,sig_idx)
+function retsys = syssetsignals (sys, opt, names, sig_idx)
 
   ## Written by John Ingram August 1996
 
   if (nargin < 3 | nargin > 4)
     usage("retsys=syssetsignals(sys,opt,names{,sig_idx})");
   elseif (!is_struct(sys))
     error("sys must be a system data structure");
   elseif (isempty(opt))
diff --git a/scripts/control/syssub.m b/scripts/control/syssub.m
--- a/scripts/control/syssub.m
+++ b/scripts/control/syssub.m
@@ -31,17 +31,17 @@
 ## -----                (_)----> y
 ##     |     ________   -|
 ##      ----|  Hsys  |---
 ##           --------
 ## @end group
 ## @end example
 ## @end deftypefn
  
-function sys = syssub(...)
+function sys = syssub (...)
 
   ## Written by John Ingram July 1996
   ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
 
   if(nargin < 1)
     usage("syssub: sys = syssub(Gsys{,Hsys,...})");
   endif
 
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -43,17 +43,17 @@
 ## If requested data in sys is already up to date then retsys=sys.
 ## 
 ## Conversion to @code{tf} or @code{zp} exits with an error if the system is 
 ##  mixed continuous/digital.
 ## @end deftypefn
 
 ## See also: tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, sys2zp
 
-function sys = sysupdate(sys,opt)
+function sys = sysupdate (sys, opt)
 
   ## Written by John Ingram  7-9-96
 
   ## check for correct number of inputs 
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
   elseif(! is_struct(sys) )
    error("1st argument must be system data structure")
diff --git a/scripts/control/tf2ss.m b/scripts/control/tf2ss.m
--- a/scripts/control/tf2ss.m
+++ b/scripts/control/tf2ss.m
@@ -37,17 +37,17 @@
 ##  The state space system matrices obtained from this function will be
 ##  in controllable canonical form as described in "Modern Control Theory",
 ##  [Brogan, 1991].
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
-function [a,b,c,d] = tf2ss(num,den)
+function [a, b, c, d] = tf2ss (num, den)
   ## Written by R. Bruce Tenison (June 22, 1994) btenison@eng.auburn.edu
   ## mod A S Hodel July, Aug  1995
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
   elseif(!is_vector(num)) 
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -45,17 +45,17 @@
 ## Sampling interval: 0.1
 ## transfer function form:
 ## 2*z^1 + 1
 ## -----------------
 ## 1*z^2 + 2*z^1 + 1
 ## @end example
 ## @end deftypefn
 
-function outsys = tf2sys(num,den,tsam,inname,outname)
+function outsys = tf2sys (num, den, tsam, inname, outname)
   ## Written by R. Bruce Tenison  July 29, 1994
   ## Name changed to TF2SYS July 1995
   ## updated for new system data structure format July 1996
 
   ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage('outsys=tf2sys(num,den[,tsam,inname,outname])');
     return
diff --git a/scripts/control/tf2sysl.m b/scripts/control/tf2sysl.m
--- a/scripts/control/tf2sysl.m
+++ b/scripts/control/tf2sysl.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{vec} = } tf2sysl (@var{vec})
 ##  used internally in @ref{tf2sys}.
 ##  strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
-function vec = tf2sysl(vec)
+function vec = tf2sysl (vec)
 ## vec = tf2sysl(vec)
 ##
 ## used internally in tf2sys
 ## strip leading zero coefficients to get the true polynomial length
 
 
 while( (length(vec) > 1) & (vec(1) == 0) )
   vec = vec(2:length(vec));
diff --git a/scripts/control/tf2zp.m b/scripts/control/tf2zp.m
--- a/scripts/control/tf2zp.m
+++ b/scripts/control/tf2zp.m
@@ -23,17 +23,17 @@
 ## 
 ##  [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
 ##  defined by num/den.  K is a gain associated with the system zeros.
 ## 
 ## 
 ## @end format
 ## @end deftypefn
 
-function [zer,pol,k] = tf2zp(num,den)
+function [zer, pol, k] = tf2zp (num, den)
 ## Written by A. S. Hodel, etc.
 
   if(nargin == 2)
     if(length(den) > 1)          pol = roots(den);
     else                         pol=[];                   endif
     if(length(num) > 1)         zer = roots(num);
     else                        zer=[];                    endif
   else                    error("Incorrect number of input arguments");
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } { } tfout (@var{num}, @var{denom}@{, @var{x}@})
 ##  print formatted transfer function @math{n(s)/d(s) } to the screen
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg, polyout
 
-function tfout(num,denom,x)
+function tfout (num, denom, x)
 ## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
   
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
   
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 ) 
     usage("tfout(num,denom[,x])");
   endif
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -42,17 +42,17 @@
 ## @strong{References}
 ## @enumerate
 ## @item Emami-Naeini and Van Dooren, Automatica, 1982.
 ## @item Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
 ## @end enumerate
 ## @end deftypefn
 
 
-function [zer, gain] = tzero(A,B,C,D)
+function [zer, gain] = tzero (A, B, C, D)
 
   ## R. Bruce Tenison July 4, 1994
   ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
   ## get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss2sys(A,B,C,D);
   elseif( (nargin == 1) && (! is_struct(A)))
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -23,17 +23,17 @@
 ##  complex systems from simple systems with buildssic.
 ##  Watch out if you are forming sampled systems since "ugain"
 ##  does not contain a sampling period.  
 ## 
 ## See also: hinfdemo (MIMO H_infinty example, Boeing 707-321 aircraft model)
 ## 
 ## @end deftypefn
 
-function outsys = ugain(n)
+function outsys = ugain (n)
 
   ## Written by Kai P. Mueller April, 1998
   ## Updates
 
   if((nargin != 1) || (nargout > 1))
     usage("outsys = ugain(n)")
   endif
   outsys = ss2sys([],[],[],eye(n));
diff --git a/scripts/control/unpacksys.m b/scripts/control/unpacksys.m
--- a/scripts/control/unpacksys.m
+++ b/scripts/control/unpacksys.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
  
-function [a,b,c,d] = unpacksys(syst)
+function [a, b, c, d] = unpacksys (syst)
 
   ## [a,b,c,d] = unpacksys(sys)
   ## Obsolete.  Use sys2ss instead.
 
   ## Written by David Clem August 19, 1994
 
   warning("unpacksys obsolete; calling sys2ss");
   [a,b,c,d] = sys2ss(syst);
diff --git a/scripts/control/wgt1o.m b/scripts/control/wgt1o.m
--- a/scripts/control/wgt1o.m
+++ b/scripts/control/wgt1o.m
@@ -26,17 +26,17 @@
 ## 
 ##  vl = Gain @@ low frequencies
 ## 
 ##  vh = Gain @@ high frequencies
 ## 
 ##  fc = Corner frequency (in Hz, *not* in rad/sec)
 ## @end deftypefn
  
-function wsys = wgt1o(vl, vh, fc)
+function wsys = wgt1o (vl, vh, fc)
 ## Written by Kai P. Mueller September 30, 1997
 
   if (nargin != 3)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
 
   if(nargout > 1)
     usage("wsys = wgt1o(vl, vh, fc)");
diff --git a/scripts/control/zgfmul.m b/scripts/control/zgfmul.m
--- a/scripts/control/zgfmul.m
+++ b/scripts/control/zgfmul.m
@@ -23,17 +23,17 @@
 ## Used by zgepbal (in zgscal) as part of generalized conjugate gradient
 ## iteration.
 ## @end deftypefn
    
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
-function y = zgfmul(a,b,c,d,x)
+function y = zgfmul (a, b, c, d, x)
 
   ## A. S. Hodel July 24 1992
   ## Conversion to Octave July 3, 1994
   
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
diff --git a/scripts/control/zgfslv.m b/scripts/control/zgfslv.m
--- a/scripts/control/zgfslv.m
+++ b/scripts/control/zgfslv.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {x =} zgfslv(@var{n},@var{m},@var{p},@var{b})
 ## solve system of equations for dense zgep problem
 ## @end deftypefn
  
-function x = zgfslv(n,m,p,b)
+function x = zgfslv (n, m, p, b)
   ## Written by A. Scotte Hodel
   ## Converted to Octave by R Bruce Tenison, July 3, 1994
 
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
   G1 = givens(sqrt(m),-sqrt(p))';
   G2 = givens(m+p,sqrt(n*(m+p)))';
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -24,17 +24,17 @@
 ## called by zgepbal
 ## 
 ## @end deftypefn 
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
-function zz = zginit(a,b,c,d)
+function zz = zginit (a, b, c, d)
 
   ## A. S. Hodel July 24 1992
   ## Conversion to Octave by R. Bruce Tenison, July 3, 1994
 
   [nn,mm] = size(b);
   [pp,mm] = size(d);
 
   nmp = nn+mm+pp;
diff --git a/scripts/control/zgpbal.m b/scripts/control/zgpbal.m
--- a/scripts/control/zgpbal.m
+++ b/scripts/control/zgpbal.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 ## for more details.
 ## 
 ## You should have received a copy of the GNU General Public License 
 ## along with Octave; see the file COPYING.  If not, write to the Free 
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
-## @deftypefn {Function File } {[retsys] =} zgpbal(Asys)
+## @deftypefn {Function File } {retsys =} zgpbal(Asys)
 ##
 ## used internally in @code{tzero}; minimal argument checking performed
 ##
 ## implementation of zero computation generalized eigenvalue problem 
 ## balancing method (Hodel and Tiller, Allerton Conference, 1991)
 ## Based on Ward's balancing algorithm (SIAM J. Sci Stat. Comput., 1981)
 ##
 ## zgpbal computes a state/input/output weighting that attempts to 
@@ -33,17 +33,18 @@
 ## zgpbal should be followed by zgpred
 ##
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
-function [retsys] = zgpbal(Asys)  
+function retsys = zgpbal (Asys)  
+
   ## A. S. Hodel July 24 1992
   ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
   if( (nargin != 1) | (!is_struct(Asys)))
     usage("retsys = zgpbal(Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
diff --git a/scripts/control/zgreduce.m b/scripts/control/zgreduce.m
--- a/scripts/control/zgreduce.m
+++ b/scripts/control/zgreduce.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { retsys = } zgreduce(@var{Asys},@var{meps})
 ## Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren, 
 ## Automatica, # 1982).
 ## @end deftypefn
  
-function retsys = zgreduce(Asys,meps)
+function retsys = zgreduce (Asys, meps)
 
   ## SYS_INTERNAL accesses members of system data structure
 
   is_digital(Asys);		# make sure it's pure digital/continuous
 
   exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
 
   if(Asys.n + Asys.nz == 0)
diff --git a/scripts/control/zgrownorm.m b/scripts/control/zgrownorm.m
--- a/scripts/control/zgrownorm.m
+++ b/scripts/control/zgrownorm.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{nonz}, @var{zer}] =} zgrownorm (@var{mat}, @var{meps})
 ## returns @var{nonz} = number of rows of @var{mat} whose two norm exceeds @var{meps}
 ##         @var{zer} = number of rows of mat whose two norm is less than meps
 ## @end deftypefn
 
-function [sig, tau] = zgrownorm(mat,meps)
+function [sig, tau] = zgrownorm (mat, meps)
 
   rownorm = [];
   for ii=1:rows(mat)
     rownorm(ii) = norm(mat(ii,:));
   endfor
   sig = sum(rownorm > meps);
   tau = sum(rownorm <= meps);
 
diff --git a/scripts/control/zgscal.m b/scripts/control/zgscal.m
--- a/scripts/control/zgscal.m
+++ b/scripts/control/zgscal.m
@@ -23,17 +23,17 @@
 ## @math{fx=z};
 ## called by @code{zgepbal}
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
-function x = zgscal(a,b,c,d,z,n,m,p)
+function x = zgscal (a, b, c, d, z, n, m, p)
 
   ## A. S. Hodel July 24 1992
   ## Conversion to Octave R. Bruce Tenison July 3, 1994
 
   ## initialize parameters:
   ## Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
 
   nmp = n+m+p;
diff --git a/scripts/control/zgsgiv.m b/scripts/control/zgsgiv.m
--- a/scripts/control/zgsgiv.m
+++ b/scripts/control/zgsgiv.m
@@ -17,17 +17,18 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. 
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } {[a ,b ] =} zgsgiv(@var{c},@var{s},@var{a},@var{b})
 ## apply givens rotation c,s to row vectors @var{a},@var{b}
 ## No longer used in zero-balancing (zgpbal); kept for backward compatibility
 ## @end deftypefn
 
-function [a,b] = zgsgiv(c,s,a,b)
+function [a, b] = zgsgiv (c, s, a, b)
+
   ## A. S. Hodel July 29, 1992
   ## Convertion to Octave by R. Bruce Tenison July 3, 1994
 
   t1 = c*a + s*b;
   t2 = -s*a + c*b;
   a = t1;
   b = t2;
 endfunction
diff --git a/scripts/control/zgshsr.m b/scripts/control/zgshsr.m
--- a/scripts/control/zgshsr.m
+++ b/scripts/control/zgshsr.m
@@ -18,17 +18,18 @@
  
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { @var{x} =} zgshsr( @var{y})
 ## apply householder vector based on @math{e^(m)} to 
 ## (column vector) y.
 ## Called by zgfslv
 ## @end deftypefn
 
-function x = zgshsr(y)
+function x = zgshsr (y)
+
   ## A. S. Hodel July 24, 1992
   ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
   if(!is_vector(y))
     error(sprintf("y(%dx%d) must be a vector",rows(y),columns(y)));
   endif
   x = vec(y);
   m = length(x);
diff --git a/scripts/control/zp2ss.m b/scripts/control/zp2ss.m
--- a/scripts/control/zp2ss.m
+++ b/scripts/control/zp2ss.m
@@ -40,17 +40,17 @@
 ## function call @code{[a,b,c,d] = zp2ss(zer,pol,k)}.  
 ## The vectors @samp{zer} and 
 ## @samp{pol} may either be row or column vectors.  Each zero and pole that
 ## has an imaginary part must have a conjugate in the list.
 ## The number of zeros must not exceed the number of poles.
 ## @samp{k} is @code{zp}-form leading coefficient.
 ## @end deftypefn
  
-function [a,b,c,d] = zp2ss(zer,pol,k)
+function [a, b, c, d] = zp2ss (zer, pol, k)
 
   ## Written by David Clem August 15, 1994
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File } { [@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
 ## Used internally in @code{zp2ss}
 ## Extract 2 values from @var{rvals} (if possible) and construct
 ##  a polynomial with those roots.
 ## @end deftypefn
 
-function [poly,rvals] = zp2ssg2(rvals)
+function [poly, rvals] = zp2ssg2 (rvals)
 
   ## A. S. Hodel Aug 1996
 
   ## locate imaginary roots (if any)
   cidx = find(imag(rvals));
 
   if(!isempty(cidx))
     ## select first complex root, omit from cidx
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -47,17 +47,17 @@
 ##         1: y_1
 ## zero-pole form:
 ## 1 (s - 1) (s + 1)
 ## -----------------
 ## s (s + 2) (s + 2)
 ## @end example
 ## @end deftypefn
  
-function  outsys = zp2sys (zer,pol,k,tsam,inname,outname)
+function outsys = zp2sys (zer, pol, k, tsam, inname, outname)
 
   ## Modified by John Ingram  July 20, 1996  
 
   ## Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
 
diff --git a/scripts/control/zp2tf.m b/scripts/control/zp2tf.m
--- a/scripts/control/zp2tf.m
+++ b/scripts/control/zp2tf.m
@@ -26,24 +26,23 @@
 ## function.  Complex values should appear in conjugate pairs
 ## @item k
 ## real scalar (leading coefficient)
 ## @end table
 ## @code{[num,den] = zp2tf(zer,pol,k)} forms the transfer function 
 ## @code{num/den} from the vectors of poles and zeros.
 ## @end deftypefn
 
-function [num,den] = zp2tf(zer,pol,k)
+function [num, den] = zp2tf (zer, pol, k)
 
   ## Find out whether data was entered as a row or a column vector and
   ## convert to a column vector if necessary
   ## Written by A. S. Hodel with help from students Ingram, McGowan.
   ## a.s.hodel@eng.auburn.edu
 
-
   [rp,cp] = size(pol);
   [rz,cz] = size(zer);
 
   if(!(is_vector(zer) | isempty(zer)) )
     error(sprintf("zer(%dx%d) must be a vector",rz,cz));
   elseif(!(is_vector(pol) | isempty(pol)) )
     error(sprintf("pol(%dx%d) must be a vector",rp,cp));
   elseif(length(zer) > length(pol))
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File } { } zpout (@var{zer}, @var{pol}, @var{k}@{, @var{x}@})
 ##  print formatted zero-pole form to the screen.  
 ## @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 
 ##  See also: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 ##	filter, polyderiv, polyinteg, polyout 
 
-function zpout(zer,pol,k,x)
+function zpout (zer, pol, k, x)
 
   ## Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
     usage("zpout(zer,pol,k[,x])");
