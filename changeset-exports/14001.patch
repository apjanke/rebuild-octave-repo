# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1323205757 28800
#      Tue Dec 06 13:09:17 2011 -0800
# Node ID 5f0bb45e615c0732adcda1a420c30b85d265403c
# Parent  15400d5deb1c249d44b54774b66011095c9710d8
doc: Update documentation for functions returning a graphics handle h (Bug #34761)

* voronoi.m, image.m, imagesc.m, imshow.m, area.m, bar.m, barh.m, clabel.m,
clf.m, compass.m, ezcontour.m, ezcontourf.m, ezmesh.m, ezmeshc.m, ezplot.m,
ezplot3.m, ezpolar.m, ezsurf.m, ezsurfc.m, feather.m, fill.m, findall.m,
findobj.m, loglog.m, mesh.m, pareto.m, patch.m, pie.m, pie3.m, plot.m, polar.m,
quiver.m, quiver3.m, rectangle.m, ribbon.m, rose.m, scatter.m, scatter3.m,
semilogx.m, semilogy.m, slice.m, stem.m, surf.m, surface.m, text.m, title.m,
trimesh.m, triplot.m, trisurf.m, xlabel.m, ylabel.m, zlabel.m:
Update documentation for functions returning a graphics handle h.

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-ff549c078493ea86e7bd87526db276a1b94a411a gnulib
+bb052d4a7416accaad0747e84bd2a0accbfcf923 gnulib
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -31,17 +31,17 @@
 ## diagram is drawn on the specified axis rather than in a new figure.
 ##
 ## The @var{options} argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
-## plotted and a graphics handle to the plot is returned.
+## plotted and a graphics handle @var{h} to the plot is returned.
 ## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the Voronoi vertices
 ## instead of plotting the diagram.
 ##
 ## @example
 ## @group
 ##   x = rand (10, 1);
 ##   y = rand (size (x));
 ##   h = convhull (x, y);
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -14,32 +14,35 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} image (@var{img})
 ## @deftypefnx {Function File} {} image (@var{x}, @var{y}, @var{img})
+## @deftypefnx {Function File} {@var{h} =} image (@dots{})
 ## Display a matrix as a color image.  The elements of @var{img} are indices
 ## into the current colormap, and the colormap will be scaled so that the
 ## extremes of @var{img} are mapped to the extremes of the colormap.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 ##
 ## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
 ## @code{ydir} property to @code{"reverse"}.  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
 ## using, for example, @code{flipud (ydata,1)}.
+##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = image (varargin)
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -27,16 +27,17 @@
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
 ## range is set to the 'clim' of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{A}.
 ##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = imagesc (varargin)
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -18,16 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} imshow (@var{im})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{limits})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{map})
 ## @deftypefnx {Function File} {} imshow (@var{rgb}, @dots{})
 ## @deftypefnx {Function File} {} imshow (@var{filename})
 ## @deftypefnx {Function File} {} imshow (@dots{}, @var{string_param1}, @var{value1}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} imshow (@dots{})
 ## Display the image @var{im}, where @var{im} can be a 2-dimensional
 ## (gray-scale image) or a 3-dimensional (RGB image) matrix.
 ##
 ## If @var{limits} is a 2-element vector @code{[@var{low}, @var{high}]},
 ## the image is shown using a display range between @var{low} and
 ## @var{high}.  If an empty matrix is passed for @var{limits}, the
 ## display range is computed as the range between the minimal and the
 ## maximal value in the image.
@@ -39,16 +40,18 @@
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
 ## @var{value1}.  @var{string_param1} can be any of the following:
 ## @table @asis
 ## @item "displayrange"
 ## @var{value1} is the display range as described above.
 ## @end table
+##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
 
 ## Author: Stefan van der Walt  <stefan@sun.ac.za>
 ## Author: Soren Hauberg <hauberg at gmail dot com>
 ## Adapted-By: jwe
 
 function h = imshow (im, varargin)
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -28,19 +28,21 @@
 ## contributions of a value to a sum, and is functionally similar to
 ## @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the area under
 ## the curve is shaded.
 ##
 ## If the @var{x} argument is omitted it is assumed to be given by
 ## @code{1 : rows (@var{y})}.  A value @var{lvl} can be defined that determines
 ## where the base level of the shading under the curve should be defined.
 ##
-## Additional arguments to the @code{area} function are passed to the
-## @code{patch}.  The optional return value @var{h} provides a handle to
-## area series object representing the patches of the areas.
+## Additional arguments to the @code{area} function are passed to
+## @code{patch}.
+##
+## The optional return value @var{h} is a graphics handle to the hggroup
+## object representing the area patch objects.
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
 
   if (nargin > 0)
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -31,17 +31,17 @@
 ## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
-## The optional return value @var{h} provides a handle to the "bar series"
+## The optional return value @var{h} is a handle to the created "bar series"
 ## object with one handle per column of the variable @var{y}.  This
 ## series allows common elements of the group of bar series objects to
 ## be changed in a single bar series and the same properties are changed
 ## in the other "bar series".  For example,
 ##
 ## @example
 ## @group
 ## h = bar (rand (5, 10));
@@ -88,8 +88,12 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = bar (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (true, "bar", varargin{:});
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/barh.m b/scripts/plot/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/barh.m
@@ -31,24 +31,28 @@
 ## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
-## The optional return value @var{h} provides a handle to the bar series
-## object.  See @code{bar} for a description of the use of the bar series.
-##
 ## The optional input handle @var{h} allows an axis handle to be passed.
 ## Properties of the patch graphics object can be changed using
 ## @var{prop}, @var{val} pairs.
 ##
+## The optional return value @var{h} is a graphics handle to the created
+## bar series object.  See @code{bar} for a description of the use of the
+## bar series.
 ## @seealso{bar, plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = barh (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (false, "barh", varargin{:});
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -34,19 +34,20 @@
 ## the contours to label can be selected with the mouse.
 ##
 ## Additional property/value pairs that are valid properties of text objects
 ## can be given and are passed to the underlying text objects.  Additionally,
 ## the property "LabelSpacing" is available allowing the spacing between labels
 ## on a contour (in points) to be specified.  The default is 144 points, or 2
 ## inches.
 ##
-## The returned value @var{h} is the set of text object that represent the
-## contour labels.  The "userdata" property of the text objects contains the
-## numerical value of the contour label.
+## The optional return value @var{h} is a vector of graphics handles to
+## the text objects representing each label.  
+## The "userdata" property of the text objects contains the numerical value of
+## the contour label.
 ##
 ## An example of the use of @code{clabel} is
 ##
 ## @example
 ## @group
 ## [c, h] = contour (peaks(), -4 : 6);
 ## clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
 ## @end group
@@ -123,17 +124,19 @@ function retval = clabel (c, varargin)
     if (! isempty (varargin))
       set (retval, varargin {:});
     endif
   else
     retval =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
   endif
 endfunction
 
-%!demo
-%! clf
-%! [c, h] = contour (peaks(), -4 : 6);
-%! clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
 
 %!demo
 %! clf
-%! [c, h] = contourf (peaks(), -7 : 6);
-%! clabel (c, h, -6 : 2 : 6, 'fontsize', 12);
+%! [c, h] = contour (peaks(), -4:6);
+%! clabel (c, h, -4:2:6, "fontsize", 12);
+
+%!demo
+%! clf
+%! [c, h] = contourf (peaks(), -7:6);
+%! clabel (c, h, -6:2:6, "fontsize", 12);
+
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -21,18 +21,20 @@
 ## @deftypefnx {Function File} {} clf ("reset")
 ## @deftypefnx {Function File} {} clf (@var{hfig})
 ## @deftypefnx {Function File} {} clf (@var{hfig}, "reset")
 ## @deftypefnx {Function File} {@var{h} =} clf (@dots{})
 ## Clear the current figure window.  @code{clf} operates by deleting child
 ## graphics objects with visible handles (@code{handlevisibility} = on).
 ## If @var{hfig} is specified operate on it instead of the current figure.
 ## If the optional argument @code{"reset"} is specified, all objects including
-## those with hidden handles are deleted.  If an output value is
-## requested, return the handle of the figure window that was cleared.
+## those with hidden handles are deleted.
+## 
+## The optional return value @var{h} is the graphics handle of the figure
+## window that was cleared.
 ## @seealso{cla, close, delete}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = clf (varargin)
 
   if (nargin > 2)
@@ -77,16 +79,17 @@ function retval = clf (varargin)
   delete (hc);
 
   if (nargout > 0)
     retval = hfig;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (!isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
@@ -94,8 +97,9 @@ endfunction
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -26,27 +26,27 @@
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
 ## from the origin of a polar plot.  If a single complex argument @var{z} is
 ## given, then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag
 ## (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
-## a = toeplitz([1;randn(9,1)],[1,randn(1,9)]);
+## a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
 ## compass (eig (a))
 ## @end group
 ## @end example
 ##
-## @seealso{plot, polar, quiver, feather}
+## @seealso{polar, quiver, feather, plot}
 ## @end deftypefn
 
 function retval = compass (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("compass", varargin{:});
 
   arrowsize = 0.25;
 
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -30,18 +30,17 @@
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -56,11 +55,13 @@ function retval = ezcontour (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontour (f, [-3, 3]);
+
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -30,18 +30,17 @@
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -56,11 +55,12 @@ function retval = ezcontourf (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontourf (f, [-3, 3]);
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -39,18 +39,18 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created 
+## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -60,33 +60,35 @@
 ## @group
 ## fx = @@(s,t) cos (s) .* cos(t);
 ## fy = @@(s,t) sin (s) .* cos(t);
 ## fz = @@(s,t) sin(t);
 ## ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezsurf, ezsurfc, ezmeshc}
+## @seealso{ezplot, ezmeshc, ezsurf, ezsurfc}
 ## @end deftypefn
 
 function retval = ezmesh (varargin)
 
   [h, needusage] = __ezplot__ ("mesh", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmesh (f, [-3, 3]);
 
 %!demo
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezmesh (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
+
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -39,18 +39,19 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a 2-element vector with a graphics
+## handle for the created mesh plot and a second handle for the created contour
+## plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -65,11 +66,13 @@ function retval = ezmeshc (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmeshc (f, [-3, 3]);
+
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -56,18 +56,17 @@
 ## value of @var{x}, @var{y} and @var{t}.  If it is a four element
 ## vector, then the minimum and maximum values of @var{x} and @var{t}
 ## are determined by the first two elements and the minimum and maximum
 ## of @var{y} by the second pair of elements.
 ##
 ## @var{n} is a scalar defining the number of points to use in plotting
 ## the function.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the line objects plotted.
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @seealso{plot, ezplot3}
 ## @end deftypefn
 
 function retval = ezplot (varargin)
 
   [h, needusage] = __ezplot__ ("plot", varargin{:});
 
@@ -75,16 +74,18 @@ function retval = ezplot (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! ezplot (@cos, @sin)
 
 %!demo
 %! ezplot ("1/x")
 
 %!demo
-%! ezplot (inline("x^2 - y^2 = 1"))
+%! ezplot (inline ("x^2 - y^2 = 1"))
+
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -27,18 +27,17 @@
 ## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions
 ## or function handles with one arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{t}.  @var{n} is a scalar defining the number of points to use.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## fx = @@(t) cos (t);
 ## fy = @@(t) sin (t);
 ## fz = @@(t) t;
 ## ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 ## @end group
@@ -55,13 +54,15 @@ function retval = ezplot3 (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! fx = @(t) cos (t);
 %! fy = @(t) sin (t);
 %! fz = @(t) t;
 %! ezplot3 (fx, fy, fz, [0, 10*pi], 100);
+
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -27,18 +27,17 @@
 ## a string, inline function or function handle with one arguments defining
 ## the function.  By default the plot is over the domain @code{0 < @var{x} <
 ## 2*pi} with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{t}.  @var{n} is a scalar defining the number of points to
 ## use.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## ezpolar (@@(t) 1 + sin (t));
 ## @end example
 ##
 ## @seealso{polar, ezplot, ezsurf, ezmesh}
 ## @end deftypefn
 
@@ -50,10 +49,12 @@ function retval = ezpolar (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! ezpolar (@(t) 1 + sin (t));
+
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -39,18 +39,18 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -76,17 +76,19 @@ function retval = ezsurf (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurf (f, [-3, 3]);
 
 %!demo
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
+
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -39,18 +39,19 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a 2-element vector with a graphics
+## for the created surface plot and a second handle for the created contour
+## plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -65,11 +66,13 @@ function retval = ezsurfc (varargin)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
 endfunction
 
+
 %!demo
 %! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurfc (f, [-3, 3]);
+
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -26,18 +26,18 @@
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
 ## from equidistant points on the x-axis.  If a single complex argument
 ## @var{z} is given, then @code{@var{u} = real (@var{z})} and
 ## @code{@var{v} = imag (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## phi = [0 : 15 : 360] * pi / 180;
 ## feather (sin (phi), cos (phi))
 ## @end group
 ## @end example
 ##
@@ -104,11 +104,13 @@ function retval = feather (varargin)
   end_unwind_protect
 
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
+
 %!demo
 %! phi = [0 : 15 : 360] * pi / 180;
 %! feather (sin (phi), cos (phi))
+
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -17,17 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fill (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} fill (@var{x1}, @var{y1}, @var{c1}, @var{x2}, @var{y2}, @var{c2})
 ## @deftypefnx {Function File} {} fill (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} fill (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} fill (@dots{})
-## Create one or more filled patch objects, returning a patch object for each.
+## Create one or more filled patch objects.
+##
+## The optional return value @var{h} is an array of graphics handles to
+## the created patch objects.
+## @seealso{patch}
 ## @end deftypefn
 
 function retval = fill (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
 
   htmp = [];
   iargs = __find_patches__ (varargin{:});
@@ -109,17 +113,19 @@ function iargs = __find_patches__ (varar
         else
           i += 2;
         endif
       endwhile
     endif
   endwhile
 endfunction
 
+
 %!demo
 %! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
-%! h = fill(x1,y1,'r',x2,y2,'g');
+%! t1 = (1/16:1/8:1)*2*pi;
+%! t2 = ((1/16:1/8:1) + 1/32)*2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
+%! h = fill (x1,y1,'r', x2,y2,'g');
+
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findall ()
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, "-depth", @var{d}, @dots{})
-## Find object with specified property values including hidden handles.
+## Find graphics object with specified property values including hidden handles.
 ##
 ## This function performs the same function as @code{findobj}, but it
 ## includes hidden objects in its search.  For full documentation, see
 ## @code{findobj}.
 ## @seealso{get, set, findobj, allchild}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findobj ()
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{prop_name})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{prop_name}, @var{pattern})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
-## Find object with specified property values.  The simplest form is
+## Find graphics object with specified property values.  The simplest form is
 ##
 ## @example
 ## findobj (@var{prop_name}, @var{prop_Value})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name
 ## @var{prop_name} and the name @var{prop_Value}.  The search can be limited
@@ -238,20 +238,22 @@ function h = findobj (varargin)
       endfor
     endfor
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   obj = findobj (hf, "type", "line");
 %!   assert (l, obj);
 %!   assert (gca, findobj (hf, "type", "axes"));
 %!   assert (hf, findobj (hf, "type", "figure"));
 %!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} loglog (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} loglog (@dots{})
 ## Produce a two-dimensional plot using log scales for both axes.  See
 ## the documentation of @code{plot} for a description of the arguments
 ## that @code{loglog} will accept.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, semilogy}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -27,16 +27,19 @@
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ##
 ## The color of the mesh is derived from the @code{colormap}
 ## and the value of @var{z}.  Optionally the color of the mesh can be
 ## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## suface object.
 ## @seealso{colormap, contour, meshgrid, surf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = mesh (varargin)
 
   newplot ();
@@ -53,8 +56,12 @@ function h = mesh (varargin)
          "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -36,24 +36,28 @@
 ## of the result.  Thus, targeting these "major causes" for elimination
 ## results in the most cost-effective improvement scheme.
 ##
 ## The data are passed as @var{x} and the abscissa as @var{y}.  If @var{y} is
 ## absent, then the abscissa are assumed to be @code{1 : length (@var{x})}.
 ## @var{y} can be a string array, a cell array of strings or a numerical
 ## vector.
 ##
+## The optional return value @var{h} is a 2-element vector with a graphics
+## handle for the created bar plot and a second handle for the created line
+## plot.
+##
 ## An example of the use of @code{pareto} is
 ##
 ## @example
 ## @group
 ## Cheese = @{"Cheddar", "Swiss", "Camembert", ...
 ##           "Munster", "Stilton", "Blue"@};
 ## Sold = [105, 30, 70, 10, 15, 20];
-## pareto(Sold, Cheese);
+## pareto (Sold, Cheese);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function h = pareto (varargin)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
@@ -94,23 +98,25 @@ function h = pareto (varargin)
   set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
 
   if (nargout > 0)
     h = [hbar; hline];
   endif
 
 endfunction
 
+
 %!demo
 %! clf
-%! colormap (jet (64))
+%! colormap (jet (64));
 %! Cheese = {"Cheddar", "Swiss", "Camembert", "Munster", "Stilton", "Blue"};
 %! Sold = [105, 30, 70, 10, 15, 20];
-%! pareto(Sold, Cheese);
+%! pareto (Sold, Cheese);
 
 %!demo
 %! clf
 %! % Suppose that we want establish which products makes 80 % of turnover.
 %! Codes = {"AB4","BD7","CF8","CC5","AD11","BB5","BB3","AD8","DF3","DE7"};
 %! Value = [2.35 7.9 2.45 1.1 0.15 13.45 5.4 2.05 0.85  1.65]';
 %! SoldUnits = [54723 41114 16939 1576091 168000 687197 120222 168195, ...
 %!              1084118 55576]';
 %! pareto (Value.*SoldUnits, Codes);
+
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -30,16 +30,20 @@
 ##
 ## For a uniform colored patch, @var{c} can be given as an RGB vector,
 ## scalar value referring to the current colormap, or string value (for
 ## example, "r" or "red").
 ##
 ## If passed a structure @var{fv} contain the fields "vertices", "faces"
 ## and optionally "facevertexcdata", create the patch based on these
 ## properties.
+##
+## The optional return value @var{h} is a graphics handle to the created patch
+## object.
+## @seealso{fill}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = patch (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
 
@@ -55,161 +59,161 @@ function retval = patch (varargin)
 
 endfunction
 
 %!demo
 %! ## Patches with same number of vertices
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
 %! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! patch([x1,x2],[y1,y2],'r');
 
 %!demo
 %! ## Unclosed patch
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
 %! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! patch([[x1;NaN(8,1)],x2],[[y1;NaN(8,1)],y2],'r');
 
 %!demo
 %! ## Specify vertices and faces separately
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
 %! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
 %! patch('Faces',fac,'Vertices',vert,'FaceColor','r');
 
 %!demo
 %! ## Specify vertices and faces separately
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
 %! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
 %! patch('Faces',fac,'Vertices',vert,'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
 
 %!demo
 %! ## Property change on multiple patches
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
 %! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! h = patch([x1,x2],[y1,y2],cat (3,[0,0],[1,0],[0,1]));
 %! pause (1);
 %! set (h, 'FaceColor', 'r');
 
 %!demo
 %! clf
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch('Vertices', vertices, 'Faces', faces, ...
-%!       'FaceVertexCData', jet(4), 'FaceColor', 'flat')
-%! view (-37.5, 30)
+%! patch ('Vertices', vertices, 'Faces', faces, ...
+%!        'FaceVertexCData', jet(4), 'FaceColor', 'flat');
+%! view (-37.5, 30);
 
 %!demo
 %! clf
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch('Vertices', vertices, 'Faces', faces, ...
-%!       'FaceVertexCData', jet(5), 'FaceColor', 'interp')
-%! view (-37.5, 30)
+%! patch ('Vertices', vertices, 'Faces', faces, ...
+%!        'FaceVertexCData', jet(5), 'FaceColor', 'interp');
+%! view (-37.5, 30);
 
 %!demo
 %! clf
-%! colormap (jet)
+%! colormap (jet);
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1)
-%! title ("Blue, Light-Green, and Red Horizontal Bars")
+%! subplot (2, 1, 1);
+%! title ("Blue, Light-Green, and Red Horizontal Bars");
 %! patch (x, y + 0, 1);
 %! patch (x, y + 1, 2);
 %! patch (x, y + 2, 3);
-%! subplot (2, 1, 2)
-%! title ("Blue, Light-Green, and Red Vertical Bars")
+%! subplot (2, 1, 2);
+%! title ("Blue, Light-Green, and Red Vertical Bars");
 %! patch (x + 0, y, 1 * ones (size (x)));
 %! patch (x + 1, y, 2 * ones (size (x)));
 %! patch (x + 2, y, 3 * ones (size (x)));
 
 %!demo
 %! clf
-%! colormap (jet)
+%! colormap (jet);
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1)
-%! title ("Blue horizontal bars: Dark to Light")
+%! subplot (2, 1, 1);
+%! title ("Blue horizontal bars: Dark to Light");
 %! patch (x, y + 0, 1, "cdatamapping", "direct");
 %! patch (x, y + 1, 9, "cdatamapping", "direct");
 %! patch (x, y + 2, 17, "cdatamapping", "direct");
-%! subplot (2, 1, 2)
+%! subplot (2, 1, 2);
 %! title ("Blue vertical bars: Dark to Light")
 %! patch (x + 0, y, 1 * ones (size (x)), "cdatamapping", "direct");
 %! patch (x + 1, y, 9 * ones (size (x)), "cdatamapping", "direct");
 %! patch (x + 2, y, 17 * ones (size (x)), "cdatamapping", "direct");
 
 %!demo
 %! clf;
 %! colormap (jet);
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, "facecolor", "b");
-%! title ("Two blue triangles")
-%! set (p, "cdatamapping", "direct", "facecolor", "flat", "cdata", [1 32])
-%! title ("Direct mapping of colors: Light-Green UL and Blue LR triangles")
+%! title ("Two blue triangles");
+%! set (p, "cdatamapping", "direct", "facecolor", "flat", "cdata", [1 32]);
+%! title ("Direct mapping of colors: Light-Green UL and Blue LR triangles");
 
 %!demo
 %! clf;
 %! colormap (jet);
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, [1 32]);
-%! title ("Autoscaling of colors: Red UL and Blue LR triangles")
+%! title ("Autoscaling of colors: Red UL and Blue LR triangles");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = patch;
 %!   assert (findobj (hf, "type", "patch"), h);
 %!   assert (get (h, "xdata"), [0; 1; 0], eps);
 %!   assert (get (h, "ydata"), [1; 1; 0], eps);
-%!   assert (isempty(get (h, "zdata")));
-%!   assert (isempty(get (h, "cdata")));
+%!   assert (isempty (get (h, "zdata")));
+%!   assert (isempty (get (h, "cdata")));
 %!   assert (get (h, "faces"), [1, 2, 3], eps);
 %!   assert (get (h, "vertices"), [0 1; 1 1; 0 0], eps);
 %!   assert (get (h, "type"), "patch");
 %!   assert (get (h, "facecolor"), [0 0 0]);
 %!   assert (get (h, "linestyle"), get (0, "defaultpatchlinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultpatchlinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultpatchmarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultpatchmarkersize"));
@@ -223,8 +227,9 @@ endfunction
 %! unwind_protect
 %!   h = patch ([0 1 0], [0 1 1], c);
 %!   assert (get (gca, "clim"), [c - 1, c + 1]);
 %!   h = patch ([0 1 0], [0 1 1], 2 * c);
 %!   assert (get (gca, "clim"), [c, 2 * c]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -17,29 +17,30 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie (@var{x})
 ## @deftypefnx {Function File} {} pie (@var{x}, @var{explode})
 ## @deftypefnx {Function File} {} pie (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie (@var{h}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
-## Produce a pie chart.
+## Produce a 2-D pie chart.
 ##
 ## Called with a single vector argument, produces a pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
-## The optional return value @var{h} provides a handle to the patch object.
+## The optional return value @var{h} is a list of handles to the patch
+## and text objects generating the plot.
 ##
 ## @seealso{pie3, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie (varargin)
@@ -60,22 +61,24 @@ function retval = pie (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! pie ([3, 2, 1], [0, 0, 1]);
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
 %! pie ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
 %! pie ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
-%! title ("missing slice");
\ No newline at end of file
+%! title ("missing slice");
+
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -30,18 +30,18 @@
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
-## The optional return value @var{h} provides a handle list to patch, surface
-## and text objects generating this plot.
+## The optional return value @var{h} is a list of graphics handles to the patch,
+## surface, and text objects generating the plot.
 ##
 ## @seealso{pie, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie3 (varargin)
@@ -62,22 +62,24 @@ function retval = pie3 (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
 %! pie3 ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
 %! pie3 ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 %! title ("missing slice");
+
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -168,16 +168,18 @@
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ##
 ## If the first argument is an axis handle, then plot into these axes,
 ## rather than the current axis handle returned by @code{gca}.
 ##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
 ## stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
@@ -196,8 +198,12 @@ function retval = plot (varargin)
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -16,20 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polar (@var{theta}, @var{rho})
 ## @deftypefnx {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## @deftypefnx {Function File} {} polar (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} polar (@dots{})
-## Make a two-dimensional plot given the polar coordinates @var{theta} and
+## Create a two-dimensional plot from polar coordinates @var{theta} and
 ## @var{rho}.
 ##
-## The optional third argument specifies the line type.
+## The optional argument @var{fmt} specifies the line format.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -29,28 +29,28 @@
 ## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] =
 ## size(@var{u})}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
-##  the arrows of the field relative to the mesh spacing.  A value of 0
+## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
-## The optional return value @var{h} provides a quiver group that
-## regroups the components of the quiver plot (body, arrow and marker),
-## and allows them to be changed together
+## The optional return value @var{h} is a graphics handle to a quiver object.
+## A quiver object regroups the components of the quiver plot (body, arrow,
+## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y] = meshgrid (1:2:20);
 ## h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
 ## set (h, "maxheadsize", 0.33);
 ## @end group
 ## @end example
@@ -76,19 +76,23 @@ function retval = quiver (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! clf
-%! [x,y] = meshgrid(1:2:20);
-%! h = quiver(x,y,sin(2*pi*x/10),sin(2*pi*y/10));
+%! [x,y] = meshgrid (1:2:20);
+%! h = quiver (x,y, sin (2*pi*x/10), sin (2*pi*y/10));
 %! set (h, "maxheadsize", 0.33);
 
 %!demo
-%! axis("equal");
-%! x=linspace(0,3,80); y=sin(2*pi*x); theta=2*pi*x+pi/2;
-%! quiver(x,y,sin(theta)/10,cos(theta)/10);
+%! axis ("equal");
+%! x = linspace (0,3,80);
+%! y = sin (2*pi*x);
+%! theta = 2*pi*x + pi/2;
+%! quiver (x, y, sin (theta)/10, cos (theta)/10);
 %! hold on; plot(x,y,"r"); hold off;
+
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -38,19 +38,19 @@
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
-## The optional return value @var{h} provides a quiver group that
-## regroups the components of the quiver plot (body, arrow and marker),
-## and allows them to be changed together
+## The optional return value @var{h} is a graphics handle to a quiver object.
+## A quiver object regroups the components of the quiver plot (body, arrow,
+## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (25);
 ## surf (x, y, z);
 ## hold on;
 ## [u, v, w] = surfnorm (x, y, z / 10);
 ## h = quiver3 (x, y, z, u, v, w);
@@ -81,23 +81,23 @@ function retval = quiver3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!demo
 %! clf
-%! colormap (jet (64))
-%! [x,y]=meshgrid (-1:0.1:1);
-%! z=sin(2*pi*sqrt(x.^2+y.^2));
-%! theta=2*pi*sqrt(x.^2+y.^2)+pi/2;
-%! quiver3(x,y,z,sin(theta),cos(theta),ones(size(z)));
+%! colormap (jet (64));
+%! [x,y] = meshgrid (-1:0.1:1);
+%! z = sin (2*pi * sqrt (x.^2+y.^2));
+%! theta = 2*pi * sqrt (x.^2+y.^2) + pi/2;
+%! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold on;
-%! mesh(x,y,z);
+%! mesh (x,y,z);
 %! hold off;
 
 %!demo
 %! clf
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -39,19 +39,20 @@
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
 ## min (pos (1:2)) / max (pos (1:2)) * curv
 ## @end example
 ##
-## Other properties are passed to the underlying patch command.  If called
-## with an output argument, @code{rectangle} returns the handle to the
-## rectangle.
+## Other properties are passed to the underlying patch command. 
+## 
+## The optional return value @var{h} is a graphics handle to the created
+## rectangle object.
 ## @end deftypefn
 ## @seealso{patch}
 
 function h = rectangle (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("rectangle", varargin{:});
 
   tmp =  __rectangle__ (hax, varargin{:});
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -18,19 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ribbon (@var{x}, @var{y}, @var{width})
 ## @deftypefnx {Function File} {} ribbon (@var{y})
 ## @deftypefnx {Function File} {@var{h} =} ribbon (@dots{})
 ## Plot a ribbon plot for the columns of @var{y} vs.  @var{x}.  The
 ## optional parameter @var{width} specifies the width of a single ribbon
 ## (default is 0.75).  If @var{x} is omitted, a vector containing the
-## row numbers is assumed (1:rows(Y)).  If requested, return a vector
-## @var{h} of the handles to the surface objects.
-## @seealso{gca, colorbar}
+## row numbers is assumed (1:rows(Y)).
+##
+## The optional return value @var{h} is a vector of graphics handles to
+## the surface objects representing each ribbon.
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
 function h = ribbon (x, y, width)
 
   newplot ();
 
@@ -80,12 +81,14 @@ function h = ribbon (x, y, width)
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
+
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -25,32 +25,31 @@
 ## Plot an angular histogram.  With one vector argument @var{th}, plots the
 ## histogram with 20 angular bins.  If @var{th} is a matrix, then each column
 ## of @var{th} produces a separate histogram.
 ##
 ## If @var{r} is given and is a scalar, then the histogram is produced with
 ## @var{r} bins.  If @var{r} is a vector, then the center of each bin are
 ## defined by the values of @var{r}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing each histogram.
 ##
-## If two output arguments are requested, then rather than plotting the
+## If two output arguments are requested then, rather than plotting the
 ## histogram, the polar vectors necessary to plot the histogram are
 ## returned.
 ##
 ## @example
 ## @group
 ## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
 ## polar (r, t);
 ## @end group
 ## @end example
 ##
-##
-## @seealso{plot, compass, polar, hist}
+## @seealso{polar, compass, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose",
                                                 varargin{:});
 
   if (nargin < 1)
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -39,17 +39,18 @@
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
 ## If the argument @code{"filled"} is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
-## The optional return value @var{h} provides a handle to the patch object
+## The optional return value @var{h} is a graphics handle to the hggroup
+## object representing the points.
 ##
 ## @example
 ## @group
 ## x = randn (100, 1);
 ## y = randn (100, 1);
 ## scatter (x, y, [], sqrt(x.^2 + y.^2));
 ## @end group
 ## @end example
@@ -84,17 +85,17 @@ endfunction
 %!demo
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! scatter (x, y, "r");
 
 %!demo
 %! x = randn (100, 1);
 %! y = randn (100, 1);
-%! scatter (x, y, [], sqrt(x.^2 + y.^2));
+%! scatter (x, y, [], sqrt (x.^2 + y.^2));
 
 %!demo
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
 %! y = rand_10x1_data2;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, s, s, "s", "filled");
@@ -112,13 +113,14 @@ endfunction
 %! rand_10x1_data6 = [0.37460, 0.25027, 0.19510, 0.51182, 0.54704, 0.56087, 0.24853, 0.75443, 0.42712, 0.44273];
 %! x = rand_10x1_data5;
 %! y = rand_10x1_data6;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, [], "r", "s");
 
 %!demo
 %! n = 500;
-%! x = rand(n,1);
-%! y = rand(n,1);
-%! idx = ceil(rand(n,1)*3);
+%! x = rand (n,1);
+%! y = rand (n,1);
+%! idx = ceil (rand (n,1)*3);
 %! colors = eye(3)(idx, :);
-%! scatter(x,y,15, colors, "filled")
\ No newline at end of file
+%! scatter (x,y,15, colors, "filled");
+
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -36,17 +36,18 @@
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
 ## If the argument 'filled' is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
-## The optional return value @var{h} provides a handle to the patch object
+## The optional return value @var{h} is a graphics handle to the hggroup
+## object representing the points.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
 ## scatter3 (x(:), y(:), z(:), [], z(:));
 ## @end group
 ## @end example
 ##
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogx (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogx (@dots{})
 ## Produce a two-dimensional plot using a logarithmic scale for the @var{x}
 ## axis.  See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogx} will accept.
+## 
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogy, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
@@ -55,64 +57,66 @@ function retval = semilogx (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! semilogx (x, y)
-%! xlabel ('semilogx (x, y)')
+%! subplot (1, 2, 1);
+%! semilogx (x, y);
+%! xlabel ("semilogx (x, y)");
 %!
-%! subplot (1, 2, 2)
-%! semilogx (-x, y)
-%! xlabel ('semilogx (-x, y)')
+%! subplot (1, 2, 2);
+%! semilogx (-x, y);
+%! xlabel ("semilogx (-x, y)");
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! semilogx (x, y)
+%! subplot (1, 2, 1);
+%! semilogx (x, y);
 %! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
 %! xlabel ({"semilogx (x, y)", "xdir = reversed"})
 %!
-%! subplot (1, 2, 2)
-%! semilogx (-x, y)
-%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
-%! xlabel ({"semilogx (-x, y)","xdir = reversed"})
+%! subplot (1, 2, 2);
+%! semilogx (-x, y);
+%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition");
+%! xlabel ({"semilogx (-x, y)", "xdir = reversed"});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   assert (get (gca, "xscale"), "log");
 %!   assert (get (gca, "yscale"), "linear");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   semilogx (a, b)
-%!   axis tight
+%!   semilogx (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogy (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogy (@dots{})
 ## Produce a two-dimensional plot using a logarithmic scale for the @var{y}
 ## axis.  See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogy} will accept.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
@@ -66,56 +68,55 @@ endfunction
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1)
-%! semilogy (x, y)
-%! ylabel ('semilogy (x, y)')
+%! subplot (2, 1, 1);
+%! semilogy (x, y);
+%! ylabel ("semilogy (x, y)");
 %!
-%! subplot (2, 1, 2)
-%! semilogy (x, -y)
-%! ylabel ('semilogy (x, -y)')
+%! subplot (2, 1, 2);
+%! semilogy (x, -y);
+%! ylabel ("semilogy (x, -y)");
 
 %!demo
 %! clf ();
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1)
-%! semilogy (x, y)
-%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
-%! ylabel ({"semilogy (x, y)", "ydir = reversed"})
+%! subplot (2, 1, 1);
+%! semilogy (x, y);
+%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition");
+%! ylabel ({"semilogy (x, y)", "ydir = reversed"});
 %!
-%! subplot (2, 1, 2)
-%! semilogy (x, -y)
-%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
-%! ylabel ({"semilogy (x, -y)", "ydir = reversed"})
+%! subplot (2, 1, 2);
+%! semilogy (x, -y);
+%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition");
+%! ylabel ({"semilogy (x, -y)", "ydir = reversed"});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   semilogy (a, b)
+%!   semilogy (a, b);
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "linear");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   semilogy (a, b)
-%!   axis tight
+%!   semilogy (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
-
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -50,18 +50,19 @@
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
 ## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## The default method is @code{"linear"}.
-## The optional return value @var{h} is a vector of handles to the
-## surface graphic objects.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## [x, y, z] = meshgrid (linspace (-8, 8, 32));
 ## v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 ## slice (x, y, z, v, [], 0, []);
@@ -174,15 +175,19 @@ function h = slice (varargin)
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! [x, y, z] = meshgrid (linspace (-8, 8, 32));
 %! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! slice (x, y, z, v, [], 0, []);
+
+%!demo
 %! [xi, yi] = meshgrid (linspace (-7, 7));
 %! zi = xi + yi;
 %! slice (x, y, z, v, xi, yi, zi);
+
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -42,18 +42,18 @@
 ## y = ones (1, length (x))*2.*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ##
-## The return value of @code{stem} is a vector of "stem series" graphics
-## handles, with one handle per column of the variable @var{y}.  This
+## The optional return value @var{h} is a vector of "stem series" graphics
+## handles with one handle per column of the variable @var{y}.  The
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example,
 ##
 ## @example
 ## @group
 ## x = [0 : 10]';
 ## y = [sin(x), cos(x)]
@@ -81,43 +81,45 @@ function h = stem (varargin)
   tmp = __stem__ (false, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! x = 1:10;
 %! stem (x);
 
 %!demo
 %! x = 1:10;
-%! y = ones (1, length (x))*2.*x;
+%! y = 2*x;
 %! stem (x, y);
 
 %!demo
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
+%! y = 2*x;
 %! h = stem (x, y, "r");
 
 %!demo
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
+%! y = 2*x;
 %! h = stem (x, y, "-.k");
 
 %!demo
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
+%! y = 2*x;
 %! h = stem (x, y, "-.k.");
 
 %!demo
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
+%! y = 2*x;
 %! h = stem (x, y, "filled");
 
 %!demo
 %! x = [0 : 10]';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), "color", "g");
 %! set (h(1), "basevalue", -1)
+
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -27,16 +27,19 @@
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ##
 ## The color of the surface is derived from the @code{colormap} and
 ## the value of @var{z}.  Optionally the color of the surface can be
 ## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ## @seealso{colormap, contour, meshgrid, mesh}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = surf (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
@@ -56,24 +59,26 @@ function retval = surf (varargin)
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! clf
-%! [~,~,Z]=peaks;
-%! surf(Z);
+%! [~,~,Z] = peaks;
+%! surf (Z);
 
 %!demo
-%! [~,~,Z]=sombrero;
-%! [Fx,Fy] = gradient(Z);
-%! surf(Z,Fx+Fy);
+%! [~,~,Z] = sombrero;
+%! [Fx,Fy] = gradient (Z);
+%! surf (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
-%! [X,Y,Z]=sombrero;
-%! [~,Fy] = gradient(Z);
-%! surf(X,Y,Z,Fy);
+%! [X,Y,Z] = sombrero;
+%! [~,Fy] = gradient (Z);
+%! surf (X, Y, Z, Fy);
 %! shading interp;
+
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -28,16 +28,19 @@
 ## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
 ## @var{y} coordinates of the surface.  If @var{x} and @var{y} are vectors,
 ## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
 ## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.  If @var{x} and @var{y}
 ## are missing, they are constructed from size of the matrix @var{z}.
 ##
 ## Any additional properties passed are assigned to the surface.
+## 
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = surface (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
@@ -158,18 +161,17 @@ function [h, bad_usage] = __surface__ (a
 
     if (! ishold ())
       set (ax, "view", [0, 90], "box", "off");
     endif
   endif
 
 endfunction
 
-## Mark file as being tested.  Tests for surface are in
-## surf.m, surfc.m, surfl.m, and pcolor.m
+## Functional tests for surface() are in surf.m, surfc.m, surfl.m, and pcolor.m
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = surface;
 %!   assert (findobj (hf, "type", "surface"), h);
 %!   assert (get (h, "xdata"), 1:3, eps);
 %!   assert (get (h, "ydata"), (1:3)', eps);
@@ -178,8 +180,9 @@ endfunction
 %!   assert (get (h, "type"), "surface");
 %!   assert (get (h, "linestyle"), get (0, "defaultsurfacelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultsurfacelinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultsurfacemarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultsurfacemarkersize"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -12,23 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{label})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{z}, @var{label})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{label}, @var{p1}, @var{v1}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{z}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefn  {Function File} {} text (@var{x}, @var{y}, @var{label})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} text (@dots{})
 ## Create a text object with text @var{label} at position @var{x},
 ## @var{y}, @var{z} on the current axes.  Property-value pairs following
 ## @var{label} may be used to specify the appearance of the text.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = text (varargin)
 
   nargs = nargin;
   offset = 0;
@@ -129,122 +133,122 @@ endfunction
 %! x = [0.25 0.5 0.75];
 %! y = [0.25 0.5 0.75];
 %! for t = 0:30:359;
 %!   for nh = 1:numel(ha)
 %!     for nv = 1:numel(va)
 %!       text (x(nh), y(nv), "Hello World", ...
 %!             "rotation", t, ...
 %!             "horizontalalignment", ha{nh}, ...
-%!             "verticalalignment", va{nv})
+%!             "verticalalignment", va{nv});
 %!     endfor
 %!   endfor
 %! endfor
 %! set (gca, "xtick", [0.25, 0.5, 0.75], ...
 %!           "xticklabel", ha, ...
 %!           "ytick", [0.25, 0.5, 0.75], ...
-%!           "yticklabel", va)
-%! axis ([0 1 0 1])
-%! xlabel ("horizontal alignment")
-%! ylabel ("vertical alignment")
+%!           "yticklabel", va);
+%! axis ([0 1 0 1]);
+%! xlabel ("horizontal alignment");
+%! ylabel ("vertical alignment");
 %! title ("text alignment and rotation (0:30:360 degrees)")
 
 %!demo
 %! clf
 %! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
 %!                  "facecolor", "none", ...
 %!                  "facealpha", 0);
 %! for t = 0:45:359;
 %!   text (25, 25, 0, "Vertical Alignment = Bottom", ...
 %!                    "rotation", t, ...
 %!                    "horizontalalignment", "left", ...
-%!                    "verticalalignment", "bottom")
+%!                    "verticalalignment", "bottom");
 %! endfor
-%! caxis ([-100 100])
-%! title ("Vertically Aligned at Bottom")
+%! caxis ([-100 100]);
+%! title ("Vertically Aligned at Bottom");
 
 %!demo
 %! clf
-%! axis ([0 8 0 8])
-%! title (["1st title";"2nd title"])
-%! xlabel (["1st xlabel";"2nd xlabel"])
-%! ylabel (["1st ylabel";"2nd ylabel"])
+%! axis ([0 8 0 8]);
+%! title (["1st title";"2nd title"]);
+%! xlabel (["1st xlabel";"2nd xlabel"]);
+%! ylabel (["1st ylabel";"2nd ylabel"]);
 %! text (4, 4, {"Hello", "World"}, ...
 %!       "horizontalalignment", "center", ...
-%!       "verticalalignment", "middle")
+%!       "verticalalignment", "middle");
 %! grid on
 
 %!demo
 %! clf
 %! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
 %!                  "facecolor", "none", ...
 %!                  "facealpha", 0);
-%! title (["1st title";"2nd title"])
-%! xlabel (["1st xlabel";"2nd xlabel"])
-%! ylabel (["1st ylabel";"2nd ylabel"])
-%! zlabel (["1st zlabel";"2nd zlabel"])
+%! title (["1st title";"2nd title"]);
+%! xlabel (["1st xlabel";"2nd xlabel"]);
+%! ylabel (["1st ylabel";"2nd ylabel"]);
+%! zlabel (["1st zlabel";"2nd zlabel"]);
 %! text (0, 0, 5, {"Hello", "World"}, ...
 %!       "horizontalalignment", "center", ...
-%!       "verticalalignment", "middle")
-%! hold on
-%! plot3 (0, 0, 5, "+k")
-%!
+%!       "verticalalignment", "middle");
+%! hold on;
+%! plot3 (0, 0, 5, "+k");
 
 %!demo
 %! clf
 %! h = text (0.5, 0.3, "char");
-%! assert ("char", class (get (h, "string")))
+%! assert ("char", class (get (h, "string")));
 %! h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
-%! assert ("char", class (get (h, "string")))
+%! assert ("char", class (get (h, "string")));
 %! h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
-%! assert ("cell", class (get (h, "string")))
+%! assert ("cell", class (get (h, "string")));
 %! h = text (0.5, 0.8, "foobar");
-%! set (h, "string", 1:3)
+%! set (h, "string", 1:3);
 %! h = text ([0.1, 0.1], [0.3, 0.4], "one string & two objects");
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
+%! assert ("char", class (get (h(1), "string")));
+%! assert ("char", class (get (h(2), "string")));
 %! h = text ([0.1, 0.1], [0.5, 0.6], {"one cellstr & two objects"});
-%! assert ("cell", class (get (h(1), "string")))
-%! assert ("cell", class (get (h(2), "string")))
+%! assert ("cell", class (get (h(1), "string")));
+%! assert ("cell", class (get (h(2), "string")));
 %! h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr 1 object 1", "cellstr 2 object 2"});
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
+%! assert ("char", class (get (h(1), "string")));
+%! assert ("char", class (get (h(2), "string")));
 %! h = text ([0.1, 0.1], [0.1, 0.2], ["1st string & 1st object"; "2nd string & 2nd object"]);
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
+%! assert ("char", class (get (h(1), "string")));
+%! assert ("char", class (get (h(2), "string")));
 %! h = text (0.7, 0.6, "single string");
-%! assert ("char", class (get (h, "string")))
+%! assert ("char", class (get (h, "string")));
 %! h = text (0.7, 0.5, {"single cell-string"});
-%! assert ("cell", class (get (h, "string")))
-%! xlabel (1:2)
-%! ylabel (1:2)
-%! title (1:2)
+%! assert ("cell", class (get (h, "string")));
+%! xlabel (1:2);
+%! ylabel (1:2);
+%! title (1:2);
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = text (0.5, 0.3, "char");
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
-%!   assert ("cell", class (get (h, "string")))
+%!   assert ("cell", class (get (h, "string")));
 %!   h = text (0.5, 0.8, "foobar");
-%!   set (h, "string", 1:3)
+%!   set (h, "string", 1:3);
 %!   h = text ([0.1, 0.1], [0.3, 0.4], "one string & two objects");
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.5, 0.6], {"one cellstr & two objects"});
-%!   assert ("cell", class (get (h(1), "string")))
-%!   assert ("cell", class (get (h(2), "string")))
+%!   assert ("cell", class (get (h(1), "string")));
+%!   assert ("cell", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr 1 object 1", "cellstr 2 object 2"});
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.1, 0.2], ["1st string & 1st object"; "2nd string & 2nd object"]);
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text (0.7, 0.6, "single string");
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.7, 0.5, {"single cell-string"});
-%!   assert ("cell", class (get (h, "string")))
+%!   assert ("cell", class (get (h, "string")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -16,17 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} title (@var{string})
 ## @deftypefnx {Function File} {} title (@var{string}, @var{p1}, @var{v1}, @dots{})
 ## @deftypefnx {Function File} {} title (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} title (@dots{})
-## Create a title object and return a handle to it.
+## Create a title object for a plot.
+##
+## The optional return value @var{h} is a graphics handle to the created object.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = title (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
 
@@ -37,43 +39,45 @@ function retval = title (varargin)
   tmp = __axis_label__ (h, "title", varargin{:});
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! clf ();
-%! ax=axes();
-%! xl = get(ax,"title");
-%! title("Testing title")
-%! assert(get(xl,"string"),"Testing title")
+%! ax = axes();
+%! xl = get (ax,"title");
+%! title ("Testing title");
+%! assert (get (xl,"string"), "Testing title");
 
 %!demo
 %! clf ();
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xl = get(gca (), "title");
-%! title("Testing title")
-%! assert(get(xl,"string"),"Testing title")
+%! title ("Testing title");
+%! assert (get (xl,"string"),"Testing title");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   ax=axes();
-%!   xl = get(ax,"title");
-%!   title("Testing title")
-%!   assert(get(xl,"string"),"Testing title")
+%!   ax = axes();
+%!   xl = get (ax,"title");
+%!   title ("Testing title");
+%!   assert (get (xl,"string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
-%!   xl = get(gca (), "title");
-%!   title("Testing title")
-%!   assert(get(xl,"string"),"Testing title")
+%!   xl = get (gca (), "title");
+%!   title("Testing title");
+%!   assert (get (xl,"string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -17,18 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
 ## Plot a triangular mesh in 3D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned
 ## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
-## handle of the plot.
+## @code{(@var{x}, @var{y})}.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{triplot, trisurf, delaunay3}
 ## @end deftypefn
 
 function h = trimesh (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
diff --git a/scripts/plot/triplot.m b/scripts/plot/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/triplot.m
@@ -18,18 +18,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} triplot (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} triplot (@var{tri}, @var{x}, @var{y}, @var{linespec})
 ## @deftypefnx {Function File} {@var{h} =} triplot (@dots{})
 ## Plot a triangular mesh in 2D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned from
 ## @code{delaunay}.  If given, @var{linespec} determines the properties
-## to use for the lines.  The output argument @var{h} is the graphic handle
-## of the plot.
+## to use for the lines. 
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, trimesh, trisurf, delaunay}
 ## @end deftypefn
 
 function h = triplot (tri, x, y, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -17,18 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trisurf (@dots{})
 ## Plot a triangular surface in 3D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned
 ## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
-## handle of the plot.
+## @code{(@var{x}, @var{y})}.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{triplot, trimesh, delaunay3}
 ## @end deftypefn
 
 function h = trisurf (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
@@ -82,24 +83,24 @@ endfunction
 %! tri = delaunay (x(:), y(:));
 %! trisurf (tri, x(:), y(:), z(:));
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z)
+%! trisurf (tri, x, y, z);
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z, "facecolor", "interp")
+%! trisurf (tri, x, y, z, "facecolor", "interp");
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k")
+%! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k");
 
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -18,20 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} xlabel (@var{h}, @var{string})
 ## @deftypefnx {Function File} {@var{h} =} xlabel (@dots{})
 ## @deftypefnx {Function File} {} ylabel (@dots{})
 ## @deftypefnx {Function File} {} zlabel (@dots{})
 ## Specify x-, y-, or z-axis labels for the current axis.  If @var{h} is
-## specified then label the axis defined by @var{h}.  The optional return
-## value @var{h} provides a handle to the created label.
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, title}
+## specified then label the axis defined by @var{h}.
+##
+## The optional return value @var{h} is a graphics handle to the created object.
+## @seealso{title, text}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = xlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
@@ -43,19 +43,21 @@ function retval = xlabel (varargin)
                         "color", get (h, "xcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   x = xlabel ("xlabel_string");
-%!   assert (get(gca, "xlabel"), x);
-%!   assert (get(x, "type"), "text");
-%!   assert (get(x, "visible"), "on");
-%!   assert (get(x, "string"), "xlabel_string");
+%!   assert (get (gca, "xlabel"), x);
+%!   assert (get (x, "type"), "text");
+%!   assert (get (x, "visible"), "on");
+%!   assert (get (x, "string"), "xlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -37,19 +37,21 @@ function retval = ylabel (varargin)
                         "color", get (h, "ycolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   y = ylabel ("ylabel_string");
-%!   assert (get(gca, "ylabel"), y);
-%!   assert (get(y, "type"), "text");
-%!   assert (get(y, "visible"), "on");
-%!   assert (get(y, "string"), "ylabel_string");
+%!   assert (get (gca, "ylabel"), y);
+%!   assert (get (y, "type"), "text");
+%!   assert (get (y, "visible"), "on");
+%!   assert (get (y, "string"), "ylabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -37,32 +37,34 @@ function retval = zlabel (varargin)
                         "color", get (h, "zcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
-%!   assert (get(gca, "zlabel"), z);
-%!   assert (get(z, "type"), "text");
-%!   assert (get(z, "visible"), "off");
-%!   assert (get(z, "string"), "zlabel_string");
+%!   assert (get (gca, "zlabel"), z);
+%!   assert (get (z, "type"), "text");
+%!   assert (get (z, "visible"), "off");
+%!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! plot3 (0, 0, 0);
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
-%!   assert (get(gca, "zlabel"), z);
-%!   assert (get(z, "type"), "text");
-%!   assert (get(z, "visible"), "off");
-%!   assert (get(z, "string"), "zlabel_string");
+%!   assert (get (gca, "zlabel"), z);
+%!   assert (get (z, "type"), "text");
+%!   assert (get (z, "visible"), "off");
+%!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
