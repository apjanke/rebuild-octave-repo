# HG changeset patch
# User Rik <rik@octave.org>
# Date 1467427715 25200
#      Fri Jul 01 19:48:35 2016 -0700
# Node ID 278fc29b69ca9f0c95b824a92e9ac996af6efa0c
# Parent  e67ff2b11147dc9f66f8f409a0fd1833e396ad86
maint: Eliminate unnecessary double newline blocks (only whitespace changes).

* Figure.cc, annotation-dialog.cc, dialog.cc, dialog.h, files-dock-widget.cc,
find-files-dialog.cc, find-files-model.cc, file-editor-tab.cc, file-editor.cc,
find-dialog.cc, octave-qscintilla.cc, octave-txt-lexer.cc, main-window.cc,
main-window.h, octave-cmd.cc, octave-cmd.h, octave-dock-widget.cc,
octave-qt-link.cc, parser.h, webinfo.cc, settings-dialog.cc,
shortcut-manager.cc, shortcut-manager.h, welcome-wizard.cc, workspace-model.cc,
__ilu__.cc, __lin_interpn__.cc, besselj.cc, bsxfun.cc, cellfun.cc, conv2.cc,
data.cc, debug.cc, debug.h, dynamic-ld.cc, fft2.cc, file-io.cc,
ft-text-renderer.cc, gl-render.cc, gl2ps-print.cc, graphics.cc, graphics.in.h,
help.cc, jit-typeinfo.cc, jit-typeinfo.h, kron.cc, ls-ascii-helper.cc,
ls-hdf5.cc, ls-hdf5.h, ls-mat5.cc, max.cc, oct-map.cc, oct-map.h,
oct-stream.cc, octave-link.h, pr-output.cc, pt-jit.cc, qz.cc, sparse-xdiv.cc,
sparse-xpow.cc, strfind.cc, strfns.cc, symtab.h, toplev.cc, toplev.h,
typecast.cc, utils.cc, variables.cc, xdiv.h, xpow.cc, xpow.h, zfstream.cc,
__eigs__.cc, __init_fltk__.cc, audioread.cc, ccolamd.cc, chol.cc, qr.cc,
ov-base-diag.cc, ov-base-int.cc, ov-base-sparse.cc, ov-base.cc, ov-base.h,
ov-bool-mat.cc, ov-bool-mat.h, ov-bool-sparse.cc, ov-bool-sparse.h, ov-bool.cc,
ov-bool.h, ov-builtin.h, ov-cell.cc, ov-cell.h, ov-class.cc, ov-class.h,
ov-classdef.cc, ov-complex.cc, ov-complex.h, ov-cs-list.cc, ov-cs-list.h,
ov-cx-diag.cc, ov-cx-diag.h, ov-cx-mat.cc, ov-cx-mat.h, ov-cx-sparse.cc,
ov-cx-sparse.h, ov-dld-fcn.cc, ov-dld-fcn.h, ov-fcn-handle.h, ov-fcn-inline.h,
ov-float.cc, ov-float.h, ov-flt-complex.cc, ov-flt-complex.h,
ov-flt-cx-diag.cc, ov-flt-cx-diag.h, ov-flt-cx-mat.cc, ov-flt-cx-mat.h,
ov-flt-re-diag.cc, ov-flt-re-diag.h, ov-flt-re-mat.cc, ov-int16.cc,
ov-int32.cc, ov-int64.cc, ov-int8.cc, ov-intx.h, ov-lazy-idx.cc, ov-lazy-idx.h,
ov-mex-fcn.h, ov-null-mat.h, ov-perm.cc, ov-perm.h, ov-range.cc, ov-range.h,
ov-re-diag.cc, ov-re-diag.h, ov-re-mat.cc, ov-re-sparse.cc, ov-re-sparse.h,
ov-scalar.cc, ov-scalar.h, ov-str-mat.h, ov-struct.cc, ov-struct.h,
ov-type-conv.h, ov-uint16.cc, ov-uint32.cc, ov-uint64.cc, ov-uint8.cc,
ov-usr-fcn.cc, ov-usr-fcn.h, ov.h, op-cm-m.cc, op-fcm-fm.cc, op-fm-fm.cc,
op-int.h, op-m-m.cc, op-pm-template.cc, pt-binop.h, pt-select.cc, pt-stmt.cc,
pt-unop.h, Array-util.cc, Array.cc, Array.h, CColVector.cc, CMatrix.cc,
CMatrix.h, CSparse.cc, MArray.cc, MSparse.cc, MatrixType.cc, PermMatrix.cc,
Range.cc, Sparse-C.cc, Sparse.cc, dMatrix.cc, dim-vector.h, fCColVector.cc,
fCMatrix.cc, fMatrix.cc, fMatrix.h, idx-vector.cc, idx-vector.h, blaswrap.c,
f77-fcn.h, DASPK.cc, eigs-base.cc, hess.cc, lo-specfun.cc, oct-fftw.cc,
oct-norm.cc, oct-rand.cc, oct-rand.h, qr.cc, qrp.cc, randmtzig.cc,
randpoisson.cc, sparse-lu.cc, sparse-lu.h, sparse-qr.cc, Sparse-op-defs.h,
mx-inlines.cc, oct-env.h, cmd-edit.cc, f2c-main.c, lo-array-errwarn.cc,
lo-array-errwarn.h, lo-array-gripes.cc, lo-array-gripes.h, lo-ieee.h,
lo-regexp.cc, oct-binmap.h, oct-inttypes.cc, oct-inttypes.h, oct-sort.cc,
oct-sort.h, mkoctfile.in.cc:
maint: Eliminate unnecessary double newline blocks (only whitespace changes).

diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -177,17 +177,16 @@ Figure::Figure (const graphics_object& g
   update (figure::properties::ID_KEYRELEASEFCN);
 
   // modal style
   update (figure::properties::ID_WINDOWSTYLE);
 
   // Visibility
   update (figure::properties::ID_VISIBLE);
 
-
   connect (this, SIGNAL (asyncUpdate (void)),
            this, SLOT (updateContainer (void)));
 
   win->addReceiver (this);
   m_container->addReceiver (this);
 }
 
 Figure::~Figure (void)
diff --git a/libgui/graphics/annotation-dialog.cc b/libgui/graphics/annotation-dialog.cc
--- a/libgui/graphics/annotation-dialog.cc
+++ b/libgui/graphics/annotation-dialog.cc
@@ -55,17 +55,16 @@ annotation_dialog::init ()
   // restore last geometry
   if (settings)
     restoreGeometry (settings->value("annotation/geometry").toByteArray ());
 
   // connect signals
   connect (ui->button_box, SIGNAL (clicked (QAbstractButton *)),
            this, SLOT (button_clicked (QAbstractButton *)));
 
-
   connect (ui->edit_string, SIGNAL (textChanged (const QString&)),
            this, SLOT (edit_string_changed (const QString&)));
 
   connect (ui->btn_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
 
   connect (ui->btn_background_color, SIGNAL (clicked ()),
            this, SLOT (prompt_for_color ()));
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -36,34 +36,32 @@ along with Octave; see the file COPYING.
 #include <QMessageBox>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QPushButton>
 #include <QGroupBox>
 #include <QGridLayout>
 #include <QLabel>
 
+
 QUIWidgetCreator uiwidget_creator;
 
-
 QUIWidgetCreator::QUIWidgetCreator (void)
   : QObject (), dialog_result (-1), dialog_button (),
     string_list (new QStringList ()), list_index (new QIntList ()),
     path_name (new QString ())
 { }
 
-
 QUIWidgetCreator::~QUIWidgetCreator (void)
 {
   delete string_list;
   delete list_index;
   delete path_name;
 }
 
-
 void
 QUIWidgetCreator::dialog_button_clicked (QAbstractButton *button)
 {
   // Wait for link thread to go to sleep state.
   mutex.lock ();
 
   // Store the value so that builtin functions can retrieve.
   if (button)
@@ -73,17 +71,16 @@ QUIWidgetCreator::dialog_button_clicked 
   dialog_result = 1;
 
   mutex.unlock ();
 
   // Wake up Octave process so that it continues.
   waitcondition.wakeAll ();
 }
 
-
 void
 QUIWidgetCreator::list_select_finished (const QIntList& selected,
                                         int button_pressed)
 {
   // Wait for link thread to go to sleep state.
   mutex.lock ();
 
   // Store the value so that builtin functions can retrieve.
@@ -91,17 +88,16 @@ QUIWidgetCreator::list_select_finished (
   dialog_result = button_pressed;
 
   mutex.unlock ();
 
   // Wake up Octave process so that it continues.
   waitcondition.wakeAll ();
 }
 
-
 void
 QUIWidgetCreator::input_finished (const QStringList& input, int button_pressed)
 {
   // Wait for link thread to go to sleep state.
   mutex.lock ();
 
   // Store the value so that builtin functions can retrieve.
   *string_list = input;
@@ -126,18 +122,16 @@ QUIWidgetCreator::filedialog_finished (c
   *path_name = path;
 
   mutex.unlock ();
 
   // Wake up Octave process so that it continues.
   waitcondition.wakeAll ();
 }
 
-
-
 MessageDialog::MessageDialog (const QString& message,
                               const QString& title,
                               const QString& qsicon,
                               const QStringList& qsbutton,
                               const QString& defbutton,
                               const QStringList& role)
   : QMessageBox (QMessageBox::NoIcon, title.isEmpty () ? " " : title,
                  message, 0, 0)
@@ -195,17 +189,16 @@ MessageDialog::MessageDialog (const QStr
             }
         }
     }
 
   connect (this, SIGNAL (buttonClicked (QAbstractButton *)),
            &uiwidget_creator, SLOT (dialog_button_clicked (QAbstractButton *)));
 }
 
-
 ListDialog::ListDialog (const QStringList& list, const QString& mode,
                         int wd, int ht, const QList<int>& initial,
                         const QString& title, const QStringList& prompt,
                         const QString& ok_string, const QString& cancel_string)
   : QDialog (), model (new QStringListModel (list))
 {
   QListView *view = new QListView;
   view->setModel (model);
@@ -318,44 +311,40 @@ ListDialog::buttonOk_clicked (void)
   for (int i = 0; i < selected_index.size (); i++)
     selected_int << selected_index.at (i).row () + 1;
 
   emit finish_selection (selected_int, 1);
 
   done (QDialog::Accepted);
 }
 
-
 void
 ListDialog::buttonCancel_clicked (void)
 {
   // Store information about what button was pressed so that builtin
   // functions can retrieve.
   QIntList empty;
 
   emit finish_selection (empty, 0);
 
   done (QDialog::Rejected);
 }
 
-
 void
 ListDialog::reject (void)
 {
   buttonCancel_clicked ();
 }
 
-
 void
 ListDialog::item_double_clicked (const QModelIndex&)
 {
   buttonOk_clicked ();
 }
 
-
 InputDialog::InputDialog (const QStringList& prompt, const QString& title,
                           const QFloatList& nr, const QFloatList& nc,
                           const QStringList& defaults)
   : QDialog ()
 {
 // FIXME: Why define and then immediately test value?
 #define LINE_EDIT_FOLLOWS_PROMPT 0
 
@@ -415,17 +404,16 @@ InputDialog::InputDialog (const QStringL
   connect (buttonCancel, SIGNAL (clicked ()),
            this, SLOT (buttonCancel_clicked ()));
 
   connect (this, SIGNAL (finish_input (const QStringList&, int)),
            &uiwidget_creator,
            SLOT (input_finished (const QStringList&, int)));
 }
 
-
 void
 InputDialog::buttonOk_clicked (void)
 {
   // Store information about what button was pressed so that builtin
   // functions can retrieve.
   QStringList string_result;
   for (int i = 0; i < input_line.size (); i++)
     string_result << input_line.at (i)->text ();
@@ -438,17 +426,16 @@ InputDialog::buttonCancel_clicked (void)
 {
   // Store information about what button was pressed so that builtin
   // functions can retrieve.
   QStringList empty;
   emit finish_input (empty, 0);
   done (QDialog::Rejected);
 }
 
-
 void
 InputDialog::reject (void)
 {
   buttonCancel_clicked ();
 }
 
 FileDialog::FileDialog (const QStringList& name_filters, const QString& title,
                         const QString& filename, const QString& dirname,
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -158,17 +158,16 @@ private:
   QIntList *list_index;
 
   QString *path_name;
 
 };
 
 extern QUIWidgetCreator uiwidget_creator;
 
-
 class MessageDialog : public QMessageBox
 {
   Q_OBJECT
 
 public:
 
   explicit MessageDialog (const QString& message, const QString& title,
                           const QString& icon, const QStringList& button,
@@ -180,17 +179,16 @@ private:
   void closeEvent (QCloseEvent *)
   {
     // Reroute the close tab to a button click so there is only a single
     // route to waking the wait condition.
     emit buttonClicked (0);
   }
 };
 
-
 class ListDialog : public QDialog
 {
   Q_OBJECT
 
   QItemSelectionModel *selector;
 
 public:
 
@@ -215,17 +213,16 @@ public slots:
 
   void item_double_clicked (const QModelIndex&);
 
 private:
 
   QAbstractItemModel *model;
 };
 
-
 class InputDialog : public QDialog
 {
   Q_OBJECT
 
   QList<QLineEdit *> input_line;
 
 public:
 
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -491,17 +491,16 @@ files_dock_widget::contextmenu_requested
           menu.addAction (tr ("Open in System File Explorer"),
                           this, SLOT (contextmenu_open_in_app (bool)));
         }
 
       if (info.isFile ())
         menu.addAction (tr ("Open in Text Editor"),
                         this, SLOT (contextmenu_open_in_editor (bool)));
 
-
       menu.addAction (tr ("Copy Selection to Clipboard"),
                       this, SLOT (contextmenu_copy_selection (bool)));
 
       if (info.isFile () && info.suffix () == "m")
         menu.addAction (resource_manager::icon ("media-playback-start"),
                         tr ("Run"), this, SLOT (contextmenu_run (bool)));
 
       if (info.isFile ())
@@ -551,17 +550,16 @@ files_dock_widget::contextmenu_open (boo
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       QFileInfo file = _file_system_model->fileInfo (*it);
       if (file.exists ())
         display_directory (file.absoluteFilePath ());
     }
 }
 
-
 void
 files_dock_widget::contextmenu_open_in_editor (bool)
 {
 
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -188,17 +188,16 @@ find_files_dialog::find_files_dialog (QW
   main_layout->setSizeConstraint (QLayout::SetFixedSize);
   main_layout->addWidget (name_group, 0, 0);
   main_layout->addWidget (content_group, 1, 0);
   main_layout->addWidget (button_box, 0, 1,3,1);
   main_layout->addWidget (_file_list,2,0);
   main_layout->setRowStretch (2,1);
   main_layout->addWidget (_status_bar,3,0,1,-1);
 
-
   setLayout (main_layout);
 
   connect (this, SIGNAL (finished (int)), this, SLOT (handle_done (int)));
 }
 
 find_files_dialog::~find_files_dialog ()
 {
   QSettings *settings = resource_manager::get_settings ();
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -66,32 +66,32 @@ public:
     QVariant leftval = getValue (left);
     QVariant rightval = getValue (right);
 
     if (_sortorder > 0)
       return lessThan (leftval, rightval);
     else
       return ! lessThan (leftval, rightval);
   }
+
 private:
   int _sortorder;
+
 };
 
-
 find_files_model::find_files_model (QObject *p)
   : QAbstractListModel (p)
 {
   _columnNames.append (tr ("Filename"));
   _columnNames.append (tr ("Directory"));
   _sortorder = 0;
 }
 
 find_files_model::~find_files_model ()
-{
-}
+{ }
 
 void
 find_files_model::clear ()
 {
   beginResetModel ();
 
   _files.clear ();
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1163,17 +1163,16 @@ file_editor_tab::zoom_normal (const QWid
 {
   if (ID != this)
     return;
 
   _edit_area->zoomTo (0);
   auto_margin_width ();
 }
 
-
 void
 file_editor_tab::handle_find_dialog_finished (int)
 {
   // Find dialog is going to hide.  Save location of window for
   // when it is reshown.
   _find_dialog_geometry = _find_dialog->geometry ();
   _find_dialog_is_visible = false;
 }
@@ -2438,17 +2437,16 @@ file_editor_tab::do_breakpoint_marker (b
                        this, SLOT (handle_request_remove_breakpoint (int)));
             }
         }
       else
         emit remove_breakpoint_via_debugger_linenr (line);
     }
 }
 
-
 void
 file_editor_tab::center_current_line (bool always)
 {
   long int visible_lines
     = _edit_area->SendScintilla (QsciScintillaBase::SCI_LINESONSCREEN);
 
   if (visible_lines > 2)
     {
@@ -2536,17 +2534,16 @@ file_editor_tab::do_smart_indent ()
           _edit_area->setCursorPosition (_line+1,
                                          _edit_area->indentation (_line));
         }
       return;
     }
 
 }
 
-
 QString
 file_editor_tab::get_function_name ()
 {
   QRegExp rxfun1 ("^[\t ]*function[^=]+=([^\\(]+)\\([^\\)]*\\)[\t ]*$");
   QRegExp rxfun2 ("^[\t ]*function[\t ]+([^\\(]+)\\([^\\)]*\\)[\t ]*$");
   QRegExp rxfun3 ("^[\t ]*function[^=]+=[\t ]*([^\\s]+)[\t ]*$");
   QRegExp rxfun4 ("^[\t ]*function[\t ]+([^\\s]+)[\t ]*$");
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -589,17 +589,16 @@ file_editor::request_mru_open_file (QAct
 {
   if (action)
     {
       request_open_file (action->data ().toStringList ().at (0),
                          action->data ().toStringList ().at (1));
     }
 }
 
-
 void
 file_editor::check_conflict_save (const QString& saveFileName,
                                   bool remove_on_success)
 {
   // Have all file editor tabs signal what their filenames are.
   editor_tab_map.clear ();
   emit fetab_file_name_query (0);
 
@@ -867,17 +866,16 @@ file_editor::request_save_file_as (bool)
 }
 
 void
 file_editor::request_print_file (bool)
 {
   emit fetab_print_file (_tab_widget->currentWidget ());
 }
 
-
 void
 file_editor::request_run_file (bool)
 {
   emit fetab_run_file (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_context_run (bool)
@@ -1039,17 +1037,16 @@ file_editor::request_conv_eol_unix (bool
 }
 void
 file_editor::request_conv_eol_mac (bool)
 {
   emit fetab_convert_eol (_tab_widget->currentWidget (),
                           QsciScintilla::EolMac);
 }
 
-
 void
 file_editor::request_find (bool)
 {
   emit fetab_find (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_goto_line (bool)
@@ -1182,17 +1179,16 @@ file_editor::request_close_other_files (
         {
           editor_tab =
               static_cast<file_editor_tab *> (_tab_widget->widget (index));
           editor_tab->conditional_close ();
         }
     }
 }
 
-
 void
 file_editor::handle_tab_close_request (int index)
 {
   file_editor_tab *editor_tab =
        static_cast<file_editor_tab *> (_tab_widget->widget (index));
   editor_tab->conditional_close ();
 }
 
@@ -1537,17 +1533,16 @@ file_editor::construct (void)
   _tool_bar = new QToolBar (editor_widget);
   _tool_bar->setMovable (true);
   _tab_widget = new tab_widget (editor_widget);
   _tab_widget->setTabsClosable (true);
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
   _tab_widget->setMovable (true);
 #endif
 
-
   // the mru-list and an empty array of actions
   QSettings *settings = resource_manager::get_settings ();
   _mru_files = settings->value ("editor/mru_file_list").toStringList ();
   _mru_files_encodings = settings->value ("editor/mru_file_encodings")
                                    .toStringList ();
 
   if (_mru_files_encodings.count () != _mru_files.count ())
     { // encodings don't have the same count -> do not use them!
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -430,10 +430,9 @@ find_dialog::replace_all ()
 void
 find_dialog::no_matches_message ()
 {
   QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
                        tr ("No more matches found"), QMessageBox::Ok, this);
   msg_box.exec ();
 }
 
-
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -260,17 +260,16 @@ octave_qscintilla::contextMenuEvent (QCo
       }
 #endif
 
   // finaly show the menu
   context_menu->exec (global_pos);
 #endif
 }
 
-
 // handle the menu entry for calling help or doc
 void
 octave_qscintilla::contextmenu_doc (bool)
 {
   contextmenu_help_doc (true);
 }
 void
 octave_qscintilla::contextmenu_help (bool)
diff --git a/libgui/src/m-editor/octave-txt-lexer.cc b/libgui/src/m-editor/octave-txt-lexer.cc
--- a/libgui/src/m-editor/octave-txt-lexer.cc
+++ b/libgui/src/m-editor/octave-txt-lexer.cc
@@ -36,24 +36,21 @@ QString
 octave_txt_lexer::description (int style) const
 {
   if (style == 0)
     return tr ("Default");
   else
     return QString ();
 };
 
-
 const char*
 octave_txt_lexer::language () const
 {
   return "Text";
 }
 
-
 const char*
 octave_txt_lexer::lexer () const
 {
   return "text";
 }
 
-
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -378,17 +378,16 @@ main_window::display_release_notes (void
           else
             news = (tr ("The release notes file '%1' is empty.")
                     . arg (QString::fromStdString (news_file)));
         }
       else
         news = (tr ("The release notes file '%1' cannot be read.")
                 . arg (QString::fromStdString (news_file)));
 
-
       release_notes_window = new QWidget;
 
       QTextBrowser *browser = new QTextBrowser (release_notes_window);
       browser->setText (news);
 
       QVBoxLayout *vlayout = new QVBoxLayout;
       vlayout->addWidget (browser);
 
@@ -1131,17 +1130,16 @@ main_window::write_settings (void)
   for (int i=0; i<_current_directory_combo_box->count (); i++)
     {
       curr_dirs.append (_current_directory_combo_box->itemText (i));
     }
   settings->setValue ("MainWindow/current_directory_list", curr_dirs);
   settings->sync ();
 }
 
-
 // Connecting the signals emitted when the visibility of a widget changes.
 // This has to be done after the window is shown (see octave-gui.cc)
 void
 main_window::connect_visibility_changed (void)
 {
   foreach (octave_dock_widget *widget, dock_widget_list ())
     widget->connect_visibility_changed ();
 
@@ -1193,17 +1191,16 @@ main_window::selectAll (void)
         {
           edit->selectAll ();
         }
     }
   else
     emit selectAll_signal ();
 }
 
-
 // Connect the signals emitted when the Octave thread wants to create
 // a dialog box of some sort.  Perhaps a better place for this would be
 // as part of the QUIWidgetCreator class.  However, mainWindow currently
 // is not a global variable and not accessible for connecting.
 
 void
 main_window::connect_uiwidget_links (void)
 {
@@ -1427,17 +1424,16 @@ main_window::construct (void)
 #endif
 
       octave_link::post_event (this, &main_window::resize_command_window_callback);
 
       configure_shortcuts ();
     }
 }
 
-
 void
 main_window::handle_octave_ready ()
 {
   // actions after the startup files are executed
   QSettings *settings = resource_manager::get_settings ();
 
   QDir startup_dir = QDir ();    // current octave dir after startup
 
@@ -1475,17 +1471,16 @@ main_window::handle_octave_ready ()
 #endif
     }
 
   if (_start_gui)
     focus_command_window ();  // make sure that the command window has focus
 
 }
 
-
 void
 main_window::construct_octave_qt_link (void)
 {
   _octave_qt_link = new octave_qt_link (this);
 
   connect (_octave_qt_link, SIGNAL (exit_app_signal (int)),
            this, SLOT (exit_app (int)));
 
@@ -1626,17 +1621,16 @@ main_window::construct_menu_bar (void)
                  << _undo_action
                  << _copy_action
                  << _paste_action
                  <<_select_all_action;
   editor_window->insert_global_actions (shared_actions);
 #endif
 }
 
-
 QAction*
 main_window::add_action (QMenu *menu, const QIcon &icon, const QString &text,
                          const char *member, const QWidget *receiver)
 {
   QAction *a;
 
   if (receiver)
     a = menu->addAction (icon, text, receiver, member);
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -290,17 +290,16 @@ private:
   void queue_command (octave_cmd *cmd);
 
   void configure_shortcuts ();
 
   workspace_model *_workspace_model;
 
   QHash<QMenu*, QStringList> _hash_menu_text;
 
-
   // Toolbars.
   QStatusBar *status_bar;
 
   // Subwindows.
   terminal_dock_widget *command_window;
   history_dock_widget *history_window;
   files_dock_widget *file_browser_window;
   documentation_dock_widget *doc_browser_window;
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -43,17 +43,16 @@ octave_cmd_exec::execute ()
   std::string pending_input = octave::command_editor::get_current_line ();
 
   octave::command_editor::set_initial_input (pending_input);
   octave::command_editor::replace_line (_cmd.toStdString ());
   octave::command_editor::redisplay ();
   octave::command_editor::accept_line ();
 }
 
-
 // ---------------------------------------------------------------------
 //  class octave_cmd_eval: running a file
 
 void
 octave_cmd_eval::execute ()
 {
   QString function_name = _info.fileName ();
   function_name.chop (_info.suffix ().length () + 1);
@@ -76,17 +75,16 @@ octave_cmd_eval::execute ()
     }
 
   octave::command_editor::set_initial_input (pending_input);
   octave::command_editor::redisplay ();
 
   octave::command_editor::accept_line ();
 }
 
-
 // ---------------------------------------------------------------------
 //  class octave_cmd_debug: executing a debugger command
 
 void
 octave_cmd_debug::execute ()
 {
   if (_cmd == "step")
     {
@@ -104,17 +102,16 @@ octave_cmd_debug::execute ()
     {
       F__db_next_breakpoint_quiet__ (ovl (_suppress_dbg_location));
       Fdbstep (ovl (_cmd.toStdString ()));
     }
 
   octave::command_editor::interrupt (true);
 }
 
-
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
 // add_cmd: add a command to the queue
 void
 octave_command_queue::add_cmd (octave_cmd* cmd)
 {
   _queue_mutex.lock ();
diff --git a/libgui/src/octave-cmd.h b/libgui/src/octave-cmd.h
--- a/libgui/src/octave-cmd.h
+++ b/libgui/src/octave-cmd.h
@@ -37,49 +37,46 @@ class octave_cmd
 public:
 
   octave_cmd () { };
   virtual ~octave_cmd () { };
 
   virtual void execute () { };
 };
 
-
 // ---------------------------------------------------------------------
 //  class octave_cmd_exec
 
 class octave_cmd_exec : public octave_cmd
 {
 public:
 
   octave_cmd_exec (const QString& cmd) : octave_cmd () { _cmd = cmd; };
   void execute ();
 
 protected:
 
   QString _cmd;
 };
 
-
 // ---------------------------------------------------------------------
 //  class octave_cmd_eval
 
 class octave_cmd_eval : public octave_cmd
 {
 public:
 
   octave_cmd_eval (const QFileInfo& info) : octave_cmd () { _info = info; };
   void execute ();
 
 protected:
 
   QFileInfo _info;
 };
 
-
 // ---------------------------------------------------------------------
 //  class octave_cmd_debug
 
 class octave_cmd_debug : public octave_cmd_exec
 {
 public:
 
   octave_cmd_debug (const QString& cmd, bool suppress_location)
@@ -90,17 +87,16 @@ public:
 
   void execute ();
 
 protected:
 
   bool _suppress_dbg_location;
 };
 
-
 /**
  * @class octave_command_queue
  *
  * Queuing commands from the GUI for the worker thread
  */
 // ---------------------------------------------------------------------
 //  class octave_command_queue: queue of octave commands
 
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -35,17 +35,16 @@ along with Octave; see the file COPYING.
 
 #include "resource-manager.h"
 #include "octave-dock-widget.h"
 
 
 octave_dock_widget::octave_dock_widget (QWidget *p)
   : QDockWidget (p)
 {
-
   _parent = static_cast<QMainWindow *> (p);     // store main window
   _floating = false;
   _predecessor_widget = 0;
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
 
   connect (p, SIGNAL (settings_changed (const QSettings*)),
@@ -151,17 +150,16 @@ octave_dock_widget::~octave_dock_widget 
 void
 octave_dock_widget::connect_visibility_changed (void)
 {
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility (bool)));
   emit active_changed (isVisible ());  // emit once for init of window menu
 }
 
-
 // set the widget which previously had focus when tabified
 void
 octave_dock_widget::set_predecessor_widget (octave_dock_widget *prev_widget)
 {
   _predecessor_widget = prev_widget;
 }
 
 // set the title in the dockwidgets title bar
@@ -225,17 +223,16 @@ octave_dock_widget::make_window ()
 
 #endif
 
   _floating = true;
 
   set_focus_predecessor ();  // set focus previously active widget if tabbed
 }
 
-
 // dock the widget
 void
 octave_dock_widget::make_widget (bool dock)
 {
 #if defined (Q_OS_WIN32)
 
   // windows: Since floating widget has no parent, we have to read it
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -562,30 +562,28 @@ void
 octave_qt_link::do_set_default_prompts (std::string& ps1, std::string& ps2,
                                         std::string& ps4)
 {
   ps1 = ">> ";
   ps2 = "";
   ps4 = "";
 }
 
-
 void
 octave_qt_link::do_insert_debugger_pointer (const std::string& file, int line)
 {
   emit insert_debugger_pointer_signal (QString::fromStdString (file), line);
 }
 
 void
 octave_qt_link::do_delete_debugger_pointer (const std::string& file, int line)
 {
   emit delete_debugger_pointer_signal (QString::fromStdString (file), line);
 }
 
-
 bool
 octave_qt_link::file_in_path (const std::string& file, const std::string& dir)
 {
 
   bool ok = false;
   bool addpath_option = true;
 
   std::string curr_dir = octave::sys::env::get_current_directory ();
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -110,17 +110,16 @@ private:
     * @param fileInfo returns file what contains that position.
     * @param realPos returns real position inside of fileInfo.
     */
   void real_position (int pos, QFileInfo & file_info, int & real_pos);
 
   /** Seeks to position pos. */
   void seek (QIODevice *io, int pos);
 
-
   QString                       _info_path;
   QFileInfoList                 _info_files;
   QHash<QString, node_map_item> _node_map;
   QHash<QString, node_position> _ref_map;
   QList<info_file_item>         _info_file_real_size_list;
   QHash<QString, QString>       _compressors_map;
 };
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -295,17 +295,16 @@ webinfo::selectAll ()
       _search_line_edit->selectAll ();
     }
   if (_text_browser->hasFocus ())
     {
       _text_browser->selectAll ();
     }
 }
 
-
 void
 webinfo::pasteClipboard ()
 {
   if (_search_line_edit->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str = clipboard->text ();
       if (str.length () > 0)
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -557,17 +557,16 @@ settings_dialog::settings_dialog (QWidge
   // connect the buttons for import/export of the shortcut sets
   connect (ui->btn_import_shortcut_set, SIGNAL (clicked ()),
            this, SLOT (import_shortcut_set ()));
   connect (ui->btn_export_shortcut_set, SIGNAL (clicked ()),
            this, SLOT (export_shortcut_set ()));
   connect (ui->btn_default_shortcut_set, SIGNAL (clicked ()),
            this, SLOT (default_shortcut_set ()));
 
-
 #if defined (HAVE_QSCINTILLA)
   // editor styles: create lexer, read settings, and create dialog elements
   QsciLexer *lexer;
 #if defined (HAVE_LEXER_OCTAVE)
   lexer = new QsciLexerOctave ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
 #elif defined (HAVE_LEXER_MATLAB)
@@ -960,17 +959,16 @@ settings_dialog::write_terminal_colors (
                 "terminal_color_"+class_chars.mid (i,1));
       if (color)
         settings->setValue ("terminal/color_"+class_chars.mid (i,1),
                             color->color ());
     }
   settings->sync ();
 }
 
-
 // internal slots
 
 void
 settings_dialog::button_clicked (QAbstractButton *button)
 {
   QDialogButtonBox::ButtonRole button_role = ui->button_box->buttonRole (button);
 
   if (button_role == QDialogButtonBox::ApplyRole ||
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -721,17 +721,16 @@ shortcut_manager::do_import_export (int 
   else
     {
       import_shortcuts (0);
     }
 
   return true;
 }
 
-
 // enter_shortcut:
 // class derived from QLineEdit for directly entering key sequences which
 enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
 {
   _direct_shortcut = true;      // the shortcut is directly entered
 }
 
 enter_shortcut::~enter_shortcut ()
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -186,10 +186,9 @@ private:
   enter_shortcut *_edit_actual;
   QLabel *_label_default;
   int _handled_index;
 
   QSettings *_settings;
 
 };
 
-
 #endif
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -43,17 +43,16 @@ make_octave_logo (QWidget *p = 0, int he
 {
   QLabel *logo = new QLabel (p);
   QPixmap logo_pixmap (":/actions/icons/logo.png");
   logo->setPixmap (logo_pixmap.scaledToHeight (height));
   return logo;
 };
 
 
-
 initial_page::initial_page (welcome_wizard *wizard)
   : QWidget (wizard),
     title (new QLabel (tr ("Welcome to Octave!"), this)),
     message (new QLabel (this)),
     logo (make_octave_logo (this)),
     next (new QPushButton (tr ("Next"), this)),
     cancel (new QPushButton (tr ("Cancel"), this))
 {
@@ -97,18 +96,16 @@ initial_page::initial_page (welcome_wiza
 
   next->setDefault (true);
   next->setFocus ();
 
   connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
   connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
 }
 
-
-
 setup_community_news::setup_community_news (welcome_wizard *wizard)
   : QWidget (wizard),
     title (new QLabel (tr ("Community News"), this)),
     message (new QLabel (this)),
     checkbox (new QCheckBox (this)),
     checkbox_message (new QLabel (this)),
     logo (make_octave_logo (this)),
     previous (new QPushButton (tr ("Previous"), this)),
@@ -188,17 +185,16 @@ setup_community_news::setup_community_ne
   connect (checkbox, SIGNAL (stateChanged (int)),
            wizard, SLOT (handle_web_connect_option (int)));
 
   connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
   connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
   connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
 }
 
-
 final_page::final_page (welcome_wizard *wizard)
   : QWidget (wizard),
     title (new QLabel (tr ("Enjoy!"), this)),
     message (new QLabel (this)),
     logo (make_octave_logo (this)),
     links (new QLabel (this)),
     previous (new QPushButton (tr ("Previous"), this)),
     finish (new QPushButton (tr ("Finish"), this)),
@@ -264,17 +260,16 @@ final_page::final_page (welcome_wizard *
   finish->setDefault (true);
   finish->setFocus ();
 
   connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
   connect (finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
   connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
 }
 
-
 welcome_wizard::welcome_wizard (QWidget *p)
   : QDialog (p), page_ctor_list (), page_list_iterator (),
     current_page (initial_page::create (this)),
     allow_web_connect_state (true)
 {
   page_ctor_list.push_back (initial_page::create);
   page_ctor_list.push_back (setup_community_news::create);
   page_ctor_list.push_back (final_page::create);
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -59,17 +59,16 @@ workspace_model::storage_class_default_c
              << QColor (255,255,190)
              << QColor (255,220,220)
              << QColor (255,190,255);
     }
 
   return colors;
 }
 
-
 QStringList
 workspace_model::storage_class_names (void)
 {
   QStringList names;
 
   if (names.isEmpty ())
     {
       names << QObject::tr ("automatic")
@@ -220,17 +219,16 @@ workspace_model::setData (const QModelIn
 
           retval = true;
         }
     }
 
   return retval;
 }
 
-
 void
 workspace_model::set_workspace (bool top_level,
                                 bool /* debug */,
                                 const QString& scopes,
                                 const QStringList& symbols,
                                 const QStringList& class_names,
                                 const QStringList& dimensions,
                                 const QStringList& values,
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -360,17 +360,16 @@ void ilu_crout (octave_matrix_t& sm_l, o
       // Check if the pivot is zero
       if (data_u[total_len_u] == zero)
         error ("ilu: encountered a pivot equal to 0");
 
       // Scale the elements in L by the pivot
       for (i = total_len_l ; i < (total_len_l + w_len_l); i++)
         data_l[i] /= data_u[total_len_u];
 
-
       total_len_u += w_len_u;
       total_len_l += w_len_l;
       // Check if there are too many elements to be indexed with
       // octave_idx_type type due to fill-in during the process.
       if (total_len_l < 0 || total_len_u < 0)
         error ("ilu: integer overflow.  Too many fill-in elements in L or U");
 
       cidx_u[k+1] = cidx_u[k] - cidx_u[0] + w_len_u;
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -148,17 +148,16 @@ lin_interpn (int n, const octave_idx_typ
           else
             {
               octave_idx_type j = index[i];
               coef[2*i+1] = (y[i][m] - x[i][j])/(x[i][j+1] - x[i][j]);
               coef[2*i] = 1 - coef[2*i+1];
             }
         }
 
-
       if (out)
         vi[m] = extrapval;
       else
         {
           vi[m] = 0;
 
           // loop over all corners of hypercube (1<<n = 2^n)
           for (int i = 0; i < (1 << n); i++)
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -842,17 +842,16 @@ FIXME: Function airy does not yet have B
 %!
 %!assert (besselj (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 
-
 Tests contributed by Robert T. Short.
 Tests are based on the properties and tables in A&S:
  Abramowitz and Stegun, "Handbook of Mathematical Functions",
  1972.
 
 For regular Bessel functions, there are 3 tests.  These compare octave
 results against Tables 9.1, 9.2, and 9.4 in A&S. Tables 9.1 and 9.2
 are good to only a few decimal places, so any failures should be
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -441,17 +441,16 @@ dimensionality as the other array.
           octave_value Ac;
           octave_value_list idxA;
           octave_value Bc;
           octave_value_list idxB;
           octave_value C;
           octave_value_list inputs (2);
           Array<int> ra_idx (dim_vector (dvc.ndims (), 1), 0);
 
-
           for (octave_idx_type i = 0; i < ncount; i++)
             {
               if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                 inputs(0) = Ac;
 
               if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
                 inputs(1) = Bc;
 
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1643,17 +1643,16 @@ template <typename NDA>
 static inline typename NDA::element_type
 do_num2cell_elem (const NDA& array, octave_idx_type i)
 { return array(i); }
 
 static inline Cell
 do_num2cell_elem (const Cell& array, octave_idx_type i)
 { return Cell (array(i)); }
 
-
 template <typename NDA>
 static Cell
 do_num2cell (const NDA& array, const Array<int>& dimv)
 {
   if (dimv.is_empty ())
     {
       Cell retval (array.dims ());
       octave_idx_type nel = array.numel ();
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -263,17 +263,16 @@ When the third argument is a matrix, ret
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
 %! assert (B, A);   # Yes, this test is for *exact* equivalence.
 
-
 %% Test input validation
 %!error conv2 ()
 %!error conv2 (1)
 %!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -316,17 +316,16 @@ This function is equivalent to @code{arg
 %! assert (issparse (y));
 %! assert (nnz (y), 3);
 %! assert (y, sparse (atan2 (0:3, zeros (1,4))));
 
 %!error atan2 ()
 %!error atan2 (1, 2, 3)
 */
 
-
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
   octave_value arg0 = x;
   octave_value arg1 = y;
   if (! arg0.is_numeric_type ())
@@ -3719,17 +3718,16 @@ Return true if @var{x} is a row vector 1
 %!assert (isrow (ones (1, 1)), true)
 %!assert (isrow (ones (1, 2)), true)
 %!assert (isrow (ones (1, 1, 1)), true)
 %!assert (isrow (ones (1, 1, 1, 1)), true)
 
 %!assert (isrow (ones (0, 0)), false)
 %!assert (isrow (ones (1, 1, 0)), false)
 
-
 %!assert (isrow ("t"), true)
 %!assert (isrow ("test"), true)
 %!assert (isrow (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
 %! assert (isrow (s), true);
 
@@ -4411,17 +4409,16 @@ When called with no arguments, return a 
 
 When called with a single argument, return a square matrix with the
 dimension specified.
 
 When called with more than one scalar argument the first two arguments are
 taken as the number of rows and columns and any further arguments specify
 additional matrix dimensions.
 
-
 The optional argument @var{class} specifies the return type and may be
 either @qcode{"double"} or @qcode{"single"}.
 @seealso{isnan, Inf}
 @end deftypefn */)
 {
   return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
@@ -5177,17 +5174,16 @@ if fewer than two values are requested.
         retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
       else
         retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
     }
 
   return retval;
 }
 
-
 /*
 %!test
 %! x1 = linspace (1, 2);
 %! x2 = linspace (1, 2, 10);
 %! x3 = linspace (1, -2, 10);
 %! assert (size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2);
 %! assert (size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2);
 %! assert (size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2);
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -558,17 +558,16 @@ bp_table::dbstop_process_map_args (const
   if (fail)
     error ("dbstop: invalid 'warn' field");
 
   // process interrupt
   if (mv.isfield ("intr"))
     Vdebug_on_interrupt = 1;
 }
 
-
 // Insert a breakpoint in function fcn at line within file fname,
 // to stop only when condition is true.
 // Record in bp_set that fname contains a breakpoint.
 bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
                                const std::string& fname,
                                const bp_table::intmap& line,
                                const std::string& condition,
@@ -739,17 +738,16 @@ bp_table::do_add_breakpoint (const std::
           // If multiple are in the same function, we insert multiple times.
           intmap ret_one;
           if (dbg_fcn
               && do_add_breakpoint_1 (dbg_fcn, fname, line, condition, ret_one))
             retval.insert (std::pair<int,int> (i, ret_one.find (i)->second));
         }
     }
 
-
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 int
 bp_table::do_remove_breakpoint_1 (octave_user_code *fcn,
                                   const std::string& fname,
diff --git a/libinterp/corefcn/debug.h b/libinterp/corefcn/debug.h
--- a/libinterp/corefcn/debug.h
+++ b/libinterp/corefcn/debug.h
@@ -157,25 +157,23 @@ public:
 private:
 
   typedef std::set<std::string>::const_iterator const_bp_set_iterator;
   typedef std::set<std::string>::iterator bp_set_iterator;
 
   // Set of function (.m file) names containing at least one breakpoint.
   std::set<std::string> bp_set;
 
-
   // Set of error and warning message IDs that cause us to stop
   // *if* Vdebug_on_error / Vdebug_on_caught / Vdebug_on_warning is set.
   // Empty means stop on any error / caught error / warning.
   static std::set<std::string> errors_that_stop;
   static std::set<std::string> caught_that_stop;
   static std::set<std::string> warnings_that_stop;
 
-
   static bp_table *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   bool do_add_breakpoint_1 (octave_user_code *fcn, const std::string& fname,
                             const intmap& line, const std::string& condition,
                             intmap& retval);
 
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -208,17 +208,16 @@ octave_dynamic_loader::instance_ok (void
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     error ("unable to create dynamic loader object!");
 
-
   return retval;
 }
 
 static void
 do_clear_function (const std::string& fcn_name)
 {
   warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
 
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -215,17 +215,16 @@ of @var{A} is treated separately
 %! sy = cos (n*y);
 %!
 %! S = kron (fft (sx)', fft (sy));
 %! answer = kron (sx', sy);
 %! s = ifft2 (S);
 %!
 %! assert (s, answer, 30*eps);
 
-
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! M = 16;
 %! N = 8;
 %!
 %! m = 5;
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -426,17 +426,16 @@ Returns the number of lines skipped (end
   off_t tmp = os.skipl (count_arg, err, who);
 
   if (! err)
     return ovl (tmp);
   else
     return ovl ();
 }
 
-
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode_arg,
                 const std::string& arch, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
@@ -1480,17 +1479,16 @@ end-of-line as specified by the @code{En
 Data columns are padded with empty fields, NaN or 0 (for integer fields) so
 that all columns have equal length
 
 @item last character is not end-of-line
 Data columns are not padded; @code{textscan} returns columns of unequal
 length
 @end table
 
-
 The second output @var{position} provides the location, in characters
 from the beginning of the file or string, where processing stopped.
 
 @seealso{dlmread, fscanf, load, strread, textread}
 @end deftypefn */)
 {
   static std::string who = "textscan";
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -171,17 +171,16 @@ private:
     //
     //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
     //
     // if (fontconfig_initialized)
     //   FcFini ();
 #endif
   }
 
-
   FT_Face do_get_font (const std::string& name, const std::string& weight,
                        const std::string& angle, double size)
   {
     FT_Face retval = 0;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
     // Look first into the font cache, then use fontconfig.  If the font
     // is present in the cache, simply add a reference and return it.
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -2957,17 +2957,16 @@ opengl_renderer::draw_patch (const patch
             {
               if (c.is_empty ())
                 c = props.get_color_data ().matrix_value ();
               has_markerfacecolor = ((c.numel () > 0)
                                      && (c.rows () == f.rows ()));
             }
         }
 
-
       init_marker (props.get_marker (), props.get_markersize (),
                    props.get_linewidth ());
 
       for (int i = 0; i < nf; i++)
         for (int j = 0; j < count_f(i); j++)
           {
             int idx = int (f(i,j) - 1);
 
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -504,17 +504,16 @@ code_to_symbol (uint32_t code)
     retval = std::string ("\xd3");
 
   if (retval.empty ())
     warning ("print: unhandled symbol %d", code);
 
   return retval;
 }
 
-
 static std::string
 select_font (caseless_str fn, bool isbold, bool isitalic)
 {
   std::transform (fn.begin (), fn.end (), fn.begin (), ::tolower);
   std::string fontname;
   if (fn == "times" || fn == "times-roman")
     {
       if (isitalic && isbold)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -205,17 +205,16 @@ viridis_colormap (void)
 
   // It would be nice if Matrix had a ctor allowing to do the
   // following without a copy
   Matrix cmap (64, 3, 0.0);
   std::copy (cmapv, cmapv + (64*3), cmap.fortran_vec ());
   return cmap;
 }
 
-
 static double
 default_screendepth (void)
 {
   return display_info::depth ();
 }
 
 static Matrix
 default_screensize (void)
@@ -1153,17 +1152,16 @@ base_property::set (const octave_value& 
         run_listeners (POSTSET);
 
       return true;
     }
 
   return false;
 }
 
-
 void
 base_property::run_listeners (listener_mode mode)
 {
   const octave_value_list& l = listeners[mode];
 
   for (int i = 0; i < l.length (); i++)
     gh_manager::execute_listener (parent, l(i));
 }
@@ -1362,17 +1360,16 @@ double_radio_property::do_set (const oct
     {
       std::string s = val.string_value ();
       std::string match;
 
       if (s.empty () || ! radio_val.contains (s, match))
         error ("invalid value for double_radio property \"%s\"",
                get_name ().c_str ());
 
-
       if (current_type != radio_t || match != current_val)
         {
           if (s.length () != match.length ())
             warning_with_id ("Octave:abbreviated-property-match",
                              "%s: allowing %s to match %s value %s",
                              "set", s.c_str (), get_name ().c_str (),
                              match.c_str ());
           current_val = match;
@@ -3969,17 +3966,16 @@ papersize_from_type (const caseless_str 
           retval(0) = 34.0 * in2units;
           retval(1) = 43.0 * in2units;
         }
     }
 
   return retval;
 }
 
-
 Matrix
 figure::properties::get_auto_paperposition (void)
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix sz;
 
   caseless_str funits = get_units ();
   caseless_str punits = get_paperunits ();
@@ -8192,17 +8188,16 @@ patch::properties::update_fvc (void)
   frame.protect_var (updating_patch_data);
   updating_patch_data = true;
 
   faces.set (idx);
   vertices.set (vert);
   facevertexcdata.set (fvc);
 }
 
-
 void
 patch::properties::update_data (void)
 {
   if (updating_patch_data)
     return;
 
   Matrix idx = get_faces ().matrix_value ().transpose ();
   Matrix vert = get_vertices ().matrix_value ();
@@ -8286,17 +8281,16 @@ patch::properties::update_data (void)
             zd(ii,jj) = vert(row,2);
 
           if (pervertex)
             for (int kk = 0; kk < fvc.columns (); kk++)
               cd(ii,jj,kk) = fvc(row,kk);
         }
     }
 
-
   octave::unwind_protect frame;
   frame.protect_var (updating_patch_data);
   updating_patch_data = true;
 
   set_xdata (xd);
   set_ydata (yd);
   set_zdata (zd);
   set_cdata (cd);
@@ -8658,17 +8652,16 @@ uicontextmenu::~uicontextmenu (void)
       graphics_object go = gh_manager::get_object (*it);
 
       if (go.valid_object () &&
           go.get ("uicontextmenu") == xproperties.get___myhandle__ ())
         go.set ("uicontextmenu", Matrix ());
     }
 }
 
-
 /*
 ## Test deletion/reset of uicontextmenu
 %!test
 %! hf = figure ("visible", "off");
 %! hax = axes ("parent", hf);
 %! unwind_protect
 %!   hctx1 = uicontextmenu ("parent", hf);
 %!   hctx2 = uicontextmenu ("parent", hf);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -307,17 +307,16 @@ public:
   OCTINTERP_API bool set (const octave_value& v, bool do_run = true,
                           bool do_notify_toolkit = true);
 
   virtual octave_value get (void) const
   {
     error ("get: invalid property \"%s\"", name.c_str ());
   }
 
-
   virtual std::string values_as_string (void) const
   {
     error ("values_as_string: invalid property \"%s\"", name.c_str ());
   }
 
   virtual Cell values_as_cell (void) const
   {
     error ("values_as_cell: invalid property \"%s\"", name.c_str ());
@@ -1768,18 +1767,16 @@ private:
   void do_adopt_child (double val)
   {
     children_list.push_front (val);
   }
 
   void do_delete_children (bool clear);
 };
 
-
-
 // ---------------------------------------------------------------------
 
 class callback_property : public base_property
 {
 public:
   callback_property (const std::string& nm, const graphics_handle& h,
                      const octave_value& m)
     : base_property (nm, h), callback (m), executing (false) { }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1319,17 +1319,16 @@ do_which (const std::string& name, std::
       if (name.size () > 1 && name[name.size () - 1] == '.')
         file = load_path::find_file (name.substr (0, name.size () - 1));
       else
         file = load_path::find_file (name);
 
       file = octave::sys::env::make_absolute (file);
     }
 
-
   return file;
 }
 
 std::string
 do_which (const std::string& name)
 {
   std::string retval;
 
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -1378,26 +1378,24 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *cmp = builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
     builder.CreateCondBr (cmp, scalar_mul, complex_mul);
 
     builder.SetInsertPoint (scalar_mul);
     llvm::Value *temp = complex_real (rhs);
     temp = builder.CreateFMul (lhs, temp);
     fn.do_return (builder, complex_new (temp, fzero), false);
 
-
     builder.SetInsertPoint (complex_mul);
     temp = complex_new (builder.CreateFMul (lhs, complex_real (rhs)),
                         builder.CreateFMul (lhs, complex_imag (rhs)));
     fn.do_return (builder, temp);
   }
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
-
   fn = mirror_binary (mul_scalar_complex);
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
   fn = create_internal ("octave_jit_+_scalar_complex", complex, scalar,
                         complex);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
@@ -1541,17 +1539,16 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   // make_range
   // FIXME: May be benificial to implement all in LLVM
   make_range_fn.stash_name ("make_range");
   jit_function compute_nelem
     = create_external (JIT_FN (octave_jit_compute_nelem),
                        index, scalar, scalar, scalar);
 
-
   fn = create_internal ("octave_jit_make_range", range, scalar, scalar, scalar);
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
     llvm::Value *base = fn.argument (builder, 0);
     llvm::Value *limit = fn.argument (builder, 1);
     llvm::Value *inc = fn.argument (builder, 2);
     llvm::Value *nelem = compute_nelem.call (builder, base, limit, inc);
@@ -1606,17 +1603,16 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     ginvalid_index.call (builder);
     builder.CreateBr (done);
 
     builder.SetInsertPoint (normal);
     llvm::Value *len
       = builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (2));
     cond = builder.CreateICmpSGT (int_idx, len);
 
-
     llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
     llvm::BasicBlock *success = fn.new_block ("success", done);
     builder.CreateCondBr (cond, bounds_error, success);
 
     builder.SetInsertPoint (bounds_error);
     gindex_range.call (builder, one_int, one_int, int_idx, len);
     builder.CreateBr (done);
 
diff --git a/libinterp/corefcn/jit-typeinfo.h b/libinterp/corefcn/jit-typeinfo.h
--- a/libinterp/corefcn/jit-typeinfo.h
+++ b/libinterp/corefcn/jit-typeinfo.h
@@ -315,17 +315,16 @@ private:
   jit_type *mresult;
   std::vector<jit_type *> args;
   jit_convention::type call_conv;
   bool mcan_error;
 };
 
 std::ostream& operator << (std::ostream& os, const jit_function& fn);
 
-
 // Keeps track of information about how to implement operations (+, -, *, ect)
 // and their resulting types.
 class
 jit_operation
 {
 public:
   // type signature vector
   typedef std::vector<jit_type *> signature_vec;
@@ -667,17 +666,16 @@ private:
   }
 
   const jit_function& do_end (jit_value *value, jit_value *index,
                               jit_value *count);
 
   jit_type *new_type (const std::string& name, jit_type *parent,
                       llvm::Type *llvm_type, bool skip_paren = false);
 
-
   void add_print (jit_type *ty, void *fptr);
 
   void add_binary_op (jit_type *ty, int op, int llvm_op);
 
   void add_binary_icmp (jit_type *ty, int op, int llvm_op);
 
   void add_binary_fcmp (jit_type *ty, int op, int llvm_op);
 
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -279,17 +279,16 @@ Since the Kronecker product is associati
   retval = dispatch_kron (a, b);
 
   for (octave_idx_type i = 2; i < nargin; i++)
     retval = dispatch_kron (retval, args(i));
 
   return retval;
 }
 
-
 /*
 %!test
 %! x = ones (2);
 %! assert (kron (x, x), ones (4));
 
 %!shared x, y, z, p1, p2, d1, d2
 %! x =  [1, 2];
 %! y =  [-1, -2];
@@ -305,17 +304,16 @@ Since the Kronecker product is associati
 %!assert (kron (complex (single(1:4)), ones (3, 1)), single(z))
 %!assert (kron (x, y, z), kron (kron (x, y), z))
 %!assert (kron (x, y, z), kron (x, kron (y, z)))
 %!assert (kron (p1, p1), kron (p2, p2))
 %!assert (kron (p1, p2), kron (p2, p1))
 %!assert (kron (d1, d1), kron (d2, d2))
 %!assert (kron (d1, d2), kron (d2, d1))
 
-
 %!assert (kron (diag ([1, 2]), diag ([3, 4])), diag ([3, 4, 6, 8]))
 
 %% Test for two diag matrices.  See the comments above in
 %% dispatch_kron for this case.
 %%
 %!test
 %! expected = zeros (16, 16);
 %! expected (1, 11) = 3;
diff --git a/libinterp/corefcn/ls-ascii-helper.cc b/libinterp/corefcn/ls-ascii-helper.cc
--- a/libinterp/corefcn/ls-ascii-helper.cc
+++ b/libinterp/corefcn/ls-ascii-helper.cc
@@ -75,20 +75,18 @@ skip_until_newline (std::istream& is, bo
           // No newline charater peeked, so read it and proceed to next
           // character.
           char d;
           is.get (d);
         }
     }
 }
 
-
-// If stream IS currently points to a newline (a leftover from a
-// previous read) then eat newline(s) until a non-newline character is
-// found.
+// If stream IS currently points to a newline (a leftover from a previous read)
+// then eat newline(s) until a non-newline character is found.
 
 void
 skip_preceeding_newline (std::istream& is)
 {
   if (! is)
     return;
 
   // Check whether IS currently points to newline character.
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -732,17 +732,16 @@ read_hdf5_data (std::istream& is, const 
         }
 
       if (found)
         break;
 
       hs.current_item++;
     }
 
-
   if (hs.current_item < static_cast<int> (num_obj))
     H5Giterate_retval = H5Giterate (hs.file_id, "/", &hs.current_item,
                                     hdf5_read_next_data, &d);
 
   if (H5Giterate_retval > 0)
     {
       global = d.global;
       tc = d.tc;
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -148,14 +148,13 @@ hdf5_check_attr (octave_hdf5_id loc_id, 
 
 extern OCTINTERP_API bool
 hdf5_get_scalar_attr (octave_hdf5_id loc_id, octave_hdf5_id type_id,
                       const char *attr_name, void *buf);
 
 extern OCTINTERP_API octave_hdf5_err
 hdf5_add_attr (octave_hdf5_id loc_id, const char *attr_name);
 
-
 extern OCTINTERP_API octave_hdf5_err
 hdf5_add_scalar_attr (octave_hdf5_id loc_id, octave_hdf5_id type_id,
                       const char *attr_name, void *buf);
 
 #endif
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1275,17 +1275,16 @@ read_mat5_binary_element (std::istream& 
     case MAT_FILE_INT64_CLASS:
       OCTAVE_MAT5_INTEGER_READ (int64NDArray);
       break;
 
     case MAT_FILE_UINT64_CLASS:
       OCTAVE_MAT5_INTEGER_READ (uint64NDArray);
       break;
 
-
     case MAT_FILE_SINGLE_CLASS:
       {
         FloatNDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
@@ -1952,17 +1951,16 @@ save_mat5_array_length (const double* va
 
 int
 save_mat5_array_length (const float* /* val */, octave_idx_type nel, bool)
 {
   if (nel > 0)
     {
       int size = 4;
 
-
       // The code below is disabled since get_save_type currently doesn't
       // deal with integer types.  This will need to be activated if
       // get_save_type is changed.
 
       // float max_val = val[0];
       // float min_val = val[0];
       // bool all_integers = true;
       //
@@ -2179,17 +2177,16 @@ save_mat5_element_length (const octave_v
           ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
         }
 
       for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
         fieldcnt++;
 
       ret += 16 + fieldcnt * (max_namelen + 1);
 
-
       for (octave_idx_type j = 0; j < nel; j++)
         {
 
           for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
             {
               const Cell elts = m.contents (i);
 
               ret += 8 + save_mat5_element_length (elts(j), "",
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -1029,17 +1029,16 @@ iw = 1  2  2  4  4  6
 %! assert (cummin (x, 1), reshape ([1 1 3 3 5 5 7 7], [2,2,2]));
 %! assert (cummin (x, 2), reshape ([1 2 1 2 5 6 5 6], [2,2,2]));
 %! [w, iw] = cummin (x, 3);
 %! assert (ndims (w), 3);
 %! assert (w, repmat ([1 3; 2 4], [1 1 2]));
 %! assert (ndims (iw), 3);
 %! assert (iw, ones (2,2,2));
 
-
 %!error cummin ()
 %!error cummin (1, 2, 3)
 */
 
 DEFUN (cummax, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} cummax (@var{x})
 @deftypefnx {} {} cummax (@var{x}, @var{dim})
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -652,17 +652,16 @@ permute_to_correct_order (octave_idx_typ
         }
     }
   catch (octave_execution_exception& e)
     {
       error (e, "cat: field names mismatch in concatenating structs");
     }
 }
 
-
 octave_map
 octave_map::cat (int dim, octave_idx_type n, const octave_scalar_map *map_list)
 {
   octave_map retval;
 
   // Allow dim = -1, -2 for compatibility, though it makes no difference here.
   if (dim == -1 || dim == -2)
     dim = -dim - 1;
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -142,17 +142,16 @@ public:
   string_vector fieldnames (void) const;
 
   void clear (void)
   {
     *this = octave_fields ();
   }
 };
 
-
 class OCTINTERP_API
 octave_scalar_map
 {
 public:
 
   octave_scalar_map (const octave_fields& k)
     : xkeys (k), xvals (k.nfields ()) { }
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3136,17 +3136,16 @@ textscan::read_until (delimited_stream& 
             }
         }
     }
   while (! done && is && ! is.eof ());
 
   return retval;
 }
 
-
 // Read stream until either fmt.width chars have been read, or
 // options.delimiter has been found.  Does *not* rely on fmt being 's'.
 // Used by formats like %6f to limit to 6.
 
 void
 textscan::scan_string (delimited_stream& is, const textscan_format_elt& fmt,
                        std::string& val) const
 {
@@ -3246,17 +3245,16 @@ textscan::scan_cstring (delimited_stream
       else
         {
           val.resize (i);
           break;
         }
     }
 }
 
-
 //  Read a single '%...' conversion and place it in position ROW of OV.
 
 void
 textscan::scan_one (delimited_stream& is, const textscan_format_elt& fmt,
                     octave_value& ov, Array<octave_idx_type> row)
 {
   skip_whitespace (is);
 
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -205,17 +205,16 @@ public:
                const std::string& multimode)
   {
     return enabled ()
            ? instance->do_file_dialog (filter, title, filename, dirname,
                                        multimode)
            : std::list<std::string> ();
   }
 
-
   static int debug_cd_or_addpath_error (const std::string& file,
                                         const std::string& dir,
                                         bool addpath_option)
   {
     return enabled ()
            ? instance->do_debug_cd_or_addpath_error (file, dir, addpath_option)
            : 0;
   }
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3849,17 +3849,16 @@ set_format_style (int argc, const string
       init_format_state ();
       set_output_prec_and_fw (5, 10);
       format = std::string ("short");
     }
 
   format_string = format;
 }
 
-
 DEFUN (format, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} format
 @deftypefnx {} {} format options
 Reset or specify the format of the output produced by @code{disp} and
 Octave's normal echoing mechanism.
 
 This command only affects the display of numbers but not how they are stored
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -567,17 +567,16 @@ jit_convert::visit_if_command_list (tree
       else
         entry_blocks[i] = factory.create<jit_block> ("ifelse_cond");
     }
 
   jit_block *tail = factory.create<jit_block> ("if_tail");
   if (! last_else)
     entry_blocks[entry_blocks.size () - 1] = tail;
 
-
   // each branch in the if statement will have different breaks/continues
   block_list current_breaks = breaks;
   block_list current_continues = continues;
   breaks.clear ();
   continues.clear ();
 
   size_t num_incomming = 0; // number of incomming blocks to our tail
   iter = lst.begin ();
@@ -1309,17 +1308,16 @@ jit_convert_llvm::convert_loop (llvm::Mo
   // more interesting
   jit_block *entry_block = blocks.front ();
   for (jit_block::iterator iter = entry_block->begin ();
        iter != entry_block->end (); ++iter)
     if (jit_extract_argument *extract
         = dynamic_cast<jit_extract_argument *> (*iter))
       argument_vec.push_back (std::make_pair (extract->name (), true));
 
-
   jit_type *any = jit_typeinfo::get_any ();
 
   // argument is an array of octave_base_value*, or octave_base_value**
   llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
   arg_type = arg_type->getPointerTo ();
   llvm::FunctionType *ft;
   ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context), arg_type,
                                 false);
@@ -1344,17 +1342,16 @@ jit_convert_llvm::convert_loop (llvm::Mo
     {
       function->eraseFromParent ();
       throw;
     }
 
   return function;
 }
 
-
 jit_function
 jit_convert_llvm::convert_function (llvm::Module *module,
                                     const jit_block_list& blocks,
                                     const std::list<jit_value *>& constants,
                                     octave_user_function& fcn,
                                     const std::vector<jit_type *>& args)
 {
   converting_function = true;
@@ -2174,17 +2171,16 @@ tree_jit::trip_count (const octave_value
       Range rng = bounds.range_value ();
       return rng.numel ();
     }
 
   // unsupported type
   return 0;
 }
 
-
 void
 tree_jit::optimize (llvm::Function *fn)
 {
   if (Vdebug_jit)
     llvm::verifyModule (*module);
 
   module_pass_manager->run (*module);
   pass_manager->run (*fn);
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -281,17 +281,16 @@ fout (const octave_idx_type& lsize, cons
       const double& beta, const double&, const double& p)
 {
   if (lsize == 1)
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
-
 //FIXME: Matlab does not produce lambda as the first output argument.
 //       Compatibility problem?
 DEFUN (qz, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{lambda} =} qz (@var{A}, @var{B})
 @deftypefnx {} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})
 QZ@tie{}decomposition of the generalized eigenvalue problem
 (@math{A x = s B x}).
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -376,17 +376,16 @@ x_el_div (double a, const SparseMatrix& 
   Matrix result;
   if (a == 0.)
     result = Matrix (nr, nc, octave::numeric_limits<double>::NaN ());
   else if (a > 0.)
     result = Matrix (nr, nc, octave::numeric_limits<double>::Inf ());
   else
     result = Matrix (nr, nc, -octave::numeric_limits<double>::Inf ());
 
-
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
         result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -46,17 +46,16 @@ along with Octave; see the file COPYING.
 static inline int
 xisint (double x)
 {
   return (octave::math::x_nint (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
-
 // Safer pow functions.  Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
 octave_value
 xpow (const SparseMatrix& a, double b)
 {
   octave_value retval;
 
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -54,17 +54,16 @@ qs_preprocess (const Array<char>& needle
   octave_idx_type m = needle.numel ();
 
   for (octave_idx_type i = 0; i < TABSIZE; i++)
     table[i] = m + 1;
   for (octave_idx_type i = 0; i < m; i++)
     table[ORD(x[i])] = m - i;
 }
 
-
 static Array<octave_idx_type>
 qs_search (const Array<char>& needle,
            const Array<char>& haystack,
            const octave_idx_type *table,
            bool overlaps = true)
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -273,17 +273,16 @@ strvcat ([97, 98, 99], "", @{"98", "99",
 %!assert (strvcat (100, [], 100), ["d";"d"])
 %!assert (strvcat ({100, [], 100}), ["d";"d"])
 %!assert (strvcat ({100,{100, {""}}}), ["d";"d"])
 %!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
 %!assert (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
 %!assert (strvcat (), "")
 */
 
-
 DEFUN (ischar, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} ischar (@var{x})
 Return true if @var{x} is a character array.
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2770,18 +2770,16 @@ private:
 
     while (q != global_table.end ())
       {
         if (pattern.match (q->first))
           global_table.erase (q++);
         else
           q++;
       }
-
-
   }
 
   void do_clear_variable_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1236,17 +1236,16 @@ octave_remove_atexit_function (const std
           found = true;
           break;
         }
     }
 
   return found;
 }
 
-
 DEFUN (atexit, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} atexit (@var{fcn})
 @deftypefnx {} {} atexit (@var{fcn}, @var{flag})
 Register a function to be called when Octave exits.
 
 For example,
 
@@ -1585,17 +1584,16 @@ specified option.
       { "YFLAGS", octave::build_env::YFLAGS },
       { "Z_CPPFLAGS", octave::build_env::Z_CPPFLAGS },
       { "Z_LDFLAGS", octave::build_env::Z_LDFLAGS },
       { "Z_LIBS", octave::build_env::Z_LIBS },
       { "config_opts", octave::build_env::config_opts },
       { 0, 0 },
     };
 
-
   static octave_scalar_map config;
   static octave_scalar_map build_env;
   static octave_scalar_map build_features = octave::build_env::features ();
 
   if (! initialized)
     {
       int i;
 
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -39,17 +39,16 @@ class tree_statement_list;
 class charMatrix;
 
 #include "quit.h"
 
 #include "input.h"
 #include "oct-map.h"
 #include "symtab.h"
 
-
 typedef void (*octave_exit_func) (int);
 extern OCTINTERP_API octave_exit_func octave_exit;
 
 extern OCTINTERP_API bool quit_allowed;
 
 extern OCTINTERP_API bool quitting_gracefully;
 
 extern OCTINTERP_API int exit_status;
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -77,17 +77,16 @@ reinterpret_copy (const void *data, octa
 
   ArrayType retval (get_vec_dims (old_dims, n));
   T *dest = retval.fortran_vec ();
   std::memcpy (dest, data, n * sizeof (T));
 
   return retval;
 }
 
-
 DEFUN (typecast, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{y} =} typecast (@var{x}, "@var{class}")
 Return a new array @var{y} resulting from interpreting the data of @var{x}
 in memory as data of the numeric class @var{class}.
 
 Both the class of @var{x} and @var{class} must be one of the built-in
 numeric classes:
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -172,17 +172,16 @@ keyword_almost_match (const char * const
 
   char *beg = kw;
   while (*beg == ' ')
     beg++;
 
   if (*beg == '\0')
     return status;
 
-
   const char **to_match = new const char * [max_toks + 1];
   const char * const *s1 = std;
   const char **s2 = to_match;
 
   if (! s1 || ! s2)
     goto done;
 
   s2[tok_count] = beg;
@@ -1107,17 +1106,16 @@ check_dimensions (dim_vector& dim, const
         }
     }
 
   if (neg)
     warning_with_id ("Octave:neg-dim-as-zero",
                      "%s: converting negative dimension to zero", warnfor);
 }
 
-
 void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim)
 {
   // We support dimensions to be specified by any vector, even if it's a
   // vector of dimensions 0x1, 1x0, 1x1x0, or 1x1x6.  If the vector ends
   // up being empty, the final dimensions end up being 0x0.
   if (! a.dims ().is_vector ())
@@ -1139,17 +1137,16 @@ get_dimensions (const octave_value& a, c
     }
   else
     for (octave_idx_type i = 0; i < n; i++)
       dim(i) = v(i);
 
   check_dimensions (dim, warn_for);
 }
 
-
 void
 get_dimensions (const octave_value& a, const char *warn_for,
                 octave_idx_type& nr, octave_idx_type& nc)
 {
   if (a.is_scalar_type ())
     {
       nr = nc = a.idx_type_value ();
     }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -2074,17 +2074,16 @@ If no function is named then unlock the 
         error ("munlock: invalid use outside a function");
 
       fcn->unlock ();
     }
 
   return ovl ();
 }
 
-
 DEFUN (mislocked, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} mislocked ()
 @deftypefnx {} {} mislocked (@var{fcn})
 Return true if the named function @var{fcn} is locked.
 
 If no function is named then return true if the current function is locked.
 @seealso{mlock, munlock, persistent}
diff --git a/libinterp/corefcn/xdiv.h b/libinterp/corefcn/xdiv.h
--- a/libinterp/corefcn/xdiv.h
+++ b/libinterp/corefcn/xdiv.h
@@ -95,17 +95,16 @@ extern FloatComplexMatrix xleftdiv (cons
                                     const FloatMatrix& b,
                                     MatrixType &typ,
                                     blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a,
                                     const FloatComplexMatrix& b,
                                     MatrixType &typ,
                                     blas_trans_type transt = blas_no_trans);
 
-
 extern Matrix xdiv (const Matrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a,
                                const ComplexDiagMatrix& b);
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -604,17 +604,16 @@ xpow (const ComplexDiagMatrix& a, double
 }
 
 octave_value
 xpow (const DiagMatrix& a, const Complex& b)
 {
   return xpow (ComplexDiagMatrix (a), b);
 }
 
-
 // Safer pow functions that work elementwise for matrices.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | * | 3 |  * |  9 |
 //                  +---+---+----+----+
 //   matrix         | 1 | 4 |  7 | 10 |
 //                  +---+---+----+----+
@@ -966,17 +965,16 @@ elem_xpow (const Complex& a, const Range
             result(i) = (limit *= inc);
         }
 
       retval = result;
     }
   else
     retval = elem_xpow (a, r.matrix_value ());
 
-
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, double b)
 {
   octave_idx_type nr = a.rows ();
diff --git a/libinterp/corefcn/xpow.h b/libinterp/corefcn/xpow.h
--- a/libinterp/corefcn/xpow.h
+++ b/libinterp/corefcn/xpow.h
@@ -88,17 +88,16 @@ extern OCTINTERP_API octave_value elem_x
 extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a, double b);
 extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
                                              const Matrix& b);
 extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
                                              const Complex& b);
 extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
                                              const ComplexMatrix& b);
 
-
 extern OCTINTERP_API octave_value elem_xpow (double a, const NDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (double a, const ComplexNDArray& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const NDArray& a, double b);
 extern OCTINTERP_API octave_value elem_xpow (const NDArray& a,
                                              const NDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (const NDArray& a,
                                              const Complex& b);
@@ -170,17 +169,16 @@ extern OCTINTERP_API octave_value elem_x
                                              float b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
                                              const FloatMatrix& b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
                                              const FloatComplex& b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
                                              const FloatComplexMatrix& b);
 
-
 extern OCTINTERP_API octave_value elem_xpow (float a, const FloatNDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (float a,
                                              const FloatComplexNDArray& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a, float b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a,
                                              const FloatNDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a,
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -1,13 +1,12 @@
 /*
 
 Copyright (C) 2005-2015 Ludwig Schwardt, Kevin Ruland
 
-
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
 Octave is distributed in the hope that it will be useful, but WITHOUT
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -390,17 +390,16 @@ Undocumented internal function.
     have_sigma = true;
 
   octave_idx_type nconv;
   if (a_is_complex || b_is_complex)
     {
       ComplexMatrix eig_vec;
       ComplexColumnVector eig_val;
 
-
       if (have_a_fun)
         nconv = EigsComplexNonSymmetricFunc
           (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
            eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
            disp, maxit);
       else if (have_sigma)
         {
           if (a_is_sparse)
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -389,17 +389,16 @@ public:
     Matrix retval = do_find_uimenu_children (uimenu_childs);
     return retval;
   }
 
   Matrix do_find_uimenu_children (Matrix uimenu_childs) const
   {
     octave_idx_type k = 0;
 
-
     Matrix pos = Matrix (uimenu_childs.numel (), 1);
 
     for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
       {
         graphics_object kidgo = gh_manager::get_object (uimenu_childs (ii));
 
         if (kidgo.valid_object () && kidgo.isa ("uimenu"))
           {
@@ -1114,17 +1113,16 @@ private:
   Fl_Button* rotate;
   Fl_Button* help;
   Fl_Output* status;
   Fl_Box* resize_dummy;
   graphics_object ax_obj;
   int pos_x;
   int pos_y;
 
-
   void axis_auto (void)
   {
     octave_value_list args;
     if (fp.get_currentaxes ().ok ())
       {
         args(0) = fp.get_currentaxes ().as_octave_value ();
         args(1) = "auto";
         feval ("axis", args);
@@ -1724,17 +1722,16 @@ private:
                     // Control how fast to zoom when using scroll wheel.
                     double wheel_zoom_speed = ap.get_mousewheelzoom ();
 
                     // Determine if we're zooming in or out.
                     const double factor = (Fl::event_dy () < 0
                                            ? 1 / (1.0 - wheel_zoom_speed)
                                            : 1.0 - wheel_zoom_speed);
 
-
                     // Get the point we're zooming about.
                     double x1, y1;
                     pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (),
                                x1, y1);
 
                     // FIXME: should we only zoom about point for 2D plots?
 
                     ap.zoom_about_point ("both", x1, y1, factor, false);
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -34,29 +34,26 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-struct.h"
 #include "pager.h"
 
-
 #if defined (HAVE_SNDFILE)
 #  include <sndfile.h>
 #endif
 
 #if defined (HAVE_SNDFILE)
-
 static void
 safe_close (SNDFILE *file)
 {
   sf_close (file);
 }
-
 #endif
 
 DEFUN_DLD (audioread, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {[@var{y}, @var{fs}] =} audioread (@var{filename})
 @deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples})
 
 @deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{datatype})
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -451,17 +451,16 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
           if (knobs[CCOLAMD_AGGRESSIVE] != 0)
             octave_stdout << "knobs(2): " << User_knobs(1)
                           << ", aggressive absorption: yes";
           else
             octave_stdout << "knobs(2): " << User_knobs(1)
                           << ", aggressive absorption: no";
 
-
           octave_stdout << "knobs(3): " << User_knobs(2)
                         << ", statistics and knobs printed\n";
         }
     }
 
   octave_idx_type n_row, n_col;
   octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -17,17 +17,16 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "chol.h"
 #include "sparse-chol.h"
 #include "oct-spparms.h"
 #include "sparse-util.h"
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -25,17 +25,16 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "qr.h"
 #include "qrp.h"
 #include "sparse-qr.h"
 
-
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <typename MT>
 static octave_value
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -64,17 +64,16 @@ octave_base_diag<DMT, MT>::subsref (cons
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
-
 template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT,MT>::diag (octave_idx_type k) const
 {
   octave_value retval;
   if (matrix.rows () == 1 || matrix.cols () == 1)
     {
       // Rather odd special case.  This is a row or column vector
@@ -89,17 +88,16 @@ octave_base_diag<DMT,MT>::diag (octave_i
         retval = matrix.array_value ().diag (k);
     }
   else
     // Returns Array<T> vector
     retval = matrix.extract_diag (k);
   return retval;
 }
 
-
 template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::do_index_op (const octave_value_list& idx,
                                         bool resize_ok)
 {
   octave_value retval;
 
   if (idx.length () == 2 && ! resize_ok)
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -117,17 +117,16 @@ struct octave_base_int_helper_traits<sig
 };
 
 template <>
 struct octave_base_int_helper_traits<unsigned char>
 {
   static const bool can_be_larger_than_uchar_max = false;
 };
 
-
 template <typename T>
 octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (this->matrix.numel () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -220,17 +220,16 @@ octave_base_sparse<T>::assign (const oct
     }
   catch (index_exception& e)
     {
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (len, k+1);
       throw;
     }
 
-
   // Invalidate matrix type.
   typ.invalidate_type ();
 }
 
 template <typename MT>
 void
 octave_base_sparse<MT>::delete_elements (const octave_value_list& idx)
 {
@@ -466,17 +465,16 @@ octave_base_sparse<T>::load_ascii (std::
   if (! is)
     error ("load: failed to load matrix constant");
 
   matrix = tmp;
 
   return true;
 }
 
-
 template <typename T>
 octave_value
 octave_base_sparse<T>::fast_elem_extract (octave_idx_type n) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
 
   octave_idx_type i = n % nr;
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1007,17 +1007,16 @@ octave_base_value::sort_rows_idx (sortmo
 }
 
 sortmode
 octave_base_value::is_sorted_rows (sortmode) const
 {
   err_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
 }
 
-
 const char *
 octave_base_value::get_umap_name (unary_mapper_t umap)
 {
   static const char *names[num_unary_mappers] =
   {
     "abs",
     "acos",
     "acosh",
@@ -1329,17 +1328,16 @@ octave_base_value::newline (std::ostream
 
 void
 octave_base_value::reset (void) const
 {
   beginning_of_line = true;
   curr_print_indent_level = 0;
 }
 
-
 octave_value
 octave_base_value::fast_elem_extract (octave_idx_type) const
 {
   return octave_value ();
 }
 
 bool
 octave_base_value::fast_elem_insert (octave_idx_type, const octave_value&)
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -159,17 +159,16 @@ DEF_CLASS_TO_BTYP (char, btyp_char);
     static std::string static_class_name (void) { return c_name; } \
     static void register_type (void); \
  \
   private: \
     static int t_id; \
     static const std::string t_name; \
     static const std::string c_name;
 
-
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
   int t::t_id (-1); \
   const std::string t::t_name (n); \
   const std::string t::c_name (c); \
   void t::register_type (void) \
     { \
       static t exemplar; \
       octave_value v (&exemplar, true); \
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -48,17 +48,16 @@ along with Octave; see the file COPYING.
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 template class octave_base_matrix<boolNDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool_matrix,
                                      "bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_bool_matrix& v = dynamic_cast<const octave_bool_matrix&> (a);
 
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -226,13 +226,12 @@ public:
   octave_value map (unary_mapper_t umap) const
   {
     octave_matrix m (array_value ());
     return m.map (umap);
   }
 
 protected:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -46,17 +46,16 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 template class OCTINTERP_API octave_base_sparse<SparseBoolMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix,
                                      "sparse bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
 
@@ -188,17 +187,16 @@ octave_sparse_bool_matrix::bool_matrix_v
 }
 
 boolNDArray
 octave_sparse_bool_matrix::bool_array_value (bool) const
 {
   return boolNDArray (matrix.matrix_value ());
 }
 
-
 SparseMatrix
 octave_sparse_bool_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (this->matrix);
 }
 
 SparseComplexMatrix
 octave_sparse_bool_matrix::sparse_complex_matrix_value (bool) const
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -147,13 +147,12 @@ public:
   octave_value map (unary_mapper_t umap) const
   {
     octave_sparse_matrix m (sparse_matrix_value ());
     return m.map (umap);
   }
 
 protected:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -45,20 +45,18 @@ along with Octave; see the file COPYING.
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_scalar<bool>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool, "bool", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_bool& v = dynamic_cast<const octave_bool&> (a);
 
   return new octave_scalar (v.bool_value ());
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -238,13 +238,12 @@ public:
   octave_value map (unary_mapper_t umap) const
   {
     octave_scalar m (scalar_value ());
     return m.map (umap);
   }
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -107,13 +107,12 @@ protected:
 private:
 
   // No copying!
 
   octave_builtin (const octave_builtin& ob);
 
   octave_builtin& operator = (const octave_builtin& ob);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -120,17 +120,16 @@ octave_base_matrix<Cell>::fast_elem_inse
   if (retval)
     matrix(n) = xrep->matrix(0);
 
   return retval;
 }
 
 template class octave_base_matrix<Cell>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cell, "cell", "cell");
 
 octave_value_list
 octave_cell::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx,
                       int nargout,
                       const std::list<octave_lvalue> *lvalue_list)
 {
@@ -353,17 +352,16 @@ octave_cell::subsasgn (const std::string
 
             dim_vector didx = dims ().redim (idxf.length ());
             for (octave_idx_type k = 0; k < idxf.length (); k++)
               if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
 
             if (didx.numel () == tmp_cell.numel ())
               tmp_cell = tmp_cell.reshape (didx);
 
-
             octave_base_matrix<Cell>::assign (idxf, tmp_cell);
           }
         else if (idxf.all_scalars ()
                  || do_index_op (idxf, true).numel () == 1)
           // Regularize a null matrix if stored into a cell.
           octave_base_matrix<Cell>::assign (idxf,
                                             Cell (t_rhs.storable_value ()));
         else
@@ -426,17 +424,16 @@ octave_cell::assign (const octave_value_
 
 void
 octave_cell::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   clear_cellstr_cache ();
   octave_base_matrix<Cell>::assign (idx, rhs);
 }
 
-
 void
 octave_cell::delete_elements (const octave_value_list& idx)
 {
   clear_cellstr_cache ();
   octave_base_matrix<Cell>::delete_elements (idx);
 }
 
 size_t
@@ -497,17 +494,16 @@ octave_cell::is_sorted (sortmode mode) c
 
   Array<std::string> tmp = cellstr_value ();
 
   retval = tmp.is_sorted (mode);
 
   return retval;
 }
 
-
 Array<octave_idx_type>
 octave_cell::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> retval;
 
   if (! is_cellstr ())
     error ("sortrows: only cell arrays of character strings may be sorted");
 
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -179,13 +179,12 @@ public:
 
 private:
 
   void clear_cellstr_cache (void) const
   { cellstr_cache.reset (); }
 
   mutable std::unique_ptr<Array<std::string> > cellstr_cache;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -979,17 +979,16 @@ octave_class::string_vector_value (bool 
         error ("cname/char method did not return a string");
 
       retval = tmp(0).string_vector_value (pad);
     }
 
   return retval;
 }
 
-
 void
 octave_class::print (std::ostream& os, bool)
 {
   print_raw (os);
 }
 
 void
 octave_class::print_raw (std::ostream& os, bool) const
@@ -1661,17 +1660,16 @@ octave_class::exemplar_info::exemplar_in
     error ("invalid call to exemplar_info constructor");
 
   octave_map m = obj.map_value ();
   field_names = m.keys ();
 
   parent_class_names = obj.parent_class_name_list ();
 }
 
-
 // A map from class names to lists of fields.
 std::map<std::string, octave_class::exemplar_info> octave_class::exemplar_map;
 
 bool
 octave_class::exemplar_info::compare (const octave_value& obj) const
 {
 
   if (! obj.is_object ())
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -200,20 +200,18 @@ public:
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
 private:
-
   octave_map map;
 
-
 public:
   int type_id (void) const { return t_id; }
   std::string type_name (void) const { return t_name; }
   std::string class_name (void) const { return c_name; }
 
   static int static_type_id (void) { return t_id; }
   static std::string static_type_name (void) { return t_name; }
   static std::string static_class_name (void) { return "<unknown>"; }
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -807,17 +807,16 @@ make_package (const std::string& nm,
   if (! nm.empty ())
     cdef_manager::register_package (pack);
 
   return pack;
 }
 
 //----------------------------------------------------------------------------
 
-
 int octave_classdef::t_id (-1);
 
 const std::string octave_classdef::t_name ("object");
 
 void
 octave_classdef::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -51,20 +51,18 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 extern template class OCTINTERP_API octave_base_scalar<FloatComplex>;
 
-
 template class octave_base_scalar<Complex>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex,
                                      "complex scalar", "double");
 
 // Complain if a complex value is used as a subscript.
 
 class complex_index_exception : public index_exception
 {
 public:
@@ -312,17 +310,16 @@ octave_complex::load_ascii (std::istream
   scalar = octave_read_value<Complex> (is);
 
   if (! is)
     error ("load: failed to load complex scalar constant");
 
   return true;
 }
 
-
 bool
 octave_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = static_cast<char> (LS_DOUBLE);
   os.write (reinterpret_cast<char *> (&tmp), 1);
   Complex ctmp = complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 16);
 
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -187,15 +187,14 @@ public:
   }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_complex octave_complex_scalar;
 
 #endif
diff --git a/libinterp/octave-value/ov-cs-list.cc b/libinterp/octave-value/ov-cs-list.cc
--- a/libinterp/octave-value/ov-cs-list.cc
+++ b/libinterp/octave-value/ov-cs-list.cc
@@ -35,18 +35,17 @@ along with Octave; see the file COPYING.
 #include "ov-cs-list.h"
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cs_list, "cs-list", "cs-list");
 
 octave_cs_list::octave_cs_list (const Cell& c)
   : octave_base_value (), lst (c)
-{
-}
+{ }
 
 octave_value
 octave_cs_list::subsref (const std::string&,
                          const std::list<octave_value_list>&)
 {
   err_indexed_cs_list ();
 }
 
diff --git a/libinterp/octave-value/ov-cs-list.h b/libinterp/octave-value/ov-cs-list.h
--- a/libinterp/octave-value/ov-cs-list.h
+++ b/libinterp/octave-value/ov-cs-list.h
@@ -79,13 +79,12 @@ public:
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int);
 
 private:
 
   // The list of Octave values.
   octave_value_list lst;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -29,19 +29,19 @@ along with Octave; see the file COPYING.
 #include "ov-cx-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-re-diag.h"
 #include "ov-base-diag.cc"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ls-utils.h"
 
+
 template class octave_base_diag<ComplexDiagMatrix, ComplexMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_diag_matrix,
                                      "complex diagonal matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
 
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -86,13 +86,12 @@ public:
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          Complex&) const;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -52,19 +52,19 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "pr-output.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
+
 template class octave_base_matrix<ComplexNDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_matrix,
                                      "complex matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
 
@@ -437,17 +437,16 @@ octave_complex_matrix::save_binary (std:
     }
   else if (dv.numel () > 4096) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
-
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
                  2 * dv.numel ());
 
   return true;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -173,13 +173,12 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -44,19 +44,19 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
 
+
 template class OCTINTERP_API octave_base_sparse<SparseComplexMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_complex_matrix,
                                      "sparse complex matrix", "double");
 
 octave_base_value *
 octave_sparse_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -148,13 +148,12 @@ public:
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-dld-fcn.cc b/libinterp/octave-value/ov-dld-fcn.cc
--- a/libinterp/octave-value/ov-dld-fcn.cc
+++ b/libinterp/octave-value/ov-dld-fcn.cc
@@ -33,17 +33,16 @@ along with Octave; see the file COPYING.
 #include "ov-dld-fcn.h"
 #include "ov.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_dld_function,
                                      "dynamically-linked function",
                                      "dynamically-linked function");
 
-
 octave_dld_function::octave_dld_function
   (octave_builtin::fcn ff, const octave::dynamic_library& shl,
    const std::string& nm, const std::string& ds)
   : octave_builtin (ff, nm, ds), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
 
   std::string file_name = fcn_file_name ();
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -90,13 +90,12 @@ private:
   bool system_fcn_file;
 
   // No copying!
 
   octave_dld_function (const octave_dld_function& fn);
 
   octave_dld_function& operator = (const octave_dld_function& fn);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -25,17 +25,16 @@ along with Octave; see the file COPYING.
 #define octave_ov_fcn_handle_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 #include <memory>
 
-
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 
 // Function handles.
 
 class
@@ -158,17 +157,16 @@ public:
 
   // Simple function handles are printed without a newline.
   bool print_as_scalar (void) const { return nm != anonymous; }
 
 private:
 
   bool set_fcn (const std::string &octaveroot, const std::string& fpath);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
 protected:
 
   // The function we are handling.
   octave_value fcn;
 
   // The name of the handle, including the "@".
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -23,17 +23,16 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_ov_fcn_inline_h)
 #define octave_ov_fcn_inline_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <string>
 
-
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "symtab.h"
 #include "ov-fcn-handle.h"
 
 // Inline functions.
@@ -86,17 +85,16 @@ public:
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
   // The expression of an inline function.
   std::string iftext;
 
   // The args of an inline function.
   string_vector ifargs;
 };
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -47,19 +47,19 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "xdiv.h"
 #include "xpow.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
+
 template class octave_base_scalar<float>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_scalar, "float scalar",
                                      "single");
 
 octave_value
 octave_float_scalar::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   // FIXME: this doesn't solve the problem of
   //
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -248,13 +248,12 @@ public:
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -49,20 +49,18 @@ along with Octave; see the file COPYING.
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<float>;
 
-
 template class octave_base_scalar<FloatComplex>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex,
                                      "float complex scalar", "single");
 
 octave_base_value *
 octave_float_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
@@ -262,17 +260,16 @@ octave_float_complex::load_ascii (std::i
   scalar = octave_read_value<FloatComplex> (is);
 
   if (! is)
     error ("load: failed to load complex scalar constant");
 
   return true;
 }
 
-
 bool
 octave_float_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = static_cast<char> (LS_FLOAT);
   os.write (reinterpret_cast<char *> (&tmp), 1);
   FloatComplex ctmp = float_complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 8);
 
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -183,15 +183,14 @@ public:
   }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_float_complex octave_float_complex_scalar;
 
 #endif
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -28,19 +28,19 @@ along with Octave; see the file COPYING.
 
 #include "ov-flt-cx-diag.h"
 #include "ov-base-diag.cc"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-complex.h"
 #include "ov-flt-cx-mat.h"
 #include "ls-utils.h"
 
+
 template class octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_diag_matrix,
                                      "float complex diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
@@ -138,17 +138,16 @@ octave_float_complex_diag_matrix::map (u
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
-
 bool
 octave_float_complex_diag_matrix::save_binary (std::ostream& os,
                                                bool& /* save_as_floats */)
 {
 
   int32_t r = matrix.rows ();
   int32_t c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -84,13 +84,12 @@ public:
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          FloatComplex&) const;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -56,19 +56,19 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "ops.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
+
 template class octave_base_matrix<FloatComplexNDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_matrix,
                                      "float complex matrix", "single");
 
 octave_base_value *
 octave_float_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -169,13 +169,12 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -27,19 +27,19 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 
 #include "ov-flt-re-diag.h"
 #include "ov-base-diag.cc"
 #include "ov-float.h"
 #include "ov-flt-re-mat.h"
 #include "ls-utils.h"
 
+
 template class octave_base_diag<FloatDiagMatrix, FloatMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_diag_matrix,
                                      "float diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
 
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -84,13 +84,12 @@ public:
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          float&) const;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -64,19 +64,19 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "ops.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+
 template class octave_base_matrix<FloatNDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix",
                                      "single");
 
 octave_base_value *
 octave_float_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<int16NDArray>;
 
 template class octave_base_int_matrix<int16NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_matrix,
                                      "int16 matrix", "int16");
 
 template class octave_base_scalar<octave_int16>;
 
 template class octave_base_int_scalar<octave_int16>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
                                      "int16 scalar", "int16");
 
 DEFUN (int16, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} int16 (@var{x})
 Convert @var{x} to 16-bit integer type.
 @seealso{int8, uint8, uint16, int32, uint32, int64, uint64}
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<int32NDArray>;
 
 template class octave_base_int_matrix<int32NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_matrix,
                                      "int32 matrix", "int32");
 
 template class octave_base_scalar<octave_int32>;
 
 template class octave_base_int_scalar<octave_int32>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
                                      "int32 scalar", "int32");
 
 DEFUN (int32, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} int32 (@var{x})
 Convert @var{x} to 32-bit integer type.
 @seealso{int8, uint8, int16, uint16, uint32, int64, uint64}
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<int64NDArray>;
 
 template class octave_base_int_matrix<int64NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_matrix,
                                      "int64 matrix", "int64");
 
 template class octave_base_scalar<octave_int64>;
 
 template class octave_base_int_scalar<octave_int64>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
                                      "int64 scalar", "int64");
 
 DEFUN (int64, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} int64 (@var{x})
 Convert @var{x} to 64-bit integer type.
 @seealso{int8, uint8, int16, uint16, int32, uint32, uint64}
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<int8NDArray>;
 
 template class octave_base_int_matrix<int8NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_matrix,
                                      "int8 matrix", "int8");
 
 template class octave_base_scalar<octave_int8>;
 
 template class octave_base_int_scalar<octave_int8>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
                                      "int8 scalar", "int8");
 
 DEFUN (int8, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} int8 (@var{x})
 Convert @var{x} to 8-bit integer type.
 @seealso{uint8, int16, uint16, int32, uint32, int64, uint64}
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -366,17 +366,16 @@ public:
           octave_matrix m (array_value ());
           return m.map (umap);
         }
       }
   }
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 class
 OCTINTERP_API
 OCTAVE_VALUE_INT_SCALAR_T
   : public octave_base_int_scalar<OCTAVE_INT_T>
 {
@@ -670,11 +669,10 @@ public:
           octave_scalar m (scalar_value ());
           return m.map (umap);
         }
       }
   }
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -172,17 +172,16 @@ bool octave_lazy_index::load_ascii (std:
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
 
   index = value.index_vector ();
 
   return true;
 }
 
-
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
   return save_binary_data (os, make_value (), value_save_tag,
                            "", false, save_as_floats);
 }
 
 bool octave_lazy_index::load_binary (std::istream& is, bool swap,
                                      octave::mach_info::float_format fmt)
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -202,17 +202,16 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
-
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -109,13 +109,12 @@ private:
   bool system_fcn_file;
 
   // No copying!
 
   octave_mex_function (const octave_mex_function& fn);
 
   octave_mex_function& operator = (const octave_mex_function& fn);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-null-mat.h b/libinterp/octave-value/ov-null-mat.h
--- a/libinterp/octave-value/ov-null-mat.h
+++ b/libinterp/octave-value/ov-null-mat.h
@@ -68,17 +68,16 @@ octave_null_str : public octave_char_mat
 public:
 
   static const octave_value instance;
 
   bool is_null_value (void) const { return true; }
 
   type_conv_info numeric_conversion_function (void) const;
 
-
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // The special '' value
 
 class
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -399,27 +399,25 @@ octave_perm_matrix::write (octave_stream
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
                                 const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
-
 octave_value
 octave_perm_matrix::to_dense (void) const
 {
   if (! dense_cache.is_defined ())
     dense_cache = Matrix (matrix);
 
   return dense_cache;
 }
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix,
                                      "permutation matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_perm_matrix& v = dynamic_cast<const octave_perm_matrix&> (a);
 
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -227,13 +227,12 @@ protected:
   PermMatrix matrix;
 
   virtual octave_value to_dense (void) const;
 
   mutable octave_value dense_cache;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -44,17 +44,16 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 #include "ls-ascii-helper.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 // If TRUE, allow ranges with non-integer elements as array indices.
 static bool Vallow_noninteger_range_as_index = true;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_range, "range", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_range& v = dynamic_cast<const octave_range&> (a);
 
   return new octave_matrix (v.matrix_value ());
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -110,17 +110,16 @@ public:
   dim_vector dims (void) const
   {
     octave_idx_type n = range.numel ();
     return dim_vector (n > 0, n);
   }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
-
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
   octave_value reshape (const dim_vector& new_dims) const
   { return NDArray (array_value ().reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
   { return NDArray (array_value ().permute (vec, inv)); }
 
@@ -308,13 +307,12 @@ private:
   }
 
   mutable idx_vector *idx_cache;
 
   // No assignment.
 
   octave_range& operator = (const octave_range&);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -28,19 +28,19 @@ along with Octave; see the file COPYING.
 
 #include "ov-re-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-base-diag.cc"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ls-utils.h"
 
+
 template class octave_base_diag<DiagMatrix, Matrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_diag_matrix, "diagonal matrix",
                                      "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
 
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -89,13 +89,12 @@ public:
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          double&) const;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -64,19 +64,19 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+
 template class octave_base_matrix<NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_matrix, "matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
 
   return new octave_float_matrix (v.float_array_value ());
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -43,19 +43,19 @@ along with Octave; see the file COPYING.
 
 #include "ov-re-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
 
+
 template class OCTINTERP_API octave_base_sparse<SparseMatrix>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_matrix, "sparse matrix",
                                      "double");
 
 idx_vector
 octave_sparse_matrix::index_vector (bool /* require_integers */) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -152,13 +152,12 @@ public:
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
   octave_value map (double (*fcn) (double)) const;
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -52,20 +52,18 @@ along with Octave; see the file COPYING.
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<float>;
 
-
 template class octave_base_scalar<double>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_scalar, "scalar", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_float_scalar (v.float_value ());
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -247,13 +247,12 @@ public:
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -168,17 +168,16 @@ public:
 
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
                                      bool resize_ok, char type = '"');
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_char_matrix_str octave_char_matrix_dq_str;
 
 class
 octave_char_matrix_sq_str : public octave_char_matrix_str
 {
@@ -241,23 +240,21 @@ public:
   { return octave_value (matrix.diag (k), '\''); }
 
   bool is_sq_string (void) const { return true; }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
   { return do_index_op_internal (idx, resize_ok, '\''); }
 
-
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
   { return octave_value (matrix.sort (dim, mode), '\''); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
   { return octave_value (matrix.sort (sidx, dim, mode), '\''); }
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -432,17 +432,16 @@ octave_struct::subsasgn (const std::stri
                 dim_vector didx = dims ().redim (idxf.length ());
                 for (octave_idx_type k = 0; k < idxf.length (); k++)
                   if (! idxf(k).is_magic_colon ())
                     didx(k) = idxf(k).numel ();
 
                 if (didx.numel () == tmp_cell.numel ())
                   tmp_cell = tmp_cell.reshape (didx);
 
-
                 map.assign (idxf, key, tmp_cell);
 
                 count++;
                 retval = octave_value (this);
               }
             else
               {
                 const octave_map& cmap =
@@ -646,17 +645,16 @@ octave_struct::print_name_tag (std::ostr
 }
 
 static bool
 scalar (const dim_vector& dims)
 {
   return dims.ndims () == 2 && dims(0) == 1 && dims(1) == 1;
 }
 
-
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
@@ -1604,17 +1602,16 @@ octave_scalar_struct::as_mxArray (void) 
       mwIndex k = 0;
       for (mwIndex j = i; j < ntot; j += nf)
         elts[j] = new mxArray (p[k++]);
     }
 
   return retval;
 }
 
-
 octave_value
 octave_scalar_struct::to_array (void)
 {
   return new octave_struct (octave_map (map));
 }
 
 bool
 octave_scalar_struct::fast_elem_insert_self (void *where,
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -156,17 +156,16 @@ public:
 
 protected:
 
   // The associative array used to manage the structure data.
   octave_map map;
 
 private:
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 class
 octave_scalar_struct : public octave_base_value
 {
 public:
 
@@ -189,17 +188,16 @@ public:
   octave_value dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int);
 
-
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   static octave_value numeric_conv (const octave_value& val,
                                     const std::string& type);
 
   octave_value subsasgn (const std::string& type,
@@ -274,13 +272,12 @@ protected:
 
   // The associative array used to manage the structure data.
   octave_scalar_map map;
 
 private:
 
   octave_value to_array (void);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-type-conv.h b/libinterp/octave-value/ov-type-conv.h
--- a/libinterp/octave-value/ov-type-conv.h
+++ b/libinterp/octave-value/ov-type-conv.h
@@ -70,17 +70,16 @@ octave_type_conv_body (const octave_valu
                 }
             }
         }
     }
 
   return retval;
 }
 
-
 #define OCTAVE_TYPE_CONV_BODY3(NAME, MATRIX_RESULT_T, SCALAR_RESULT_T) \
  \
   if (args.length () != 1) \
     print_usage (); \
  \
   octave_value retval; \
  \
   const octave_value arg = args(0); \
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<uint16NDArray>;
 
 template class octave_base_int_matrix<uint16NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_matrix,
                                      "uint16 matrix", "uint16");
 
 template class octave_base_scalar<octave_uint16>;
 
 template class octave_base_int_scalar<octave_uint16>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
                                      "uint16 scalar", "uint16");
 
 DEFUN (uint16, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} uint16 (@var{x})
 Convert @var{x} to unsigned 16-bit integer type.
 @seealso{int8, uint8, int16, int32, uint32, int64, uint64}
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<uint32NDArray>;
 
 template class octave_base_int_matrix<uint32NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_matrix,
                                      "uint32 matrix", "uint32");
 
 template class octave_base_scalar<octave_uint32>;
 
 template class octave_base_int_scalar<octave_uint32>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
                                      "uint32 scalar", "uint32");
 
 DEFUN (uint32, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} uint32 (@var{x})
 Convert @var{x} to unsigned 32-bit integer type.
 @seealso{int8, uint8, int16, uint16, int32, int64, uint64}
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<uint64NDArray>;
 
 template class octave_base_int_matrix<uint64NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_matrix,
                                      "uint64 matrix", "uint64");
 
 template class octave_base_scalar<octave_uint64>;
 
 template class octave_base_int_scalar<octave_uint64>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
                                      "uint64 scalar", "uint64");
 
 DEFUN (uint64, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} uint64 (@var{x})
 Convert @var{x} to unsigned 64-bit integer type.
 @seealso{int8, uint8, int16, uint16, int32, uint32, int64}
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -56,30 +56,27 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTINTERP_API octave_base_scalar<double>;
 
-
 template class octave_base_matrix<uint8NDArray>;
 
 template class octave_base_int_matrix<uint8NDArray>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_matrix,
                                      "uint8 matrix", "uint8");
 
 template class octave_base_scalar<octave_uint8>;
 
 template class octave_base_int_scalar<octave_uint8>;
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
                                      "uint8 scalar", "uint8");
 
 DEFUN (uint8, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} uint8 (@var{x})
 Convert @var{x} to unsigned 8-bit integer type.
 @seealso{int8, int16, uint16, int32, uint32, int64, uint64}
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -64,17 +64,16 @@ extern char Vstring_fill_char;   // see 
 std::map<std::string, octave_value>
 octave_user_code::subfunctions (void) const
 {
   return std::map<std::string, octave_value> ();
 }
 
 // User defined scripts.
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_script,
                                      "user-defined script",
                                      "user-defined script");
 
 octave_user_script::octave_user_script (void)
   : octave_user_code (), cmd_list (0), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
@@ -163,17 +162,16 @@ octave_user_script::do_multi_index_op (i
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
 }
 
 // User defined functions.
 
-
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -162,17 +162,16 @@ private:
   int call_depth;
 
   // No copying!
 
   octave_user_script (const octave_user_script& f);
 
   octave_user_script& operator = (const octave_user_script& f);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
@@ -517,13 +516,12 @@ private:
   void restore_warning_states (void);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn);
 
   octave_user_function& operator = (const octave_user_function& fn);
 
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -954,34 +954,30 @@ public:
 
   RowVector row_vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
   ComplexRowVector
   complex_row_vector_value (bool frc_str_conv = false,
                             bool frc_vec_conv = false) const;
 
-
   FloatColumnVector float_column_vector_value (bool frc_str_conv = false,
                                                bool frc_vec_conv = false) const;
 
   FloatComplexColumnVector
   float_complex_column_vector_value (bool frc_str_conv = false,
                                      bool frc_vec_conv = false) const;
 
   FloatRowVector float_row_vector_value (bool frc_str_conv = false,
                                          bool frc_vec_conv = false) const;
 
   FloatComplexRowVector
   float_complex_row_vector_value (bool frc_str_conv = false,
                                   bool frc_vec_conv = false) const;
 
-
-
-
   Array<int> int_vector_value (bool req_int = false,
                                bool frc_str_conv = false,
                                bool frc_vec_conv = false) const;
 
   Array<octave_idx_type>
   octave_idx_type_vector_value (bool req_int = false,
                                 bool frc_str_conv = false,
                                 bool frc_vec_conv = false) const;
@@ -1555,17 +1551,16 @@ DEF_VALUE_EXTRACTOR (octave_int8, int8_s
 DEF_VALUE_EXTRACTOR (octave_int16, int16_scalar)
 DEF_VALUE_EXTRACTOR (octave_int32, int32_scalar)
 DEF_VALUE_EXTRACTOR (octave_int64, int64_scalar)
 DEF_VALUE_EXTRACTOR (octave_uint8, uint8_scalar)
 DEF_VALUE_EXTRACTOR (octave_uint16, uint16_scalar)
 DEF_VALUE_EXTRACTOR (octave_uint32, uint32_scalar)
 DEF_VALUE_EXTRACTOR (octave_uint64, uint64_scalar)
 
-
 DEF_VALUE_EXTRACTOR (NDArray, array)
 DEF_VALUE_EXTRACTOR (FloatNDArray, float_array)
 DEF_VALUE_EXTRACTOR (ComplexNDArray, complex_array)
 DEF_VALUE_EXTRACTOR (FloatComplexNDArray, float_complex_array)
 DEF_VALUE_EXTRACTOR (boolNDArray, bool_array)
 
 DEF_VALUE_EXTRACTOR (charNDArray, char_array)
 DEF_VALUE_EXTRACTOR (int8NDArray, int8_array)
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -66,17 +66,16 @@ DEFBINOP (div, complex_matrix, matrix)
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
-
 DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
   const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -70,17 +70,16 @@ DEFBINOP (div, float_complex_matrix, flo
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
-
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
   const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -161,18 +161,16 @@ DEFNDBINOP_FN (el_not_and, float_matrix,
                float_array, mx_el_not_and)
 DEFNDBINOP_FN (el_not_or,  float_matrix, float_matrix, float_array,
                float_array, mx_el_not_or)
 DEFNDBINOP_FN (el_and_not, float_matrix, float_matrix, float_array,
                float_array, mx_el_and_not)
 DEFNDBINOP_FN (el_or_not,  float_matrix, float_matrix, float_array,
                float_array, mx_el_or_not)
 
-
-
 DEFNDCATOP_FN (fm_fm, float_matrix, float_matrix, float_array,
                float_array, concat)
 
 DEFNDCATOP_FN (m_fm, matrix, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_m, float_matrix, matrix, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -448,17 +448,16 @@ along with Octave; see the file COPYING.
     for (int i = 0; i < b.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a, b(i)); \
       } \
     return octave_value (result); \
   }
 
-
 #define OCTAVE_SM_CONV(TS, TM) \
   DEFCONV (TS ## s_ ## TM ## m_conv, TM ## scalar, TM ## matrix) \
   { \
     const octave_ ## TS ## scalar& v = dynamic_cast<const octave_ ## TS ## scalar&> (a); \
  \
     return new octave_ ## TM ## matrix (v.TM ## array_value ()); \
   }
 
@@ -614,17 +613,16 @@ octave_value elem_xpow (FloatNDArray a, 
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = powf (a(i), b); \
     } \
   return octave_value (result); \
 }
 
-
 #define OCTAVE_MS_INT_OPS(TYPE) \
   OCTAVE_MS_POW_OPS (TYPE, TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (ms, TYPE ## _, TYPE ## _, TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (msx, TYPE ## _, , TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (mxs, , TYPE ## _, TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (msfx, TYPE ## _, float_, TYPE) \
   OCTAVE_MS_INT_ARITH_OPS (mfxs, float_, TYPE ## _, TYPE) \
   OCTAVE_MS_INT_CMP_OPS (ms, TYPE ## _, TYPE ## _) \
@@ -825,17 +823,16 @@ octave_value elem_xpow (FloatNDArray a, 
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
   }
 
-
 #define OCTAVE_MM_CONV(T1, T2) \
   DEFCONV (T1 ## m_ ## T2 ## m_conv, T1 ## matrix, T2 ## matrix) \
   { \
     const octave_ ## T1 ## matrix& v = dynamic_cast<const octave_ ## T1 ## matrix&> (a); \
  \
     return new octave_ ## T2 ## matrix (v.T2 ## array_value ()); \
   }
 
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -141,17 +141,16 @@ DEFBINOP (el_ldiv, matrix, matrix)
 
 DEFNDBINOP_FN (el_and, matrix, matrix, array, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  matrix, matrix, array, array, mx_el_or)
 DEFNDBINOP_FN (el_not_and, matrix, matrix, array, array, mx_el_not_and)
 DEFNDBINOP_FN (el_not_or,  matrix, matrix, array, array, mx_el_not_or)
 DEFNDBINOP_FN (el_and_not, matrix, matrix, array, array, mx_el_and_not)
 DEFNDBINOP_FN (el_or_not,  matrix, matrix, array, array, mx_el_or_not)
 
-
 DEFNDCATOP_FN (m_m, matrix, matrix, array, array, concat)
 
 DEFNDASSIGNOP_FN (assign, matrix, matrix, array, assign)
 DEFNDASSIGNOP_FN (sgl_assign, float_matrix, matrix, float_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, matrix, delete_elements)
 
 DEFNDASSIGNOP_OP (assign_add, matrix, matrix, array, +=)
diff --git a/libinterp/operators/op-pm-template.cc b/libinterp/operators/op-pm-template.cc
--- a/libinterp/operators/op-pm-template.cc
+++ b/libinterp/operators/op-pm-template.cc
@@ -71,17 +71,16 @@ DEFBINOP (div, LMATRIX, RMATRIX)
 {
   const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
   const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return v1.LMATRIX_VALUE () * v2.perm_matrix_value ().inverse ();
 }
 #endif
 
-
 #define SHORT_NAME CONCAT3(LSHORT, _, RSHORT)
 #define INST_NAME CONCAT3(install_, SHORT_NAME, _ops)
 
 void
 INST_NAME (void)
 {
   INSTALL_BINOP (op_mul, OCTAVE_LMATRIX, OCTAVE_RMATRIX, mul);
 #if defined (LEFT)
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -99,17 +99,16 @@ public:
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   std::string profiler_name (void) const { return "binary " + oper (); }
 
-
 protected:
 
   // The operands for the expression.
   tree_expression *op_lhs;
   tree_expression *op_rhs;
 
 private:
 
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -112,17 +112,16 @@ tree_if_command::accept (tree_walker& tw
 
 tree_switch_case::~tree_switch_case (void)
 {
   delete label;
   delete list;
   delete lead_comm;
 }
 
-
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
   if (label_value.is_defined ())
     {
       if (label_value.is_cell ())
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -297,17 +297,16 @@ tree_statement_list::remove_all_breakpoi
 
       if (! file.empty ())
         octave_link::update_breakpoint (false, file, lineno);
     }
 
   return retval;
 }
 
-
 tree_statement_list *
 tree_statement_list::dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const
 {
   tree_statement_list *new_list = new tree_statement_list ();
 
   new_list->function_body = function_body;
 
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -107,17 +107,16 @@ public:
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   std::string profiler_name (void) const { return "prefix " + oper (); }
 
-
 private:
 
   // No copying!
 
   tree_prefix_expression (const tree_prefix_expression&);
 
   tree_prefix_expression& operator = (const tree_prefix_expression&);
 };
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -652,18 +652,16 @@ ind2sub (const dim_vector& dv, const idx
               k /= dv(j);
             }
         }
 
       for (octave_idx_type j = 0; j < n; j++)
         retval(j) = rdata[j];
     }
 
-
-
   return retval;
 }
 
 int
 permute_vector_compare (const void *a, const void *b)
 {
   const permute_vector *pva = static_cast<const permute_vector *> (a);
   const permute_vector *pvb = static_cast<const permute_vector *> (b);
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -439,17 +439,16 @@ private:
   rec_permute_helper& operator = (const rec_permute_helper&);
 
 public:
 
   template <typename T>
   void permute (const T *src, T *dest) const { do_permute (src, dest, top); }
 };
 
-
 template <typename T>
 Array<T>
 Array<T>::permute (const Array<octave_idx_type>& perm_vec_arg, bool inv) const
 {
   Array<T> retval;
 
   Array<octave_idx_type> perm_vec = perm_vec_arg;
 
@@ -856,17 +855,16 @@ Array<T>::index (const Array<idx_vector>
       for (int i = 0; i < ial; i++)
         {
           if (ia(i).extent (dv(i)) != dv(i))
             err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
 
           all_colons = all_colons && ia(i).is_colon ();
         }
 
-
       if (all_colons)
         {
           // A(:,:,...,:) produces a shallow copy.
           dv.chop_trailing_singletons ();
           retval = Array<T> (*this, dv);
         }
       else
         {
@@ -1122,17 +1120,16 @@ Array<T>::index (const Array<idx_vector>
           if (tmp.dimensions != dvx)
             return Array<T> ();
         }
     }
 
   return tmp.index (ia);
 }
 
-
 template <typename T>
 void
 Array<T>::assign (const idx_vector& i, const Array<T>& rhs, const T& rfv)
 {
   octave_idx_type n = numel ();
   octave_idx_type rhl = rhs.numel ();
 
   if (rhl != 1 && i.length (n) != rhl)
@@ -1606,17 +1603,16 @@ Array<T>::insert (const Array<T>& a, con
   for (octave_idx_type k = 0; k < n; k++)
     idx(k) = idx_vector (ra_idx(k), ra_idx(k) + dva(k));
 
   assign (idx, a);
 
   return *this;
 }
 
-
 template <typename T>
 Array<T>
 Array<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
@@ -2096,17 +2092,16 @@ Array<T>::sort_rows_idx (sortmode mode) 
 
   idx = Array<octave_idx_type> (dim_vector (r, 1));
 
   lsort.sort_rows (data (), idx.fortran_vec (), r, c);
 
   return idx;
 }
 
-
 template <typename T>
 sortmode
 Array<T>::is_sorted_rows (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
@@ -2506,17 +2501,16 @@ Array<T>::nnz (void) const\
 { return 0; } \
 template <> Array<octave_idx_type> \
 Array<T>::find (octave_idx_type, bool) const\
 { return Array<octave_idx_type> (); } \
  \
 template <> Array<T>  \
 Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); }
 
-
 template <typename T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.ndims ();
   Array<T> d;
 
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -513,17 +513,16 @@ public:
   //@}
 
   //@{
   //! Indexing with possible resizing and fill
 
   // FIXME: this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
-
   Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
   Array<T> index (const idx_vector& i, bool resize_ok) const
   {
     return index (i, resize_ok, resize_fill_value ());
   }
 
   Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok,
                   const T& rfv) const;
@@ -536,17 +535,16 @@ public:
   Array<T> index (const Array<idx_vector>& ia, bool resize_ok,
                   const T& rfv) const;
   Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const
   {
     return index (ia, resize_ok, resize_fill_value ());
   }
   //@}
 
-
   //@{
   //! Indexed assignment (always with resize & fill).
   void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);
   void assign (const idx_vector& i, const Array<T>& rhs)
   {
     assign (i, rhs, resize_fill_value ());
   }
 
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -136,17 +136,16 @@ ComplexColumnVector::fill (const Complex
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
-
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
@@ -336,17 +335,16 @@ operator * (const ComplexMatrix& m, cons
 
           F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                    nr, nc, 1.0, m.data (), nr,
                                    a.data (), 1, 0.0, y, 1
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
-
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const Matrix& m, const ComplexColumnVector& a)
 {
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1560,17 +1560,16 @@ ComplexMatrix::determinant (MatrixType& 
   else if (typ == MatrixType::Hermitian)
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-
       char job = 'L';
       F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
@@ -1786,17 +1785,16 @@ ComplexMatrix::rcond (MatrixType &mattyp
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
-
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
@@ -2028,17 +2026,16 @@ ComplexMatrix::fsolve (MatrixType &matty
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -452,17 +452,16 @@ extern OCTAVE_API ComplexMatrix max (con
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& m, const Complex& c);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& a,
                                      const ComplexMatrix& b);
 
 extern OCTAVE_API ComplexMatrix linspace (const ComplexColumnVector& x1,
                                           const ComplexColumnVector& x2,
                                           octave_idx_type n);
 
-
 MS_CMP_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 MS_BOOL_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -264,17 +264,16 @@ SparseComplexMatrix::max (int dim) const
 SparseComplexMatrix
 SparseComplexMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
-
   if (dim >= dv.ndims ())
     {
       idx_arg.resize (dim_vector (nr, nc), 0);
       return *this;
     }
 
   if (dim < 0)
     dim = dv.first_non_singleton ();
@@ -891,17 +890,16 @@ SparseComplexMatrix::tinverse (MatrixTyp
                     {
                       v -= retval.xdata (colXp) * data (colUp);
                       colXp++;
                       colUp++;
                     }
                 }
               while (rpX < j && rpU < j && colXp < cx && colUp < nz);
 
-
               // get A(m,m)
               if (typ == MatrixType::Upper)
                 colUp = cidx (j+1) - 1;
               else
                 colUp = cidx (j);
               Complex pivot = data (colUp);
               if (pivot == 0. || ridx (colUp) != j)
                 (*current_liboctave_error_handler) ("division by zero");
@@ -3286,17 +3284,16 @@ SparseComplexMatrix::ltsolve (MatrixType
               rcond = 1. / ainvnorm / anorm;
             }
         }
       else
         {
           OCTAVE_LOCAL_BUFFER (Complex, work, nm);
           retval.resize (nc, b_nc, 0.);
 
-
           for (octave_idx_type j = 0; j < b_nc; j++)
             {
               for (octave_idx_type i = 0; i < nr; i++)
                 work[i] = b(i,j);
               for (octave_idx_type i = nr; i < nc; i++)
                 work[i] = 0.;
 
               for (octave_idx_type k = 0; k < nc; k++)
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -274,17 +274,16 @@ operator -= (MArray<T>& a, const MArray<
 {
   if (a.is_shared ())
     a = a - b;
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_sub2, mx_inline_sub2, "-=");
   return a;
 }
 
-
 template <typename T>
 MArray<T>&
 product_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = product (a, b);
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_mul2, mx_inline_mul2, ".*=");
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -104,17 +104,16 @@ operator += (MSparse<T>& a, const MSpars
 
 template <typename T>
 MSparse<T>&
 operator -= (MSparse<T>& a, const MSparse<T>& b)
 {
   return plus_or_minus (a, b, std::minus<T> (), "operator -=");
 }
 
-
 // Element by element MSparse by scalar ops.
 
 template <typename T, typename OP>
 MArray<T>
 plus_or_minus (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
@@ -136,17 +135,16 @@ operator + (const MSparse<T>& a, const T
 
 template <typename T>
 MArray<T>
 operator - (const MSparse<T>& a, const T& s)
 {
   return plus_or_minus (a, s, std::minus<T> ());
 }
 
-
 template <typename T, typename OP>
 MSparse<T>
 times_or_divide (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
@@ -172,17 +170,16 @@ operator * (const MSparse<T>& a, const T
 
 template <typename T>
 MSparse<T>
 operator / (const MSparse<T>& a, const T& s)
 {
   return times_or_divide (a, s, std::divides<T> ());
 }
 
-
 // Element by element scalar by MSparse ops.
 
 template <typename T, typename OP>
 MArray<T>
 plus_or_minus (const T& s, const MSparse<T>& a, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
@@ -239,17 +236,16 @@ operator * (const T& s, const MSparse<T>
 
 template <typename T>
 MSparse<T>
 operator / (const T& s, const MSparse<T>& a)
 {
   return times_or_divides (s, a, std::divides<T> ());
 }
 
-
 // Element by element MSparse by MSparse ops.
 
 template <typename T, typename OP>
 MSparse<T>
 plus_or_minus (const MSparse<T>& a, const MSparse<T>& b, OP op,
                const char* op_name, bool negate)
 {
   MSparse<T> r;
@@ -586,18 +582,16 @@ quotient (const MSparse<T>& a, const MSp
         }
 
       r.maybe_compress (true);
     }
 
   return r;
 }
 
-
-
 // Unary MSparse ops.
 
 template <typename T>
 MSparse<T>
 operator + (const MSparse<T>& a)
 {
   return a;
 }
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -177,17 +177,16 @@ matrix_complex_probe (const MArray<std::
               std::complex<T> aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
               hermitian = hermitian && (aij == std::conj (aji)
                                         && std::norm (aij) < diag[i]*diag[j]);
             }
         }
 
-
       if (upper)
         typ = MatrixType::Upper;
       else if (lower)
         typ = MatrixType::Lower;
       else if (hermitian)
         typ = MatrixType::Hermitian;
       else if (ncols == nrows)
         typ = MatrixType::Full;
@@ -209,17 +208,16 @@ MatrixType::MatrixType (const Matrix &a)
 MatrixType::MatrixType (const ComplexMatrix &a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_complex_probe (a);
 }
 
-
 MatrixType::MatrixType (const FloatMatrix &a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
     dense (false), full (true), nperm (0), perm (0)
 {
   typ = matrix_real_probe (a);
 }
 
@@ -507,17 +505,16 @@ MatrixType::MatrixType (const SparseMatr
                       double d = a.data (i);
                       is_herm = d > 0.;
                       diag(j) = d;
                       break;
                     }
                 }
             }
 
-
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             for (octave_idx_type i = a.cidx (j); is_herm && i < a.cidx (j+1); i++)
               {
                 octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
@@ -849,17 +846,16 @@ MatrixType::MatrixType (const SparseComp
                           {
                             is_herm = a.data (l) == d;
                             break;
                           }
                       }
                   }
               }
 
-
           if (is_herm)
             {
               if (typ == MatrixType::Full)
                 typ = MatrixType::Hermitian;
               else if (typ == MatrixType::Banded)
                 typ = MatrixType::Banded_Hermitian;
               else
                 typ = MatrixType::Tridiagonal_Hermitian;
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -101,17 +101,16 @@ PermMatrix::checkelem (octave_idx_type i
 {
   octave_idx_type len = Array<octave_idx_type>::numel ();
   if (i < 0 || j < 0 || i > len || j > len)
     (*current_liboctave_error_handler) ("index out of range");
 
   return elem (i, j);
 }
 
-
 PermMatrix
 PermMatrix::transpose (void) const
 {
   octave_idx_type len = Array<octave_idx_type>::numel ();
 
   PermMatrix retval (len);
 
   for (octave_idx_type i = 0; i < len; ++i)
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -431,17 +431,16 @@ Range operator * (const Range& r, double
 {
   Range result (r.base () * x, r.limit () * x, r.inc () * x, r.numel ());
   if (result.rng_numel < 0)
     result.cache = r.matrix_value () * x;
 
   return result;
 }
 
-
 // C  See Knuth, Art Of Computer Programming, Vol. 1, Problem 1.2.4-5.
 // C
 // C===Tolerant FLOOR function.
 // C
 // C    X  -  is given as a Double Precision argument to be operated on.
 // C          It is assumed that X is represented with M mantissa bits.
 // C    CT -  is   given   as   a   Comparison   Tolerance   such   that
 // C          0.LT.CT.LE.3-SQRT(5)/2. If the relative difference between
diff --git a/liboctave/array/Sparse-C.cc b/liboctave/array/Sparse-C.cc
--- a/liboctave/array/Sparse-C.cc
+++ b/liboctave/array/Sparse-C.cc
@@ -36,17 +36,16 @@ along with Octave; see the file COPYING.
 
 static double
 xabs (const Complex& x)
 {
   return ((octave::math::isinf (x.real ()) || octave::math::isinf (x.imag ()))
           ? octave::numeric_limits<double>::Inf () : abs (x));
 }
 
-
 template <>
 bool
 sparse_ascending_compare<Complex> (const Complex& a, const Complex& b)
 {
   return (octave::math::isnan (b) || (xabs (a) < xabs (b))
           || ((xabs (a) == xabs (b)) && (arg (a) < arg (b))));
 }
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2791,17 +2791,16 @@ read_sparse_matrix (std::istream& is, Sp
 
       for (octave_idx_type j = jold; j < nc; j++)
         a.cidx (j+1) = ii;
     }
 
   return is;
 }
 
-
 /*
  * Tests
  *
 
 %!function x = set_slice (x, dim, slice, arg)
 %!  switch (dim)
 %!    case 11
 %!      x(slice) = 2;
@@ -2878,17 +2877,16 @@ read_sparse_matrix (std::istream& is, Sp
 %!test test_sparse_slice ([2 2], 11, 2);
 %!test test_sparse_slice ([2 2], 11, 3);
 %!test test_sparse_slice ([2 2], 11, 4);
 %!test test_sparse_slice ([2 2], 11, [4, 4]);
 # These 2 errors are the same as in the full case
 %!error id=Octave:invalid-resize set_slice (sparse (ones ([2 2])), 11, 5)
 %!error id=Octave:invalid-resize set_slice (sparse (ones ([2 2])), 11, 6)
 
-
 #### 2d indexing
 
 ## size = [2 0]
 %!test test_sparse_slice ([2 0], 21, []);
 %!test test_sparse_slice ([2 0], 21, 1);
 %!test test_sparse_slice ([2 0], 21, 2);
 %!test test_sparse_slice ([2 0], 21, [2,2]);
 %!assert (set_slice (sparse (ones ([2 0])), 21, 3), sparse (3,0))
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -89,17 +89,16 @@ extern "C"
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
-
   F77_RET_T
   F77_FUNC (dgemm, DGEMM) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const double&,
                            const double*, const octave_idx_type&,
                            const double*, const octave_idx_type&,
                            const double&, double*, const octave_idx_type&
@@ -697,17 +696,16 @@ Matrix::tinverse (MatrixType &mattype, o
     }
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
-
 Matrix
 Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1242,17 +1240,16 @@ Matrix::determinant (MatrixType& mattype
   else if (typ == MatrixType::Hermitian)
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-
       char job = 'L';
       F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
@@ -2980,17 +2977,16 @@ Sylvester (const Matrix& a, const Matrix
 
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
-
   // FIXME: check info?
 
   retval = ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
@@ -3286,17 +3282,16 @@ Matrix linspace (const ColumnVector& x1,
       retval(i, j) = x1(i) + j*delta[i];
 
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, n-1) = x2(i);
 
   return retval;
 }
 
-
 MS_CMP_OPS (Matrix, double)
 MS_BOOL_OPS (Matrix, double)
 
 SM_CMP_OPS (double, Matrix)
 SM_BOOL_OPS (double, Matrix)
 
 MM_CMP_OPS (Matrix, Matrix)
 MM_BOOL_OPS (Matrix, Matrix)
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -370,17 +370,16 @@ public:
     return retval;
   }
 
   bool empty_2d (void) const
   {
     return ndims () == 2 && (elem (0) == 0 || elem (1) == 0);
   }
 
-
   bool zero_by_zero (void) const
   {
     return ndims () == 2 && elem (0) == 0 && elem (1) == 0;
   }
 
   bool any_zero (void) const
   {
     bool retval = false;
@@ -559,17 +558,16 @@ public:
     octave_idx_type k = idx[0];
 
     for (int i = 1; i < ndims (); i++)
       k += rep[i-1] * idx[i];
 
     return k;
   }
 
-
   friend bool operator == (const dim_vector& a, const dim_vector& b);
 };
 
 inline bool
 operator == (const dim_vector& a, const dim_vector& b)
 {
   // Fast case.
   if (a.rep == b.rep)
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -137,17 +137,16 @@ FloatComplexColumnVector::fill (const Fl
   if (len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < len; i++)
         xelem (i) = val;
     }
 
-
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val,
                                 octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1561,17 +1561,16 @@ FloatComplexMatrix::determinant (MatrixT
   else if (typ == MatrixType::Hermitian)
     {
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-
       char job = 'L';
       F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
@@ -1782,17 +1781,16 @@ FloatComplexMatrix::rcond (MatrixType &m
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
-
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
@@ -2028,17 +2026,16 @@ FloatComplexMatrix::fsolve (MatrixType &
                             solve_singularity_handler sing_handler,
                             bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -91,17 +91,16 @@ extern "C"
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
-
   F77_RET_T
   F77_FUNC (sgemm, SGEMM) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const float&, const float*,
                            const octave_idx_type&, const float*,
                            const octave_idx_type&, const float&, float*,
                            const octave_idx_type&
@@ -704,17 +703,16 @@ FloatMatrix::tinverse (MatrixType &matty
     }
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
 
   return retval;
 }
 
-
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1253,17 +1251,16 @@ FloatMatrix::determinant (MatrixType& ma
   else if (typ == MatrixType::Hermitian)
     {
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-
       char job = 'L';
       F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
@@ -2998,17 +2995,16 @@ Sylvester (const FloatMatrix& a, const F
 
   F77_XFCN (strsyl, STRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
-
   // FIXME: check info?
 
   retval = ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -398,17 +398,16 @@ extern OCTAVE_API FloatMatrix min (const
 extern OCTAVE_API FloatMatrix max (float d, const FloatMatrix& m);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& m, float d);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& a, const FloatMatrix& b);
 
 extern OCTAVE_API FloatMatrix linspace (const FloatColumnVector& x1,
                                         const FloatColumnVector& x2,
                                         octave_idx_type n);
 
-
 MS_CMP_OP_DECLS (FloatMatrix, float, OCTAVE_API)
 MS_BOOL_OP_DECLS (FloatMatrix, float, OCTAVE_API)
 
 SM_CMP_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -74,17 +74,16 @@ idx_vector::idx_base_rep::as_array (void
 {
   (*current_liboctave_error_handler)
     ("internal error: as_array not allowed for this index class");
 
   // Never actually executed, but required to silence compiler warning
   return Array<octave_idx_type> ();
 }
 
-
 idx_vector::idx_colon_rep::idx_colon_rep (char c)
 {
   if (c != ':')
     {
       (*current_liboctave_error_handler)
         ("internal error: invalid character converted to idx_vector; must be ':'");
       // FIXME: this is unreachable now.
       err = true;
@@ -108,17 +107,16 @@ idx_vector::idx_colon_rep::sort_idx (Arr
 }
 
 std::ostream&
 idx_vector::idx_colon_rep::print (std::ostream& os) const
 {
   return os << ":";
 }
 
-
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
   : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
     err_invalid_range ();
   if (start < 0)
@@ -254,17 +252,16 @@ inline octave_idx_type
 convert_index (octave_int<T> x, bool& conv_error,
                octave_idx_type& ext)
 {
   octave_idx_type i = octave_int<octave_idx_type> (x).value ();
 
   return convert_index (i, conv_error, ext);
 }
 
-
 template <typename T>
 idx_vector::idx_scalar_rep::idx_scalar_rep (T x)
   : data (0)
 {
   octave_idx_type dummy = 0;
 
   data = convert_index (x, err, dummy);
 }
@@ -306,17 +303,16 @@ idx_vector::idx_scalar_rep::unconvert (v
 }
 
 Array<octave_idx_type>
 idx_vector::idx_scalar_rep::as_array (void)
 {
   return Array<octave_idx_type> (dim_vector (1, 1), data);
 }
 
-
 template <typename T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : data (0), len (nda.numel ()), ext (0), aowner (0), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
       std::unique_ptr<octave_idx_type []> d (new octave_idx_type [len]);
 
@@ -628,17 +624,16 @@ idx_vector::idx_vector_rep::as_array (vo
       // Delete the old copy and share the data instead to save memory.
       delete [] data;
       data = retval.fortran_vec ();
       aowner = new Array<octave_idx_type> (retval);
       return retval;
     }
 }
 
-
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), lsti (-1), lste (-1),
     aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
       bool *d = new bool [1];
       d[0] = true;
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -142,17 +142,16 @@ private:
     OCTAVE_NORETURN idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type) const { return true; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
 
-
     // No copying!
     idx_colon_rep (const idx_colon_rep& idx);
     idx_colon_rep& operator = (const idx_colon_rep& idx);
   };
 
   // To distinguish the "direct" constructors that blindly trust the data.
   enum direct { DIRECT };
 
@@ -203,17 +202,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Range unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-
     // No copying!
     idx_range_rep (const idx_range_rep& idx);
     idx_range_rep& operator = (const idx_range_rep& idx);
 
     octave_idx_type start, len, step;
 
   };
 
@@ -259,17 +257,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     double unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-
     // No copying!
     idx_scalar_rep (const idx_scalar_rep& idx);
     idx_scalar_rep& operator = (const idx_scalar_rep& idx);
 
     octave_idx_type data;
 
   };
 
@@ -325,17 +322,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Array<double> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-
     // No copying!
     idx_vector_rep (const idx_vector_rep& idx);
     idx_vector_rep& operator = (const idx_vector_rep& idx);
 
     const octave_idx_type *data;
     octave_idx_type len;
     octave_idx_type ext;
 
@@ -398,17 +394,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Array<bool> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-
     // No copying!
     idx_mask_rep (const idx_mask_rep& idx);
     idx_mask_rep& operator = (const idx_mask_rep& idx);
 
     const bool *data;
     octave_idx_type len;
     octave_idx_type ext;
 
diff --git a/liboctave/cruft/misc/blaswrap.c b/liboctave/cruft/misc/blaswrap.c
--- a/liboctave/cruft/misc/blaswrap.c
+++ b/liboctave/cruft/misc/blaswrap.c
@@ -249,17 +249,16 @@ type name (void *a1, void *a2, void *a3,
   return cplx; \
 }
 
 F2C_BLAS_CALL(complex, cdotu_)
 F2C_BLAS_CALL(doublecomplex, zdotu_)
 F2C_BLAS_CALL(complex, cdotc_)
 F2C_BLAS_CALL(doublecomplex, zdotc_)
 
-
 /*
  * Function pointer arrays, indexed by the enums
  */
 static void (*f2c_blas_func[f2c_BLAS_COUNT]) (void) = { 0 };
 static void (*f2c_lapack_func[f2c_LAPACK_COUNT]) (void) = { 0 };
 
 /*
  * Initialization: This is called before main ().
diff --git a/liboctave/cruft/misc/f77-fcn.h b/liboctave/cruft/misc/f77-fcn.h
--- a/liboctave/cruft/misc/f77-fcn.h
+++ b/liboctave/cruft/misc/f77-fcn.h
@@ -268,17 +268,16 @@ octave_make_cray_const_ftn_ch_dsc (const
 #if defined (HAVE_OCTAVE_NORETURN_ATTR)
 #  define F77_NORETURN(retval)
 #else
 #  define F77_NORETURN(retval) return retval;
 #endif
 
 #endif
 
-
 /* Build a C string local variable CS from the Fortran string parameter S
    declared as F77_CHAR_ARG_DEF(s, len) or F77_CONST_CHAR_ARG_DEF(s, len).
    The string will be cleaned up at the end of the current block.
    Needs to include <cstring> and <vector>.  */
 
 #define F77_CSTRING(s, len, cs) \
  OCTAVE_LOCAL_BUFFER (char, cs, F77_CHAR_ARG_LEN_USE (s, len) + 1); \
  memcpy (cs, F77_CHAR_ARG_USE (s), F77_CHAR_ARG_LEN_USE (s, len)); \
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -118,17 +118,16 @@ ddaspk_psol (const octave_idx_type&, con
 
   abort ();
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-
 static octave_idx_type
 ddaspk_j (const double& time, const double *state, const double *deriv,
           double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME: would be nice to avoid copying the data.
 
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -143,17 +143,16 @@ extern "C"
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&,
                            const double&, const double*,
                            const octave_idx_type&, const double*,
                            const octave_idx_type&, const double&, double*,
                            const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 
-
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&,
                            const Complex&, const Complex*,
                            const octave_idx_type&, const Complex*,
                            const octave_idx_type&, const Complex&, Complex*,
                            const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
@@ -1388,17 +1387,16 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
           // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
-
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
           for (octave_idx_type i = 0; i < n; i++)
             x(i) = *ip2++;
 
@@ -2199,17 +2197,16 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
     (*current_liboctave_error_handler)
       ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
         (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-
 #include "CMatrix.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 #include "fCMatrix.h"
 #include "fMatrix.h"
 #include "hess.h"
 #include "lo-error.h"
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3003,17 +3003,16 @@ namespace octave
 
           if (err)
             return FloatNDArray ();
         }
 
       return retval;
     }
 
-
     Complex rc_log1p (double x)
     {
       const double pi = 3.14159265358979323846;
       return (x < -1.0
               ? Complex (std::log (-(1.0 + x)), pi)
               : Complex (log1p (x)));
     }
 
@@ -3895,17 +3894,16 @@ namespace octave
         }
       return dgam;
     }
 
     // explicit instantiations
     Complex psi (const Complex& z) { return xpsi (z); }
     FloatComplex psi (const FloatComplex& z) { return xpsi (z); }
 
-
     template <typename T>
     static inline void
     fortran_psifn (const T z, const octave_idx_type n, T* ans,
                    octave_idx_type* ierr);
 
     template <>
     inline void
     fortran_psifn<double> (const double z, const octave_idx_type n,
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-
 #include <iostream>
 #include <string>
 #include <vector>
 
 #if defined (HAVE_FFTW3_H)
 #  include <fftw3.h>
 #endif
 
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -215,17 +215,16 @@ public:
   template <typename U>
   void accum (U val)
   {
     if (val != static_cast<U> (0)) ++num;
   }
   operator R () { return num; }
 };
 
-
 // OK, we're armed :) Now let's go for the fun
 
 template <typename T, typename R, typename ACC>
 inline void vector_norm (const Array<T>& v, R& res, ACC acc)
 {
   for (octave_idx_type i = 0; i < v.numel (); i++)
     acc.accum (v(i));
 
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -328,17 +328,16 @@ octave_rand::do_poisson_distribution (vo
 void
 octave_rand::do_gamma_distribution (void)
 {
   switch_to_generator (gamma_dist);
 
   F77_FUNC (setcgn, SETCGN) (gamma_dist);
 }
 
-
 double
 octave_rand::do_scalar (double a)
 {
   double retval = 0.0;
 
   if (use_old_generators)
     {
       switch (current_distribution)
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -158,17 +158,16 @@ public:
 
   // Return an N-dimensional array of numbers from the sequence,
   // filled in column major order.
   static NDArray nd_array (const dim_vector& dims, double a = 1.0)
   {
     return instance_ok () ? instance->do_nd_array (dims, a) : NDArray ();
   }
 
-
   // Return an N-dimensional array of numbers from the sequence,
   // filled in column major order.
   static FloatNDArray float_nd_array (const dim_vector& dims, float a = 1.0)
   {
     return instance_ok () ? instance->do_float_nd_array (dims, a)
                           : FloatNDArray ();
   }
 
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -633,17 +633,16 @@ qr<Matrix>::form (octave_idx_type n, Mat
             for (octave_idx_type i = j + 1; i < m; i++)
               {
                 q.xelem (i, j) = afact.xelem (i, j);
                 afact.xelem (i, j) = 0;
               }
           r = afact;
         }
 
-
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           double rlwork;
           F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &rlwork, -1, info));
 
@@ -993,17 +992,16 @@ qr<FloatMatrix>::form (octave_idx_type n
             for (octave_idx_type i = j + 1; i < m; i++)
               {
                 q.xelem (i, j) = afact.xelem (i, j);
                 afact.xelem (i, j) = 0;
               }
           r = afact;
         }
 
-
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           float rlwork;
           F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &rlwork, -1, info));
 
@@ -1354,17 +1352,16 @@ qr<ComplexMatrix>::form (octave_idx_type
             for (octave_idx_type i = j + 1; i < m; i++)
               {
                 q.xelem (i, j) = afact.xelem (i, j);
                 afact.xelem (i, j) = 0;
               }
           r = afact;
         }
 
-
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           Complex clwork;
           F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &clwork, -1, info));
 
@@ -1719,17 +1716,16 @@ qr<FloatComplexMatrix>::form (octave_idx
             for (octave_idx_type i = j + 1; i < m; i++)
               {
                 q.xelem (i, j) = afact.xelem (i, j);
                 afact.xelem (i, j) = 0;
               }
           r = afact;
         }
 
-
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           FloatComplex clwork;
           F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
                                      &clwork, -1, info));
 
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -106,17 +106,16 @@ qrp<Matrix>::init (const Matrix& a, type
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
-
   form (n, afact, tau, qr_type);
 }
 
 template <>
 qrp<Matrix>::qrp (const Matrix& a, type qr_type)
   : qr<Matrix> (), p ()
 {
   init (a, qr_type);
@@ -171,17 +170,16 @@ qrp<FloatMatrix>::init (const FloatMatri
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
-
   form (n, afact, tau, qr_type);
 }
 
 template <>
 qrp<FloatMatrix>::qrp (const FloatMatrix& a, type qr_type)
   : qr<FloatMatrix> (), p ()
 {
   init (a, qr_type);
@@ -238,17 +236,16 @@ qrp<ComplexMatrix>::init (const ComplexM
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
-
   form (n, afact, tau, qr_type);
 }
 
 template <>
 qrp<ComplexMatrix>::qrp (const ComplexMatrix& a, type qr_type)
   : qr<ComplexMatrix> (), p ()
 {
   init (a, qr_type);
@@ -305,17 +302,16 @@ qrp<FloatComplexMatrix>::init (const Flo
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
-
   form (n, afact, tau, qr_type);
 }
 
 template <>
 qrp<FloatComplexMatrix>::qrp (const FloatComplexMatrix& a, type qr_type)
   : qr<FloatComplexMatrix> (), p ()
 {
   init (a, qr_type);
diff --git a/liboctave/numeric/randmtzig.cc b/liboctave/numeric/randmtzig.cc
--- a/liboctave/numeric/randmtzig.cc
+++ b/liboctave/numeric/randmtzig.cc
@@ -663,17 +663,16 @@ oct_rande (void)
 #define NRANDI randi32() /* 31 bits for mantissa + 1 bit sign */
 #define RANDU randu32()
 
 static ZIGINT fki[ZIGGURAT_TABLE_SIZE];
 static float fwi[ZIGGURAT_TABLE_SIZE], ffi[ZIGGURAT_TABLE_SIZE];
 static ZIGINT fke[ZIGGURAT_TABLE_SIZE];
 static float fwe[ZIGGURAT_TABLE_SIZE], ffe[ZIGGURAT_TABLE_SIZE];
 
-
 static void
 create_ziggurat_float_tables (void)
 {
   int i;
   float x, x1;
 
   /* Ziggurat tables for the normal distribution */
   x1 = ZIGGURAT_NOR_R;
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -103,17 +103,16 @@ flogfak (double k)
       r  = 1.0 / k;
       rr = r * r;
       return ((k + 0.5)*std::log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[static_cast<int> (k)]);
 }
 
-
 /******************************************************************
  *                                                                *
  * Poisson Distribution - Patchwork Rejection/Inversion           *
  *                                                                *
  ******************************************************************
  *                                                                *
  * For parameter my < 10, Tabulated Inversion is applied.         *
  * For my >= 10, Patchwork Rejection is employed:                 *
@@ -287,17 +286,16 @@ pprsc (double my)
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
       if (std::log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
     }
 }
 /* ---- pprsc.c end ------ */
 
-
 /* The remainder of the file is by Paul Kienzle */
 
 /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
 static void
 poisson_cdf_lookup (double lambda, double *p, size_t n)
 {
   /* Table size is predicated on the maximum value of lambda
    * we want to store in the table, and the maximum value of
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -296,31 +296,29 @@ umfpack_numeric<Complex>
    const Complex *Az, void *Symbolic, void **Numeric,
    const double *Control, double *Info)
 {
   return UMFPACK_ZNAME (numeric) (Ap, Ai,
                                   reinterpret_cast<const double *> (Az),
                                   0, Symbolic, Numeric, Control, Info);
 }
 
-
 template <>
 inline octave_idx_type
 umfpack_qsymbolic<Complex>
   (octave_idx_type n_row, octave_idx_type n_col,
    const octave_idx_type *Ap, const octave_idx_type *Ai,
    const Complex *Az, const octave_idx_type *Qinit,
    void **Symbolic, const double *Control, double *Info)
 {
   return UMFPACK_ZNAME (qsymbolic) (n_row, n_col, Ap, Ai,
                                     reinterpret_cast<const double *> (Az),
                                     0, Qinit, Symbolic, Control, Info);
 }
 
-
 template <>
 inline void
 umfpack_report_control<Complex> (const double *Control)
 {
   UMFPACK_ZNAME (report_control) (Control);
 }
 
 template <>
diff --git a/liboctave/numeric/sparse-lu.h b/liboctave/numeric/sparse-lu.h
--- a/liboctave/numeric/sparse-lu.h
+++ b/liboctave/numeric/sparse-lu.h
@@ -17,17 +17,16 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-
 #if ! defined (octave_sparse_lu_h)
 #define octave_sparse_lu_h 1
 
 #include "octave-config.h"
 
 #include "MArray.h"
 #include "dSparse.h"
 
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -1037,17 +1037,16 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->U->n;
   octave_idx_type nz = N->U->nzmax;
 
   SparseComplexMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
 
-
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->U->p[j];
 
   for (octave_idx_type j = 0; j < nz; j++)
     {
       ret.xridx (j) = N->U->i[j];
       ret.xdata (j) = reinterpret_cast<Complex *>(N->U->x)[j];
     }
@@ -1074,17 +1073,16 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix ret (b_nr, b_nc);
   Complex *vec = ret.fortran_vec ();
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
-
   if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
 
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1462,17 +1462,16 @@ along with Octave; see the file COPYING.
             } \
         } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
-
 #define SPARSE_CUMPROD(RET_TYPE, ELT_TYPE, FCN) \
  \
   octave_idx_type nr = rows (); \
   octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
@@ -1657,17 +1656,16 @@ along with Octave; see the file COPYING.
   tmp[j] OP data (i)
 
 #define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT) \
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
                         SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
                         SPARSE_REDUCTION_OP_COL_EXPR (OP), \
                         INIT_VAL, MT_RESULT)
 
-
 // Don't break from this loop if the test succeeds because
 // we are looping over the rows and not the columns in the inner loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     tmp[ridx (i)] = TEST_TRUE_VAL;
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -522,17 +522,16 @@ OP_RED_FCN (mx_inline_dsum, T, PROMOTE_D
 OP_RED_FCN (mx_inline_count, bool, T, OP_RED_SUM, 0)
 OP_RED_FCN (mx_inline_prod, T, T, OP_RED_PROD, 1)
 OP_RED_FCN (mx_inline_dprod, T, PROMOTE_DOUBLE(T), op_dble_prod, 1)
 OP_RED_FCN (mx_inline_sumsq, T, T, OP_RED_SUMSQ, 0)
 OP_RED_FCN (mx_inline_sumsq, std::complex<T>, T, OP_RED_SUMSQC, 0)
 OP_RED_FCN (mx_inline_any, T, bool, OP_RED_ANYC, false)
 OP_RED_FCN (mx_inline_all, T, bool, OP_RED_ALLC, true)
 
-
 #define OP_RED_FCN2(F, TSRC, TRES, OP, ZERO) \
 template <typename T> \
 inline void \
 F (const TSRC* v, TRES *r, octave_idx_type m, octave_idx_type n) \
 { \
   for (octave_idx_type i = 0; i < m; i++) \
     r[i] = ZERO; \
   for (octave_idx_type j = 0; j < n; j++) \
diff --git a/liboctave/system/oct-env.h b/liboctave/system/oct-env.h
--- a/liboctave/system/oct-env.h
+++ b/liboctave/system/oct-env.h
@@ -120,17 +120,16 @@ namespace octave
 
       env (const env&);
 
       env& operator = (const env&);
 
       // The real thing.
       static env *instance;
 
-
       static void cleanup_instance (void) { delete instance; instance = 0; }
 
       // TRUE means follow symbolic links that point to directories just
       // as if they are real directories.
       bool follow_symbolic_links;
 
       // TRUE means that pwd always give verbatim directory, regardless
       // of symbolic link following.
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -587,17 +587,16 @@ namespace octave
     else
       {
         ::octave_rl_set_completer_quote_characters ("");
 
         return octave_rl_get_completer_word_break_characters ();
       }
   }
 
-
   string_vector
   gnu_readline::do_generate_filename_completions (const std::string& text)
   {
     string_vector retval;
 
     int n = 0;
     int count = 0;
 
diff --git a/liboctave/util/f2c-main.c b/liboctave/util/f2c-main.c
--- a/liboctave/util/f2c-main.c
+++ b/liboctave/util/f2c-main.c
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <assert.h>
 
-
 /* Dummy Fortran main declaration, needed in order to link to some
    Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #if defined (F77_DUMMY_MAIN)
 #  if defined (__cplusplus)
 extern "C"
 #  endif
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -210,17 +210,16 @@ void
 err_invalid_index (double n, octave_idx_type nd, octave_idx_type dim,
                    const std::string& var)
 {
   std::ostringstream buf;
   buf << n + 1;
   err_invalid_index (buf.str (), nd, dim, var);
 }
 
-
 // Complain for read access beyond the bounds of an array.
 
 class out_of_range : public index_exception
 {
 public:
 
   out_of_range (const std::string& value, octave_idx_type nd_in,
                 octave_idx_type dim_in)
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -111,17 +111,16 @@ OCTAVE_NORETURN OCTAVE_API extern void
 err_nonconformant (const char *op, octave_idx_type op1_len,
                    octave_idx_type op2_len);
 
 OCTAVE_NORETURN OCTAVE_API extern void
 err_nonconformant (const char *op,
                    octave_idx_type op1_nr, octave_idx_type op1_nc,
                    octave_idx_type op2_nr, octave_idx_type op2_nc);
 
-
 OCTAVE_NORETURN OCTAVE_API extern void
 err_nonconformant (const char *op,
                    const dim_vector& op1_dims, const dim_vector& op2_dims);
 
 OCTAVE_NORETURN OCTAVE_API extern void
 err_index_out_of_range (int nd, int dim, octave_idx_type iext,
                         octave_idx_type ext, const dim_vector& d);
 
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -174,17 +174,16 @@ gripe_invalid_index (double n, octave_id
 
   gripe_invalid_index (buf.str (), nd, dim, var);
 
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 #  pragma GCC diagnostic pop
 #endif
 }
 
-
 // Gripe and exception for read access beyond the bounds of an array.
 
 class out_of_range : public index_exception
 {
 public:
 
   out_of_range (const std::string& value, octave_idx_type nd_in,
                 octave_idx_type dim_in)
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -46,17 +46,16 @@ gripe_nonconformant (const char *op,
                      octave_idx_type op2_len);
 
 OCTAVE_DEPRECATED ("use 'err_nonconformant' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op,
                      octave_idx_type op1_nr, octave_idx_type op1_nc,
                      octave_idx_type op2_nr, octave_idx_type op2_nc);
 
-
 OCTAVE_DEPRECATED ("use 'err_nonconformant' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op, const dim_vector& op1_dims,
                      const dim_vector& op2_dims);
 
 OCTAVE_DEPRECATED ("use 'err_index_out_of_range' instead")
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_index_out_of_range (int nd, int dim,
diff --git a/liboctave/util/lo-ieee.h b/liboctave/util/lo-ieee.h
--- a/liboctave/util/lo-ieee.h
+++ b/liboctave/util/lo-ieee.h
@@ -102,17 +102,16 @@ extern OCTAVE_API int __lo_ieee_float_si
 
 #define lo_ieee_isnan(x) (sizeof (x) == sizeof (float) ? \
                          __lo_ieee_float_isnan (x) : __lo_ieee_isnan (x))
 #define lo_ieee_finite(x) (sizeof (x) == sizeof (float) ? \
                            __lo_ieee_float_finite (x) : __lo_ieee_finite (x))
 #define lo_ieee_isinf(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_isinf (x) : __lo_ieee_isinf (x))
 
-
 #define lo_ieee_is_NA(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_is_NA (x) : __lo_ieee_is_NA (x))
 #define lo_ieee_is_NaN_or_NA(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_is_NaN_or_NA (x) : __lo_ieee_is_NaN_or_NA (x))
 #define lo_ieee_signbit(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_signbit (x) : __lo_ieee_signbit (x))
 
 #if defined (__cplusplus)
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -437,17 +437,16 @@ regexp::is_match (const string_vector& b
 
 // Declare rep_token_t used in processing replacement string
 typedef struct
 {
   size_t pos;
   int num;
 } rep_token_t;
 
-
 std::string
 regexp::replace (const std::string& buffer, const std::string& replacement)
 {
   std::string retval;
 
   regexp::match_data rx_lst = match (buffer);
 
   size_t num_matches = rx_lst.size ();
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -96,17 +96,16 @@ public:
       r[i] = f (x[i], y);
   }
 };
 
 // Static init
 template <typename R, typename X, typename Y, typename F>
 F bsxfun_wrapper<R, X, Y, F>::f;
 
-
 // scalar-Array
 template <typename U, typename T, typename R, typename F>
 Array<U>
 binmap (const T& x, const Array<R>& ya, F fcn)
 {
   octave_idx_type len = ya.numel ();
 
   const R *y = ya.data ();
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -316,17 +316,16 @@ octave_int_cmp_op::emulate_mop (double x
 template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (double x, int64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
 }
 
-
 // Define handlers for int64 multiplication
 
 template <>
 uint64_t
 octave_int_arith_base<uint64_t, false>::mul_internal (uint64_t x, uint64_t y)
 {
   // Get upper words
   uint64_t ux = x >> 32;
@@ -444,17 +443,16 @@ octave_int_arith_base<int64_t, true>::mu
       if (res > static_cast<uint64_t> (-min_val ()))
         {
           return min_val ();
         }
       else
         return -static_cast<int64_t> (res);
     }
 
-
 overflow:
   return positive ? max_val () : min_val ();
 
 }
 
 #define INT_DOUBLE_BINOP_DECL(OP,SUFFIX) \
   template <> \
   OCTAVE_API octave_ ## SUFFIX \
@@ -816,17 +814,16 @@ INSTANTIATE_INTTYPE (int16_t);
 INSTANTIATE_INTTYPE (int32_t);
 INSTANTIATE_INTTYPE (int64_t);
 
 INSTANTIATE_INTTYPE (uint8_t);
 INSTANTIATE_INTTYPE (uint16_t);
 INSTANTIATE_INTTYPE (uint32_t);
 INSTANTIATE_INTTYPE (uint64_t);
 
-
 /*
 
 %!assert (intmax ("int64") / intmin ("int64"), int64 (-1))
 %!assert (intmin ("int64") / int64 (-1), intmax ("int64"))
 %!assert (int64 (2**63), intmax ("int64"))
 %!assert (uint64 (2**64), intmax ("uint64"))
 %!test
 %! a = 1.9*2^61; b = uint64 (a); b++; assert (b > a);
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -1090,17 +1090,16 @@ operator << (std::ostream& os, const oct
 template <>
 inline std::ostream&
 operator << (std::ostream& os, const octave_int<uint8_t>& ival)
 {
   os << static_cast<unsigned int> (ival.value ());
   return os;
 }
 
-
 template <>
 inline std::istream&
 operator >> (std::istream& is, octave_int<int8_t>& ival)
 {
   int tmp = 0;
   is >> tmp;
   ival = static_cast<int8_t> (tmp);
   return is;
@@ -1111,17 +1110,16 @@ inline std::istream&
 operator >> (std::istream& is, octave_int<uint8_t>& ival)
 {
   unsigned int tmp = 0;
   is >> tmp;
   ival = static_cast<uint8_t> (tmp);
   return is;
 }
 
-
 // Bitwise operations
 
 #define OCTAVE_INT_BITCMP_OP(OP) \
   template <typename T> \
   octave_int<T> \
   operator OP (const octave_int<T>& x, const octave_int<T>& y) \
   { return x.value () OP y.value (); }
 
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -1584,32 +1584,30 @@ octave_sort<T>::is_sorted (const T *data
 // FIXME: is there really no way to make this local to the following function?
 struct sortrows_run_t
 {
   sortrows_run_t (octave_idx_type c, octave_idx_type o, octave_idx_type n)
     : col (c), ofs (o), nel (n) { }
   octave_idx_type col, ofs, nel;
 };
 
-
 template <typename T>
 template <typename Comp>
 void
 octave_sort<T>::sort_rows (const T *data, octave_idx_type *idx,
                            octave_idx_type rows, octave_idx_type cols,
                            Comp comp)
 {
   OCTAVE_LOCAL_BUFFER (T, buf, rows);
   for (octave_idx_type i = 0; i < rows; i++)
     idx[i] = i;
 
   if (cols == 0 || rows <= 1)
     return;
 
-
   // This is a breadth-first traversal.
   typedef sortrows_run_t run_t;
   std::stack<run_t> runs;
 
   runs.push (run_t (0, 0, rows));
 
   while (! runs.empty ())
     {
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -227,17 +227,16 @@ private:
 
     MergeState& operator = (const MergeState&);
   };
 
   compare_fcn_type compare;
 
   MergeState *ms;
 
-
   template <typename Comp>
   void binarysort (T *data, octave_idx_type nel,
                    octave_idx_type start, Comp comp);
 
   template <typename Comp>
   void binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
                    octave_idx_type start, Comp comp);
 
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -95,17 +95,16 @@ get_line (FILE *fp)
       buf[idx++] = c;
     }
   if (idx == 0)
     return std::string ("");
   else
     return std::string (&buf[0], idx);
 }
 
-
 static std::string
 get_variable (const char *name, const std::string& defval)
 {
   const char *val = getenv (name);
   if (val && *val)
     return std::string (val);
   else
     return defval;
