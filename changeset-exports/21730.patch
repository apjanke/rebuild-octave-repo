# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463599385 14400
#      Wed May 18 15:23:05 2016 -0400
# Node ID 30c53770f47e7126787ebca8754234493b6985cf
# Parent  815b2f500fab83ac23beef323e663a270d5c3272
use namespace for system time classes

* oct-time.h, oct-time.cc: Put time classes in octave::sys namespace.
Change all uses.
(octave_time, octave_base_tm, octave_localtime, octave_gmtime,
octave_strptime): Now deprecated typedefs for corresponding classes in
octave::sys namespace.

diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1897,17 +1897,17 @@ Use @code{imfinfo} instead.\n\
   // We can't actually get FormatVersion but even Matlab sometimes can't.
   template_info.setfield ("FormatVersion", octave_value (""));
 
   const file_stat fs (filename);
   if (! fs)
     error ("imfinfo: error reading '%s': %s", filename.c_str (),
            fs.error ().c_str ());
 
-  const octave_localtime mtime (fs.mtime ());
+  const octave::sys::localtime mtime (fs.mtime ());
   const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
   template_info.setfield ("Filename",    octave_value (filename));
   template_info.setfield ("FileModDate", octave_value (filetime));
   template_info.setfield ("FileSize",    octave_value (fs.size ()));
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       OCTAVE_QUIT;
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6245,17 +6245,17 @@ between the calls.  This may include tim
 doing nothing at all.\n\
 @seealso{toc, cputime}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     warning ("tic: ignoring extra arguments");
 
   octave_value retval;
-  octave_time now;
+  octave::sys::time now;
   double tmp = now.double_value ();
 
   if (nargout > 0)
     {
       double ip = 0.0;
       double frac = modf (tmp, &ip);
       uint64_t microsecs = static_cast<uint64_t> (CLOCKS_PER_SEC * frac);
       microsecs += CLOCKS_PER_SEC * static_cast<uint64_t> (ip);
@@ -6295,17 +6295,17 @@ DEFUN (toc, args, nargout,
 
       // FIXME: should we also check to see whether the start
       //        time is after the beginning of this Octave session?
     }
 
   if (start_time < 0)
     error ("toc called before timer set");
 
-  octave_time now;
+  octave::sys::time now;
 
   double etime = now.double_value () - start_time;
 
   octave_value retval;
   if (nargout > 0)
     retval = etime;
   else
     octave_stdout << "Elapsed time is " << etime << " seconds.\n";
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we ask for confirmation before recursively removing a
 // directory tree.
 static bool Vconfirm_recursive_rmdir = true;
 
 // The time we last time we changed directories.
-octave_time Vlast_chdir_time = 0.0;
+octave::sys::time Vlast_chdir_time = 0.0;
 
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   std::string xdir = file_ops::tilde_expand (newdir);
 
   int cd_ok = octave_env::chdir (xdir);
 
diff --git a/libinterp/corefcn/dirfns.h b/libinterp/corefcn/dirfns.h
--- a/libinterp/corefcn/dirfns.h
+++ b/libinterp/corefcn/dirfns.h
@@ -27,11 +27,11 @@ along with Octave; see the file COPYING.
 
 #include <ctime>
 
 #include <string>
 
 #include "oct-time.h"
 
 // The time we last time we changed directories.
-extern octave_time Vlast_chdir_time;
+extern octave::sys::time Vlast_chdir_time;
 
 #endif
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -89,17 +89,17 @@ std::string VPS4 = "+ ";
 //   1  ==>  echo commands read from script files
 //   2  ==>  echo commands from functions
 //   4  ==>  echo commands read from command line
 //
 // more than one state can be active at once.
 int Vecho_executing_commands = ECHO_OFF;
 
 // The time we last printed a prompt.
-octave_time Vlast_prompt_time = 0.0;
+octave::sys::time Vlast_prompt_time = 0.0;
 
 // Character to append after successful command-line completion attempts.
 static char Vcompletion_append_char = ' ';
 
 // TRUE means this is an interactive shell (either forced or not)
 bool interactive = false;
 
 // TRUE means the user forced this shell to be interactive (-i).
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -77,17 +77,17 @@ enum echo_state
   ECHO_OFF = 0,
   ECHO_SCRIPTS = 1,
   ECHO_FUNCTIONS = 2,
   ECHO_CMD_LINE = 4
 };
 
 extern int Vecho_executing_commands;
 
-extern octave_time Vlast_prompt_time;
+extern octave::sys::time Vlast_prompt_time;
 
 class
 octave_base_reader
 {
 public:
 
   friend class octave_input_reader;
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -130,27 +130,27 @@ load_path::dir_info::is_package (const s
     }
 }
 
 void
 load_path::dir_info::initialize (void)
 {
   is_relative = ! octave_env::absolute_pathname (dir_name);
 
-  dir_time_last_checked = octave_time (static_cast<time_t> (0));
+  dir_time_last_checked = octave::sys::time (static_cast<time_t> (0));
 
   file_stat fs (dir_name);
 
   if (fs)
     {
       method_file_map.clear ();
       package_dir_map.clear ();
 
       dir_mtime = fs.mtime ();
-      dir_time_last_checked = octave_time ();
+      dir_time_last_checked = octave::sys::time ();
 
       get_file_list (dir_name);
 
       try
         {
           std::string abs_name = octave_env::make_absolute (dir_name);
 
           // FIXME: nothing is ever removed from this cache of
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -389,18 +389,18 @@ private:
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
     bool is_relative;
-    octave_time dir_mtime;
-    octave_time dir_time_last_checked;
+    octave::sys::time dir_mtime;
+    octave::sys::time dir_time_last_checked;
     string_vector all_files;
     string_vector fcn_files;
     fcn_file_map_type private_file_map;
     method_file_map_type method_file_map;
     package_dir_map_type package_dir_map;
 
     bool is_package (const std::string& name) const;
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1173,17 +1173,17 @@ write_header (std::ostream& os, load_sav
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
         char const * versionmagic;
         int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
         char headertext[128];
-        octave_gmtime now;
+        octave::sys::gmtime now;
 
         // ISO 8601 format date
         const char *matlab_format = "MATLAB 5.0 MAT-file, written by Octave "
             OCTAVE_VERSION ", %Y-%m-%d %T UTC";
         std::string comment_string = now.strftime (matlab_format);
 
         size_t len = std::min (comment_string.length (), static_cast<size_t> (124));
         memset (headertext, ' ', 124);
@@ -1207,17 +1207,17 @@ write_header (std::ostream& os, load_sav
 
       break;
 
 #if defined (HAVE_HDF5)
     case LS_HDF5:
 #endif
     case LS_TEXT:
       {
-        octave_localtime now;
+        octave::sys::localtime now;
 
         std::string comment_string = now.strftime (Vsave_header_format_string);
 
         if (! comment_string.empty ())
           {
 #if defined (HAVE_HDF5)
             if (format == LS_HDF5)
               {
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -539,17 +539,17 @@ initialize_history (bool read_history_fi
                                octave_env::getenv ("OCTAVE_HISTCONTROL"));
 
   octave_link::set_history (command_history::list ());
 }
 
 void
 octave_history_write_timestamp (void)
 {
-  octave_localtime now;
+  octave::sys::localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
     if (command_history::add (timestamp))
       octave_link::append_history (timestamp);
 }
 
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -365,17 +365,17 @@ profile_data_accumulator::get_hierarchic
     }
 
   return retval;
 }
 
 double
 profile_data_accumulator::query_time (void) const
 {
-  octave_time now;
+  octave::sys::time now;
 
   // FIXME: is this volatile declaration really needed?
   // See bug #34210 for additional details.
   volatile double dnow = now.double_value ();
 
   return dnow;
 }
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -223,17 +223,17 @@ out_of_date_check (octave_value& functio
       // FIXME: we need to handle subfunctions properly here.
 
       if (! fcn->is_subfunction ())
         {
           std::string ff = fcn->fcn_file_name ();
 
           if (! ff.empty ())
             {
-              octave_time tc = fcn->time_checked ();
+              octave::sys::time tc = fcn->time_checked ();
 
               bool relative = check_relative && fcn->is_relative ();
 
               if (tc <= Vlast_prompt_time
                   || (relative && tc < Vlast_chdir_time))
                 {
                   bool clear_breakpoints = false;
                   std::string nm = fcn->name ();
@@ -321,20 +321,20 @@ out_of_date_check (octave_value& functio
                       function = octave_value ();
 
                       clear_breakpoints = true;
                     }
                   else if (is_same_file)
                     {
                       // Same file.  If it is out of date, then reload it.
 
-                      octave_time ottp = fcn->time_parsed ();
+                      octave::sys::time ottp = fcn->time_parsed ();
                       time_t tp = ottp.unix_time ();
 
-                      fcn->mark_fcn_file_up_to_date (octave_time ());
+                      fcn->mark_fcn_file_up_to_date (octave::sys::time ());
 
                       if (! (Vignore_function_time_stamp == 2
                              || (Vignore_function_time_stamp
                                  && fcn->is_system_fcn_file ())))
                         {
                           file_stat fs (ff);
 
                           if (fs)
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "oct-map.h"
 #include "oct-time.h"
 #include "ov.h"
 #include "ovl.h"
 
 // Date and time functions.
 
 static octave_scalar_map
-mk_tm_map (const octave_base_tm& t)
+mk_tm_map (const octave::sys::base_tm& t)
 {
   octave_scalar_map m;
 
   m.assign ("usec", static_cast<double> (t.usec ()));
   m.assign ("sec", static_cast<double> (t.sec ()));
   m.assign ("min", static_cast<double> (t.min ()));
   m.assign ("hour", static_cast<double> (t.hour ()));
   m.assign ("mday", static_cast<double> (t.mday ()));
@@ -77,20 +77,20 @@ stringfield (const octave_scalar_map& m,
   octave_value v = m.getfield (k);
 
   if (! v.is_empty ())
     retval = v.xstring_value ("%s: invalid TM_STRUCT argument", who);
 
   return retval;
 }
 
-static octave_base_tm
+static octave::sys::base_tm
 extract_tm (const octave_scalar_map& m, const char *who)
 {
-  octave_base_tm tm;
+  octave::sys::base_tm tm;
 
   tm.usec (intfield (m, "usec", who));
   tm.sec (intfield (m, "sec", who));
   tm.min (intfield (m, "min", who));
   tm.hour (intfield (m, "hour", who));
   tm.mday (intfield (m, "mday", who));
   tm.mon (intfield (m, "mon", who));
   tm.year (intfield (m, "year", who));
@@ -112,17 +112,17 @@ The epoch is referenced to 00:00:00 CUT 
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the value\n\
 returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return ovl (octave_time ());
+  return ovl (octave::sys::time ());
 }
 
 /*
 %!assert (time () > 0)
 
 %!error time (1)
 */
 
@@ -156,17 +156,17 @@ gmtime (time ())\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double tmp = args(0).double_value ();
 
-  return ovl (mk_tm_map (octave_gmtime (tmp)));
+  return ovl (mk_tm_map (octave::sys::gmtime (tmp)));
 }
 
 /*
 %!test
 %! ts = gmtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -211,17 +211,17 @@ localtime (time ())\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double tmp = args(0).double_value ();
 
-  return ovl (mk_tm_map (octave_localtime (tmp)));
+  return ovl (mk_tm_map (octave::sys::localtime (tmp)));
 }
 
 /*
 %!test
 %! ts = localtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -255,19 +255,19 @@ mktime (localtime (time ()))\n\
 @seealso{strftime, strptime, localtime, gmtime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_scalar_map map = args(0).xscalar_map_value ("mktime: TM_STRUCT argument must be a structure");
 
-  octave_base_tm tm = extract_tm (map, "mktime");
+  octave::sys::base_tm tm = extract_tm (map, "mktime");
 
-  return ovl (octave_time (tm));
+  return ovl (octave::sys::time (tm));
 }
 
 /*
 %!test
 %! t = time ();
 %! assert (fix (mktime (localtime (t))) == fix (t));
 
 ## These tests fail on systems with mktime functions of limited
@@ -442,17 +442,17 @@ Year (1970-).\n\
 {
   if (args.length () != 2)
     print_usage ();
 
   std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
 
   octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
 
-  octave_base_tm tm = extract_tm (map, "strftime");
+  octave::sys::base_tm tm = extract_tm (map, "strftime");
 
   return ovl (tm.strftime (fmt));
 }
 
 /*
 %!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))))
 %!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))))
 %!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))))
@@ -479,17 +479,17 @@ you're absolutely sure the date string w
 {
   if (args.length () != 2)
     print_usage ();
 
   std::string str = args(0).xstring_value ("strptime: argument STR must be a string");
 
   std::string fmt = args(1).xstring_value ("strptime: FMT must be a string");
 
-  octave_strptime t (str, fmt);
+  octave::sys::strptime t (str, fmt);
 
   return ovl (mk_tm_map (t), t.characters_converted ());
 }
 
 /*
 %!test
 %! fmt = "%Y-%m-%d %H:%M:%S";
 %! s = strftime (fmt, localtime (time ()));
diff --git a/libinterp/octave-value/ov-dld-fcn.cc b/libinterp/octave-value/ov-dld-fcn.cc
--- a/libinterp/octave-value/ov-dld-fcn.cc
+++ b/libinterp/octave-value/ov-dld-fcn.cc
@@ -59,17 +59,17 @@ octave_dld_function::~octave_dld_functio
 }
 
 std::string
 octave_dld_function::fcn_file_name (void) const
 {
   return sh_lib.file_name ();
 }
 
-octave_time
+octave::sys::time
 octave_dld_function::time_parsed (void) const
 {
   return sh_lib.time_loaded ();
 }
 
 // Note: this wrapper around the octave_dld_function constructor is
 //       necessary to work around a MSVC limitation handling in
 //       virtual destructors that prevents unloading a dynamic module
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -51,23 +51,23 @@ public:
   { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
                        const std::string& nm = "",
                        const std::string& ds = "");
 
   ~octave_dld_function (void);
 
-  void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
+  void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
-  octave_time time_parsed (void) const;
+  octave::sys::time time_parsed (void) const;
 
-  octave_time time_checked (void) const { return t_checked; }
+  octave::sys::time time_checked (void) const { return t_checked; }
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
   static octave_dld_function* create (octave_builtin::fcn ff,
@@ -79,17 +79,17 @@ public:
   { return sh_lib; }
 
 private:
 
   octave_shlib sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
-  mutable octave_time t_checked;
+  mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
   // No copying!
 
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -67,25 +67,25 @@ public:
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
-  virtual void mark_fcn_file_up_to_date (const octave_time&) { }
+  virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
   virtual symbol_table::scope_id scope (void) { return -1; }
 
-  virtual octave_time time_parsed (void) const
-  { return octave_time (static_cast<time_t> (0)); }
+  virtual octave::sys::time time_parsed (void) const
+  { return octave::sys::time (static_cast<time_t> (0)); }
 
-  virtual octave_time time_checked (void) const
-  { return octave_time (static_cast<time_t> (0)); }
+  virtual octave::sys::time time_checked (void) const
+  { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
 
   virtual bool is_class_constructor (const std::string& = "") const
   { return false; }
 
   virtual bool
   is_classdef_constructor (const std::string& = "") const
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -65,17 +65,17 @@ octave_mex_function::~octave_mex_functio
 }
 
 std::string
 octave_mex_function::fcn_file_name (void) const
 {
   return sh_lib.file_name ();
 }
 
-octave_time
+octave::sys::time
 octave_mex_function::time_parsed (void) const
 {
   return sh_lib.time_loaded ();
 }
 
 octave_value_list
 octave_mex_function::subsref (const std::string& type,
                               const std::list<octave_value_list>& idx,
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -64,23 +64,23 @@ public:
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
   const octave_function *function_value (bool = false) const { return this; }
 
-  void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
+  void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
-  octave_time time_parsed (void) const;
+  octave::sys::time time_parsed (void) const;
 
-  octave_time time_checked (void) const { return t_checked; }
+  octave::sys::time time_checked (void) const { return t_checked; }
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_mex_function (void) const { return true; }
 
   octave_value_list
@@ -98,17 +98,17 @@ private:
   void (*exit_fcn_ptr) (void);
 
   bool have_fmex;
 
   octave_shlib sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
-  mutable octave_time t_checked;
+  mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
   // No copying!
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -106,29 +106,29 @@ public:
 
   // Scripts and user functions are both considered "scripts" because
   // they are written in Octave's scripting language.
 
   bool is_user_script (void) const { return true; }
 
   void stash_fcn_file_name (const std::string& nm) { file_name = nm; }
 
-  void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
+  void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
-  void stash_fcn_file_time (const octave_time& t)
+  void stash_fcn_file_time (const octave::sys::time& t)
   {
     t_parsed = t;
     mark_fcn_file_up_to_date (t);
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
-  octave_time time_parsed (void) const { return t_parsed; }
+  octave::sys::time time_parsed (void) const { return t_parsed; }
 
-  octave_time time_checked (void) const { return t_checked; }
+  octave::sys::time time_checked (void) const { return t_checked; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
 
@@ -147,21 +147,21 @@ private:
 
   // The list of commands that make up the body of this function.
   tree_statement_list *cmd_list;
 
   // The name of the file we parsed.
   std::string file_name;
 
   // The time the file was parsed.
-  octave_time t_parsed;
+  octave::sys::time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
-  octave_time t_checked;
+  octave::sys::time t_checked;
 
   // Used to keep track of recursion depth.
   int call_depth;
 
   // No copying!
 
   octave_user_script (const octave_user_script& f);
 
@@ -226,37 +226,37 @@ public:
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
   void stash_parent_fcn_scope (symbol_table::scope_id ps) { parent_scope = ps; }
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
-  void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
+  void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
-  void stash_fcn_file_time (const octave_time& t)
+  void stash_fcn_file_time (const octave::sys::time& t)
   {
     t_parsed = t;
     mark_fcn_file_up_to_date (t);
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
   symbol_table::scope_id parent_fcn_scope (void) const { return parent_scope; }
 
   symbol_table::scope_id scope (void) { return local_scope; }
 
-  octave_time time_parsed (void) const { return t_parsed; }
+  octave::sys::time time_parsed (void) const { return t_parsed; }
 
-  octave_time time_checked (void) const { return t_checked; }
+  octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_user_function (void) const { return true; }
 
   void erase_subfunctions (void)
@@ -452,21 +452,21 @@ private:
   // The name of the parent function, if any.
   std::string parent_name;
 
   // The list of subfunctions (if any) in the order they appear in the
   // file.
   std::list<std::string> subfcn_names;
 
   // The time the file was parsed.
-  octave_time t_parsed;
+  octave::sys::time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
-  octave_time t_checked;
+  octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
   // Used to keep track of recursion depth.
   int call_depth;
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -510,17 +510,17 @@ octave_value::octave_value (long long in
 
 #if defined (OCTAVE_HAVE_UNSIGNED_LONG_LONG_INT)
 octave_value::octave_value (unsigned long long int i)
   : rep (new octave_scalar (i))
 {
 }
 #endif
 
-octave_value::octave_value (octave_time t)
+octave_value::octave_value (octave::sys::time t)
   : rep (new octave_scalar (t.double_value ()))
 {
 }
 
 octave_value::octave_value (double d)
   : rep (new octave_scalar (d))
 {
 }
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -186,17 +186,17 @@ public:
 
 #if defined (OCTAVE_HAVE_LONG_LONG_INT)
   octave_value (long long int i);
 #endif
 #if defined (OCTAVE_HAVE_UNSIGNED_LONG_LONG_INT)
   octave_value (unsigned long long int i);
 #endif
 
-  octave_value (octave_time t);
+  octave_value (octave::sys::time t);
   octave_value (double d);
   octave_value (float d);
   octave_value (const Array<octave_value>& a, bool is_cs_list = false);
   octave_value (const Cell& c, bool is_cs_list = false);
   octave_value (const Matrix& m, const MatrixType& t = MatrixType ());
   octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const NDArray& nda);
   octave_value (const FloatNDArray& nda);
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3089,17 +3089,17 @@ octave_base_parser::make_script (tree_st
 
   octave_user_script *script
     = new octave_user_script (lexer.fcn_file_full_name,
                               lexer.fcn_file_name,
                               cmds, lexer.help_text);
 
   lexer.help_text = "";
 
-  octave_time now;
+  octave::sys::time now;
 
   script->stash_fcn_file_time (now);
 
   primary_fcn_ptr = script;
 }
 
 // Begin defining a function.
 
@@ -3171,17 +3171,17 @@ octave_base_parser::frob_function (const
            id_name.c_str (), lexer.fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
   if (lexer.reading_fcn_file || lexer.reading_classdef_file || autoloading)
     {
-      octave_time now;
+      octave::sys::time now;
 
       fcn->stash_fcn_file_name (lexer.fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -567,17 +567,17 @@ octave_rand::do_float_nd_array (const di
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.  The
 // technique used below will cycle monthly, but it it does seem to
 // work ok to give fairly different seeds each time Octave starts.
 
 void
 octave_rand::initialize_ranlib_generators (void)
 {
-  octave_localtime tm;
+  octave::sys::localtime tm;
   int stored_distribution = current_distribution;
   F77_FUNC (setcgn, SETCGN) (uniform_dist);
 
   int hour = tm.hour () + 1;
   int minute = tm.min () + 1;
   int second = tm.sec () + 1;
 
   int32_t s0 = tm.mday () * hour * minute * second;
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -161,17 +161,17 @@ base_file_stat::mode_as_string (void) co
 
   return std::string (buf);
 }
 
 // Has FILE been modified since TIME?  Returns 1 for yes, 0 for no,
 // and -1 for any error.
 
 int
-base_file_stat::is_newer (const std::string& file, const octave_time& time)
+base_file_stat::is_newer (const std::string& file, const octave::sys::time& time)
 {
   file_stat fs (file);
 
   return fs ? fs.is_newer (time) : -1;
 }
 
 // Private stuff:
 
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -74,19 +74,19 @@ public:
       }
 
     return *this;
   }
 
   // The minimum difference in file time stamp values.
   // FIXME: This value should come from the filesystem itself.
   //        How can we get that info?
-  octave_time time_resolution (void) const
+  octave::sys::time time_resolution (void) const
   {
-    static octave_time resolution (1.0);
+    static octave::sys::time resolution (1.0);
     return resolution;
   }
 
   // File status and info.  The is_XXX functions will return false for
   // file_stat objects that are not properly initialized.  The others
   // should all return 0 (or the equivalent, for the given object)
   // which is likely not meaningful.
 
@@ -111,19 +111,19 @@ public:
 
   nlink_t nlink (void) const { return fs_nlink; }
 
   uid_t uid (void) const { return fs_uid; }
   gid_t gid (void) const { return fs_gid; }
 
   off_t size (void) const { return fs_size; }
 
-  octave_time atime (void) const { return fs_atime; }
-  octave_time mtime (void) const { return fs_mtime; }
-  octave_time ctime (void) const { return fs_ctime; }
+  octave::sys::time atime (void) const { return fs_atime; }
+  octave::sys::time mtime (void) const { return fs_mtime; }
+  octave::sys::time ctime (void) const { return fs_ctime; }
 
   dev_t rdev (void) const { return fs_rdev; }
 
   long blksize (void) const { return fs_blksize; }
   long blocks (void) const { return fs_blocks; }
 
   mode_t mode (void) const { return fs_mode; }
 
@@ -133,21 +133,21 @@ public:
 
   operator bool () const { return ok (); }
 
   bool exists (void) const { return ok (); }
 
   std::string error (void) const { return ok () ? "" : errmsg; }
 
   // Has the file referenced by this object been modified since TIME?
-  bool is_newer (const octave_time& time) const { return fs_mtime > time; }
+  bool is_newer (const octave::sys::time& time) const { return fs_mtime > time; }
 
   // It's nice to be able to hide the file_stat object if we don't
   // really care about it.
-  static int is_newer (const std::string&, const octave_time&);
+  static int is_newer (const std::string&, const octave::sys::time&);
 
 protected:
 
   virtual ~base_file_stat (void) { }
 
   // TRUE means we have already called stat.
   bool initialized;
 
@@ -174,23 +174,23 @@ protected:
 
   // group ID of owner
   gid_t fs_gid;
 
   // size in bytes, for regular files
   off_t fs_size;
 
   // time of last access
-  octave_time fs_atime;
+  octave::sys::time fs_atime;
 
   // time of last modification
-  octave_time fs_mtime;
+  octave::sys::time fs_mtime;
 
   // time of last file status change
-  octave_time fs_ctime;
+  octave::sys::time fs_ctime;
 
   // device number for special files
   dev_t fs_rdev;
 
   // best I/O block size
   long fs_blksize;
 
   // number of 512-byte blocks allocated
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -35,277 +35,285 @@ along with Octave; see the file COPYING.
 #include "strftime.h"
 
 #include "lo-error.h"
 #include "lo-math.h"
 #include "lo-utils.h"
 #include "oct-locbuf.h"
 #include "oct-time.h"
 
-octave_time::octave_time (double d)
-  : ot_unix_time (static_cast<time_t> (d)), ot_usec (0)
-{
-  double ip;
-  ot_usec = static_cast<int> (std::modf (d, &ip) * 1e6);
-}
-
-octave_time::octave_time (const octave_base_tm& tm)
-  : ot_unix_time (), ot_usec ()
+namespace
+octave
 {
-  struct tm t;
+  namespace
+  sys
+  {
+    time::time (double d)
+      : ot_unix_time (static_cast<time_t> (d)), ot_usec (0)
+    {
+      double ip;
+      ot_usec = static_cast<int> (std::modf (d, &ip) * 1e6);
+    }
 
-  t.tm_sec = tm.sec ();
-  t.tm_min = tm.min ();
-  t.tm_hour = tm.hour ();
-  t.tm_mday = tm.mday ();
-  t.tm_mon = tm.mon ();
-  t.tm_year = tm.year ();
-  t.tm_wday = tm.wday ();
-  t.tm_yday = tm.yday ();
-  t.tm_isdst = tm.isdst ();
+    time::time (const base_tm& tm)
+      : ot_unix_time (), ot_usec ()
+    {
+      struct ::tm t;
+
+      t.tm_sec = tm.sec ();
+      t.tm_min = tm.min ();
+      t.tm_hour = tm.hour ();
+      t.tm_mday = tm.mday ();
+      t.tm_mon = tm.mon ();
+      t.tm_year = tm.year ();
+      t.tm_wday = tm.wday ();
+      t.tm_yday = tm.yday ();
+      t.tm_isdst = tm.isdst ();
 
 #if defined (HAVE_TM_GMTOFF)
-  t.tm_gmtoff = tm.gmtoff ();
+      t.tm_gmtoff = tm.gmtoff ();
 #endif
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
-  std::string s = tm.zone ();
-  char *ps = strsave (s.c_str ());
-  t.tm_zone = ps;
+      std::string s = tm.zone ();
+      char *ps = strsave (s.c_str ());
+      t.tm_zone = ps;
 #endif
 
-  ot_unix_time = gnulib::mktime (&t);
+      ot_unix_time = gnulib::mktime (&t);
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
-  delete [] ps;
+      delete [] ps;
 #endif
 
-  ot_usec = tm.usec ();
-}
+      ot_usec = tm.usec ();
+    }
 
-std::string
-octave_time::ctime (void) const
-{
-  return octave_localtime (*this) . asctime ();
-}
+    std::string
+    time::ctime (void) const
+    {
+      return localtime (*this) . asctime ();
+    }
 
-void
-octave_time::stamp (void)
-{
-  struct timeval tp;
+    void
+    time::stamp (void)
+    {
+      struct ::timeval tp;
 
-  gnulib::gettimeofday (&tp, 0);
+      gnulib::gettimeofday (&tp, 0);
 
-  ot_unix_time = tp.tv_sec;
-  ot_usec = tp.tv_usec;
-}
+      ot_unix_time = tp.tv_sec;
+      ot_usec = tp.tv_usec;
+    }
 
-// From the mktime() manual page:
-//
-//     The mktime() function converts a broken-down time structure,
-//     expressed as local time, to calendar time representation.
-//
-//     <snip>
-//
-//     If structure members are outside their legal interval, they
-//     will be normalized (so that, e.g., 40 October is changed into
-//     9 November).
-//
-// So, we no longer check limits here.
+    // From the mktime() manual page:
+    //
+    //     The mktime() function converts a broken-down time structure,
+    //     expressed as local time, to calendar time representation.
+    //
+    //     <snip>
+    //
+    //     If structure members are outside their legal interval, they
+    //     will be normalized (so that, e.g., 40 October is changed into
+    //     9 November).
+    //
+    // So, we no longer check limits here.
 
-#define DEFINE_SET_FIELD_FCN(type, f, lo, hi) \
-  octave_base_tm& \
-  octave_base_tm::f (type v) \
-  { \
-    tm_ ## f = v; \
- \
-    return *this; \
-  }
+#define DEFINE_SET_FIELD_FCN(type, f, lo, hi)   \
+    base_tm&                             \
+    base_tm::f (type v)                  \
+    {                                           \
+      m_ ## f = v;                             \
+                                                \
+      return *this;                             \
+    }
 
-#define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
-  DEFINE_SET_FIELD_FCN (int, f, lo, hi)
+#define DEFINE_SET_INT_FIELD_FCN(f, lo, hi)     \
+    DEFINE_SET_FIELD_FCN (int, f, lo, hi)
 
-DEFINE_SET_INT_FIELD_FCN (usec, 0, 1000000)
-DEFINE_SET_INT_FIELD_FCN (sec, 0, 61)
-DEFINE_SET_INT_FIELD_FCN (min, 0, 59)
-DEFINE_SET_INT_FIELD_FCN (hour, 0, 23)
-DEFINE_SET_INT_FIELD_FCN (mday, 1, 31)
-DEFINE_SET_INT_FIELD_FCN (mon, 0, 11)
-DEFINE_SET_INT_FIELD_FCN (year, std::numeric_limits<int>::min (),
-                          std::numeric_limitd<int>::max ())
-DEFINE_SET_INT_FIELD_FCN (wday, 0, 6)
-DEFINE_SET_INT_FIELD_FCN (yday, 0, 365)
-DEFINE_SET_INT_FIELD_FCN (isdst, 0, 1)
-DEFINE_SET_FIELD_FCN (long, gmtoff, -86400, 0)
+    DEFINE_SET_INT_FIELD_FCN (usec, 0, 1000000)
+    DEFINE_SET_INT_FIELD_FCN (sec, 0, 61)
+    DEFINE_SET_INT_FIELD_FCN (min, 0, 59)
+    DEFINE_SET_INT_FIELD_FCN (hour, 0, 23)
+    DEFINE_SET_INT_FIELD_FCN (mday, 1, 31)
+    DEFINE_SET_INT_FIELD_FCN (mon, 0, 11)
+    DEFINE_SET_INT_FIELD_FCN (year, std::numeric_limits<int>::min (),
+                              std::numeric_limitd<int>::max ())
+    DEFINE_SET_INT_FIELD_FCN (wday, 0, 6)
+    DEFINE_SET_INT_FIELD_FCN (yday, 0, 365)
+    DEFINE_SET_INT_FIELD_FCN (isdst, 0, 1)
+    DEFINE_SET_FIELD_FCN (long, gmtoff, -86400, 0)
 
-octave_base_tm&
-octave_base_tm::zone (const std::string& s)
-{
-  tm_zone = s;
-  return *this;
-}
+    base_tm&
+    base_tm::zone (const std::string& s)
+    {
+      m_zone = s;
+      return *this;
+    }
 
 #if ! defined STRFTIME_BUF_INITIAL_SIZE
 #  define STRFTIME_BUF_INITIAL_SIZE 128
 #endif
 
-std::string
-octave_base_tm::strftime (const std::string& fmt) const
-{
-  std::string retval;
+    std::string
+    base_tm::strftime (const std::string& fmt) const
+    {
+      std::string retval;
 
-  if (! fmt.empty ())
-    {
-      struct tm t;
+      if (! fmt.empty ())
+        {
+          struct ::tm t;
 
-      t.tm_sec = tm_sec;
-      t.tm_min = tm_min;
-      t.tm_hour = tm_hour;
-      t.tm_mday = tm_mday;
-      t.tm_mon = tm_mon;
-      t.tm_year = tm_year;
-      t.tm_wday = tm_wday;
-      t.tm_yday = tm_yday;
-      t.tm_isdst = tm_isdst;
+          t.tm_sec = m_sec;
+          t.tm_min = m_min;
+          t.tm_hour = m_hour;
+          t.tm_mday = m_mday;
+          t.tm_mon = m_mon;
+          t.tm_year = m_year;
+          t.tm_wday = m_wday;
+          t.tm_yday = m_yday;
+          t.tm_isdst = m_isdst;
 
 #if defined (HAVE_TM_GMTOFF)
-      t.tm_gmtoff = tm_gmtoff;
+          t.tm_gmtoff = m_gmtoff;
 #endif
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
-      char *ps = strsave (tm_zone.c_str ());
+          char *ps = strsave (m_zone.c_str ());
+          t.tm_zone = ps;
+#endif
+
+          const char *fmt_str = fmt.c_str ();
+
+          char *buf = 0;
+          size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
+          size_t chars_written = 0;
+
+          while (chars_written == 0)
+            {
+              delete [] buf;
+              buf = new char [bufsize];
+              buf[0] = '\0';
+
+              chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
+
+              bufsize *= 2;
+            }
+
+#if defined (HAVE_STRUCT_TM_TM_ZONE)
+          delete [] ps;
+#endif
+
+          retval = buf;
+
+          delete [] buf;
+        }
+
+      return retval;
+    }
+
+    void
+    base_tm::init (void *p)
+    {
+      if (! p)
+        return;
+
+      struct ::tm *t = static_cast<struct ::tm*> (p);
+
+      m_sec = t->tm_sec;
+      m_min = t->tm_min;
+      m_hour = t->tm_hour;
+      m_mday = t->tm_mday;
+      m_mon = t->tm_mon;
+      m_year = t->tm_year;
+      m_wday = t->tm_wday;
+      m_yday = t->tm_yday;
+      m_isdst = t->tm_isdst;
+
+#if defined (HAVE_TM_GMTOFF)
+      m_gmtoff = t->tm_gmtoff;
+#endif
+
+#if defined (HAVE_STRUCT_TM_TM_ZONE)
+      if (t->tm_zone)
+        m_zone = t->tm_zone;
+#elif defined (HAVE_TZNAME)
+      if (t->tm_isdst == 0 || t->tm_isdst == 1)
+        m_zone = tzname[t->tm_isdst];
+#endif
+    }
+
+    void
+    localtime::init (const time& ot)
+    {
+      m_usec = ot.usec ();
+
+      time_t t = ot.unix_time ();
+
+      base_tm::init (gnulib::localtime (&t));
+    }
+
+    void
+    gmtime::init (const time& ot)
+    {
+      m_usec = ot.usec ();
+
+      time_t t = ot.unix_time ();
+
+      base_tm::init (gnulib::gmtime (&t));
+    }
+
+    void
+    strptime::init (const std::string& str, const std::string& fmt)
+    {
+      struct ::tm t;
+
+      t.tm_sec = 0;
+      t.tm_min = 0;
+      t.tm_hour = 0;
+      t.tm_mday = 0;
+      t.tm_mon = -1;
+      t.tm_year = std::numeric_limits<int>::min ();
+      t.tm_wday = 0;
+      t.tm_yday = 0;
+      t.tm_isdst = 0;
+
+#if defined (HAVE_TM_GMTOFF)
+      t.tm_gmtoff = 0;
+#endif
+
+#if defined (HAVE_STRUCT_TM_TM_ZONE)
+      char *ps = strsave ("");
       t.tm_zone = ps;
 #endif
 
-      const char *fmt_str = fmt.c_str ();
+      const char *p = str.c_str ();
+
+      char *q = gnulib::strptime (p, fmt.c_str (), &t);
 
-      char *buf = 0;
-      size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
-      size_t chars_written = 0;
-
-      while (chars_written == 0)
+      // Fill in wday and yday, but only if mday is valid and the mon and year
+      // are filled in, avoiding issues with mktime and invalid dates.
+      if (t.tm_mday != 0 && t.tm_mon >= 0
+          && t.tm_year != std::numeric_limits<int>::min ())
         {
-          delete [] buf;
-          buf = new char [bufsize];
-          buf[0] = '\0';
+          t.tm_isdst = -1;
+          gnulib::mktime (&t);
+        }
+
+      if (t.tm_mon < 0)
+        t.tm_mon = 0;
 
-          chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
+      if (t.tm_year == std::numeric_limits<int>::min ())
+        t.tm_year = 0;
 
-          bufsize *= 2;
-        }
+      if (q)
+        nchars = q - p + 1;
+      else
+        nchars = 0;
+
+      base_tm::init (&t);
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
       delete [] ps;
 #endif
-
-      retval = buf;
-
-      delete [] buf;
     }
-
-  return retval;
-}
-
-void
-octave_base_tm::init (void *p)
-{
-  if (! p)
-    return;
-
-  struct tm *t = static_cast<struct tm*> (p);
-
-  tm_sec = t->tm_sec;
-  tm_min = t->tm_min;
-  tm_hour = t->tm_hour;
-  tm_mday = t->tm_mday;
-  tm_mon = t->tm_mon;
-  tm_year = t->tm_year;
-  tm_wday = t->tm_wday;
-  tm_yday = t->tm_yday;
-  tm_isdst = t->tm_isdst;
-
-#if defined (HAVE_TM_GMTOFF)
-  tm_gmtoff = t->tm_gmtoff;
-#endif
-
-#if defined (HAVE_STRUCT_TM_TM_ZONE)
-  if (t->tm_zone)
-    tm_zone = t->tm_zone;
-#elif defined (HAVE_TZNAME)
-  if (t->tm_isdst == 0 || t->tm_isdst == 1)
-    tm_zone = tzname[t->tm_isdst];
-#endif
-}
-
-void
-octave_localtime::init (const octave_time& ot)
-{
-  tm_usec = ot.usec ();
-
-  time_t t = ot.unix_time ();
-
-  octave_base_tm::init (gnulib::localtime (&t));
+  }
 }
-
-void
-octave_gmtime::init (const octave_time& ot)
-{
-  tm_usec = ot.usec ();
-
-  time_t t = ot.unix_time ();
-
-  octave_base_tm::init (gnulib::gmtime (&t));
-}
-
-void
-octave_strptime::init (const std::string& str, const std::string& fmt)
-{
-  struct tm t;
-
-  t.tm_sec = 0;
-  t.tm_min = 0;
-  t.tm_hour = 0;
-  t.tm_mday = 0;
-  t.tm_mon = -1;
-  t.tm_year = std::numeric_limits<int>::min ();
-  t.tm_wday = 0;
-  t.tm_yday = 0;
-  t.tm_isdst = 0;
-
-#if defined (HAVE_TM_GMTOFF)
-  t.tm_gmtoff = 0;
-#endif
-
-#if defined (HAVE_STRUCT_TM_TM_ZONE)
-  char *ps = strsave ("");
-  t.tm_zone = ps;
-#endif
-
-  const char *p = str.c_str ();
-
-  char *q = gnulib::strptime (p, fmt.c_str (), &t);
-
-  // Fill in wday and yday, but only if mday is valid and the mon and year
-  // are filled in, avoiding issues with mktime and invalid dates.
-  if (t.tm_mday != 0 && t.tm_mon >= 0
-      && t.tm_year != std::numeric_limits<int>::min ())
-    {
-      t.tm_isdst = -1;
-      gnulib::mktime (&t);
-    }
-
-  if (t.tm_mon < 0)
-    t.tm_mon = 0;
-
-  if (t.tm_year == std::numeric_limits<int>::min ())
-    t.tm_year = 0;
-
-  if (q)
-    nchars = q - p + 1;
-  else
-    nchars = 0;
-
-  octave_base_tm::init (&t);
-
-#if defined (HAVE_STRUCT_TM_TM_ZONE)
-  delete [] ps;
-#endif
-}
diff --git a/liboctave/system/oct-time.h b/liboctave/system/oct-time.h
--- a/liboctave/system/oct-time.h
+++ b/liboctave/system/oct-time.h
@@ -23,341 +23,368 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_oct_time_h)
 #define octave_oct_time_h 1
 
 #include "octave-config.h"
 
 #include <ctime>
 #include <string>
 
-class octave_base_tm;
-
-class
-OCTAVE_API
-octave_time
+namespace
+octave
 {
-public:
+  namespace
+  sys
+  {
+    class base_tm;
+
+    class
+    OCTAVE_API
+    time
+    {
+    public:
+
+      time (void)
+        : ot_unix_time (0), ot_usec (0) { stamp (); }
+
+      time (time_t t)
+        : ot_unix_time (t), ot_usec (0) { }
 
-  octave_time (void)
-    : ot_unix_time (0), ot_usec (0) { stamp (); }
+      time (time_t t, int us)
+        : ot_unix_time (t), ot_usec ()
+        {
+          int rem, extra;
 
-  octave_time (time_t t)
-    : ot_unix_time (t), ot_usec (0) { }
+          if (us >= 0)
+            {
+              rem = us % 1000000;
+              extra = (us - rem) / 1000000;
+            }
+          else
+            {
+              us = -us;
+              rem = us % 1000000;
+              extra = - (1 + (us - rem) / 1000000);
+              rem = 1000000 - us % 1000000;
+            }
 
-  octave_time (time_t t, int us)
-    : ot_unix_time (t), ot_usec ()
-  {
-    int rem, extra;
+          ot_usec = rem;
+          ot_unix_time += extra;
+        }
+
+      time (double d);
+
+      time (const base_tm& tm);
+
+      time (const time& ot)
+        : ot_unix_time (ot.ot_unix_time), ot_usec (ot.ot_usec) { }
+
+      time& operator = (const time& ot)
+        {
+          if (this != &ot)
+            {
+              ot_unix_time = ot.ot_unix_time;
+              ot_usec = ot.ot_usec;
+            }
 
-    if (us >= 0)
-      {
-        rem = us % 1000000;
-        extra = (us - rem) / 1000000;
-      }
-    else
-      {
-        us = -us;
-        rem = us % 1000000;
-        extra = - (1 + (us - rem) / 1000000);
-        rem = 1000000 - us % 1000000;
-      }
+          return *this;
+        }
+
+      ~time (void) { }
+
+      void stamp (void);
+
+      double double_value (void) const { return ot_unix_time + ot_usec / 1e6; }
+
+      time_t unix_time (void) const { return ot_unix_time; }
+
+      int usec (void) const { return ot_usec; }
+
+      std::string ctime (void) const;
+
+    private:
+
+      // Seconds since the epoch.
+      time_t ot_unix_time;
 
-    ot_usec = rem;
-    ot_unix_time += extra;
-  }
+      // Additional microseconds.
+      int ot_usec;
+    };
+
+    inline bool
+    operator == (const time& t1, const time& t2)
+    {
+      return (t1.unix_time () == t2.unix_time () && t1.usec () == t2.usec ());
+    }
+
+    inline bool
+    operator != (const time& t1, const time& t2)
+    {
+      return ! (t1 == t2);
+    }
 
-  octave_time (double d);
+    inline bool
+    operator < (const time& t1, const time& t2)
+    {
+      if (t1.unix_time () < t2.unix_time ())
+        return true;
+      else if (t1.unix_time () > t2.unix_time ())
+        return false;
+      else if (t1.usec () < t2.usec ())
+        return true;
+      else
+        return false;
+    }
 
-  octave_time (const octave_base_tm& tm);
-
-  octave_time (const octave_time& ot)
-    : ot_unix_time (ot.ot_unix_time), ot_usec (ot.ot_usec) { }
+    inline bool
+    operator <= (const time& t1, const time& t2)
+    {
+      return (t1 < t2 || t1 == t2);
+    }
 
-  octave_time& operator = (const octave_time& ot)
-  {
-    if (this != &ot)
-      {
-        ot_unix_time = ot.ot_unix_time;
-        ot_usec = ot.ot_usec;
-      }
+    inline bool
+    operator > (const time& t1, const time& t2)
+    {
+      if (t1.unix_time () > t2.unix_time ())
+        return true;
+      else if (t1.unix_time () < t2.unix_time ())
+        return false;
+      else if (t1.usec () > t2.usec ())
+        return true;
+      else
+        return false;
+    }
+
+    inline bool
+    operator >= (const time& t1, const time& t2)
+    {
+      return (t1 > t2 || t1 == t2);
+    }
 
-    return *this;
-  }
+    inline time
+    operator + (const time& t1, const time& t2)
+    {
+      return time (t1.unix_time () + t2.unix_time (),
+                          t1.usec () + t2.usec ());
+    }
 
-  ~octave_time (void) { }
+    class
+    OCTAVE_API
+    base_tm
+    {
+    public:
 
-  void stamp (void);
-
-  double double_value (void) const { return ot_unix_time + ot_usec / 1e6; }
+      base_tm (void)
+        : m_usec (0), m_sec (0), m_min (0), m_hour (0),
+          m_mday (0), m_mon (0), m_year (0), m_wday (0),
+          m_yday (0), m_isdst (0), m_gmtoff (0), m_zone ("unknown")
+        { }
 
-  time_t unix_time (void) const { return ot_unix_time; }
-
-  int usec (void) const { return ot_usec; }
+      base_tm (const base_tm& tm)
+        : m_usec (tm.m_usec), m_sec (tm.m_sec), m_min (tm.m_min),
+          m_hour (tm.m_hour), m_mday (tm.m_mday), m_mon (tm.m_mon),
+          m_year (tm.m_year), m_wday (tm.m_wday), m_yday (tm.m_yday),
+          m_isdst (tm.m_isdst), m_gmtoff (tm.m_gmtoff), m_zone (tm.m_zone)
+        { }
 
-  std::string ctime (void) const;
-
-private:
+      base_tm& operator = (const base_tm& tm)
+        {
+          if (this != &tm)
+            {
+              m_usec = tm.m_usec;
+              m_sec = tm.m_sec;
+              m_min = tm.m_min;
+              m_hour = tm.m_hour;
+              m_mday = tm.m_mday;
+              m_mon = tm.m_mon;
+              m_year = tm.m_year;
+              m_wday = tm.m_wday;
+              m_yday = tm.m_yday;
+              m_isdst = tm.m_isdst;
+              m_gmtoff = tm.m_gmtoff;
+              m_zone = tm.m_zone;
+            }
 
-  // Seconds since the epoch.
-  time_t ot_unix_time;
+          return *this;
+        }
+
+      virtual ~base_tm (void) { }
 
-  // Additional microseconds.
-  int ot_usec;
-};
+      int usec (void) const { return m_usec; }
+      int sec (void) const { return m_sec; }
+      int min (void) const { return m_min; }
+      int hour (void) const { return m_hour; }
+      int mday (void) const { return m_mday; }
+      int mon (void) const { return m_mon; }
+      int year (void) const { return m_year; }
+      int wday (void) const { return m_wday; }
+      int yday (void) const { return m_yday; }
+      int isdst (void) const { return m_isdst; }
+      long gmtoff (void) const { return m_gmtoff; }
+      std::string zone (void) const { return m_zone; }
 
-inline bool
-operator == (const octave_time& t1, const octave_time& t2)
-{
-  return (t1.unix_time () == t2.unix_time () && t1.usec () == t2.usec ());
-}
+      base_tm& usec (int v);
+      base_tm& sec (int v);
+      base_tm& min (int v);
+      base_tm& hour (int v);
+      base_tm& mday (int v);
+      base_tm& mon (int v);
+      base_tm& year (int v);
+      base_tm& wday (int v);
+      base_tm& yday (int v);
+      base_tm& isdst (int v);
+      base_tm& gmtoff (long v);
+      base_tm& zone (const std::string& s);
+
+      std::string strftime (const std::string& fmt) const;
+
+      std::string asctime (void) const
+      { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
+
+    protected:
+
+      // Microseconds after the second (0, 999999).
+      int m_usec;
+
+      // Seconds after the minute (0, 61).
+      int m_sec;
 
-inline bool
-operator != (const octave_time& t1, const octave_time& t2)
-{
-  return ! (t1 == t2);
-}
+      // Minutes after the hour (0, 59).
+      int m_min;
+
+      // Hours since midnight (0, 23).
+      int m_hour;
+
+      // Day of the month (1, 31).
+      int m_mday;
+
+      // Months since January (0, 11).
+      int m_mon;
+
+      // Years since 1900.
+      int m_year;
+
+      // Days since Sunday (0, 6).
+      int m_wday;
+
+      // Days since January 1 (0, 365).
+      int m_yday;
+
+      // Daylight Savings Time flag.
+      int m_isdst;
+
+      // Time zone.
+      long m_gmtoff;
 
-inline bool
-operator < (const octave_time& t1, const octave_time& t2)
-{
-  if (t1.unix_time () < t2.unix_time ())
-    return true;
-  else if (t1.unix_time () > t2.unix_time ())
-    return false;
-  else if (t1.usec () < t2.usec ())
-    return true;
-  else
-    return false;
-}
+      // Time zone.
+      std::string m_zone;
+
+      void init (void *p);
+    };
+
+    class
+    OCTAVE_API
+    localtime : public base_tm
+    {
+    public:
+
+      localtime (void)
+        : base_tm () { init (time ()); }
+
+      localtime (const time& ot)
+        : base_tm () { init (ot); }
+
+      localtime (const localtime& t)
+        : base_tm (t) { }
 
-inline bool
-operator <= (const octave_time& t1, const octave_time& t2)
-{
-  return (t1 < t2 || t1 == t2);
-}
+      localtime& operator = (const localtime& t)
+        {
+          base_tm::operator = (t);
+          return *this;
+        }
+
+      ~localtime (void) { }
+
+    private:
+
+      void init (const time& ot);
+    };
+
+    class
+    OCTAVE_API
+    gmtime : public base_tm
+    {
+    public:
+
+      gmtime (void)
+        : base_tm () { init (time ()); }
+
+      gmtime (const time& ot)
+        : base_tm () { init (ot); }
 
-inline bool
-operator > (const octave_time& t1, const octave_time& t2)
-{
-  if (t1.unix_time () > t2.unix_time ())
-    return true;
-  else if (t1.unix_time () < t2.unix_time ())
-    return false;
-  else if (t1.usec () > t2.usec ())
-    return true;
-  else
-    return false;
-}
+      gmtime& operator = (const gmtime& t)
+        {
+          base_tm::operator = (t);
+          return *this;
+        }
+
+      ~gmtime (void) { }
+
+    private:
+
+      void init (const time& ot);
+    };
+
+    class
+    OCTAVE_API
+    strptime : public base_tm
+    {
+    public:
 
-inline bool
-operator >= (const octave_time& t1, const octave_time& t2)
-{
-  return (t1 > t2 || t1 == t2);
-}
+      strptime (const std::string& str, const std::string& fmt)
+        : base_tm (), nchars (0)
+        {
+          init (str, fmt);
+        }
+
+      strptime (const strptime& s)
+        : base_tm (s), nchars (s.nchars) { }
 
-inline octave_time
-operator + (const octave_time& t1, const octave_time& t2)
-{
-  return octave_time (t1.unix_time () + t2.unix_time (),
-                      t1.usec () + t2.usec ());
+      strptime& operator = (const strptime& s)
+        {
+          base_tm::operator = (s);
+          nchars = s.nchars;
+          return *this;
+        }
+
+      int characters_converted (void) const { return nchars; }
+
+      ~strptime (void) { }
+
+    private:
+
+      int nchars;
+
+      void init (const std::string& str, const std::string& fmt);
+    };
+  }
 }
 
-class
-OCTAVE_API
-octave_base_tm
-{
-public:
-
-  octave_base_tm (void)
-    : tm_usec (0), tm_sec (0), tm_min (0), tm_hour (0),
-      tm_mday (0), tm_mon (0), tm_year (0), tm_wday (0),
-      tm_yday (0), tm_isdst (0), tm_gmtoff (0), tm_zone ("unknown")
-  { }
-
-  octave_base_tm (const octave_base_tm& tm)
-    : tm_usec (tm.tm_usec), tm_sec (tm.tm_sec), tm_min (tm.tm_min),
-      tm_hour (tm.tm_hour), tm_mday (tm.tm_mday), tm_mon (tm.tm_mon),
-      tm_year (tm.tm_year), tm_wday (tm.tm_wday), tm_yday (tm.tm_yday),
-      tm_isdst (tm.tm_isdst), tm_gmtoff (tm.tm_gmtoff), tm_zone (tm.tm_zone)
-  { }
-
-  octave_base_tm& operator = (const octave_base_tm& tm)
-  {
-    if (this != &tm)
-      {
-        tm_usec = tm.tm_usec;
-        tm_sec = tm.tm_sec;
-        tm_min = tm.tm_min;
-        tm_hour = tm.tm_hour;
-        tm_mday = tm.tm_mday;
-        tm_mon = tm.tm_mon;
-        tm_year = tm.tm_year;
-        tm_wday = tm.tm_wday;
-        tm_yday = tm.tm_yday;
-        tm_isdst = tm.tm_isdst;
-        tm_gmtoff = tm.tm_gmtoff;
-        tm_zone = tm.tm_zone;
-      }
-
-    return *this;
-  }
-
-  virtual ~octave_base_tm (void) { }
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  int usec (void) const { return tm_usec; }
-  int sec (void) const { return tm_sec; }
-  int min (void) const { return tm_min; }
-  int hour (void) const { return tm_hour; }
-  int mday (void) const { return tm_mday; }
-  int mon (void) const { return tm_mon; }
-  int year (void) const { return tm_year; }
-  int wday (void) const { return tm_wday; }
-  int yday (void) const { return tm_yday; }
-  int isdst (void) const { return tm_isdst; }
-  long gmtoff (void) const { return tm_gmtoff; }
-  std::string zone (void) const { return tm_zone; }
-
-  octave_base_tm& usec (int v);
-  octave_base_tm& sec (int v);
-  octave_base_tm& min (int v);
-  octave_base_tm& hour (int v);
-  octave_base_tm& mday (int v);
-  octave_base_tm& mon (int v);
-  octave_base_tm& year (int v);
-  octave_base_tm& wday (int v);
-  octave_base_tm& yday (int v);
-  octave_base_tm& isdst (int v);
-  octave_base_tm& gmtoff (long v);
-  octave_base_tm& zone (const std::string& s);
-
-  std::string strftime (const std::string& fmt) const;
+OCTAVE_DEPRECATED ("use octave::sys::time instead")
+typedef octave::sys::time octave_time;
 
-  std::string asctime (void) const
-  { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
-
-protected:
-
-  // Microseconds after the second (0, 999999).
-  int tm_usec;
-
-  // Seconds after the minute (0, 61).
-  int tm_sec;
-
-  // Minutes after the hour (0, 59).
-  int tm_min;
-
-  // Hours since midnight (0, 23).
-  int tm_hour;
-
-  // Day of the month (1, 31).
-  int tm_mday;
-
-  // Months since January (0, 11).
-  int tm_mon;
-
-  // Years since 1900.
-  int tm_year;
-
-  // Days since Sunday (0, 6).
-  int tm_wday;
+OCTAVE_DEPRECATED ("use octave::sys::base_tm instead")
+typedef octave::sys::base_tm octave_base_tm;
 
-  // Days since January 1 (0, 365).
-  int tm_yday;
-
-  // Daylight Savings Time flag.
-  int tm_isdst;
-
-  // Time zone.
-  long tm_gmtoff;
-
-  // Time zone.
-  std::string tm_zone;
-
-  void init (void *p);
-};
-
-class
-OCTAVE_API
-octave_localtime : public octave_base_tm
-{
-public:
-
-  octave_localtime (void)
-    : octave_base_tm () { init (octave_time ()); }
-
-  octave_localtime (const octave_time& ot)
-    : octave_base_tm () { init (ot); }
-
-  octave_localtime (const octave_localtime& t)
-    : octave_base_tm (t) { }
-
-  octave_localtime& operator = (const octave_localtime& t)
-  {
-    octave_base_tm::operator = (t);
-    return *this;
-  }
-
-  ~octave_localtime (void) { }
-
-private:
-
-  void init (const octave_time& ot);
-};
-
-class
-OCTAVE_API
-octave_gmtime : public octave_base_tm
-{
-public:
+OCTAVE_DEPRECATED ("use octave::sys::localtime instead")
+typedef octave::sys::localtime octave_localtime;
 
-  octave_gmtime (void)
-    : octave_base_tm () { init (octave_time ()); }
-
-  octave_gmtime (const octave_time& ot)
-    : octave_base_tm () { init (ot); }
-
-  octave_gmtime& operator = (const octave_gmtime& t)
-  {
-    octave_base_tm::operator = (t);
-    return *this;
-  }
-
-  ~octave_gmtime (void) { }
-
-private:
-
-  void init (const octave_time& ot);
-};
-
-class
-OCTAVE_API
-octave_strptime : public octave_base_tm
-{
-public:
+OCTAVE_DEPRECATED ("use octave::sys::gmtime instead")
+typedef octave::sys::gmtime octave_gmtime;
 
-  octave_strptime (const std::string& str, const std::string& fmt)
-    : octave_base_tm (), nchars (0)
-  {
-    init (str, fmt);
-  }
-
-  octave_strptime (const octave_strptime& s)
-    : octave_base_tm (s), nchars (s.nchars) { }
-
-  octave_strptime& operator = (const octave_strptime& s)
-  {
-    octave_base_tm::operator = (s);
-    nchars = s.nchars;
-    return *this;
-  }
-
-  int characters_converted (void) const { return nchars; }
-
-  ~octave_strptime (void) { }
-
-private:
-
-  int nchars;
-
-  void init (const std::string& str, const std::string& fmt);
-};
+OCTAVE_DEPRECATED ("use octave::sys::strptime instead")
+typedef octave::sys::strptime octave_strptime;
 
 #endif
+
+#endif
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1606,17 +1606,17 @@ command_editor::do_decode_prompt_string 
 
             case 'd':
             case 't':
             case 'T':
             case '@':
             case 'A':
               // Make the current time/date into a string.
               {
-                octave_localtime now;
+                octave::sys::localtime now;
 
                 if (c == 'd')
                   tmpstr = now.strftime ("%a %b %d");
                 else if (c == 't')
                   tmpstr = now.strftime ("%H:%M:%S");
                 else if (c == 'T')
                   tmpstr = now.strftime ("%I:%M:%S");
                 else if (c == '@')
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -67,17 +67,17 @@ public: // FIXME: make this class privat
 
     bool is_out_of_date (void) const;
 
     // This method will be overridden conditionally.
     static shlib_rep *new_instance (const std::string& f);
 
     static shlib_rep *get_instance (const std::string& f, bool fake);
 
-    octave_time time_loaded (void) const
+    octave::sys::time time_loaded (void) const
     { return tm_loaded; }
 
     std::string file_name (void) const
     { return file; }
 
     size_t num_fcn_names (void) const { return fcn_names.size (); }
 
     void add_fcn_name (const std::string&);
@@ -90,17 +90,17 @@ public: // FIXME: make this class privat
 
     octave_refcount<int> count;
 
   protected:
 
     void fake_reload (void);
 
     std::string file;
-    octave_time tm_loaded;
+    octave::sys::time tm_loaded;
 
     // Set of hooked function names.
     typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
     typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
 
     std::map<std::string, size_t> fcn_names;
 
     static std::map<std::string, shlib_rep *> instances;
@@ -178,17 +178,17 @@ public:
   { return rep->num_fcn_names (); }
 
   bool is_out_of_date (void) const
   { return rep->is_out_of_date (); }
 
   std::string file_name (void) const
   { return rep->file_name (); }
 
-  octave_time time_loaded (void) const
+  octave::sys::time time_loaded (void) const
   { return rep->time_loaded (); }
 
 private:
 
   shlib_rep *rep;
 };
 
 #endif
