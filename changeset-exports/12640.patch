# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1304265457 25200
#      Sun May 01 08:57:37 2011 -0700
# Node ID 88b82e1b54ac9d76f1bc2a3fd6d462a8ead8d527
# Parent  fd367312095a1fb550a904801ba72fba3d40ebf0
# Parent  4d777e05d47c2a82879e5ad7f1d9ca8a5869741b
maint: Periodic merge of stable branch to default branch

diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -84,30 +84,30 @@ Note that breakpoints cannot be set in b
 set a breakpoint immediately on entering a function, the breakpoint
 should be set to line 1. The leading comment block will be ignored and
 the breakpoint will be set to the first executable statement in the
 function.  For example:
 
 @example
 @group
 dbstop ("asind", 1)
-@result{} 27
+@result{} 28
 @end group
 @end example
 
 @noindent
 Note that the return value of @code{27} means that the breakpoint was
 effectively set to line 27.  The status of breakpoints in a function can
 be queried with the @code{dbstatus} function.
 
 @DOCSTRING(dbstatus)
 
 @noindent
 Taking the above as an example, @code{dbstatus ("asind")} should return
-27.  The breakpoints can then be cleared with the @code{dbclear} function
+28.  The breakpoints can then be cleared with the @code{dbclear} function
 
 @DOCSTRING(dbclear)
 
 @noindent
 These functions can be used to clear all the breakpoints in a function.  For
 example:
 
 @example
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -333,16 +333,34 @@ c = 2
 @end group
 @end example
 
 @noindent
 along with a warning.
 
 @DOCSTRING(nargout)
 
+It is good practice at the head of a function to verify that it has been called
+correctly.  In Octave the following idiom is seen frequently
+
+@example
+@group
+if (nargin < min_#_inputs || nargin > max_#_inputs)
+  print_usage ();
+endif
+@end group
+@end example
+
+@noindent
+which stops the function execution and prints a message about the correct
+way to call the function whenever the number of inputs is wrong.
+
+For compatability with @sc{matlab}, @code{nargchk} and @code{nargoutchk} are
+available which provide similar error checking.
+
 @DOCSTRING(nargchk)
 
 @DOCSTRING(nargoutchk)
 
 @anchor{doc-varargin} @anchor{doc-varargout}
 @node Variable-length Argument Lists
 @section Variable-length Argument Lists
 @cindex variable-length argument lists
@@ -1272,51 +1290,56 @@ to find them.
 
 The following is a list of all the function file subdirectories, and the
 types of functions you will find there.
 
 @table @file
 @item audio
 Functions for playing and recording sounds.
 
-@item control
-Functions for design and simulation of automatic control systems.
+@item deprecated
+Out-of-date functions which will eventually be removed from Octave.
 
 @item elfun
-Elementary functions.
+Elementary functions, principally trigonometric.
 
-@item finance
-Functions for computing interest payments, investment values, and rates
-of return.
+@item @@ftp
+Class functions for the FTP object.
 
 @item general
 Miscellaneous matrix manipulations, like @code{flipud}, @code{rot90},
 and @code{triu}, as well as other basic functions, like
 @code{ismatrix}, @code{nargchk}, etc.
 
+@item geometry
+Functions related to Delaunay triangulation.
+
+@item help
+Functions for Octave's built-in help system.
+
 @item image
 Image processing tools.  These functions require the X Window System.
 
 @item io
 Input-output functions.
 
 @item linear-algebra
 Functions for linear algebra.
 
 @item miscellaneous
 Functions that don't really belong anywhere else.
 
 @item optimization
-Minimization of functions.
+Functions related to minimzation, optimization, and root finding.
 
 @item path
 Functions to manage the directory path Octave uses to find functions.
 
 @item pkg
-Install external packages of functions in Octave.
+Package manager for installing external packages of functions in Octave.
 
 @item plot
 Functions for displaying and printing two- and three-dimensional graphs.
 
 @item polynomial
 Functions for manipulating polynomials.
 
 @item set
@@ -1324,28 +1347,29 @@ Functions for creating and manipulating 
 
 @item signal
 Functions for signal processing applications.
 
 @item sparse
 Functions for handling sparse matrices.
 
 @item specfun
-Special functions.
+Special functions such as @code{bessel} or @code{factor}.
 
 @item special-matrix
-Functions that create special matrix forms.
+Functions that create special matrix forms such as Hilbert or Vandermonde
+matrices.
 
 @item startup
 Octave's system-wide startup file.
 
 @item statistics
 Statistical functions.
 
 @item strings
 Miscellaneous string-handling functions.
 
 @item testfun
-Perform unit tests on other functions.
+Functions for performing unit tests on other functions.
 
 @item time
-Functions related to time keeping.
+Functions related to time and date processing.
 @end table
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -70,21 +70,21 @@ Note that in conditional contexts (like 
 @DOCSTRING(diff)
 
 @DOCSTRING(isinf)
 
 @DOCSTRING(isnan)
 
 @DOCSTRING(isfinite)
 
+@DOCSTRING(common_size)
+
 @DOCSTRING(find)
         
 @DOCSTRING(lookup)
-        
-@DOCSTRING(common_size)
 
 @node Rearranging Matrices
 @section Rearranging Matrices
 
 @DOCSTRING(fliplr)
 
 @DOCSTRING(flipud)
 
@@ -105,47 +105,26 @@ Note that in conditional contexts (like 
 @DOCSTRING(ipermute)
 
 @DOCSTRING(reshape)
 
 @DOCSTRING(resize)
 
 @DOCSTRING(circshift)
 
-@DOCSTRING(shiftdim)
+@DOCSTRING(shift)
 
-@DOCSTRING(shift)
+@DOCSTRING(shiftdim)
 
 @DOCSTRING(sort)
 
 @DOCSTRING(sortrows)
 
 @DOCSTRING(issorted)
 
-Since the @code{sort} function does not allow sort keys to be specified,
-it can't be used to order the rows of a matrix according to the values
-of the elements in various columns@footnote{For example, to first sort
-based on the values in column 1, and then, for any values that are
-repeated in column 1, sort based on the values found in column 2, etc.}
-in a single call.  Using the second output, however, it is possible to
-sort all rows based on the values in a given column.  Here's an example
-that sorts the rows of a matrix based on the values in the second
-column.
-
-@example
-@group
-a = [1, 2; 2, 3; 3, 1];
-[s, i] = sort (a (:, 2));
-a (i, :)
-     @result{}  3  1
-         1  2
-         2  3
-@end group
-@end example
-
 @DOCSTRING(nth_element)
 
 @anchor{doc-triu}
 @DOCSTRING(tril)
 
 @DOCSTRING(vec)
 
 @DOCSTRING(vech)
@@ -173,16 +152,24 @@ a (i, :)
 @DOCSTRING(ones)
 
 @DOCSTRING(zeros)
 
 @DOCSTRING(repmat)
 
 @DOCSTRING(repelems)
 
+The functions @code{linspace} and @code{logspace} make it very easy to
+create vectors with evenly or logarithmically spaced elements.
+@xref{Ranges}.
+
+@DOCSTRING(linspace)
+
+@DOCSTRING(logspace)
+
 @DOCSTRING(rand)
 
 @DOCSTRING(randi)
 
 @DOCSTRING(randn)
 
 @DOCSTRING(rande)
 
@@ -243,24 +230,16 @@ single element of a random sequence.
 The original @code{rand} and @code{randn} functions use Fortran code from
 @sc{ranlib}, a library of Fortran routines for random number generation,
 compiled by Barry W. Brown and James Lovato of the Department of
 Biomathematics at The University of Texas, M.D. Anderson Cancer Center,
 Houston, TX 77030.
 
 @DOCSTRING(randperm)
 
-The functions @code{linspace} and @code{logspace} make it very easy to
-create vectors with evenly or logarithmically spaced elements.
-@xref{Ranges}.
-
-@DOCSTRING(linspace)
-
-@DOCSTRING(logspace)
-
 @node Famous Matrices
 @section Famous Matrices
 
 The following functions return famous matrix forms.
 
 @DOCSTRING(hadamard)
 
 @DOCSTRING(hankel)
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -25,19 +25,19 @@
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "UniformOutput", @var{val})
 ## @deftypefnx {Function File} {} arrayfun (@dots{}, "ErrorHandler", @var{errfunc})
 ##
 ## Execute a function on each element of an array.  This is useful for
 ## functions that do not accept array arguments.  If the function does
 ## accept array arguments it is better to call the function directly.
 ##
 ## The first input argument @var{func} can be a string, a function
-## handle, an inline function or an anonymous function.  The input
+## handle, an inline function, or an anonymous function.  The input
 ## argument @var{A} can be a logic array, a numeric array, a string
-## array, a structure array or a cell array.  By a call of the function
+## array, a structure array, or a cell array.  By a call of the function
 ## @command{arrayfun} all elements of @var{A} are passed on to the named
 ## function @var{func} individually.
 ##
 ## The named function can also take more than two input arguments, with
 ## the input arguments given as third input argument @var{b}, fourth
 ## input argument @var{c}, @dots{}  If given more than one array input
 ## argument then all input arguments must have the same sizes, for
 ## example:
@@ -91,29 +91,29 @@
 ##   [1,1] =  10
 ##   [2,1] = [](0x0)
 ## @}
 ## @end group
 ## @end example
 ##
 ## If the parameter @var{errfunc} after a further string input argument
 ## "ErrorHandler" is another string, a function handle, an inline
-## function or an anonymous function, then @var{errfunc} defines a
+## function, or an anonymous function, then @var{errfunc} defines a
 ## function to call in the case that @var{func} generates an error.
 ## The definition of the function must be of the form
 ##
 ## @example
 ## function [@dots{}] = errfunc (@var{s}, @dots{})
 ## @end example
 ##
 ## @noindent
 ## where there is an additional input argument to @var{errfunc}
 ## relative to @var{func}, given by @var{s}.  This is a structure with
-## the elements "identifier", "message" and "index", giving
-## respectively the error identifier, the error message and the index of
+## the elements "identifier", "message", and "index" giving,
+## respectively, the error identifier, the error message, and the index of
 ## the array elements that caused the error.  The size of the output
 ## argument of @var{errfunc} must have the same size as the output
 ## argument of @var{func}, otherwise a real error is thrown.  For
 ## example:
 ##
 ## @example
 ## @group
 ## function y = ferr (s, x), y = "MyString"; endfunction
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blkdiag (@var{A}, @var{B}, @var{C}, @dots{})
-## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}.
+## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}
 ## All the arguments must be numeric and are two-dimensional matrices or
 ## scalars.
 ## @seealso{diag, horzcat, vertcat}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -13,28 +13,29 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fliplr (@var{x})
-## Return a copy of @var{x} with the order of the columns reversed.  For
+## Return a copy of @var{x} with the order of the columns reversed.  In
+## other words, @var{x} is flipped left-to-right about a vertical axis.  For
 ## example:
 ##
 ## @example
 ## @group
 ## fliplr ([1, 2; 3, 4])
 ##      @result{}  2  1
 ##          4  3
 ## @end group
 ## @end example
 ##
-## Note that @code{fliplr} only work with 2-D arrays.  To flip N-d arrays
+## Note that @code{fliplr} only works with 2-D arrays.  To flip N-D arrays
 ## use @code{flipdim} instead.
 ## @seealso{flipud, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = fliplr (x)
 
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -13,29 +13,29 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} flipud (@var{x})
-## Return a copy of @var{x} with the order of the rows reversed.  For
+## Return a copy of @var{x} with the order of the rows reversed.  In
+## other words, @var{x} is flipped upside-down about a horizontal axis.  For
 ## example:
 ##
 ## @example
 ## @group
 ## flipud ([1, 2; 3, 4])
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining which axis about which to flip the
-## matrix @code{flipud} only work with 2-d arrays.  To flip N-d arrays
+## Note that @code{flipud} only works with 2-D arrays.  To flip N-D arrays
 ## use @code{flipdim} instead.
 ## @seealso{fliplr, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = flipud (x)
 
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -12,54 +12,53 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} logspace (@var{base}, @var{limit})
-## @deftypefnx {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
-## Similar to @code{linspace} except that the values are logarithmically
-## spaced from
+## @deftypefn  {Function File} {} logspace (@var{a}, @var{b})
+## @deftypefnx {Function File} {} logspace (@var{b}, @var{b}, @var{n})
+## @deftypefnx {Function File} {} logspace (@var{a}, pi, @var{n})
+## Return a row vector with @var{n} elements logarithmically spaced from
 ## @tex
-## $10^{base}$ to $10^{limit}$.
+## $10^{a}$ to $10^{b}$.
 ## @end tex
 ## @ifnottex
-## 10^base to 10^limit.
+## 10^@var{a} to 10^@var{b}.
 ## @end ifnottex
+## If @var{n} is unspecified it defaults to 50.
 ##
-## If @var{limit} is equal to
+## If @var{b} is equal to
 ## @tex
 ## $\pi$,
 ## @end tex
 ## @ifnottex
 ## pi,
 ## @end ifnottex
 ## the points are between
 ## @tex
-## $10^{base}$ and $\pi$,
+## $10^{a}$ and $\pi$,
 ## @end tex
 ## @ifnottex
-## 10^base and pi,
+## 10^@var{a} and pi,
 ## @end ifnottex
 ## @emph{not}
 ## @tex
-## $10^{base}$ and $10^{\pi}$,
+## $10^{a}$ and $10^{\pi}$,
 ## @end tex
 ## @ifnottex
-## 10^base and 10^pi,
+## 10^@var{a} and 10^pi,
 ## @end ifnottex
-## in order to be compatible with the corresponding @sc{matlab}
-## function.
-## If @var{n} is unspecified it defaults to 50.
+## in order to be compatible with the corresponding @sc{matlab} function.
 ##
-## Also for compatibility with @sc{matlab}, return the second argument if
-## fewer than two values are requested.
+## Also for compatibility with @sc{matlab}, return the second argument @var{b}
+## if fewer than two values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = logspace (base, limit, n)
 
   if (nargin == 2)
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} postpad (@var{x}, @var{l})
 ## @deftypefnx {Function File} {} postpad (@var{x}, @var{l}, @var{c})
 ## @deftypefnx {Function File} {} postpad (@var{x}, @var{l}, @var{c}, @var{dim})
-## Append the scalar value @var{c} to the vector @var{x}
-## until it is of length @var{l}.  If the third argument is not
-## supplied, a value of 0 is used.
+## Append the scalar value @var{c} to the vector @var{x} until it is of length
+## @var{l}.  If @var{c} is not given, a value of 0 is used.
 ##
 ## If @code{length (@var{x}) > @var{l}}, elements from the end of
 ## @var{x} are removed until a vector of length @var{l} is obtained.
 ##
 ## If @var{x} is a matrix, elements are appended or removed from each row.
 ##
 ## If the optional argument @var{dim} is given, operate along this
 ## dimension.
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -15,19 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} prepad (@var{x}, @var{l})
 ## @deftypefnx {Function File} {} prepad (@var{x}, @var{l}, @var{c})
 ## @deftypefnx {Function File} {} prepad (@var{x}, @var{l}, @var{c}, @var{dim})
-## Prepend the scalar value @var{c} to the vector @var{x}
-## until it is of length @var{l}.  If the third argument is not
-## supplied, a value of 0 is used.
+## Prepend the scalar value @var{c} to the vector @var{x} until it is of length
+## @var{l}.  If @var{c} is not given, a value of 0 is used.
 ##
 ## If @code{length (@var{x}) > @var{l}}, elements from the beginning of
 ## @var{x} are removed until a vector of length @var{l} is obtained.
 ##
 ## If @var{x} is a matrix, elements are prepended or removed from each row.
 ##
 ## If the optional argument @var{dim} is given, operate along this
 ## dimension.
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} randi (@var{imax})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{n})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{m}, @var{n}, @dots{})
-## @deftypefnx {Function File} {} randi ([@var{imin}, @var{imax}], @dots{})
+## @deftypefnx {Function File} {} randi ([@var{imin} @var{imax}], @dots{})
 ## @deftypefnx {Function File} {} randi (@dots{}, "@var{class}")
 ## Return random integers in the range 1:@var{imax}.
 ##
 ## Additional arguments determine the shape of the return matrix.  When no
 ## arguments are specified a single random integer is returned.  If one
 ## argument @var{n} is specified then a square matrix @w{(@var{n} x @var{n})} is
 ## returned.  Two or more arguments will return a multi-dimensional
 ## matrix @w{(@var{m} x @var{n} x @dots{})}.
@@ -42,17 +42,17 @@
 ## @example
 ## ri = randi (10, 150, 1);
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
 ## uses class "double" to represent numbers.  This limits the maximum
 ## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
-## this value is @w{@code{2^53 - 1}}.
+## this value is @w{@math{2^{53} - 1}}.
 ##
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 
 function ri = randi (bounds, varargin)
 
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -13,17 +13,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} repmat (@var{A}, @var{m}, @var{n})
+## @deftypefn  {Function File} {} repmat (@var{A}, @var{m})
+## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n})
+## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n}, @var{p}, @dots{})
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
 ## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
 ## @var{A} as each element.  If @var{n} is not specified, form an
 ## @var{m} by @var{m} block matrix.
 ## @seealso{repelems}
 ## @end deftypefn
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -12,17 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rot90 (@var{A}, @var{k})
+## @deftypefn  {Function File} {} rot90 (@var{A})
+## @deftypefnx {Function File} {} rot90 (@var{A}, @var{k})
 ## Return a copy of @var{A} with the elements rotated counterclockwise in
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
 ## Negative values of @var{k} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
@@ -39,18 +40,17 @@
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ## rot90 ([1, 2; 3, 4], 3)
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining an axis about which to rotate the
-## matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
+## Note that @code{rot90} only works with 2-D arrays.  To rotate N-D arrays
 ## use @code{rotdim} instead.
 ## @seealso{rotdim, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function B = rot90 (A, k)
 
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -12,24 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rotdim (@var{x}, @var{n}, @var{plane})
+## @deftypefn  {Function File} {} rotdim (@var{x})
+## @deftypefnx {Function File} {} rotdim (@var{x}, @var{n})
+## @deftypefnx {Function File} {} rotdim (@var{x}, @var{n}, @var{plane})
 ## Return a copy of @var{x} with the elements rotated counterclockwise in
-## 90-degree increments.  The second argument is optional, and specifies
-## how many 90-degree rotations are to be applied (the default value is 1).
+## 90-degree increments.
+## The second argument @var{n} is optional, and specifies how many 90-degree
+## rotations are to be applied (the default value is 1).
 ## The third argument is also optional and defines the plane of the
-## rotation.  As such @var{plane} is a two element vector containing two
-## different valid dimensions of the matrix.  If @var{plane} is not given
-## Then the first two non-singleton dimensions are used.
+## rotation.  If present, @var{plane} is a two element vector containing two
+## different valid dimensions of the matrix.  When @var{plane} is not given
+## the first two non-singleton dimensions are used.
 ##
 ## Negative values of @var{n} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
 ## rotdim ([1, 2; 3, 4], -1, [1, 2])
 ##      @result{}  3  1
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} shiftdim (@var{x}, @var{n})
 ## @deftypefnx {Function File} {[@var{y}, @var{ns}] =} shiftdim (@var{x})
-## Shift the dimension of @var{x} by @var{n}, where @var{n} must be
+## Shift the dimensions of @var{x} by @var{n}, where @var{n} must be
 ## an integer scalar.  When @var{n} is positive, the dimensions of
 ## @var{x} are shifted to the left, with the leading dimensions
 ## circulated to the end.  If @var{n} is negative, then the dimensions
 ## of @var{x} are shifted to the right, with @var{n} leading singleton
 ## dimensions added.
 ##
 ## Called with a single argument, @code{shiftdim}, removes the leading
 ## singleton dimensions, returning the number of dimensions removed
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -13,17 +13,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sortrows (@var{A}, @var{c})
+## @deftypefn  {Function File} {[@var{s}, @var{i}] =} sortrows (@var{A})
+## @deftypefnx {Function File} {[@var{s}, @var{i}] =} sortrows (@var{A}, @var{c})
 ## Sort the rows of the matrix @var{A} according to the order of the
 ## columns specified in @var{c}.  If @var{c} is omitted, a
 ## lexicographical sort is used.  By default ascending order is used
 ## however if elements of @var{c} are negative then the corresponding
 ## column is sorted in descending order.
 ## @end deftypefn
 
 ## Author: Daniel Calvelo, Paul Kienzle
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -16,17 +16,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vech (@var{x})
 ## Return the vector obtained by eliminating all supradiagonal elements of
 ## the square matrix @var{x} and stacking the result one column above the
-## other.
+## other.  This has uses in matrix calculus where the underlying matrix
+## is symmetric and it would be pointless to keep values above the main
+## diagonal.
+## @seealso{vec}
 ## @end deftypefn
 
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 
 ## Author KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -71,17 +71,17 @@
 ## @table @samp
 ## @item editor
 ## This is the editor to use to modify the functions.  By default it uses
 ## Octave's @env{EDITOR} built-in function, which comes from
 ## @code{getenv("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
 ## In place of the function name.  For example,
 ## @table @samp
 ## @item [EDITOR, " %s"]
-## Use the editor which Octave uses for @code{bug_report}.
+## Use the editor which Octave uses for @code{edit_history}.
 ##
 ## @item "xedit %s &"
 ## pop up simple X11 editor in a separate window
 ##
 ## @item "gnudoit -q \"(find-file \\\"%s\\\")\""
 ## Send it to current Emacs; must have @code{(gnuserv-start)} in @file{.emacs}.
 ## @end table
 ##
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -12,21 +12,34 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
+## @deftypefn {Mapping Function} {@var{z} =} xor (@var{x}, @var{y})
 ## Return the `exclusive or' of the entries of @var{x} and @var{y}.
 ## For boolean expressions @var{x} and @var{y},
-## @code{xor (@var{x}, @var{y})} is true if and only if @var{x} or @var{y}
-## is true, but not if both @var{x} and @var{y} are true.
+## @code{xor (@var{x}, @var{y})} is true if and only if one of @var{x} or
+## @var{y} is true.  Otherwise, for @var{x} and @var{y} both true or both
+## false, @code{xor} returns false.
+##
+## The truth table for the xor operation is
+##
+## @multitable @columnfractions 0.44 .03 .05 .03 0.44
+## @item @tab @var{x} @tab @var{y} @tab @var{z} @tab
+## @item @tab 0 @tab 0 @tab 0 @tab
+## @item @tab 1 @tab 0 @tab 1 @tab
+## @item @tab 0 @tab 1 @tab 1 @tab
+## @item @tab 1 @tab 1 @tab 0 @tab
+## @end multitable
+##
+## @seealso{and, or, not}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -19,20 +19,22 @@
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fzero (@var{fun}, @var{x0})
 ## @deftypefnx {Function File} {} fzero (@var{fun}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@dots{})
 ## Find a zero of a univariate function.
 ##
-## @var{fun} should be a function handle or name.  @var{x0} should be a
-## two-element vector specifying two points which bracket a zero.  In
-## other words, there must be a change in sign of the function between
-## @var{x0}(1) and @var{x0}(2).  More mathematically, the following must hold
+## @var{fun} is a function handle, inline function, or string
+## containing the name of the function to evaluate.
+## @var{x0} should be a two-element vector specifying two points which
+## bracket a zero.  In other words, there must be a change in sign of the
+## function between @var{x0}(1) and @var{x0}(2).  More mathematically, the
+## following must hold
 ##
 ## @example
 ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
 ## @end example
 ##
 ## If @var{x0} is a single scalar then several nearby and distant
 ## values are probed in an attempt to obtain a valid bracketing.  If this
 ## is not successful, the function fails.
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -16,18 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fplot (@var{fn}, @var{limits})
 ## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{tol})
 ## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{n})
 ## @deftypefnx {Function File} {} fplot (@dots{}, @var{fmt})
-## Plot a function @var{fn}, within the defined limits.  @var{fn}
-## an be either a string, a function handle or an inline function.
+## Plot a function @var{fn} within defined limits.
+## @var{fn} is a function handle, inline function, or string
+## containing the name of the function to evaluate.
 ## The limits of the plot are given by @var{limits} of the form
 ## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
 ## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
 ## plot, and if @var{tol} is an integer it is assumed that it defines the
 ## number points to use in the plot.  The @var{fmt} argument is passed
 ## to the plot command.
 ##
 ## @example
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hadamard (@var{n})
-## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The
-## size @var{n} must be of the form @code{2 ^ @var{k} * @var{p}} in which
-## @var{p} is one of 1, 12, 20 or 28.  The returned matrix is normalized,
-## meaning @code{Hn(:,1) == 1} and @code{Hn(1,:) == 1}.
+## Construct a Hadamard matrix (@nospell{Hn}) of size @var{n}-by-@var{n}.  The
+## size @var{n} must be of the form @math{2^k * p} in which
+## p is one of 1, 12, 20 or 28.  The returned matrix is normalized,
+## meaning @w{@code{Hn(:,1) == 1}} and @w{@code{Hn(1,:) == 1}}.
 ##
 ## Some of the properties of Hadamard matrices are:
 ##
 ## @itemize @bullet
 ## @item
-## @code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size
-## @var{m}-by-@var{n}.
+## @code{kron (Hm, Hn)} is a Hadamard matrix of size @var{m}-by-@var{n}.
 ##
 ## @item
-## @code{Hn * Hn' == @var{n} * eye (@var{n})}.
+## @code{Hn * Hn' = @var{n} * eye (@var{n})}.
+##
+## @item
+## The rows of @nospell{Hn} are orthogonal.
 ##
 ## @item
-## The rows of @var{Hn} are orthogonal.
+## @code{det (@var{A}) <= abs (det (Hn))} for all @var{A} with
+## @w{@code{abs (@var{A}(i, j)) <= 1}}.
 ##
 ## @item
-## @code{det (@var{A}) <= abs(det (@var{Hn}))} for all @var{A} with
-## @code{abs (@var{A} (@var{i}, @var{j})) <= 1}.
-##
-## @item
-## Multiply any row or column by -1 and still have a Hadamard matrix.
+## Multiplying any row or column by -1 and the matrix will remain a Hadamard
+## matrix.
 ## @end itemize
-##
+## @seealso{compan, hankel, toeplitz}
 ## @end deftypefn
 
 
 ## Reference [1] contains a list of Hadamard matrices up to n=256.
 ## See code for h28 in hadamard.m for an example of how to extend
 ## this function for additional p.
 ##
 ## References:
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hankel (@var{c})
 ## @deftypefnx {Function File} {} hankel (@var{c}, @var{r})
-## Return the Hankel matrix constructed given the first column @var{c}, and
+## Return the Hankel matrix constructed from the first column @var{c}, and
 ## (optionally) the last row @var{r}.  If the last element of @var{c} is
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, it is assumed to
 ## be a vector of zeros with the same size as @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
 ## @tex
@@ -37,17 +37,17 @@
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{vander, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{hadamard, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
     r = resize (resize (c, 0), size(c));
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -13,37 +13,46 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
-## Return the Hilbert matrix of order @var{n}.  The
-## @tex
-## $i,\,j$
-## @end tex
-## @ifnottex
-## i, j
-## @end ifnottex
-## element of a Hilbert matrix is defined as
+## Return the Hilbert matrix of order @var{n}.  The @math{i,j} element
+## of a Hilbert matrix is defined as
 ## @tex
 ## $$
 ## H (i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
+##
+## Hilbert matrices are close to being singular which make them difficult to
+## invert with numerical routines.
+## Comparing the condition number of a random matrix 5x5 matrix with that of
+## a Hilbert matrix of order 5 reveals just how difficult the problem is.
+##
+## @example
+## @group
+## cond (rand (5))
+##     @result{} 14.392
+## cond (hilb (5))
+##     @result{} 4.7661e+05
+## @end group
+## @end example
+##
+## @seealso{invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
   if (nargin != 1)
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -63,17 +63,17 @@
 ## The validity of this formula can easily be checked by expanding
 ## the binomial coefficients in both formulas as factorials.  It can
 ## be derived more directly via the theory of Cauchy matrices.
 ## See J. W. Demmel, @cite{Applied Numerical Linear Algebra}, p. 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
-## @seealso{hilb, hankel, vander, sylvester_matrix, toeplitz}
+## @seealso{hilb}
 ## @end deftypefn
 
 ## Author: Dirk Laurie <dlaurie@na-net.ornl.gov>
 
 function retval = invhilb (n)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -14,19 +14,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} magic (@var{n})
 ##
-## Create an @var{n}-by-@var{n} magic square.  Note that @code{magic
-## (@var{2})} is undefined since there is no 2-by-2 magic square.
+## Create an @var{n}-by-@var{n} magic square.  A magic square is an arrangement
+## of the integers @code{1:n^2} such that the row sums, column sums, and
+## diagonal sums are all equal to the same value.
 ##
+## Note: @var{n} must be greater than 2 for the magic square to exist.
 ## @end deftypefn
 
 function A = magic(n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -15,29 +15,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pascal (@var{n})
 ## @deftypefnx {Function File} {} pascal (@var{n}, @var{t})
-## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
-## @var{t} defaults to 0.  Return the pseudo-lower triangular 
-## Cholesky@tie{}factor of the Pascal matrix if @code{@var{t} = 1} (The sign
-## of some columns may be negative).  This matrix is its own
-## inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
-## If @code{@var{t} = -1}, return the true Cholesky@tie{}factor with strictly
-## positive values on the diagonal.  
-## If @code{@var{t} = 2}, return a transposed and permuted version of
-## @code{pascal (@var{n}, 1)}, which is the cube root of the identity
-## matrix.  That is, @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
+## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.  @var{t}
+## defaults to 0.  Return the pseudo-lower triangular Cholesky@tie{}factor of
+## the Pascal matrix if @code{@var{t} = 1} (The sign of some columns may be
+## negative).  This matrix is its own inverse, that is @code{pascal (@var{n},
+## 1) ^ 2 == eye (@var{n})}.  If @code{@var{t} = -1}, return the true
+## Cholesky@tie{}factor with strictly positive values on the diagonal.  If
+## @code{@var{t} = 2}, return a transposed and permuted version of @code{pascal
+## (@var{n}, 1)}, which is the cube root of the identity matrix.  That is,
+## @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, wilkinson, compan, rosser}
+## @seealso{chol}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = pascal (n, t)
 
   if (nargin > 2) || (nargin == 0)
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -16,18 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rosser ()
 ## Return the Rosser matrix.  This is a difficult test case used to evaluate
 ## eigenvalue algorithms.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, wilkinson, compan, pascal}
+## @seealso{wilkinson, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = rosser ()
 
   if (nargin != 0)
@@ -37,12 +36,13 @@ function retval = rosser ()
   retval = [611,   196,  -192,   407,    -8,   -52,   -49,    29;
             196,   899,   113,  -192,   -71,   -43,    -8,   -44;
            -192,   113,   899,   196,    61,    49,     8,    52;
             407,  -192,   196,   611,     8,    44,    59,   -23;
              -8,   -71,    61,     8,   411,  -599,   208,   208;
             -52,   -43,    49,    44,  -599,   411,   208,   208;
             -49,    -8,     8,    59,   208,   208,    99,  -911;
              29,   -44,    52,   -23,   208,   208,  -911,    99];
+
 endfunction
 
 %!assert (size(rosser()), [8,8])
 %!error (rosser(1))
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -18,19 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sylvester_matrix (@var{k})
 ## Return the Sylvester matrix of order
 ## @tex
 ## $n = 2^k$.
 ## @end tex
 ## @ifnottex
-## n = 2^k.
+## n = 2^@var{k}.
 ## @end ifnottex
-## @seealso{hankel, vander, hilb, invhilb, toeplitz}
+##
+## @seealso{toeplitz, hankel}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -15,19 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} toeplitz (@var{c})
 ## @deftypefnx {Function File} {} toeplitz (@var{c}, @var{r})
-## Return the Toeplitz matrix constructed given the first column @var{c},
-## and (optionally) the first row @var{r}.  If the first element of @var{c}
-## is not the same as the first element of @var{r}, the first element of
+## Return the Toeplitz matrix constructed from the first column @var{c},
+## and (optionally) the first row @var{r}.  If the first element of @var{r}
+## is not the same as the first element of @var{c}, the first element of
 ## @var{c} is used.  If the second argument is omitted, the first row is
 ## taken to be the same as the first column.
 ##
 ## A square Toeplitz matrix has the form:
 ## @tex
 ## $$
 ## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
 ##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
@@ -46,17 +46,17 @@
 ##  .     .      .   .      .
 ##  .     .      .     .    .
 ##  .     .      .       .  .
 ## c(n) c(n-1) c(n-2) @dots{}  c(0)
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb}
+## @seealso{hankel}
 ## @end deftypefn
 
 ## Author: jwe && jh
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -42,17 +42,17 @@
 ##     .     .      .      .    .
 ##     .       .    .      .    .
 ##     .         .  .      .    .
 ## c(n)^(n-1) @dots{} c(n)^2  c(n)  1
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
+## @seealso{polyfit}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = vander (c, n)
 
   if (nargin == 1)
     n = length (c);
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wilkinson (@var{n})
 ## Return the Wilkinson matrix of order @var{n}.  Wilkinson matrices are
 ## symmetric and tridiagonal with pairs of nearly, but not exactly, equal
-## eigenvalues.
+## eigenvalues.  They are useful in testing the behavior and performance
+## of eigenvalue solvers.
 ##
-## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz,
-##          hadamard, rosser, compan, pascal}
+## @seealso{rosser, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = wilkinson (n)
 
   if (nargin != 1)
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -15,16 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{q}, @var{s}] =} qqplot (@var{x})
 ## @deftypefnx {Function File} {[@var{q}, @var{s}] =} qqplot (@var{x}, @var{dist})
 ## @deftypefnx {Function File} {[@var{q}, @var{s}] =} qqplot (@var{x}, @var{dist}, @var{params})
+## @deftypefnx {Function File} {} qqplot (@dots{})
 ## Perform a QQ-plot (quantile plot).
 ##
 ## If F is the CDF of the distribution @var{dist} with parameters
 ## @var{params} and G its inverse, and @var{x} a sample vector of length
 ## @var{n}, the QQ-plot graphs ordinate @var{s}(@var{i}) = @var{i}-th
 ## largest element of x versus abscissa @var{q}(@var{i}f) = G((@var{i} -
 ## 0.5)/@var{n}).
 ##
@@ -32,17 +33,17 @@
 ## and scale, the pairs will approximately follow a straight line.
 ##
 ## The default for @var{dist} is the standard normal distribution.  The
 ## optional argument @var{params} contains a list of parameters of
 ## @var{dist}.  For example, for a quantile plot of the uniform
 ## distribution on [2,4] and @var{x}, use
 ##
 ## @example
-## qqplot (x, "uniform", 2, 4)
+## qqplot (x, "unif", 2, 4)
 ## @end example
 ##
 ## @noindent
 ## @var{dist} can be any string for which a function @var{distinv} or
 ## @var{dist_inv} exists that calculates the inverse CDF of distribution
 ## @var{dist}.
 ##
 ## If no output arguments are given, the data are plotted directly.
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -46,17 +46,17 @@
 ## error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
 ## If @var{tol} is negative use it as a relative tolerance, will produce an
 ## error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} *
 ## @var{expected})}.  If @var{expected} is zero @var{tol} will always be used as
 ## an absolute tolerance.
 ## @end table
-## @seealso{test}
+## @seealso{test, fail}
 ## @end deftypefn
 
 ## FIXME: Output throttling: don't print out the entire 100x100 matrix,
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
 ## the message generation type specific.
 
 function assert (cond, varargin)
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -15,17 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} fail (@var{code}, @var{pattern})
+## @deftypefn  {Function File} {} fail (@var{code})
+## @deftypefnx {Function File} {} fail (@var{code}, @var{pattern})
 ## @deftypefnx {Function File} {} fail (@var{code}, 'warning', @var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
 ## @var{pattern}, otherwise produce an error.  Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
 ## @example
 ##           expected error but got none
@@ -40,17 +41,17 @@
 ## @end group
 ## @end example
 ##
 ## The angle brackets are not part of the output.
 ##
 ## Called with three arguments, the behavior is similar to
 ## @code{fail(@var{code}, @var{pattern})}, but produces an error if no
 ## warning is given during code execution or if the code fails.
-##
+## @seealso{assert}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function ret = fail (code, pattern, warning_pattern)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -308,19 +308,20 @@ update_index (Array<int>& idx, const dim
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 Apply a binary function @var{f} element-by-element to two matrix arguments\n\
-@var{A} and @var{B}.  The function @var{f} must be capable of accepting\n\
-two column-vector arguments of equal length, or one column vector\n\
-argument and a scalar.\n\
+@var{A} and @var{B}.  @var{f} is a function handle, inline function, or\n\
+string containing the name of the function to evaluate.\n\
+The function @var{f} must be capable of accepting two column-vector\n\
+arguments of equal length, or one column vector argument and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
 singleton dimensions of the matrices will be expanded to the same\n\
 dimensionality as the other matrix.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -59,16 +59,24 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 {
   MArray<T> y;
 
   octave_idx_type a_len  = a.length ();
   octave_idx_type b_len  = b.length ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
+  // FIXME: The two lines below should be unecessary because
+  //        this template is called with a and b as column vectors
+  //        already.  However the a.resize line is currently (2011/04/26)
+  //        necessary to stop bug #33164.
+  b.resize (dim_vector (ab_len, 1), 0.0);
+  if (a_len > 1)
+    a.resize (dim_vector (ab_len, 1), 0.0);
+
   T norm = a (0);
 
   if (norm == static_cast<T>(0.0))
     {
       error ("filter: the first element of A must be non-zero");
       return y;
     }
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -336,21 +336,21 @@ find_nonzero_elem_idx (const PermMatrix&
 }
 
 DEFUN_DLD (find, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{idx} =} find (@var{x})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
 @deftypefnx {Loadable Function} {[i, j] =} find (@dots{})\n\
-@deftypefnx {Loadable Function} {[i, j, v]] =} find (@dots{})\n\
+@deftypefnx {Loadable Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
-@var{x} is a row or as a column otherwise.  To obtain a single index for\n\
-each matrix element, Octave pretends that the columns of a matrix form one\n\
-long vector (like Fortran arrays are stored).  For example:\n\
+@var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
+for each matrix element, Octave pretends that the columns of a matrix form\n\
+one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
      @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
 \n\
@@ -385,19 +385,19 @@ If three inputs are given, @var{directio
 However, the indices are always returned in ascending order.\n\
 \n\
 Note that this function is particularly useful for sparse matrices, as\n\
 it extracts the non-zero elements as vectors, which can then be used to\n\
 create the original matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
-sz = size(a);\n\
+sz = size (a);\n\
 [i, j, v] = find (a);\n\
-b = sparse(i, j, v, sz(1), sz(2));\n\
+b = sparse (i, j, v, sz(1), sz(2));\n\
 @end group\n\
 @end example\n\
 @seealso{nonzeros}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -183,40 +183,41 @@ do_numeric_lookup (const ArrayT& array, 
   else
     retval = idx;
 
   return retval;
 }
 
 DEFUN_DLD (lookup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
+@deftypefn  {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
+@deftypefnx {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.  Usually used as a prelude to\n\
 interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)}\n\
-within the table.  If @code{y(i) < table (1)} then\n\
+within the table.  If @code{y(i) < table(1)} then\n\
 @code{idx(i)} is 0. If @code{y(i) >= table(end)} or @code{isnan (y(i))} then\n\
 @code{idx(i)} is @code{n}.\n\
 \n\
 If the table is decreasing, then the tests are reversed.\n\
 For non-strictly monotonic tables, empty intervals are always skipped.\n\
 The result is undefined if @var{table} is not monotonic, or if\n\
 @var{table} contains a NaN.\n\
 \n\
 The complexity of the lookup is O(M*log(N)) where N is the size of\n\
 @var{table} and M is the size of @var{y}.  In the special case when @var{y}\n\
 is also sorted, the complexity is O(min(M*log(N),M+N)).\n\
 \n\
 @var{table} and @var{y} can also be cell arrays of strings\n\
 (or @var{y} can be a single string).  In this case, string lookup\n\
 is performed using lexicographical comparison.\n\
 \n\
-If @var{opts} is specified, it shall be a string with letters indicating\n\
+If @var{opts} is specified, it must be a string with letters indicating\n\
 additional options.\n\
 \n\
 @table @code\n\
 @item m\n\
 @code{table(idx(i)) == val(i)} if @code{val(i)}\n\
 occurs in table; otherwise, @code{idx(i)} is zero.\n\
 \n\
 @item b\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -321,18 +321,19 @@ do_rand (const octave_value_list& args, 
         }
     }
   else
     return octave_rand::nd_array (dims);
 }
 
 DEFUN_DLD (rand, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rand (@var{x})\n\
-@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} rand (@var{n})\n\
+@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} rand ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} rand (\"state\")\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} rand (\"seed\")\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", \"reset\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
@@ -354,23 +355,23 @@ rand (\"state\", v)\n\
 @end example\n\
 \n\
 @noindent\n\
 You may also initialize the state vector from an arbitrary vector of\n\
 length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
-available, otherwise from CPU time, wall clock time and the current\n\
+available, otherwise from CPU time, wall clock time, and the current\n\
 fraction of a second.\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
 Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and\n\
 T. Nishimura,\n\
-@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform \n\
+@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform\n\
 pseudorandom number generator}, ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,\n\
 @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).\n\
 Do @strong{not} use for cryptography without securely hashing\n\
 several returned values together, otherwise the generator state\n\
 can be learned after reading 624 consecutive values.\n\
 \n\
 Older versions of Octave used a different random number generator.\n\
@@ -485,18 +486,19 @@ using the \"reset\" keyword.\n\
 %! endif
 */
 
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randn (@var{x})\n\
-@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randn (@var{n})\n\
+@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randn ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randn (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", \"reset\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
@@ -550,18 +552,19 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.02);
 %!   assert(skewness(x),0,0.02);
 %!   assert(kurtosis(x),0,0.04);
 %! endif
 */
 
 DEFUN_DLD (rande, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rande (@var{x})\n\
-@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} rande (@var{n})\n\
+@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} rande ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} rande (\"state\")\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} rande (\"seed\")\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", \"reset\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
@@ -616,18 +619,19 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.03);
 %!   assert(skewness(x),2,0.06);
 %!   assert(kurtosis(x),6,0.7);
 %! endif
 */
 
 DEFUN_DLD (randg, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randg (@var{a}, @var{x})\n\
-@deftypefnx {Loadable Function} {} randg (@var{a}, @var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randg (@var{n})\n\
+@deftypefnx {Loadable Function} {} randg (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randg ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
@@ -658,17 +662,17 @@ r = a * randg (n)\n\
 @end example\n\
 \n\
 @item @code{chisq (df)} for @code{df > 0}\n\
 \n\
 @example\n\
 r = 2 * randg (df / 2)\n\
 @end example\n\
 \n\
-@item @code{t(df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
+@item @code{t (df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
 \n\
 @example\n\
 r = randn () / sqrt (2 * randg (df / 2) / df)\n\
 @end example\n\
 \n\
 @item @code{F (n1, n2)} for @code{0 < n1}, @code{0 < n2}\n\
 \n\
 @example\n\
@@ -872,18 +876,19 @@ r = r / sum (r)\n\
 %!   assert(skewness(x),2/sqrt(a), 0.05);
 %!   assert(kurtosis(x),6/a,       0.2);
 %! endif
 */
 
 
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randp (@var{l}, @var{x})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})\n\
+@deftypefn  {Loadable Function} {} randp (@var{l}, @var{n})\n\
+@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Loadable Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randp (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", \"reset\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.  The arguments\n\
@@ -1017,17 +1022,17 @@ D 50 p1284, 1994.\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} permutations,\n\
-one in each row of an @nospell{NxM} matrix.  The complexity is O(M*N) in both\n\
+one in each row of an @nospell{MxN} matrix.  The complexity is O(M*N) in both\n\
 time and memory.  The randomization is performed using rand().\n\
 All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -384,17 +384,17 @@ tril (ones (3), 1)\n\
          1  1  1\n\
          1  1  1\n\
 @end group\n\
 @end example\n\
 \n\
 If the option \"pack\" is given as third argument, the extracted elements\n\
 are not inserted into a matrix, but rather stacked column-wise one above\n\
 other.\n\
-@seealso{triu, diag}\n\
+@seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN_DLD (triu, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} triu (@var{A})\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -101,20 +101,35 @@ along with Octave; see the file COPYING.
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (all, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} all (@var{x}, @var{dim})\n\
-The function @code{all} behaves like the function @code{any}, except\n\
-that it returns true only if all the elements of a vector, or all the\n\
-elements along dimension @var{dim} of a matrix, are nonzero.\n\
+@deftypefn  {Built-in Function} {} all (@var{x})\n\
+@deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
+For a vector argument, return true (logical 1) if all elements of the vector\n\
+are nonzero.\n\
+\n\
+For a matrix argument, return a row vector of logical ones and\n\
+zeros with each element indicating whether all of the elements of the\n\
+corresponding column of the matrix are nonzero.  For example:\n\
+\n\
+@example\n\
+@group\n\
+all ([2, 3; 1, 0]))\n\
+     @result{} [ 1, 0 ]\n\
+@end group\n\
+@end example\n\
+\n\
+If the optional argument @var{dim} is supplied, work along dimension\n\
+@var{dim}.\n\
+@seealso{any}\n\
 @end deftypefn")
 {
   ANY_ALL (all);
 }
 
 /*
 
 %!test
@@ -135,21 +150,22 @@ elements along dimension @var{dim} of a 
 
 %!error <Invalid call to all.*> all ();
 %!error <Invalid call to all.*> all (1, 2, 3);
 
  */
 
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} any (@var{x}, @var{dim})\n\
-For a vector argument, return 1 if any element of the vector is\n\
-nonzero.\n\
+@deftypefn  {Built-in Function} {} any (@var{x})\n\
+@deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
+For a vector argument, return true (logical 1) if any element of the vector\n\
+is nonzero.\n\
 \n\
-For a matrix argument, return a row vector of ones and\n\
+For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
      @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
@@ -159,16 +175,17 @@ If the optional argument @var{dim} is su
 @var{dim}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4), 2)\n\
      @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
+@seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
 /*
 
 %!test
@@ -1681,79 +1698,91 @@ do_cat (const octave_value_list& args, i
     print_usage ();
 
   return retval;
 }
 
 DEFUN (horzcat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the horizontal concatenation of N-d array objects, @var{array1},\n\
+Return the horizontal concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
+\n\
+Arrays may also be concatenated horizontally using the syntax for creating\n\
+new matrices.  For example:\n\
+\n\
+@example\n\
+@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ];\n\
+@end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 DEFUN (vertcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the vertical concatenation of N-d array objects, @var{array1},\n\
+Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
+\n\
+Arrays may also be concatenated vertically using the syntax for creating\n\
+new matrices.  For example:\n\
+\n\
+@example\n\
+@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ];\n\
+@end example\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 DEFUN (cat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
-Return the concatenation of N-d array objects, @var{array1},\n\
+Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
 cat (2, A, B)\n\
-@result{} ans =\n\
-\n\
-     1 1 0 0\n\
-     1 1 0 0\n\
+    @result{} 1 1 0 0\n\
+       1 1 0 0\n\
 @end group\n\
 @end example\n\
 \n\
 Alternatively, we can concatenate @var{A} and @var{B} along the\n\
 second dimension the following way:\n\
 \n\
 @example\n\
 @group\n\
 [A, B].\n\
 @end group\n\
 @end example\n\
 \n\
-@var{dim} can be larger than the dimensions of the N-d array objects\n\
+@var{dim} can be larger than the dimensions of the N-D array objects\n\
 and the result will thus have @var{dim} dimensions as the\n\
 following example shows:\n\
 \n\
 @example\n\
 @group\n\
-cat (4, ones(2, 2), zeros (2, 2))\n\
-@result{} ans =\n\
+cat (4, ones (2, 2), zeros (2, 2))\n\
+    @result{} ans =\n\
 \n\
-   ans(:,:,1,1) =\n\
+       ans(:,:,1,1) =\n\
 \n\
-     1 1\n\
-     1 1\n\
+         1 1\n\
+         1 1\n\
 \n\
-   ans(:,:,1,2) =\n\
-     0 0\n\
-     0 0\n\
+       ans(:,:,1,2) =\n\
+         0 0\n\
+         0 0\n\
 @end group\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () > 0)
@@ -1941,37 +1970,37 @@ do_permute (const octave_value_list& arg
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\n\
-Return the generalized transpose for an N-d array object @var{a}.\n\
+@deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
+Return the generalized transpose for an N-D array object @var{A}.\n\
 The permutation vector @var{perm} must contain the elements\n\
-@code{1:ndims(a)} (in any order, but each element must appear just once).\n\
+@code{1:ndims(A)} (in any order, but each element must appear only once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
+@deftypefn {Built-in Function} {} ipermute (@var{A}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
-ipermute (permute (a, perm), perm)\n\
+ipermute (permute (A, perm), perm)\n\
 @end example\n\
 \n\
 @noindent\n\
-returns the original array @var{a}.\n\
+returns the original array @var{A}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
@@ -3428,38 +3457,39 @@ fill_matrix (const octave_value_list& ar
         retval = boolNDArray (dims, val);
     }
 
   return retval;
 }
 
 DEFUN (ones, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} ones (@var{x})\n\
-@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {Built-in Function} {} ones (@var{n})\n\
+@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} ones (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {Built-in Function} {} ones ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 1.\n\
-If invoked with a single scalar integer argument, return a square\n\
-matrix of the specified size.  If invoked with two or more scalar\n\
+If invoked with a single scalar integer argument @var{n}, return a square\n\
+@nospell{NxN} matrix.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
-given dimensions.\n\
+the given dimensions.\n\
 \n\
 If you need to create a matrix whose values are all the same, you should\n\
 use an expression like\n\
 \n\
 @example\n\
-val_matrix = val * ones (n, m)\n\
+val_matrix = val * ones (m, n)\n\
 @end example\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
 and defaults to double.  For example:\n\
 \n\
 @example\n\
-val = ones (n,m, \"uint8\")\n\
+val = ones (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
 /*
@@ -3478,31 +3508,32 @@ val = ones (n,m, \"uint8\")\n\
 %!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
 %!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
 %!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} zeros (@var{x})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})\n\
-@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k}, @dots{})\n\
+@deftypefn  {Built-in Function} {} zeros (@var{n})\n\
+@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
+@deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
-matrix of the specified size.  If invoked with two or more scalar\n\
+@nospell{NxN} matrix.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
-given dimensions.\n\
+the given dimensions.\n\
 \n\
 The optional argument @var{class} specifies the class of the return array\n\
 and defaults to double.  For example:\n\
 \n\
 @example\n\
-val = zeros (n,m, \"uint8\")\n\
+val = zeros (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
 /*
@@ -4108,24 +4139,25 @@ identity_matrix (int nr, int nc, oct_dat
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} eye (@var{x})\n\
-@deftypefnx {Built-in Function} {} eye (@var{n}, @var{m})\n\
+@deftypefn  {Built-in Function} {} eye (@var{n})\n\
+@deftypefnx {Built-in Function} {} eye (@var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {} eye ([@var{m} @var{n}])\n\
 @deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})\n\
-Return an identity matrix.  If invoked with a single scalar argument,\n\
-@code{eye} returns a square matrix with the dimension specified.  If you\n\
-supply two scalar arguments, @code{eye} takes them to be the number of\n\
-rows and columns.  If given a vector with two elements, @code{eye} uses\n\
-the values of the elements as the number of rows and columns,\n\
+Return an identity matrix.  If invoked with a single scalar argument @var{n},\n\
+return a square @nospell{NxN} identity matrix.  If\n\
+supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them to be\n\
+the number of rows and columns.  If given a vector with two elements,\n\
+@code{eye} uses the values of the elements as the number of rows and columns,\n\
 respectively.  For example:\n\
 \n\
 @example\n\
 @group\n\
 eye (3)\n\
      @result{}  1  0  0\n\
          0  1  0\n\
          0  0  1\n\
@@ -4149,16 +4181,17 @@ the specified type, like\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 \n\
 Calling @code{eye} with no arguments is equivalent to calling it\n\
 with an argument of 1.  This odd definition is for compatibility\n\
 with @sc{matlab}.\n\
+@seealso{speye}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
@@ -4266,30 +4299,31 @@ do_linspace (const octave_value& base, c
         }
     }
 
   return retval;
 }
 
 DEFUN (linspace, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
+@deftypefn  {Built-in Function} {} linspace (@var{base}, @var{limit})\n\
+@deftypefnx {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
-then the @var{base} and @var{limit} are always included in\n\
+then the endpoints @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
 \n\
 The @code{linspace} function always returns a row vector if both\n\
-@var{base} and @var{limit} are scalars.  If one of them or both are column\n\
+@var{base} and @var{limit} are scalars.  If one, or both, of them are column\n\
 vectors, @code{linspace} returns a matrix.\n\
 \n\
-For compatibility with @sc{matlab}, return the second argument if\n\
-fewer than two values are requested.\n\
+For compatibility with @sc{matlab}, return the second argument (@var{limit})\n\
+if fewer than two values are requested.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   octave_idx_type npoints = 100;
 
@@ -4352,18 +4386,18 @@ fewer than two values are requested.\n\
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
-@deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
 In other words, the statement\n\
 \n\
@@ -4381,21 +4415,22 @@ is equivalent to the following code:\n\
   for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor\n\
   y(idx@{:@}) = x(idx@{:@});\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but is performed more efficiently.\n\
 \n\
-If only @var{m} is supplied and it is a scalar, the dimension of the\n\
-result is @var{m}-by-@var{m}.  If @var{m} is a vector, then the\n\
-dimensions of the result are given by the elements of @var{m}.\n\
-If both @var{m} and @var{n} are scalars, then the dimensions of\n\
-the result are @var{m}-by-@var{n}.\n\
+If only @var{m} is supplied, and it is a scalar, the dimension of the\n\
+result is @var{m}-by-@var{m}.\n\
+If @var{m}, @var{n}, @dots{} are all scalars, then the dimensions of\n\
+the result are @var{m}-by-@var{n}-by-@dots{}.\n\
+If given a vector as input, then the\n\
+dimensions of the result are given by the elements of that vector.\n\
 \n\
 An object can be resized to more dimensions than it has;\n\
 in such case the missing dimensions are assumed to be 1.\n\
 Resizing an object to fewer dimensions is not possible.\n\
 @seealso{reshape, postpad}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -4438,38 +4473,44 @@ Resizing an object to fewer dimensions i
     print_usage ();
   return retval;
 }
 
 // FIXME -- should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
-@deftypefnx {Built-in Function} {} reshape (@var{a}, @var{size})\n\
-Return a matrix with the given dimensions whose elements are taken\n\
-from the matrix @var{a}.  The elements of the matrix are accessed in\n\
-column-major order (like Fortran arrays are stored).\n\
+@deftypefn  {Built-in Function} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, [@var{m} @var{n} @dots{}])\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, @dots{}, [], @dots{})\n\
+@deftypefnx {Built-in Function} {} reshape (@var{A}, @var{size})\n\
+Return a matrix with the specified dimensions (@var{m}, @var{n}, @dots{})\n\
+whose elements are taken from the matrix @var{A}.  The elements of the\n\
+matrix are accessed in column-major order (like Fortran arrays are stored).\n\
 \n\
-For example:\n\
+The following code demonstrates reshaping a 1x4 row vector into a 2x2 square\n\
+matrix.\n\
 \n\
 @example\n\
 @group\n\
 reshape ([1, 2, 3, 4], 2, 2)\n\
      @result{}  1  3\n\
          2  4\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the total number of elements in the original\n\
-matrix must match the total number of elements in the new matrix.\n\
+matrix (@code{prod (size (@var{A}))}) must match the total number of elements\n\
+in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
-A single dimension of the return matrix can be unknown and is flagged\n\
-by an empty argument.\n\
+A single dimension of the return matrix may be left unspecified and Octave\n\
+will determine its size automatically.  An empty matrix ([]) is used to flag\n\
+the unspecified dimension.\n\
+@seealso{resize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector new_dims;
 
@@ -4579,16 +4620,17 @@ DEFUN (vec, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
 are set to @var{dim} with all elements along the last dimension.\n\
 This is equivalent to @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
+@seealso{vech}\n\
 @end deftypefn")
 {
   octave_value retval;
   int dim = 1;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
@@ -4866,17 +4908,17 @@ unary_op_defun_body (octave_value::unary
   return retval;
 }
 
 DEFUN (not, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} not (@var{x})\n\
 Return the logical NOT of @var{x}.  This function is equivalent to\n\
 @code{! x}.\n\
-@seealso{and, or}\n\
+@seealso{and, or, xor}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
@@ -5209,17 +5251,17 @@ This function is equivalent to @w{@code{
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 & x2) & x3) & @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{or, not}\n\
+@seealso{or, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
 }
 
 DEFUN (or, args, ,
   "-*- texinfo -*-\n\
@@ -5230,17 +5272,17 @@ This function is equivalent to @w{@code{
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 | x2) | x3) | @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{and, not}\n\
+@seealso{and, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
@@ -5420,55 +5462,71 @@ CPU time used is nonzero.\n\
 
 DEFUN (sort, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing\n\
-order.  For matrices, @code{sort} orders the elements in each column.\n\
+order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
      @result{}  1  1\n\
          2  2\n\
          3  3\n\
 @end group\n\
 @end example\n\
 \n\
+If the optional argument @var{dim} is given, then the matrix is sorted\n\
+along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
+defines the order in which the values will be sorted.  Valid values of\n\
+@code{mode} are `ascend' or `descend'.\n\
+\n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
 matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
      @result{} s = 1  1\n\
             2  2\n\
             3  3\n\
      @result{} i = 1  3\n\
             2  1\n\
             3  2\n\
 @end group\n\
 @end example\n\
 \n\
-If the optional argument @var{dim} is given, then the matrix is sorted\n\
-along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
-defines the order in which the values will be sorted.  Valid values of\n\
-@code{mode} are `ascend' or `descend'.\n\
+For equal elements, the indices are such that equal elements are listed\n\
+in the order in which they appeared in the original list.\n\
+\n\
+Sorting of complex entries is done first by magnitude (@code{abs (@var{z})})\n\
+and for any ties by phase angle (@code{angle (z)}).  For example:\n\
 \n\
-For equal elements, the indices are such that the equal elements are listed\n\
-in the order that appeared in the original list.\n\
+@example\n\
+@group\n\
+sort ([1+i; 1; 1-i])\n\
+     @result{} 1 + 0i\n\
+        1 - 1i\n\
+        1 + 1i\n\
+@end group\n\
+@end example\n\
+\n\
+NaN values are treated as being greater than any other value and are sorted\n\
+to the end of the list.\n\
 \n\
 The @code{sort} function may also be used to sort strings and cell arrays\n\
-of strings, in which case the dictionary order of the strings is used.\n\
+of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
+lowercase 'a') of the strings is used.\n\
 \n\
 The algorithm used in @code{sort} is optimized for the sorting of partially\n\
 ordered lists.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -5808,17 +5866,18 @@ get_sort_mode_option (const octave_value
   else
     error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
+@deftypefn  {Built-in Function} {} issorted (@var{a})\n\
+@deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @code{\"rows\"}, @var{mode})\n\
 Return true if the array is sorted according to @var{mode}, which\n\
 may be either \"ascending\", \"descending\", or \"either\".  By default,\n\
  @var{mode} is \"ascending\".  NaNs are treated in the same manner as\n\
 @code{sort}.\n\
 \n\
 If the optional argument \"rows\" is supplied, check whether\n\
 the array is sorted by rows as output by the function @code{sortrows}\n\
@@ -5931,17 +5990,18 @@ Select the n-th smallest element of a ve
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
 If @var{x} is an array, @code{nth_element} operates along the dimension\n\
 defined by @var{dim}, or the first non-singleton dimension if @var{dim} is\n\
 not given.\n\
 \n\
 nth_element encapsulates the C++ standard library algorithms nth_element and\n\
 partial_sort.  On average, the complexity of the operation is O(M*log(K)),\n\
-where @code{M = size(@var{x}, @var{dim})} and @code{K = length (@var{n})}.\n\
+where @w{@code{M = size (@var{x}, @var{dim})}} and\n\
+@w{@code{K = length (@var{n})}}.\n\
 This function is intended for cases where the ratio K/M is small; otherwise,\n\
 it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
@@ -6545,41 +6605,43 @@ do_diff (const octave_value& array, octa
         retval = array.array_value ().diff (order, dim);
     }
 
   return retval;
 }
 
 DEFUN (diff, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
-If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the\n\
+@deftypefn  {Built-in Function} {} diff (@var{x})\n\
+@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k})\n\
+@deftypefnx {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
+If @var{x} is a vector of length @math{n}, @code{diff (@var{x})} is the\n\
 vector of first differences\n\
 @tex\n\
  $x_2 - x_1, \\ldots{}, x_n - x_{n-1}$.\n\
 @end tex\n\
 @ifnottex\n\
  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).\n\
 @end ifnottex\n\
 \n\
 If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column\n\
 differences along the first non-singleton dimension.\n\
 \n\
 The second argument is optional.  If supplied, @code{diff (@var{x},\n\
 @var{k})}, where @var{k} is a non-negative integer, returns the\n\
 @var{k}-th differences.  It is possible that @var{k} is larger than\n\
-then first non-singleton dimension of the matrix.  In this case,\n\
+the first non-singleton dimension of the matrix.  In this case,\n\
 @code{diff} continues to take the differences along the next\n\
 non-singleton dimension.\n\
 \n\
 The dimension along which to take the difference can be explicitly\n\
-stated with the optional variable @var{dim}.  In this case the \n\
+stated with the optional variable @var{dim}.  In this case the\n\
 @var{k}-th order differences are calculated along this dimension.\n\
 In the case where @var{k} exceeds @code{size (@var{x}, @var{dim})}\n\
-then an empty matrix is returned.\n\
+an empty matrix is returned.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   else if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -2117,18 +2117,18 @@ No checks are made for duplicate element
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add @var{dir1}, @dots{} to the current function search path.  If\n\
-@var{option} is @samp{\"-begin\"} or 0 (the default), prepend the\n\
-directory name to the current path.  If @var{option} is @samp{\"-end\"}\n\
+@var{option} is \"-begin\" or 0 (the default), prepend the\n\
+directory name to the current path.  If @var{option} is \"-end\"\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
 addpath (\"dir1:/dir2:~/dir3\");\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -874,21 +874,21 @@ Compute the Gamma function,\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-            infinity\n\
-            /\n\
+             infinity\n\
+             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
-            /\n\
-         t=0\n\
+             /\n\
+          t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -874,16 +874,27 @@ the arguments of the inline function @va
 }
 
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
 by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
 @code{.*}, @code{./}, etc.\n\
+\n\
+This may be useful, for example, when using inline functions with\n\
+numerical integration or optimization where a vector-valued function\n\
+is expected.\n\
+\n\
+@example\n\
+fcn = vectorize (inline (\"x^2 - 1\"))\n\
+   @result{} fcn = f(x) = x.^2 - 1\n\
+quadv (fcn, 0, 3)\n\
+   @result{} 6\n\
+@end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -541,16 +541,17 @@ Check only for variables.\n\
 Check only for built-in functions.\n\
 \n\
 @item \"file\"\n\
 Check only for files.\n\
 \n\
 @item \"dir\"\n\
 Check only for directories.\n\
 @end table\n\
+@seealso{file_in_loadpath}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
