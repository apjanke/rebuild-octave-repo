# HG changeset patch
# User jwe
# Date 1145905991 0
#      Mon Apr 24 19:13:11 2006 +0000
# Node ID ace8d8d26933c072d3badebb7c155f14c841b18d
# Parent  e7af222e98b02573c5ed3fd9b576deb97fc4ff1a
[project @ 2006-04-24 19:13:06 by jwe]

diff --git a/ChangeLog.1 b/ChangeLog.1
--- a/ChangeLog.1
+++ b/ChangeLog.1
@@ -2526,17 +2526,17 @@ Mon Jul 25 12:57:09 1994  John Eaton  (j
 
 	* src/octave.cc (Fshell_cmd): Restore accidentally deleted
 	function.
 
 	* scripts/conv-amr.m, scripts/deconv-amr.m, scripts/roots-amr.m,
 	scripts/poly-amr.m, scripts/roots-tuwien.m, scripts/conv-tuwien.m,
 	scripts/deconv-tuwien.m, scripts/poly-tuwien.m:
 	New files.
-	XXX FIXME XXX -- For each of these functions, either one of the
+	FIXME -- For each of these functions, either one of the
 	versions will need to be selected, or they will need to be merged
 	before the next release.
 
 	* scripts/null.m, scripts/orth.m, scripts/fft2.m, scripts/ifft2.m,
 	scripts/filter.m, scripts/compan.m, scripts/polyderiv.m,
 	scripts/polyinteg.m, scripts/polyreduce.m, scripts/polyval.m,
 	scripts/polyvalm.m, scripts/postpad.m, scripts/prepad.m,
 	scripts/residue.m, scripts/sinc.m, scripts/freqz.m,
@@ -9089,17 +9089,17 @@ Sat Nov 21 16:41:02 1992  John W. Eaton 
 	CRMATRIX_ASSIGN_ELEM): New macro for dealing with real and complex
 	matrices in the same tree_constant_rep function.
 
 	* tree-const.cc: Include arith-ops.cc.
 
 	* arith-op.cc: New file for functions that implement unary and
 	binary operations for the tree_constat classes.
 	* Mark all operations that aren't implemented yet with a
-	XXX FIXME XXX comment.  There are about 35-40 things left to fix
+	FIXME comment.  There are about 35-40 things left to fix
 	in this file.
 
 Thu Nov 19 00:25:16 1992  John W. Eaton  (jwe@schoch.che.utexas.edu)
 
 	* Version 0.46.
 	[ This one wasn't tested, but there have been a lot of significant
 	changes and I wanted a backup. ]
 
diff --git a/aclocal.m4 b/aclocal.m4
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -585,25 +585,25 @@ EOF
       if test "`${NM-nm} conftest.o | grep _FSmy_dld_fcn`" != ""; then
         octave_cv_cxx_prepends_underscore=yes
       fi
     else
       echo "configure: failed program was:" >&AS_MESSAGE_LOG_FD
       cat conftest.$ac_ext >&AS_MESSAGE_LOG_FD
     fi
     AC_LANG_POP(C++)
-### XXX FIXME XXX -- Ignore test result on Windows.  Yes it prepends
+### FIXME -- Ignore test result on Windows.  Yes it prepends
 ### underscore, but LoadLibrary ignores it automatically.  The
 ### correct test is to build the shared library then try to grab the
 ### symbol from it with and without underscore.
     case "$canonical_host_type" in
       *-*-cygwin* | *-*-mingw*)
         octave_cv_cxx_prepends_underscore=no
       ;;
-### XXX FIXME XXX -- Ignore test result on OS X.  Yes it prepends
+### FIXME -- Ignore test result on OS X.  Yes it prepends
 ### underscore, but also messes with the name so test fails (incorrectly).
       *-*-darwin*)
         octave_cv_cxx_prepends_underscore=yes
       ;;
     esac
   ])
   AC_MSG_RESULT($octave_cv_cxx_prepends_underscore)
   if test $octave_cv_cxx_prepends_underscore = yes; then
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.507 $)
+AC_REVISION($Revision: 1.508 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -660,17 +660,17 @@ if $have_fortran_compiler; then
 
 pic/%.o : %.f
 	$(FC) -c $(FPICFLAG) $(ALL_FFLAGS) $< -o $@
 
 EOF
 elif $have_f2c; then
   AC_DEFINE(HAVE_F2C, 1, [Define if we are using f2c.])
 
-### XXX FIMXE XXX -- these shouldn't be fixed names, eh?
+### FIXME -- these shouldn't be fixed names, eh?
 
   oct_conflib=libconflib.a
   oct_obj_ext=o
 
   CONFLIB_ARG=
   if AC_TRY_EVAL(ac_compile); then
     $AR $ARFLAGS $oct_conflib conftest.$oct_obj_ext 1>&AS_MESSAGE_LOG_FD()
     if test -n "$RANLIB"; then
diff --git a/doc/interpreter/Makefile.in b/doc/interpreter/Makefile.in
--- a/doc/interpreter/Makefile.in
+++ b/doc/interpreter/Makefile.in
@@ -40,17 +40,17 @@ SUB_TEXINFO := $(SUB_SOURCE:.txi=.texi)
 TEXINFO := $(MAIN_TEXINFO) $(SUB_TEXINFO) ../conf.texi
 
 FORMATTED = octave.dvi octave.ps octave.pdf \
 	octave.info octave.info-[0-9]*
 
 MAN_BASE := mkoctfile octave octave-bug octave-config
 MAN_SRC := $(addsuffix .1, $(MAN_BASE))
 
-# XXX FIXME XXX -- need to include generated figures here...
+# FIXME -- need to include generated figures here...
 DISTFILES = Makefile.in dir munge-texi.cc $(MAN_SRC) \
   $(SOURCES) $(TEXINFO) $(FORMATTED)
 
 DISTDIRS = HTML
 
 DISTSUBDIRS = $(IMAGEDIR)
 
 # Look for version.h to get version information.
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -574,17 +574,17 @@ re-running chunks of commands from the h
 
 @DOCSTRING(history_size)
 
 @DOCSTRING(saving_history)
 
 @node Customizing readline
 @subsection Customizing @code{readline}
 
-@c XXX FIXME XXX -- need a brief description of the ~/.inputrc file here.
+@c FIXME -- need a brief description of the ~/.inputrc file here.
 
 @DOCSTRING(read_readline_init_file)
 
 @node Customizing the Prompt
 @subsection Customizing the Prompt
 @cindex prompt customization
 @cindex customizing the prompt
 
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -430,17 +430,17 @@ function files that are distributed with
 
 If you know that your own function files will not change while you are
 running Octave, you can improve performance by setting the variable
 @code{ignore_function_time_stamp} to @code{"all"}, so that Octave will
 ignore the time stamps for all function files.  Setting it to
 @code{"system"} gives the default behavior.  If you set it to anything
 else, Octave will check the time stamps on all function files.
 
-@c XXX FIXME XXX -- note about time stamps on files in NFS environments?
+@c FIXME -- note about time stamps on files in NFS environments?
 
 @DOCSTRING(DEFAULT_LOADPATH)
 
 @DOCSTRING(LOADPATH)
 
 @DOCSTRING(rehash)
 
 @DOCSTRING(file_in_loadpath)
@@ -734,17 +734,17 @@ function when the file that defines it i
 time that the function was loaded.  If more than one function is defined
 in a single @file{.oct} file, reloading the file may force other
 functions to be cleared and reloaded.  If all the functions loaded from
 a given @file{.oct} file are cleared, Octave will automatically unload
 the @file{.oct} file.
 
 @DOCSTRING(warn_reload_forces_clear)
 
-@c XXX FIXME XXX -- is there a better place for this?
+@c FIXME -- is there a better place for this?
 
 @DOCSTRING(variables_can_hide_functions)
 
 Additional examples for writing dynamically linked functions are
 available in the files in the @file{src} directory of the Octave
 distribution.  Currently, this includes the files
 
 @example
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -17,19 +17,19 @@ language.
 
 GNU Octave is also freely redistributable software.  You may
 redistribute it and/or modify it under the terms of the GNU General
 Public License as published by the Free Software Foundation.  The GPL is
 included in this manual in @ref{Copying}.
 
 This document corresponds to Octave version @value{VERSION}.
 
-@c XXX FIXME XXX -- add explanation about how and why Octave was written.
+@c FIXME -- add explanation about how and why Octave was written.
 @c
-@c XXX FIXME XXX -- add a sentence or two explaining that we could
+@c FIXME -- add a sentence or two explaining that we could
 @c                  always use more funding.
 
 @menu
 * Running Octave::              
 * Simple Examples::             
 * Conventions::                 
 @end menu
 
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -36,17 +36,17 @@ variable @code{page_screen_output} to 0.
 @DOCSTRING(PAGER)
 
 @DOCSTRING(page_screen_output)
 
 @DOCSTRING(page_output_immediately)
 
 @DOCSTRING(fflush)
 
-@c XXX FIXME XXX -- maybe this would be a good place to describe the
+@c FIXME -- maybe this would be a good place to describe the
 @c following message:
 @c
 @c warning: connection to external pager (pid = 9334) lost --
 @c warning: pending computations and output may be lost
 @c warning: broken pipe
 
 @menu
 * Basic Input and Output::      
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -61,17 +61,17 @@ 1989, and in @cite{@sc{Lapack} Users' Gu
 @DOCSTRING(qz)
 
 @DOCSTRING(qzhess)
 
 @DOCSTRING(schur)
 
 @DOCSTRING(svd)
 
-@c XXX FIXME XXX -- should there be a new section here?
+@c FIXME -- should there be a new section here?
 
 @DOCSTRING(housh)
 
 @DOCSTRING(krylov)
 
 @node Functions of a Matrix
 @section Functions of a Matrix
 
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -195,21 +195,21 @@ The @code{rand} and @code{randn} functio
 compiled by Barry W. Brown and James Lovato of the Department of
 Biomathematics at The University of Texas, M.D. Anderson Cancer Center,
 Houston, TX 77030.
 
 @DOCSTRING(randperm)
 
 @DOCSTRING(diag)
 
-@c XXX FIXME XXX -- is this really worth documenting?
+@c FIXME -- is this really worth documenting?
 @c
 @c DOCSTRING(warn_imag_to_real)
 @c 
-@c XXX FIXME XXX -- this is here because it is used by @code{ones},
+@c FIXME -- this is here because it is used by @code{ones},
 @c @code{zeros}, @code{rand}, etc.
 
 The functions @code{linspace} and @code{logspace} make it very easy to
 create vectors with evenly or logarithmically spaced elements.
 @xref{Ranges}.
 
 @DOCSTRING(linspace)
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -122,17 +122,17 @@ supports the multiplot feature.
 @DOCSTRING(subwindow)
 
 @node Multiple Plot Windows
 @section Multiple Plot Windows
 
 @DOCSTRING(figure)
 
 @c @node Exporting Plots
-@c XXX FIXME XXX -- add info about getting paper copies of plots.
+@c FIXME -- add info about getting paper copies of plots.
 
 @node Low-Level plotting commands
 @section Low-Level plotting commands
 
 @deffn {Command} gplot @var{ranges} @var{expression} @var{using} @var{title} @var{style}
 Generate a 2-dimensional plot.
 
 The @var{ranges}, @var{using}, @var{title}, and @var{style} arguments
@@ -319,17 +319,17 @@ time something as minor as an axis label
 The command @code{shg} is equivalent to executing @code{replot}.
 @end deffn
 
 @DOCSTRING(automatic_replot)
 
 Note that NaN values in the plot data are automatically omitted, and
 Inf values are converted to a very large value before calling gnuplot.
 
-@c XXX FIXME XXX -- add info about what to do to get plots on remote X
+@c FIXME -- add info about what to do to get plots on remote X
 @c terminals.  People often forget how to properly set DISPLAY and run
 @c xhost.
 
 
 @node Interaction with gnuplot
 @section Interaction with @code{gnuplot}
 
 @DOCSTRING(gnuplot_binary)
diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -32,17 +32,17 @@ please contact @email{bug@@octave.org}.
 @DOCSTRING(freqz)
 
 @DOCSTRING(freqz_plot)
 
 @DOCSTRING(sinc)
 
 @DOCSTRING(unwrap)
 
-@c XXX FIXME XXX -- someone needs to organize these...
+@c FIXME -- someone needs to organize these...
 
 @DOCSTRING(arch_fit)
 
 @DOCSTRING(arch_rnd)
 
 @DOCSTRING(arch_test)
 
 @DOCSTRING(arma_rnd)
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -30,17 +30,17 @@ you would like to help improve Octave in
 @DOCSTRING(corrcoef)
 
 @DOCSTRING(kurtosis)
 
 @DOCSTRING(mahalanobis)
 
 @DOCSTRING(skewness)
 
-@c XXX FIXME XXX -- these need to be organized.
+@c FIXME -- these need to be organized.
 
 @DOCSTRING(values)
 
 @DOCSTRING(var)
 
 @DOCSTRING(table)
 
 @DOCSTRING(studentize)
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -23,17 +23,17 @@ following expressions
 @noindent
 represent the string whose contents are @samp{parrot}.  Strings in
 Octave can be of any length.
 
 Since the single-quote mark is also used for the transpose operator
 (@pxref{Arithmetic Ops}) but double-quote marks have no other purpose in
 Octave, it is best to use double-quote marks to denote strings.
 
-@c XXX FIXME XXX -- this is probably pretty confusing.
+@c FIXME -- this is probably pretty confusing.
 
 @cindex escape sequence notation
 Some characters cannot be included literally in a string constant.  You
 represent them instead with @dfn{escape sequences}, which are character
 sequences beginning with a backslash (@samp{\}).
 
 One use of an escape sequence is to include a double-quote
 (single-quote) character in a string constant that has been defined
diff --git a/libcruft/Makefile.in b/libcruft/Makefile.in
--- a/libcruft/Makefile.in
+++ b/libcruft/Makefile.in
@@ -46,17 +46,17 @@ LINK_DEPS = $(BLAS_LIBS) $(FFTW_LIBS) $(
 
 all: libraries
 .PHONY: all
 
 $(SUBDIRS):
 	$(MAKE) -C $@ all
 .PHONY: $(SUBDIRS)
 
-# XXX FIXME XXX -- this should build the shared library directly from
+# FIXME -- this should build the shared library directly from
 # a normal archive file (created from PIC code, though).
 
 MISC_OBJ := misc/machar.o misc/f77-extern.o \
 	misc/f77-fcn.o misc/lo-error.o misc/quit.o misc/cquit.o
 
 CRUFT_FSRC := $(foreach dir, $(SUBDIRS), $(wildcard $(srcdir)/$(dir)/*.f))
 CRUFT_OBJ2 := $(patsubst $(srcdir)/%, %, $(CRUFT_FSRC))
 CRUFT_OBJ1 := $(patsubst %.f, %.o, $(CRUFT_OBJ2))
diff --git a/libcruft/Makerules.in b/libcruft/Makerules.in
--- a/libcruft/Makerules.in
+++ b/libcruft/Makerules.in
@@ -1,13 +1,13 @@
 # @configure_input@
 #
 # Common rules for octave's libcruft directories.
 #
-# XXX FIXME XXX -- assumes that the libcruft directory tree is only
+# FIXME -- assumes that the libcruft directory tree is only
 # one level deep.
 #
 # John W. Eaton
 # jwe@bevo.che.wisc.edu
 # University of Wisconsin-Madison
 # Department of Chemical Engineering
 
 SOURCES = *.f
diff --git a/libcruft/misc/cquit.c b/libcruft/misc/cquit.c
--- a/libcruft/misc/cquit.c
+++ b/libcruft/misc/cquit.c
@@ -41,17 +41,17 @@ octave_save_current_context (void *save_
 void
 octave_restore_current_context (void *save_buf)
 {
   memcpy (current_context, save_buf, sizeof (octave_jmp_buf));
 }
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
 
-/* XXX FIXME XXX -- eventually remove the debugging */
+/* FIXME -- eventually remove the debugging */
 #if defined (DEBUG)
 
 #define PRINT_CURRENT_THREAD() printf ("%lx: ", GetCurrentThreadId ())
 
 #define DEBUGs(s) \
   do \
     { \
       PRINT_CURRENT_THREAD (); \
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -96,17 +96,17 @@ extern int f77_exception_encountered;
   octave_make_cray_const_ftn_ch_dsc (x.c_str (), x.length ())
 #define F77_CHAR_ARG_LEN(l)
 #define F77_CHAR_ARG_DECL octave_cray_ftn_ch_dsc
 #define F77_CONST_CHAR_ARG_DECL octave_cray_ftn_ch_dsc
 #define F77_CHAR_ARG_LEN_DECL
 #define F77_RET_T int
 #define F77_RETURN(retval) return retval;
 
-/* XXX FIXME XXX -- these should work for SV1 or Y-MP systems but will
+/* FIXME -- these should work for SV1 or Y-MP systems but will
    need to be changed for others.  */
 
 typedef union
 {
   const char *const_ptr;
   char *ptr;
   struct
   {
diff --git a/libcruft/misc/machar.c b/libcruft/misc/machar.c
--- a/libcruft/misc/machar.c
+++ b/libcruft/misc/machar.c
@@ -369,17 +369,17 @@ rmachar(int *ibeta, int *it, int *irnd, 
 #ifndef TEST
 
 F77_RET_T
 F77_FUNC (machar, MACHAR) (REAL *xmin, REAL *xmax, REAL *epsneg,
 			   REAL *eps, REAL *log10_ibeta)
 {
 #if defined (_CRAY)
 
-  // XXX FIXME XXX -- make machar work for the Cray too.
+  // FIXME -- make machar work for the Cray too.
 
   int ibeta = FLT_RADIX;
   *xmin = DBL_MIN;
   *xmax = DBL_MAX;
   *epsneg = DBL_EPSILON;
   *eps = DBL_EPSILON;
 
 #else
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -371,17 +371,17 @@ get_ra_idx (octave_idx_type idx, const d
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
   for (octave_idx_type i = 0; i < idx; i++)
     increment_index (retval, dims);
 
-  // XXX FIXME XXX -- the solution using increment_index is not
+  // FIXME -- the solution using increment_index is not
   // efficient.
 
 #if 0
   octave_idx_type var = 1;
   for (int i = 0; i < n_dims; i++)
     {
       std::cout << "idx: " << idx << ", var: " << var << ", dims(" << i << "): " << dims(i) <<"\n";
       retval(i) = ((int)floor(((idx) / (double)var))) % dims(i);
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -105,17 +105,17 @@ Array<T>::squeeze (void) const
 	      break;
 
 	    default:
 	      new_dimensions.resize (k);
 	      break;
 	    }
 	}
 
-      // XXX FIXME XXX -- it would be better if we did not have to do
+      // FIXME -- it would be better if we did not have to do
       // this, so we could share the data while still having different
       // dimension vectors.
 
       retval.make_unique ();
 
       retval.dimensions = new_dimensions;
     }
 
@@ -124,17 +124,17 @@ Array<T>::squeeze (void) const
 
 // A guess (should be quite conservative).
 #define MALLOC_OVERHEAD 1024
 
 template <class T>
 octave_idx_type
 Array<T>::get_size (octave_idx_type r, octave_idx_type c)
 {
-  // XXX KLUGE XXX
+  // KLUGE
 
   // If an allocation of an array with r * c elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
@@ -164,17 +164,17 @@ Array<T>::get_size (octave_idx_type r, o
 	// if (r*c) below limit, then return r*c, otherwise return TOO BIG num!
   return (nt < nl || (nt == nl && dt < dl)) ? r * c : max_items;
 }
 
 template <class T>
 octave_idx_type
 Array<T>::get_size (octave_idx_type r, octave_idx_type c, octave_idx_type p)
 {
-  // XXX KLUGE XXX
+  // KLUGE
 
   // If an allocation of an array with r * c * p elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
@@ -210,17 +210,17 @@ Array<T>::get_size (octave_idx_type r, o
 
   return (nt < nl || (nt == nl && dt < dl)) ? r * c * p : max_items;
 }
 
 template <class T>
 octave_idx_type
 Array<T>::get_size (const dim_vector& ra_idx)
 {
-  // XXX KLUGE XXX
+  // KLUGE
 
   // If an allocation of an array with r * c elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
@@ -486,17 +486,17 @@ Array<T>::permute (const Array<octave_id
       else
 	checked.elem(perm_elt) = true;
 
       dv_new(i) = dv(perm_elt);
     }
 
   int nd = dv.length ();
 
-  // XXX FIXME XXX -- it would be nice to have a sort method in the
+  // FIXME -- it would be nice to have a sort method in the
   // Array class that also returns the sort indices.
 
   if (inv)
     {
       OCTAVE_LOCAL_BUFFER (permute_vector, pvec, nd);
 
       for (int i = 0; i < nd; i++)
 	{
@@ -913,17 +913,17 @@ Array<T>::resize_and_fill (octave_idx_ty
       octave_idx_type min_p = old_d3 < p ? old_d3 : p;
 
       if (old_data && old_len > 0)
 	for (octave_idx_type k = 0; k < min_p; k++)
 	  for (octave_idx_type j = 0; j < min_c; j++)
 	    for (octave_idx_type i = 0; i < min_r; i++)
 	      xelem (i, j, k) = old_data[old_d1*(old_d2*k+j)+i];
 
-      // XXX FIXME XXX -- if the copy constructor is expensive, this
+      // FIXME -- if the copy constructor is expensive, this
       // may win.  Otherwise, it may make more sense to just copy the
       // value everywhere when making the new ArrayRep.
 
       for (octave_idx_type k = 0; k < min_p; k++)
 	for (octave_idx_type j = min_c; j < c; j++)
 	  for (octave_idx_type i = 0; i < min_r; i++)
 	    xelem (i, j, k) = val;
 
@@ -2445,17 +2445,17 @@ Array<T>::index (Array<idx_vector>& ra_i
 
 	    }
 	}
     }
 
   return retval;
 }
 
-// XXX FIXME XXX -- this is a mess.
+// FIXME -- this is a mess.
 
 template <class LT, class RT>
 int
 assign (Array<LT>& lhs, const Array<RT>& rhs, const LT& rfv)
 {
   int retval = 0;
 
   switch (lhs.ndims ())
@@ -2608,17 +2608,17 @@ assign2 (Array<LT>& lhs, const Array<RT>
     {
       xrhs = xrhs.squeeze ();
 
       dim_vector dv_tmp = xrhs.dims ();
 
       switch (dv_tmp.length ())
 	{
 	case 1:
-	  // XXX FIXME XXX -- this case should be unnecessary, because
+	  // FIXME -- this case should be unnecessary, because
 	  // squeeze should always return an object with 2 dimensions.
 	  if (rhs_nr == 1)
 	    rhs_nc = dv_tmp.elem (0);
 	  break;
 
 	case 2:
 	  rhs_nr = dv_tmp.elem (0);
 	  rhs_nc = dv_tmp.elem (1);
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -297,17 +297,17 @@ public:
   T xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return xelem (i, dim2()*k+j); }
 
   T& xelem (const Array<int>& ra_idx)
     { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<int>& ra_idx) const
     { return xelem (compute_index (ra_idx)); }
 
-  // XXX FIXME XXX -- would be nice to fix this so that we don't
+  // FIXME -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= rep->length ())
 	return range_error ("T& Array<T>::checkelem", n);
       else
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -25,17 +25,17 @@ 02110-1301, USA.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 
 #include <iostream>
 
-// XXX FIXME XXX
+// FIXME
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #include "Array-util.h"
 #include "CMatrix.h"
 #include "CmplxAEPBAL.h"
 #include "CmplxDET.h"
@@ -196,17 +196,17 @@ ComplexMatrix::ComplexMatrix (const Comp
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-// XXX FIXME XXX -- could we use a templated mixed-type copy function
+// FIXME -- could we use a templated mixed-type copy function
 // here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
@@ -2062,17 +2062,17 @@ ComplexMatrix::expm (void) const
   // code follows development in AEPBAL
 
   Complex *mp = m.fortran_vec ();
 
   octave_idx_type info, ilo, ihi,ilos,ihis;
   Array<double> dpermute (nc);
   Array<double> dscale (nc);
 
-  // XXX FIXME XXX -- should pass job as a parameter in expm
+  // FIXME -- should pass job as a parameter in expm
 
   // Permute first
   char job = 'P';
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nc, mp, nc, ilo, ihi,
 			     dpermute.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)));
 
@@ -2576,17 +2576,17 @@ ComplexMatrix::too_large_for_float (void
 	    || (! (xisnan (i_val) || xisinf (i_val))
 		&& fabs (i_val) > FLT_MAX))
 	  return true;
       }
 
   return false;
 }
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 ComplexMatrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
 
@@ -3095,17 +3095,17 @@ Givens (const Complex& x, const Complex&
 }
 
 ComplexMatrix
 Sylvester (const ComplexMatrix& a, const ComplexMatrix& b,
 	   const ComplexMatrix& c)
 {
   ComplexMatrix retval;
 
-  // XXX FIXME XXX -- need to check that a, b, and c are all the same
+  // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
   ComplexSCHUR as (a, "U");
   ComplexSCHUR bs (b, "U");
   
   // Transform c to new coordinates.
@@ -3137,17 +3137,17 @@ Sylvester (const ComplexMatrix& a, const
 			     b_nr, px, a_nr, scale, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in ztrsyl");
   else
     {
-      // XXX FIXME XXX -- check info?
+      // FIXME -- check info?
 
       retval = -ua * cx * ub.hermitian ();
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -3200,17 +3200,17 @@ operator * (const ComplexMatrix& m, cons
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgemm");
 	}
     }
 
   return retval;
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 ComplexMatrix
 min (const Complex& c, const ComplexMatrix& m)
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -489,17 +489,17 @@ ComplexNDArray::operator ! (void) const
   boolNDArray b (dims ());
 
   for (octave_idx_type i = 0; i < length (); i++)
     b.elem (i) = elem (i) == 0.0;
 
   return b;
 }
 
-// XXX FIXME XXX -- this is not quite the right thing.
+// FIXME -- this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
@@ -1021,17 +1021,17 @@ operator >> (std::istream& is, ComplexND
 	  }
     }
 
  done:
 
   return is;
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nel == 0)	\
     return T (dv);
 
 ComplexNDArray
 min (const Complex& c, const ComplexNDArray& m)
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -53,17 +53,17 @@ public:
       MArrayN<Complex>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
-  // XXX FIXME XXX -- this is not quite the right thing.
+  // FIXME -- this is not quite the right thing.
 
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7550,17 +7550,17 @@ SparseComplexMatrix::too_large_for_float
 	    || r_val < FLT_MIN
 	    || i_val < FLT_MIN)
 	  return true;
     }
 
   return false;
 }
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 SparseBoolMatrix
 SparseComplexMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
@@ -7835,17 +7835,17 @@ operator * (const SparseMatrix& m, const
 }
 
 ComplexMatrix
 operator * (const SparseComplexMatrix& m, const ComplexMatrix& a)
 {
   SPARSE_FULL_MUL (ComplexMatrix, Complex, Complex (0.,0.));
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseComplexMatrix
 min (const Complex& c, const SparseComplexMatrix& m)
diff --git a/liboctave/CmplxDET.h b/liboctave/CmplxDET.h
--- a/liboctave/CmplxDET.h
+++ b/liboctave/CmplxDET.h
@@ -23,17 +23,17 @@ 02110-1301, USA.
 
 #if !defined (octave_ComplexDET_h)
 #define octave_ComplexDET_h 1
 
 #include <iostream>
 
 #include "oct-cmplx.h"
 
-// XXX FIXME XXX -- we could use templates here; compare with dbleDET.h
+// FIXME -- we could use templates here; compare with dbleDET.h
 
 class
 ComplexDET
 {
 friend class ComplexMatrix;
 friend class SparseComplexMatrix;
 
 public:
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -119,17 +119,17 @@ ddaspk_psol (const octave_idx_type&, con
 
 
 static octave_idx_type
 ddaspk_j (const double& time, const double *state, const double *deriv,
 	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // XXX FIXME XXX -- would be nice to avoid copying the data.
+  // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
@@ -144,17 +144,17 @@ ddaspk_j (const double& time, const doub
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
 {
-  // XXX FIXME XXX -- should handle all this option stuff just once
+  // FIXME -- should handle all this option stuff just once
   // for each new problem.
 
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASPK_options::reset)
     {
       integration_error = false;
 
@@ -343,17 +343,17 @@ DASPK::do_integrate (double tout)
 	  integration_error = true;
 	  return retval;
 	}
 
       if (ccic)
 	{
 	  if (ccic == 1)
 	    {
-	      // XXX FIXME XXX -- this code is duplicated below.
+	      // FIXME -- this code is duplicated below.
 
 	      Array<octave_idx_type> av = algebraic_variables ();
 
 	      if (av.length () == n)
 		{
 		  octave_idx_type lid;
 		  if (eiq == 0 || eiq == 2)
 		    lid = 40;
@@ -383,17 +383,17 @@ DASPK::do_integrate (double tout)
 
 	  info(10) = ccic;
 	}
 
       if (eavfet)
 	{
 	  info(15) = 1;
 
-	  // XXX FIXME XXX -- this code is duplicated above.
+	  // FIXME -- this code is duplicated above.
 
 	  Array<octave_idx_type> av = algebraic_variables ();
 
 	  if (av.length () == n)
 	    {
 	      octave_idx_type lid;
 	      if (eiq == 0 || eiq == 2)
 		lid = 40;
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -92,17 +92,17 @@ ddasrt_f (const double& t, const double 
 }
 
 octave_idx_type
 ddasrt_j (const double& time, const double *state, const double *deriv,
 	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // XXX FIXME XXX -- would be nice to avoid copying the data.
+  // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -58,17 +58,17 @@ static DAEFunc::DAEJacFunc user_jac;
 static octave_idx_type nn;
 
 static octave_idx_type
 ddassl_f (const double& time, const double *state, const double *deriv,
 	  double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // XXX FIXME XXX -- would be nice to avoid copying the data.
+  // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
@@ -94,17 +94,17 @@ ddassl_f (const double& time, const doub
 }
 
 static octave_idx_type
 ddassl_j (const double& time, const double *state, const double *deriv,
 	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // XXX FIXME XXX -- would be nice to avoid copying the data.
+  // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -85,17 +85,17 @@ private:
 	  {
 	    static T foo;
 	    return foo;
 	  }
       }
 
   private:
 
-    // XXX FIXME XXX -- this is declared private to keep the user from
+    // FIXME -- this is declared private to keep the user from
     // taking the address of a Proxy.  Maybe it should be implemented
     // by means of a companion function in the DiagArray2 class.
 
     T *operator& () const { assert (0); return 0; }
 
     octave_idx_type i;
     octave_idx_type j;
 
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -28,17 +28,17 @@ 02110-1301, USA.
 #include "Quad.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "quit.h"
 #include "sun-utils.h"
 
 static integrand_fcn user_fcn;
 
-// XXX FIXME XXX -- would be nice to not have to have this global
+// FIXME -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 typedef octave_idx_type (*quad_fcn_ptr) (double*, int&, double*);
 			      
 extern "C"
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -31,17 +31,17 @@ 02110-1301, USA.
 
 #if !defined (octave_Quad_typedefs)
 #define octave_Quad_typedefs 1
 
 typedef double (*integrand_fcn) (double x);
 
 #endif
 
-// XXX FIXME XXX -- would be nice to not have to have this global
+// FIXME -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 extern int quad_integration_error;
 
 #include "Quad-opts.h"
 
 class
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -611,17 +611,17 @@ Boston, MA 02110-1301, USA.
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
-        /* XXX FIXME XXX Kludge... Always double/Complex, so Complex () */ \
+        /* FIXME Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
@@ -661,17 +661,17 @@ Boston, MA 02110-1301, USA.
 	r.maybe_compress (true); \
       } \
  \
     return r; \
   }
 
 // Note that SM ./ SM needs to take into account the NaN and Inf values
 // implied by the division by zero.
-// XXX FIXME XXX Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex
+// FIXME Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex
 // case?
 #define SPARSE_SMSM_BIN_OPS(R1, R2, M1, M2)  \
   SPARSE_SMSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_SMSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_SMSM_BIN_OP_2 (R2, product,     *, M1, M2) \
   SPARSE_SMSM_BIN_OP_3 (R2, quotient,    /, M1, M2)
 
 #define SPARSE_SMSM_CMP_OP_DECLS(M1, M2) \
@@ -888,17 +888,17 @@ Boston, MA 02110-1301, USA.
 	      } \
 	    r.cidx(j+1) = ii; \
 	  } \
       } \
  \
     return r; \
   }
 
-// XXX FIXME XXX Pass a specific ZERO value
+// FIXME Pass a specific ZERO value
 #define SPARSE_MSM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_MSM_BIN_OP_2 (R2, product,     *, M1, M2, 0.0) \
   SPARSE_MSM_BIN_OP_2 (R2, quotient,    /, M1, M2, 0.0)
 
 #define SPARSE_MSM_CMP_OP_DECLS(M1, M2) \
   SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2); \
@@ -1114,17 +1114,17 @@ Boston, MA 02110-1301, USA.
 	      } \
 	    r.cidx(j+1) = ii; \
 	  } \
       } \
  \
     return r; \
   }
 
-// XXX FIXME XXX Pass a specific ZERO value
+// FIXME Pass a specific ZERO value
 #define SPARSE_SMM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_SMM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_SMM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_SMM_BIN_OP_2 (R2, product,     *, M1, M2, 0.0) \
   SPARSE_SMM_BIN_OP_2 (R2, quotient,    /, M1, M2, 0.0)
 
 #define SPARSE_SMM_CMP_OP_DECLS(M1, M2) \
   SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2); \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1992,17 +1992,17 @@ Sparse<T>::index (Array<idx_vector>& ra_
     {
       (*current_liboctave_error_handler) ("range error for index");
       return *this;
     }
 
   return index (ra_idx (0), ra_idx (1), resize_ok);
 }
 
-// XXX FIXME XXX
+// FIXME
 // Unfortunately numel can overflow for very large but very sparse matrices.
 // For now just flag an error when this happens.
 template <class LT, class RT>
 int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
 
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -308,17 +308,17 @@ public:
   T xelem (octave_idx_type i, octave_idx_type j) const { return rep->celem (i, j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index (ra_idx)); }
 
-  // XXX FIXME XXX -- would be nice to fix this so that we don't
+  // FIXME -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= numel ())
 	return range_error ("T& Sparse<T>::checkelem", n);
       else
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -74,17 +74,17 @@ SparseComplexQR::SparseComplexQR_rep::~S
 #endif
 }
 
 SparseComplexMatrix 
 SparseComplexQR::SparseComplexQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
-  // XXX FIXME XXX Is the double transpose to sort necessary?
+  // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->L);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->L, 1);
   CXSPARSE_ZNAME (_spfree) (N->L);
   N->L = CXSPARSE_ZNAME (_transpose) (D, 1);
   CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -130,17 +130,17 @@ SparseComplexQR::SparseComplexQR_rep::P 
 #endif
 }
 
 SparseComplexMatrix 
 SparseComplexQR::SparseComplexQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
-  // XXX FIXME XXX Is the double transpose to sort necessary?
+  // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->U);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->U, 1);
   CXSPARSE_ZNAME (_spfree) (N->U);
   N->U = CXSPARSE_ZNAME (_transpose) (D, 1);
   CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -63,17 +63,17 @@ SparseQR::SparseQR_rep::~SparseQR_rep (v
 #endif
 }
 
 SparseMatrix 
 SparseQR::SparseQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
-  // XXX FIXME XXX Is the double transpose to sort necessary?
+  // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->L);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->L, 1);
   CXSPARSE_DNAME (_spfree) (N->L);
   N->L = CXSPARSE_DNAME (_transpose) (D, 1);
   CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -119,17 +119,17 @@ SparseQR::SparseQR_rep::P (void) const
 #endif
 }
 
 SparseMatrix 
 SparseQR::SparseQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
-  // XXX FIXME XXX Is the double transpose to sort necessary?
+  // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->U);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->U, 1);
   CXSPARSE_DNAME (_spfree) (N->U);
   N->U = CXSPARSE_DNAME (_transpose) (D, 1);
   CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -26,17 +26,17 @@ Boston, MA 02110-1301, USA.
 
 #include <vector>
 
 #include "SparseType.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 
-// XXX FIXME XXX There is a large code duplication here
+// FIXME There is a large code duplication here
 
 SparseType::SparseType (void) : typ (SparseType::Unknown), nperm (0)
 {
   sp_bandden = Voctave_sparse_controls.get_key ("bandden");
 } 
 
 SparseType::SparseType (const SparseType &a) : typ (a.typ), 
     sp_bandden (a.sp_bandden), bandden (a.bandden), 
@@ -182,17 +182,17 @@ SparseType::SparseType (const SparseMatr
 	    maybe_hermitian = true;
 	}
 
       if (typ == SparseType::Full)
 	{
 	  // Search for a permuted triangular matrix, and test if
 	  // permutation is singular
 
-	  // XXX FIXME XXX
+	  // FIXME
 	  // Perhaps this should be based on a dmperm algorithm
 	  bool found = false;
 
 	  nperm = ncols;
 	  perm = new octave_idx_type [ncols];
 
 	  for (octave_idx_type i = 0; i < ncols; i++)
 	    perm [i] = -1;
@@ -286,17 +286,17 @@ SparseType::SparseType (const SparseMatr
 	    }
 	  else
 	    {
 	      delete [] perm;
 	      nperm = 0;
 	    }
 	}
 
-      // XXX FIXME XXX
+      // FIXME
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
 	   && nrows > ncols) ||
 	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
 	   && nrows < ncols))
 	{
@@ -507,17 +507,17 @@ SparseType::SparseType (const SparseComp
 	    maybe_hermitian = true;
 	}
 
       if (typ == SparseType::Full)
 	{
 	  // Search for a permuted triangular matrix, and test if
 	  // permutation is singular
 
-	  // XXX FIXME XXX
+	  // FIXME
 	  // Perhaps this should be based on a dmperm algorithm
 	  bool found = false;
 
 	  nperm = ncols;
 	  perm = new octave_idx_type [ncols];
 
 	  for (octave_idx_type i = 0; i < ncols; i++)
 	    perm [i] = -1;
@@ -611,17 +611,17 @@ SparseType::SparseType (const SparseComp
 	    }
 	  else
 	    {
 	      delete [] perm;
 	      nperm = 0;
 	    }
 	}
 
-      // XXX FIXME XXX
+      // FIXME
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
 	   && nrows > ncols) ||
 	  ((typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
 	   && nrows < ncols))
 	{
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -72,17 +72,17 @@ boolMatrix::operator ! (void) const
     for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
 // other operations
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 boolMatrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
 
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -39,17 +39,17 @@ boolNDArray::operator ! (void) const
   boolNDArray b (dims ());
 
   for (octave_idx_type i = 0; i < length (); i++)
     b.elem (i) = ! elem (i);
 
   return b;
 }
 
-// XXX FIXME XXX -- this is not quite the right thing.
+// FIXME -- this is not quite the right thing.
 
 boolNDArray
 boolNDArray::all (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (MX_ND_ALL_EXPR), true);
 }
 
 boolNDArray
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -57,17 +57,17 @@ public:
       ArrayN<bool>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
-  // XXX FIXME XXX -- this is not quite the right thing.
+  // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   boolNDArray concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   boolNDArray& insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c);
   boolNDArray& insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx);
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -111,17 +111,17 @@ SparseBoolMatrix::operator ! (void) cons
       r.cidx (i) = ii;
     }
 
   return r;
 }
 
 // other operations
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 SparseBoolMatrix
 SparseBoolMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
diff --git a/liboctave/byte-swap.h b/liboctave/byte-swap.h
--- a/liboctave/byte-swap.h
+++ b/liboctave/byte-swap.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */
 
 #if !defined (octave_byte_swap_h)
 #define octave_byte_swap_h 1
 
-// XXX FIXME XXX -- not sure these volatile qualifiers are really
+// FIXME -- not sure these volatile qualifiers are really
 // needed or appropriate here.
 
 static inline void
 swap_bytes (volatile void *ptr, unsigned int i, unsigned int j)
 {
   volatile char *t = static_cast<volatile char *> (ptr);
 
   char tmp = t[i];
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -184,17 +184,17 @@ charMatrix::extract (octave_idx_type r1,
 
   for (octave_idx_type j = 0; j < new_c; j++)
     for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 charMatrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
 
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -27,17 +27,17 @@ 02110-1301, USA.
 #endif
 
 #include "Array-util.h"
 #include "chNDArray.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
-// XXX FIXME XXX -- this is not quite the right thing.
+// FIXME -- this is not quite the right thing.
 
 boolNDArray
 charNDArray::all (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (elem (iter_idx) == ' '), true);
 }
 
 boolNDArray
@@ -73,17 +73,17 @@ charNDArray::concat (const NDArray& rb, 
 	    ("invalid conversion from NaN to character");
 	  return *this;
 	}
       else
 	{
 	  octave_idx_type ival = NINTbig (d);
 
 	  if (ival < 0 || ival > UCHAR_MAX)
-	    // XXX FIXME XXX -- is there something
+	    // FIXME -- is there something
 	    // better we could do? Should we warn the user?
 	    ival = 0;
 
 	  tmp.elem (i) = static_cast<char>(ival);
 	}
     }
 
   insert (tmp, ra_idx);
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -56,17 +56,17 @@ public:
   charNDArray (const ArrayN<char>& a) : MArrayN<char> (a) { }
 
   charNDArray& operator = (const charNDArray& a)
     {
       MArrayN<char>::operator = (a);
       return *this;
     }
 
-  // XXX FIXME XXX -- this is not quite the right thing.
+  // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
   charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -147,17 +147,17 @@ private:
 
   static char **command_completer (const char *text, int start, int end);
 };
 
 gnu_readline::gnu_readline ()
   : command_editor (), previous_startup_hook (0),
     previous_event_hook (0), completion_function (0)
 {
-  // XXX FIXME XXX -- need interface to rl_add_defun, rl_initialize, and
+  // FIXME -- need interface to rl_add_defun, rl_initialize, and
   // a function to set rl_terminal_name
 
   std::string term = octave_env::getenv ("TERM");
 
   octave_rl_set_terminal_name (term.c_str ());
 
   octave_rl_initialize ();
 
@@ -564,30 +564,30 @@ FILE *
 default_command_editor::do_get_output_stream (void)
 {
   return output_stream;
 }
 
 string_vector
 default_command_editor::do_generate_filename_completions (const std::string&)
 {
-  // XXX FIXME XXX
+  // FIXME
   return string_vector ();
 }
 
 void
 default_command_editor::do_insert_text (const std::string&)
 {
-  // XXX FIXME XXX
+  // FIXME
 }
 
 void
 default_command_editor::do_newline (void)
 {
-  // XXX FIXME XXX
+  // FIXME
 }
 
 bool
 command_editor::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -200,17 +200,17 @@ gnu_history::do_goto_mark (void)
 	  command_editor::insert_text (line);
 
 	  command_editor::clear_undo_list ();
 	}
     }
 
   mark = 0;
 
-  // XXX FIXME XXX -- for operate_and_get_next.
+  // FIXME -- for operate_and_get_next.
   command_editor::restore_startup_hook ();
 
   return 0;
 }
 
 void
 gnu_history::do_read (const std::string& f, bool must_exist)
 {
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -161,17 +161,17 @@ Matrix::Matrix (const ColumnVector& cv)
 
 Matrix::Matrix (const DiagMatrix& a)
   : MArray2<double> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-// XXX FIXME XXX -- could we use a templated mixed-type copy function
+// FIXME -- could we use a templated mixed-type copy function
 // here?
 
 Matrix::Matrix (const boolMatrix& a)
   : MArray2<double> (a.rows (), a.cols ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
@@ -2081,17 +2081,17 @@ Matrix::too_large_for_float (void) const
       if (! (xisnan (val) || xisinf (val))
 	  && fabs (val) > FLT_MAX)
 	return true;
     }
 
   return false;
 }
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 Matrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
 
@@ -2483,17 +2483,17 @@ Givens (double x, double y)
   return g;
 }
 
 Matrix
 Sylvester (const Matrix& a, const Matrix& b, const Matrix& c)
 {
   Matrix retval;
 
-  // XXX FIXME XXX -- need to check that a, b, and c are all the same
+  // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions.
 
   SCHUR as (a, "U");
   SCHUR bs (b, "U");
   
   // Transform c to new coordinates.
@@ -2526,17 +2526,17 @@ Sylvester (const Matrix& a, const Matrix
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dtrsyl");
   else
     {
-      // XXX FIXME XXX -- check info?
+      // FIXME -- check info?
   
       retval = -ua*cx*ub.transpose ();
     }
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
@@ -2577,17 +2577,17 @@ operator * (const Matrix& m, const Matri
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgemm");
 	}
     }
 
   return retval;
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 Matrix
 min (double d, const Matrix& m)
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -592,17 +592,17 @@ NDArray::too_large_for_float (void) cons
       if (! (xisnan (val) || xisinf (val))
 	  && fabs (val) > FLT_MAX)
 	return true;
     }
 
   return false;
 }
 
-// XXX FIXME XXX -- this is not quite the right thing.
+// FIXME -- this is not quite the right thing.
 
 boolNDArray
 NDArray::all (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (MX_ND_ALL_EXPR), true);
 }
 
 boolNDArray
@@ -826,17 +826,17 @@ NDArray::concat (const charNDArray& rb, 
 	    ("invalid conversion from NaN to character");
 	  return retval;
 	}
       else
 	{
 	  octave_idx_type ival = NINTbig (d);
 
 	  if (ival < 0 || ival > UCHAR_MAX)
-	    // XXX FIXME XXX -- is there something
+	    // FIXME -- is there something
 	    // better we could do? Should we warn the user?
 	    ival = 0;
 
 	  retval.elem (i) = static_cast<char>(ival);
 	}
     }
 
   if (rb.numel () == 0)
@@ -969,17 +969,17 @@ operator >> (std::istream& is, NDArray& 
 	  }
     }
 
  done:
 
   return is;
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nel == 0)	\
     return T (dv);
 
 NDArray
 min (double d, const NDArray& m)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -63,17 +63,17 @@ public:
   boolNDArray operator ! (void) const;
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
-  // XXX FIXME XXX -- this is not quite the right thing.
+  // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   NDArray cumprod (int dim = -1) const;
   NDArray cumsum (int dim = -1) const;
   NDArray prod (int dim = -1) const;
   NDArray sum (int dim = -1) const;  
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7615,17 +7615,17 @@ SparseMatrix::operator ! (void) const
 	    }
 	}
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
-// XXX FIXME XXX Do these really belong here?  Maybe they should be
+// FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 SparseBoolMatrix
 SparseMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
@@ -7916,17 +7916,17 @@ operator * (const Matrix& m, const Spars
 }
 
 Matrix
 operator * (const SparseMatrix& m, const Matrix& a)
 {
   SPARSE_FULL_MUL (Matrix, double, 0.);
 }
 
-// XXX FIXME XXX -- it would be nice to share code among the min/max
+// FIXME -- it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseMatrix
 min (double d, const SparseMatrix& m)
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -514,19 +514,19 @@ gripe_data_conversion (const char *from,
     ("unable to convert from %s to %s format", from, to);
 }
 
 // But first, some data conversion routines.
 
 // Currently, we only handle conversions for the IEEE types.  To fix
 // that, make more of the following routines work.
 
-// XXX FIXME XXX -- assumes sizeof (Complex) == 8
-// XXX FIXME XXX -- assumes sizeof (double) == 8
-// XXX FIXME XXX -- assumes sizeof (float) == 4
+// FIXME -- assumes sizeof (Complex) == 8
+// FIXME -- assumes sizeof (double) == 8
+// FIXME -- assumes sizeof (float) == 4
 
 static void
 IEEE_big_double_to_IEEE_little_double (void *d, int len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
diff --git a/liboctave/dbleDET.h b/liboctave/dbleDET.h
--- a/liboctave/dbleDET.h
+++ b/liboctave/dbleDET.h
@@ -21,17 +21,17 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_DET_h)
 #define octave_DET_h 1
 
 #include <iostream>
 
-// XXX FIXME XXX -- we could use templates here; compare with CmplxDET.h
+// FIXME -- we could use templates here; compare with CmplxDET.h
 
 class
 DET
 {
 friend class Matrix;
 friend class SparseMatrix;
 
 public:
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -454,17 +454,17 @@ extern int errno;
 	{
 	  retval = resolved;
 	  break;
 	}
     }
 
 #else
 
-  // XXX FIXME XXX -- provide replacement here...
+  // FIXME -- provide replacement here...
   retval = name;
 
 #endif
 
   if (retval.empty ())
     {
       using namespace std;
       msg = ::strerror (errno);
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -41,17 +41,17 @@ 02110-1301, USA.
 #if !defined (HAVE_LSTAT)
 static inline int
 lstat (const char *name, struct stat *buf)
 {
   return stat (name, buf);
 }
 #endif
 
-// XXX FIXME XXX -- the is_* and mode_as_string functions are only valid
+// FIXME -- the is_* and mode_as_string functions are only valid
 // for initialized objects.  If called for an object that is not
 // initialized, they should throw an exception.
 
 bool
 file_stat::is_blk (void) const
 {
   return is_blk (fs_mode);
 }
diff --git a/liboctave/glob-match.cc b/liboctave/glob-match.cc
--- a/liboctave/glob-match.cc
+++ b/liboctave/glob-match.cc
@@ -101,17 +101,17 @@ glob_match::glob (void)
 	  int err = ::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
 	  if (! err)
 	    {
 	      int n = glob_info.gl_pathc;
 
 	      const char * const *matches = glob_info.gl_pathv;
 
-	      // XXX FIXME XXX -- we shouldn't have to check to see if
+	      // FIXME -- we shouldn't have to check to see if
 	      // a single match exists, but it seems that glob() won't
 	      // check for us unless the pattern contains globbing
 	      // characters.  Hmm.
 
 	      if (n > 1
 		  || (n == 1
 		      && single_match_exists (std::string (matches[0]))))
 		{
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -39,17 +39,17 @@ intNDArray<T>::operator ! (void) const
   boolNDArray b (this->dims ());
 
   for (octave_idx_type i = 0; i < this->length (); i++)
     b.elem (i) = ! this->elem (i);
 
   return b;
 }
 
-// XXX FIXME XXX -- this is not quite the right thing.
+// FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (this->elem (iter_idx) == T (0)), true);
 }
 
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -57,17 +57,17 @@ public:
   intNDArray& operator = (const intNDArray<T>& a)
     {
       MArrayN<T>::operator = (a);
       return *this;
     }
 
   boolNDArray operator ! (void) const;
 
-  // XXX FIXME XXX -- this is not quite the right thing.
+  // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray squeeze (void) const
     { return intNDArray<T> (MArrayN<T>::squeeze ()); }
 
   intNDArray transpose (void) const
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -32,17 +32,17 @@ extern "C" {
 extern double octave_Inf;
 
 /* Octave's idea of a missing value.  */
 extern double octave_NA;
 
 /* Octave's idea of not a number.  */
 extern double octave_NaN;
 
-/* XXX FIXME XXX -- this code assumes that a double has twice the
+/* FIXME -- this code assumes that a double has twice the
    number of bits as an int */
 
 extern int lo_ieee_hw;
 extern int lo_ieee_lw;
 
 typedef union
 {
   double value;
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -129,17 +129,17 @@ octave_is_NA (double x)
 bool
 octave_is_NaN_or_NA (double x)
 {
   return lo_ieee_isnan (x);
 }
 
 // (double, double) -> double mappers.
 
-// XXX FIXME XXX -- need to handle NA too?
+// FIXME -- need to handle NA too?
 
 double
 xmin (double x, double y)
 {
   if (x < y)
     return x;
 
   if (y <= x)
@@ -281,17 +281,17 @@ octave_is_NA (const Complex& x)
 bool
 octave_is_NaN_or_NA (const Complex& x)
 {
   return (xisnan (real (x)) || xisnan (imag (x)));
 }
 
 // (complex, complex) -> complex mappers.
 
-// XXX FIXME XXX -- need to handle NA too?
+// FIXME -- need to handle NA too?
 
 Complex
 xmin (const Complex& x, const Complex& y)
 {
   return abs (x) <= abs (y) ? x : (xisnan (x) ? x : y);
 }
 
 Complex
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1229,17 +1229,17 @@ betainc (const NDArray& x, const NDArray
 	retval (i) = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
-// XXX FIXME XXX -- there is still room for improvement here...
+// FIXME -- there is still room for improvement here...
 
 double
 gammainc (double x, double a, bool& err)
 {
   double retval;
 
   err = false;
 
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -43,17 +43,17 @@ 02110-1301, USA.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 
 // Convert X to the nearest integer value.  Should not pass NaN to
 // this function.
 
 // Sometimes you need a large integer, but not always.
-// XXX FIXME-64 XXX -- INT_MAX and INT_MIN are probably not right here.
+// FIXME -- INT_MAX and INT_MIN are probably not right for 64-bits.
 
 octave_idx_type
 NINTbig (double x)
 {
   if (x > INT_MAX)
     return INT_MAX;
   else if (x < INT_MIN)
     return INT_MIN;
@@ -93,17 +93,17 @@ strsave (const char *s)
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
 // This function was adapted from xputenv from Karl Berry's kpathsearch
 // library.
 
-// XXX FIXME XXX -- make this do the right thing if we don't have a
+// FIXME -- make this do the right thing if we don't have a
 // SMART_PUTENV.
 
 void
 octave_putenv (const std::string& name, const std::string& value)
 {
   int new_len = name.length () + value.length () + 2;
 
   char *new_item = static_cast<char*> (malloc (new_len));
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -71,17 +71,17 @@ equiv_compare (const equiv *std, const e
   return 1;
 }
 
 void
 oct_mach_info::init_float_format (void) const
 {
 #if defined (CRAY)
 
-  // XXX FIXME XXX -- this should be determined automatically.
+  // FIXME -- this should be determined automatically.
 
   native_float_fmt = oct_mach_info::flt_fmt_cray;
 
 #else
 
   float_params fp[5];
 
   INIT_FLT_PAR (fp[0], oct_mach_info::flt_fmt_ieee_big_endian,
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -41,17 +41,17 @@ octave_allocator::alloc (size_t size)
 	return 0;
     }
 
   link *tmp = head;
   head = head->next;
   return tmp;
 }
 
-// XXX FIXME XXX -- if we free the last item on the list, shouldn't we
+// FIXME -- if we free the last item on the list, shouldn't we
 // also free the underlying character array used for storage?
 
 void
 octave_allocator::free (void *p, size_t size)
 {
   if (size != item_size)
     ::delete [] (static_cast<char *> (p));
   else
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -168,17 +168,17 @@ octave_env::get_user_name (void)
 
 std::string
 octave_env::get_host_name (void)
 {
   return (instance_ok ())
     ? instance->do_get_host_name () : std::string ();
 }
 
-// XXX FIXME XXX -- this leaves no way to distinguish between a
+// FIXME -- this leaves no way to distinguish between a
 // variable that is not set and one that is set to the empty string.
 // Is this a problem?
 
 std::string
 octave_env::getenv (const std::string& name)
 {
   return (instance_ok ())
     ? instance->do_getenv (name) : std::string ();
@@ -299,17 +299,17 @@ octave_env::do_make_absolute (const std:
   if (current_dir.empty ())
     current_dir = do_getcwd ();
 
   size_t pos = current_dir.length () - 1;
 
   if (! file_ops::is_dir_sep (current_dir[pos]))
     current_dir.append (file_ops::dir_sep_str);
 
-  // XXX FIXME XXX -- this is probably not correct for all systems.
+  // FIXME -- this is probably not correct for all systems.
 
   size_t i = 0;
   size_t slen = s.length ();
 
   while (i < slen)
     {
       if (s[i] == '.')
 	{
@@ -395,33 +395,33 @@ octave_env::do_get_home_directory (void)
     }
 
   return hd;
 }
 
 std::string
 octave_env::do_get_user_name (void) const
 {
-  // XXX FIXME XXX -- is it possible for this to change while Octave
+  // FIXME -- is it possible for this to change while Octave
   // is running?
 
   if (user_name.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (octave_syscalls::getuid ());
 
       user_name = pw ? pw.name () : std::string ("unknown");
     }
 
   return user_name;
 }
 
 std::string
 octave_env::do_get_host_name (void) const
 {
-  // XXX FIXME XXX -- is it possible for this to change while Octave
+  // FIXME -- is it possible for this to change while Octave
   // is running?
 
   if (host_name.empty ())
     {
       char hostname[256];
 
       int status = octave_gethostname (hostname, 255);
 
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -38,17 +38,17 @@ 02110-1301, USA.
 // performance.
 
 // Also note that if FFTW_ESTIMATE is not used the planner in FFTW3
 // destroys the input and output arrays. So with the form of the
 // current code we definitely want FFTW_ESTIMATE!! However, we use any
 // wsidom that is available, either in a FFTW3 system wide file or as
 // supplied by the user.
 
-// XXX FIXME XXX -- if we can ensure 16 byte alignment in Array<T>
+// FIXME -- if we can ensure 16 byte alignment in Array<T>
 // (<T> *data) the FFTW3 can use SIMD instructions for further
 // acceleration.
 
 // Note that it is profitable to store the FFTW3 plans, for small
 // ffts.
 
 class
 octave_fftw_planner
@@ -64,17 +64,17 @@ public:
   fftw_plan create_plan (const int rank, const dim_vector dims, 
 			 octave_idx_type howmany, octave_idx_type stride, octave_idx_type dist, 
 			 const double *in, Complex *out);
 
 private:
 
   int plan_flags;
 
-  // XXX FIXME XXX -- perhaps this should be split into two classes?
+  // FIXME -- perhaps this should be split into two classes?
 
   // Plan for fft and ifft of complex values
   fftw_plan plan[2];
 
   // dist
   octave_idx_type d[2];
 
   // stride
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -186,17 +186,17 @@ octave_group::octave_group (void *p, std
       gr_name = gr->gr_name;
 
 #if defined (HAVE_GR_PASSWD)
       gr_passwd = gr->gr_passwd;
 #endif
 
       gr_gid = gr->gr_gid;
 
-      // XXX FIXME XXX -- maybe there should be a string_vector
+      // FIXME -- maybe there should be a string_vector
       // constructor that takes a NULL terminated list of C
       // strings.
 
       const char * const *tmp = gr->gr_mem;
 
       int k = 0;
       while (*tmp++)
 	k++;
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -71,17 +71,17 @@ octave_rl_enable_paren_matching (int val
 
 /* It would be much simpler if we could just call _rl_clear_screen to
    only clear the screen, but it is not a public function, and on some
    systems, it is not exported from shared library versions of
    readline, so we can't use it.
 
    Instead, temporarily redefine the redisplay function to do nothing.
 
-   XXX FIXME XXX -- It would be safer to do this when protected from
+   FIXME -- It would be safer to do this when protected from
    interrupts... */
 
 static void
 flush_stdout (void)
 {
   fflush (stdout);
 }
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -611,17 +611,17 @@ octave_dyld_shlib::open (const std::stri
 		("couldn't link module %s", file.c_str ());	
 	    }
 	}
       else
 	{
 	  (*current_liboctave_error_handler)
 	    ("got NSObjectFileImageReturnCode %d", returnCode);
 
-	  // XXX FIXME XXX -- should use NSLinkEditError () to get
+	  // FIXME -- should use NSLinkEditError () to get
 	  // more info on what went wrong.
 	}
     }
   else
     {
       (*current_liboctave_error_handler)
 	("bundle %s is already open", file.c_str ());
     }
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -130,17 +130,17 @@
 #include <time.h>
 
 #ifdef HAVE_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
 
 #include "randmtzig.h"
    
-/* XXX FIXME XXX may want to suppress X86 if sizeof(long)>4 */
+/* FIXME may want to suppress X86 if sizeof(long)>4 */
 #if !defined(USE_X86_32)
 # if defined(i386) || defined(HAVE_X86_32)
 #  define USE_X86_32 1
 # else
 #  define USE_X86_32 0
 # endif
 #endif
 
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -423,17 +423,17 @@ oct_randp (double L)
       ++em;
       t *= RUNI;
     } while (t > g);
     ret = em;
   } else if (L <= 1e8) {
     /* numerical recipes */
     poisson_rejection(L, &ret, 1);
   } else if (INFINITE(L)) {
-    /* XXX FIXME XXX R uses NaN, but the normal approx. suggests that as
+    /* FIXME R uses NaN, but the normal approx. suggests that as
      * limit should be inf. Which is correct? */
     ret = NAN;
   } else {
     /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
     ret = floor(RNOR*sqrt(L) + L + 0.5);
     if (ret < 0.0) ret = 0.0; /* will probably never happen */
   }
   return ret;
diff --git a/liboctave/so-array.cc b/liboctave/so-array.cc
--- a/liboctave/so-array.cc
+++ b/liboctave/so-array.cc
@@ -24,17 +24,17 @@ 02110-1301, USA.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "ArrayN.h"
 #include "Array-util.h"
-// XXX FIXME XXX -- we are including the MArray{,2,N}.h files just for
+// FIXME -- we are including the MArray{,2,N}.h files just for
 // their gripe_nonconformant function decls.
 #include "MArray.h"
 #include "MArray2.h"
 #include "MArrayN.h"
 #include "MArray-defs.h"
 #include "boolMatrix.h"
 #include "boolNDArray.h"
 #include "mx-op-defs.h"
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -415,17 +415,17 @@ dmsolve (const ST &a, const T &b, octave
 	      nnz_remaining -= m.nnz();
 	      RT ctmp = dmsolve_extract (btmp, NULL, NULL, 0, 
 					 dm->rr[2], 0, b_nc);
 	      btmp.insert (ctmp - m * mtmp, 0, 0);
 	    }
 	}
       
       // Structurally non-singular blocks
-      // XXX FIXME XXX Should use fine Dulmange-Mendelsohn decomposition here.
+      // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && 
 	  !info && !error_state)
 	{
 	  ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
 				  dm->cc [2], dm->cc [3], nnz_remaining, false);
 	  nnz_remaining -= m.nnz();
 	  RT btmp2 = dmsolve_extract (btmp, NULL, NULL, dm->rr [1], dm->rr [2], 
 				      0, b_nc);
diff --git a/mk-opts.pl b/mk-opts.pl
--- a/mk-opts.pl
+++ b/mk-opts.pl
@@ -587,17 +587,17 @@ sub emit_option_table_entry
 
   print "},\n";
 }
 
 sub emit_print_function
 {
   local ($i);
 
-  ## XXX FIXME XXX -- determine the width of the table automatically.
+  ## FIXME -- determine the width of the table automatically.
 
   print "static void
 print_${class_name} (void)
 {
   std::ostringstream buf;
 
   buf << \"\\n\"
       << \"Options for $CLASS include:\\n\\n\"
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -28,17 +28,17 @@
 
 ## Author:  Andreas Weingessel <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 18 October 1994
 ## Adapted-By: jwe
 
 function y = mu2lin (x, bit)
 
   if (nargin == 1)
-    ## XXX COMPATIBILITY XXX: bps defaults to 8 for octave, 0 for Matlab
+    ## COMPATIBILITY -- bps defaults to 8 for octave, 0 for Matlab
     bit = 8;
   elseif (nargin == 2)
     if (bit != 0 && bit != 8 && bit != 16)
       error ("mu2lin: bit must be either 0, 8 or 16");
     endif
   else
     usage ("y = mu2lin (x, bit)");
   endif
diff --git a/scripts/control/base/lsim.m b/scripts/control/base/lsim.m
--- a/scripts/control/base/lsim.m
+++ b/scripts/control/base/lsim.m
@@ -71,17 +71,17 @@ function [y, x] = lsim (sys, u, t, x0)
   Ts = 0;
   t(2)-t(1);
   u=u';
   n = max(size(t));
 
   for ii = 1:(n-1)
 
     ## check if step size changed
-    ## XXX FIXME XXX -- this is probably not the best test, but it is
+    ## FIXME -- this is probably not the best test, but it is
     ## better than a test for exact equality.
     if (abs (t(ii+1) - t(ii) - Ts) > 10 * eps)
       Ts = t(ii+1) - t(ii);
       ## [F,G] = c2d(a,b,Ts);
       dsys = c2d(sys, Ts);
       [F,G] = sys2ss(dsys);
     endif
 
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -33,15 +33,15 @@ function [R, G, B] = ind2rgb (X, map)
   if (nargin < 1 || nargin > 2)
     usage ("ind2rgb (X, map)");
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   [hi, wi] = size (X);
 
-  ## XXX FIXME XXX -- we should check size of X and map.
+  ## FIXME -- we should check size of X and map.
 
   R = reshape (map (X(:), 1), hi, wi);
   G = reshape (map (X(:), 2), hi, wi);
   B = reshape (map (X(:), 3), hi, wi);
 
 endfunction
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -41,17 +41,17 @@
 
 function z = cross (x, y, dim)
 	
   if (nargin != 2 && nargin != 3)
     usage ("cross (x, y, dim)");
   endif
 
   if (ndims (x) < 3 && ndims (y) < 3 && nargin < 3)
-    ## XXX COMPATIBILITY XXX opposite behaviour for cross(row,col)
+    ## COMPATIBILITY -- opposite behaviour for cross(row,col)
     ## Swap x and y in the assignments below to get the matlab behaviour.
     ## Better yet, fix the calling code so that it uses conformant vectors.
     if (columns (x) == 1 && rows (y) == 1)
       warning ("cross: taking cross product of column by row");
       y = y.';
     elseif (rows (x) == 1 && columns (y) == 1)
       warning ("cross: taking cross product of row by column");
       x = x.';
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -117,17 +117,17 @@ function [Uret, H, nu] = krylov (A, V, k
       q = V(:,jj);
       short_q = q(short_pv);
 
       if (norm (short_q) < eps1)
 	## insignificant column; delete
         nv = columns (V);
         if (jj != nv)
           [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
-	  ## XXX FIXME XXX -- H columns should be swapped too.  Not done
+	  ## FIXME -- H columns should be swapped too.  Not done
 	  ## since Block Hessenberg structure is lost anyway.
         endif
         V = V(:,1:(nv-1));
 	## one less reflection
         nu--;
       else
 	## new householder reflection
         if (pflg)
@@ -151,17 +151,17 @@ function [Uret, H, nu] = krylov (A, V, k
 
         [hv, av, z] = housh (q(idx), 1, 0);
         alpha(nu) = av;
         U(idx,nu) = hv;
 
         # reduce V per the reflection
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
         if(iter > 1)
-	  ## XXX FIXME XXX -- not done correctly for block case
+	  ## FIXME -- not done correctly for block case
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
         ## advance to next column of V
         jj++;
       endif
     endwhile
 
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -40,17 +40,17 @@
 ## named @var{filename}.  @var{directory} may be a list of directories
 ## specified either by name or with wildcard characters (like * and ?)
 ## which will be expanded with glob.
 ## @seealso{ls, stat, readdir, glob, filesep}
 ## @end deftypefn
 
 ## Author: jwe
 
-## XXX FIXME XXX -- this is quite slow for large directories, so perhaps
+## FIXME -- this is quite slow for large directories, so perhaps
 ## it should be converted to C++.
 
 function retval = dir (file)
 
   if (nargin == 0)
     file = ".";
   elseif (nargin > 1)
     usage ("dir (file)");
diff --git a/scripts/miscellaneous/doc.m b/scripts/miscellaneous/doc.m
--- a/scripts/miscellaneous/doc.m
+++ b/scripts/miscellaneous/doc.m
@@ -33,17 +33,17 @@
 
 function retval = doc (fname)
 
   if (nargin != 1 || ! ischar (fname))
     usage ("doc function_name")
   endif
 
   ## Get the directory where the function lives.
-  ## XXX FIXME XXX -- maybe we should have a better way of doing this.
+  ## FIXME -- maybe we should have a better way of doing this.
 
   x = exist (fname);
 
   if (x == 2)
     ffile = file_in_loadpath (strcat (fname, "."));
   elseif (x == 3)
     ffile = file_in_loadpath (strcat (fname, "."));
   else
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -27,17 +27,17 @@
 ## Author: jwe
 
 function dump_prefs (file)
 
   if (nargin == 0)
     file = stdout;
   endif
 
-  ## XXX FIXME XXX -- it would be nice to be able to get the list of
+  ## FIXME -- it would be nice to be able to get the list of
   ## built-in variables directly from Octave so that we wouldn't have to
   ## remember to update it each time the list of preference variables
   ## changes
 
   var_list = ["DEFAULT_EXEC_PATH";
 	      "DEFAULT_LOADPATH";
 	      "EDITOR";
               "EXEC_PATH";
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -96,17 +96,17 @@ function [status, msg, msgid] = fileattr
     for i = 1:nfiles
       [info, err, msg] = stat (files{i});
       if (! err)
 	r_n{i} = canonicalize_file_name (files{i});
 	r_a{i} = NaN;
 	r_s{i} = NaN;
 	r_h{i} = NaN;
 	r_d{i} = S_ISDIR (info.mode);
-	## XXX FIXME XXX -- maybe we should have S_IRUSR etc. masks?
+	## FIXME -- maybe we should have S_IRUSR etc. masks?
 	modestr = info.modestr;
 	r_u_r{i} = modestr(2) == "r";
 	r_u_w{i} = modestr(3) == "w";
 	r_u_x{i} = modestr(4) == "x";
 	r_g_r{i} = modestr(5) == "r";
 	r_g_w{i} = modestr(6) == "w";
 	r_g_x{i} = modestr(7) == "x";
 	r_o_r{i} = modestr(8) == "r";
diff --git a/scripts/path/setpath.m b/scripts/path/setpath.m
--- a/scripts/path/setpath.m
+++ b/scripts/path/setpath.m
@@ -24,17 +24,17 @@
 ## PKGADD: mark_as_command setpath
 
 function opath = setpath (npath)
 
   if (nargin == 1)
     if (nargout > 0)
       opath = LOADPATH;
     endif
-    ## XXX FIXME XXX -- perhaps validate elements of npath to make sure
+    ## FIXME -- perhaps validate elements of npath to make sure
     ## they are existing directories?
     if (ischar (npath))
       LOADPATH = npath;
     else
       error ("setpath: expecting argument to be a character string");
     endif
   else
     usage ("opath = setpath (npath)");
diff --git a/scripts/plot/__axis_label__.m b/scripts/plot/__axis_label__.m
--- a/scripts/plot/__axis_label__.m
+++ b/scripts/plot/__axis_label__.m
@@ -37,17 +37,17 @@ function h = __axis_label__ (caller, tex
       endif
     else
       error ("%s: text must be a string", caller);
     endif
   else
     usage ("%s (text)", caller);
   endif
 
-  ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
+  ## FIXME -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
 
   if (nargout > 0)
     h = -1;
   endif
 
 endfunction
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -144,17 +144,17 @@ function curr_axis = axis (ax, varargin)
     if (strcmp (ax, "ij"))
       __gnuplot_raw__ ("set yrange [] reverse;\n"); 
     elseif (strcmp (ax, "xy"))
       __gnuplot_raw__ ("set yrange [] noreverse;\n");
 
       ## aspect ratio
     elseif (strcmp (ax, "image"))
       __gnuplot_raw__ ("set size ratio -1;\n"); 
-      __gnuplot_raw__ ("set autoscale;\n"); ## XXX FIXME XXX should be the same as "tight"
+      __gnuplot_raw__ ("set autoscale;\n"); ## FIXME should be the same as "tight"
     elseif (strcmp (ax, "equal"))
       __gnuplot_raw__ ("set size ratio -1;\n");
     elseif (strcmp (ax, "square"))
       __gnuplot_raw__ ("set size ratio 1;\n");
     elseif (strcmp (ax, "normal"))
       __gnuplot_raw__ ("set size noratio;\n");
 
 
@@ -165,24 +165,24 @@ function curr_axis = axis (ax, varargin)
       else
 	__gnuplot_raw__ ("set autoscale;\n");
       endif
     elseif (strcmp (ax, "manual"))
       ## fixes the axis limits, like axis(axis) should;
       __gnuplot_raw__ ("set xrange [] writeback;\n");
       __gnuplot_raw__ ("set yrange [] writeback;\n");
       __gnuplot_raw__ ("set zrange [] writeback;\n");
-      ## XXX FIXME XXX if writeback were set in plot, no need to replot here.
+      ## FIXME if writeback were set in plot, no need to replot here.
       ## No semicolon (see replot.m).
       replot ();
       __gnuplot_raw__ ("set noautoscale x;\n");
       __gnuplot_raw__ ("set noautoscale y;\n");
       __gnuplot_raw__ ("set noautoscale z;\n");
     elseif (strcmp (ax, "tight"))
-      ## XXX FIXME XXX if tight, plot must set ranges to limits of the
+      ## FIXME if tight, plot must set ranges to limits of the
       ## all the data on the current plot, even if from a previous call.
       ## Instead, just let gnuplot do as it likes.
       __gnuplot_raw__ ("set autoscale;\n");
 
 
       ## tic marks
     elseif (strcmp (ax, "on"))
       __gnuplot_raw__ ("set xtics;\n");
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -25,17 +25,17 @@
 ## before this will be very useful.
 ## @seealso{plot, mesh, meshgrid}
 ## @end deftypefn
 
 ## Author: jwe
 
 function contour (x, y, z, n)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   if (nargin == 1 || nargin == 2)
     z = x;
     if (nargin == 1) 
       n = 10;
     else
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -25,17 +25,17 @@
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
 ## replot, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function loglog (varargin)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set logscale x;\n");
   __gnuplot_raw__ ("set logscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __plt__ ("loglog", varargin{:});
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -27,17 +27,17 @@
 ## to different @var{y} values.
 ## @seealso{meshgrid, contour}
 ## @end deftypefn
 
 ## Author: jwe
 
 function mesh (x, y, z)
 
-  ## XXX FIXME XXX -- the plot states should really just be set
+  ## FIXME -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   if (nargin == 1)
     z = x;
     if (ismatrix (z))
       __gnuplot_raw__ ("set hidden3d;\n");
       __gnuplot_raw__ ("set data style lines;\n");
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -53,17 +53,17 @@ function multiplot (xn, yn)
 
   xn = round (xn);
   yn = round (yn);
 
   if (xn == 0 && yn == 0)
 
     oneplot ();
 
-    ## XXX FIXME XXX -- do we really need to reset these here?
+    ## FIXME -- do we really need to reset these here?
 
     __multiplot_xsize__ = 1;
     __multiplot_ysize__ = 1;
     __multiplot_xn__ = 1;
     __multiplot_yn__ = 1;
     __multiplot_xi__ = 1;
     __multiplot_yi__ = 1;
 
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -165,17 +165,17 @@
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
 ## bar, stairs, errorbar, replot, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function plot (varargin)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set nologscale;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __plt__ ("plot", varargin{:});
 
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -26,17 +26,17 @@
 ## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
 ## stairs, replot, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set nologscale;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   if (nargin == 3)
     if (! ischar (fmt))
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -299,17 +299,17 @@ function print (varargin)
 	options = strcat (options, " ", fontsize);
       endif
       __gnuplot_raw__ ("set terminal push;\n");
       __gnuplot_raw__ (sprintf ("set terminal emf %s;\n", options));
 
     elseif (strcmp (dev, "png") || strcmp (dev, "pbm"))
       ## Portable network graphics, PBMplus
 
-      ## XXX FIXME XXX -- New PNG interface takes color as "xRRGGBB"
+      ## FIXME -- New PNG interface takes color as "xRRGGBB"
       ## where x is the literal character 'x' and 'RRGGBB' are the red,
       ## green and blue components in hex.  For now we just ignore it
       ## and use default.  The png terminal now is so rich with options,
       ## that one perhaps has to write a separate printpng.m function.
       ## DAS
 
       ## if (use_color >= 0)
       ##	eval (sprintf ("__gnuplot_set__ term %s color medium", dev));
@@ -343,16 +343,16 @@ function print (varargin)
     command = sprintf ("convert '%s' '%s'", name, convertname);
     [errcode, output] = system (command);
     unlink (name);
     if (errcode)
       error ("print: could not convert");
     endif
   endif
 
-  ## XXX FIXME XXX -- This looks like a dirty, Unix-specific hack.
+  ## FIXME -- This looks like a dirty, Unix-specific hack.
   ## DAS
   if (doprint)
     system (sprintf ("lpr %s '%s'", printer, printname));
     unlink (printname);
   endif
 
 endfunction
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -25,17 +25,17 @@
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
 ## replot, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function semilogx (varargin)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set logscale x;\n");
   __gnuplot_raw__ ("set nologscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __plt__ ("semilogx", varargin{:});
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -25,17 +25,17 @@
 ## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
 ## replot, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function semilogy (varargin)
 
-  ## XXX FIXME XXX -- these plot states should really just be set
+  ## FIXME -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set nologscale x;\n");
   __gnuplot_raw__ ("set logscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __plt__ ("semilogy", varargin{:});
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -118,17 +118,17 @@ function subplot (rows, columns, index)
   endif
 
   if (columns*rows == 1)
 
     ## switching to single plot ?
 
     oneplot ();
 
-    ## XXX FIXME XXX -- do we really need to reset these here?
+    ## FIXME -- do we really need to reset these here?
 
     __multiplot_xn__ = 1;
     __multiplot_yn__ = 1;
 
   else
 
     ## doing multiplot plots
 
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -37,17 +37,17 @@ function h = title (text)
 			      undo_string_escapes (text)));
     if (automatic_replot)
       replot ();
     endif
   else
     error ("title: text must be a string");
   endif
 
-  ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
+  ## FIXME -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
 
   if (nargout > 0)
     h = -1;
   endif
 
 endfunction
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -27,17 +27,17 @@
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs, replot, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = xlabel (varargin)
 
-  ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
+  ## FIXME -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
 
   if (nargout > 0)
     h = __axis_label__ ("xlabel", varargin{:});
   else
     __axis_label__ ("xlabel", varargin{:});
   endif
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} ylabel (@var{string})
 ## See xlabel.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = ylabel (varargin)
 
-  ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
+  ## FIXME -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
 
   if (nargout > 0)
     h = __axis_label__ ("ylabel", varargin{:});
   else
     __axis_label__ ("ylabel", varargin{:});
   endif
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function h = zlabel (varargin)
 
-  ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
+  ## FIXME -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
 
   if (nargout > 0)
     h = __axis_label__ ("zlabel", varargin{:});
   else
     __axis_label__ ("zlabel", varargin{:});
   endif
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -73,17 +73,17 @@ function freqz_plot(w,h)
       xlabel ("Frequency");
       axis ([ w(1), w(n) ]);
       plot (w, phase*360/(2*pi), ";Phase (degrees);");
       
     unwind_protect_cleanup
 
       ## Restore graph state.
 
-      ## XXX FIXME XXX -- if automatic_replot is non-zero, this will
+      ## FIXME -- if automatic_replot is non-zero, this will
       ## mess up the graph, however if we don't do it here then the user
       ## will have to do it themselves.
 
       grid ("off");
       axis ("auto", "label");
       __gnuplot_set__ lmargin;
       __gnuplot_set__ tmargin;
       oneplot ();
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -30,17 +30,17 @@ function [count,mean,var] = spstats(S,j)
   endif 
   [n, m] = size (S);
 
   count = spsum (sparse (i, j, 1, n, m));
   if (nargout > 1) 
     mean = spsum(S) ./ count; 
   end
   if (nargout > 2) 
-    ## XXX FIXME XXX Variance with count = 0 or 1?
+    ## FIXME Variance with count = 0 or 1?
     diff = S - sparse (i, j, mean(j), n, m); 
     var = spsum (diff .* diff) ./ (count - 1);
   end
 endfunction
 
 %!test
 %! [n,m,v] = spstats([1 2 1 2 3 4],[2 2 1 1 1 1]);
 %! assert(n,[4,2]);
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -548,17 +548,17 @@ endfunction
 %!fail ('toeplitz([1,2],[1,2;3,4])', msg);
 %!fail ('toeplitz ([1,2;3,4],[1,2])', msg);
 % !fail ('toeplitz','usage: toeplitz'); # usage doesn't generate an error
 % !fail ('toeplitz(1, 2, 3)', 'usage: toeplitz');
 %!test  assert (toeplitz ([1,2,3], [1,4]), [1,4; 2,1; 3,2]);
 %!demo  toeplitz ([1,2,3,4],[1,5,6])
 
 ### example from kron
-%!#error kron  # XXX FIXME XXX suppress these until we can handle output
+%!#error kron  # FIXME suppress these until we can handle output
 %!#error kron(1,2,3)
 %!test assert (isempty (kron ([], rand(3, 4))))
 %!test assert (isempty (kron (rand (3, 4), [])))
 %!test assert (isempty (kron ([], [])))
 %!shared A, B
 %!test
 %! A = [1, 2, 3; 4, 5, 6]; 
 %! B = [1, -1; 2, -2];
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -89,28 +89,28 @@ public:
 
   Cell reshape (const dim_vector& new_dims) const
     { return ArrayN<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
-  // XXX FIXME XXX
+  // FIXME
   boolMatrix all (int /* dim */ = 0) const { return boolMatrix (); }
 
-  // XXX FIXME XXX
+  // FIXME
   boolMatrix any (int /* dim */ = 0) const { return boolMatrix (); }
 
   Cell concat (const Cell& rb, const Array<octave_idx_type>& ra_idx);
 
   Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
   Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
-  // XXX FIXME XXX
+  // FIXME
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 };
 
 #endif
 
 /*
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -221,17 +221,17 @@ qp (const Matrix& H, const ColumnVector&
 	  // Computing the null space.
 
 	  octave_idx_type rank;
 
 	  Matrix Z = null (Aact, rank);
 
 	  octave_idx_type dimZ = n - rank;
 
-	  // XXX FIXME XXX -- still remain to handle the case of
+	  // FIXME -- still remain to handle the case of
 	  // non-full rank active set matrix.
 
 	  // Computing the Y matrix (orthogonal to Z)
 	  Y = Aact.pseudo_inverse ();
 
 	  // Reduced Hessian
 	  Matrix Zt = Z.transpose ();
 	  Matrix rH = Zt * H * Z;
diff --git a/src/DLD-FUNCTIONS/dispatch.cc b/src/DLD-FUNCTIONS/dispatch.cc
--- a/src/DLD-FUNCTIONS/dispatch.cc
+++ b/src/DLD-FUNCTIONS/dispatch.cc
@@ -31,37 +31,37 @@ 02110-1301, USA.
 #include "ov.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
-// XXX FIXME XXX should be using a map from type_id->name, rather
+// FIXME should be using a map from type_id->name, rather
 // than type_name->name
 
 template class std::map<std::string,std::string>;
 
 typedef std::map<std::string,std::string> Table;
 
 class
 octave_dispatch : public octave_function
 {
 public:
 
-  // XXX FIXME XXX need to handle doc strings of dispatched functions, for
+  // FIXME need to handle doc strings of dispatched functions, for
   // example, by appending "for <f>(<type>,...) see <name>" for each
   // time dispatch(f,type,name) is called.
   octave_dispatch (const std::string &nm)
     : octave_function (nm, "Overloaded function"), tab (), base (nm),
       has_alias (false)
   { }
 
-  // XXX FIXME XXX if we get deleted, we should restore the original
+  // FIXME if we get deleted, we should restore the original
   // symbol_record from base before dying.
   ~octave_dispatch (void) { }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_function *function_value (bool) { return this; }
 
   octave_value do_index_op (const octave_value_list&, int)
@@ -199,30 +199,30 @@ builtin (const std::string& base)
       dispatch->unprotect ();
 
       fbi_sym_tab->rename (base, "dispatch:" + base);
 
       fbi_sym_tab->rename ("builtin:" + base, base);
 
       // check for updates to builtin function; ignore errors that
       // appear (they interfere with renaming), and remove the updated
-      // name from the current symbol table.  XXX FIXME XXX check that
+      // name from the current symbol table.  FIXME check that
       // updating a function updates it in all contexts --- it may be
       // that it is updated only in the current symbol table, and not
       // the caller.  I believe this won't be a problem because the
       // caller will go through the same logic and end up with the
       // newer version.
       fcn = is_valid_function (base, "dispatch", 1);
       int cache_error = error_state;
       error_state = 0;
       curr_sym_tab->clear_function (base);
 
       // Move the builtin function out of the way and restore the
       // dispatch fuction.
-      // XXX FIXME XXX what if builtin wants to protect itself?
+      // FIXME what if builtin wants to protect itself?
       symbol_record *found = fbi_sym_tab->lookup (base, 0);
       bool readonly = found->is_read_only ();
       found->unprotect ();
       fbi_sym_tab->rename (base, "builtin:" + base);
       fbi_sym_tab->rename ("dispatch:" + base, base);
       if (readonly)
 	found->protect ();
       dispatch->protect ();
@@ -386,41 +386,41 @@ dispatch_record (const std::string &f, c
       // Create a symbol record for the dispatch object.
       sr = fbi_sym_tab->lookup (f, true);
       sr->unprotect ();
       sr->define (octave_value (dispatch), symbol_record::BUILTIN_FUNCTION); 
       // std::cout << "iscommand('"<<f<<"')=" << iscommand << std::endl;
       if (iscommand)
 	sr->mark_as_command();
       sr->document ("\n\n@noindent\nOverloaded function:\n");
-      sr->make_eternal (); // XXX FIXME XXX why??
+      sr->make_eternal (); // FIXME why??
       sr->mark_as_static ();
       sr->protect ();
     }
 
   // clear/replace/extend the map with the new type-function pair
   const octave_dispatch& rep
     = dynamic_cast<const octave_dispatch&> (sr->def().get_rep ());
 
   if (t.empty ())
-    // XXX FIXME XXX should return the list if nargout > 1
+    // FIXME should return the list if nargout > 1
     rep.print (octave_stdout);
   else if (n.empty ())
     {
-      // XXX FIXME XXX should we eliminate the dispatch function if
+      // FIXME should we eliminate the dispatch function if
       // there are no more elements?
-      // XXX FIXME XXX should clear the " $t:\w+" from the help string.
-      // XXX FIXME XXX -- seems bad to cast away const here...
+      // FIXME should clear the " $t:\w+" from the help string.
+      // FIXME -- seems bad to cast away const here...
       octave_dispatch& xrep = const_cast<octave_dispatch&> (rep);
 
       xrep.clear (t);
     }
   else
     {
-      // XXX FIXME XXX -- seems bad to cast away const here...
+      // FIXME -- seems bad to cast away const here...
       octave_dispatch& xrep = const_cast<octave_dispatch&> (rep);
 
       xrep.add (t, n);
 
       if (! sr->help().empty ())
 	sr->document (sr->help() + "\n" + n + " (" + t + ", ...)\n");
     }
 }
@@ -524,17 +524,17 @@ for @var{f}.\n\
 %! dispatch('qr','string');
 %!test # override pre-loaded m-file
 %! evalin('base','hanning(1);');
 %! dispatch('hanning','length','string')
 %! evalin('base','assert(hanning("abc"),3)');
 %! evalin('base','assert(hanning(1),1)');
 %! dispatch('hanning','string');
 
-XXX FIXME XXX I would rather not create dispatch_x/dispatch_y
+FIXME I would rather not create dispatch_x/dispatch_y
 in the current directory!  I don't want them installed accidentally.
 
 %!test # replace base m-file
 %! system("echo 'function a=dispatch_x(a)'>dispatch_x.m");
 %! dispatch('dispatch_x','length','string')
 %! assert(dispatch_x(3),3)
 %! assert(dispatch_x("a"),1)
 %! pause(1);
@@ -549,11 +549,11 @@ in the current directory!  I don't want 
 %! dispatch('hello','dispatch_y','complex scalar')
 %! assert(hello(3i),3i)
 %! pause(1);
 %! system("echo 'function a=dispatch_y(a),++a;'>dispatch_y.m");
 %! assert(hello(3i),1+3i)
 %!test 
 %! system("rm dispatch_y.m");
 
-XXX FIXME XXX add tests for preservation of mark_as_command status.
+FIXME add tests for preservation of mark_as_command status.
 
 */
diff --git a/src/DLD-FUNCTIONS/fftw_wisdom.cc b/src/DLD-FUNCTIONS/fftw_wisdom.cc
--- a/src/DLD-FUNCTIONS/fftw_wisdom.cc
+++ b/src/DLD-FUNCTIONS/fftw_wisdom.cc
@@ -108,17 +108,17 @@ Octave.\n\
 	  if (NINTbig (dval) != 0)
 	    overwrite = true;
 	}
 
       std::string str = args(0).string_value ();
       std::string wisdom = octave_env::make_absolute
 	(Vload_path_dir_path.find_first_of (str), octave_env::getcwd ());
 
-      // XXX FIXME XXX -- should probably protect FILE* resources with
+      // FIXME -- should probably protect FILE* resources with
       // auto_ptr or similar...
 
       if (wisdom.empty () || overwrite)
 	{
 	  if (str.empty ())
 	    error ("fftw_wisdom: can not save to file");
 	  else
 	    {
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -26,17 +26,17 @@ 02110-1301, USA.
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "lo-mappers.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
-// XXX FIXME XXX -- should probably handle Inf, NaN.
+// FIXME -- should probably handle Inf, NaN.
 
 static inline bool
 is_integer_value (double x)
 {
   return x == static_cast<double> (static_cast<long> (x));
 }
 
 DEFUN_DLD (gcd, args, nargout,
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -132,17 +132,17 @@ elements @code{sec} (seconds) @code{usec
 A structure containing the user CPU time used.  The structure has the\n\
 elements @code{sec} (seconds) @code{usec} (microseconds).\n\
 @end table\n\
 @end deftypefn")
 {
   Octave_map m;
   Octave_map tv_tmp;
 
-  // XXX FIXME XX -- maybe encapsulate all of this in a liboctave class
+  // FIXME -- maybe encapsulate all of this in a liboctave class
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
   tv_tmp.assign ("sec", static_cast<double> (ru.ru_utime.tv_sec));
   tv_tmp.assign ("usec", static_cast<double> (ru.ru_utime.tv_usec));
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -117,17 +117,17 @@ ill-conditioned matrix if the reciprocal
   else
     {
       gripe_wrong_type_arg ("inv", arg);
     }
 
   return retval;
 }
 
-// XXX FIXME XXX -- this should really be done with an alias, but
+// FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} inverse (@var{a})\n\
 See inv.\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -136,17 +136,17 @@ are the same as for @dfn{lu}.\n\
 	    }
 
 	  if (map.contains ("thresh"))
 	    thresh = map.contents ("thresh")(0).double_value ();
 	}
       else
 	droptol = args(1).double_value ();
 
-      // XXX FIXME XXX Add code for zero-level factorization
+      // FIXME Add code for zero-level factorization
       if (zero_level)
 	error ("luinc: zero-level factorization not implemented");
 
       if (!error_state)
 	{
 	  if (args(0).type_name () == "sparse matrix") 
 	    {
 	      SparseMatrix sm = args(0).sparse_matrix_value ();
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -186,17 +186,17 @@ matrix type.\n\
 		// This should never happen!!!
 		retval = octave_value ("Unknown");
 	    }
 	  else
 	    {
 	      // Ok, we're changing the matrix type
 	      std::string str_typ = args(1).string_value ();
 
-	      // XXX FIXME, why do I have to explicitly call the constructor?
+	      // FIXME -- why do I have to explicitly call the constructor?
 	      SparseType mattyp = SparseType ();
 
 	      octave_idx_type nl = 0;
 	      octave_idx_type nu = 0;
 	      
 	      if (error_state)
 		error ("Matrix type must be a string");
 	      else
@@ -303,17 +303,17 @@ matrix type.\n\
 	error ("matrix_type: Only sparse matrices treated at the moment");
     }
 
   return retval;
 }
 
 /*
 
-## XXX FIXME XXX
+## FIXME
 ## Disable tests for lower under-determined and upper over-determined 
 ## matrices and this detection is disabled in SparseType due to issues
 ## of non minimum norm solution being found.
  
 %!assert(matrix_type(speye(10,10)),"Diagonal");
 %!assert(matrix_type(speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -67,40 +67,40 @@ quad_user_function (double x)
   args(0) = x;
 
   if (quad_fcn)
     {
       octave_value_list tmp = quad_fcn->do_multi_index_op (1, args);
 
       if (error_state)
 	{
-	  quad_integration_error = 1;  // XXX FIXME XXX
+	  quad_integration_error = 1;  // FIXME
 	  gripe_user_supplied_eval ("quad");
 	  return retval;
 	}
 
       if (tmp.length () && tmp(0).is_defined ())
 	{
 	  if (! warned_imaginary && tmp(0).is_complex_type ())
 	    {
 	      warning ("quad: ignoring imaginary part returned from user-supplied function");
 	      warned_imaginary = true;
 	    }
 
 	  retval = tmp(0).double_value ();
 
 	  if (error_state)
 	    {
-	      quad_integration_error = 1;  // XXX FIXME XXX
+	      quad_integration_error = 1;  // FIXME
 	      gripe_user_supplied_eval ("quad");
 	    }
 	}
       else
 	{
-	  quad_integration_error = 1;  // XXX FIXME XXX
+	  quad_integration_error = 1;  // FIXME
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
 #define QUAD_ABORT() \
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -772,17 +772,17 @@ Order of output arguments was selected f
 			  std::cout << "aa(" << idr << "," << idc << ")="
 			       << aa(idr,idc) << std::endl;
 			  std::cout << "bb(" << idr << "," << idc << ")="
 			       << bb(idr,idc) << std::endl;
 			}
 		    }
 #endif
 
-		  // XXX FIXME XXX -- probably should be using
+		  // FIXME -- probably should be using
 		  // fortran_vec instead of &aa(jj,jj) here.
 
 		  double scale1, scale2, wr1, wr2, wi;
 		  const double *aa_ptr = aa.data () + jj*nn+jj;
 		  const double *bb_ptr = bb.data () + jj*nn+jj;
 		  F77_XFCN (dlag2, DLAG2,
 			    (aa_ptr, nn, bb_ptr, nn, safmin,
 			     scale1, scale2, wr1, wr2, wi));
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -15,17 +15,17 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; see the file COPYING.  If not, write to the
 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.
 
 */
 
-// XXX FIXME XXX
+// FIXME
 // regexprep should be written as an m-file based on regexp
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 #include <sstream>
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -853,17 +853,17 @@ ordered lists.\n\
 	  else
 	    {
 	      if (return_idx)
 		retval = mx_sort_indexed (chm, dim, smode);
 	      else
 		retval = mx_sort (chm, dim, smode);
 	    }
 
-	  // XXX FIXME XXX It would have been better to call 
+	  // FIXME It would have been better to call 
 	  // "octave_value(m, true)" but how can that be done 
 	  // within the template
 	  retval(0) = retval(0).convert_to_str (false, true);
 	}
     }
   else if (arg.is_cell ())
     {
       Cell cellm = arg.cell_value ();
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -175,17 +175,17 @@ Manchester, England, January 1999.\n\
 
       if (arg.is_real_matrix ())
 	{
 	  Matrix A = arg.matrix_value();
 
 	  if (error_state)
 	    return retval;
 
-	  // XXX FIXME XXX -- eventually, ComplexSCHUR will accept a
+	  // FIXME -- eventually, ComplexSCHUR will accept a
 	  // real matrix arg.
 
 	  ComplexMatrix Ac (A);
 
 	  const ComplexSCHUR schur (Ac, std::string ());
 
 	  if (error_state)
 	    return retval;
@@ -205,17 +205,17 @@ Manchester, England, January 1999.\n\
 	      }
 
 	  if (imagX < normX * 100 * DBL_EPSILON)
 	    retval(0) = real (X);
 	  else
 	    retval(0) = X;
 
 	  // Compute error
-	  // XXX FIXME XXX can we estimate the error without doing the
+	  // FIXME can we estimate the error without doing the
 	  // matrix multiply?
 
 	  err = frobnorm (X*X - ComplexMatrix (A)) / frobnorm (A);
 
 	  if (xisnan (err))
 	    err = lo_ieee_inf_value ();
 
 	  // Find min diagonal
diff --git a/src/__gnuplot_raw__.l b/src/__gnuplot_raw__.l
--- a/src/__gnuplot_raw__.l
+++ b/src/__gnuplot_raw__.l
@@ -370,17 +370,17 @@ handle_string (char delim)
 // (Probably not necessesary, but current Matlab style plot functions
 // break without this (they emit too short gnuplot commands))
 
 static std::string
 plot_style_token (const std::string& s)
 {
   std::string retval;
 
-  // XXX FIXME XXX -- specify minimum match length for these.
+  // FIXME -- specify minimum match length for these.
   static const char *plot_styles[] =
     {
       "boxes",
       "boxerrorbars",
       "boxxyerrorbars",
       "candlesticks",
       "dots",
       "errorbars",
@@ -612,17 +612,17 @@ handle_style (int& lasttok)
   style = std::string (yytext);
   style = plot_style_token (style);
 
   if (! style.empty ())
     retstr += style;
   else
     retstr += std::string (yytext);
 
-  // XXX FIXME XXX -- should evaluate the remaining tokens, but this
+  // FIXME -- should evaluate the remaining tokens, but this
   // needs changes in the parser.
   retstr += " " + read_until (plottok_or_end_p, lasttok);
 
   return retstr;
 }
 
 // Axes has only one qualifier keyword, which is not evaluated.
 
@@ -750,17 +750,17 @@ public:
   }
 
   static void set_gnuplot_use_title_option (bool opt)
   {
     if (ensure_instance ())
       instance->do_set_gnuplot_use_title_option (opt);
   }
 
-  // XXX FIXME XXX -- should only remove tmp files associated with
+  // FIXME -- should only remove tmp files associated with
   // gnuplot?
   static void cleanup_tmp_files (void) { ::cleanup_tmp_files (); }
 
   static void plot (const string_vector& argv)
   {
     if (ensure_plot_stream ())
       instance->do_plot (argv);
   }
@@ -944,17 +944,17 @@ gnuplot::do_open (void)
 
       std::string cmd;
 
       if (gnuplot_exe.empty ())
 	cmd = "gnuplot";
       else
         cmd = "\"" + gnuplot_exe + "\"";
 
-      // XXX FIXME XXX -- I'm not sure this is the right thing to do,
+      // FIXME -- I'm not sure this is the right thing to do,
       // but without it, C-c at the octave prompt will kill gnuplot...
 
 #if defined (HAVE_POSIX_SIGNALS)
       sigset_t nset, oset;
       sigemptyset (&nset);
       sigaddset (&nset, SIGINT);
       sigprocmask (SIG_BLOCK, &nset, &oset);
 #else
@@ -1088,17 +1088,17 @@ gnuplot::do_send_raw (const std::string&
     }
 }
 
 void
 gnuplot::do_clear (void)
 {
   do_send_raw ("clear\n");
 
-  // XXX FIXME XXX -- instead of just clearing these things, it would
+  // FIXME -- instead of just clearing these things, it would
   // be nice if we could reset things to a user-specified default
   // state.
 
   do_send_raw ("set title\n");
   do_send_raw ("set xlabel\n");
   do_send_raw ("set ylabel\n");
   do_send_raw ("set nogrid\n");
   do_send_raw ("set nolabel\n");
@@ -1286,17 +1286,17 @@ gnuplot::makeplot (std::string caller, s
 	    throw gpt_parse_error ();
 
 	  std::ostringstream tmp_buf;
 	  tmp_data.print_raw (tmp_buf);
 
 	  if (tmp_data.is_string ())
 	    {
 	      file = file_ops::tilde_expand (tmp_data.string_value ());
-	      // XXX FIXME XXX -- perhaps should check if the file exists?
+	      // FIXME -- perhaps should check if the file exists?
 	      outstr += file + " ";
 	    }
 	  else
 	    {
 	      switch (ndim)
 		{
 		case 2:
 		  file = save_in_tmp_file (tmp_data, ndim);
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -37,17 +37,17 @@ 02110-1301, USA.
 #include "ov-uint8.h"
 #include "ov-int64.h"
 #include "ov-int32.h"
 #include "ov-int16.h"
 #include "ov-int8.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 
-// XXX FIXME XXX -- could probably eliminate some code duplication by
+// FIXME -- could probably eliminate some code duplication by
 // clever use of templates.
 
 #define BITOPX(OP, FNAME, RET) \
       { \
 	int nelx = x.numel (); \
 	int nely = y.numel (); \
  \
 	bool is_scalar_op = (nelx == 1 || nely == 1); \
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -39,17 +39,17 @@ 02110-1301, USA.
 #define SEEK_END 2
 #endif
 
 c_file_ptr_buf::~c_file_ptr_buf (void)
 {
   close ();
 }
 
-// XXX FIXME XXX -- I'm sure there is room for improvement here...
+// FIXME -- I'm sure there is room for improvement here...
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::overflow (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
   if (f)
     return (c != traits_type::eof ()) ? fputc (c, f) : flush ();
   else
@@ -124,34 +124,34 @@ seekdir_to_whence (std::ios::seekdir dir
 	  (dir == std::ios::end) ? SEEK_END :
 	  dir);
 }
 
 std::streampos
 c_file_ptr_buf::seekoff (std::streamoff offset, std::ios::seekdir dir,
 			 std::ios::openmode)
 {
-  // XXX FIXME XXX
+  // FIXME
 #if 0
   if (f)
     {
       fseek (f, offset, seekdir_to_whence (dir));
 
       return ftell (f);
     }
   else
     return 0;
 #endif
   return -1;
 }
 
 std::streampos
 c_file_ptr_buf::seekpos (std::streampos offset, std::ios::openmode)
 {
-  // XXX FIXME XXX
+  // FIXME
 #if 0  
   if (f)
     {
       fseek (f, offset, SEEK_SET);
 
       return ftell (f);
     }
   else
@@ -192,17 +192,17 @@ c_file_ptr_buf::close (void)
 
 #ifdef HAVE_ZLIB
 
 c_zfile_ptr_buf::~c_zfile_ptr_buf (void)
 {
   close ();
 }
 
-// XXX FIXME XXX -- I'm sure there is room for improvement here...
+// FIXME -- I'm sure there is room for improvement here...
 
 c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::overflow (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
   if (f)
     return (c != traits_type::eof ()) ? gzputc (f, c) : flush ();
   else
@@ -268,34 +268,34 @@ c_zfile_ptr_buf::xsgetn (char *s, std::s
   else
     return 0;
 }
 
 std::streampos
 c_zfile_ptr_buf::seekoff (std::streamoff offset, std::ios::seekdir dir,
 			 std::ios::openmode)
 {
-  // XXX FIXME XXX
+  // FIXME
 #if 0
   if (f)
     {
       gzseek (f, offset, seekdir_to_whence (dir));
 
       return gztell (f);
     }
   else
     return 0;
 #endif
   return -1;
 }
 
 std::streampos
 c_zfile_ptr_buf::seekpos (std::streampos offset, std::ios::openmode)
 {
-  // XXX FIXME XXX
+  // FIXME
 #if 0  
   if (f)
     {
       gzseek (f, offset, SEEK_SET);
 
       return gztell (f);
     }
   else
@@ -310,17 +310,17 @@ c_zfile_ptr_buf::sync (void)
   flush ();
 
   return 0;
 }
 
 int
 c_zfile_ptr_buf::flush (void)
 {
-  // XXX FIXME XXX -- do we need something more complex here, passing
+  // FIXME -- do we need something more complex here, passing
   // something other than 0 for the second argument to gzflush and
   // checking the return value, etc.?
 
   return f ? gzflush (f, 0) : EOF;
 }
 
 int
 c_zfile_ptr_buf::close (void)
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -89,17 +89,17 @@ protected:
 
   close_fcn cf;
 
 private:
 
   int_type underflow_common (bool);
 };
 
-// XXX FIXME XXX -- the following three classes could probably share
+// FIXME -- the following three classes could probably share
 // some code...
 
 template <typename STREAM_T, typename FILE_T, typename BUF_T>
 class
 c_file_ptr_stream : public STREAM_T
 {
 public:
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -427,17 +427,17 @@ is omitted, it defaults to 1 (column-wis
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the cumulative sum of the elements as a vector with the\n\
 same orientation as @var{x}.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumsum);
 }
 
-// XXX FIXME XXX -- we could eliminate some duplicate code here with
+// FIXME -- we could eliminate some duplicate code here with
 // some template functions or macros.
 
 static octave_value
 make_diag (const Matrix& v, octave_idx_type k)
 {
   octave_idx_type nr = v.rows ();
   octave_idx_type nc = v.columns ();
   assert (nc == 1 || nr == 1);
@@ -868,17 +868,17 @@ static octave_value
 do_permute (const octave_value_list& args, bool inv, const std::string& fname)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
     {
       Array<int> vec = args(1).int_vector_value ();
 
-      // XXX FIXME XXX -- maybe we should create an idx_vector object
+      // FIXME -- maybe we should create an idx_vector object
       // here and pass that to permute?
 
       int n = vec.length ();
 
       for (int i = 0; i < n; i++)
 	vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
@@ -1211,17 +1211,17 @@ Return true if @var{x} is a complex-valu
   if (args.length () == 1)
     retval = args(0).is_complex_type ();
   else
     print_usage ("iscomplex");
 
   return retval;
 }
 
-// XXX FIXME XXX -- perhaps this should be implemented with an
+// FIXME -- perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} complex (@var{val})\n\
 @deftypefnx {Built-in Function} {} complex (@var{re}, @var{im})\n\
 Convert @var{x} to a complex value.\n\
 @end deftypefn")
@@ -1475,17 +1475,17 @@ fill_matrix (const octave_value_list& ar
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
-      // XXX FIXME XXX -- perhaps this should be made extensible by
+      // FIXME -- perhaps this should be made extensible by
       // using the class name to lookup a function to call to create
       // the new value.
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
 	{
@@ -1518,17 +1518,17 @@ fill_matrix (const octave_value_list& ar
 	    case oct_data_conv::dt_int64:
 	      retval = int64NDArray (dims, val);
 	      break;
 
 	    case oct_data_conv::dt_uint64:
 	      retval = uint64NDArray (dims, val);
 	      break;
 
-	    case oct_data_conv::dt_single: // XXX FIXME XXX
+	    case oct_data_conv::dt_single: // FIXME
 	    case oct_data_conv::dt_double:
 	      retval = NDArray (dims, val);
 	      break;
 
 	    case oct_data_conv::dt_logical:
 	      retval = boolNDArray (dims, val);
 	      break;
 
@@ -1599,17 +1599,17 @@ fill_matrix (const octave_value_list& ar
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
 	{
 	  switch (dt)
 	    {
-	    case oct_data_conv::dt_single: // XXX FIXME XXX
+	    case oct_data_conv::dt_single: // FIXME
 	    case oct_data_conv::dt_double:
 	      retval = NDArray (dims, val);
 	      break;
 
 	    default:
 	      error ("%s: invalid class name", fcn);
 	      break;
 	    }
@@ -1677,17 +1677,17 @@ fill_matrix (const octave_value_list& ar
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
 	{
 	  switch (dt)
 	    {
-	    case oct_data_conv::dt_single: // XXX FIXME XXX
+	    case oct_data_conv::dt_single: // FIXME
 	    case oct_data_conv::dt_double:
 	      retval = ComplexNDArray (dims, val);
 	      break;
 
 	    default:
 	      error ("%s: invalid class name", fcn);
 	      break;
 	    }
@@ -2084,17 +2084,17 @@ INSTANTIATE_EYE (uint64NDArray);
 INSTANTIATE_EYE (NDArray);
 INSTANTIATE_EYE (boolNDArray);
 
 static octave_value
 identity_matrix (int nr, int nc, oct_data_conv::data_type dt)
 {
   octave_value retval;
 
-  // XXX FIXME XXX -- perhaps this should be made extensible by using
+  // FIXME -- perhaps this should be made extensible by using
   // the class name to lookup a function to call to create the new
   // value.
 
   if (! error_state)
     {
       switch (dt)
 	{
 	case oct_data_conv::dt_int8:
@@ -2124,17 +2124,17 @@ identity_matrix (int nr, int nc, oct_dat
 	case oct_data_conv::dt_int64:
 	  retval = identity_matrix<int64NDArray> (nr, nc);
 	  break;
 
 	case oct_data_conv::dt_uint64:
 	  retval = identity_matrix<uint64NDArray> (nr, nc);
 	  break;
 
-	case oct_data_conv::dt_single: // XXX FIXME XXX
+	case oct_data_conv::dt_single: // FIXME
 	case oct_data_conv::dt_double:
 	  retval = identity_matrix<NDArray> (nr, nc);
 	  break;
 
 	case oct_data_conv::dt_logical:
 	  retval = identity_matrix<boolNDArray> (nr, nc);
 	  break;
 
@@ -2307,17 +2307,17 @@ The @code{linspace} function always retu
 	}
     }
   else
     error ("linspace: expecting third argument to be an integer");
 
   return retval;
 }
 
-// XXX FIXME XXX -- should accept dimensions as separate args for N-d
+// FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} resize (@var{x}, @var{m})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})\n\
 Resize @var{x} to be dimension @var{m}-by-@var{n} where @var{m}\n\
 and @var{n} are scalar. If @var{n} is not supplied, then resize @var{x}\n\
@@ -2361,17 +2361,17 @@ dimensions of the resized matrix.\n\
 	  retval = retval.resize (dim_vector (m, n), true);
 	}
     }
   else
     print_usage ("resize");
   return retval;
 }
 
-// XXX FIXME XXX -- should use octave_idx_type for dimensions.
+// FIXME -- should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n\
 @deftypefnx {Function File} {} reshape (@var{a}, @var{siz})\n\
 Return a matrix with the given dimensions whose elements are taken\n\
 from the matrix @var{a}.  The elements of the matrix are access in\n\
 column-major order (like Fortran arrays are stored).\n\
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -593,17 +593,17 @@ loadpath (void)
       //	warning ("LOADPATH will ignore default load path");
 
       Vload_path = s;
 
       // By resetting the last prompt time variable, we will force
       // checks for out of date symbols even if the change to LOADPATH
       // and subsequent function calls happen between prompts.
 
-      // XXX FIXME XXX -- maybe we should rename
+      // FIXME -- maybe we should rename
       // Vlast_prompt_time_stamp since the new usage doesn't really
       // fit with the current name?
 
       Vlast_prompt_time.stamp ();
 
       update_load_path_dir_path ();
     }
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -229,17 +229,17 @@ typedef bool (*octave_dld_fcn_installer)
 #define DEFCONST_INTERNAL(name, defn, doc) \
   INSTALL_CONST (#name, SBV_ ## name, defn, false, doc);
 
 #define DEFCONSTX_INTERNAL(name, sname, defn, doc) \
   INSTALL_CONST (name, sname, defn, false, doc);
 
 // How mapper functions are actually installed.
 
-// XXX FIXME XXX -- Really want to avoid the following casts, since
+// FIXME -- Really want to avoid the following casts, since
 // (as always with casts) it may mask some real errors...
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      ch_map_flag, can_ret_cmplx_for_real, doc) \
   install_builtin_mapper \
     (new octave_mapper \
      (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, c_c_map, \
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -37,17 +37,17 @@ 02110-1301, USA.
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "symtab.h"
 #include "variables.h"
 
-// XXX FIXME XXX -- this function could probably share some code with
+// FIXME -- this function could probably share some code with
 // the help functions.
 
 void
 print_usage (const std::string& nm, bool just_usage,
 	     const std::string& extra_msg)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (nm);
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -62,27 +62,27 @@ 02110-1301, USA.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we ask for confirmation before recursively removing a
 // directory tree.
 static bool Vconfirm_recursive_rmdir = true;
 
-// XXX FIXME XXX -- changing the plotter directory should be handled
+// FIXME -- changing the plotter directory should be handled
 // by registering a function for octave_env::chdir to call so that
 // this function can be eliminated.
 
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   int cd_ok = octave_env::chdir (newdir);
 
   if (cd_ok)
-    // XXX FIXME XXX -- this should be handled as a list of functions
+    // FIXME -- this should be handled as a list of functions
     // to call so users can add their own chdir handlers.
     /* do_external_plotter_cd (newdir) */;
   else
     {
       using namespace std;
 
       error ("%s: %s", newdir.c_str (), strerror (errno));
     }
@@ -280,17 +280,17 @@ system-dependent error message.\n\
 	}
     }
   else
     print_usage ("readdir");
 
   return retval;
 }
 
-// XXX FIXME XXX -- should maybe also allow second arg to specify
+// FIXME -- should maybe also allow second arg to specify
 // mode?  OTOH, that might cause trouble with compatibility later...
 
 DEFCMD (mkdir, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{dir})\n\
 Create a directory named @var{dir}.\n\
 \n\
 If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -151,17 +151,17 @@ vwarning (const char *name, const char *
 
   if (name)
     output_buf << name << ": ";
 
   octave_vformat (output_buf, fmt, args);
 
   output_buf << std::endl;
 
-  // XXX FIXME XXX -- we really want to capture the message before it
+  // FIXME -- we really want to capture the message before it
   // has all the formatting goop attached to it.  We probably also
   // want just the message, not the traceback information.
 
   std::string msg_string = output_buf.str ();
 
   if (! warning_state)
     {
       // This is the first warning in a possible series.
@@ -197,17 +197,17 @@ verror (bool save_last_error, std::ostre
 
   if (name)
     output_buf << name << ": ";
 
   octave_vformat (output_buf, fmt, args);
 
   output_buf << std::endl;
 
-  // XXX FIXME XXX -- we really want to capture the message before it
+  // FIXME -- we really want to capture the message before it
   // has all the formatting goop attached to it.  We probably also
   // want just the message, not the traceback information.
 
   std::string msg_string = output_buf.str ();
 
   if (! error_state && save_last_error)
     {
       // This is the first error in a possible series.
@@ -219,17 +219,17 @@ verror (bool save_last_error, std::ostre
   if (buffer_error_messages)
     {
       std::string tmp = msg_string;
 
       if (! error_message_buffer)
 	{
 	  error_message_buffer = new std::ostringstream ();
 
-	  // XXX FIXME XXX -- this is ugly, but it prevents
+	  // FIXME -- this is ugly, but it prevents
 	  //
 	  //   eval ("error (\"msg\")", "error (lasterr ())");
 	  //
 	  // from printing `error: ' twice.  Assumes that the NAME we
 	  // have been given doesn't contain `:'.
 
 	  size_t pos = msg_string.find (':');
 
@@ -401,17 +401,17 @@ pr_where (const char *name, bool print_c
 	    pr_where_1 ("%s: in %s near line %d, column %d:",
 			name, nm.c_str (), l, c);
 	  else
 	    pr_where_1 ("%s: in %s", name, nm.c_str ());
 	}
 
       if (print_code)
 	{
-	  // XXX FIXME XXX -- Note that the column number is probably
+	  // FIXME -- Note that the column number is probably
 	  // not going to mean much here since the code is being
 	  // reproduced from the parse tree, and we are only showing
 	  // one statement even if there were multiple statements on
 	  // the original source line.
 
 	  std::ostringstream output_buf;
 
 	  output_buf << std::endl;
@@ -773,17 +773,17 @@ a single message:\n\
 @group\n\
 function h () nargin == 1 || error (\"nargin != 1\\n\"); end\n\
 f ()\n\
 error: nargin != 1\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  // XXX FIXME XXX -- need to extract and pass message id to
+  // FIXME -- need to extract and pass message id to
   // handle_message.
 
   octave_value_list retval;
   handle_message (error_with_id, "", "unspecified error", args);
   return retval;
 }
 
 DEFCMD (warning, args, nargout,
@@ -877,30 +877,30 @@ to go on.\n\
 		      octave_idx_type nel = ident.numel ();
 
 		      bool found = false;
 
 		      for (octave_idx_type i = 0; i < nel; i++)
 			{
 			  if (ident(i).string_value () == arg2)
 			    {
-			      // XXX FIXME XXX -- if state for "all" is
+			      // FIXME -- if state for "all" is
 			      // same as arg1, we can simply remove the
 			      // item from the list.
 
 			      state(i) = arg1;
 			      warning_options.assign ("state", state);
 			      found = true;
 			      break;
 			    }
 			}
 
 		      if (! found)
 			{
-			  // XXX FIXME XXX -- if state for "all" is
+			  // FIXME -- if state for "all" is
 			  // same as arg1, we don't need to do anything.
 
 			  ident.resize (dim_vector (1, nel+1));
 			  state.resize (dim_vector (1, nel+1));
 
 			  ident(nel) = arg2;
 			  state(nel) = arg1;
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -103,17 +103,17 @@ initialize_file_io (void)
 void
 close_files (void)
 {
   octave_stream_list::clear ();
 }
 
 // List of files to delete when we exit or crash.
 //
-// XXX FIXME XXX -- this should really be static, but that causes
+// FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::stack <std::string> tmp_files;
 
 void
 mark_for_deletion (const std::string& file)
 {
   tmp_files.push (file);
 }
@@ -246,17 +246,17 @@ stream before calling @code{input}.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      // XXX FIXME XXX -- any way to avoid special case for stdout?
+      // FIXME -- any way to avoid special case for stdout?
 
       int fid = octave_stream_list::get_file_number (args (0));
 
       if (fid == 1)
 	{
 	  flush_octave_stdout ();
 
 	  retval = 0;
@@ -1131,17 +1131,17 @@ string is treated as an end-of-file cond
 		      octave_idx_type count = 0;
 
 		      Array<double> size = (nargin == 3)
 			? args(2).vector_value ()
 			: Array<double> (1, lo_ieee_inf_value ());
 
 		      octave_value tmp = os.scanf (args(1), size, count, who);
 
-		      // XXX FIXME XXX -- is this the right thing to do?
+		      // FIXME -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
 		      std::string errmsg = os.error ();
 
 		      retval(3) = os.tell () + 1;
 		      retval(2) = errmsg;
 		      retval(1) = count;
 		      retval(0) = tmp;
diff --git a/src/fn-cache.cc b/src/fn-cache.cc
--- a/src/fn-cache.cc
+++ b/src/fn-cache.cc
@@ -99,17 +99,17 @@ octave_fcn_file_name_cache::do_list (con
   update (path);
 
   string_vector fcn_file_names;
   string_vector fcn_file_names_no_suffix;
 
   // For now, always generate the list of function files on each
   // call.
 
-  // XXX FIXME XXX -- this could probably be improved by keeping lists
+  // FIXME -- this could probably be improved by keeping lists
   // of all the function files for the current load path and only
   // updating that when the load path changes.  Have to be careful to
   // return the right thing when we are only looking for a subset of
   // all the files in the load path.
 
   int total_len = 0;
 
   dir_path p = path.empty () ? Vload_path_dir_path : dir_path (path);
diff --git a/src/fn-cache.h b/src/fn-cache.h
--- a/src/fn-cache.h
+++ b/src/fn-cache.h
@@ -26,17 +26,17 @@ 02110-1301, USA.
 
 #include <string>
 #include <map>
 
 #include "oct-time.h"
 
 class string_vector;
 
-// XXX FIXME XXX -- this should maybe be nested in the
+// FIXME -- this should maybe be nested in the
 // octave_fcn_file_name_cache class...
 
 class
 file_name_cache_elt
 {
 public:
 
   file_name_cache_elt (void)
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -79,17 +79,17 @@ std::string Vinfo_prog;
 
 // Name of the makeinfo program to run.
 static std::string Vmakeinfo_prog = "makeinfo";
 
 // If TRUE, don't print additional help message in help and usage
 // functions.
 static bool Vsuppress_verbose_help_message;
 
-// XXX FIXME XXX -- maybe this should use string instead of char*.
+// FIXME -- maybe this should use string instead of char*.
 
 struct help_list
 {
   const char *name;
   const char *help;
 };
 
 static help_list operators[] =
@@ -382,17 +382,17 @@ operator_help (void)
 }
 
 static help_list *
 keyword_help (void)
 {
   return keywords;
 }
 
-// It's not likely that this does the right thing now.  XXX FIXME XXX
+// It's not likely that this does the right thing now.  FIXME
 
 string_vector
 make_name_list (void)
 {
   string_vector key = names (keyword_help ());
   int key_len = key.length ();
 
   string_vector fbi = fbi_sym_tab->name_list ();
@@ -456,17 +456,17 @@ Additional help for built-in functions, 
 is available in the on-line version of the manual.  Use the command\n\
 `doc <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.octave.org and via the help@octave.org\n\
 mailing list.\n"; 
 }
 
-// XXX FIXME XXX -- this needs a major overhaul to cope with new
+// FIXME -- this needs a major overhaul to cope with new
 // symbol table stuff.
 
 static void
 display_names_from_help_list (std::ostream& os, help_list *list,
 			      const char *desc)
 {
   string_vector symbols = names (list);
 
@@ -511,17 +511,17 @@ simple_help (void)
   additional_help_message (octave_stdout);
 
   display_names_from_help_list (octave_stdout, operator_help (),
 				"operators");
 
   display_names_from_help_list (octave_stdout, keyword_help (),
 				"reserved words");
 
-  // XXX FIXME XXX -- is this distinction needed?
+  // FIXME -- is this distinction needed?
 
   LIST_SYMBOLS (symbol_record::BUILTIN_CONSTANT, "built-in constants");
 
   LIST_SYMBOLS (symbol_record::BUILTIN_VARIABLE, "built-in variables");
 
   LIST_SYMBOLS (symbol_record::COMMAND, "commands");
 
   LIST_SYMBOLS (symbol_record::MAPPER_FUNCTION, "mapper functions");
@@ -756,32 +756,32 @@ extract_help_from_dispatch (const std::s
 	{
 	  dispatch->unprotect ();
 
 	  fbi_sym_tab->rename (nm, "dispatch:" + nm);
 	  fbi_sym_tab->rename ("builtin:" + nm, nm);
 
 	  // Check for updates to builtin function; ignore errors
 	  // that appear (they interfere with renaming), and remove
-	  // the updated name from the current symbol table.  XXX
-	  // FIXME XXX check that updating a function updates it in
-	  // all contexts --- it may be that it is updated only in the
+	  // the updated name from the current symbol table.  FIXME --
+	  // check that updating a function updates it in all
+	  // contexts.  It may be that it is updated only in the 
 	  // current symbol table, and not the caller.  I believe this
 	  // won't be a problem because the caller will go through the
 	  // same logic and end up with the newer version.
 
 	  octave_function *f = is_valid_function (nm);
 
 	  if (f)
 	    retval = builtin->help ();
 
 	  curr_sym_tab->clear_function (nm);
 
 	  // Move the builtin function out of the way and restore the
-	  // dispatch fuction.  XXX FIXME XXX what if builtin wants to
+	  // dispatch fuction.  FIXME what if builtin wants to
 	  // protect itself?
 
 	  fbi_sym_tab->rename (nm, "builtin:" + nm);
 	  fbi_sym_tab->rename ("dispatch:" + nm, nm);
 
 	  dispatch->protect ();
 	}
       else
@@ -973,17 +973,17 @@ representation.  This problem may be fix
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("type");
 
   if (! error_state)
     {
       if (argc > 1)
 	{
-	  // XXX FIXME XXX -- we should really use getopt ()
+	  // FIXME -- we should really use getopt ()
 
 	  bool quiet = false;
 	  bool pr_orig_txt = true;
 
 	  int idx;
 
 	  for (idx = 1; idx < argc; idx++)
 	    {
@@ -1101,17 +1101,17 @@ function file, the full name of the file
 	}
       else
 	print_usage (argv[0]);
     }
 
   return retval;
 }
 
-// XXX FIXME XXX 
+// FIXME 
 // This function attempts to find the first sentence of a help string, though
 // given that the user can create the help in an arbitrary format, your
 // success might vary.. it works much better with help string formated in
 // texinfo. Using regex might make this function much simpler.
 
 std::string 
 first_help_sentence (const std::string& h, bool short_sentence = true)
 {
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -287,17 +287,17 @@ get_user_input (void)
     input_line_number++;
 
   return retval;
 }
 
 int
 octave_read (char *buf, unsigned max_size)
 {
-  // XXX FIXME XXX -- is this a safe way to buffer the input?
+  // FIXME -- is this a safe way to buffer the input?
 
   static const char * const eol = "\n";
   static std::string input_buf;
   static const char *pos = 0;
   static size_t chars_left = 0;
 
   int status = 0;
   if (chars_left == 0)
@@ -381,17 +381,17 @@ get_input_from_file (const std::string& 
 
 FILE *
 get_input_from_stdin (void)
 {
   command_editor::set_input_stream (stdin);
   return command_editor::get_input_stream ();
 }
 
-// XXX FIXME XXX -- make this generate file names when appropriate.
+// FIXME -- make this generate file names when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
 			       std::string& hint)
 {
   string_vector names;
 
   prefix = "";
@@ -463,17 +463,17 @@ generate_completion (const std::string& 
 
 	  if (hint == name.substr (0, hint_len))
 	    {
 	      if (list_index <= name_list_len && ! prefix.empty ())
 		retval = prefix + "." + name;
 	      else
 		retval = name;
 
-	      // XXX FIXME XXX -- looks_like_struct is broken for now,
+	      // FIXME -- looks_like_struct is broken for now,
 	      // so it always returns false.
 
  	      if (matches == 1 && looks_like_struct (retval))
  		{
  		  // Don't append anything, since we don't know
  		  // whether it should be '(' or '.'.
 
  		  command_editor::set_completion_append_character ('\0');
@@ -493,17 +493,17 @@ generate_completion (const std::string& 
 void
 initialize_command_input (void)
 {
   // If we are using readline, this allows conditional parsing of the
   // .inputrc file.
 
   command_editor::set_name ("Octave");
 
-  // XX FIXME XXX -- this needs to include a comma too, but that
+  // FIXME -- this needs to include a comma too, but that
   // causes trouble for the new struct element completion code.
 
   static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
 
   command_editor::set_basic_word_break_characters (s);
 
   command_editor::set_completer_word_break_characters (s);
 
@@ -647,17 +647,17 @@ get_user_input (const octave_value_list&
 	      tree::break_function = octave_call_stack::current ();
 
 	      return retval;
 	    }
 	}
 
       if (read_as_string)
 	{
-	  // XXX FIXME XXX -- fix gnu_readline and octave_gets instead!
+	  // FIXME -- fix gnu_readline and octave_gets instead!
 	  if (input_buf.length () == 1 && input_buf[0] == '\n')
 	    retval(0) = "";
 	  else
 	    retval(0) = input_buf;
 	}
       else
 	{
 	  int parse_status = 0;
@@ -804,17 +804,17 @@ do_keyboard (const octave_value_list& ar
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
   unwind_protect::begin_frame ("do_keyboard");
 
-  // XXX FIXME XXX -- we shouldn't need both the
+  // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries (false);
 
   unwind_protect::add (restore_command_history, 0);
 
   unwind_protect_bool (Vsaving_history);
 
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */
 
 #if !defined (octave_lex_h)
 #define octave_lex_h 1
 
-// XXX FIXME XXX -- these input buffer things should be members of a
+// FIXME -- these input buffer things should be members of a
 // parser input stream class.
 
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
 
 // Associate a buffer with a new file to read.
 extern YY_BUFFER_STATE create_buffer (FILE *f);
 
 // Report the current buffer.
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -163,17 +163,17 @@ bool parser_end_of_input = false;
 // Flags that need to be shared between the lexer and parser.
 lexical_feedback lexer_flags;
 
 // Stack to hold tokens so that we can delete them when the parser is
 // reset and avoid growing forever just because we are stashing some
 // information.  This has to appear before lex.h is included, because
 // one of the macros defined there uses token_stack.
 //
-// XXX FIXME XXX -- this should really be static, but that causes
+// FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::stack <token*> token_stack;
 
 // Did eat_whitespace() eat a space or tab, or a newline, or both?
 
 typedef int yum_yum;
 
 const yum_yum ATE_NOTHING = 0;
@@ -1230,17 +1230,17 @@ force_local_variable (const std::string&
   symbol_record *sr = curr_sym_tab->lookup (name, true);
 
   if (sr)
     sr->define (octave_value ());
 }
 
 // Grab the help text from an function file.
 
-// XXX FIXME XXX -- gobble_leading_white_space() in parse.y
+// FIXME -- gobble_leading_white_space() in parse.y
 // duplicates some of this code!
 
 static std::string
 grab_help_text (void)
 {
   std::string buf;
 
   bool begin_comment = true;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -113,17 +113,17 @@ gripe_file_open (const std::string& fcn,
   if (fcn == "load")
     error ("%s: unable to open input file `%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
     error ("%s: unable to open output file `%s'", fcn.c_str (), file.c_str ());
   else
     error ("%s: unable to open file `%s'", fcn.c_str (), file.c_str ());
 }
 
-// XXX FIXME XXX -- shouldn't this be implemented in terms of other
+// FIXME -- shouldn't this be implemented in terms of other
 // functions that are already available?
 
 // Install a variable with name NAME and the value specified TC in the
 // symbol table.  If FORCE is TRUE, replace any existing definition
 // for NAME.  If GLOBAL is TRUE, make the variable global.
 //
 // Assumes TC is defined.
 
@@ -784,17 +784,17 @@ Force Octave to assume the file is in Oc
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
 	error ("load: cannot read HDF5 format from stdin");
       else
 #endif /* HAVE_HDF5 */
       if (format != LS_UNKNOWN)
 	{
-	  // XXX FIXME XXX -- if we have already seen EOF on a
+	  // FIXME -- if we have already seen EOF on a
 	  // previous call, how do we fix up the state of std::cin so
 	  // that we can get additional input?  I'm afraid that we
 	  // can't fix this using std::cin only.
 
 	  retval = do_load (std::cin, orig_fname, force, format, flt_fmt,
 			    list_only, swap, verbose, argv, i, argc,
 			    nargout);
 	}
@@ -1325,17 +1325,17 @@ dump_octave_core (std::ostream& os, cons
       if (sr->is_variable ())
 	{
 	  octave_value tc = sr->def ();
 
 	  if (tc.is_defined ())
 	    {
 	      double tc_size = tc.byte_size () / 1024;
 
-	      // XXX FIXME XXX -- maybe we should try to throw out the
+	      // FIXME -- maybe we should try to throw out the
 	      // largest first...
 
 	      if (Voctave_core_file_limit < 0
 		  || save_mem_size + tc_size < Voctave_core_file_limit)
 		{
 		  save_mem_size += tc_size;
 
 		  std::string name = sr->name ();
@@ -1356,17 +1356,17 @@ dump_octave_core (std::ostream& os, cons
   message (0, "save to `%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
-      // XXX FIXME XXX -- should choose better file name?
+      // FIXME -- should choose better file name?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
       message (0, "attempting to save variables to `%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_builtins = false;
@@ -1633,17 +1633,17 @@ the file @file{data} in Octave's binary 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         error ("save: cannot write HDF5 format to stdout");
       else
 #endif /* HAVE_HDF5 */
 	// don't insert any commands here!  the brace below must go
 	// with the "else" above!
 	{
-	  // XXX FIXME XXX -- should things intended for the screen end up
+	  // FIXME -- should things intended for the screen end up
 	  // in a octave_value (string)?
 	  
 	  save_vars (argv, i, argc, octave_stdout, save_builtins, format,
 		     save_as_floats, true);
 	}
     }
 
   // Guard against things like `save a*', which are probably mistakes...
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -330,17 +330,17 @@ hdf5_read_next_data (hid_t group_id, con
 
 	  H5Sclose (space_id);
 	}
       else if (type_class_id == H5T_INTEGER)
 	{
 	  // What integer type do we really have..
 	  std::string int_typ;
 #ifdef HAVE_H5T_GET_NATIVE_TYPE
-	  // XXX FIXME XX test this code and activated with an autoconf 
+	  // FIXME test this code and activated with an autoconf 
 	  // test!! It is also incorrect for 64-bit indexing!!
 	  
 	  switch (H5Tget_native_type (type_id, H5T_DIR_ASCEND))
 	    {
 	    case H5T_NATIVE_CHAR:
 	      int_typ = "int8 ";
 	      break;
  
@@ -533,17 +533,17 @@ read_hdf5_data (std::istream& is, const 
   // Versions of HDF5 prior to 1.2.2 had a bug in H5Giterate where it
   // would return the index of the last item processed instead of the
   // next item to be processed, forcing us to increment the index manually.
 
   unsigned int vers_major, vers_minor, vers_release;
 
   H5get_libversion (&vers_major, &vers_minor, &vers_release);
 
-  // XXX FIXME XXX -- this test looks wrong.
+  // FIXME -- this test looks wrong.
   have_h5giterate_bug
     = (vers_major < 1
        || (vers_major == 1 && (vers_minor < 2
 			       || (vers_minor == 2 && vers_release < 2))));
 
   herr_t H5Giterate_retval = -1;
 
 #ifdef HAVE_H5GGET_NUM_OBJS
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -292,17 +292,17 @@ read_mat_ascii_data (std::istream& is, c
 			}
 
 		    }
 		}
 	    }
 
 	  if (is || is.eof ())
 	    {
-	      // XXX FIXME XXX -- not sure this is best, but it works.
+	      // FIXME -- not sure this is best, but it works.
 
 	      if (is.eof ())
 		is.clear ();
 
 	      octave_idx_type expected = nr * nc;
 
 	      if (expected == total_count)
 		{
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -442,17 +442,17 @@ read_mat5_binary_element (std::istream& 
 	{
 	  // Why should I have to initialize outbuf as I'll just overwrite!!
 	  if (swap)
 	    swap_bytes<4> (tmp, 2);
 
 	  destLen = tmp[1] + 8;
 	  std::string outbuf (destLen, ' '); 
 
-	  // XXX FIXME XXX -- find a way to avoid casting away const here!
+	  // FIXME -- find a way to avoid casting away const here!
 
 	  int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())), &destLen, 
 				reinterpret_cast<Bytef *> (inbuf), element_length);
 
 	  if (err != Z_OK)
 	    error ("load: error uncompressing data element");
 	  else
 	    {
@@ -1656,17 +1656,17 @@ save_mat5_binary_element (std::ostream& 
       else
 	{
 	  SparseMatrix m = tc.sparse_matrix_value ();
 	  int nc = m.cols ();
 
 	  write_mat5_integer_data (os, m.ridx (), - sizeof(int), nnz);
 	  write_mat5_integer_data (os, m.cidx (), - sizeof(int), nc + 1);
 
-	  // XXX FIXME XXX
+	  // FIXME
 	  // Is there a way to easily do without this buffer
 	  NDArray buf (dim_vector (nnz, 1));
 
 	  for (int i = 0; i < nnz; i++)
 	    buf (i) = m.data (i);
 
 	  write_mat5_array (os, buf, save_as_floats);
 	}
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -253,17 +253,17 @@ extract_keyword (std::istream& is, const
 //  is
 //  # length: 1
 //  a
 //  # length: 6
 //  string
 //  # length: 5
 //  array
 //
-// XXX FIXME XXX -- this format is fairly rigid, and doesn't allow for
+// FIXME -- this format is fairly rigid, and doesn't allow for
 // arbitrary comments.  Someone should fix that. It does allow arbitrary
 // types however.
 
 // Ugh.  The signature of the compare method is not standard in older
 // versions of the GNU libstdc++.  Do this instead:
 
 #define SUBSTRING_COMPARE_EQ(s, pos, n, t) (s.substr (pos, n) == t)
 
@@ -342,17 +342,17 @@ read_ascii_data (std::istream& is, const
 // and Infinite values are converted to +/-OCT_RBV (A Real Big Value,
 // but not so big that gnuplot can't handle it when trying to compute
 // axis ranges, etc.).
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
-// XXX FIXME XXX -- should probably write the help string here too.
+// FIXME -- should probably write the help string here too.
 
 bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
 		 const std::string& name, bool& infnan_warned,
 		 bool strip_nan_and_inf, bool mark_as_global,
 		 int precision)
 {
   bool success = true;
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -201,17 +201,17 @@ read_binary_data (std::istream& is, bool
       break;
 
     case 4:
       tc = octave_value_typeinfo::lookup_type ("complex matrix");
       break;
 
     case 5:
       {
-	// XXX FIXME XXXX
+	// FIXMEX
 	// This is cruft, since its for a save type that is old. Maybe
 	// this is taking backward compatability too far!!
 	FOUR_BYTE_INT len;
 	if (! is.read (reinterpret_cast<char *> (&len), 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_bytes<4> (&len);
 	OCTAVE_LOCAL_BUFFER (char, s, len+1);
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -32,17 +32,17 @@ 02110-1301, USA.
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-mapper.h"
 #include "variables.h"
 
-// XXX FIXME XXX -- perhaps this could be avoided by determining
+// FIXME -- perhaps this could be avoided by determining
 // whether the is* functions are actually functions or just macros.
 
 static int
 xabs (int c)
 {
   return static_cast<unsigned char> (c);
 }
 
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -540,17 +540,17 @@ do_run_history (int argc, const string_v
   input_from_tmp_history_file = true;
 
   parse_and_execute (name);
 
   unwind_protect::run_frame ("do_run_history");
 
   // Delete the temporary file.
 
-  // XXX FIXME XXX -- should probably be done using an unwind_protect.
+  // FIXME -- should probably be done using an unwind_protect.
 
   unlink (name.c_str ());
 }
 
 void
 octave_history_write_timestamp (void)
 {
   octave_localtime now;
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -28,17 +28,17 @@ class octave_value;
 class octave_value_list;
 
 #include <string>
 
 #include "oct-obj.h"
 #include "pt-idx.h"
 #include "symtab.h"
 
-// XXX FIXME XXX -- eliminate the following kluge?
+// FIXME -- eliminate the following kluge?
 
 // This variable is used when creating dummy octave_lvalue objects.
 static octave_value dummy_val;
 
 class
 octave_lvalue
 {
 public:
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -52,17 +52,17 @@ public:
   ~octave_value_list (void) { }
 
   void *operator new (size_t size)
     { return allocator.alloc (size); }
 
   void operator delete (void *p, size_t size)
     { allocator.free (p, size); }
 
-  // XXX FIXME XXX -- without this, I have errors with the stack of
+  // FIXME -- without this, I have errors with the stack of
   // octave_value_list objects in ov-usr-fcn.h.  Why?
   void *operator new (size_t size, void *p)
     { return ::operator new (size, p); }
 
   void operator delete (void *p, void *)
     {
 #if defined (HAVE_PLACEMENT_DELETE)
       ::operator delete (p, static_cast<void *> (0));
diff --git a/src/oct-prcstrm.h b/src/oct-prcstrm.h
--- a/src/oct-prcstrm.h
+++ b/src/oct-prcstrm.h
@@ -21,17 +21,17 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_octave_procstream_h)
 #define octave_octave_procstream_h 1
 
 #include "oct-stdstrm.h"
 
-// XXX FIXME XXX -- why don't these classes use iprocstream and
+// FIXME -- why don't these classes use iprocstream and
 // oprocstream, which in turn use the octave_procbuf class?
 
 class
 octave_iprocstream : public octave_stdiostream
 {
 public:
 
   octave_iprocstream (const std::string& n,
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -68,17 +68,17 @@ public:
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
   std::istream *input_stream (void) { return (md & std::ios::in) ? s : 0; }
 
   std::ostream *output_stream (void) { return (md & std::ios::out) ? s : 0; }
 
-  // XXX FIXME XXX -- should not have to cast away const here.
+  // FIXME -- should not have to cast away const here.
   BUF_T *rdbuf (void) const
     { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : 0; }
 
   bool bad (void) const { return s ? s->bad () : true; }
 
   void clear (void) { if (s) s->clear (); }
 
   void do_close (void) { if (s) s->close (); }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1031,17 +1031,17 @@ octave_base_stream::gets (octave_idx_typ
 #if defined (__GNUG__) && ! defined (CXX_ISO_COMPLIANT_LIBRARY)
 
 #define OCTAVE_SCAN(is, fmt, arg) is.scan ((fmt).text, arg)
 
 #else
 
 #define OCTAVE_SCAN(is, fmt, arg) octave_scan (is, fmt, arg)
 
-// XXX FIXME XXX -- this needs to be fixed to handle formats which
+// FIXME -- this needs to be fixed to handle formats which
 // specify a maximum width.
 
 template <class T>
 std::istream&
 octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
 {
   T& ref = *valptr;
 
@@ -1922,17 +1922,17 @@ octave_base_stream::do_scanf (scanf_form
 		    }
 
 		  // If it looks like we have a matching failure, then
 		  // reset the failbit in the stream state.
 
 		  if (is.rdstate () & std::ios::failbit)
 		    is.clear (is.rdstate () & (~std::ios::failbit));
 
-		  // XXX FIXME XXX -- is this the right thing to do?
+		  // FIXME -- is this the right thing to do?
 
 		  if (interactive && name () == "stdin")
 		    {
 		      is.clear ();
 
 		      // Skip to end of line.
 
 		      bool err;
@@ -2130,17 +2130,17 @@ octave_base_stream::do_oscanf (const sca
 	      break;
 	    }
 	}
 
       if (ok () && is.fail ())
 	{
 	  error ("%s: read error", who.c_str ());
 
-	  // XXX FIXME XXX -- is this the right thing to do?
+	  // FIXME -- is this the right thing to do?
 
 	  if (interactive && name () == "stdin")
 	    {
 	      // Skip to end of line.
 
 	      bool err;
 	      do_gets (-1, err, false, who);
 	    }
@@ -2678,17 +2678,17 @@ octave_base_stream::puts (const std::str
   if (osp)
     {
       std::ostream& os = *osp;
 
       os << s;
 
       if (os)
 	{
-	  // XXX FIXME XXX -- why does this seem to be necessary?
+	  // FIXME -- why does this seem to be necessary?
 	  // Without it, output from a loop like
 	  //
 	  //   for i = 1:100, fputs (stdout, "foo\n"); endfor
 	  //
 	  // doesn't seem to go to the pager immediately.
 
 	  os.flush ();
 
@@ -3037,17 +3037,17 @@ do_read (octave_stream& strm, octave_idx
     }
   else
     {
       nda.resize (dim_vector (32, 1), elt_zero);
       dat = nda.fortran_vec ();
       max_size = 32;
     }
 
-  // XXX FIXME XXX -- byte order for Cray?
+  // FIXME -- byte order for Cray?
 
   bool swap = false;
 
   if (oct_mach_info::words_big_endian ())
     swap = (from_flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
 	    || from_flt_fmt == oct_mach_info::flt_fmt_vax_g
 	    || from_flt_fmt == oct_mach_info::flt_fmt_vax_g);
   else
@@ -3064,17 +3064,17 @@ do_read (octave_stream& strm, octave_idx
   if (isp)
     {
       std::istream& is = *isp;
 
       octave_idx_type elts_read = 0;
 
       for (;;)
 	{
-	  // XXX FIXME XXX -- maybe there should be a special case for
+	  // FIXME -- maybe there should be a special case for
 	  // skip == 0.
 
 	  if (is)
 	    {
 	      if (nr > 0 && nc > 0 && count == max_size)
 		{
 		  final_nr = nr;
 		  final_nc = nc;
@@ -3161,17 +3161,17 @@ do_read (octave_stream& strm, octave_idx
   return retval;
 }
 
 #define DO_READ_VAL_TEMPLATE(RET_T, READ_T) \
   template octave_value \
   do_read<RET_T, READ_T> (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, \
 			  oct_mach_info::float_format, octave_idx_type&)
 
-// XXX FIXME XXX -- should we only have float if it is a different
+// FIXME -- should we only have float if it is a different
 // size from double?
 
 #define INSTANTIATE_DO_READ(VAL_T) \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_uint8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int16); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_uint16); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int32); \
@@ -3249,19 +3249,19 @@ octave_stream::read (const Array<double>
 
       initialized = true;
     }
 
   octave_value retval;
 
   if (stream_ok ())
     {
-      // XXX FIXME XXX -- we may eventually want to make this extensible.
-
-      // XXX FIXME XXX -- we need a better way to ensure that this
+      // FIXME -- we may eventually want to make this extensible.
+
+      // FIXME -- we need a better way to ensure that this
       // numbering stays consistent with the order of the elements in the
       // data_type enum in the oct_data_conv class.
 
       char_count = 0;
 
       octave_idx_type nr = -1;
       octave_idx_type nc = -1;
 
@@ -3284,17 +3284,17 @@ octave_stream::read (const Array<double>
 					 || input_type == oct_data_conv::dt_single)
 					&& ffmt != float_format ());
 
 	      if (fcn)
 		{
 		  retval = (*fcn) (*this, nr, nc, block_size, skip,
 				   do_float_fmt_conv, ffmt, char_count);
 
-		  // XXX FIXME XXX -- kluge!
+		  // FIXME -- kluge!
 
 		  if (! error_state
 		      && (output_type == oct_data_conv::dt_char
 			  || output_type == oct_data_conv::dt_schar
 			  || output_type == oct_data_conv::dt_uchar))
 		    retval = octave_value (retval.char_matrix_value (), true);
 		}
 	      else
@@ -3463,17 +3463,17 @@ octave_stream::write (const Array<T>& da
 
   octave_idx_type n = data.length ();
 
   oct_mach_info::float_format native_flt_fmt
     = oct_mach_info::float_format ();
 
   bool do_float_conversion = (flt_fmt != native_flt_fmt);
 
-  // XXX FIXME XXX -- byte order for Cray?
+  // FIXME -- byte order for Cray?
 
   bool swap = false;
 
   if (oct_mach_info::words_big_endian ())
     swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
 	    || flt_fmt == oct_mach_info::flt_fmt_vax_g
 	    || flt_fmt == oct_mach_info::flt_fmt_vax_g);
   else
@@ -3487,17 +3487,17 @@ octave_stream::write (const Array<T>& da
 	{
 	  std::ostream& os = *osp;
 
 	  // It seems that Matlab writes zeros instead of actually
 	  // seeking.  Hmm...
 
 	  if (skip != 0 && (i % block_size) == 0)
 	    {
-	      // XXX FIXME XXX -- probably should try to write larger
+	      // FIXME -- probably should try to write larger
 	      // blocks...
 
 	      unsigned char zero = 0;
 	      for (int j = 0; j < skip; j++)
 		os.write (reinterpret_cast<const char *> (&zero), 1);
 	    }
 
 	  if (os)
@@ -3699,17 +3699,17 @@ octave_stream::puts (const std::string& 
   int retval = -1;
 
   if (stream_ok ())
     retval = rep->puts (s, who);
 
   return retval;
 }
 
-// XXX FIXME XXX -- maybe this should work for string arrays too.
+// FIXME -- maybe this should work for string arrays too.
 
 int
 octave_stream::puts (const octave_value& tc_s, const std::string& who)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -717,24 +717,24 @@ octave_main (int argc, char **argv, int 
 
   // Force input to be echoed if not really interactive, but the user
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
-      // XXX FIXME XXX -- is this the right thing to do?
+      // FIXME -- is this the right thing to do?
 
       bind_builtin_variable ("echo_executing_commands", ECHO_CMD_LINE);
     }
 
   if (embedded)
     {
-      // XXX FIXME XXX -- do we need to do any cleanup here before
+      // FIXME -- do we need to do any cleanup here before
       // returning?  If we don't, what will happen to Octave functions
       // that have been registered to execute with atexit, for example?
 
       return 1;
     }
 
   int retval = main_loop ();
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -246,17 +246,17 @@ extern void install_ops (void);
 
 #define DEFNDUNOP_OP(name, t, e, op) \
   UNOPDECL (name, a) \
   { \
     CAST_UNOP_ARG (const octave_ ## t&); \
     return octave_value (op v.e ## _value ()); \
   }
 
-// XXX FIXME XXX -- in some cases, the constructor isn't necessary.
+// FIXME -- in some cases, the constructor isn't necessary.
 
 #define DEFUNOP_FN(name, t, f) \
   UNOPDECL (name, a) \
   { \
     CAST_UNOP_ARG (const octave_ ## t&); \
     return octave_value (f (v.t ## _value ())); \
   }
 
@@ -296,17 +296,17 @@ extern void install_ops (void);
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     return octave_value \
       (v1.e1 ## _value () op v2.e2 ## _value ()); \
   }
 
-// XXX FIXME XXX -- in some cases, the constructor isn't necessary.
+// FIXME -- in some cases, the constructor isn't necessary.
 
 #define DEFBINOP_FN(name, t1, t2, f) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     return octave_value (f (v1.t1 ## _value (), v2.t2 ## _value ())); \
   }
 
@@ -329,17 +329,17 @@ extern void install_ops (void);
 		      const Array<int>& ra_idx)
 
 #define DEFCATOPX(name, t1, t2)	\
   CATOPDECL (name, , )
 
 #define DEFCATOP(name, t1, t2)	\
   CATOPDECL (name, a1, a2)
 
-// XXX FIXME XXX -- in some cases, the constructor isn't necessary.
+// FIXME -- in some cases, the constructor isn't necessary.
 
 #define DEFCATOP_FN(name, t1, t2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (octave_ ## t1&, const octave_ ## t2&); \
     return octave_value (v1.t1 ## _value () . f (v2.t2 ## _value (), ra_idx)); \
   }
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -253,34 +253,34 @@ template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
 				  bool pr_as_read_syntax) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nz = nnz ();
 
-  // XXX FIXME XXX -- this should probably all be handled by a
+  // FIXME -- this should probably all be handled by a
   // separate octave_print_internal function that can handle format
   // compact, loose, etc.
 
   os << "Compressed Column Sparse (rows = " << nr
      << ", cols = " << nc
      << ", nnz = " << nz << ")\n";
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
 
   if (nz != 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  OCTAVE_QUIT;
 
-	  // XXX FIXME XXX -- is there an easy way to get the max row
+	  // FIXME -- is there an easy way to get the max row
 	  // and column indices so we can set the width appropriately
 	  // and line up the columns here?  Similarly, we should look
 	  // at all the nonzero values and display them with the same
 	  // formatting rules that apply to columns of a matrix.
 
 	  for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
 	    {
 	      os << "\n";
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1018,17 +1018,17 @@ bool octave_base_value::beginning_of_lin
 
 void
 octave_base_value::indent (std::ostream& os) const
 {
   assert (curr_print_indent_level >= 0);
  
   if (beginning_of_line)
     {
-      // XXX FIXME XXX -- do we need this?
+      // FIXME -- do we need this?
       // os << prefix;
 
       for (int i = 0; i < curr_print_indent_level; i++)
 	os << " ";
 
       beginning_of_line = false;
     }
 }
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -85,29 +85,29 @@ octave_bool_matrix::try_narrowing_conver
     }
 
   return retval;
 }
 
 bool
 octave_bool_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "real scalar");
 
@@ -116,20 +116,20 @@ octave_bool_matrix::double_value (bool) 
 
 Complex
 octave_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -84,28 +84,28 @@ octave_sparse_bool_matrix::try_narrowing
     retval = new octave_bool_matrix (matrix.matrix_value ());
 
   return retval;
 }
 
 bool
 octave_sparse_bool_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("bool sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "real scalar");
 
@@ -114,20 +114,20 @@ octave_sparse_bool_matrix::double_value 
 
 Complex
 octave_sparse_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("bool sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
 
@@ -137,17 +137,17 @@ octave_sparse_bool_matrix::complex_value
 octave_value
 octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force,
 						    char type) const
 {
   octave_value tmp = octave_value (array_value ());
   return tmp.convert_to_str (pad, force, type);
 }
 
-// XXX FIXME XXX These are inefficient ways of creating full matrices
+// FIXME These are inefficient ways of creating full matrices
 
 Matrix
 octave_sparse_bool_matrix::matrix_value (bool) const
 {
   return Matrix (matrix.matrix_value ());
 }
 
 ComplexMatrix
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -78,17 +78,17 @@ public:
 
   octave_base_value *clone (void) const { return new octave_sparse_bool_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_sparse_bool_matrix (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
-  // XXX FIXME XXX Adapt idx_vector to allow sparse logical indexing!!
+  // FIXME Adapt idx_vector to allow sparse logical indexing!!
   idx_vector index_vector (void) const 
     { return idx_vector (bool_array_value ()); }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -80,23 +80,23 @@ octave_value
 octave_bool::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (valid_scalar_indices (idx))
     retval = scalar;
   else
     {
-      // XXX FIXME XXX -- this doesn't solve the problem of
+      // FIXME -- this doesn't solve the problem of
       //
       //   a = 1; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
-      // XXX FIXME XXX -- using this constructor avoids narrowing the
+      // FIXME -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_bool_matrix (bool_matrix_value ()));
 
       retval = tmp.do_index_op (idx, resize_ok);
     }
 
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -76,21 +76,21 @@ octave_builtin::subsref (const std::stri
 	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
   //
-  // XXX FIXME XXX -- Note that if a function call returns multiple
+  // FIXME -- Note that if a function call returns multiple
   // values, and there is further indexing to perform, then we are
   // ignoring all but the first value.  Is this really what we want to
   // do?  If it is not, then what should happen for stat("file").size,
   // for exmaple?
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -104,17 +104,17 @@ octave_cell::subsref (const std::string&
 	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -52,20 +52,20 @@ octave_char_matrix::valid_as_scalar_inde
   return retval;
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("character matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("character matrix", "real scalar");
 
@@ -74,20 +74,20 @@ octave_char_matrix::double_value (bool) 
 
 Complex
 octave_char_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("character matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -68,23 +68,23 @@ octave_value
 octave_complex::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (idx.valid_scalar_indices ())
     retval = scalar;
   else
     {
-      // XXX FIXME XXX -- this doesn't solve the problem of
+      // FIXME -- this doesn't solve the problem of
       //
       //   a = i; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
-      // XXX FIXME XXX -- using this constructor avoids narrowing the
+      // FIXME -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_complex_matrix (complex_matrix_value ()));
 
       retval = tmp.do_index_op (idx, resize_ok);
     }
 
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -83,17 +83,17 @@ public:
 	      && ! (lo_ieee_isnan (OCTAVE_STD::real (scalar))
 		    || lo_ieee_isnan (OCTAVE_STD::imag (scalar))));
     }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
-  // XXX FIXME XXX ???
+  // FIXME ???
   bool valid_as_scalar_index (void) const { return false; }
   bool valid_as_zero_index (void) const { return false; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -109,32 +109,32 @@ octave_complex_matrix::assign (const oct
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
 }
 
 bool
 octave_complex_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion && Vwarn_imag_to_real)
     gripe_implicit_conversion ("complex matrix", "real scalar");
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
@@ -156,20 +156,20 @@ octave_complex_matrix::matrix_value (boo
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
@@ -398,17 +398,17 @@ octave_complex_matrix::save_binary (std:
       if (m.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (d.numel () > 4096) // XXX FIXME XXX -- make this configurable.
+  else if (d.numel () > 4096) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
 
   const Complex *mtmp = m.data ();
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -105,32 +105,32 @@ octave_sparse_complex_matrix::assign (co
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
 }
 
 bool
 octave_sparse_complex_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion && Vwarn_imag_to_real)
     gripe_implicit_conversion ("complex sparse matrix", "real scalar");
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
@@ -152,20 +152,20 @@ octave_sparse_complex_matrix::matrix_val
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
@@ -233,17 +233,17 @@ octave_sparse_complex_matrix::save_binar
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (matrix.nzmax () > 8192) // XXX FIXME XXX -- make this configurable.
+  else if (matrix.nzmax () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -86,24 +86,24 @@ octave_fcn_handle::subsref (const std::s
 	if (f && f->time_checked () < Vlast_prompt_time)
 	  {
 	    std::string ff_nm = f->fcn_file_name ();
 
 	    time_t tp = f->time_parsed ();
 
 	    if (ff_nm.empty ())
 	      {
-		// XXX FIXME XXX -- need to handle inline and
+		// FIXME -- need to handle inline and
 		// command-line functions here.
 	      }
 	    else
 	      {
 		if (fcn_out_of_date (f, ff_nm, tp))
 		  {
-		    // XXX FIXME XXX -- there is currently no way to
+		    // FIXME -- there is currently no way to
 		    // parse a .m file or reload a .oct file that
 		    // leaves the fbi symbol table untouched.  We need
 		    // a function that will parse the file and return
 		    // a pointer to the new function definition
 		    // without altering the symbol table.
 
 		    if (f->is_nested_function ())
 		      reload_warning ("nested");
@@ -128,17 +128,17 @@ octave_fcn_handle::subsref (const std::s
 	error ("%s cannot be indexed with %c", typ_nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_builtin::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -242,17 +242,17 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   size_t len = 0;
   for (int i = 0; i < ifargs.length (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
   hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
   bool retval = true;
 
-  // XXX FIXME XXX Is there a better way of saving string vectors, than a
+  // FIXME Is there a better way of saving string vectors, than a
   // null padded matrix?
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   hdims[1] = ifargs.length ();
   hdims[0] = len + 1;
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -84,17 +84,17 @@ public:
 
   double
   double_value (bool = false) const
     {
       double retval = lo_ieee_nan_value ();
 
       if (numel () > 0)
 	{
-	  // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+	  // FIXME -- is warn_fortran_indexing the right variable here?
 	  if (Vwarn_fortran_indexing)
 	    gripe_implicit_conversion (type_name (), "real scalar");
 
 	  retval = double (matrix(0));
 	}
       else
 	gripe_invalid_conversion (type_name (), "real scalar");
 
@@ -174,23 +174,23 @@ public:
   octave_value do_index_op (const octave_value_list& idx, int resize_ok)
     {
       octave_value retval;
 
       if (idx.valid_scalar_indices ())
 	retval = scalar;
       else
 	{
-	  // XXX FIXME XXX -- this doesn't solve the problem of
+	  // FIXME -- this doesn't solve the problem of
 	  //
 	  //   a = 1; a([1,1], [1,1], [1,1])
 	  //
 	  // and similar constructions.  Hmm...
 
-	  // XXX FIXME XXX -- using this constructor avoids narrowing the
+	  // FIXME -- using this constructor avoids narrowing the
 	  // 1x1 matrix back to a scalar value.  Need a better solution
 	  // to this problem.
 
 	  octave_value tmp
 	    (new OCTAVE_VALUE_INT_MATRIX_T
 	     (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ())); 
 
 	  retval = tmp.do_index_op (idx, resize_ok);
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -109,17 +109,17 @@ octave_list::subsref (const std::string&
 	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -209,17 +209,17 @@ any_element_greater_than (const SparseMa
 #define SPARSE_MAPPER_LOOP(T, ET, F, M) \
   SPARSE_MAPPER_LOOP_1 (T, ET, F, M, )
 
 octave_value
 octave_mapper::apply (const octave_value& arg) const
 {
   octave_value retval;
 
-  // XXX FIXME XXX -- is_real_type can return true.  Should it really
+  // FIXME -- is_real_type can return true.  Should it really
   // work that way?
 
   if (arg.is_real_type ()
       && (c_c_map_fcn || d_d_map_fcn || d_b_map_fcn)
       && ! (arg.is_string () && ch_map_fcn))
     {
       if (arg.is_scalar_type ())
 	{
@@ -343,17 +343,17 @@ octave_mapper::apply (const octave_value
 	    MAPPER_LOOP (boolNDArray, c_b_map_fcn, cm);
 	  else
 	    error ("%s: unable to handle complex arguments",
 		   name().c_str ());
 	}
     }
   else if (ch_map_fcn)
     {
-      // XXX FIXME XXX -- this could be done in a better way...
+      // FIXME -- this could be done in a better way...
 
       octave_value tmp = arg.convert_to_str ();
 
       if (! error_state)
 	{
 	  charNDArray chm = tmp.char_array_value ();
 
 	  if (! error_state)
@@ -410,17 +410,17 @@ octave_mapper::subsref (const std::strin
 	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // and octave_builtin::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -107,23 +107,23 @@ octave_range::subsref (const std::string
     }
 
   return retval.next_subsref (type, idx);
 }
 
 octave_value
 octave_range::do_index_op (const octave_value_list& idx, int resize_ok)
 {
-  // XXX FIXME XXX -- this doesn't solve the problem of
+  // FIXME -- this doesn't solve the problem of
   //
   //   a = 1:5; a(1, 1, 1)
   //
   // and similar constructions.  Hmm...
 
-  // XXX FIXME XXX -- using this constructor avoids possibly narrowing
+  // FIXME -- using this constructor avoids possibly narrowing
   // the range to a scalar value.  Need a better solution to this
   // problem.
 
   octave_value tmp (new octave_matrix (range.matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
@@ -131,56 +131,56 @@ double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("range", "real scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
 
 octave_value
 octave_range::all (int dim) const
 {
-  // XXX FIXME XXX -- this is a potential waste of memory.
+  // FIXME -- this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.all (dim);
 }
 
 octave_value
 octave_range::any (int dim) const
 {
-  // XXX FIXME XXX -- this is a potential waste of memory.
+  // FIXME -- this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.any (dim);
 }
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
   if (range.nelem () != 0)
     {
-      // XXX FIXME XXX -- this is a potential waste of memory.
+      // FIXME -- this is a potential waste of memory.
 
       Matrix m ((range.matrix_value () . all ()) . all ());
 
       retval = (m.rows () == 1 && m.columns () == 1 && m (0, 0) != 0.0);
     }
 
   return retval;
 }
@@ -191,17 +191,17 @@ octave_range::complex_value (bool) const
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("range", "complex scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -140,17 +140,16 @@ public:
     {
       double b = range.base ();
       return (range.nelem () == 1
 	      && ! xisnan (b) && D_NINT (b) == b && NINTbig (b) == 0);
     }
 
   bool is_numeric_type (void) const { return true; }
 
-  // XXX DO ME XXX
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const
@@ -192,17 +191,17 @@ public:
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
-      // XXX FIXME XXX -- could be more memory efficient by having a
+      // FIXME -- could be more memory efficient by having a
       // special case of the octave_stream::write method for ranges.
 
       return os.write (matrix_value (), block_size, output_type, skip,
 		       flt_fmt);
     }
 
 private:
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -76,70 +76,70 @@ octave_matrix::try_narrowing_conversion 
     retval = new octave_scalar (matrix (0));
 
   return retval;
 }
 
 bool
 octave_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
-// XXX FIXME XXX
+// FIXME
 
 Matrix
 octave_matrix::matrix_value (bool) const
 {
   return matrix.matrix_value ();
 }
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
-// XXX FIXME XXX
+// FIXME
 
 ComplexMatrix
 octave_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
 }
 
 ComplexNDArray
@@ -165,17 +165,17 @@ SparseMatrix
 octave_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (matrix.matrix_value ());
 }
 
 SparseComplexMatrix 
 octave_matrix::sparse_complex_matrix_value (bool) const
 {
-  // XXX FIXME XXX Need a SparseComplexMatrix (Matrix) constructor to make
+  // FIXME Need a SparseComplexMatrix (Matrix) constructor to make
   // this function more efficient. Then this should become
   // return SparseComplexMatrix (matrix.matrix_value ());
   return SparseComplexMatrix (sparse_matrix_value ());
 }
 
 streamoff_array
 octave_matrix::streamoff_array_value (void) const
 {
@@ -229,17 +229,17 @@ octave_matrix::convert_to_str_internal (
 	      return retval;
 	    }
 	  else
 	    {
 	      int ival = NINT (d);
 
 	      if (ival < 0 || ival > UCHAR_MAX)
 		{
-		  // XXX FIXME XXX -- is there something
+		  // FIXME -- is there something
 		  // better we could do?
 
 		  ival = 0;
 
 		  if (! warned)
 		    {
 		      ::warning ("range error for conversion to character value");
 		      warned = true;
@@ -447,17 +447,17 @@ octave_matrix::save_binary (std::ostream
       if (m.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (d.numel () > 8192) // XXX FIXME XXX -- make this configurable.
+  else if (d.numel () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, d.numel ());
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -82,28 +82,28 @@ octave_sparse_matrix::try_narrowing_conv
     retval = new octave_matrix (matrix.matrix_value ());
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::valid_as_scalar_index (void) const
 {
-  // XXX FIXME XXX
+  // FIXME
   return false;
 }
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("real sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "real scalar");
 
@@ -112,20 +112,20 @@ octave_sparse_matrix::double_value (bool
 
 Complex
 octave_sparse_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
+  // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "complex scalar");
 
@@ -217,17 +217,17 @@ octave_sparse_matrix::convert_to_str_int
 		  return retval;
 		}
 	      else
 		{
 		  int ival = NINT (d);
 
 		  if (ival < 0 || ival > UCHAR_MAX)
 		    {
-		      // XXX FIXME XXX -- is there something
+		      // FIXME -- is there something
 		      // better we could do?
 
 		      ival = 0;
 
 		      if (! warned)
 			{
 			  ::warning ("range error for conversion to character value");
 			  warned = true;
@@ -278,17 +278,17 @@ octave_sparse_matrix::save_binary (std::
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (matrix.nzmax () > 8192) // XXX FIXME XXX -- make this configurable.
+  else if (matrix.nzmax () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -57,23 +57,23 @@ octave_value
 octave_scalar::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (idx.valid_scalar_indices ())
     retval = scalar;
   else
     {
-      // XXX FIXME XXX -- this doesn't solve the problem of
+      // FIXME -- this doesn't solve the problem of
       //
       //   a = 1; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
-      // XXX FIXME XXX -- using this constructor avoids narrowing the
+      // FIXME -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_matrix (matrix_value ()));
 
       retval = tmp.do_index_op (idx, resize_ok);
     }
 
@@ -137,17 +137,17 @@ octave_scalar::convert_to_str_internal (
   if (xisnan (scalar))
     ::error ("invalid conversion from NaN to character");
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > UCHAR_MAX)
 	{
-	  // XXX FIXME XXX -- is there something better we could do?
+	  // FIXME -- is there something better we could do?
 
 	  ival = 0;
 
 	  ::warning ("range error for conversion to character value");
 	}
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -141,17 +141,17 @@ octave_char_matrix_str::do_index_op_inte
 }
 
 void
 octave_char_matrix_str::assign (const octave_value_list& idx,
 				const charMatrix& rhs)
 {
   octave_idx_type len = idx.length ();
 
-  // XXX FIXME XXX
+  // FIXME
   charMatrix tmp = rhs;
   if (tmp.rows () == 1 && tmp.columns () == 0)
     tmp.resize (0, 0);    
 
   for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, tmp, Vstring_fill_char);
@@ -254,17 +254,17 @@ std::string
 octave_char_matrix_str::string_value (bool) const
 {
   std::string retval;
 
   if (matrix.ndims () == 2)
     {
       charMatrix chm = matrix.matrix_value ();
 
-      retval = chm.row_as_string (0);  // XXX FIXME??? XXX
+      retval = chm.row_as_string (0);  // FIXME???
     }
   else
     error ("invalid conversion of charNDArray to string");
 
   return retval;
 }
 
 void
@@ -363,17 +363,17 @@ octave_char_matrix_str::load_ascii (std:
 	    }
 	}
       else if (kw == "elements")
 	{
 	  int elements = val;
 
 	  if (elements >= 0)
 	    {
-	      // XXX FIXME XXX -- need to be able to get max length
+	      // FIXME -- need to be able to get max length
 	      // before doing anything.
 
 	      charMatrix chm (elements, 0);
 	      int max_len = 0;
 	      for (int i = 0; i < elements; i++)
 		{
 		  int len;
 		  if (extract_keyword (is, "length", len) && len >= 0)
diff --git a/src/ov-streamoff.cc b/src/ov-streamoff.cc
--- a/src/ov-streamoff.cc
+++ b/src/ov-streamoff.cc
@@ -47,17 +47,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 
 std::streamoff
 octave_streamoff::streamoff_value (void) const
 {
   std::streamoff retval (-1);
 
   if (numel () > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("streamoff array", "scalar streamoff");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("streamoff array", "scalar streamoff");
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -146,17 +146,17 @@ octave_struct::subsref (const std::strin
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
@@ -411,17 +411,17 @@ void
 octave_struct::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_struct::print_raw (std::ostream& os, bool) const
 {
-  // XXX FIXME XXX -- would be nice to print the output in some
+  // FIXME -- would be nice to print the output in some
   // standard order.  Maybe all substructures first, maybe
   // alphabetize entries, etc.
 
   unwind_protect::begin_frame ("octave_struct_print");
 
   unwind_protect_int (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print >= 0)
@@ -704,17 +704,17 @@ the second must be a string.\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = false;
 
-      // XXX FIXME XXX -- should this work for all types that can do
+      // FIXME -- should this work for all types that can do
       // structure reference operations?
 
       if (args(0).is_map () && args(1).is_string ())
 	{
 	  std::string key = args(1).string_value ();
 
 	  Octave_map m = args(0).map_value ();
 
@@ -816,34 +816,34 @@ A(1)\n\
       Cell c = args(0).cell_value ();
 
       if (! error_state)
 	{
 	  octave_value field = args(1);
 
 	  // Field is either cell or character matrix.
 
-	  // XXX FIXME XX -- this could be simplified if we had
+	  // FIXME -- this could be simplified if we had
 	  // cellstr and iscellstr functions available.
 
 	  bool field_is_cell = field.is_cell ();
 
 	  Cell field_cell;
 	  charMatrix field_char;
 
 	  if (field_is_cell)
 	    field_cell = field.cell_value ();
 	  else
 	    field_char = field.char_matrix_value ();
 
 	  if (! error_state)
 	    {
 	      // Retrieve the dimension value.
 
-	      // XXX FIX ME XXX --  int_value () should print out the
+	      // FIXME --  int_value () should print out the
 	      // conversions it does to be Matlab compatible.
 
 	      octave_idx_type dim = args(2).int_value () - 1;
 
 	      if (! error_state)
 		{
 		  dim_vector c_dv = c.dims ();
 		  dim_vector field_dv = field.dims ();
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -158,17 +158,17 @@ octave_value_typeinfo::register_type_con
 bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
 					     octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
-// XXX FIXME XXX -- we should also store all class names and provide a
+// FIXME -- we should also store all class names and provide a
 // way to list them (calling class with nargin == 0?).
 
 int
 octave_value_typeinfo::do_register_type (const std::string& t_name,
 					 const std::string& c_name,
 					 const octave_value& val)
 {
   int i = 0;
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -119,17 +119,17 @@ octave_user_function::stash_fcn_file_nam
 
 void
 octave_user_function::mark_as_system_fcn_file (void)
 {
   if (! file_name.empty ())
     {
       // We really should stash the whole path to the file we found,
       // when we looked it up, to avoid possible race conditions...
-      // XXX FIXME XXX
+      // FIXME
       //
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
       std::string ff_name = fcn_file_in_path (file_name);
 
@@ -206,17 +206,17 @@ octave_user_function::varargout_to_vr_va
   if (sr && sr->is_variable ())
     {
       octave_value v = sr->def ();
 
       Cell c = v.cell_value ();
 
       if (! error_state)
 	{
-	  // XXX FIXME XXX -- should varargout be required to be a
+	  // FIXME -- should varargout be required to be a
 	  // cell array with a single row or column?  If not, should
 	  // we have a cleaner way of doing this operation?
 
 	  int n = c.length ();
 
 	  const octave_value *d = c.data ();
 
 	  for (int i = 0; i < n; i++)
@@ -315,17 +315,17 @@ octave_user_function::subsref (const std
 	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // XXX FIXME XXX -- perhaps there should be an
+  // FIXME -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_builtin::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -87,17 +87,17 @@ DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 bool Vwarn_fortran_indexing;
 
 // Should we warn about conversions from complex to real?
 int Vwarn_imag_to_real;
 
-// XXX FIXME XXX
+// FIXME
 
 // Octave's value type.
 
 std::string
 octave_value::unary_op_as_string (unary_op op)
 {
   std::string retval;
 
@@ -824,17 +824,17 @@ octave_value::assign (assign_op op, cons
   octave_value retval;
 
   make_unique ();
 
   octave_value t_rhs = rhs;
 
   if (op != op_asn_eq)
     {
-      // XXX FIXME XXX -- only do the following stuff if we can't find
+      // FIXME -- only do the following stuff if we can't find
       // a specific function to call to handle the op= operation for
       // the types we have.
 
       octave_value t;
       if (is_constant ())
 	t = subsref (type, idx);
       else
 	{
@@ -872,17 +872,17 @@ octave_value::assign (assign_op op, cons
 
 const octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
     operator = (rhs);
   else
     {
-      // XXX FIXME XXX -- only do the following stuff if we can't find
+      // FIXME -- only do the following stuff if we can't find
       // a specific function to call to handle the op= operation for
       // the types we have.
 
       binary_op binop = op_eq_to_binary_op (op);
 
       if (! error_state)
 	{
 	  octave_value t = do_binary_op (binop, *this, rhs);
@@ -1137,17 +1137,17 @@ octave_value::vector_value (bool force_s
   else if (nc == 1)
     {
       retval.resize (nr);
       for (octave_idx_type i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else if (nr > 0 && nc > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "real vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
@@ -1212,17 +1212,17 @@ octave_value::int_vector_value (bool for
 	      return retval;
 	    }
 
 	  retval (i) = static_cast<int> (d);
 	}
     }
   else if (nr > 0 && nc > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "real vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
@@ -1279,17 +1279,17 @@ octave_value::complex_vector_value (bool
       for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  retval (i) = m (i, 0);
 	}
     }
   else if (nr > 0 && nc > 0)
     {
-      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      // FIXME -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "complex vector");
 
       retval.resize (nr * nc);
       octave_idx_type k = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
@@ -1664,17 +1664,17 @@ octave_value::do_non_const_unary_op (una
   if (idx.empty ())
     {
       do_non_const_unary_op (op);
 
       retval = *this;
     }
   else
     {
-      // XXX FIXME XXX -- only do the following stuff if we can't find a
+      // FIXME -- only do the following stuff if we can't find a
       // specific function to call to handle the op= operation for the
       // types we have.
 
       assign_op assop = unary_op_to_assign_op (op);
 
       retval = assign (assop, type, idx, 1.0);
     }
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -141,17 +141,17 @@ public:
   octave_value (void);
   octave_value (short int i);
   octave_value (unsigned short int i);
   octave_value (int i);
   octave_value (unsigned int i);
   octave_value (long int i);
   octave_value (unsigned long int i);
 
-  // XXX FIXME XXX -- these are kluges.  They turn into doubles
+  // FIXME -- these are kluges.  They turn into doubles
   // internally, which will break for very large values.  We just use
   // them to store things like 64-bit ino_t, etc, and hope that those
   // values are never actually larger than can be represented exactly
   // in a double.
 
 #if defined (HAVE_LONG_LONG_INT)
   octave_value (long long int i);
 #endif
@@ -868,17 +868,17 @@ OV_BINOP_FN (op_struct_ref)
 // for A already defined and a matrix type.
 extern bool Vwarn_fortran_indexing;
 
 // Should we warn about conversions from complex to real?
 extern int Vwarn_imag_to_real;
 
 extern void install_types (void);
 
-// XXX FIXME XXX -- these trait classes probably belong somehwere else...
+// FIXME -- these trait classes probably belong somehwere else...
 
 template <typename T>
 class
 octave_type_traits
 {
 public:
   typedef T val_type;
 };
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -148,17 +148,17 @@ do_sync (const char *msg, int len, bool 
 
 #if defined (EPIPE)
 		  if (errno == EPIPE)
 		    external_pager->setstate (std::ios::failbit);
 #endif
 		}
 	      else
 		{
-		  // XXX FIXME XXX -- omething is not right with the
+		  // FIXME -- omething is not right with the
 		  // pager.  If it died then we should receive a
 		  // signal for that.  If there is some other problem,
 		  // then what?
 		}
 	    }
 	  else
 	    {
 	      std::cout.write (msg, len);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1725,17 +1725,17 @@ finish_colon_expression (tree_colon_expr
 		}
 	    }
 	}
       else
 	{
 	  e->preserve_base ();
 	  delete e;
 
-	  // XXX FIXME XXX -- need to attempt constant folding here
+	  // FIXME -- need to attempt constant folding here
 	  // too (we need a generic way to do that).
 	  retval = base;
 	}
     }
 
   unwind_protect::run_frame ("finish_colon_expression");
 
   return retval;
@@ -1798,17 +1798,17 @@ make_fcn_handle (token *tok_val)
   return retval;
 }
 
 // Make an anonymous function handle.
 
 static tree_constant *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
 {
-  // XXX FIXME XXX -- need to get these from the location of the @ symbol.
+  // FIXME -- need to get these from the location of the @ symbol.
 
   int l = -1;
   int c = -1;
 
   tree_parameter_list *ret_list = 0;
 
   if (stmt && stmt->is_expression ())
     {
@@ -1819,17 +1819,17 @@ make_anon_fcn_handle (tree_parameter_lis
       tree_identifier *id = new tree_identifier (sr);
 
       tree_simple_assignment *asn = new tree_simple_assignment (id, e);
 
       stmt->set_expression (asn);
 
       stmt->set_print_flag (false);
 
-      // XXX FIXME XXX -- would like to delete old_stmt here or
+      // FIXME -- would like to delete old_stmt here or
       // replace expression inside it with the new expression we just
       // created so we don't have to create a new statement at all.
 
       id = new tree_identifier (sr);
 
       ret_list = new tree_parameter_list (id);
     }
 
@@ -2946,17 +2946,17 @@ parse_and_execute (FILE *f)
   while (retval == 0);
 
   unwind_protect::run_frame ("parse_and_execute");
 }
 
 static void
 safe_fclose (void *f)
 {
-  // XXX FIXME XXX -- comments at the end of an input file are
+  // FIXME -- comments at the end of an input file are
   // discarded (otherwise, they would be appended to the next
   // statement, possibly from the command line or another file, which
   // can be quite confusing).
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
   delete tc;
 
@@ -3042,17 +3042,17 @@ text_getc (FILE *f)
 // Eat whitespace and comments from FFILE, returning the text of the
 // comments read if it doesn't look like a copyright notice.  If
 // IN_PARTS, consider each block of comments separately; otherwise,
 // grab them all at once.  If UPDATE_POS is TRUE, line and column
 // number information is updated.  If SAVE_COPYRIGHT is TRUE, then
 // comments that are recognized as a copyright notice are saved in the
 // comment buffer.
 
-// XXX FIXME XXX -- grab_help_text() in lex.l duplicates some of this
+// FIXME -- grab_help_text() in lex.l duplicates some of this
 // code!
 
 static std::string
 gobble_leading_white_space (FILE *ffile, bool in_parts,
 			    bool update_pos, bool save_copyright)
 {
   std::string help_txt;
 
@@ -3287,17 +3287,17 @@ parse_fcn_file (const std::string& ff, b
 
   if (ffile)
     {
       // Check to see if this file defines a function or is just a
       // list of commands.
 
       if (! force_script && is_function_file (ffile))
 	{
-	  // XXX FIXME XXX -- we shouldn't need both the
+	  // FIXME -- we shouldn't need both the
 	  // command_history object and the
 	  // Vsaving_history variable...
 	  command_history::ignore_entries ();
 
 	  unwind_protect::add (restore_command_history, 0);
 
 	  unwind_protect_int (Vecho_executing_commands);
 	  unwind_protect_bool (Vsaving_history);
@@ -3325,17 +3325,17 @@ parse_fcn_file (const std::string& ff, b
 
 	  std::string txt
 	    = gobble_leading_white_space (ffile, true, true, true);
 
 	  help_buf.push (txt);
 
 	  octave_comment_buffer::append (txt);
 
-	  // XXX FIXME XXX -- this should not be necessary.
+	  // FIXME -- this should not be necessary.
 	  gobble_leading_white_space (ffile, false, true, false);
 
 	  int status = yyparse ();
 
 	  if (status != 0)
 	    {
 	      error ("parse error while reading function file %s",
 		     ff.c_str ());
@@ -3343,17 +3343,17 @@ parse_fcn_file (const std::string& ff, b
 	    }
 	}
       else if (exec_script)
 	{
 	  // The value of `reading_fcn_file' will be restored to the
 	  // proper value when we unwind from this frame.
 	  reading_fcn_file = old_reading_fcn_file_state;
 
-	  // XXX FIXME XXX -- we shouldn't need both the
+	  // FIXME -- we shouldn't need both the
 	  // command_history object and the
 	  // Vsaving_history variable...
 	  command_history::ignore_entries ();
 
 	  unwind_protect::add (restore_command_history, 0);
 
 	  unwind_protect_bool (Vsaving_history);
 	  unwind_protect_bool (reading_script_file);
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -281,17 +281,17 @@ pr_min_internal (const Matrix& m)
       }
 
   if (all_inf_or_nan)
     result = 0.0;
 
   return result;
 }
 
-// XXX FIXME XXX -- it would be nice to share more code among these
+// FIXME -- it would be nice to share more code among these
 // functions,..
 
 static void
 set_real_format (bool sign, int digits, bool inf_or_nan, bool int_only,
 		 int &fw)
 {
   static float_format fmt;
 
@@ -1114,20 +1114,20 @@ pr_any_float (const float_format *fmt, s
       if (hex_format)
 	{
 	  equiv tmp;
 	  tmp.d = d;
 
 	  // Unless explicitly asked for, always print in big-endian
 	  // format.
 
-	  // XXX FIXME XXX -- is it correct to swap bytes for VAX
+	  // FIXME -- is it correct to swap bytes for VAX
 	  // formats and not for Cray?
 
-	  // XXX FIXME XXX -- will bad things happen if we are
+	  // FIXME -- will bad things happen if we are
 	  // interrupted before resetting the format flags and fill
 	  // character?
 
 	  oct_mach_info::float_format flt_fmt =
 	    oct_mach_info::native_float_format ();
 
 	  char ofill = os.fill ('0');
 
@@ -1151,17 +1151,17 @@ pr_any_float (const float_format *fmt, s
 	  os.fill (ofill);
 	  os.setf (oflags);	  
 	}
       else if (bit_format)
 	{
 	  equiv tmp;
 	  tmp.d = d;
 
-	  // XXX FIXME XXX -- is it correct to swap bytes for VAX
+	  // FIXME -- is it correct to swap bytes for VAX
 	  // formats and not for Cray?
 
 	  oct_mach_info::float_format flt_fmt =
 	    oct_mach_info::native_float_format ();
 
 	  if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
 	      || flt_fmt == oct_mach_info::flt_fmt_cray
 	      || flt_fmt == oct_mach_info::flt_fmt_unknown)
@@ -1926,17 +1926,17 @@ octave_print_internal (std::ostream& os,
       PRINT_ND_ARRAY (os, nda, boolNDArray, bool, boolMatrix);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax,
-		       int /* extra_indent XXX FIXME XXX */,
+		       int /* extra_indent FIXME */,
 		       bool pr_as_string)
 {
   if (pr_as_string)
     {
       octave_idx_type nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
@@ -2002,17 +2002,17 @@ octave_print_internal (std::ostream& os,
 
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const ArrayN<std::string>& nda,
 		       bool pr_as_read_syntax, int /* extra_indent */)
 {
-  // XXX FIXME XXX -- this mostly duplicates the code in the
+  // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     {
       os << nda(0);
     }
@@ -2060,17 +2060,17 @@ octave_print_internal (std::ostream& os,
 	  idx(0) = idx_vector (':');
 	  idx(1) = idx_vector (':');
 
 	  for (int k = 2; k < ndims; k++)
 	    idx(k) = idx_vector (ra_idx(k) + 1);
 
 	  Array2<std::string> page (nda.index (idx), nr, nc);
 
-	  // XXX FIXME XXX -- need to do some more work to put these
+	  // FIXME -- need to do some more work to put these
 	  // in neatly aligned columns...
 
 	  octave_idx_type n_rows = page.rows ();
 	  octave_idx_type n_cols = page.cols ();
 
 	  os << nm << " =\n\n";
 
 	  for (octave_idx_type ii = 0; ii < n_rows; ii++)
@@ -2177,17 +2177,17 @@ pr_int (std::ostream& os, const T& d, in
     }
 }
 
 template <class T>
 void
 octave_print_internal (std::ostream& os, const intNDArray<T>& nda,
 		       bool pr_as_read_syntax, int extra_indent)
 {
-  // XXX FIXME XXX -- this mostly duplicates the code in the
+  // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal (os, nda (0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
@@ -2394,17 +2394,17 @@ octave_print_internal (std::ostream& os,
 	    {
 	      os << "\n";
 	      increment_index (ra_idx, dims, 2);
 	    }
 	}
     }
 }
 
-// XXX FIXME XXX -- this is not the right spot for this...
+// FIXME -- this is not the right spot for this...
 
 template void
 pr_int (std::ostream&, const octave_int8&, int);
 
 template void
 pr_int (std::ostream&, const octave_int16&, int);
 
 template void
@@ -2469,17 +2469,17 @@ octave_print_internal (std::ostream& os,
     {
       if (free_format)
 	os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
       else
 	pr_int (os, val);
     }
 }
 
-// XXX FIXME XXX -- this is not the right spot for this...
+// FIXME -- this is not the right spot for this...
 
 template void
 octave_print_internal (std::ostream&, const octave_int8&, bool);
 
 template void
 octave_print_internal (std::ostream&, const octave_int16&, bool);
 
 template void
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -81,17 +81,17 @@ int
 tree_argument_list::nargout_count (void) const
 {
   int retval = 0;
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
-      // XXX FIXME XXX -- need to be able to determine whether elt is
+      // FIXME -- need to be able to determine whether elt is
       // an expression that could evaluate to a cs-list object, and if
       // so, how many elements are in that list.  Ugly!
 
       retval++;
     }
 
   return retval;
 }
@@ -173,17 +173,17 @@ tree_argument_list::convert_to_const_vec
 
       unwind_protect_const_ptr (indexed_object);
 
       indexed_object = object;
     }
 
   int len = length ();
 
-  // XXX FIXME XXX -- would be nice to know in advance how largs args
+  // FIXME -- would be nice to know in advance how largs args
   // needs to be even when we have a list containing an all_va_args
   // token.
 
   octave_value_list args;
   int args_len = len;
   args.resize (args_len);
 
   iterator p = begin ();
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -64,17 +64,17 @@ tree_simple_assignment::rvalue (int narg
   if (nargout > 1)
     error ("invalid number of output arguments for expression X = RHS");
   else
     retval = rvalue ();
 
   return retval;
 }
 
-// XXX FIXME XXX -- this works, but it would look a little better if
+// FIXME -- this works, but it would look a little better if
 // it were broken up into a couple of separate functions.
 
 octave_value
 tree_simple_assignment::rvalue (void)
 {
   octave_value retval;
 
   if (error_state)
@@ -191,17 +191,17 @@ tree_multi_assignment::rvalue (void)
   octave_value_list tmp = rvalue (1);
 
   if (! tmp.empty ())
     retval = tmp(0);
 
   return retval;
 }
 
-// XXX FIXME XXX -- this works, but it would look a little better if
+// FIXME -- this works, but it would look a little better if
 // it were broken up into a couple of separate functions.
 
 octave_value_list
 tree_multi_assignment::rvalue (int)
 {
   octave_value_list retval;
 
   if (error_state)
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -168,17 +168,17 @@ do_unwind_protect_cleanup_code (void *pt
   tree_break_command::breaking = 0;
 
   if (list)
     list->eval ();
 
   // The unwind_protects are popped off the stack in the reverse of
   // the order they are pushed on.
 
-  // XXX FIXME XXX -- these statements say that if we see a break or
+  // FIXME -- these statements say that if we see a break or
   // return statement in the cleanup block, that we want to use the
   // new value of the breaking or returning flag instead of restoring
   // the previous value.  Is that the right thing to do?  I think so.
   // Consider the case of
   //
   //   function foo ()
   //     unwind_protect
   //       stderr << "1: this should always be executed\n";
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -154,17 +154,17 @@ tree_identifier::rvalue (int nargout)
   bool script_file_executed = false;
 
   octave_value val = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
       if (val.is_defined ())
 	{
-	  // XXX GAGME XXX -- this would be cleaner if we required
+	  // GAGME -- this would be cleaner if we required
 	  // parens to indicate function calls.
 	  //
 	  // If this identifier refers to a function, we need to know
 	  // whether it is indexed so that we can do the same thing
 	  // for `f' and `f()'.  If the index is present, return the
 	  // function object and let tree_index_expression::rvalue
 	  // handle indexing.  Otherwise, arrange to call the function
 	  // here, so that we don't return the function definition as
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -210,17 +210,17 @@ tree_index_expression::get_struct_index
   return fn;
 }
 
 Octave_map
 tree_index_expression::make_arg_struct (void) const
 {
   int n = args.size ();
 
-  // XXX FIXME XXX -- why not just make these Cell objects?
+  // FIXME -- why not just make these Cell objects?
   octave_value_list subs_list (n, octave_value ());
   octave_value_list type_list (n, octave_value ());
 
   std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
   std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
   std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
 
   Octave_map m;
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -374,17 +374,17 @@ tree_simple_for_command::eval (void)
 	  {
 	    cm_tmp = rhs.complex_array_value ();
 	    dv = cm_tmp.dims ();
 	  }
 
 	if (error_state)
 	  goto cleanup;
 
-	// XXX FIXME XXX -- maybe we need a function for this?
+	// FIXME -- maybe we need a function for this?
 	int ndims = dv.length ();
 	for (int i = 2; i < ndims; i++)
 	  dv(1) *= dv(i);
 
 	if (dv(1) > 0)
 	  {
 	    if (rhs.is_real_type ())
 	      {
@@ -426,17 +426,17 @@ tree_simple_for_command::eval (void)
 	  }
       }
     else if (rhs.is_cell ())
       {
 	Cell c_tmp = rhs.cell_value ();
 
 	dim_vector dv = c_tmp.dims ();
 
-	// XXX FIXME XXX -- maybe we need a function for this?
+	// FIXME -- maybe we need a function for this?
 	int ndims = dv.length ();
 	for (int i = 2; i < ndims; i++)
 	  dv(1) *= dv(i);
 
 	if (dv(1) > 0)
 	  {
 	    if (ndims > 2)
 	      c_tmp = c_tmp.reshape (dv);
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -117,17 +117,17 @@ tree_switch_case::~tree_switch_case (voi
 {
   delete label;
   delete list;
   delete lead_comm;
 }
 
 
 // Compare two octave values, returning true if equal, false if not
-// XXX FIXME XXX --- should be member or friend of octave_value class.
+// FIXME --- should be member or friend of octave_value class.
 
 static bool
 equal (const octave_value& val, const octave_value& test)
 {
   bool retval = false;
 
   // If there is no op_eq for these types, we can't compare values.
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -99,22 +99,22 @@ tree_statement::eval (bool silent, int n
       maybe_echo_code (in_function_body);
 
       if (cmd)
 	cmd->eval ();
       else
 	{
 	  expr->set_print_flag (pf);
 
-	  // XXX FIXME XXX -- maybe all of this should be packaged in
+	  // FIXME -- maybe all of this should be packaged in
 	  // one virtual function that returns a flag saying whether
 	  // or not the expression will take care of binding ans and
 	  // printing the result.
 
-	  // XXX FIXME XXX -- it seems that we should just have to
+	  // FIXME -- it seems that we should just have to
 	  // call expr->rvalue () and that should take care of
 	  // everything, binding ans as necessary?
 
 	  bool do_bind_ans = false;
 
 	  bool script_file_executed = false;
 
 	  if (expr->is_identifier ())
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -196,17 +196,17 @@ octave_set_signal_handler (int sig, sig_
 
   if (sig == SIGALRM)
     {
 #if defined (SA_INTERRUPT)
       act.sa_flags |= SA_INTERRUPT;
 #endif
     }
 #if defined (SA_RESTART)
-  // XXX FIXME XXX -- Do we also need to explicitly disable SA_RESTART?
+  // FIXME -- Do we also need to explicitly disable SA_RESTART?
   else if (restart_syscalls)
     act.sa_flags |= SA_RESTART;
 #endif
 
   sigemptyset (&act.sa_mask);
   sigemptyset (&oact.sa_mask);
 
   sigaction (sig, &act, &oact);
@@ -483,17 +483,17 @@ w32_sigint_handler (DWORD sig)
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
 	user_abort(sig_name, sig);
         break;
     }
 
   // Return TRUE if the event was handled, or FALSE if another handler 
   // should be called.
-  // XXX FIXME XXX check that windows terminates the thread.
+  // FIXME check that windows terminates the thread.
   return TRUE;
 }
 #endif /* w32_sigint_handler */
 
 
 octave_interrupt_handler
 octave_catch_interrupts (void)
 {
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -71,17 +71,17 @@ Free Software Foundation, Inc.
 #define UNBLOCK_CHILD(ovar) sigprocmask (SIG_SETMASK, &ovar, 0)
 #else
 #define BLOCK_CHILD(nvar, ovar) ovar = sigblock (sigmask (SIGCHLD))
 #define UNBLOCK_CHILD(ovar) sigsetmask (ovar)
 #endif
 
 typedef RETSIGTYPE sig_handler (int);
 
-// XXX FIXME XXX -- the data should probably be private...
+// FIXME -- the data should probably be private...
 
 struct
 octave_interrupt_handler
 {
 #ifdef SIGINT
   sig_handler *int_handler;
 #endif
 
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -209,17 +209,17 @@ xpow (const SparseComplexMatrix& a, doub
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// XXX FIXME XXX -- these functions need to be fixed so that things
+// FIXME -- these functions need to be fixed so that things
 // like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
@@ -295,34 +295,34 @@ elem_xpow (double a, const SparseComplex
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, double b)
 {
-  // XXX FIXME XXX What should a .^ 0 give?? Matlab gives a 
+  // FIXME What should a .^ 0 give?? Matlab gives a 
   // sparse matrix with same structure as a, which is strictly
   // incorrect. Keep compatiability.
 
   octave_value retval;
 
   octave_idx_type nz = a.nzmax ();
 
   if (b <= 0.0)
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       if (static_cast<int> (b) != b && a.any_element_is_negative ())
 	{
 	  ComplexMatrix result (nr, nc, Complex (pow (0.0, b)));
 
-	  // XXX FIXME XXX -- avoid apparent GNU libm bug by
+	  // FIXME -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 	  Complex btmp (b);
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
 		OCTAVE_QUIT;
 	      
@@ -350,17 +350,17 @@ elem_xpow (const SparseMatrix& a, double
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 
-	  // XXX FIXME XXX -- avoid apparent GNU libm bug by
+	  // FIXME -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 
 	  Complex atmp (a.data (i));
 	  Complex btmp (b);
 
 	  result.data (i) = pow (atmp, btmp);
 	}
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -470,34 +470,34 @@ symbol_record::dimensions_string_req_fir
 }
 
 // Calculate how much space needs to be reserved for the the
 // dimensions string.  For example,
 //
 //   mat is a 12x3 matrix
 //            ^^^^ => 4 columns
 //
-// XXX FIXME XXX -- why not just use the dim_vector::str () method?
+// FIXME -- why not just use the dim_vector::str () method?
 
 int
 symbol_record::dimensions_string_req_total_space (int print_dims) const
 {
   std::string dim_str = "";
   std::stringstream ss;
 
   ss << make_dimensions_string (print_dims);
   dim_str = ss.str ();
 
   return dim_str.length ();
 }
 
 // Make the dimensions-string.  For example: mat is a 2x3 matrix.
 //                                                    ^^^
 //
-// XXX FIXME XXX -- why not just use the dim_vector::str () method?
+// FIXME -- why not just use the dim_vector::str () method?
 
 std::string
 symbol_record::make_dimensions_string (int print_dims) const
 {
   // Calculating dimensions.
 
   std::string dim_str = "";
   std::stringstream ss;
@@ -792,17 +792,17 @@ symbol_table::rename (const std::string&
       prev = ptr;
       ptr = ptr->next ();
     }
 
   error ("unable to rename `%s' to `%s'", old_name.c_str (),
 	 new_name.c_str ());
 }
 
-// XXX FIXME XXX -- it would be nice to eliminate a lot of the
+// FIXME -- it would be nice to eliminate a lot of the
 // following duplicate code.
 
 void
 symbol_table::clear (void)
 {
   for (unsigned int i = 0; i < table_size; i++)
     {
       symbol_record *ptr = table[i].next ();
@@ -1399,17 +1399,17 @@ symbol_table::parse_whos_line_format (Ar
 	  pos = cmd.find (';');
 	  if (pos != NPOS)
 	    cmd = cmd.substr (0, pos+1);
 	  else
 	    error ("parameter without ; in whos_line_format");
 
 	  idx += cmd.length ();
 
-	  // XXX FIXME XXX -- use iostream functions instead of sscanf!
+	  // FIXME -- use iostream functions instead of sscanf!
 
 	  if (cmd.find_first_of ("crl") != 1)
 	    items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d:%d;",
 			    &garbage, &param.command, &a, &b, &c, &balance);
 	  else
 	    items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d:%d;",
 			    &garbage, &param.modifier, &param.command,
 			    &a, &b, &c, &balance) - 1;
@@ -1534,17 +1534,17 @@ symbol_table::maybe_list (const char *he
 
   // This method invokes print_symbol_info_line to print info on every
   // symbol.
 
   int status = 0;
 
   if (show_verbose)
     {
-      // XXX FIXME XXX Should separate argv to lists with and without dots.
+      // FIXME Should separate argv to lists with and without dots.
       Array<symbol_record *> xsymbols = symbol_list (argv, type, scope);
       Array<symbol_record *> xsubsymbols = subsymbol_list (argv, type, scope);
 
       int sym_len = xsymbols.length (), subsym_len = xsubsymbols.length (),
 	len = sym_len + subsym_len;
  
       Array<symbol_record *> symbols (dim_vector (len, 1));
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -150,17 +150,17 @@ private:
       { return (symbol_type & symbol_record::BUILTIN_VARIABLE); }
 
     bool is_builtin_function (void) const
       { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
 
     bool is_dld_function (void) const
       { return (symbol_type & symbol_record::DLD_FUNCTION); }
 
-    // XXX FIXME XXX
+    // FIXME
     bool is_map_element (const std::string& /* elts */) const
       { return false; }
 
     bool is_defined (void) const
       { return definition.is_defined (); }
 
     bool is_read_only (void) const
       { return read_only; }
@@ -270,17 +270,17 @@ public:
   typedef int (*change_function) (void);
 
   symbol_record (void)
     : formal_param (false), linked_to_global (false),
       tagged_static (false), can_hide_function (true),
       visible (true), nm (), chg_fcn (0),
       definition (new symbol_def ()), next_elem (0) { }
 
-  // XXX FIXME XXX -- kluge alert!  We obviously need a better way of
+  // FIXME -- kluge alert!  We obviously need a better way of
   // handling allow_shadow!
 
   symbol_record (const std::string& n, symbol_record *nxt)
     : formal_param (false), linked_to_global (false),
       tagged_static (false), can_hide_function (n != "__end__"),
       visible (true), nm (n), chg_fcn (0),
       definition (new symbol_def ()), next_elem (nxt) { }
 
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -292,17 +292,17 @@ system-dependent error message.\n\
 	{
 	  int fid = strm.file_number ();
 
 	  int req = args(1).int_value (true);
 	  int arg = args(2).int_value (true);
 
 	  if (! error_state)
 	    {
-	      // XXX FIXME XXX -- Need better checking here?
+	      // FIXME -- Need better checking here?
 	      if (fid < 0)
 		error ("fcntl: invalid file id");
 	      else
 		{
 		  std::string msg;
 
 		  int status = octave_syscalls::fcntl (fid, req, arg, msg);
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -108,17 +108,17 @@ BSD_init (void)
 
 void
 w32_set_quiet_shutdown (void)
 {
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
   // Let the user close the console window or shutdown without the
   // pesky dialog.
   //
-  // XXX FIXME XXX -- should this be user configurable?
+  // FIXME -- should this be user configurable?
   SetProcessShutdownParameters (0x280, SHUTDOWN_NORETRY);
 #endif
 }
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
 void
 MINGW_signal_cleanup (void)
 {
@@ -512,17 +512,17 @@ Set the value of the environment variabl
 	error ("putenv: first argument should be a string");
     }
   else
     print_usage ("putenv");
 
   return retval;
 }
 
-// XXX FIXME XXX -- perhaps kbhit should also be able to print a prompt?
+// FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} kbhit ()\n\
 Read a single keystroke from the keyboard. If called with one\n\
 argument, don't wait for a keypress.  For example,\n\
 \n\
 @example\n\
@@ -539,17 +539,17 @@ x = kbhit (1);\n\
 \n\
 @noindent\n\
 identical to the above example, but don't wait for a keypress,\n\
 returning the empty string if no key is available.\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  // XXX FIXME XXX -- add timeout and default value args?
+  // FIXME -- add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
 	c = 0;
 
@@ -671,17 +671,17 @@ of time less than one second, @code{usle
 	}
     }
   else
     print_usage ("usleep");
 
   return retval;
 }
 
-// XXX FIXME XXX -- maybe this should only return 1 if IEEE floating
+// FIXME -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isieee ()\n\
 Return 1 if your computer claims to conform to the IEEE standard for\n\
 floating point calculations.\n\
 @end deftypefn")
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -407,17 +407,17 @@ run_command_and_return_output (const std
   if (cmd)
     {
       unwind_protect::add (cleanup_iprocstream, cmd);
 
       if (*cmd)
 	{
 	  std::ostringstream output_buf;
 
-	  // XXX FIXME XXX -- Perhaps we should read more than one
+	  // FIXME -- Perhaps we should read more than one
 	  // character at a time and find a way to avoid the call to
 	  // octave_usleep as well?
 
 	  // This is a bit of a kluge...
 
 	  octave_usleep (100);
 
 	  char ch;
@@ -544,17 +544,17 @@ variable @code{status} to the integer @s
 	    {
 #ifdef HAVE_FORK
 	      pid_t pid = fork ();
 
 	      if (pid < 0) 
 		error ("system: fork failed -- can't create child process");
 	      else if (pid == 0)
 		{
-		  // XXX FIXME XXX -- should probably replace this
+		  // FIXME -- should probably replace this
 		  // call with something portable.
 
 		  execl ("/bin/sh", "sh", "-c", cmd_str.c_str (),
 			 static_cast<void *> (0));
 
 		  panic_impossible ();
 		}
 	      else
@@ -586,17 +586,17 @@ variable @code{status} to the integer @s
 
   unwind_protect::run_frame ("Fsystem");
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
-// XXX FIXME XXX -- this should really be static, but that causes
+// FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::stack<std::string> octave_atexit_functions;
 
 void
 do_octave_atexit (void)
 {
   static bool deja_vu = false;
 
@@ -614,17 +614,17 @@ do_octave_atexit (void)
     }
 
   if (! deja_vu)
     {
       deja_vu = true;
 
       command_editor::restore_terminal_state ();
 
-      // XXX FIXME XXX -- is this needed?  Can it cause any trouble?
+      // FIXME -- is this needed?  Can it cause any trouble?
       raw_mode (0);
 
       octave_history_write_timestamp ();
 
       command_history::clean_up_and_save ();
 
       close_files ();
 
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -132,17 +132,17 @@ saved_variable::~saved_variable (void)
 {
   switch (type_tag)
     {
     case string_type:
       delete str_value;
       break;
 
     case generic:
-      // XXX FIXME XXX
+      // FIXME
       // delete [] gen_ptr_value;
       break;
 
     default:
       break;
     }
 }
 
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -963,17 +963,17 @@ octave_vformat (std::ostream& os, const 
       retval = strlen (s);
     }
 
 #endif
 
   return retval;
 }
 
-/* XXX FIXME XXX -- we really need a configure test for this.  */
+/* FIXME -- we really need a configure test for this.  */
 
 #if defined __GNUC__ && __GNUC__ >= 3
 #define HAVE_C99_VSNPRINTF 1
 #endif
 
 // We manage storage.  User should not free it, and its contents are
 // only valid until next call to vsnprintf.
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -672,17 +672,17 @@ generate_struct_completions (const std::
 	  if (tmp.is_defined () && tmp.is_map ())
 	    names = tmp.map_keys ();
 	}
     }
 
   return names;
 }
 
-// XXX FIXME XXX -- this will have to be much smarter to work
+// FIXME -- this will have to be much smarter to work
 // "correctly".
 
 bool
 looks_like_struct (const std::string& text)
 {
   bool retval = (! text.empty ()
 		 && text != "."
 		 && text.find_first_of (file_ops::dir_sep_chars) == NPOS
@@ -1025,17 +1025,17 @@ symbol_out_of_date (symbol_record *sr)
 	  if (! ff.empty ())
 	    {
 	      if (fcn->time_checked () < Vlast_prompt_time)
 		{
 		  time_t tp = fcn->time_parsed ();
 
 		  std::string nm = fcn->name ();
 
-		  // XXX FIXME XXX -- the following code is repeated
+		  // FIXME -- the following code is repeated
 		  // in load_fcn_from_file in parse.y.
 
 		  string_vector names (2);
 
 		  int nm_len = nm.length ();
 
 		  std::string file;
 
@@ -1074,17 +1074,17 @@ symbol_out_of_date (symbol_record *sr)
 		      if (full_sr)
 			{
 			  octave_value v = full_sr->def ();
 
 			  if (v.is_function ())
 			    {
 			      // OK, swap the aliases around.
 
-			      // XXX FIXME XXX -- this is a bit
+			      // FIXME -- this is a bit
 			      // tricky, so maybe some refactoring is
 			      // in order here too...
 
 			      symbol_record *short_sr = fbi_sym_tab->lookup (nm);
 
 			      if (short_sr)
 				short_sr->alias (full_sr);
 
@@ -1452,17 +1452,17 @@ Set the documentation string for @var{sy
 	}
     }
   else
     print_usage ("document");
 
   return retval;
 }
 
-// XXX FIXME XXX -- this function is duplicated in symtab.cc with the
+// FIXME -- this function is duplicated in symtab.cc with the
 // name maybe_list_cmp_fcn.
 
 static int
 symbol_record_name_compare (const void *a_arg, const void *b_arg)
 {
   const symbol_record *a = static_cast<const symbol_record *> (a_arg);
   const symbol_record *b = static_cast<const symbol_record *> (b_arg);
 
@@ -1528,17 +1528,17 @@ do_who (int argc, const string_vector& a
   if (show_verbose && ! (show_builtins || show_functions || show_variables))
     {
       show_functions = at_top_level ();
       show_variables = 1;
     }
 
   if (return_list)
     {
-      // XXX FIXME XXX -- maybe symbol_list should return a std::list
+      // FIXME -- maybe symbol_list should return a std::list
       // object instead of an Array.
 
       dim_vector dv (0, 0);
 
       Array<symbol_record *> s1 (dv);
       Array<symbol_record *> s2 (dv);
       Array<symbol_record *> s3 (dv);
       Array<symbol_record *> s4 (dv);
@@ -2159,17 +2159,17 @@ static inline bool
 do_clear_variable_pattern (const std::string& pat)
 {
   return curr_sym_tab->clear_variable_pattern (pat);
 }
 
 static inline bool
 do_clear_symbol_pattern (const std::string& pat)
 {
-  // XXX FIXME XXX -- if we have a variable v1 and a function v2 and
+  // FIXME -- if we have a variable v1 and a function v2 and
   // someone says clear v*, we will clear the variable but not the
   // function.  Is that really what should happen?  (I think it is
   // what Matlab does.)
 
   bool cleared = curr_sym_tab->clear_variable_pattern (pat);
 
   if (! cleared)
     cleared = do_clear_function_pattern (pat);
@@ -2296,17 +2296,17 @@ do_clear_symbols (const string_vector& a
 		  bool exclusive = false)
 {
   if (idx == argc)
     do_clear_variables ();
   else
     {
       if (exclusive)
 	{
-	  // XXX FIXME XXX -- is this really what we want, or do we
+	  // FIXME -- is this really what we want, or do we
 	  // somehow want to only clear the functions that are not
 	  // shadowed by local variables?  It seems that would be a
 	  // bit harder to do.
 
 	  do_clear_variables (argv, argc, idx, exclusive);
 	  do_clear_functions (argv, argc, idx, exclusive);
 	}
       else
@@ -2601,17 +2601,17 @@ Print symbol table information for the s
 	print_usage ("__print_symbol_info__");
     }
   else
     print_usage ("__print_symbol_info__");
 
   return retval;
 }
 
-// XXX FIXME XXX -- some of these should do their own checking to be
+// FIXME -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
 static int
 ignore_function_time_stamp (void)
 {
   int pref = 0;
 
   std::string val = builtin_string_variable ("ignore_function_time_stamp");
@@ -2624,17 +2624,17 @@ ignore_function_time_stamp (void)
 	pref = 1;
     }
 
   Vignore_function_time_stamp = pref;
 
   return 0;
 }
 
-// XXX FIXME XXX -- there still may be better places for some of these
+// FIXME -- there still may be better places for some of these
 // to be defined.
 
 void
 symbols_of_variables (void)
 {
   DEFVAR (ans, , 0,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} ans\n\
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -177,17 +177,17 @@ xpow (const Matrix& a, double b)
 	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
-	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
+	      // FIXME -- we shouldn't do this if the exponent is
 	      // large...
 
 	      Matrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
 		  octave_idx_type info;
@@ -373,17 +373,17 @@ xpow (const ComplexMatrix& a, double b)
 	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
-	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
+	      // FIXME -- we shouldn't do this if the exponent is
 	      // large...
 
 	      ComplexMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
 		  octave_idx_type info;
@@ -472,17 +472,17 @@ xpow (const ComplexMatrix& a, const Comp
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// XXX FIXME XXX -- these functions need to be fixed so that things
+// FIXME -- these functions need to be fixed so that things
 // like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
@@ -870,17 +870,17 @@ elem_xpow (const ComplexMatrix& a, const
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_N_d    | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// XXX FIXME XXX -- these functions need to be fixed so that things
+// FIXME -- these functions need to be fixed so that things
 // like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
diff --git a/test/octave.test/linalg/qr-2.m b/test/octave.test/linalg/qr-2.m
--- a/test/octave.test/linalg/qr-2.m
+++ b/test/octave.test/linalg/qr-2.m
@@ -1,10 +1,10 @@
 a = [0, 2, 1; 2, 1, 2];
 
-[q, r, p] = qr (a);  # not giving right dimensions. XXX FIXME XXX
+[q, r, p] = qr (a);  # not giving right dimensions. FIXME
 
 [qe, re, pe] = qr (a, 0);
 
 (size (q) == [2, 2] && size (r) == [2, 3] && size (p) == [3, 3]
  && abs (q * r - a * p) < sqrt (eps)
  && size (qe) == [2, 2] && size (re) == [2, 3] && size (pe) == [1, 3]
  && abs (qe * re - a(:,pe)) < sqrt (eps))
diff --git a/test/test_error.m b/test/test_error.m
--- a/test/test_error.m
+++ b/test/test_error.m
@@ -15,17 +15,17 @@
 %!error <foo> f ();
 
 %% test/octave.test/error/error-3.m
 %!error error ();
 
 %% test/octave.test/error/error-4.m
 %!error <foo> error ("foo\n");
 
-%% XXX FIXME XXX Why can't I use %!warning <foo> f;
+%% FIXME Why can't I use %!warning <foo> f;
 %% test/octave.test/error/warning-1.m
 %!function g ()
 %! warning ("foo");
 %!function f ()
 %! g;
 %!test
 %! fail("f","warning","foo");
 
@@ -36,17 +36,17 @@
 %! warning ("on","backtrace");
 %! st.state = "on";
 %! assert(warning ("query","backtrace"),st);
 %! warning ("off","backtrace");
 %! st.state = "off";
 %! assert(warning ("query","backtrace"),st);
 %! warning (ws.state,"backtrace");
 
-%% XXX FIXME XXX This test no longer makes sense with new warning syntax
+%% FIXME This test no longer makes sense with new warning syntax
 %% test/octave.test/error/warning-3.m
 %!#warning <foo> warning ("foo", 1);
 
 %% test/octave.test/error/usage-1.m
 %!function g () 
 %! usage ("foo");
 %!function f () 
 %! g (); 
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -8,17 +8,17 @@
 %!test
 %! eval ("", "error('Shouldn't get here');");
 
 %% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
-%% XXX FIXME XXX This is redundant with the changes to the above
+%% FIXME This is redundant with the changes to the above
 %% test/octave.test/eval-catch/eval-catch-4.m
 
 %% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
 %! assert(lasterr()(1:20),"error: `a' undefined");
 %! assert(str(1:20),"error: `a' undefined");
 
diff --git a/test/test_eval.m b/test/test_eval.m
--- a/test/test_eval.m
+++ b/test/test_eval.m
@@ -10,17 +10,17 @@
 %! x = 1;
 %! assert(eval ("x;"));
 
 %% test/octave.test/eval/eval-3.m
 %!test
 %! x = 1;
 %! assert(eval ("x;"),1);
 
-%% XXX FIXME XXX
+%% FIXME
 %% Disable this test as adding the ";" is redundant with eval-1 and
 %% in any case is a syntax error with assert
 %% test/octave.test/eval/eval-4.m
 %!#test
 %! x = 1;
 %! assert(eval ("x");,1);
 
 %% test/octave.test/eval/eval-5.m
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -183,17 +183,17 @@
 %! [load_status, load_files] = testls (1);
 %! 
 %! for f = [save_files, load_files]
 %!   unlink (f{1});
 %! endfor
 %! 
 %! assert(save_status && load_status);
 
-%% XXX FIXME XXX Disable this test as it writes to stdout and there is no easy
+%% FIXME Disable this test as it writes to stdout and there is no easy
 %% way to recover output. Need to spawn new octave process and pipe stdout
 %% somewhere to treat this case
 %% test/octave.test/io/puts-1.m
 %!#test
 %! puts ("foo\n");
 
 %% test/octave.test/io/puts-2.m
 %!assert(puts (1),-1);
@@ -509,17 +509,17 @@
 %!error <Invalid call to feof.*> feof ();
 
 %% test/octave.test/io/feof-2.m
 %!error <Invalid call to feof.*> feof (1, 2);
 
 %% test/octave.test/io/feof-3.m
 %!error feof ("foo");
 
-%% XXX FIXME XXX trimerr in test.m finds and strips ".*ferror:"!!
+%% FIXME trimerr in test.m finds and strips ".*ferror:"!!
 %% So use fail for the next two tests instead.
 %% test/octave.test/io/ferror-1.m
 %!test
 %! fail("ferror ();","Invalid call to ferror.*");
 
 %% test/octave.test/io/ferror-2.m
 %!test
 %! fail("ferror (1, \"clear\", 2);","Invalid call to ferror.*"); 
diff --git a/test/test_linalg.m b/test/test_linalg.m
--- a/test/test_linalg.m
+++ b/test/test_linalg.m
@@ -173,17 +173,17 @@
 %! && abs (q * r - a) < sqrt (eps)
 %! && size (qe) == [2, 2] && size (re) == [2, 3]
 %! && abs (qe * re - a) < sqrt (eps)));
 
 %% test/octave.test/linalg/qr-2.m
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
 %! 
-%! [q, r, p] = qr (a);  # not giving right dimensions. XXX FIXME XXX
+%! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
 %! 
 %! [qe, re, pe] = qr (a, 0);
 %! 
 %! assert((size (q) == [2, 2] && size (r) == [2, 3] && size (p) == [3, 3]
 %! && abs (q * r - a * p) < sqrt (eps)
 %! && size (qe) == [2, 2] && size (re) == [2, 3] && size (pe) == [1, 3]
 %! && abs (qe * re - a(:,pe)) < sqrt (eps)));
 
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -90,25 +90,25 @@
 %! warn_resize_on_range_error = wrre;
 
 %% test/octave.test/prefer/prefer-18.m
 %!test
 %! clear a; 
 %! a(1) = 1; a(2) = 2;
 %! assert(all (a == [1,2]));
 
-%% XXX FIXME XXX How the hell do I test this one in test/assert 
+%% FIXME How the hell do I test this one in test/assert 
 %% test/octave.test/prefer/prefer-19.m
 %!#test
 %! pid = print_answer_id_name
 %! print_answer_id_name = 0;
 %! a = 1
 %! print_answer_id_name = pid;
 
-%% XXX FIXME XXX How the hell do I test this one in test/assert 
+%% FIXME How the hell do I test this one in test/assert 
 %% test/octave.test/prefer/prefer-20.m
 %!#test
 %! pid = print_answer_id_name
 %! print_answer_id_name = 1;
 %! a = 1
 %! print_answer_id_name = pid;
 
 %% test/octave.test/prefer/prefer-21.m
@@ -131,17 +131,17 @@
 %! print_empty_dimensions = ped;
 
 %% test/octave.test/prefer/prefer-23.m
 %!assert(all (size (inv ([])) == [0, 0]));
 
 %% test/octave.test/prefer/prefer-24.m
 %!assert(all (svd ([]) == zeros (0, 1)));
 
-%% XXX FIXME XXX return_last_computed_value no longer exists!!
+%% FIXME return_last_computed_value no longer exists!!
 %% Remove the next two tests
 %% test/octave.test/prefer/prefer-25.m
 %% test/octave.test/prefer/prefer-26.m
 
 %% test/octave.test/prefer/prefer-27.m
 %!test
 %! sp = save_precision;
 %! save_precision = 1;
@@ -162,28 +162,28 @@
 %! nm = tmpnam();
 %! save("-text",nm,"x");
 %! clear x;
 %! load(nm);
 %! unlink(nm);
 %! assert(x,3.1416);
 %! save_precision = sp;
 
-%% XXX FIXME XXX Same problem as above!!!
+%% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-29.m
 %!function f ()
 %! 1
 %!#test
 %! sf = silent_functions;
 %! silent_functions = 0;
 %! f
 %! assert(??);
 %! silent_functions = sf;
 
-%% XXX FIXME XXX Same problem as above!!!
+%% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-30.m
 %!function f ()
 %! 1
 %!#test
 %! sf = silent_functions;
 %! silent_functions = 1;
 %! f
 %! assert(??);
diff --git a/test/test_string.m b/test/test_string.m
--- a/test/test_string.m
+++ b/test/test_string.m
@@ -88,17 +88,17 @@
 %% test/octave.test/string/str-esc-12.m
 %!test
 %! x = [7, 8, 12, 10, 13, 9, 11, 92, 39, 34];
 %! if (strcmp ("\a\b\f\n\r\t\v\\\'\"", setstr (x)))
 %! printf_assert ("ok\n");
 %! endif
 %! assert(prog_output_assert("ok"));
 
-%% XXX FIXME XXX
+%% FIXME
 %% Why do the next two tests fail?
 %% test/octave.test/string/string_fill_char-1.m
 %!#test
 %! sfc = string_fill_char;
 %! string_fill_char = "X";
 %! str = ["these"; "are"; "strings"];
 %! assert(str,["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char = sfc;
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -246,17 +246,17 @@
 
 %% test/octave.test/system/rmdir-2.m
 %!test
 %! crr = confirm_recursive_rmdir;
 %! confirm_recursive_rmdir = 0;
 %! assert(!rmdir ("foo", "s"));
 %! confirm_recursive_rmdir = crr;
 
-%% XXX FIXME XXX This test messes up the path it seems!! Why?
+%% FIXME This test messes up the path it seems!! Why?
 %% test/octave.test/system/umask-1.m
 %!#test
 %! umask (0);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s1 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
