# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453337939 28800
#      Wed Jan 20 16:58:59 2016 -0800
# Node ID 499b851fbfae0a9aab199f36ca99fa187be8bc57
# Parent  90cd0f9442d5fb1cc8e1b1543154f884f8ed24ba
Replace pattern if/err_XXX/else/code with if/err_XXX/ code.

* schur.cc, ov-complex.h, ov-cx-mat.cc, ov-cx-sparse.cc, ov-float.h,
ov-flt-complex.h, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-range.cc,
ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.h, ov-str-mat.cc, ops.h, pt-idx.cc,
Array.cc, CColVector.cc, CMatrix.cc, CRowVector.cc, MSparse.cc, PermMatrix.cc,
Sparse.cc, dColVector.cc, dMatrix.cc, dRowVector.cc, dSparse.cc,
fCColVector.cc, fCMatrix.cc, fCRowVector.cc, fColVector.cc, fMatrix.cc,
fRowVector.cc:
Replace pattern if/err_XXX/else/code with if/err_XXX/ code.

diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -164,21 +164,22 @@ in control (see @code{are} and @code{dar
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     err_square_matrix_required ("schur", "A");
 
+  if (! arg.is_numeric_type ())
+    err_wrong_type_arg ("schur", arg);
+
   octave_value_list retval;
 
-  if (! arg.is_numeric_type ())
-    err_wrong_type_arg ("schur", arg);
-  else if (arg.is_single_type ())
+  if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (nargout <= 1)
             {
               FloatSCHUR result (tmp, ord, false);
@@ -286,47 +287,41 @@ Note that the following relations hold:\
 \n\
 Note also that @var{U} and @var{T} are not unique.\n\
 @seealso{schur}\n\
 @end deftypefn")
 {
   if (args.length () != 2 || nargout > 2)
     print_usage ();
 
-  octave_value_list retval;
-
   if (! args(0).is_numeric_type ())
     err_wrong_type_arg ("rsf2csf", args(0));
-  else if (! args(1).is_numeric_type ())
+  if (! args(1).is_numeric_type ())
     err_wrong_type_arg ("rsf2csf", args(1));
-  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+  if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
+
+  if (args(0).is_single_type () || args(1).is_single_type ())
+    {
+      FloatMatrix u = args(0).float_matrix_value ();
+      FloatMatrix t = args(1).float_matrix_value ();
+
+      FloatComplexSCHUR cs (FloatSCHUR (t, u));
+
+      return ovl (cs.unitary_matrix (), cs.schur_matrix ());
+    }
   else
     {
-      if (args(0).is_single_type () || args(1).is_single_type ())
-        {
-          FloatMatrix u = args(0).float_matrix_value ();
-          FloatMatrix t = args(1).float_matrix_value ();
-
-          FloatComplexSCHUR cs (FloatSCHUR (t, u));
+      Matrix u = args(0).matrix_value ();
+      Matrix t = args(1).matrix_value ();
 
-          retval = ovl (cs.unitary_matrix (), cs.schur_matrix ());
-        }
-      else
-        {
-          Matrix u = args(0).matrix_value ();
-          Matrix t = args(1).matrix_value ();
+      ComplexSCHUR cs (SCHUR (t, u));
 
-          ComplexSCHUR cs (SCHUR (t, u));
-
-          retval = ovl (cs.unitary_matrix (), cs.schur_matrix ());
-        }
+      return ovl (cs.unitary_matrix (), cs.schur_matrix ());
     }
-
-  return retval;
 }
 
 /*
 %!test
 %! A = [1, 1, 1, 2; 1, 2, 1, 1; 1, 1, 3, 1; -2, 1, 1, 1];
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u, t);
 %! assert (norm (u * t * u' - U * T * U'), 0, 1e-12);
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -135,27 +135,27 @@ public:
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0.0 && scalar != 1.0)
+    if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return scalar != 0.0;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0.0 && scalar != 1.0)
+    if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 0.0);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   void increment (void) { scalar += 1.0; }
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -229,18 +229,18 @@ octave_complex_matrix::float_complex_mat
   return FloatComplexMatrix (ComplexMatrix (matrix));
 }
 
 boolNDArray
 octave_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real ()
-                    || real (matrix).any_element_not_one_or_zero ()))
+  if (warn && (! matrix.all_elements_are_real ()
+               || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 charNDArray
 octave_complex_matrix::char_array_value (bool frc_str_conv) const
 {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -209,18 +209,18 @@ octave_sparse_complex_matrix::sparse_mat
   return retval;
 }
 
 SparseBoolMatrix
 octave_sparse_complex_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real ()
-                    || real (matrix).any_element_not_one_or_zero ()))
+  if (warn && (! matrix.all_elements_are_real ()
+               || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool
 octave_sparse_complex_matrix::save_binary (std::ostream& os,
                                            bool&save_as_floats)
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -193,27 +193,27 @@ public:
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0 && scalar != 1)
+    if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0 && scalar != 1)
+    if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -131,27 +131,27 @@ public:
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0.0f && scalar != 1.0f)
+    if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return scalar != 0.0f;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0.0f && scalar != 1.0f)
+    if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 1.0f);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   void increment (void) { scalar += 1.0; }
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -203,18 +203,18 @@ octave_float_complex_matrix::float_compl
   return FloatComplexMatrix (matrix);
 }
 
 boolNDArray
 octave_float_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real ()
-                    || real (matrix).any_element_not_one_or_zero ()))
+  if (warn && (! matrix.all_elements_are_real ()
+               || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, FloatComplex (0.0));
 }
 
 charNDArray
 octave_float_complex_matrix::char_array_value (bool frc_str_conv) const
 {
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -200,17 +200,17 @@ octave_float_matrix::array_value (bool) 
   return NDArray (matrix);
 }
 
 boolNDArray
 octave_float_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && matrix.any_element_not_one_or_zero ())
+  if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_float_matrix::char_array_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -323,17 +323,17 @@ octave_range::float_complex_value (bool)
 
 boolNDArray
 octave_range::bool_array_value (bool warn) const
 {
   Matrix m = range.matrix_value ();
 
   if (m.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && m.any_element_not_one_or_zero ())
+  if (warn && m.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
 {
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -209,17 +209,17 @@ octave_matrix::float_complex_array_value
   return FloatComplexNDArray (matrix);
 }
 
 boolNDArray
 octave_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && matrix.any_element_not_one_or_zero ())
+  if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_matrix::char_array_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -137,17 +137,17 @@ octave_sparse_matrix::matrix_value (bool
 
 boolNDArray
 octave_sparse_matrix::bool_array_value (bool warn) const
 {
   NDArray m = matrix.matrix_value ();
 
   if (m.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && m.any_element_not_one_or_zero ())
+  if (warn && m.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 charNDArray
 octave_sparse_matrix::char_array_value (bool) const
 {
@@ -180,17 +180,17 @@ octave_sparse_matrix::array_value (bool)
   return NDArray (matrix.matrix_value ());
 }
 
 SparseBoolMatrix
 octave_sparse_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     err_nan_to_logical_conversion ();
-  else if (warn && matrix.any_element_not_one_or_zero ())
+  if (warn && matrix.any_element_not_one_or_zero ())
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, 0.0);
 }
 
 octave_value
 octave_sparse_matrix::convert_to_str_internal (bool, bool, char type) const
 {
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -192,27 +192,27 @@ public:
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0 && scalar != 1)
+    if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
       err_nan_to_logical_conversion ();
-    else if (warn && scalar != 0 && scalar != 1)
+    if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -160,24 +160,22 @@ octave_char_matrix_str::resize (const di
   return octave_value (retval, is_sq_string () ? '\'' : '"');
 }
 
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
   if (! force_string_conv) \
     err_invalid_conversion ("string", TNAME); \
-  else \
-    { \
-      warning_with_id ("Octave:str-to-num", \
-                       "implicit conversion from %s to %s", \
-                       "string", TNAME); \
  \
-      retval = octave_char_matrix::FCN (); \
-    } \
+  warning_with_id ("Octave:str-to-num", \
+                   "implicit conversion from %s to %s", \
+                   "string", TNAME); \
+ \
+  retval = octave_char_matrix::FCN (); \
  \
   return retval
 
 double
 octave_char_matrix_str::double_value (bool force_string_conv) const
 {
   CHAR_MATRIX_CONV (double, = 0, "real scalar", double_value);
 }
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -297,19 +297,19 @@ extern void install_ops (void);
   }
 
 #define DEFSCALARBOOLOP_OP(name, t1, t2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     if (xisnan (v1.CONCAT2(t1, _value) ()) || xisnan (v2.CONCAT2(t2, _value) ())) \
       err_nan_to_logical_conversion (); \
-    else \
-      return octave_value \
-        (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
+ \
+    return octave_value \
+      (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value \
       (v1.CONCAT2(e1, _value) () op v2.CONCAT2(e2, _value) ()); \
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -486,17 +486,18 @@ tree_index_expression::lvalue (void)
 
   octave_idx_type tmpi = 0;
   std::list<octave_value_list> tmpidx;
 
   for (int i = 0; i < n; i++)
     {
       if (retval.numel () != 1)
         err_indexed_cs_list ();
-      else if (tmpi < i)
+
+      if (tmpi < i)
         {
           try
             {
               tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
             }
           catch (index_exception& e)  // problems with range, invalid type etc.
             {
               final_index_error (e, expr);
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -928,62 +928,60 @@ Array<T>::resize1 (octave_idx_type n, co
     dv = dim_vector (1, n);
   else if (columns () == 1)
     dv = dim_vector (n, 1);
   else
     invalid = true;
 
   if (invalid)
     err_invalid_resize ();
-  else
+
+  octave_idx_type nx = numel ();
+  if (n == nx - 1 && n > 0)
     {
-      octave_idx_type nx = numel ();
-      if (n == nx - 1 && n > 0)
+      // Stack "pop" operation.
+      if (rep->count == 1)
+        slice_data[slice_len-1] = T ();
+      slice_len--;
+      dimensions = dv;
+    }
+  else if (n == nx + 1 && nx > 0)
+    {
+      // Stack "push" operation.
+      if (rep->count == 1
+          && slice_data + slice_len < rep->data + rep->len)
         {
-          // Stack "pop" operation.
-          if (rep->count == 1)
-            slice_data[slice_len-1] = T ();
-          slice_len--;
+          slice_data[slice_len++] = rfv;
           dimensions = dv;
         }
-      else if (n == nx + 1 && nx > 0)
+      else
         {
-          // Stack "push" operation.
-          if (rep->count == 1
-              && slice_data + slice_len < rep->data + rep->len)
-            {
-              slice_data[slice_len++] = rfv;
-              dimensions = dv;
-            }
-          else
-            {
-              static const octave_idx_type max_stack_chunk = 1024;
-              octave_idx_type nn = n + std::min (nx, max_stack_chunk);
-              Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
-              T *dest = tmp.fortran_vec ();
-
-              std::copy (data (), data () + nx, dest);
-              dest[nx] = rfv;
-
-              *this = tmp;
-            }
-        }
-      else if (n != nx)
-        {
-          Array<T> tmp = Array<T> (dv);
+          static const octave_idx_type max_stack_chunk = 1024;
+          octave_idx_type nn = n + std::min (nx, max_stack_chunk);
+          Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
           T *dest = tmp.fortran_vec ();
 
-          octave_idx_type n0 = std::min (n, nx);
-          octave_idx_type n1 = n - n0;
-          std::copy (data (), data () + n0, dest);
-          std::fill_n (dest + n0, n1, rfv);
+          std::copy (data (), data () + nx, dest);
+          dest[nx] = rfv;
 
           *this = tmp;
         }
     }
+  else if (n != nx)
+    {
+      Array<T> tmp = Array<T> (dv);
+      T *dest = tmp.fortran_vec ();
+
+      octave_idx_type n0 = std::min (n, nx);
+      octave_idx_type n1 = n - n0;
+      std::copy (data (), data () + n0, dest);
+      std::fill_n (dest + n0, n1, rfv);
+
+      *this = tmp;
+    }
 }
 
 template <class T>
 void
 Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r < 0 || c < 0 || ndims () != 2)
     err_invalid_resize ();
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -336,36 +336,34 @@ operator * (const ComplexMatrix& m, cons
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
-  else
+
+  retval.clear (nr);
+
+  if (nr != 0)
     {
-      retval.clear (nr);
-
-      if (nr != 0)
+      if (nc == 0)
+        retval.fill (0.0);
+      else
         {
-          if (nc == 0)
-            retval.fill (0.0);
-          else
-            {
-              Complex *y = retval.fortran_vec ();
+          Complex *y = retval.fortran_vec ();
 
-              F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                       nr, nc, 1.0, m.data (), nr,
-                                       a.data (), 1, 0.0, y, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                   nr, nc, 1.0, m.data (), nr,
+                                   a.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
         }
+    }
 
-    }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const Matrix& m, const ComplexColumnVector& a)
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -3712,112 +3712,110 @@ xgemm (const ComplexMatrix& a, const Com
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-  else
+
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    retval = ComplexMatrix (a_nr, b_nc, 0.0);
+  else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-        retval = ComplexMatrix (a_nr, b_nc, 0.0);
-      else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+      octave_idx_type lda = a.rows ();
+
+      // FIXME: looking at the reference BLAS, it appears that it
+      // should not be necessary to initialize the output matrix if
+      // BETA is 0 in the call to ZHERK, but ATLAS appears to
+      // use the result matrix before zeroing the elements.
+
+      retval = ComplexMatrix (a_nr, b_nc, 0.0);
+      Complex *c = retval.fortran_vec ();
+
+      const char ctra = get_blas_trans_arg (tra, cja);
+      if (cja || cjb)
         {
-          octave_idx_type lda = a.rows ();
-
-          // FIXME: looking at the reference BLAS, it appears that it
-          // should not be necessary to initialize the output matrix if
-          // BETA is 0 in the call to ZHERK, but ATLAS appears to
-          // use the result matrix before zeroing the elements.
-
-          retval = ComplexMatrix (a_nr, b_nc, 0.0);
-          Complex *c = retval.fortran_vec ();
-
-          const char ctra = get_blas_trans_arg (tra, cja);
-          if (cja || cjb)
-            {
-              F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                       F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       a_nr, a_nc, 1.0,
-                                       a.data (), lda, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-              for (octave_idx_type j = 0; j < a_nr; j++)
-                for (octave_idx_type i = 0; i < j; i++)
-                  retval.xelem (j,i) = std::conj (retval.xelem (i,j));
-            }
-          else
-            {
-              F77_XFCN (zsyrk, ZSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                       F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       a_nr, a_nc, 1.0,
-                                       a.data (), lda, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-              for (octave_idx_type j = 0; j < a_nr; j++)
-                for (octave_idx_type i = 0; i < j; i++)
-                  retval.xelem (j,i) = retval.xelem (i,j);
-
-            }
-
+          F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   a_nr, a_nc, 1.0,
+                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
+          for (octave_idx_type j = 0; j < a_nr; j++)
+            for (octave_idx_type i = 0; i < j; i++)
+              retval.xelem (j,i) = std::conj (retval.xelem (i,j));
         }
       else
         {
-          octave_idx_type lda = a.rows ();
-          octave_idx_type tda = a.cols ();
-          octave_idx_type ldb = b.rows ();
-          octave_idx_type tdb = b.cols ();
-
-          retval = ComplexMatrix (a_nr, b_nc, 0.0);
-          Complex *c = retval.fortran_vec ();
-
-          if (b_nc == 1 && a_nr == 1)
-            {
-              if (cja == cjb)
-                {
-                  F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1,
-                                             *c);
-                  if (cja) *c = std::conj (*c);
-                }
-              else if (cja)
-                F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1,
-                                           *c);
-              else
-                F77_FUNC (xzdotc, XZDOTC) (a_nc, b.data (), 1, a.data (), 1,
-                                           *c);
-            }
-          else if (b_nc == 1 && ! cjb)
+          F77_XFCN (zsyrk, ZSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   a_nr, a_nc, 1.0,
+                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
+          for (octave_idx_type j = 0; j < a_nr; j++)
+            for (octave_idx_type i = 0; i < j; i++)
+              retval.xelem (j,i) = retval.xelem (i,j);
+
+        }
+
+    }
+  else
+    {
+      octave_idx_type lda = a.rows ();
+      octave_idx_type tda = a.cols ();
+      octave_idx_type ldb = b.rows ();
+      octave_idx_type tdb = b.cols ();
+
+      retval = ComplexMatrix (a_nr, b_nc, 0.0);
+      Complex *c = retval.fortran_vec ();
+
+      if (b_nc == 1 && a_nr == 1)
+        {
+          if (cja == cjb)
             {
-              const char ctra = get_blas_trans_arg (tra, cja);
-              F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       lda, tda, 1.0,  a.data (), lda,
-                                       b.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
+              F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1,
+                                         *c);
+              if (cja) *c = std::conj (*c);
             }
-          else if (a_nr == 1 && ! cja && ! cjb)
-            {
-              const char crevtrb = get_blas_trans_arg (! trb, cjb);
-              F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                       ldb, tdb, 1.0,  b.data (), ldb,
-                                       a.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          else if (cja)
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1,
+                                       *c);
           else
-            {
-              const char ctra = get_blas_trans_arg (tra, cja);
-              const char ctrb = get_blas_trans_arg (trb, cjb);
-              F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                       a_nr, b_nc, a_nc, 1.0, a.data (),
-                                       lda, b.data (), ldb, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, b.data (), 1, a.data (), 1,
+                                       *c);
+        }
+      else if (b_nc == 1 && ! cjb)
+        {
+          const char ctra = get_blas_trans_arg (tra, cja);
+          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   lda, tda, 1.0,  a.data (), lda,
+                                   b.data (), 1, 0.0, c, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
+      else if (a_nr == 1 && ! cja && ! cjb)
+        {
+          const char crevtrb = get_blas_trans_arg (! trb, cjb);
+          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
+                                   ldb, tdb, 1.0,  b.data (), ldb,
+                                   a.data (), 1, 0.0, c, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
+      else
+        {
+          const char ctra = get_blas_trans_arg (tra, cja);
+          const char ctrb = get_blas_trans_arg (trb, cjb);
+          F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   F77_CONST_CHAR_ARG2 (&ctrb, 1),
+                                   a_nr, b_nc, a_nc, 1.0, a.data (),
+                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& a, const ComplexMatrix& b)
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -321,34 +321,32 @@ operator * (const ComplexRowVector& v, c
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+
+  if (len == 0)
+    retval.resize (a_nc, 0.0);
   else
     {
-      if (len == 0)
-        retval.resize (a_nc, 0.0);
-      else
-        {
-          // Transpose A to form A'*x == (x'*A)'
+      // Transpose A to form A'*x == (x'*A)'
 
-          octave_idx_type ld = a_nr;
+      octave_idx_type ld = a_nr;
 
-          retval.resize (a_nc);
-          Complex *y = retval.fortran_vec ();
+      retval.resize (a_nc);
+      Complex *y = retval.fortran_vec ();
 
-          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                                   a_nr, a_nc, 1.0, a.data (),
-                                   ld, v.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
-        }
+      F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                               a_nr, a_nc, 1.0, a.data (),
+                               ld, v.data (), 1, 0.0, y, 1
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
@@ -446,17 +444,17 @@ operator * (const ComplexRowVector& v, c
   Complex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
-  else if (len != 0)
+  if (len != 0)
     F77_FUNC (xzdotu, XZDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 // other operations
 
 ComplexRowVector
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -34,70 +34,68 @@ plus_or_minus (MSparse<T>& a, const MSpa
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr != b_nr || a_nc != b_nc)
     err_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
-  else
-    {
-      r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
+
+  r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
-      octave_idx_type jx = 0;
-      for (octave_idx_type i = 0 ; i < a_nc ; i++)
-        {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
+  octave_idx_type jx = 0;
+  for (octave_idx_type i = 0 ; i < a_nc ; i++)
+    {
+      octave_idx_type  ja = a.cidx (i);
+      octave_idx_type  ja_max = a.cidx (i+1);
+      bool ja_lt_max= ja < ja_max;
+
+      octave_idx_type  jb = b.cidx (i);
+      octave_idx_type  jb_max = b.cidx (i+1);
+      bool jb_lt_max = jb < jb_max;
 
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
-          bool jb_lt_max = jb < jb_max;
-
-          while (ja_lt_max || jb_lt_max)
+      while (ja_lt_max || jb_lt_max)
+        {
+          octave_quit ();
+          if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+            {
+              r.ridx (jx) = a.ridx (ja);
+              r.data (jx) = op (a.data (ja), 0.);
+              jx++;
+              ja++;
+              ja_lt_max= ja < ja_max;
+            }
+          else if ((! ja_lt_max)
+                   || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
             {
-              octave_quit ();
-              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              r.ridx (jx) = b.ridx (jb);
+              r.data (jx) = op (0., b.data (jb));
+              jx++;
+              jb++;
+              jb_lt_max= jb < jb_max;
+            }
+          else
+            {
+              if (op (a.data (ja), b.data (jb)) != 0.)
                 {
+                  r.data (jx) = op (a.data (ja), b.data (jb));
                   r.ridx (jx) = a.ridx (ja);
-                  r.data (jx) = op (a.data (ja), 0.);
                   jx++;
-                  ja++;
-                  ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max)
-                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
-                {
-                  r.ridx (jx) = b.ridx (jb);
-                  r.data (jx) = op (0., b.data (jb));
-                  jx++;
-                  jb++;
-                  jb_lt_max= jb < jb_max;
-                }
-              else
-                {
-                  if (op (a.data (ja), b.data (jb)) != 0.)
-                    {
-                      r.data (jx) = op (a.data (ja), b.data (jb));
-                      r.ridx (jx) = a.ridx (ja);
-                      jx++;
-                    }
-                  ja++;
-                  ja_lt_max= ja < ja_max;
-                  jb++;
-                  jb_lt_max= jb < jb_max;
-                }
+              ja++;
+              ja_lt_max= ja < ja_max;
+              jb++;
+              jb_lt_max= jb < jb_max;
             }
-          r.cidx (i+1) = jx;
         }
+      r.cidx (i+1) = jx;
+    }
 
-      a = r.maybe_compress ();
-    }
+  a = r.maybe_compress ();
 
   return a;
 }
 
 template <typename T>
 MSparse<T>&
 operator += (MSparse<T>& a, const MSparse<T>& b)
 {
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -231,13 +231,13 @@ operator *(const PermMatrix& a, const Pe
 
   const Array<octave_idx_type> ia = a.col_perm_vec ();
   const Array<octave_idx_type> ib = b.col_perm_vec ();
 
   octave_idx_type n = a.columns ();
 
   if (n != b.rows ())
     err_nonconformant ("operator *", n, n, b.rows (), b.rows ());
-  else
-    r = PermMatrix (ia.index (idx_vector (ib)), true, false);
+
+  r = PermMatrix (ia.index (idx_vector (ib)), true, false);
 
   return r;
 }
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -1160,17 +1160,18 @@ Sparse<T>::delete_elements (const idx_ve
   octave_idx_type nz = nnz ();
 
   octave_idx_type nel = numel (); // Can throw.
 
   const dim_vector idx_dims = idx.orig_dimensions ();
 
   if (idx.extent (nel) > nel)
     err_del_index_out_of_range (true, idx.extent (nel), nel);
-  else if (nc == 1)
+
+  if (nc == 1)
     {
       // Sparse column vector.
       const Sparse<T> tmp = *this; // constant copy to prevent COW.
 
       octave_idx_type lb, ub;
 
       if (idx.is_cont_range (nel, lb, ub))
         {
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -201,33 +201,31 @@ operator * (const Matrix& m, const Colum
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
-  else
+
+  retval.clear (nr);
+
+  if (nr != 0)
     {
-      retval.clear (nr);
-
-      if (nr != 0)
+      if (nc == 0)
+        retval.fill (0.0);
+      else
         {
-          if (nc == 0)
-            retval.fill (0.0);
-          else
-            {
-              double *y = retval.fortran_vec ();
+          double *y = retval.fortran_vec ();
 
-              F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                       nr, nc, 1.0, m.data (), nr,
-                                       a.data (), 1, 0.0, y, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                   nr, nc, 1.0, m.data (), nr,
+                                   a.data (), 1, 0.0, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
@@ -238,30 +236,28 @@ operator * (const DiagMatrix& m, const C
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
+
+  if (nr == 0 || nc == 0)
+    retval.resize (nr, 0.0);
   else
     {
-      if (nr == 0 || nc == 0)
-        retval.resize (nr, 0.0);
-      else
-        {
-          retval.resize (nr);
+      retval.resize (nr);
 
-          for (octave_idx_type i = 0; i < a_len; i++)
-            retval.elem (i) = a.elem (i) * m.elem (i, i);
+      for (octave_idx_type i = 0; i < a_len; i++)
+        retval.elem (i) = a.elem (i) * m.elem (i, i);
 
-          for (octave_idx_type i = a_len; i < nr; i++)
-            retval.elem (i) = 0.0;
-        }
+      for (octave_idx_type i = a_len; i < nr; i++)
+        retval.elem (i) = 0.0;
     }
 
   return retval;
 }
 
 // other operations
 
 double
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -3103,81 +3103,79 @@ xgemm (const Matrix& a, const Matrix& b,
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    retval = Matrix (a_nr, b_nc, 0.0);
+  else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+    {
+      octave_idx_type lda = a.rows ();
+
+      retval = Matrix (a_nr, b_nc);
+      double *c = retval.fortran_vec ();
+
+      const char ctra = get_blas_trans_arg (tra);
+      F77_XFCN (dsyrk, DSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                               F77_CONST_CHAR_ARG2 (&ctra, 1),
+                               a_nr, a_nc, 1.0,
+                               a.data (), lda, 0.0, c, a_nr
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
+      for (int j = 0; j < a_nr; j++)
+        for (int i = 0; i < j; i++)
+          retval.xelem (j,i) = retval.xelem (i,j);
+
+    }
   else
     {
-      if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-        retval = Matrix (a_nr, b_nc, 0.0);
-      else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+      octave_idx_type lda = a.rows ();
+      octave_idx_type tda = a.cols ();
+      octave_idx_type ldb = b.rows ();
+      octave_idx_type tdb = b.cols ();
+
+      retval = Matrix (a_nr, b_nc);
+      double *c = retval.fortran_vec ();
+
+      if (b_nc == 1)
         {
-          octave_idx_type lda = a.rows ();
-
-          retval = Matrix (a_nr, b_nc);
-          double *c = retval.fortran_vec ();
-
-          const char ctra = get_blas_trans_arg (tra);
-          F77_XFCN (dsyrk, DSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                   a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
-                                   F77_CHAR_ARG_LEN (1)
+          if (a_nr == 1)
+            F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
+          else
+            {
+              const char ctra = get_blas_trans_arg (tra);
+              F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                       lda, tda, 1.0,  a.data (), lda,
+                                       b.data (), 1, 0.0, c, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
+      else if (a_nr == 1)
+        {
+          const char crevtrb = get_blas_trans_arg (! trb);
+          F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
+                                   ldb, tdb, 1.0,  b.data (), ldb,
+                                   a.data (), 1, 0.0, c, 1
                                    F77_CHAR_ARG_LEN (1)));
-          for (int j = 0; j < a_nr; j++)
-            for (int i = 0; i < j; i++)
-              retval.xelem (j,i) = retval.xelem (i,j);
-
         }
       else
         {
-          octave_idx_type lda = a.rows ();
-          octave_idx_type tda = a.cols ();
-          octave_idx_type ldb = b.rows ();
-          octave_idx_type tdb = b.cols ();
-
-          retval = Matrix (a_nr, b_nc);
-          double *c = retval.fortran_vec ();
-
-          if (b_nc == 1)
-            {
-              if (a_nr == 1)
-                F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
-              else
-                {
-                  const char ctra = get_blas_trans_arg (tra);
-                  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                           lda, tda, 1.0,  a.data (), lda,
-                                           b.data (), 1, 0.0, c, 1
-                                           F77_CHAR_ARG_LEN (1)));
-                }
-            }
-          else if (a_nr == 1)
-            {
-              const char crevtrb = get_blas_trans_arg (! trb);
-              F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                       ldb, tdb, 1.0,  b.data (), ldb,
-                                       a.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
-          else
-            {
-              const char ctra = get_blas_trans_arg (tra);
-              const char ctrb = get_blas_trans_arg (trb);
-              F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                       a_nr, b_nc, a_nc, 1.0, a.data (),
-                                       lda, b.data (), ldb, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          const char ctra = get_blas_trans_arg (tra);
+          const char ctrb = get_blas_trans_arg (trb);
+          F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   F77_CONST_CHAR_ARG2 (&ctrb, 1),
+                                   a_nr, b_nc, a_nc, 1.0, a.data (),
+                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 Matrix
 operator * (const Matrix& a, const Matrix& b)
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -196,34 +196,32 @@ operator * (const RowVector& v, const Ma
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+
+  if (len == 0)
+    retval.resize (a_nc, 0.0);
   else
     {
-      if (len == 0)
-        retval.resize (a_nc, 0.0);
-      else
-        {
-          // Transpose A to form A'*x == (x'*A)'
+      // Transpose A to form A'*x == (x'*A)'
 
-          octave_idx_type ld = a_nr;
+      octave_idx_type ld = a_nr;
 
-          retval.resize (a_nc);
-          double *y = retval.fortran_vec ();
+      retval.resize (a_nc);
+      double *y = retval.fortran_vec ();
 
-          F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                                   a_nr, a_nc, 1.0, a.data (),
-                                   ld, v.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
-        }
+      F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                               a_nr, a_nc, 1.0, a.data (),
+                               ld, v.data (), 1, 0.0, y, 1
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations
 
 double
@@ -319,17 +317,18 @@ operator * (const RowVector& v, const Co
   double retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
-  else if (len != 0)
+
+  if (len != 0)
     F77_FUNC (xddot, XDDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
 {
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -758,70 +758,68 @@ atan2 (const SparseMatrix& x, const Spar
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
         err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
-      else
+
+      r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
+
+      octave_idx_type jx = 0;
+      r.cidx (0) = 0;
+      for (octave_idx_type i = 0 ; i < x_nc ; i++)
         {
-          r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
-
-          octave_idx_type jx = 0;
-          r.cidx (0) = 0;
-          for (octave_idx_type i = 0 ; i < x_nc ; i++)
-            {
-              octave_idx_type  ja = x.cidx (i);
-              octave_idx_type  ja_max = x.cidx (i+1);
-              bool ja_lt_max= ja < ja_max;
-
-              octave_idx_type  jb = y.cidx (i);
-              octave_idx_type  jb_max = y.cidx (i+1);
-              bool jb_lt_max = jb < jb_max;
-
-              while (ja_lt_max || jb_lt_max)
-                {
-                  octave_quit ();
-                  if ((! jb_lt_max)
-                      || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
+          octave_idx_type  ja = x.cidx (i);
+          octave_idx_type  ja_max = x.cidx (i+1);
+          bool ja_lt_max= ja < ja_max;
+
+          octave_idx_type  jb = y.cidx (i);
+          octave_idx_type  jb_max = y.cidx (i+1);
+          bool jb_lt_max = jb < jb_max;
+
+          while (ja_lt_max || jb_lt_max)
+            {
+              octave_quit ();
+              if ((! jb_lt_max)
+                  || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
+                {
+                  r.ridx (jx) = x.ridx (ja);
+                  r.data (jx) = atan2 (x.data (ja), 0.);
+                  jx++;
+                  ja++;
+                  ja_lt_max= ja < ja_max;
+                }
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
+                {
+                  jb++;
+                  jb_lt_max= jb < jb_max;
+                }
+              else
+                {
+                  double tmp = atan2 (x.data (ja), y.data (jb));
+                  if (tmp != 0.)
                     {
+                      r.data (jx) = tmp;
                       r.ridx (jx) = x.ridx (ja);
-                      r.data (jx) = atan2 (x.data (ja), 0.);
                       jx++;
-                      ja++;
-                      ja_lt_max= ja < ja_max;
                     }
-                  else if ((! ja_lt_max)
-                           || (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
-                    {
-                      jb++;
-                      jb_lt_max= jb < jb_max;
-                    }
-                  else
-                    {
-                      double tmp = atan2 (x.data (ja), y.data (jb));
-                      if (tmp != 0.)
-                        {
-                          r.data (jx) = tmp;
-                          r.ridx (jx) = x.ridx (ja);
-                          jx++;
-                        }
-                      ja++;
-                      ja_lt_max= ja < ja_max;
-                      jb++;
-                      jb_lt_max= jb < jb_max;
-                    }
-                }
-              r.cidx (i+1) = jx;
-            }
-
-          r.maybe_compress ();
+                  ja++;
+                  ja_lt_max= ja < ja_max;
+                  jb++;
+                  jb_lt_max= jb < jb_max;
+                }
+            }
+          r.cidx (i+1) = jx;
         }
+
+      r.maybe_compress ();
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SparseMatrix
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -339,33 +339,31 @@ operator * (const FloatComplexMatrix& m,
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
-  else
+
+  retval.clear (nr);
+
+  if (nr != 0)
     {
-      retval.clear (nr);
-
-      if (nr != 0)
+      if (nc == 0)
+        retval.fill (0.0);
+      else
         {
-          if (nc == 0)
-            retval.fill (0.0);
-          else
-            {
-              FloatComplex *y = retval.fortran_vec ();
+          FloatComplex *y = retval.fortran_vec ();
 
-              F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                       nr, nc, 1.0f, m.data (), nr,
-                                       a.data (), 1, 0.0f, y, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                   nr, nc, 1.0f, m.data (), nr,
+                                   a.data (), 1, 0.0f, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -3715,112 +3715,110 @@ xgemm (const FloatComplexMatrix& a, cons
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
-  else
+
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
+  else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-        retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
-      else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+      octave_idx_type lda = a.rows ();
+
+      // FIXME: looking at the reference BLAS, it appears that it
+      // should not be necessary to initialize the output matrix if
+      // BETA is 0 in the call to CHERK, but ATLAS appears to
+      // use the result matrix before zeroing the elements.
+
+      retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
+      FloatComplex *c = retval.fortran_vec ();
+
+      const char ctra = get_blas_trans_arg (tra, cja);
+      if (cja || cjb)
         {
-          octave_idx_type lda = a.rows ();
-
-          // FIXME: looking at the reference BLAS, it appears that it
-          // should not be necessary to initialize the output matrix if
-          // BETA is 0 in the call to CHERK, but ATLAS appears to
-          // use the result matrix before zeroing the elements.
-
-          retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
-          FloatComplex *c = retval.fortran_vec ();
-
-          const char ctra = get_blas_trans_arg (tra, cja);
-          if (cja || cjb)
-            {
-              F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                       F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       a_nr, a_nc, 1.0,
-                                       a.data (), lda, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-              for (octave_idx_type j = 0; j < a_nr; j++)
-                for (octave_idx_type i = 0; i < j; i++)
-                  retval.xelem (j,i) = std::conj (retval.xelem (i,j));
-            }
-          else
-            {
-              F77_XFCN (csyrk, CSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                       F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       a_nr, a_nc, 1.0,
-                                       a.data (), lda, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-              for (octave_idx_type j = 0; j < a_nr; j++)
-                for (octave_idx_type i = 0; i < j; i++)
-                  retval.xelem (j,i) = retval.xelem (i,j);
-
-            }
-
+          F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   a_nr, a_nc, 1.0,
+                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
+          for (octave_idx_type j = 0; j < a_nr; j++)
+            for (octave_idx_type i = 0; i < j; i++)
+              retval.xelem (j,i) = std::conj (retval.xelem (i,j));
         }
       else
         {
-          octave_idx_type lda = a.rows ();
-          octave_idx_type tda = a.cols ();
-          octave_idx_type ldb = b.rows ();
-          octave_idx_type tdb = b.cols ();
-
-          retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
-          FloatComplex *c = retval.fortran_vec ();
-
-          if (b_nc == 1 && a_nr == 1)
-            {
-              if (cja == cjb)
-                {
-                  F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1,
-                                             *c);
-                  if (cja) *c = std::conj (*c);
-                }
-              else if (cja)
-                F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1,
-                                           *c);
-              else
-                F77_FUNC (xcdotc, XCDOTC) (a_nc, b.data (), 1, a.data (), 1,
-                                           *c);
-            }
-          else if (b_nc == 1 && ! cjb)
+          F77_XFCN (csyrk, CSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   a_nr, a_nc, 1.0,
+                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
+          for (octave_idx_type j = 0; j < a_nr; j++)
+            for (octave_idx_type i = 0; i < j; i++)
+              retval.xelem (j,i) = retval.xelem (i,j);
+
+        }
+
+    }
+  else
+    {
+      octave_idx_type lda = a.rows ();
+      octave_idx_type tda = a.cols ();
+      octave_idx_type ldb = b.rows ();
+      octave_idx_type tdb = b.cols ();
+
+      retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
+      FloatComplex *c = retval.fortran_vec ();
+
+      if (b_nc == 1 && a_nr == 1)
+        {
+          if (cja == cjb)
             {
-              const char ctra = get_blas_trans_arg (tra, cja);
-              F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       lda, tda, 1.0,  a.data (), lda,
-                                       b.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
+              F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1,
+                                         *c);
+              if (cja) *c = std::conj (*c);
             }
-          else if (a_nr == 1 && ! cja && ! cjb)
-            {
-              const char crevtrb = get_blas_trans_arg (! trb, cjb);
-              F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                       ldb, tdb, 1.0,  b.data (), ldb,
-                                       a.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          else if (cja)
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1,
+                                       *c);
           else
-            {
-              const char ctra = get_blas_trans_arg (tra, cja);
-              const char ctrb = get_blas_trans_arg (trb, cjb);
-              F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                       a_nr, b_nc, a_nc, 1.0, a.data (),
-                                       lda, b.data (), ldb, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, b.data (), 1, a.data (), 1,
+                                       *c);
+        }
+      else if (b_nc == 1 && ! cjb)
+        {
+          const char ctra = get_blas_trans_arg (tra, cja);
+          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   lda, tda, 1.0,  a.data (), lda,
+                                   b.data (), 1, 0.0, c, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
+      else if (a_nr == 1 && ! cja && ! cjb)
+        {
+          const char crevtrb = get_blas_trans_arg (! trb, cjb);
+          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
+                                   ldb, tdb, 1.0,  b.data (), ldb,
+                                   a.data (), 1, 0.0, c, 1
+                                   F77_CHAR_ARG_LEN (1)));
+        }
+      else
+        {
+          const char ctra = get_blas_trans_arg (tra, cja);
+          const char ctrb = get_blas_trans_arg (trb, cjb);
+          F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   F77_CONST_CHAR_ARG2 (&ctrb, 1),
+                                   a_nr, b_nc, a_nc, 1.0, a.data (),
+                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -322,34 +322,32 @@ operator * (const FloatComplexRowVector&
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+
+  if (len == 0)
+    retval.resize (a_nc, 0.0);
   else
     {
-      if (len == 0)
-        retval.resize (a_nc, 0.0);
-      else
-        {
-          // Transpose A to form A'*x == (x'*A)'
+      // Transpose A to form A'*x == (x'*A)'
 
-          octave_idx_type ld = a_nr;
+      octave_idx_type ld = a_nr;
 
-          retval.resize (a_nc);
-          FloatComplex *y = retval.fortran_vec ();
+      retval.resize (a_nc);
+      FloatComplex *y = retval.fortran_vec ();
 
-          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                                   a_nr, a_nc, 1.0, a.data (),
-                                   ld, v.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
-        }
+      F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                               a_nr, a_nc, 1.0, a.data (),
+                               ld, v.data (), 1, 0.0, y, 1
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 FloatComplexRowVector
 operator * (const FloatRowVector& v, const FloatComplexMatrix& a)
 {
@@ -447,17 +445,18 @@ operator * (const FloatComplexRowVector&
   FloatComplex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
-  else if (len != 0)
+
+  if (len != 0)
     F77_FUNC (xcdotu, XCDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 // other operations
 
 FloatComplexRowVector
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -200,33 +200,31 @@ operator * (const FloatMatrix& m, const 
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
-  else
+
+  retval.clear (nr);
+
+  if (nr != 0)
     {
-      retval.clear (nr);
-
-      if (nr != 0)
+      if (nc == 0)
+        retval.fill (0.0);
+      else
         {
-          if (nc == 0)
-            retval.fill (0.0);
-          else
-            {
-              float *y = retval.fortran_vec ();
+          float *y = retval.fortran_vec ();
 
-              F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                       nr, nc, 1.0f, m.data (), nr,
-                                       a.data (), 1, 0.0f, y, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                   nr, nc, 1.0f, m.data (), nr,
+                                   a.data (), 1, 0.0f, y, 1
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
@@ -237,30 +235,28 @@ operator * (const FloatDiagMatrix& m, co
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     err_nonconformant ("operator *", nr, nc, a_len, 1);
+
+  if (nr == 0 || nc == 0)
+    retval.resize (nr, 0.0);
   else
     {
-      if (nr == 0 || nc == 0)
-        retval.resize (nr, 0.0);
-      else
-        {
-          retval.resize (nr);
+      retval.resize (nr);
 
-          for (octave_idx_type i = 0; i < a_len; i++)
-            retval.elem (i) = a.elem (i) * m.elem (i, i);
+      for (octave_idx_type i = 0; i < a_len; i++)
+        retval.elem (i) = a.elem (i) * m.elem (i, i);
 
-          for (octave_idx_type i = a_len; i < nr; i++)
-            retval.elem (i) = 0.0;
-        }
+      for (octave_idx_type i = a_len; i < nr; i++)
+        retval.elem (i) = 0.0;
     }
 
   return retval;
 }
 
 // other operations
 
 float
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -3108,81 +3108,79 @@ xgemm (const FloatMatrix& a, const Float
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
     err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    retval = FloatMatrix (a_nr, b_nc, 0.0);
+  else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+    {
+      octave_idx_type lda = a.rows ();
+
+      retval = FloatMatrix (a_nr, b_nc);
+      float *c = retval.fortran_vec ();
+
+      const char ctra = get_blas_trans_arg (tra);
+      F77_XFCN (ssyrk, SSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
+                               F77_CONST_CHAR_ARG2 (&ctra, 1),
+                               a_nr, a_nc, 1.0,
+                               a.data (), lda, 0.0, c, a_nr
+                               F77_CHAR_ARG_LEN (1)
+                               F77_CHAR_ARG_LEN (1)));
+      for (int j = 0; j < a_nr; j++)
+        for (int i = 0; i < j; i++)
+          retval.xelem (j,i) = retval.xelem (i,j);
+
+    }
   else
     {
-      if (a_nr == 0 || a_nc == 0 || b_nc == 0)
-        retval = FloatMatrix (a_nr, b_nc, 0.0);
-      else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
+      octave_idx_type lda = a.rows ();
+      octave_idx_type tda = a.cols ();
+      octave_idx_type ldb = b.rows ();
+      octave_idx_type tdb = b.cols ();
+
+      retval = FloatMatrix (a_nr, b_nc);
+      float *c = retval.fortran_vec ();
+
+      if (b_nc == 1)
         {
-          octave_idx_type lda = a.rows ();
-
-          retval = FloatMatrix (a_nr, b_nc);
-          float *c = retval.fortran_vec ();
-
-          const char ctra = get_blas_trans_arg (tra);
-          F77_XFCN (ssyrk, SSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
-                                   F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                   a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
-                                   F77_CHAR_ARG_LEN (1)
+          if (a_nr == 1)
+            F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
+          else
+            {
+              const char ctra = get_blas_trans_arg (tra);
+              F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                       lda, tda, 1.0,  a.data (), lda,
+                                       b.data (), 1, 0.0, c, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
+        }
+      else if (a_nr == 1)
+        {
+          const char crevtrb = get_blas_trans_arg (! trb);
+          F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
+                                   ldb, tdb, 1.0,  b.data (), ldb,
+                                   a.data (), 1, 0.0, c, 1
                                    F77_CHAR_ARG_LEN (1)));
-          for (int j = 0; j < a_nr; j++)
-            for (int i = 0; i < j; i++)
-              retval.xelem (j,i) = retval.xelem (i,j);
-
         }
       else
         {
-          octave_idx_type lda = a.rows ();
-          octave_idx_type tda = a.cols ();
-          octave_idx_type ldb = b.rows ();
-          octave_idx_type tdb = b.cols ();
-
-          retval = FloatMatrix (a_nr, b_nc);
-          float *c = retval.fortran_vec ();
-
-          if (b_nc == 1)
-            {
-              if (a_nr == 1)
-                F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
-              else
-                {
-                  const char ctra = get_blas_trans_arg (tra);
-                  F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                           lda, tda, 1.0,  a.data (), lda,
-                                           b.data (), 1, 0.0, c, 1
-                                           F77_CHAR_ARG_LEN (1)));
-                }
-            }
-          else if (a_nr == 1)
-            {
-              const char crevtrb = get_blas_trans_arg (! trb);
-              F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                       ldb, tdb, 1.0,  b.data (), ldb,
-                                       a.data (), 1, 0.0, c, 1
-                                       F77_CHAR_ARG_LEN (1)));
-            }
-          else
-            {
-              const char ctra = get_blas_trans_arg (tra);
-              const char ctrb = get_blas_trans_arg (trb);
-              F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                       F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                       a_nr, b_nc, a_nc, 1.0, a.data (),
-                                       lda, b.data (), ldb, 0.0, c, a_nr
-                                       F77_CHAR_ARG_LEN (1)
-                                       F77_CHAR_ARG_LEN (1)));
-            }
+          const char ctra = get_blas_trans_arg (tra);
+          const char ctrb = get_blas_trans_arg (trb);
+          F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
+                                   F77_CONST_CHAR_ARG2 (&ctrb, 1),
+                                   a_nr, b_nc, a_nc, 1.0, a.data (),
+                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   F77_CHAR_ARG_LEN (1)
+                                   F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 FloatMatrix
 operator * (const FloatMatrix& a, const FloatMatrix& b)
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -196,34 +196,32 @@ operator * (const FloatRowVector& v, con
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     err_nonconformant ("operator *", 1, len, a_nr, a_nc);
+
+  if (len == 0)
+    retval.resize (a_nc, 0.0);
   else
     {
-      if (len == 0)
-        retval.resize (a_nc, 0.0);
-      else
-        {
-          // Transpose A to form A'*x == (x'*A)'
+      // Transpose A to form A'*x == (x'*A)'
 
-          octave_idx_type ld = a_nr;
+      octave_idx_type ld = a_nr;
 
-          retval.resize (a_nc);
-          float *y = retval.fortran_vec ();
+      retval.resize (a_nc);
+      float *y = retval.fortran_vec ();
 
-          F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                                   a_nr, a_nc, 1.0, a.data (),
-                                   ld, v.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
-        }
+      F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
+                               a_nr, a_nc, 1.0, a.data (),
+                               ld, v.data (), 1, 0.0, y, 1
+                               F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations
 
 float
@@ -319,17 +317,18 @@ operator * (const FloatRowVector& v, con
   float retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
-  else if (len != 0)
+
+  if (len != 0)
     F77_FUNC (xsdot, XSDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 FloatComplex
 operator * (const FloatRowVector& v, const FloatComplexColumnVector& a)
 {
