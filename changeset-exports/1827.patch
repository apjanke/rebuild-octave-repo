# HG changeset patch
# User jwe
# Date 823270210 0
#      Fri Feb 02 14:10:10 1996 +0000
# Node ID effa9400766fe5aab4a39ccceb29ee2f5c7f8666
# Parent  b14829582cc44e7e088b14b1b858c140678ee857
[project @ 1996-02-02 14:07:51 by jwe]

diff --git a/src/pt-base.cc b/src/pt-base.cc
--- a/src/pt-base.cc
+++ b/src/pt-base.cc
@@ -1,12 +1,12 @@
 // pt-base.cc                                           -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -35,51 +35,51 @@ Software Foundation, 59 Temple Place - S
 
 #include "pt-base.h"
 #include "user-prefs.h"
 
 // Current indentation.
 int tree_print_code::curr_print_indent_level = 0;
 
 // Nonzero means we are at the beginning of a line.
-int tree_print_code::beginning_of_line = 1;
+bool tree_print_code::beginning_of_line = true;
 
 // All print_code() functions should use this to print new lines.
 
 void
 tree_print_code::print_code_new_line (ostream& os)
 {
   os << "\n";
 
-  beginning_of_line = 1;
+  beginning_of_line = true;
 }
 
 // Each print_code() function should call this before printing
 // anything.
 //
 // This doesn't need to be fast, but isn't there a better way?
 
 void
 tree_print_code::print_code_indent (ostream& os)
 {
   assert (curr_print_indent_level >= 0);
  
   if (beginning_of_line)
     {
       os.form ("%s%*s", user_pref.ps4.c_str (), curr_print_indent_level, "");
-      beginning_of_line = 0;
+      beginning_of_line = false;
     }
 }
 
 // For ressetting print_code state.
 
 void
 tree_print_code::print_code_reset (void)
 {
-  beginning_of_line = 1;
+  beginning_of_line = true;
   curr_print_indent_level = 0;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -1,12 +1,12 @@
 // pt-base.h                                           -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -52,17 +52,17 @@ public:
   void print_code_new_line (ostream& os);
 
   void print_code_indent (ostream& os);
 
   void print_code_reset (void);
 
 private:
   static int curr_print_indent_level;
-  static int beginning_of_line;
+  static bool beginning_of_line;
 };
 
 // Base class for the parse tree.
 
 class
 tree : public tree_print_code
 {
 public:
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -1,12 +1,12 @@
 // pt-cmd.cc                                           -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -51,25 +51,25 @@ int returning = 0;
 #include "pt-fvc.h"
 #include "pt-misc.h"
 #include "pt-mvr.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "variables.h"
 
 // Decide if it's time to quit a for or while loop.
-static inline int
+static inline bool
 quit_loop_now (void)
 {
   // Maybe handle `continue N' someday...
 
   if (continuing)
     continuing--;
 
-  int quit = (returning || breaking || continuing);
+  bool quit = (returning || breaking || continuing);
 
   if (breaking)
     breaking--;
 
   return quit;
 }
 
 // But first, some extra functions used by the tree classes.
@@ -207,142 +207,142 @@ tree_for_command::~tree_for_command (voi
   delete id;
   delete id_list;
   delete expr;
   delete list;
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_return_list *lst,
-				    const Octave_object& rhs, int& quit)
+				    const Octave_object& rhs, bool& quit)
 {
-  quit = 0;
+  quit = false;
 
   tree_oct_obj *tmp = new tree_oct_obj (rhs);
   tree_multi_assignment_expression tmp_ass (lst, tmp, 1);
-  tmp_ass.eval (0);
+  tmp_ass.eval (false);
 
   if (error_state)
     {
       eval_error ();
       return;
     }
 
   if (list)
     {
       list->eval (1);
       if (error_state)
 	{
 	  eval_error ();
-	  quit = 1;
+	  quit = true;
 	  return;
 	}
     }
 
   quit = quit_loop_now ();
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_index_expression *idx_expr,
-				    const tree_constant& rhs, int& quit)
+				    const tree_constant& rhs, bool& quit)
 {
-  quit = 0;
+  quit = false;
 
   tree_constant *tmp = new tree_constant (rhs);
-  tree_simple_assignment_expression tmp_ass (idx_expr, tmp, 1);
-  tmp_ass.eval (0);
+  tree_simple_assignment_expression tmp_ass (idx_expr, tmp, true);
+  tmp_ass.eval (false);
 
   if (error_state)
     {
       eval_error ();
       return;
     }
 
   if (list)
     {
       list->eval (1);
       if (error_state)
 	{
 	  eval_error ();
-	  quit = 1;
+	  quit = true;
 	  return;
 	}
     }
 
   quit = quit_loop_now ();
 }
 
 inline void
 tree_for_command::do_for_loop_once (tree_identifier *ident,
-				    tree_constant& rhs, int& quit)
+				    tree_constant& rhs, bool& quit)
 {
-  quit = 0;
+  quit = false;
 
   ident->assign (rhs);
 
   if (error_state)
     {
       eval_error ();
       return;
     }
 
   if (list)
     {
       list->eval (1);
       if (error_state)
 	{
 	  eval_error ();
-	  quit = 1;
+	  quit = true;
 	  return;
 	}
     }
 
   quit = quit_loop_now ();
 }
 
 #define DO_LOOP(val) \
   do \
     { \
       if (ident) \
 	for (int i = 0; i < steps; i++) \
 	  { \
 	    tree_constant rhs (val); \
-	    int quit = 0; \
+	    bool quit = false; \
 	    do_for_loop_once (ident, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
       else if (id_list) \
 	for (int i = 0; i < steps; i++) \
 	  { \
 	    Octave_object rhs (val); \
-	    int quit = 0; \
+	    bool quit = false; \
 	    do_for_loop_once (id_list, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
       else \
 	for (int i = 0; i < steps; i++) \
 	  { \
 	    tree_constant rhs (val); \
-	    int quit = 0; \
+	    bool quit = false; \
 	    do_for_loop_once (tmp_id, rhs, quit); \
 	    if (quit) \
 	      break; \
 	  } \
     } \
   while (0)
 
 void
 tree_for_command::eval (void)
 {
   if (error_state || ! expr)
     return;
 
-  tree_constant tmp_expr = expr->eval (0);
+  tree_constant tmp_expr = expr->eval (false);
 
   if (error_state || tmp_expr.is_undefined ())
     {
       eval_error ();
       return;
     }
 
   tree_index_expression *tmp_id = id;
@@ -360,17 +360,17 @@ tree_for_command::eval (void)
   if (id_list && ! ident && ! tmp_expr.is_map ())
     {
       error ("in statement `for [X, Y] = VAL', VAL must be a structure");
       return;
     }
 
   if (tmp_expr.is_scalar_type ())
     {
-      int quit = 0;
+      bool quit = false;
       if (ident)
 	do_for_loop_once (ident, tmp_expr, quit);
       else if (id_list)
 	{
 	  Octave_object rhs (tmp_expr);
 	  do_for_loop_once (id_list, rhs, quit);
 	}
       else
@@ -425,47 +425,47 @@ tree_for_command::eval (void)
       if (ident)
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
 	      tree_constant rhs (tmp_val);
 
-	      int quit = 0;
+	      bool quit = false;
 	      do_for_loop_once (ident, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else if (id_list)
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
 	      Octave_object rhs (tmp_val);
 
-	      int quit = 0;
+	      bool quit = false;
 	      do_for_loop_once (id_list, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else
 	{
 	  for (int i = 0; i < steps; i++)
 	    {
 	      double tmp_val = b + i * increment;
 
 	      tree_constant rhs (tmp_val);
 
-	      int quit = 0;
+	      bool quit = false;
 	      do_for_loop_once (tmp_id, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
     }
   else if (tmp_expr.is_map ())
@@ -473,17 +473,17 @@ tree_for_command::eval (void)
       if (ident)
 	{
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
 	      tree_constant rhs (tmp_val.contents (p));
 
-	      int quit;
+	      bool quit = false;
 	      do_for_loop_once (ident, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else if (id_list)
 	{
@@ -494,32 +494,32 @@ tree_for_command::eval (void)
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
 	      Octave_object tmp;
 	      tmp (1) = tmp_val.key (p);
 	      tmp (0) = tmp_val.contents (p);
 
-	      int quit;
+	      bool quit = false;
 	      do_for_loop_once (id_list, tmp, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
       else
 	{
 	  Octave_map tmp_val (tmp_expr.map_value ());
 
 	  for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
 	    {
 	      tree_constant rhs = tmp_val.contents (p);
 
-	      int quit;
+	      bool quit = false;
 	      do_for_loop_once (tmp_id, rhs, quit);
 
 	      if (quit)
 		break;
 	    }
 	}
     }
   else
@@ -626,17 +626,17 @@ do_catch_code (void *ptr)
 
   unwind_protect_int (returning);
   returning = 0;
 
   unwind_protect_int (breaking);
   breaking = 0;
 
   if (list)
-    list->eval (1);
+    list->eval (true);
 
   // This is the one for breaking.  (The unwind_protects are popped
   // off the stack in the reverse of the order they are pushed on).
 
   // XXX FIXME XXX -- inside a try-catch, should break work like
   // a return, or just jump to the end of the try_catch block?
   // The following code makes it just jump to the end of the block.
 
@@ -663,17 +663,17 @@ tree_try_catch_command::eval (void)
 
   if (catch_code)
     {
       unwind_protect_int (buffer_error_messages);
       buffer_error_messages = 1;
     }
 
   if (try_code)
-    try_code->eval (1);
+    try_code->eval (true);
 
   if (catch_code && error_state)
     {
       error_state = 0;
       run_unwind_frame ("tree_try_catch::eval");
     }
   else
     {
@@ -744,17 +744,17 @@ do_unwind_protect_cleanup_code (void *pt
 
   unwind_protect_int (returning);
   returning = 0;
 
   unwind_protect_int (breaking);
   breaking = 0;
 
   if (list)
-    list->eval (1);
+    list->eval (true);
 
   // This is the one for breaking.  (The unwind_protects are popped
   // off the stack in the reverse of the order they are pushed on).
 
   // XXX FIXME XXX -- inside an unwind_protect, should break work like
   // a return, or just jump to the end of the unwind_protect block?
   // The following code makes it just jump to the end of the block.
 
@@ -780,17 +780,17 @@ do_unwind_protect_cleanup_code (void *pt
 }
 
 void
 tree_unwind_protect_command::eval (void)
 {
   add_unwind_protect (do_unwind_protect_cleanup_code, cleanup_code);
 
   if (unwind_protect_code)
-    unwind_protect_code->eval (1);
+    unwind_protect_code->eval (true);
 
   run_unwind_protect ();
 }
 
 void
 tree_unwind_protect_command::print_code (ostream& os)
 {
   print_code_indent (os);
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -1,12 +1,12 @@
 // pt-cmd.h                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -141,23 +141,23 @@ public:
   void eval (void);
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
 private:
   void do_for_loop_once (tree_return_list *lst,
-			 const Octave_object& rhs, int& quit);
+			 const Octave_object& rhs, bool& quit);
 
   void do_for_loop_once (tree_index_expression *idx_expr,
-			 const tree_constant& rhs, int& quit);
+			 const tree_constant& rhs, bool& quit);
 
   void do_for_loop_once (tree_identifier *ident,
-			 tree_constant& rhs, int& quit);
+			 tree_constant& rhs, bool& quit);
 
   tree_index_expression *id;	// Identifier to modify.
   tree_return_list *id_list;	// List of identifiers to modify.
   tree_expression *expr;	// Expression to evaluate.
   tree_statement_list *list;	// List of commands to execute.
 };
 
 // If.
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -1,12 +1,12 @@
 // pt-const.cc                                         -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -95,26 +95,28 @@ increment_structure_indent_level (void)
 }
 
 static void
 decrement_structure_indent_level (void)
 {
   structure_indent_level -= 2;
 }
 
-static int
+static bool
 any_element_is_complex (const ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
+
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (imag (a.elem (i, j)) != 0.0)
-	return 1;
-  return 0;
+	return true;
+
+  return false;
 }
 
 // The following three variables could be made static members of the
 // tree_constant class.
 
 // Pointer to the blocks of memory we manage.
 static tree_constant *tc_newlist = 0;
 
@@ -183,18 +185,18 @@ tree_constant::operator = (const tree_co
 	delete rep;
       rep = a.rep;
       rep->count++;
     }
   return *this;  
 }
 
 tree_constant
-tree_constant::lookup_map_element (const string& ref, int insert,
-				   int silent)
+tree_constant::lookup_map_element (const string& ref, bool insert,
+				   bool silent)
 {
   tree_constant retval;
 
   if (! ref.empty ())
     {
       SLList<string> list;
 
       size_t beg = 0;
@@ -213,18 +215,18 @@ tree_constant::lookup_map_element (const
 
       retval = lookup_map_element (list, insert, silent);
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant::lookup_map_element (SLList<string>& list, int insert,
-				   int silent)
+tree_constant::lookup_map_element (SLList<string>& list, bool insert,
+				   bool silent)
 {
   tree_constant retval;
 
   tree_constant_rep *tmp_rep = rep;
 
   Pix p = list.first ();
   while (p)
     {
@@ -253,37 +255,37 @@ tree_constant::print (void)
 {
   ostrstream output_buf;
   print (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 void
-tree_constant::print_with_name (const string& name, int print_padding)
+tree_constant::print_with_name (const string& name, bool print_padding)
 {
   ostrstream output_buf;
   print_with_name (output_buf, name, print_padding);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 void
 tree_constant::print_with_name (ostream& output_buf, const string& name,
-				int print_padding) 
+				bool print_padding) 
 {
-  int pad_after = 0;
+  bool pad_after = false;
 
   if (user_pref.print_answer_id_name)
     {
       if (print_as_scalar () || print_as_structure ())
 	output_buf << name << " = ";
       else
 	{
-	  pad_after = 1;
+	  pad_after = true;
 	  output_buf << name << " =\n\n";
 	}
     }
 
   print (output_buf);
 
   if (print_padding && pad_after)
     output_buf << "\n";
@@ -387,17 +389,17 @@ tree_constant::assign_map_element (SLLis
 
       tmp_rep = tmp.make_unique_map ();
     }
 
   return tree_constant ();
 }
 
 Octave_object
-tree_constant::eval (int print, int, const Octave_object& args)
+tree_constant::eval (bool print, int, const Octave_object& args)
 {
   Octave_object retval;
 
   if (args.length () > 0)
     retval(0) = rep->do_index (args);
   else
     retval(0) = *this;
 
@@ -700,17 +702,17 @@ TC_REP::tree_constant_rep (const string_
     {
       nc = s[i].length ();
       for (int j = 0; j < nc; j++)
 	char_matrix->elem (i, j) = s[i][j];
     }
   type_tag = char_matrix_constant_str;
 }
 
-TC_REP::tree_constant_rep (const charMatrix& chm, int is_str)
+TC_REP::tree_constant_rep (const charMatrix& chm, bool is_str)
 {
   char_matrix = new charMatrix (chm);
   type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
 }
 
 TC_REP::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
@@ -1053,48 +1055,48 @@ TC_REP::any (void) const
     default:
       gripe_wrong_type_arg ("any", *this);
       break;
     }
 
   return retval;
 }
 
-int
+bool
 TC_REP::valid_as_scalar_index (void) const
 {
   return (type_tag == magic_colon
 	  || (type_tag == scalar_constant 
 	      && ! xisnan (scalar)
 	      && NINT (scalar) == 1)
 	  || (type_tag == range_constant
 	      && range->nelem () == 1
 	      && ! xisnan (range->base ())
 	      && NINT (range->base ()) == 1));
 }
 
-int
+bool
 TC_REP::valid_as_zero_index (void) const
 {
   return ((type_tag == scalar_constant
 	   && ! xisnan (scalar)
 	   && NINT (scalar) == 0)
 	  || (type_tag == matrix_constant
 	      && matrix->rows () == 0
 	      && matrix->columns () == 0)
 	  || (type_tag == range_constant
 	      && range->nelem () == 1
 	      && ! xisnan (range->base ())
 	      && NINT (range->base ()) == 0));
 }
 
-int
+bool
 TC_REP::is_true (void) const
 {
-  int retval = 0;
+  int retval = false;
 
   if (error_state)
     return retval;
 
   if (! is_numeric_type ())
     {
       tree_constant tmp = make_numeric ();
 
@@ -1142,17 +1144,17 @@ TC_REP::is_true (void) const
 
 static void
 warn_implicit_conversion (const char *from, const char *to)
 {
   warning ("implicit conversion from %s to %s", from, to);
 }
 
 double
-TC_REP::double_value (int force_str_conv) const
+TC_REP::double_value (bool force_string_conv) const
 {
   double retval = octave_NaN;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
@@ -1202,17 +1204,17 @@ TC_REP::double_value (int force_str_conv
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "real scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
-	int flag = force_str_conv;
+	int flag = force_string_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real scalar");
 
 	int len = char_matrix->rows ();
 	if (flag
@@ -1238,17 +1240,17 @@ TC_REP::double_value (int force_str_conv
       gripe_invalid_conversion (type_as_string (), "real scalar");
       break;
     }
 
   return retval;
 }
 
 Matrix
-TC_REP::matrix_value (int force_str_conv) const
+TC_REP::matrix_value (bool force_string_conv) const
 {
   Matrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = Matrix (1, 1, scalar);
       break;
@@ -1279,17 +1281,17 @@ TC_REP::matrix_value (int force_str_conv
       break;
 
     case char_matrix_constant:
       retval = Matrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
-	int flag = force_str_conv;
+	int flag = force_string_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real matrix");
 
 	if (flag)
 	  retval = Matrix (*char_matrix);
@@ -1306,17 +1308,17 @@ TC_REP::matrix_value (int force_str_conv
       gripe_invalid_conversion (type_as_string (), "real matrix");
       break;
     }
 
   return retval;
 }
 
 Complex
-TC_REP::complex_value (int force_str_conv) const
+TC_REP::complex_value (bool force_string_conv) const
 {
   Complex retval (octave_NaN, octave_NaN);
 
   switch (type_tag)
     {
     case complex_scalar_constant:
       retval = *complex_scalar;
       break;
@@ -1348,17 +1350,17 @@ TC_REP::complex_value (int force_str_con
 	  retval = toascii ((int) char_matrix->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "complex scalar");
       }
       break;
 
     case char_matrix_constant_str:
       {
-	int flag = force_str_conv;
+	int flag = force_string_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex scalar");
 
 	int len = char_matrix->cols ();
 	if (flag
@@ -1384,17 +1386,17 @@ TC_REP::complex_value (int force_str_con
       gripe_invalid_conversion (type_as_string (), "complex scalar");
       break;
     }
 
   return retval;
 }
 
 ComplexMatrix
-TC_REP::complex_matrix_value (int force_str_conv) const
+TC_REP::complex_matrix_value (bool force_string_conv) const
 {
   ComplexMatrix retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = ComplexMatrix (1, 1, Complex (scalar));
       break;
@@ -1412,17 +1414,17 @@ TC_REP::complex_matrix_value (int force_
       break;
 
     case char_matrix_constant:
       retval = ComplexMatrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
-	int flag = force_str_conv;
+	int flag = force_string_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex matrix");
 
 	if (flag)
 	  retval = ComplexMatrix (*char_matrix);
@@ -1441,21 +1443,21 @@ TC_REP::complex_matrix_value (int force_
     }
 
   return retval;
 }
 
 // XXX FIXME XXX -- this needs to try to do some conversions...
 
 charMatrix
-TC_REP::char_matrix_value (int force_str_conv) const
+TC_REP::char_matrix_value (bool force_string_conv) const
 {
   charMatrix retval;
 
-  int flag = force_str_conv;
+  int flag = force_string_conv;
   if (! flag)
     flag = user_pref.implicit_str_to_num_ok;
 
   switch (type_tag)
     {
     case char_matrix_constant:
     case char_matrix_constant_str:
       retval = *char_matrix;
@@ -1505,17 +1507,17 @@ TC_REP::range_value (void) const
 Octave_map
 TC_REP::map_value (void) const
 {
   assert (type_tag == map_constant);
   return *a_map;
 }
 
 tree_constant&
-TC_REP::lookup_map_element (const string& name, int insert, int silent)
+TC_REP::lookup_map_element (const string& name, bool insert, bool silent)
 {
   static tree_constant retval;
 
   if (type_tag == map_constant)
     {
       Pix idx = a_map->seek (name);
 
       if (idx)
@@ -1530,22 +1532,22 @@ TC_REP::lookup_map_element (const string
 
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on matrix_value() to do any possible type conversions.
 
 ColumnVector
-TC_REP::vector_value (int force_str_conv,
-		      int force_vector_conversion) const
+TC_REP::vector_value (bool force_string_conv,
+		      bool force_vector_conversion) const
 {
   ColumnVector retval;
 
-  Matrix m = matrix_value (force_str_conv);
+  Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
@@ -1574,22 +1576,22 @@ TC_REP::vector_value (int force_str_conv
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
 // than relying on complex_matrix_value() to do any possible type
 // conversions.
 
 ComplexColumnVector
-TC_REP::complex_vector_value (int force_str_conv,
-			      int force_vector_conversion) const
+TC_REP::complex_vector_value (bool force_string_conv,
+			      bool force_vector_conversion) const
 {
   ComplexColumnVector retval;
 
-  ComplexMatrix m = complex_matrix_value (force_str_conv);
+  ComplexMatrix m = complex_matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
   int nr = m.rows ();
   int nc = m.columns ();
   if (nr == 1)
     {
@@ -1803,17 +1805,17 @@ TC_REP::convert_to_row_or_column_vector 
 	}
 
       delete complex_matrix;
       complex_matrix = cm;
     }
 }
 
 void
-TC_REP::convert_to_matrix_type (int make_complex)
+TC_REP::convert_to_matrix_type (bool make_complex)
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
       {
 	Complex *old_complex = complex_scalar;
 	complex_matrix = new ComplexMatrix (1, 1, *complex_scalar);
 	type_tag = complex_matrix_constant;
@@ -1872,30 +1874,30 @@ TC_REP::convert_to_matrix_type (int make
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::force_numeric (int force_str_conv)
+TC_REP::force_numeric (bool force_string_conv)
 {
   switch (type_tag)
     {
     case scalar_constant:
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
     case char_matrix_constant:
       break;
 
     case char_matrix_constant_str:
       {
-	if (! force_str_conv && ! user_pref.implicit_str_to_num_ok)
+	if (! force_string_conv && ! user_pref.implicit_str_to_num_ok)
 	  {
 	    ::error ("string to numeric conversion failed --\
  default conversion turned off");
 	    return;
 	  }
 
 	int nr = char_matrix->rows ();
 	int nc = char_matrix->cols ();
@@ -1959,17 +1961,17 @@ TC_REP::force_numeric (int force_str_con
 
     default:
       gripe_invalid_conversion (type_as_string (), "numeric type");
       break;
     }
 }
 
 tree_constant
-TC_REP::make_numeric (int force_str_conv) const
+TC_REP::make_numeric (bool force_string_conv) const
 {
   tree_constant retval;
 
   switch (type_tag)
     {
     case scalar_constant:
       retval = scalar;
       break;
@@ -1987,36 +1989,36 @@ TC_REP::make_numeric (int force_str_conv
       break;
 
     case char_matrix_constant:
       retval = *char_matrix;
       break;
 
     case char_matrix_constant_str:
       {
-	int flag = force_str_conv;
+	int flag = force_string_conv;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "char matrix");
 
 	if (flag)
 	  {
 	    retval = *char_matrix;
-	    retval.force_numeric (force_str_conv);
+	    retval.force_numeric (force_string_conv);
 	  }
 	else
 	  gripe_invalid_conversion ("string", "char matrix");
       }
       break;
 
     case range_constant:
       retval = *range;
-      retval.force_numeric (force_str_conv);
+      retval.force_numeric (force_string_conv);
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "numeric value");
       break;
     }
 
   return retval;
@@ -2400,18 +2402,18 @@ TC_REP::type_as_string (void) const
     }
 }
 
 tree_constant
 do_binary_op (tree_constant& a, tree_constant& b, tree_expression::type t)
 {
   tree_constant retval;
 
-  int first_empty = (a.rows () == 0 || a.columns () == 0);
-  int second_empty = (b.rows () == 0 || b.columns () == 0);
+  bool first_empty = (a.rows () == 0 || a.columns () == 0);
+  bool second_empty = (b.rows () == 0 || b.columns () == 0);
 
   if (first_empty || second_empty)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
@@ -2790,17 +2792,17 @@ TC_REP::set_index (char c)
 
     default:
       panic_impossible ();
       break;
     }
 }
 
 void
-TC_REP::set_index (const Octave_object& args, int rhs_is_complex)
+TC_REP::set_index (const Octave_object& args, bool rhs_is_complex)
 {
   switch (type_tag)
     {
     case unknown_constant:
     case scalar_constant:
     case complex_scalar_constant:
     case range_constant:
       convert_to_matrix_type (rhs_is_complex);
@@ -2834,37 +2836,37 @@ TC_REP::set_index (const Octave_object& 
       if (error_state)
 	{
 	  clear_index ();
 	  break;
 	}
     }
 }
 
-static inline int
+static inline bool
 valid_scalar_indices (const Octave_object& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (! args(i).valid_as_scalar_index ())
-      return 0;
-
-  return 1;
+      return false;
+
+  return true;
 }
 
 tree_constant
 TC_REP::do_index (const Octave_object& args)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  int originally_scalar_type = is_scalar_type ();
+  bool originally_scalar_type = is_scalar_type ();
 
   if (originally_scalar_type && valid_scalar_indices (args))
     {
       switch (type_tag)
 	{
 	case scalar_constant:
 	  retval = scalar;
 	  break;
@@ -3108,30 +3110,31 @@ TC_REP::assign (tree_constant& rhs, cons
 
   // Do the right thing for assignments like `x(1) = pi' when x is
   // undefined before the assignment.
 
   if (is_matrix_type () || is_range ())
     maybe_mutate ();
 }
 
-int
+bool
 TC_REP::print_as_scalar (void)
 {
   int nr = rows ();
   int nc = columns ();
+
   return (is_scalar_type ()
 	  || (is_string () && nr <= 1)
 	  || (is_matrix_type ()
 	      && ((nr == 1 && nc == 1)
 		  || nr == 0
 		  || nc == 0)));
 }
 
-int
+bool
 TC_REP::print_as_structure (void)
 {
   return is_map ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -1,12 +1,12 @@
 // pt-const.h                                        -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -49,279 +49,279 @@ class
 tree_constant : public tree_fvc
 {
 private:
 
 // The actual representation of the tree_constant.
 
   class
   tree_constant_rep
-    {
-      private:
-
-      friend class tree_constant;
+  {
+  public:
 
-	enum constant_type
-	  {
-	    unknown_constant,
-	    scalar_constant,
-	    matrix_constant,
-	    complex_scalar_constant,
-	    complex_matrix_constant,
-	    char_matrix_constant,
-	    char_matrix_constant_str,
-	    range_constant,
-	    map_constant,
-	    magic_colon,
-	    all_va_args,
-	  };
+    enum constant_type
+      {
+	unknown_constant,
+	scalar_constant,
+	matrix_constant,
+	complex_scalar_constant,
+	complex_matrix_constant,
+	char_matrix_constant,
+	char_matrix_constant_str,
+	range_constant,
+	map_constant,
+	magic_colon,
+	all_va_args,
+      };
 
-	enum force_orient
-	  {
-	    no_orient,
-	    row_orient,
-	    column_orient,
-	  };
+    enum force_orient
+      {
+	no_orient,
+	row_orient,
+	column_orient,
+      };
 
-	tree_constant_rep (void);
+    tree_constant_rep (void);
 
-	tree_constant_rep (double d);
-	tree_constant_rep (const Matrix& m);
-	tree_constant_rep (const DiagMatrix& d);
-	tree_constant_rep (const RowVector& v, int pcv);
-	tree_constant_rep (const ColumnVector& v, int pcv);
+    tree_constant_rep (double d);
+    tree_constant_rep (const Matrix& m);
+    tree_constant_rep (const DiagMatrix& d);
+    tree_constant_rep (const RowVector& v, int pcv);
+    tree_constant_rep (const ColumnVector& v, int pcv);
 
-	tree_constant_rep (const Complex& c);
-	tree_constant_rep (const ComplexMatrix& m);
-	tree_constant_rep (const ComplexDiagMatrix& d);
-	tree_constant_rep (const ComplexRowVector& v, int pcv);
-	tree_constant_rep (const ComplexColumnVector& v, int pcv);
+    tree_constant_rep (const Complex& c);
+    tree_constant_rep (const ComplexMatrix& m);
+    tree_constant_rep (const ComplexDiagMatrix& d);
+    tree_constant_rep (const ComplexRowVector& v, int pcv);
+    tree_constant_rep (const ComplexColumnVector& v, int pcv);
 
-	tree_constant_rep (const char *s);
-	tree_constant_rep (const string& s);
-	tree_constant_rep (const string_vector& s);
-	tree_constant_rep (const charMatrix& chm, int is_string);
+    tree_constant_rep (const char *s);
+    tree_constant_rep (const string& s);
+    tree_constant_rep (const string_vector& s);
+    tree_constant_rep (const charMatrix& chm, bool is_string);
 
-	tree_constant_rep (double base, double limit, double inc);
-	tree_constant_rep (const Range& r);
+    tree_constant_rep (double base, double limit, double inc);
+    tree_constant_rep (const Range& r);
 
-	tree_constant_rep (const Octave_map& m);
+    tree_constant_rep (const Octave_map& m);
 
-	tree_constant_rep (tree_constant_rep::constant_type t);
+    tree_constant_rep (tree_constant_rep::constant_type t);
+
+    tree_constant_rep (const tree_constant_rep& t);
 
-	tree_constant_rep (const tree_constant_rep& t);
+    ~tree_constant_rep (void);
 
-	~tree_constant_rep (void);
+    void *operator new (size_t size);
+    void operator delete (void *p, size_t size);
 
-	void *operator new (size_t size);
-	void operator delete (void *p, size_t size);
+    int rows (void) const;
+    int columns (void) const;
 
-	int rows (void) const;
-	int columns (void) const;
+    bool is_defined (void) const
+      { return type_tag != unknown_constant; }
 
-	int is_defined (void) const
-	  { return type_tag != unknown_constant; }
+    bool is_undefined (void) const
+      { return type_tag == unknown_constant; }
 
-	int is_undefined (void) const
-	  { return type_tag == unknown_constant; }
+    bool is_unknown (void) const
+      { return type_tag == unknown_constant; }
 
-	int is_unknown (void) const
-	  { return type_tag == unknown_constant; }
+    bool is_real_scalar (void) const
+      { return type_tag == scalar_constant; }
 
-	int is_real_scalar (void) const
-	  { return type_tag == scalar_constant; }
+    bool is_real_matrix (void) const
+      { return type_tag == matrix_constant; }
 
-	int is_real_matrix (void) const
-	  { return type_tag == matrix_constant; }
+    bool is_complex_scalar (void) const
+      { return type_tag == complex_scalar_constant; }
 
-	int is_complex_scalar (void) const
-	  { return type_tag == complex_scalar_constant; }
+    bool is_complex_matrix (void) const
+      { return type_tag == complex_matrix_constant; }
 
-	int is_complex_matrix (void) const
-	  { return type_tag == complex_matrix_constant; }
+    bool is_char_matrix (void) const
+      { return type_tag == char_matrix_constant; }
+
+    bool is_string (void) const
+      { return type_tag == char_matrix_constant_str; }
 
-	int is_char_matrix (void) const
-	  { return type_tag == char_matrix_constant; }
+    bool is_range (void) const
+      { return type_tag == range_constant; }
 
-	int is_string (void) const
-	  { return type_tag == char_matrix_constant_str; }
+    bool is_map (void) const
+      { return type_tag == map_constant; }
 
-	int is_range (void) const
-	  { return type_tag == range_constant; }
+    bool is_magic_colon (void) const
+      { return type_tag == magic_colon; }
 
-	int is_map (void) const
-	  { return type_tag == map_constant; }
+    bool is_all_va_args (void) const
+      { return type_tag == all_va_args; }
 
-	int is_magic_colon (void) const
-	  { return type_tag == magic_colon; }
+    tree_constant all (void) const;
+    tree_constant any (void) const;
 
-	int is_all_va_args (void) const
-	  { return type_tag == all_va_args; }
-
-	tree_constant all (void) const;
-	tree_constant any (void) const;
+    bool is_real_type (void) const
+      {
+	return (type_tag == scalar_constant
+		|| type_tag == matrix_constant
+		|| type_tag == range_constant
+		|| type_tag == char_matrix_constant
+		|| type_tag == char_matrix_constant_str);
+      }
 
-	int is_real_type (void) const
-	  {
-	    return (type_tag == scalar_constant
-		    || type_tag == matrix_constant
-		    || type_tag == range_constant
-		    || type_tag == char_matrix_constant
-		    || type_tag == char_matrix_constant_str);
-	  }
+    bool is_complex_type (void) const
+      {
+	return (type_tag == complex_matrix_constant
+		|| type_tag == complex_scalar_constant);
+      }
+
+    // Would be nice to get rid of the next four functions:
 
-	int is_complex_type (void) const
-	  {
-	    return (type_tag == complex_matrix_constant
-		    || type_tag == complex_scalar_constant);
-	  }
+    bool is_scalar_type (void) const
+      {
+	return (type_tag == scalar_constant
+		|| type_tag == complex_scalar_constant);
+      }
 
-	// Would be nice to get rid of the next four functions:
-
-	int is_scalar_type (void) const
-	  {
-	    return (type_tag == scalar_constant
-		    || type_tag == complex_scalar_constant);
-	  }
+    bool is_matrix_type (void) const
+      {
+	return (type_tag == matrix_constant
+		|| type_tag == complex_matrix_constant);
+      }
 
-	int is_matrix_type (void) const
-	  {
-	    return (type_tag == matrix_constant
-		    || type_tag == complex_matrix_constant);
-	  }
+    bool is_numeric_type (void) const
+      {
+	return (type_tag == scalar_constant
+		|| type_tag == matrix_constant
+		|| type_tag == complex_matrix_constant
+		|| type_tag == complex_scalar_constant);
+      }
 
-	int is_numeric_type (void) const
-	  {
-	    return (type_tag == scalar_constant
-		    || type_tag == matrix_constant
-		    || type_tag == complex_matrix_constant
-		    || type_tag == complex_scalar_constant);
-	  }
+    bool valid_as_scalar_index (void) const;
+    bool valid_as_zero_index (void) const;
+
+    bool is_true (void) const;
 
-	int valid_as_scalar_index (void) const;
-	int valid_as_zero_index (void) const;
-
-	int is_true (void) const;
+    bool is_empty (void) const
+      {
+	return ((! (is_magic_colon ()
+		    || is_all_va_args ()
+		    || is_unknown ()))
+		&& (rows () == 0
+		    || columns () == 0));
+      }
 
-	int is_empty (void) const
-	  {
-	    return ((! (is_magic_colon ()
-			|| is_all_va_args ()
-			|| is_unknown ()))
-		    && (rows () == 0
-			|| columns () == 0));
-	  }
+    double double_value (bool frc_str_conv = false) const;
+    Matrix matrix_value (bool frc_str_conv = false) const;
+    Complex complex_value (bool frc_str_conv = false) const;
+    ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const;
+    charMatrix char_matrix_value (bool frc_str_conv = false) const;
+    charMatrix all_strings (void) const;
+    string string_value (void) const;
+    Range range_value (void) const;
+    Octave_map map_value (void) const;
 
-	double double_value (int frc_str_conv = 0) const;
-	Matrix matrix_value (int frc_str_conv = 0) const;
-	Complex complex_value (int frc_str_conv = 0) const;
-	ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const;
-	charMatrix char_matrix_value (int frc_str_conv = 0) const;
-	charMatrix all_strings (void) const;
-        string string_value (void) const;
-	Range range_value (void) const;
-	Octave_map map_value (void) const;
+    tree_constant& lookup_map_element (const string& name,
+				       bool insert = false,
+				       bool silent = false);
+
+    ColumnVector vector_value (bool frc_str_conv = false,
+			       bool frc_vec_conv = false) const;
 
-	tree_constant& lookup_map_element (const string& name,
-					   int insert = 0,
-					   int silent = 0);
+    ComplexColumnVector
+    complex_vector_value (bool frc_str_conv = false,
+			  bool frc_vec_conv = false) const;
 
-	ColumnVector vector_value (int frc_str_conv = 0,
-				   int frc_vec_conv = 0) const;
+    tree_constant convert_to_str (void) const;
+
+    void convert_to_row_or_column_vector (void);
+
+    void bump_value (tree_expression::type);
 
-	ComplexColumnVector complex_vector_value (int frc_str_conv = 0,
-						  int frc_vec_conv = 0) const;
+    void resize (int i, int j);
+    void resize (int i, int j, double val);
 
-	tree_constant convert_to_str (void) const;
+    void stash_original_text (const string& s);
 
-	void convert_to_row_or_column_vector (void);
-
-	void bump_value (tree_expression::type);
+    void maybe_mutate (void);
 
-	void resize (int i, int j);
-	void resize (int i, int j, double val);
+    void print (void);
+    void print (ostream& os);
 
-	void stash_original_text (const string& s);
+    void print_code (ostream& os);
 
-	void maybe_mutate (void);
+    void gripe_wrong_type_arg (const char *name,
+			       const tree_constant_rep& tcr) const;
 
-	void print (void);
-	void print (ostream& os);
-
-	void print_code (ostream& os);
+    char *type_as_string (void) const;
 
-	void gripe_wrong_type_arg (const char *name,
-				   const tree_constant_rep& tcr) const;
+    // Binary and unary operations.
 
-	char *type_as_string (void) const;
-
-	// Binary and unary operations.
+    friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
+				       tree_expression::type t);
 
-	friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
-					   tree_expression::type t);
+    friend tree_constant do_unary_op (tree_constant& a,
+				      tree_expression::type t);
 
-	friend tree_constant do_unary_op (tree_constant& a,
-					  tree_expression::type t);
+    // We want to eliminate this.
 
-	// We want to eliminate this.
+    constant_type const_type (void) const { return type_tag; }
+
+    // We want to get rid of these too:
 
-	constant_type const_type (void) const { return type_tag; }
+    void force_numeric (bool frc_str_conv = false);
+    tree_constant make_numeric (bool frc_str_conv = false) const;
 
-	// We want to get rid of these too:
+    // But not this.
 
-	void force_numeric (int frc_str_conv = 0);
-	tree_constant make_numeric (int frc_str_conv = 0) const;
+    void convert_to_matrix_type (bool make_complex);
 
-	// But not this.
+    // Indexing and assignment.
 
-	void convert_to_matrix_type (int make_complex);
+    void clear_index (void);
 
-	// Indexing and assignment.
-
-	void clear_index (void);
+    // void set_index (double d);
+    void set_index (const Range& r);
+    void set_index (const ColumnVector& v);
+    void set_index (const Matrix& m);
+    void set_index (char c);
 
-	// void set_index (double d);
-	void set_index (const Range& r);
-	void set_index (const ColumnVector& v);
-	void set_index (const Matrix& m);
-	void set_index (char c);
+    void set_index (const Octave_object& args,
+		    bool rhs_is_complex = false);
 
-	void set_index (const Octave_object& args, int rhs_is_complex = 0);
+    tree_constant do_index (const Octave_object& args);
 
-	tree_constant do_index (const Octave_object& args);
+    void maybe_widen (constant_type t);
 
-	void maybe_widen (constant_type t);
+    void assign (tree_constant& rhs, const Octave_object& args);
 
-	void assign (tree_constant& rhs, const Octave_object& args);
+    bool print_as_scalar (void);
 
-	int print_as_scalar (void);
+    bool print_as_structure (void);
 
-	int print_as_structure (void);
-
-	// Data.
+    // Data.
 
-	union
-	  {
-	    double scalar;		    // A real scalar constant.
-	    Matrix *matrix;		    // A real matrix constant.
-	    Complex *complex_scalar;	    // A real scalar constant.
-	    ComplexMatrix *complex_matrix;  // A real matrix constant.
-	    charMatrix *char_matrix;	    // A character string constant.
-	    Range *range;		    // A set of evenly spaced values.
-	    Octave_map *a_map;	      	    // An associative array.
+    union
+      {
+	double scalar;			// A real scalar constant.
+	Matrix *matrix;			// A real matrix constant.
+	Complex *complex_scalar;	// A real scalar constant.
+	ComplexMatrix *complex_matrix;	// A real matrix constant.
+	charMatrix *char_matrix;	// A character string constant.
+	Range *range;			// A set of evenly spaced values.
+	Octave_map *a_map;		// An associative array.
 
-	    tree_constant_rep *freeptr;     // For custom memory management.
-	  };
+	tree_constant_rep *freeptr;	// For custom memory management.
+      };
 
-	constant_type type_tag;
+    constant_type type_tag;
 
-	int count;
+    int count;
 
-	string orig_text;
-    };
+    string orig_text;
+  };
 
   union
     {
       tree_constant *freeptr;  // For custom memory management.
       tree_constant_rep *rep;  // The real representation.
     };
 
 public:
@@ -393,17 +393,17 @@ public:
 
   tree_constant (const string& s, int l = -1, int c = -1) : tree_fvc (l, c)
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
   tree_constant (const string_vector& s, int l = -1, int c = -1)
     : tree_fvc (l, c)
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
-  tree_constant (const charMatrix& chm, int is_string = 0) : tree_fvc ()
+  tree_constant (const charMatrix& chm, bool is_string = false) : tree_fvc ()
     { rep = new tree_constant_rep (chm, is_string); rep->count = 1; }
 
   tree_constant (double base, double limit, double inc) : tree_fvc ()
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
 
   tree_constant (const Range& r) : tree_fvc ()
     { rep = new tree_constant_rep (r); rep->count = 1; }
 
@@ -467,124 +467,127 @@ public:
   // Indexed structure assignment.
 
   tree_constant assign_map_element (SLList<string>& list,
 				    tree_constant& rhs,
 				    const Octave_object& args);
 
   // Type.  It would be nice to eliminate the need for this.
 
-  int is_constant (void) const { return 1; }
+  bool is_constant (void) const { return true; }
 
   // Size.
 
   int rows (void) const { return rep->rows (); }
   int columns (void) const { return rep->columns (); }
 
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
-  int is_defined (void) const { return rep->is_defined (); }
-  int is_undefined (void) const { return rep->is_undefined (); }
+  bool is_defined (void) const { return rep->is_defined (); }
+  bool is_undefined (void) const { return rep->is_undefined (); }
 
   // Is this constant a particular type, or does it belong to a
   // particular class of types?
 
-  int is_unknown (void) const { return rep->is_unknown (); }
-  int is_real_scalar (void) const { return rep->is_real_scalar (); }
-  int is_real_matrix (void) const { return rep->is_real_matrix (); }
-  int is_complex_scalar (void) const { return rep->is_complex_scalar (); }
-  int is_complex_matrix (void) const { return rep->is_complex_matrix (); }
-  int is_string (void) const { return rep->is_string (); }
-  int is_range (void) const { return rep->is_range (); }
-  int is_map (void) const { return rep->is_map (); }
-  int is_magic_colon (void) const { return rep->is_magic_colon (); }
-  int is_all_va_args (void) const { return rep->is_all_va_args (); }
+  bool is_unknown (void) const { return rep->is_unknown (); }
+  bool is_real_scalar (void) const { return rep->is_real_scalar (); }
+  bool is_real_matrix (void) const { return rep->is_real_matrix (); }
+  bool is_complex_scalar (void) const { return rep->is_complex_scalar (); }
+  bool is_complex_matrix (void) const { return rep->is_complex_matrix (); }
+  bool is_string (void) const { return rep->is_string (); }
+  bool is_range (void) const { return rep->is_range (); }
+  bool is_map (void) const { return rep->is_map (); }
+  bool is_magic_colon (void) const { return rep->is_magic_colon (); }
+  bool is_all_va_args (void) const { return rep->is_all_va_args (); }
 
   // Are any or all of the elements in this constant nonzero?
 
   tree_constant all (void) const { return rep->all (); }
   tree_constant any (void) const { return rep->any (); }
 
   // Other type stuff.
 
-  int is_real_type (void) const { return rep->is_real_type (); }
+  bool is_real_type (void) const { return rep->is_real_type (); }
 
-  int is_complex_type (void) const { return rep->is_complex_type (); }
+  bool is_complex_type (void) const { return rep->is_complex_type (); }
 
-  int is_scalar_type (void) const { return rep->is_scalar_type (); }
-  int is_matrix_type (void) const { return rep->is_matrix_type (); }
+  bool is_scalar_type (void) const { return rep->is_scalar_type (); }
+  bool is_matrix_type (void) const { return rep->is_matrix_type (); }
 
-  int is_numeric_type (void) const
+  bool is_numeric_type (void) const
     { return rep->is_numeric_type (); }
 
-  int valid_as_scalar_index (void) const
+  bool valid_as_scalar_index (void) const
     { return rep->valid_as_scalar_index (); }
 
-  int valid_as_zero_index (void) const
+  bool valid_as_zero_index (void) const
     { return rep->valid_as_zero_index (); }
 
   // Does this constant correspond to a truth value?
 
-  int is_true (void) const { return rep->is_true (); }
+  bool is_true (void) const { return rep->is_true (); }
 
   // Is at least one of the dimensions of this constant zero?
 
-  int is_empty (void) const
+  bool is_empty (void) const
     { return rep->is_empty (); }
 
   // Are the dimensions of this constant zero by zero?
 
-  int is_zero_by_zero (void) const
+  bool is_zero_by_zero (void) const
     {
       return ((! (is_magic_colon () || is_all_va_args () || is_unknown ()))
 	      && rows () == 0 && columns () == 0);
     } 
 
   // Values.
 
-  double double_value (int frc_str_conv = 0) const
+  double double_value (bool frc_str_conv = false) const
     { return rep->double_value (frc_str_conv); }
 
-  Matrix matrix_value (int frc_str_conv = 0) const
+  Matrix matrix_value (bool frc_str_conv = false) const
     { return rep->matrix_value (frc_str_conv); }
 
-  Complex complex_value (int frc_str_conv = 0) const
+  Complex complex_value (bool frc_str_conv = false) const
     { return rep->complex_value (frc_str_conv); }
 
-  ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const
+  ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const
     { return rep->complex_matrix_value (frc_str_conv); }
 
-  charMatrix char_matrix_value (int frc_str_conv = 0) const
+  charMatrix char_matrix_value (bool frc_str_conv = false) const
     { return rep->char_matrix_value (frc_str_conv); }
 
   charMatrix all_strings (void) const
     { return rep->all_strings (); }
 
   string string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
   Octave_map map_value (void) const;
 
-  tree_constant lookup_map_element (const string& ref, int insert = 0,
-				    int silent = 0);
+  tree_constant lookup_map_element (const string& ref,
+				    bool insert = false,
+				    bool silent = false);
 
   tree_constant lookup_map_element (SLList<string>& list,
-				    int insert = 0, int silent = 0);
+				    bool insert = false,
+				    bool silent = false);
 
-  ColumnVector vector_value (int /* frc_str_conv */ = 0,
-			     int /* frc_vec_conv */ = 0) const 
+  ColumnVector vector_value (bool /* frc_str_conv */ = false,
+			     bool /* frc_vec_conv */ = false) const 
     { return rep->vector_value (); }
 
-  ComplexColumnVector complex_vector_value (int /* frc_str_conv */ = 0,
-					    int /* frc_vec_conv */ = 0) const
+  ComplexColumnVector
+  complex_vector_value (bool /* frc_str_conv */ = false,
+			bool /* frc_vec_conv */ = false) const
     { return rep->complex_vector_value (); }
 
   // Binary and unary operations.
 
   friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
 				     tree_expression::type t);
 
   friend tree_constant do_unary_op (tree_constant& a,
@@ -612,35 +615,35 @@ public:
 	}
 
       rep->bump_value (et);
     }
 
   void print (void);
   void print (ostream& os) { rep->print (os); }
 
-  void print_with_name (const string& name, int print_padding = 1);
+  void print_with_name (const string& name, bool print_padding = true);
   void print_with_name (ostream& os, const string& name,
-			int print_padding = 1);
+			bool print_padding = true);
 
   // Evaluate this constant, possibly converting complex to real, or
   // matrix to scalar, etc.
 
-  tree_constant eval (int print_result)
+  tree_constant eval (bool print_result)
     {
       if (print_result)
 	{
 	  rep->maybe_mutate ();  // XXX FIXME XXX -- is this necessary?
 	  print ();
 	}
 
       return *this;
     }
 
-  Octave_object eval (int, int, const Octave_object&);
+  Octave_object eval (bool, int, const Octave_object&);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const string& s)
     { rep->stash_original_text (s); }
 
   // Pretty print this constant.
@@ -658,37 +661,37 @@ private:
 
   tree_constant_rep *make_unique_map (void);
 
   // We want to eliminate this, or at least make it private.
 
   tree_constant_rep::constant_type const_type (void) const
     { return rep->const_type (); }
 
-  void convert_to_matrix_type (int make_complex)
+  void convert_to_matrix_type (bool make_complex)
     { rep->convert_to_matrix_type (make_complex); }
 
   // Can we make these go away?
 
   // These need better names, since a range really is a numeric type.
 
-  void force_numeric (int frc_str_conv = 0)
+  void force_numeric (bool frc_str_conv = false)
     { rep->force_numeric (frc_str_conv); }
 
-  tree_constant make_numeric (int frc_str_conv = 0) const
+  tree_constant make_numeric (bool frc_str_conv = false) const
     {
       if (is_numeric_type ())
 	return *this;
       else
 	return rep->make_numeric (frc_str_conv);
     }
 
-  int print_as_scalar (void) { return rep->print_as_scalar (); }
+  bool print_as_scalar (void) { return rep->print_as_scalar (); }
 
-  int print_as_structure (void) { return rep->print_as_structure (); }
+  bool print_as_structure (void) { return rep->print_as_structure (); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -1,12 +1,12 @@
 // pt-exp-base.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -35,22 +35,22 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-exp-base.h"
 #include "user-prefs.h"
 
 // Expressions.
 
-int
+bool
 tree_expression::is_logically_true (const char *warn_for)
 {
-  int expr_value = 0;
+  bool expr_value = false;
 
-  tree_constant t1 = eval (0);
+  tree_constant t1 = eval (false);
 
   if (! error_state)
     {
       if (t1.is_defined ())
 	{
 	  if (t1.rows () == 0 || t1.columns () == 0)
 	    {
 	      t1 = 0.0;
@@ -70,17 +70,17 @@ tree_expression::is_logically_true (cons
 	      tree_constant t2 = t1.all ();
 	      if (! error_state)
 		t1 = t2.all ();
 	    }
 
 	  if (! error_state)
 	    {
 	      if (t1.is_real_scalar ())
-		expr_value = (int) t1.double_value ();
+		expr_value = t1.double_value () != 0.0;
 	      else if (t1.is_complex_scalar ())
 		expr_value = t1.complex_value () != 0.0;
 	      else
 		panic_impossible ();
 	    }
 	  else
 	    ::error ("%s: invalid type in conditional expression", warn_for);
 	}
@@ -96,17 +96,17 @@ tree_expression::is_logically_true (cons
 
 void
 tree_expression::mark_for_possible_ans_assign (void)
 {
   panic_impossible ();
 }
 
 tree_constant
-tree_expression::eval (int /* print */)
+tree_expression::eval (bool /* print */)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -1,12 +1,12 @@
 // pt-exp-base.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -77,48 +77,48 @@ public:
       decrement,
    };
 
   tree_expression (int l = -1, int c = -1, type et = unknown)
     : tree (l, c), in_parens (0), etype (et) { }
 
   virtual ~tree_expression (void) { }
 
-  virtual int is_constant (void) const
-    { return 0; }
+  virtual bool is_constant (void) const
+    { return false; }
 
-  virtual int is_matrix_constant (void) const
-    { return 0; }
+  virtual bool is_matrix_constant (void) const
+    { return false; }
 
-  virtual int is_range_constant (void) const
-    { return 0; }
+  virtual bool is_range_constant (void) const
+    { return false; }
 
-  virtual int is_multi_val_ret_expression (void) const
-    { return 0; }
+  virtual bool is_multi_val_ret_expression (void) const
+    { return false; }
 
-  virtual int is_identifier (void) const
-    { return 0; }
+  virtual bool is_identifier (void) const
+    { return false; }
 
-  virtual int is_indirect_ref (void) const
-    { return 0; }
+  virtual bool is_indirect_ref (void) const
+    { return false; }
 
-  virtual int is_index_expression (void) const
-    { return 0; }
+  virtual bool is_index_expression (void) const
+    { return false; }
 
-  virtual int is_assignment_expression (void) const
-    { return 0; }
+  virtual bool is_assignment_expression (void) const
+    { return false; }
 
-  virtual int is_prefix_expression (void) const
-    { return 0; }
+  virtual bool is_prefix_expression (void) const
+    { return false; }
 
-  virtual int is_logically_true (const char *);
+  virtual bool is_logically_true (const char *);
 
   virtual void mark_for_possible_ans_assign (void);
 
-  virtual tree_constant eval (int print) = 0;
+  virtual tree_constant eval (bool print) = 0;
 
 protected:
   type etype;
 };
 
 #endif
 
 /*
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -1,12 +1,12 @@
 // pt-exp.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -56,17 +56,17 @@ extern int breaking;
 // Prefix expressions.
 
 tree_prefix_expression::~tree_prefix_expression (void)
 {
   delete id;
 }
 
 tree_constant
-tree_prefix_expression::eval (int print)
+tree_prefix_expression::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (id)
     {
@@ -140,17 +140,17 @@ tree_prefix_expression::print_code (ostr
 // Postfix expressions.
 
 tree_postfix_expression::~tree_postfix_expression (void)
 {
   delete id;
 }
 
 tree_constant
-tree_postfix_expression::eval (int print)
+tree_postfix_expression::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (id)
     {
@@ -214,32 +214,32 @@ tree_postfix_expression::print_code (ost
 
   if (in_parens)
     os << ")";
 }
 
 // Unary expressions.
 
 tree_constant
-tree_unary_expression::eval (int /* print */)
+tree_unary_expression::eval (bool /* print */)
 {
   if (error_state)
     return tree_constant ();
 
   tree_constant retval;
 
   switch (etype)
     {
     case tree_expression::not:
     case tree_expression::uminus:
     case tree_expression::hermitian:
     case tree_expression::transpose:
       if (op)
 	{
-	  tree_constant u = op->eval (0);
+	  tree_constant u = op->eval (false);
 	  if (error_state)
 	    eval_error ();
 	  else if (u.is_defined ())
 	    {
 	      retval = do_unary_op (u, etype);
 	      if (error_state)
 		{
 		  retval = tree_constant ();
@@ -332,17 +332,17 @@ tree_unary_expression::print_code (ostre
 
   if (in_parens)
     os << ")";
 }
 
 // Binary expressions.
  
 tree_constant
-tree_binary_expression::eval (int /* print */)
+tree_binary_expression::eval (bool /* print */)
 {
   if (error_state)
     return tree_constant ();
 
   tree_constant retval;
 
   switch (etype)
     {
@@ -361,22 +361,22 @@ tree_binary_expression::eval (int /* pri
     case tree_expression::cmp_eq:
     case tree_expression::cmp_ge:
     case tree_expression::cmp_gt:
     case tree_expression::cmp_ne:
     case tree_expression::and:
     case tree_expression::or:
       if (op1)
 	{
-	  tree_constant a = op1->eval (0);
+	  tree_constant a = op1->eval (false);
 	  if (error_state)
 	    eval_error ();
 	  else if (a.is_defined () && op2)
 	    {
-	      tree_constant b = op2->eval (0);
+	      tree_constant b = op2->eval (false);
 	      if (error_state)
 		eval_error ();
 	      else if (b.is_defined ())
 		{
 		  retval = do_binary_op (a, b, etype);
 		  if (error_state)
 		    {
 		      retval = tree_constant ();
@@ -386,53 +386,53 @@ tree_binary_expression::eval (int /* pri
 		}
 	    }
 	}
       break;
 
     case tree_expression::and_and:
     case tree_expression::or_or:
       {
-	int result = 0;
+	bool result = false;
 	if (op1)
 	  {
-	    tree_constant a = op1->eval (0);
+	    tree_constant a = op1->eval (false);
 	    if (error_state)
 	      {
 		eval_error ();
 		break;
 	      }
 
-	    int a_true = a.is_true ();
+	    bool a_true = a.is_true ();
 	    if (error_state)
 	      {
 		eval_error ();
 		break;
 	      }
 
 	    if (a_true)
 	      {
 		if (etype == tree_expression::or_or)
 		  {
-		    result = 1;
+		    result = true;
 		    goto done;
 		  }
 	      }
 	    else
 	      {
 		if (etype == tree_expression::and_and)
 		  {
-		    result = 0;
+		    result = false;
 		    goto done;
 		  }
 	      }
 
 	    if (op2)
 	      {
-		tree_constant b = op2->eval (0);
+		tree_constant b = op2->eval (false);
 		if (error_state)
 		  {
 		    eval_error ();
 		    break;
 		  }
 
 		result = b.is_true ();
 		if (error_state)
@@ -578,28 +578,28 @@ tree_binary_expression::print_code (ostr
 
   if (in_parens)
     os << ")";
 }
 
 // Simple assignment expressions.
 
 tree_simple_assignment_expression::tree_simple_assignment_expression
-  (tree_identifier *i, tree_expression *r, int plhs, int ans_assign,
+  (tree_identifier *i, tree_expression *r, bool plhs, bool ans_assign,
    int l, int c)
     : tree_expression (l, c)
       {
 	init (plhs, ans_assign);
 	lhs = new tree_indirect_ref (i);
 	rhs = r;
       }
 
 tree_simple_assignment_expression::tree_simple_assignment_expression
-  (tree_index_expression *idx_expr, tree_expression *r, int plhs,
-   int ans_assign, int l, int c)
+  (tree_index_expression *idx_expr, tree_expression *r, bool plhs,
+   bool ans_assign, int l, int c)
     : tree_expression (l, c)
       {
 	init (plhs, ans_assign);
 	lhs_idx_expr = idx_expr; // cache this -- we may need to delete it.
 	lhs = idx_expr->ident ();
 	index = idx_expr->arg_list ();
 	rhs = r;
       }
@@ -612,41 +612,41 @@ tree_simple_assignment_expression::~tree
 	delete lhs_idx_expr;
       else
 	delete lhs;
     }
 
   delete rhs;
 }
 
-int
+bool
 tree_simple_assignment_expression::left_hand_side_is_identifier_only (void)
 {
   return lhs->is_identifier_only ();
 }
 
 tree_identifier *
 tree_simple_assignment_expression::left_hand_side_id (void)
 {
   return lhs->ident ();
 }
 
 tree_constant
-tree_simple_assignment_expression::eval (int print)
+tree_simple_assignment_expression::eval (bool print)
 {
   assert (etype == tree_expression::assignment);
 
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (rhs)
     {
-      tree_constant rhs_val = rhs->eval (0);
+      tree_constant rhs_val = rhs->eval (false);
       if (error_state)
 	{
 	  eval_error ();
 	}
       else if (rhs_val.is_undefined ())
 	{
 	  error ("value on right hand side of assignment is undefined");
 	  eval_error ();
@@ -689,16 +689,17 @@ tree_simple_assignment_expression::eval 
 
 void
 tree_simple_assignment_expression::eval_error (void)
 {
   if (error_state > 0)
     {
       int l = line ();
       int c = column ();
+
       if (l != -1 && c != -1)
 	::error ("evaluating assignment expression near line %d, column %d",
 		 l, c);
     }
 }
 
 void
 tree_simple_assignment_expression::print_code (ostream& os)
@@ -727,21 +728,21 @@ tree_simple_assignment_expression::print
     rhs->print_code (os);
 
   if (in_parens)
     os << ")";
 }
 
 // Colon expressions.
 
-int
+bool
 tree_colon_expression::is_range_constant (void) const
 {
-  int tmp = (op1 && op1->is_constant ()
-	     && op2 && op2->is_constant ());
+  bool tmp = (op1 && op1->is_constant ()
+	      && op2 && op2->is_constant ());
 
   return op3 ? (tmp && op3->is_constant ()) : tmp;
 }
 
 tree_colon_expression *
 tree_colon_expression::chain (tree_expression *t)
 {
   tree_colon_expression *retval = 0;
@@ -753,41 +754,41 @@ tree_colon_expression::chain (tree_expre
       op2 = t;
 
       retval = this;
     }
   return retval;
 }
 
 tree_constant
-tree_colon_expression::eval (int /* print */)
+tree_colon_expression::eval (bool /* print */)
 {
   tree_constant retval;
 
   if (error_state || ! op1 || ! op2)
     return retval;
 
-  tree_constant tmp = op1->eval (0);
+  tree_constant tmp = op1->eval (false);
 
   if (tmp.is_undefined ())
     {
       eval_error ("invalid null value in colon expression");
       return retval;
     }
 
   double base = tmp.double_value ();
 
   if (error_state)
     {
       error ("colon expression elements must be scalars");
       eval_error ("evaluating colon expression");
       return retval;
     }
 
-  tmp = op2->eval (0);
+  tmp = op2->eval (false);
 
   if (tmp.is_undefined ())
     {
       eval_error ("invalid null value in colon expression");
       return retval;
     }
 
   double limit = tmp.double_value ();
@@ -797,17 +798,17 @@ tree_colon_expression::eval (int /* prin
       error ("colon expression elements must be scalars");
       eval_error ("evaluating colon expression");
       return retval;
     }
 
   double inc = 1.0;
   if (op3)
     {
-      tmp = op3->eval (0);
+      tmp = op3->eval (false);
 
       if (tmp.is_undefined ())
 	{
 	  eval_error ("invalid null value in colon expression");
 	  return retval;
 	}
 
       inc = tmp.double_value ();
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -1,12 +1,12 @@
-// tree-exp.h                                      -*- C++ -*-
+// pt-exp.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -47,22 +47,22 @@ tree_prefix_expression : public tree_exp
     : tree_expression (l, c), id (0) { }
 
   tree_prefix_expression (tree_identifier *t, tree_expression::type et,
 			  int l = -1, int c = -1)
     : tree_expression (l, c, et), id (t) { }
 
   ~tree_prefix_expression (void);
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
   void eval_error (void);
 
-  int is_prefix_expression (void) const
-    { return 1; }
+  bool is_prefix_expression (void) const
+    { return true; }
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
   tree_identifier *id;
 };
@@ -77,17 +77,17 @@ tree_postfix_expression : public tree_ex
     : tree_expression (l, c), id (0) { }
 
   tree_postfix_expression (tree_identifier *t, tree_expression::type et,
 			   int l = -1, int c = -1)
     : tree_expression (l, c, et), id (t) { }
 
   ~tree_postfix_expression (void);
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -105,17 +105,17 @@ tree_unary_expression : public tree_expr
 
   tree_unary_expression (tree_expression *a, tree_expression::type t,
 			 int l = -1, int c = -1)
     : tree_expression (l, c, t), op (a) { }
 
   ~tree_unary_expression (void)
     { delete op; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -136,17 +136,17 @@ tree_binary_expression : public tree_exp
     : tree_expression (l, c, t), op1 (a), op2 (b) { }
 
   ~tree_binary_expression (void)
     {
       delete op1;
       delete op2;
     }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
   void eval_error (void);
 
   char *oper (void) const;
 
   void print_code (ostream& os);
 
  private:
@@ -155,79 +155,83 @@ tree_binary_expression : public tree_exp
 };
 
 // Simple assignment expressions.
 
 class
 tree_simple_assignment_expression : public tree_expression
 {
 private:
-  void init (int plhs, int ans_assign)
+  void init (bool plhs, bool ans_assign)
     {
       etype = tree_expression::assignment;
       lhs_idx_expr = 0;
       lhs = 0;
       index = 0;
       rhs = 0;
       preserve = plhs;
       ans_ass = ans_assign;
     }
 
  public:
-  tree_simple_assignment_expression (int plhs = 0, int ans_assign = 0,
+  tree_simple_assignment_expression (bool plhs = false,
+				     bool ans_assign = false,
 				     int l = -1, int c = -1)
     : tree_expression (l, c)
       { init (plhs, ans_assign); }
 
   tree_simple_assignment_expression (tree_identifier *i,
 				     tree_expression *r,
-				     int plhs = 0, int ans_assign = 0,
+				     bool plhs = false,
+				     bool ans_assign = false,
 				     int l = -1, int c = -1);
 
   tree_simple_assignment_expression (tree_indirect_ref *i,
 				     tree_expression *r,
-				     int plhs = 0, int ans_assign = 0,
+				     bool plhs = false,
+				     bool ans_assign = false,
 				     int l = -1, int c = -1)
     : tree_expression (l, c)
       {
 	init (plhs, ans_assign);
 	lhs = i;
 	rhs = r;
       }
 
   tree_simple_assignment_expression (tree_index_expression *idx_expr,
 				     tree_expression *r,
-				     int plhs = 0, int ans_assign = 0,
+				     bool plhs = false,
+				     bool ans_assign = false,
 				     int l = -1, int c = -1);
 
   ~tree_simple_assignment_expression (void);
 
-  int left_hand_side_is_identifier_only (void);
+  bool left_hand_side_is_identifier_only (void);
 
   tree_identifier *left_hand_side_id (void);
 
-  int is_ans_assign (void)
+  bool is_ans_assign (void)
     { return ans_ass; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  int is_assignment_expression (void) const
-    { return 1; }
+  bool is_assignment_expression (void) const
+    { return true; }
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
  private:
   tree_index_expression *lhs_idx_expr;
   tree_indirect_ref *lhs;
   tree_argument_list *index;
   tree_expression *rhs;
-  int preserve;
-  int ans_ass;
+  bool preserve;
+  bool ans_ass;
 };
 
 // Colon expressions.
 
 class
 tree_colon_expression : public tree_expression
 {
  public:
@@ -242,21 +246,21 @@ tree_colon_expression : public tree_expr
 
   ~tree_colon_expression (void)
     {
       delete op1;
       delete op2;
       delete op3;
     }
 
-  int is_range_constant (void) const;
+  bool is_range_constant (void) const;
 
   tree_colon_expression *chain (tree_expression *t);
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
   void eval_error (const char *s);
 
   void print_code (ostream& os);
 
  private:
   tree_expression *op1;
   tree_expression *op2;
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -1,12 +1,12 @@
 // pt-fcn.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -147,17 +147,17 @@ tree_function::mark_as_system_fcn_file (
 
       if (system_dir.compare (ff_name, 0, system_dir.length ()) == 0)
 	system_fcn_file = 1;
     }
   else
     system_fcn_file = 0;
 }
 
-int
+bool
 tree_function::takes_varargs (void) const
 {
   return (param_list && param_list->takes_varargs ());
 }
 
 tree_constant
 tree_function::octave_va_arg (void)
 {
@@ -181,17 +181,17 @@ tree_function::octave_all_va_args (void)
 
   int k = 0;
   for (int i = num_named_args; i < num_args_passed; i++)
     retval(k++) = args_passed(i);
 
   return retval;
 }
 
-int
+bool
 tree_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
 }
 
 void
 tree_function::octave_vr_val (const tree_constant& val)
 {
@@ -202,17 +202,17 @@ tree_function::octave_vr_val (const tree
 
 void
 tree_function::stash_function_name (const string& s)
 {
   fcn_name = s;
 }
 
 tree_constant
-tree_function::eval (int print)
+tree_function::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state || ! cmd_list)
     return retval;
 
   Octave_object tmp_args;
   Octave_object tmp = eval (print, 0, tmp_args);
@@ -243,17 +243,17 @@ delete_vr_list (void *list)
 static void
 clear_symbol_table (void *table)
 {
   symbol_table *tmp = (symbol_table *) table;
   tmp->clear ();
 }
 
 Octave_object
-tree_function::eval (int /* print */, int nargout, const Octave_object& args)
+tree_function::eval (bool /* print */, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
@@ -320,25 +320,25 @@ tree_function::eval (int /* print */, in
 
   // The following code is in a separate scope to avoid warnings from
   // G++ about `goto abort' crossing the initialization of some
   // variables.
 
   {
     bind_nargin_and_nargout (nargin, nargout);
 
-    int echo_commands
+    bool echo_commands
       = (user_pref.echo_executing_commands & ECHO_FUNCTIONS);
 
     if (echo_commands)
       print_code_function_header ();
 
     // Evaluate the commands that make up the function.
 
-    int pf = ! user_pref.silent_functions;
+    bool pf = ! user_pref.silent_functions;
     tree_constant last_computed_value = cmd_list->eval (pf);
 
     if (echo_commands)
       print_code_function_trailer ();
 
     if (returning)
       returning = 0;
 
diff --git a/src/pt-fcn.h b/src/pt-fcn.h
--- a/src/pt-fcn.h
+++ b/src/pt-fcn.h
@@ -1,12 +1,12 @@
 // pt-fcn.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -95,55 +95,55 @@ public:
   string fcn_file_name (void)
     { return file_name; }
 
   time_t time_parsed (void)
     { return t_parsed; }
 
   void mark_as_system_fcn_file (void);
 
-  int is_system_fcn_file (void) const
+  bool is_system_fcn_file (void) const
     { return system_fcn_file; }
 
-  int takes_varargs (void) const;
+  bool takes_varargs (void) const;
 
   void octave_va_start (void)
     { curr_va_arg_number = num_named_args; }
 
   tree_constant octave_va_arg (void);
 
   Octave_object octave_all_va_args (void);
 
-  int takes_var_return (void) const;
+  bool takes_var_return (void) const;
 
   void octave_vr_val (const tree_constant& val);
 
   void stash_function_name (const string& s);
 
   string function_name (void)
     { return fcn_name; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   void traceback_error (void);
 
   void print_code (ostream& os);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
   symbol_table *sym_tab;
   tree_statement_list *cmd_list;
   string file_name;
   string fcn_name;
   time_t t_parsed;
-  int system_fcn_file;
+  bool system_fcn_file;
   int num_named_args;
   Octave_object args_passed;
   int num_args_passed;
   int curr_va_arg_number;
   tree_va_return_list *vr_list;
   symbol_record *nargin_sr;
   symbol_record *nargout_sr;
 
diff --git a/src/pt-fvc-base.cc b/src/pt-fvc-base.cc
--- a/src/pt-fvc-base.cc
+++ b/src/pt-fvc-base.cc
@@ -1,12 +1,12 @@
 // pt-fvc-base.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -57,17 +57,17 @@ tree_fvc::name (void) const
 
 void
 tree_fvc::bump_value (tree_expression::type)
 {
   panic_impossible ();
 }
 
 tree_constant
-tree_fvc::lookup_map_element (SLList<string>&, int, int)
+tree_fvc::lookup_map_element (SLList<string>&, bool, bool)
 {
   static tree_constant retval;
 
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("invalid structure reference");
@@ -80,17 +80,17 @@ tree_fvc::lookup_map_element (SLList<str
 time_t
 tree_fvc::time_parsed (void)
 {
   panic_impossible ();
   return 0;
 }
 
 int
-tree_fvc::save (ostream&, int, int)
+tree_fvc::save (ostream&, bool, int)
 {
   panic_impossible ();
   return 0;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-fvc-base.h b/src/pt-fvc-base.h
--- a/src/pt-fvc-base.h
+++ b/src/pt-fvc-base.h
@@ -1,12 +1,12 @@
 // pt-fvc-base.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -54,27 +54,28 @@ public:
   virtual tree_constant assign (tree_constant& t,
 				const Octave_object& args);
 
   virtual string name (void) const;
 
   virtual void bump_value (tree_expression::type);
 
   virtual tree_constant lookup_map_element (SLList<string>& list,
-					    int insert = 0, int silent = 0);
+					    bool insert = false,
+					    bool silent = false);
 
   virtual string fcn_file_name (void)
     { return string (); }
 
   virtual time_t time_parsed (void);
 
-  virtual int is_system_fcn_file (void) const
-    { return 0; }
+  virtual bool is_system_fcn_file (void) const
+    { return false; }
 
-  virtual int save (ostream& /* os */, int /* mark_as_global */ = 0,
+  virtual int save (ostream& /* os */, bool /* mark_as_global */ = false,
 		    int /* precision */ = 17);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -1,12 +1,12 @@
 // pt-fvc.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -42,54 +42,58 @@ Software Foundation, 59 Temple Place - S
 #include "symtab.h"
 #include "pt-const.h"
 #include "pt-fvc.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // But first, some extra functions used by the tree classes.
 
-static int
+static bool
 any_element_less_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
+
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (a.elem (i, j) < val)
-	return 1;
-  return 0;
+	return true;
+
+  return false;
 }
 
-static int
+static bool
 any_element_greater_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
+
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (a.elem (i, j) > val)
-	return 1;
-  return 0;
+	return true;
+
+  return false;
 }
 
 // Make sure that all arguments have values.
 
 // Are any of the arguments `:'?
 
-static int
+static bool
 any_arg_is_magic_colon (const Octave_object& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (args(i).is_magic_colon ())
-	return 1;
+	return true;
 
-  return 0;
+  return false;
 }
 
 // Symbols from the symbol table.
 
 string
 tree_identifier::name (void) const
 {
   string retval;
@@ -271,17 +275,17 @@ tree_identifier::assign (SLList<string> 
 		sym->define (tmp);
 	    }
 	}
     }
 
   return retval;
 }
 
-int
+bool
 tree_identifier::is_defined (void)
 {
   return (sym && sym->is_defined ());
 }
 
 void
 tree_identifier::bump_value (tree_expression::type etype)
 {
@@ -301,16 +305,17 @@ tree_identifier::bump_value (tree_expres
     }
 }
 
 void
 tree_identifier::eval_undefined_error (void)
 {
   int l = line ();
   int c = column ();
+
   if (l == -1 && c == -1)
     ::error ("`%s' undefined", name ().c_str ());
   else
     ::error ("`%s' undefined near line %d column %d",
 	     name ().c_str (), l, c);
 }
 
 // Try to find a definition for an identifier.  Here's how:
@@ -324,17 +329,17 @@ tree_identifier::eval_undefined_error (v
 //
 //   * If the identifier is still undefined, try looking for an
 //     function file to parse.
 //
 //   * On systems that support dynamic linking, we prefer .oct files
 //     over .m files.
 
 tree_fvc *
-tree_identifier::do_lookup (int& script_file_executed, int exec_script)
+tree_identifier::do_lookup (bool& script_file_executed, bool exec_script)
 {
   script_file_executed = lookup (sym, exec_script);
 
   tree_fvc *retval = 0;
 
   if (! script_file_executed)
     retval = sym->def ();
 
@@ -351,24 +356,24 @@ tree_identifier::link_to_global (void)
 void
 tree_identifier::mark_as_formal_parameter (void)
 {
   if (sym)
     sym->mark_as_formal_parameter ();
 }
 
 tree_constant
-tree_identifier::eval (int print)
+tree_identifier::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  int script_file_executed = 0;
+  bool script_file_executed = false;
 
   tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
       if (object_to_eval)
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
@@ -377,17 +382,17 @@ tree_identifier::eval (int print)
 	    {
 	      Octave_object tmp_args;
 	      Octave_object tmp = object_to_eval->eval (0, nargout, tmp_args);
 
 	      if (tmp.length () > 0)
 		retval = tmp(0);
 	    }
 	  else
-	    retval = object_to_eval->eval (0);
+	    retval = object_to_eval->eval (false);
 	}
       else
 	eval_undefined_error ();
     }
 
   if (! error_state && retval.is_defined ())
     {
       if (maybe_do_ans_assign && ! object_to_eval->is_constant ())
@@ -395,24 +400,24 @@ tree_identifier::eval (int print)
       else if (print)
 	retval.print_with_name (name ());
     }
 
   return retval;
 }
 
 Octave_object
-tree_identifier::eval (int print, int nargout, const Octave_object& args)
+tree_identifier::eval (bool print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
-  int script_file_executed = 0;
+  bool script_file_executed = false;
 
   tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
       if (object_to_eval)
 	{
 	  if (maybe_do_ans_assign && nargout == 1)
@@ -509,30 +514,30 @@ tree_indirect_ref::assign (tree_constant
     retval = id->assign (t, args);
   else
     retval = id->assign (refs, t, args);
 
   return retval;
 }
 
 tree_constant
-tree_indirect_ref::eval (int print)
+tree_indirect_ref::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (refs.empty ())
     {
       retval = id->eval (print);
     }
   else
     {
-      int script_file_executed;
+      bool script_file_executed;
 
       tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
 
       if (object_to_eval)
 	{
 	  retval = object_to_eval->lookup_map_element (refs);
 
 	  if (! error_state && print)
@@ -541,30 +546,30 @@ tree_indirect_ref::eval (int print)
       else
 	id->eval_undefined_error ();
     }
 
   return retval;
 }
 
 Octave_object
-tree_indirect_ref::eval (int print, int nargout, const Octave_object& args)
+tree_indirect_ref::eval (bool print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (refs.empty ())
     {
       retval = id->eval (print, nargout, args);
     }
   else
     {
-      int script_file_executed;
+      bool script_file_executed;
 
       tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
 
       if (object_to_eval)
 	{
 	  tree_constant tmp = object_to_eval->lookup_map_element (refs);
 
 	  if (! error_state)
@@ -624,17 +629,17 @@ tree_builtin::tree_builtin (Mapper_fcn& 
 tree_builtin::tree_builtin (Octave_builtin_fcn g_fcn, const string& nm)
 {
   is_mapper = 0;
   fcn = g_fcn;
   my_name = nm;
 }
 
 tree_constant
-tree_builtin::eval (int /* print */)
+tree_builtin::eval (bool /* print */)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (fcn)
     {
@@ -659,17 +664,17 @@ tree_builtin::eval (int /* print */)
 	::error ("unable to load builtin function %s", my_name.c_str ());
     }
 
   return retval;
 }
 
 static tree_constant
 apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn,
-		  int /* print */)
+		  bool /* print */)
 {
   tree_constant retval;
 
   if (arg.is_real_type ())
     {
       if (arg.is_scalar_type ())
 	{
 	  double d = arg.double_value ();
@@ -745,17 +750,17 @@ apply_mapper_fcn (const tree_constant& a
     }
   else
     gripe_wrong_type_arg ("mapper", arg);
 
   return retval;
 }
 
 Octave_object
-tree_builtin::eval (int /* print */, int nargout, const Octave_object& args)
+tree_builtin::eval (bool /* print */, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   int nargin = args.length ();
 
diff --git a/src/pt-fvc.h b/src/pt-fvc.h
--- a/src/pt-fvc.h
+++ b/src/pt-fvc.h
@@ -1,12 +1,12 @@
-// tree-fvc.h                                      -*- C++ -*-
+// pt-fvc.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -43,112 +43,112 @@ class tree_function;
 
 class
 tree_identifier : public tree_fvc
 {
   friend class tree_index_expression;
 
 public:
   tree_identifier (int l = -1, int c = -1)
-    : tree_fvc (l, c), sym (0), maybe_do_ans_assign (0) { }
+    : tree_fvc (l, c), sym (0), maybe_do_ans_assign (false) { }
 
   tree_identifier (symbol_record *s, int l = -1, int c = -1)
-    : tree_fvc (l, c), sym (s), maybe_do_ans_assign (0) { }
+    : tree_fvc (l, c), sym (s), maybe_do_ans_assign (false) { }
 
   ~tree_identifier (void) { }
 
-  int is_identifier (void) const
-    { return 1; }
+  bool is_identifier (void) const
+    { return true; }
 
   string name (void) const;
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (const string& s);
 
   tree_constant assign (tree_constant& t);
   tree_constant assign (tree_constant& t, const Octave_object& args);
 
   tree_constant assign (SLList<string> list, tree_constant& t);
   tree_constant assign (SLList<string> list, tree_constant& t,
 			const Octave_object& args); 
 
-  int is_defined (void);
+  bool is_defined (void);
 
   void bump_value (tree_expression::type);
 
-  tree_fvc *do_lookup (int& script_file_executed, int exec_script = 1);
+  tree_fvc *do_lookup (bool& script_file_executed, bool exec_script = true);
 
   void link_to_global (void);
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void)
-    { maybe_do_ans_assign = 1; }
+    { maybe_do_ans_assign = true; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   void eval_undefined_error (void);
 
   void print_code (ostream& os);
 
 private:
   symbol_record *sym;
-  int maybe_do_ans_assign;
+  bool maybe_do_ans_assign;
 };
 
 // Indirect references to values (structure references).
 
 class
 tree_indirect_ref : public tree_fvc
 {
 public:
   tree_indirect_ref (int l = -1, int c = -1)
-    : tree_fvc (l, c), id (0), preserve_ident (0) { }
+    : tree_fvc (l, c), id (0), preserve_ident (false) { }
 
   tree_indirect_ref (tree_identifier *i, int l = -1, int c = -1)
-    : tree_fvc (l, c), id (i), preserve_ident (0) { }
+    : tree_fvc (l, c), id (i), preserve_ident (false) { }
 
   ~tree_indirect_ref (void);
 
   tree_indirect_ref *chain (const string& s);
 
-  int is_indirect_ref (void) const
-    { return 1; }
+  bool is_indirect_ref (void) const
+    { return true; }
 
-  int is_identifier_only (void) const
+  bool is_identifier_only (void) const
     { return (id && refs.empty ()); }
 
   tree_identifier *ident (void)
     { return id; }
 
   void preserve_identifier (void)
-    { preserve_ident = 1; }
+    { preserve_ident = true; }
 
   string name (void) const;
 
   tree_constant assign (tree_constant& t);
   tree_constant assign (tree_constant& t, const Octave_object& args);
 
   void mark_for_possible_ans_assign (void)
     { id->mark_for_possible_ans_assign (); }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   void print_code (ostream& os);
 
 private:
   tree_identifier *id;
   SLList<string> refs;
-  int preserve_ident;
+  bool preserve_ident;
 };
 
 // Builtin functions.
 
 class
 tree_builtin : public tree_fvc
 {
 public:
@@ -157,30 +157,30 @@ public:
   tree_builtin (Mapper_fcn& m_fcn, const string& nm = string ());
 
   tree_builtin (Octave_builtin_fcn f, const string& nm = string ());
 
   ~tree_builtin (void) { }  // XXX ?? XXX
 
 //  int is_builtin (void) const;
 
-  int is_mapper_function (void) const
+  bool is_mapper_function (void) const
     { return is_mapper; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   string name (void) const
     { return my_name; }
 
   void print_code (ostream& os);
 
 private:
-  int is_mapper;
+  bool is_mapper;
   Mapper_fcn mapper_fcn;
   Octave_builtin_fcn fcn;
   string my_name;
 };
 
 #endif
 
 /*
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1,12 +1,12 @@
 // pt-mat.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -41,471 +41,528 @@ Software Foundation, 59 Temple Place - S
 #include "pt-misc.h"
 #include "pt-mvr.h"
 #include "user-prefs.h"
 
 // General matrices.  This list type is much more work to handle than
 // constant matrices, but it allows us to construct matrices from
 // other matrices, variables, and functions.
 
-tree_matrix::~tree_matrix (void)
-{
-  delete element;
-  delete next;
-}
+// But first, some internal classes that make our job much easier.
 
-int
-tree_matrix::is_matrix_constant (void) const
+class
+tm_row_const
 {
-  const tree_matrix *list = this;
+private:
+
+  class
+  tm_row_const_rep : public SLList<tree_constant>
+  {
+  public:
+
+    tm_row_const_rep (void)
+      : SLList<tree_constant> (), count (1), nr (0), nc (0),
+	all_str (false), is_cmplx (false), ok (false) { }
+
+    tm_row_const_rep (const tree_matrix_row& mr)
+      : SLList<tree_constant> (), count (1), nr (0), nc (0),
+	all_str (false), is_cmplx (false), ok (false)
+        { init (mr); }
+
+    ~tm_row_const_rep (void) { }
+
+    int count;
+
+    int nr;
+    int nc;
 
-  while (list)
+    bool all_str;
+    bool is_cmplx;
+
+    bool ok;
+
+    void init (const tree_matrix_row&);
+
+  private:
+
+    tm_row_const_rep (const tm_row_const_rep&);
+
+    tm_row_const_rep& operator =
+      (const tm_row_const_rep&);
+  };
+
+public:
+
+  tm_row_const (void) : rep (0) { }
+
+  tm_row_const (const tree_matrix_row& mr)
+    : rep (new tm_row_const_rep (mr)) { }
+
+  tm_row_const (const tm_row_const& x) : rep (x.rep)
     {
-      tree_expression *elem = list->element;
+      if (rep)
+	rep->count++;
+    }
+
+  tm_row_const& operator = (const tm_row_const& x)
+    {
+      if (this != &x && rep != x.rep)
+	{
+	  if (rep && --rep->count == 0)
+	    delete rep;
 
-      if (! elem->is_constant ())
-	return 0;
+	  rep = x.rep;
+
+	  if (rep)
+	    rep->count++;
+	}
 
-      list = list->next;
+      return *this;
+    }
+
+  ~tm_row_const (void)
+    {
+      if (rep && --rep->count == 0)
+	delete rep;
     }
 
-  return 1;
+  int rows (void) { return rep->nr; }
+  int cols (void) { return rep->nc; }
+
+  bool all_strings (void) const { return rep->all_str; }
+  bool is_complex (void) const { return rep->is_cmplx; }
+
+  tree_constant& operator () (Pix p) { return rep->operator () (p); }
+
+  const tree_constant& operator () (Pix p) const
+    { return rep->operator () (p); }
+
+  Pix first (void) const { return rep->first (); }
+  void next (Pix& p) const { rep->next (p); }
+  
+  operator void* () const
+    {
+      return (rep && rep->ok) ? (void *) -1 : (void *) 0;
+    }
+
+private:
+
+  tm_row_const_rep *rep;
+};
+
+void
+tm_row_const::tm_row_const_rep::init (const tree_matrix_row& mr)
+{
+  all_str = true;
+
+  int empties_ok = user_pref.empty_list_elements_ok;
+
+  bool first_elem = true;
+
+  for (Pix p = mr.first (); p != 0; mr.next (p))
+    {
+      tree_expression *elt = mr (p);
+
+      tree_constant tmp = elt->eval (false);
+
+      if (error_state || tmp.is_undefined ())
+	break;
+      else
+	{
+	  int this_elt_nr = tmp.rows ();
+	  int this_elt_nc = tmp.columns ();
+
+	  if (this_elt_nr == 0 || this_elt_nc == 0)
+	    {
+	      if (empties_ok < 0)
+		warning ("empty matrix found in matrix list");
+	      else if (empties_ok == 0)
+		{
+		  ::error ("empty matrix found in matrix list");
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (first_elem)
+		{
+		  first_elem = false;
+
+		  nr = this_elt_nr;
+		}
+	      else if (this_elt_nr != nr)
+		{
+		  ::error ("number of rows must match");
+		  break;
+		}
+
+	      nc += this_elt_nc;
+
+	      append (tmp);
+	    }
+
+	  if (all_str && ! tmp.is_string ())
+	    all_str = false;
+
+	  if (! is_cmplx && tmp.is_complex_type ())
+	    is_cmplx = true;
+	}
+    }
+
+  ok = ! error_state;
 }
 
-tree_matrix *
-tree_matrix::chain (tree_expression *t, tree_matrix::dir d)
+template class SLNode<tm_row_const>;
+template class SLList<tm_row_const>;
+
+class
+tm_const : public SLList<tm_row_const>
+{
+public:
+
+  tm_const (const tree_matrix& tm)
+    : SLList<tm_row_const> (), nr (0), nc (0), all_str (false),
+      is_cmplx (false), ok (false)
+      { init (tm); }
+
+  ~tm_const (void) { }
+
+  int rows (void) const { return nr; }
+  int cols (void) const { return nc; }
+
+  bool all_strings (void) const { return all_str; }
+  bool is_complex (void) const { return is_cmplx; }
+
+  operator void* () const { return ok ? (void *) -1 : (void *) 0; }
+
+private:
+
+  int nr;
+  int nc;
+
+  bool all_str;
+  bool is_cmplx;
+
+  bool ok;
+
+  tm_const (void);
+
+  tm_const (const tm_const&);
+
+  tm_const& operator = (const tm_const&);
+
+  void init (const tree_matrix& tm);
+};
+
+void
+tm_const::init (const tree_matrix& tm)
 {
-  tree_matrix *tmp = new tree_matrix (t, d);
-  tmp->next = this;
-  return tmp;
+  all_str = true;
+
+  int empties_ok = user_pref.empty_list_elements_ok;
+
+  bool first_elem = true;
+
+  // Just eval and figure out if what we have is complex or all
+  // strings.  We can't check columns until we know that this is a
+  // numeric matrix -- collections of strings can have elements of
+  // different lengths.
+
+  for (Pix p = tm.first (); p != 0; tm.next (p))
+    {
+      tree_matrix_row *elt = tm (p);
+
+      tm_row_const tmp (*elt);
+
+      if (tmp)
+	{
+	  if (all_str && ! tmp.all_strings ())
+	    all_str = false;
+
+	  if (! is_cmplx && tmp.is_complex ())
+	    is_cmplx = true;
+
+	  append (tmp);
+	}
+      else
+	break;
+    }
+
+  if (! error_state)
+    {
+      for (Pix p = first (); p != 0; next (p))
+	{
+	  tm_row_const elt = this->operator () (p);
+
+	  int this_elt_nr = elt.rows ();
+	  int this_elt_nc = elt.cols ();
+
+	  if (this_elt_nr == 0 || this_elt_nc == 0)
+	    {
+	      if (empties_ok < 0)
+		warning ("empty matrix found in matrix list");
+	      else if (empties_ok == 0)
+		{
+		  ::error ("empty matrix found in matrix list");
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (first_elem)
+		{
+		  first_elem = false;
+
+		  nc = this_elt_nc;
+		}
+	      else if (all_str)
+		{
+		  if (this_elt_nc > nc)
+		    nc = this_elt_nc;
+		}
+	      else if (this_elt_nc != nc)
+		{
+		  ::error ("number of columns must match");
+		  break;
+		}
+
+	      nr += this_elt_nr;
+	    }
+	}
+    }
+
+  ok = ! error_state;
 }
 
-tree_matrix *
-tree_matrix::reverse (void)
+bool
+tree_matrix_row::is_matrix_constant (void) const
 {
-  tree_matrix *list = this;
-  tree_matrix *next;
-  tree_matrix *prev = 0;
+  for (Pix p = first (); p != 0; next (p))
+    {
+      tree_expression *elt = this->operator () (p);
 
-  while (list)
-    {
-      next = list->next;
-      list->next = prev;
-      prev = list;
-      list = next;
+      if (! elt->is_constant ())
+	return false;
     }
-  return prev;
-}
 
-int
-tree_matrix::length (void)
-{
-  tree_matrix *list = this;
-  int len = 0;
-  while (list)
-    {
-      len++;
-      list = list->next;
-    }
-  return len;
+  return true;
 }
 
 tree_return_list *
-tree_matrix::to_return_list (void)
+tree_matrix_row::to_return_list (void)
 {
   tree_return_list *retval = 0;
 
-  tree_matrix *list;
+  bool first_elem = true;
 
-  for (list = this; list; list = list->next)
+  for (Pix p = first (); p != 0; next (p))
     {
-      tree_expression *elem = list->element;
+      tree_expression *elt = this->operator () (p);
 
-      int is_id = elem->is_identifier ();
+      bool is_id = elt->is_identifier ();
 
-      int is_idx_expr = elem->is_index_expression ();
+      bool is_idx_expr = elt->is_index_expression ();
 
       if (is_id || is_idx_expr)
 	{
 	  tree_index_expression *idx_expr;
+
 	  if (is_id)
 	    {
-	      tree_identifier *id = (tree_identifier *) elem;
+	      tree_identifier *id = (tree_identifier *) elt;
 	      idx_expr = new tree_index_expression (id);
 	    }
 	  else
-	    idx_expr = (tree_index_expression *) elem;
+	    idx_expr = (tree_index_expression *) elt;
 
-	  if (list == this)
-	    retval = new tree_return_list (idx_expr);
+	  if (first_elem)
+	    {
+	      first_elem = false;
+
+	      retval = new tree_return_list (idx_expr);
+	    }
 	  else
 	    retval->append (idx_expr);
 	}
       else
 	{
 	  delete retval;
 	  retval = 0;
 	  break;
 	}
     }
 
   return retval;
 }
 
-// Just about as ugly as it gets.
-
-struct const_matrix_list
+void
+tree_matrix_row::print_code (ostream& os)
 {
-  tree_matrix::dir direction;
-  tree_constant elem;
-  int nr;
-  int nc;
-};
+  Pix p = first ();
+
+  while (p)
+    {
+      tree_expression *elt = this->operator () (p);
+
+      next (p);
+
+      if (elt)
+	{
+	  elt->print_code (os);
+
+	  if (p)
+	    os << ", ";
+	}
+    }
+}
 
+bool
+tree_matrix::is_matrix_constant (void) const
+{
+  for (Pix p = first (); p != 0; next (p))
+    {
+      tree_matrix_row *elt = this->operator () (p);
+
+      if (! elt->is_matrix_constant ())
+	return false;
+    }
+
+  return true;
+}
+
+// Just about as ugly as it gets.
 // Less ugly than before, anyway.
+// Looking better all the time.
 
 tree_constant
-tree_matrix::eval (int /* print */)
+tree_matrix::eval (bool /* print */)
 {
   tree_constant retval;
 
-  if (error_state)
-    return retval;
+  tm_const tmp (*this);
 
-  // Just count the elements without looking at them.
-
-  int total_len = length ();
+  if (tmp)
+    {
+      int nr = tmp.rows ();
+      int nc = tmp.cols ();
 
-  // Easier to deal with this later instead of a tree_matrix
-  // structure.
-
-  const_matrix_list *list = new const_matrix_list [total_len];
+      Matrix m;
+      ComplexMatrix cm;
+      charMatrix chm;
 
-  // Stats we want to keep track of.
+      // Now, extract the values from the individual elements and
+      // insert them in the result matrix.
 
-  int all_strings = 1;
-
-  int found_complex = 0;
+      bool all_strings = tmp.all_strings ();
+      bool found_complex = tmp.is_complex ();
 
-  int row_total = 0;
-  int col_total = 0;
+      if (all_strings)
+	chm.resize (nr, nc, 0);
+      else if (found_complex)
+	cm.resize (nr, nc, 0.0);
+      else
+	m.resize (nr, nc, 0.0);
 
-  int row_height = 0;
-
-  int cols_this_row = 0;
-
-  int first_row = 1;
+      int put_row = 0;
 
-  int empties_ok = user_pref.empty_list_elements_ok;
-
-  tree_matrix *ptr = this;
+      for (Pix p = tmp.first (); p != 0; tmp.next (p))
+	{
+	  int put_col = 0;
 
-  // Stuff for the result matrix or string.  Declared here so that we
-  // don't get warnings from gcc about the goto crossing the
-  // initialization of these values.
+	  tm_row_const row = tmp (p);
 
-  int put_row = 0;
-  int put_col = 0;
+	  for (Pix q = row.first (); q != 0; row.next (q))
+	    {
+	      tree_constant elt = row (q);
 
-  int prev_nr = 0;
-  int prev_nc = 0;
-
-  Matrix m;
-  ComplexMatrix cm;
-  charMatrix chm;
-
-  // Eliminate empties and gather stats.
+	      if (found_complex)
+		{
+		  if (elt.is_real_scalar ())
+		    cm (put_row, put_col) = elt.double_value ();
+		  else if (elt.is_real_matrix () || elt.is_range ())
+		    cm.insert (elt.matrix_value (), put_row, put_col);
+		  else if (elt.is_complex_scalar ())
+		    cm (put_row, put_col) = elt.complex_value ();
+		  else
+		    {
+		      ComplexMatrix cm_elt = elt.complex_matrix_value ();
 
-  int found_new_row_in_empties = 0;
-
-  int len = 0;
-  for (int i = 0; i < total_len; i++)
-    {
-      tree_expression *elem = ptr->element;
-      if (! elem)
-	{
-	  retval = tree_constant (Matrix ());
-	  goto done;
-	}
+		      if (error_state)
+			goto done;
 
-      tree_constant tmp = elem->eval (0);
-      if (error_state || tmp.is_undefined ())
-	{
-	  retval = tree_constant ();
-	  goto done;
-	}
+		      cm.insert (cm_elt, put_row, put_col);
+		    }
+		}
+	      else
+		{
+		  if (elt.is_real_scalar ())
+		    m (put_row, put_col) = elt.double_value ();
+		  else if (elt.is_string () && all_strings)
+		    {
+		      charMatrix chm_elt = elt.all_strings ();
 
-      int nr = tmp.rows ();
-      int nc = tmp.columns ();
+		      if (error_state)
+			goto done;
 
-      dir direct = ptr->direction;
+		      chm.insert (chm_elt, put_row, put_col);
+		    }
+		  else
+		    {
+		      Matrix m_elt = elt.matrix_value ();
+
+		      if (error_state)
+			goto done;
 
-      if (nr == 0 || nc == 0)
-	{
-	  if (empties_ok < 0)
-	    warning ("empty matrix found in matrix list");
-	  else if (empties_ok == 0)
-	    {
-	      ::error ("empty matrix found in matrix list");
-	      retval = tree_constant ();
-	      goto done;
+		      m.insert (m_elt, put_row, put_col);
+		    }
+		}
+
+	      if (all_strings && chm.rows () > 0 && chm.cols () > 0)
+		retval = tree_constant (chm, true);
+	      else if (found_complex)
+		retval = cm;
+	      else
+		retval = m;
+
+	      put_col += elt.columns ();
 	    }
 
-	  if (direct == md_down)
-	    found_new_row_in_empties = 1;
-
-	  goto next;
-	}
-
-      if (found_new_row_in_empties)
-	{
-	  found_new_row_in_empties = 0;
-	  list[len].direction = md_down;
-	}
-      else
-	list[len].direction = direct;
-
-      list[len].elem = tmp;
-      list[len].nr = nr;
-      list[len].nc = nc;
-
-      if (all_strings && ! tmp.is_string ())
-	all_strings = 0;
-
-      if (! found_complex && tmp.is_complex_type ())
-	found_complex = 1;
-
-      len++;
-
-    next:
-
-      ptr = ptr->next;
-    }
-
-  //  if (all_strings)
-  //    cerr << "all strings\n";
-
-  // Compute size of result matrix, and check to see that the dimensions
-  // of all the elements will match up properly.
-
-  for (int i = 0; i < len; i++)
-    {
-      dir direct = list[i].direction;
-
-      int nr = list[i].nr;
-      int nc = list[i].nc;
-
-      if (i == 0)
-	{
-	  row_total = nr;
-	  col_total = nc;
-
-	  row_height = nr;
-	  cols_this_row = nc;
-	}
-      else
-	{
-	  switch (direct)
-	    {
-	    case md_right:
-	      {
-		if (nr != row_height)
-		  {
-		    ::error ("number of rows must match");
-		    goto done;
-		  }
-		else
-		  {
-		    cols_this_row += nc;
-
-		    if (first_row)
-		      col_total = cols_this_row;
-		    else if (all_strings && cols_this_row > col_total)
-		      col_total = cols_this_row;
-		  }
-	      }
-	      break;
-
-	    case md_down:
-	      {
-		if (cols_this_row != col_total && ! all_strings)
-		  {
-		    ::error ("number of columns must match");
-		    goto done;
-		  }
-		first_row = 0;
-		row_total += nr;
-		row_height = nr;
-		cols_this_row = nc;
-	      }
-	      break;
-
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
+	  put_row += row.rows ();
 	}
     }
 
-  // Don't forget to check to see if the last element will fit.
-
-  if (all_strings && cols_this_row > col_total)
-    {
-      col_total = cols_this_row;
-    }
-  else if (cols_this_row != col_total)
-    {
-      ::error ("number of columns must match");
-      goto done;
-    }
-
-  // Now, extract the values from the individual elements and insert
-  // them in the result matrix.
-
-  if (all_strings)
-    chm.resize (row_total, col_total, 0);
-  else if (found_complex)
-    cm.resize (row_total, col_total, 0.0);
-  else
-    m.resize (row_total, col_total, 0.0);
-
-  for (int i = 0; i < len; i++)
-    {
-      tree_constant tmp = list[i].elem;
-
-      int nr = list[i].nr;
-      int nc = list[i].nc;
-
-      if (nr == 0 || nc == 0)
-	continue;
-
-      if (i == 0)
-	{
-	  put_row = 0;
-	  put_col = 0;
-	}
-      else
-	{
-	  switch (list[i].direction)
-	    {
-	    case md_right:
-	      put_col += prev_nc;
-	      break;
-
-	    case md_down:
-	      put_row += prev_nr;
-	      put_col = 0;
-	      break;
-
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
-	}
-
-      if (found_complex)
-	{
-	  if (tmp.is_real_scalar ())
-	    {
-	      cm (put_row, put_col) = tmp.double_value ();
-	    }
-	  else if (tmp.is_real_matrix () || tmp.is_range ())
-	    {
-	      cm.insert (tmp.matrix_value (), put_row, put_col);
-	    }
-	  else if (tmp.is_complex_scalar ())
-	    {
-	      cm (put_row, put_col) = tmp.complex_value ();
-	    }
-	  else
-	    {
-	      ComplexMatrix cm_tmp = tmp.complex_matrix_value ();
-
-	      if (error_state)
-		goto done;
-
-	      cm.insert (cm_tmp, put_row, put_col);
-	    }
-	}
-      else
-	{
-	  if (tmp.is_real_scalar ())
-	    {
-	      m (put_row, put_col) = tmp.double_value ();
-	    }
-	  else if (tmp.is_string () && all_strings)
-	    {
-	      charMatrix chm_tmp = tmp.all_strings ();
-
-	      if (error_state)
-		goto done;
-
-	      chm.insert (chm_tmp, put_row, put_col);
-	    }
-	  else
-	    {
-	      Matrix m_tmp = tmp.matrix_value ();
-
-	      if (error_state)
-		goto done;
-
-	      m.insert (m_tmp, put_row, put_col);
-	    }
-	}
-
-      prev_nr = nr;
-      prev_nc = nc;
-    }
-
-  if (all_strings && chm.rows () > 0 && chm.cols () > 0)
-    retval = tree_constant (chm, 1);
-  else if (found_complex)
-    retval = cm;
-  else
-    retval = m;
-
- done:
-  delete [] list;
+done:
 
   return retval;
 }
 
 void
 tree_matrix::print_code (ostream& os)
 {
   print_code_indent (os);
 
   if (in_parens)
     os << "(";
 
   os << "[";
 
-  tree_matrix *list = this;
+  Pix p = first ();
 
-  while (list)
+  while (p)
     {
-      list->element->print_code (os);
+      tree_matrix_row *elt = this->operator () (p);
 
-      list = list->next;
+      next (p);
 
-      if (list)
+      if (elt)
 	{
-	  switch (list->direction)
-	    {
-	    case md_right:
-	      os << ", ";
-	      break;
+	  elt->print_code (os);
 
-	    case md_down:
-	      os << "; ";
-	      break;
-
-	    default:
-	      break;
-	    }
+	  if (p)
+	    os << "; ";
 	}
     }
 
   os << "]";
 
   if (in_parens)
     os << ")";
 }
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -1,12 +1,12 @@
 // pt-mat.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -28,57 +28,62 @@ Software Foundation, 59 Temple Place - S
 #pragma interface
 #endif
 
 class ostream;
 
 class tree_constant;
 class tree_return_list;
 
+#include <SLList.h>
+
 #include "pt-exp.h"
 
 // General matrices.  This allows us to construct matrices from
 // other matrices, variables, and functions.
 
 class
-tree_matrix : public tree_expression
+tree_matrix_row : public SLList<tree_expression *>
 {
 public:
-  enum dir
-    {
-      md_none,
-      md_right,
-      md_down,
-    };
-
-  tree_matrix (void)
-    : tree_expression (), direction (tree_matrix::md_none),
-      element (0), next (0) { }
 
-  tree_matrix (tree_expression *e, tree_matrix::dir d)
-    : tree_expression (), direction (d), element (e), next (0) { }
-
-  ~tree_matrix (void);
+  tree_matrix_row (tree_expression *e = 0) : SLList<tree_expression *> ()
+    {
+      if (e)
+	append (e);
+    }
 
-  int is_matrix_constant (void) const;
+  ~tree_matrix_row (void) { }
 
-  tree_matrix *chain (tree_expression *e, tree_matrix::dir d);
-  tree_matrix *reverse (void);
-  int length (void);
+  bool is_matrix_constant (void) const;
 
   tree_return_list *to_return_list (void);
 
-  tree_constant eval (int print);
+  void print_code (ostream& os);
+};
+
+class
+tree_matrix : public tree_expression, public SLList<tree_matrix_row *>
+{
+public:
+
+  tree_matrix (tree_matrix_row *mr = 0)
+    : tree_expression (), SLList<tree_matrix_row *> ()
+      {
+	if (mr)
+	  append (mr);
+      }
+
+  ~tree_matrix (void) { }
+
+  bool is_matrix_constant (void) const;
+
+  tree_constant eval (bool print);
 
   void print_code (ostream& os);
-
-private:
-  tree_matrix::dir direction; // Direction from the previous element.
-  tree_expression *element;
-  tree_matrix *next;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -1,12 +1,12 @@
 // pt-misc.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -77,17 +77,17 @@ tree_statement::line (void)
 int
 tree_statement::column (void)
 {
   return command
     ? command->column () : (expression ? expression->column () : -1);
 }
 
 void
-tree_statement::maybe_echo_code (int in_function_body)
+tree_statement::maybe_echo_code (bool in_function_body)
 {
   if (in_function_body
       && (user_pref.echo_executing_commands & ECHO_FUNCTIONS))
     {
       ostrstream output_buf;
       print_code (output_buf);
       output_buf << ends;
       maybe_page_output (output_buf);
@@ -113,30 +113,30 @@ tree_statement::print_code (ostream& os)
       if (! print_flag)
 	os << ";";
 
       expression->print_code_new_line (os);
     }
 }
 
 tree_constant
-tree_statement_list::eval (int print)
+tree_statement_list::eval (bool print)
 {
-  int pf;
+  bool pf;
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_statement *elt = this->operator () (p);
 
-      if (print == 0)
-	pf = 0;
+      if (! print)
+	pf = false;
       else
 	pf = elt->print_flag;
 
       tree_command *cmd = elt->command;
       tree_expression *expr = elt->expression;
 
       if (cmd || expr)
 	{
@@ -158,33 +158,33 @@ tree_statement_list::eval (int print)
 	}
       else
 	retval = tree_constant ();
     }
   return retval;
 }
 
 Octave_object
-tree_statement_list::eval (int print, int nargout)
+tree_statement_list::eval (bool print, int nargout)
 {
   Octave_object retval;
 
   if (nargout > 1)
     {
-      int pf;
+      bool pf;
 
       if (error_state)
 	return retval;
 
       for (Pix p = first (); p != 0; next (p))
 	{
 	  tree_statement *elt = this->operator () (p);
 
-	  if (print == 0)
-	    pf = 0;
+	  if (! print)
+	    pf = false;
 	  else
 	    pf = elt->print_flag;
 
 	  tree_command *cmd = elt->command;
 	  tree_expression *expr = elt->expression;
 
 	  if (cmd || expr)
 	    {
@@ -250,17 +250,17 @@ tree_argument_list::convert_to_const_vec
 
   Pix p = first ();
   int j = 0;
   for (int k = 0; k < len; k++)
     {
       tree_expression *elt = this->operator () (p);
       if (elt)
 	{
-	  tree_constant tmp = elt->eval (0);
+	  tree_constant tmp = elt->eval (false);
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k);
 	      args = Octave_object ();
 	      break;
 	    }
 	  else
 	    {
@@ -398,45 +398,45 @@ tree_parameter_list::convert_to_const_ve
 
   int i = 0;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
 
       if (elt->is_defined ())
-	retval(i) = elt->eval (0);
+	retval(i) = elt->eval (false);
 
       i++;
     }
 
   if (vr_list)
     {
       for (Pix p = vr_list->first (); p != 0; vr_list->next (p))
 	{
 	  retval(i) = vr_list->operator () (p);
 	  i++;
 	}
     }
 
   return retval;
 }
 
-int
+bool
 tree_parameter_list::is_defined (void)
 {
-  int status = 1;
+  bool status = true;
 
   for (Pix p = first (); p != 0; next (p))
     {
       tree_identifier *elt = this->operator () (p);
 
       if (! elt->is_defined ())
 	{
-	  status = 0;
+	  status = false;
 	  break;
 	}
     }
 
   return status;
 }
 
 void
@@ -509,17 +509,17 @@ tree_global::eval (void)
     }
   else if (assign_expr)
     {
       tree_identifier *id = 0;
       if (assign_expr->left_hand_side_is_identifier_only ()
 	  && (id = assign_expr->left_hand_side_id ()))
 	{
 	  id->link_to_global ();
-	  assign_expr->eval (0);
+	  assign_expr->eval (false);
 	}
       else
 	error ("global: unable to make individual structure elements global");
     }
 }
 
 void
 tree_global::print_code (ostream& os)
@@ -573,17 +573,17 @@ tree_if_clause::~tree_if_clause (void)
 }
 
 int
 tree_if_clause::eval (void)
 {
   if (is_else_clause () || expr->is_logically_true ("if"))
     {
       if (list)
-	list->eval (1);
+	list->eval (true);
 
       return 1;
     }
 
   return 0;
 }
 
 void
@@ -618,17 +618,17 @@ tree_if_command_list::eval (void)
     }
 }
 
 void
 tree_if_command_list::print_code (ostream& os)
 {
   Pix p = first ();
 
-  int first_elt = 1;
+  bool first_elt = true;
 
   while (p)
     {
       tree_if_clause *elt = this->operator () (p);
 
       if (elt)
 	{
 	  if (! first_elt)
@@ -639,17 +639,17 @@ tree_if_command_list::print_code (ostrea
 		os << "else";
 	      else
 		os << "elseif ";
 	    }
 
 	  elt->print_code (os);
 	}
 
-      first_elt = 0;
+      first_elt = false;
       next (p);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -1,12 +1,12 @@
 // pt-misc.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -57,79 +57,79 @@ class tree_global_init_list;
 
 class
 tree_statement : public tree_print_code
 {
 friend class tree_statement_list;
 
 public:
   tree_statement (void)
-    : tree_print_code (), command (0), expression (0), print_flag (1) { }
+    : tree_print_code (), command (0), expression (0), print_flag (true) { }
 
   tree_statement (tree_command *c)
-    : tree_print_code (), command (c), expression (0), print_flag (1) { }
+    : tree_print_code (), command (c), expression (0), print_flag (true) { }
 
   tree_statement (tree_expression *e)
-    : tree_print_code (), command (0), expression (e), print_flag (1) { }
+    : tree_print_code (), command (0), expression (e), print_flag (true) { }
 
   ~tree_statement (void);
 
-  void set_print_flag (int print)
+  void set_print_flag (bool print)
     { print_flag = print; }
 
-  int is_command (void)
+  bool is_command (void)
     { return command != 0; }
 
-  int is_expression (void)
+  bool is_expression (void)
     { return expression != 0; }
 
   int line (void);
   int column (void);
 
-  void maybe_echo_code (int);
+  void maybe_echo_code (bool);
 
   void print_code (ostream& os);
 
 private:
   tree_command *command;	// Command to execute.
   tree_expression *expression;	// Command to execute.
-  int print_flag;		// Print result of eval for this command?
+  bool print_flag;		// Print result of eval for this command?
 };
 
 class
 tree_statement_list : public SLList<tree_statement *>, public tree_print_code
 {
 public:
   tree_statement_list (void)
-    : SLList<tree_statement *> (), tree_print_code ()
-      { function_body = 0; }
+    : SLList<tree_statement *> (), tree_print_code (), function_body (false)
+      { }
 
   tree_statement_list (tree_statement *s)
-    : SLList<tree_statement *> (), tree_print_code (), function_body (0)
+    : SLList<tree_statement *> (), tree_print_code (), function_body (false)
       { append (s); }
 
   ~tree_statement_list (void)
     {
       while (! empty ())
 	{
 	  tree_statement *t = remove_front ();
 	  delete t;
 	}
     }
 
-  void mark_as_function_body (void) { function_body = 1; }
+  void mark_as_function_body (void) { function_body = true; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout);
+  Octave_object eval (bool print, int nargout);
 
   void print_code (ostream& os);
 
 private:
-  int function_body;
+  bool function_body;
 };
 
 // Argument lists.  Used to hold the list of expressions that are the
 // arguments in a function call or index expression.
 
 class
 tree_argument_list : public SLList<tree_expression *>, public tree_print_code
 {
@@ -176,30 +176,30 @@ public:
 
 //  char *name (void) const;
 
   void mark_as_formal_parameters (void);
 
   void mark_varargs (void)
     { marked_for_varargs = 1; }
 
-  int takes_varargs (void) const
-    { return marked_for_varargs; }
+  bool takes_varargs (void) const
+    { return marked_for_varargs != 0; }
 
   void mark_varargs_only (void)
     { marked_for_varargs = -1; }
 
-  int varargs_only (void)
+  bool varargs_only (void)
     { return (marked_for_varargs < 0); }
 
   void initialize_undefined_elements (tree_constant& val);
 
   void define_from_arg_vector (const Octave_object& args);
 
-  int is_defined (void);
+  bool is_defined (void);
 
   Octave_object convert_to_const_vector (tree_va_return_list *vr_list);
 
   void print_code (ostream& os);
 
 private:
   int marked_for_varargs;
 };
@@ -292,20 +292,18 @@ public:
   tree_if_clause (tree_statement_list *l)
     : tree_print_code (), expr (0), list (l) { }
 
   tree_if_clause (tree_expression *e, tree_statement_list *l)
     : tree_print_code (), expr (e), list (l) { }
 
   ~tree_if_clause (void);
 
-  int is_else_clause (void)
-    {
-      return ! expr;
-    }
+  bool is_else_clause (void)
+    { return ! expr; }
 
   int eval (void);
 
   void print_code (ostream& os);
 
 private:
   tree_expression *expr;
   tree_statement_list *list;
diff --git a/src/pt-mvr-base.cc b/src/pt-mvr-base.cc
--- a/src/pt-mvr-base.cc
+++ b/src/pt-mvr-base.cc
@@ -1,12 +1,12 @@
 // pt-mvr-base.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "pt-const.h"
 #include "pt-mvr-base.h"
 
 // A base class for objects that can be return multiple values
 
 tree_constant
-tree_multi_val_ret::eval (int /* print */)
+tree_multi_val_ret::eval (bool /* print */)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-mvr-base.h b/src/pt-mvr-base.h
--- a/src/pt-mvr-base.h
+++ b/src/pt-mvr-base.h
@@ -1,12 +1,12 @@
 // pt-mvr-base.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -41,22 +41,22 @@ tree_multi_val_ret : public tree_express
 public:
   tree_multi_val_ret (int l = -1, int c = -1) : tree_expression (l, c) { }
 
   tree_multi_val_ret (int l = -1, int c = -1, tree_expression::type et)
     : tree_expression (l, c, et) { }
 
   ~tree_multi_val_ret (void) { }
 
-  int is_multi_val_ret_expression (void) const
-    { return 1; }
+  bool is_multi_val_ret_expression (void) const
+    { return true; }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  virtual Octave_object eval (int print, int nargout,
+  virtual Octave_object eval (bool print, int nargout,
 			      const Octave_object& args) = 0;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-mvr.cc b/src/pt-mvr.cc
--- a/src/pt-mvr.cc
+++ b/src/pt-mvr.cc
@@ -1,12 +1,12 @@
 // pt-mvr.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -41,38 +41,38 @@ Software Foundation, 59 Temple Place - S
 #include "pt-misc.h"
 #include "pt-mvr.h"
 #include "user-prefs.h"
 
 // But first, some extra functions used by the tree classes.
 
 // Make sure that all arguments have values.
 
-static int
+static bool
 all_args_defined (const Octave_object& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (args(i).is_undefined ())
-      return 0;
+      return false;
 
-  return 1;
+  return true;
 }
 
 // Used internally.
 
 tree_constant
-tree_oct_obj::eval (int /* print */)
+tree_oct_obj::eval (bool /* print */)
 {
   return values(0);
 }
 
 Octave_object
-tree_oct_obj::eval (int /* print */, int /* nargout */,
+tree_oct_obj::eval (bool /* print */, int /* nargout */,
 		    const Octave_object& /* args */)
 {
   return values;
 }
 
 // Index expressions.
 
 tree_index_expression::tree_index_expression
@@ -106,17 +106,17 @@ tree_index_expression::name (void)
 void
 tree_index_expression::mark_for_possible_ans_assign (void)
 {
   if (id)
     id->mark_for_possible_ans_assign ();
 }
 
 tree_constant
-tree_index_expression::eval (int print)
+tree_index_expression::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
@@ -157,17 +157,17 @@ tree_index_expression::eval (int print)
       if (error_state)
 	eval_error ();
     }
 
   return retval;
 }
 
 Octave_object
-tree_index_expression::eval (int print, int nargout,
+tree_index_expression::eval (bool print, int nargout,
 			     const Octave_object& /* args */)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list)
@@ -268,34 +268,34 @@ tree_multi_assignment_expression::~tree_
 {
   if (! preserve)
     delete lhs;
 
   delete rhs;
 }
 
 tree_constant
-tree_multi_assignment_expression::eval (int print)
+tree_multi_assignment_expression::eval (bool print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   Octave_object tmp_args;
   Octave_object result = eval (print, 1, tmp_args);
 
   if (result.length () > 0)
     retval = result(0);
 
   return retval;
 }
 
 Octave_object
-tree_multi_assignment_expression::eval (int print, int nargout,
+tree_multi_assignment_expression::eval (bool print, int nargout,
 					const Octave_object& /* args */)
 {
   assert (etype == tree_expression::multi_assignment);
 
   if (error_state || ! rhs)
     return Octave_object ();
 
   nargout = lhs->length ();
@@ -306,18 +306,19 @@ tree_multi_assignment_expression::eval (
     eval_error ();
 
   int ma_line = line ();
   int ma_column = column ();
 
   if (results.length () > 0)
     {
       int i = 0;
-      int pad_after = 0;
-      int last_was_scalar_type = 0;
+
+      bool pad_after = false;
+
       for (Pix p = lhs->first (); p != 0; lhs->next (p))
 	{
 	  tree_index_expression *lhs_expr = lhs->operator () (p);
 
 	  if (i < nargout)
 	    {
 	      // XXX FIXME? XXX -- this is apparently the way Matlab
 	      // works, but maybe we should have the option of
@@ -331,48 +332,41 @@ tree_multi_assignment_expression::eval (
 		  break;
 		}
 	      else
 		tmp = new tree_constant (results(i));
 
 	      tree_simple_assignment_expression tmp_expr
 		(lhs_expr, tmp, 1, 0, ma_line, ma_column);
 
-	      results(i) = tmp_expr.eval (0); // May change
+	      results(i) = tmp_expr.eval (false); // May change
 
 	      if (error_state)
 		break;
 
 	      if (print && pad_after)
 		{
 		  ostrstream output_buf;
 		  output_buf << "\n" << ends;
 		  maybe_page_output (output_buf);
 		}
 
 	      if (print)
 		results(i).print_with_name (lhs_expr->name (), 0);
 
-	      pad_after++;
+	      pad_after = true;
+
 	      i++;
 	    }
 	  else
 	    {
 	      tree_simple_assignment_expression tmp_expr
 		(lhs_expr, 0, 1, 0, ma_line, ma_column);
 
-	      tmp_expr.eval (0);
-
-	      if (error_state)
-		break;
-
-	      if (last_was_scalar_type && i == 1)
-		pad_after = 0;
-
-	      break;
+	      tmp_expr.eval (false);
 	    }
 	}
 
       if (print && pad_after)
 	{
 	  ostrstream output_buf;
 	  output_buf << "\n" << ends;
 	  maybe_page_output (output_buf);
diff --git a/src/pt-mvr.h b/src/pt-mvr.h
--- a/src/pt-mvr.h
+++ b/src/pt-mvr.h
@@ -1,12 +1,12 @@
-// tree-mvr.h                                      -*- C++ -*-
+// pt-mvr.h                                      -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -52,19 +52,19 @@ tree_oct_obj : public tree_multi_val_ret
 public:
   tree_oct_obj (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
 
   tree_oct_obj (const Octave_object& v, int l = -1, int c = -1)
     : tree_multi_val_ret (l, c), values (v) { }
 
   ~tree_oct_obj (void) { }
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   void print_code (ostream&) { }
 
 private:
   Octave_object values;
 };
 
 // Index expressions.
@@ -85,74 +85,74 @@ public:
     : tree_multi_val_ret (l, c), id (i), list (0) { }
 
   tree_index_expression (tree_indirect_ref *i, tree_argument_list *lst,
 			 int l = -1, int c = -1)
     : tree_multi_val_ret (l, c), id (i), list (lst) { }
 
   ~tree_index_expression (void);
 
-  int is_index_expression (void) const
-    { return 1; }
+  bool is_index_expression (void) const
+    { return true; }
 
   tree_indirect_ref *ident (void)
     { return id; }
 
   string name (void);
 
   tree_argument_list *arg_list (void)
     { return list; }
 
   void mark_for_possible_ans_assign (void);
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
  private:
   tree_indirect_ref *id;
   tree_argument_list *list;
 };
 
 // Multi-valued assignment expressions.
 
 class
 tree_multi_assignment_expression : public tree_multi_val_ret
 {
  public:
-  tree_multi_assignment_expression (int plhs = 0, int l = -1, int c = -1)
+  tree_multi_assignment_expression (bool plhs = false, int l = -1, int c = -1)
     : tree_multi_val_ret (l, c, tree_expression::multi_assignment),
       preserve (plhs), lhs (0), rhs (0) { }
 
   tree_multi_assignment_expression (tree_return_list *lst,
 				    tree_multi_val_ret *r,
-				    int plhs = 0,
+				    bool plhs = false,
 				    int l = -1, int c = -1)
     : tree_multi_val_ret (l, c, tree_expression::multi_assignment),
       preserve (plhs), lhs (lst), rhs (r) { }
 
   ~tree_multi_assignment_expression (void);
 
-  tree_constant eval (int print);
+  tree_constant eval (bool print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args);
+  Octave_object eval (bool print, int nargout, const Octave_object& args);
 
-  int is_assignment_expression (void) const
-    { return 1; }
+  bool is_assignment_expression (void) const
+    { return true; }
 
   void eval_error (void);
 
   void print_code (ostream& os);
 
  private:
-  int preserve;
+  bool preserve;
   tree_return_list *lhs;
   tree_multi_val_ret *rhs;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1,12 +1,12 @@
 // pt-plot.cc                                         -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -61,23 +61,23 @@ Software Foundation, 59 Temple Place - S
 #include "sysdep.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // The number of lines we've plotted so far.
 static int plot_line_count = 0;
 
 // Is this a parametric plot?  Makes a difference for 3D plotting.
-static int parametric_plot = 0;
+static bool parametric_plot = false;
 
 // The gnuplot terminal type.
 static char *gnuplot_terminal_type = 0;
 
 // Should the graph window be cleared before plotting the next line?
-static int clear_before_plotting = 1;
+static bool clear_before_plotting = true;
 
 // List of files to delete when we exit or crash.
 static SLStack <string> tmp_files;
 
 // Pipe to gnuplot.
 static oprocstream *plot_stream = 0;
 
 // Use shortest possible abbreviations to minimize trouble caused by
@@ -105,27 +105,27 @@ static oprocstream *plot_stream = 0;
 
 #ifndef GNUPLOT_COMMAND_TITLE
 #define GNUPLOT_COMMAND_TITLE  "t"
 #endif
 
 static void
 open_plot_stream (void)
 {
-  static int initialized = 0;
+  static bool initialized = false;
 
   if (plot_stream && ! *plot_stream)
     {
       delete plot_stream;
       plot_stream = 0;
     }
 
   if (! plot_stream)
     {
-      initialized = 0;
+      initialized = false;
 
       plot_line_count = 0;
 
       string plot_prog = user_pref.gnuplot_binary;
 
       if (! plot_prog.empty ())
 	{
 	  plot_stream = new oprocstream (plot_prog.c_str ());
@@ -164,17 +164,17 @@ open_plot_stream (void)
 	  if (! plot_stream)
 	    error ("plot: unable to open pipe to `%s'",
 		   plot_prog.c_str ());
 	}
     }
 
   if (! error_state && plot_stream && *plot_stream && ! initialized)
     {
-      initialized = 1;
+      initialized = true;
       *plot_stream << "set data style lines\n";
 
       if (gnuplot_terminal_type)
 	*plot_stream << "set term " << gnuplot_terminal_type << "\n";
     }
 }
 
 static int
@@ -191,19 +191,19 @@ send_to_plot_stream (const char *cmd)
       if (error_state)
 	return -1;
     }
 
   int replot_len = strlen (GNUPLOT_COMMAND_REPLOT);
   int splot_len = strlen (GNUPLOT_COMMAND_SPLOT);
   int plot_len = strlen (GNUPLOT_COMMAND_PLOT);
 
-  int is_replot = (strncmp (cmd, GNUPLOT_COMMAND_REPLOT, replot_len) == 0);
-  int is_splot = (strncmp (cmd, GNUPLOT_COMMAND_SPLOT, splot_len) == 0);
-  int is_plot = (strncmp (cmd, GNUPLOT_COMMAND_PLOT, plot_len) == 0);
+  bool is_replot = (strncmp (cmd, GNUPLOT_COMMAND_REPLOT, replot_len) == 0);
+  bool is_splot = (strncmp (cmd, GNUPLOT_COMMAND_SPLOT, splot_len) == 0);
+  bool is_plot = (strncmp (cmd, GNUPLOT_COMMAND_PLOT, plot_len) == 0);
 
   if (plot_line_count == 0 && is_replot)
     error ("replot: no previous plot");
   else
     {
       *plot_stream << cmd;
 
       if (! (is_replot || is_splot || is_plot)
@@ -400,34 +400,34 @@ plot_range::~plot_range (void)
 
 void
 plot_range::print (ostrstream& plot_buf)
 {
   plot_buf << " [";
 
   if (lower)
     {
-      tree_constant lower_val = lower->eval (0);
+      tree_constant lower_val = lower->eval (false);
       if (error_state)
 	{
 	  ::error ("evaluating lower bound of plot range");
 	  return;
 	}
       else
 	{
 	  double lo = lower_val.double_value ();
 	  plot_buf << lo;
 	}
     }
 
   plot_buf << ":";
 
   if (upper)
     {
-      tree_constant upper_val = upper->eval (0);
+      tree_constant upper_val = upper->eval (false);
       if (error_state)
 	{
 	  ::error ("evaluating upper bound of plot range");
 	  return;
 	}
       else
 	{
 	  double hi = upper_val.double_value ();
@@ -468,17 +468,17 @@ subplot_using::eval (int ndim, int n_max
 
   if (qualifier_count > 0)
     val.resize (qualifier_count);
 
   for (int i = 0; i < qualifier_count; i++)
     {
       if (x[i])
 	{
-	  tree_constant tmp = x[i]->eval (0);
+	  tree_constant tmp = x[i]->eval (false);
 	  if (error_state)
 	    {
 	      ::error ("evaluating plot using command");
 	      return -1;
 	    }
 
 	  double val_tmp;
 	  if (tmp.is_defined ())
@@ -595,17 +595,17 @@ int
 subplot_style::print (ostrstream& plot_buf)
 {
   if (! style.empty ())
     {
       plot_buf << " " << GNUPLOT_COMMAND_WITH << " " << style;
 
       if (linetype)
 	{
-	  tree_constant tmp = linetype->eval (0);
+	  tree_constant tmp = linetype->eval (false);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.double_value ();
 	      if (xisnan (val))
 		{
 		  ::error ("NaN is invalid a plotting line style");
 		  return -1;
 		}
@@ -616,17 +616,17 @@ subplot_style::print (ostrstream& plot_b
 	    {
 	      ::error ("evaluating plot style command");
 	      return -1;
 	    }
 	}
 
       if (pointtype)
 	{
-	  tree_constant tmp = pointtype->eval (0);
+	  tree_constant tmp = pointtype->eval (false);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.double_value ();
 	      if (xisnan (val))
 		{
 		  ::error ("NaN is invalid a plotting point style");
 		  return -1;
 		}
@@ -718,17 +718,17 @@ subplot::extract_plot_data (int ndim, tr
   return retval;
 }
 
 int
 subplot::handle_plot_data (int ndim, ostrstream& plot_buf)
 {
   if (plot_data)
     {
-      tree_constant data = plot_data->eval (0);
+      tree_constant data = plot_data->eval (false);
 
       if (! error_state && data.is_defined ())
 	{
 	  string file;
 
 	  if (data.is_string ())
 	    {
 	      // Should really try to look at data file to determine
@@ -810,17 +810,17 @@ subplot::print (int ndim, ostrstream& pl
 {
   int status = handle_plot_data (ndim, plot_buf);
 
   if (status < 0)
     return -1;
 
   if (title_clause)
     {
-      tree_constant tmp = title_clause->eval (0);
+      tree_constant tmp = title_clause->eval (false);
       if (! error_state && tmp.is_string ())
 	plot_buf << " " << GNUPLOT_COMMAND_TITLE << " "
 	  << '"' << tmp.string_value () << '"';
       else
 	{
 	  warning ("line title must be a string");
 	  plot_buf << " " << GNUPLOT_COMMAND_TITLE << " "
 	    << '"' << "line " << plot_line_count << '"';
@@ -908,17 +908,17 @@ subplot_list::print_code (ostream& os)
 
 	  if (p)
 	    os << ",";
 	}
     }
 }
 
 string
-save_in_tmp_file (tree_constant& t, int ndim, int parametric)
+save_in_tmp_file (tree_constant& t, int ndim, bool parametric)
 {
   string name = oct_tempnam ();
 
   if (! name.empty ())
     {
       ofstream file (name.c_str ());
 
       if (file)
@@ -1041,19 +1041,19 @@ drawn.  With no argument, toggle the cur
   switch (argc)
     {
     case 1:
       clear_before_plotting = ! clear_before_plotting;
       break;
 
     case 2:
       if (argv[1] == "on")
-	clear_before_plotting = 0;
+	clear_before_plotting = false;
       else if (argv[1] == "off")
-	clear_before_plotting = 1;
+	clear_before_plotting = true;
       else
 	print_usage ("hold");
       break;
 
     default:
       print_usage ("hold");
       break;
     }
@@ -1091,19 +1091,19 @@ set plotting options")
   if (error_state)
     return retval;
 
   ostrstream plot_buf;
 
   if (argc > 1)
     {
       if (almost_match ("parametric", argv[1], 3))
-	parametric_plot = 1;
+	parametric_plot = true;
       else if (almost_match ("noparametric", argv[1], 5))
-	parametric_plot = 0;
+	parametric_plot = false;
       else if (almost_match ("term", argv[1], 1))
 	{
 	  delete [] gnuplot_terminal_type;
 	  ostrstream buf;
 	  for (int i = 2; i < argc; i++)
 	    buf << argv[i] << " ";
 	  buf << "\n" << ends;
 	  gnuplot_terminal_type = buf.str ();
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -1,12 +1,12 @@
 // pt-plot.h                                         -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993, 1994, 1995 John W. Eaton
+Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -74,17 +74,17 @@ plot_limits : public tree_print_code
 {
 public:
   plot_limits (plot_range *xlim = 0, plot_range *ylim = 0,
 	       plot_range *zlim = 0)
     : tree_print_code (), x_range (xlim), y_range (ylim), z_range (zlim) { }
 
   ~plot_limits (void);
 
-  void print (int print, ostrstream& plot_buf);
+  void print (int ndim, ostrstream& plot_buf);
 
   void print_code (ostream& os);
 
 private:
   plot_range *x_range;
   plot_range *y_range;
   plot_range *z_range;
 };
@@ -230,17 +230,17 @@ public:
   ~subplot_list (void);
 
   int print (int ndim, ostrstream& plot_buf);
 
   void print_code (ostream& os);
 };
 
 extern string save_in_tmp_file (tree_constant& t, int ndim = 2,
-				int parametric = 0);
+				bool parametric = false);
 
 extern void mark_for_deletion (const string&);
 
 extern void cleanup_tmp_files (void);
 
 extern void close_plot_stream (void);
 
 extern void do_external_plotter_cd (const string& newdir);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -94,35 +94,35 @@ initialize_symbol_tables (void)
 
   curr_sym_tab = top_level_sym_tab;
 }
 
 // Attributes of variables and functions.
 
 // Is this variable a builtin?
 
-int
+bool
 is_builtin_variable (const string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_builtin_variable ());
 }
 
 // Is this a text-style function?
 
-int
+bool
 is_text_function_name (const string& s)
 {
   symbol_record *sr = global_sym_tab->lookup (s);
   return (sr && sr->is_text_function ());
 }
 
 // Is this function globally in this scope?
 
-int
+bool
 is_globally_visible (const string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_linked_to_global ());
 }
 
 // Is this tree_constant a valid function?
 
@@ -757,20 +757,20 @@ parse_fcn_file (int exec_script, const s
       fclose (ffile);
     }
 
   run_unwind_frame ("parse_fcn_file");
 
   return script_file_executed;
 }
 
-static int
+static bool
 load_fcn_from_file (symbol_record *sym_rec, int exec_script)
 {
-  int script_file_executed = 0;
+  bool script_file_executed = false;
 
   string nm = sym_rec->name ();
 
   if (load_octave_oct_file (nm))
     {
       force_link_to_function (nm);
     }
   else
@@ -794,20 +794,20 @@ load_fcn_from_file (symbol_record *sym_r
 	force_link_to_function (nm);
 
       run_unwind_frame ("load_fcn_from_file");
     }
 
   return script_file_executed;
 }
 
-int
+bool
 lookup (symbol_record *sym_rec, int exec_script)
 {
-  int script_executed = 0;
+  bool script_executed = false;
 
   if (! sym_rec->is_linked_to_global ())
     {
       if (sym_rec->is_defined ())
 	{
 	  if (sym_rec->is_function () && symbol_out_of_date (sym_rec))
 	    script_executed = load_fcn_from_file (sym_rec, exec_script);
 	}
@@ -1470,17 +1470,17 @@ bind_ans (const tree_constant& val, int 
 
   tree_identifier *ans_id = new tree_identifier (sr);
   tree_constant *tmp = new tree_constant (val);
 
   // XXX FIXME XXX -- making ans_id static, passing its address to
   // tree_simple_assignment_expression along with a flag to not delete
   // it seems to create a memory leak.  Hmm.
 
-  tree_simple_assignment_expression tmp_ass (ans_id, tmp, 0, 1);
+  tree_simple_assignment_expression tmp_ass (ans_id, tmp, false, true);
 
   tmp_ass.eval (print);
 }
 
 void
 bind_global_error_variable (void)
 {
   *error_message_buffer << ends;
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -65,35 +65,35 @@ struct builtin_function
   string name;
   int is_text_fcn;
   Octave_builtin_fcn fcn;
   string help_string;
 };
 
 extern void initialize_symbol_tables (void);
 
-extern int lookup (symbol_record *s, int exec_script = 1);
+extern bool lookup (symbol_record *s, int exec_script = 1);
 
 extern symbol_record *lookup_by_name (const string& nm, int exec_script = 1);
 
 extern string get_help_from_file (const string& f);
 
 extern string builtin_string_variable (const string&);
 extern int builtin_real_scalar_variable (const string&, double&);
 extern tree_constant builtin_any_variable (const string&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
 extern void force_link_to_function (const string&);
 
-extern int is_builtin_variable (const string&);
-extern int is_text_function_name (const string&);
-extern int is_globally_visible (const string&);
+extern bool is_builtin_variable (const string&);
+extern bool is_text_function_name (const string&);
+extern bool is_globally_visible (const string&);
 
 extern tree_fvc *is_valid_function (const tree_constant&, const string&,
 				    int warn = 0); 
 
 extern string_vector make_name_list (void);
 
 extern void install_builtin_mapper (const builtin_mapper_function& mf);
 
