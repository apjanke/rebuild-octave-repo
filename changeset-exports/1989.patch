# HG changeset patch
# User jwe
# Date 825726852 0
#      Sat Mar 02 00:34:12 1996 +0000
# Node ID a4b0826e240c3eead508e5b14aff8c9789ad337b
# Parent  7b56630a1e05bb55b7b508e6804c21c9de6b7951
[project @ 1996-03-02 00:33:22 by jwe]

diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -18,35 +18,43 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate Arrays of Complex values.
 
+#include "oct-cmplx.h"
+
 #include "Array.h"
 #include "Array.cc"
 
-#include "oct-cmplx.h"
-
 template class Array<Complex>;
-template class Array2<Complex>;
-template class DiagArray<Complex>;
 
 template void assign (Array<Complex>&, const Array<Complex>&);
 template void assign (Array<Complex>&, const Array<double>&);
 template void assign (Array<Complex>&, const Array<int>&);
 template void assign (Array<Complex>&, const Array<short>&);
 template void assign (Array<Complex>&, const Array<char>&);
 
+#include "Array2.h"
+#include "Array2.cc"
+
+template class Array2<Complex>;
+
 template void assign (Array2<Complex>&, const Array2<Complex>&);
 template void assign (Array2<Complex>&, const Array2<double>&);
 template void assign (Array2<Complex>&, const Array2<int>&);
 template void assign (Array2<Complex>&, const Array2<short>&);
 template void assign (Array2<Complex>&, const Array2<char>&);
 
+#include "DiagArray2.h"
+#include "DiagArray2.cc"
+
+template class DiagArray2<Complex>;
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -18,30 +18,33 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate Arrays of char values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "Array.h"
 #include "Array.cc"
 
 template class Array<char>;
-template class Array2<char>;
-
-#ifndef NO_DIAG_ARRAY
-template class DiagArray<char>;
-#endif
 
 template void assign (Array<char>&, const Array<char>&);
 
+#include "Array2.h"
+#include "Array2.cc"
+
+template class Array2<char>;
+
 template void assign (Array2<char>&, const Array2<char>&);
 
+#include "DiagArray2.h"
+#include "DiagArray2.cc"
+
+template class DiagArray2<char>;
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -22,27 +22,35 @@ Software Foundation, 59 Temple Place - S
 */
 
 // Instantiate Arrays of double values.
 
 #include "Array.h"
 #include "Array.cc"
 
 template class Array<double>;
-template class Array2<double>;
-template class DiagArray<double>;
 
 template void assign (Array<double>&, const Array<double>&);
 template void assign (Array<double>&, const Array<int>&);
 template void assign (Array<double>&, const Array<short>&);
 template void assign (Array<double>&, const Array<char>&);
 
+#include "Array2.h"
+#include "Array2.cc"
+
+template class Array2<double>;
+
 template void assign (Array2<double>&, const Array2<double>&);
 template void assign (Array2<double>&, const Array2<int>&);
 template void assign (Array2<double>&, const Array2<short>&);
 template void assign (Array2<double>&, const Array2<char>&);
 
+#include "DiagArray2.h"
+#include "DiagArray2.cc"
+
+template class DiagArray2<double>;
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -18,34 +18,37 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate Arrays of integer values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "Array.h"
 #include "Array.cc"
 
 template class Array<int>;
-template class Array2<int>;
-
-#ifndef NO_DIAG_ARRAY
-template class DiagArray<int>;
-#endif
 
 template void assign (Array<int>&, const Array<int>&);
 template void assign (Array<int>&, const Array<short>&);
 template void assign (Array<int>&, const Array<char>&);
 
+#include "Array2.h"
+#include "Array2.cc"
+
+template class Array2<int>;
+
 template void assign (Array2<int>&, const Array2<int>&);
 template void assign (Array2<int>&, const Array2<short>&);
 template void assign (Array2<int>&, const Array2<char>&);
 
+#include "DiagArray2.h"
+#include "DiagArray2.cc"
+
+template class DiagArray2<int>;
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-idx.h b/liboctave/Array-idx.h
--- a/liboctave/Array-idx.h
+++ b/liboctave/Array-idx.h
@@ -212,16 +212,17 @@ assign (Array<LT>& lhs, const Array<RT>&
       retval = 0;
     }
 
   lhs.clear_index ();
 
   return retval;
 }
 
+#if 0 /* XXX */
 template <class T>
 Array2<T>
 Array2<T>::value (void)
 {
   Array2<T> retval;
 
   int n_idx = index_count ();
 
@@ -782,15 +783,16 @@ Array3<T>::value (void)
 
 template <class LT, class RT>
 int
 assign (Array3<LT>&, const Array3<RT>&)
 {
   assert (0);
   return 0;
 }
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array-s.cc b/liboctave/Array-s.cc
--- a/liboctave/Array-s.cc
+++ b/liboctave/Array-s.cc
@@ -18,32 +18,35 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate Arrays of short int values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "Array.h"
 #include "Array.cc"
 
 template class Array<short>;
-template class Array2<short>;
-
-#ifndef NO_DIAG_ARRAY
-template class DiagArray<short>;
-#endif
 
 template void assign (Array<short>&, const Array<short>&);
 template void assign (Array<short>&, const Array<char>&);
 
+#include "Array2.h"
+#include "Array2.cc"
+
+template class Array2<short>;
+
 template void assign (Array2<short>&, const Array2<short>&);
 template void assign (Array2<short>&, const Array2<char>&);
 
+#include "DiagArray2.h"
+#include "DiagArray2.cc"
+
+template class DiagArray2<short>;
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -206,391 +206,14 @@ Array<T>::fortran_vec (void)
   if (rep->count > 1)
     {
       --rep->count;
       rep = new ArrayRep (*rep);
     }
   return rep->data;
 }
 
-// Two dimensional array class.
-
-template <class T>
-T&
-Array2<T>::checkelem (int i, int j)
-{
-  if (i < 0 || j < 0 || i >= d1 || j >= d2)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static T foo;
-      return foo;
-    }
-  return Array<T>::elem (d1*j+i);
-}
-
-template <class T>
-T
-Array2<T>::elem (int i, int j) const
-{
-  return Array<T>::elem (d1*j+i);
-}
-
-template <class T>
-T
-Array2<T>::checkelem (int i, int j) const
-{
-  if (i < 0 || j < 0 || i >= d1 || j >= d2)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return Array<T>::elem (d1*j+i);
-}
-
-template <class T>
-T
-Array2<T>::operator () (int i, int j) const
-{
-  if (i < 0 || j < 0 || i >= d1 || j >= d2)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return Array<T>::elem (d1*j+i);
-}
-
-template <class T>
-void
-Array2<T>::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimension");
-      return;
-    }
-
-  if (r == dim1 () && c == dim2 ())
-    return;
-
-  ArrayRep *old_rep = rep;
-  const T *old_data = data ();
-
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_len = length ();
-
-  rep = new ArrayRep (r*c);
-
-  d1 = r;
-  d2 = c;
-
-  if (old_data && old_len > 0)
-    {
-      int min_r = old_d1 < r ? old_d1 : r;
-      int min_c = old_d2 < c ? old_d2 : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  xelem (i, j) = old_data[old_d1*j+i];
-    }
-
-  if (--old_rep->count <= 0)
-    delete old_rep;
-}
-
-template <class T>
-void
-Array2<T>::resize (int r, int c, const T& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimension");
-      return;
-    }
-
-  if (r == dim1 () && c == dim2 ())
-    return;
-
-  ArrayRep *old_rep = rep;
-  const T *old_data = data ();
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_len = length ();
-
-  rep = new ArrayRep (r*c);
-
-  d1 = r;
-  d2 = c;
-
-  int min_r = old_d1 < r ? old_d1 : r;
-  int min_c = old_d2 < c ? old_d2 : c;
-
-  if (old_data && old_len > 0)
-    {
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  xelem (i, j) = old_data[old_d1*j+i];
-    }
-
-  for (int j = 0; j < min_c; j++)
-    for (int i = min_r; i < r; i++)
-      xelem (i, j) = val;
-
-  for (int j = min_c; j < c; j++)
-    for (int i = 0; i < r; i++)
-      xelem (i, j) = val;
-
-  if (--old_rep->count <= 0)
-    delete old_rep;
-}
-
-template <class T>
-Array2<T>&
-Array2<T>::insert (const Array2<T>& a, int r, int c)
-{
-  int a_rows = a.rows ();
-  int a_cols = a.cols ();
-
-  if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
-
-  for (int j = 0; j < a_cols; j++)
-    for (int i = 0; i < a_rows; i++)
-      elem (r+i, c+j) = a.elem (i, j);
-
-  return *this;
-}
-
-// Three dimensional array class.
-
-template <class T>
-T&
-Array3<T>::checkelem (int i, int j, int k)
-{
-  if (i < 0 || j < 0 || k < 0 || i >= d1 || j >= d2 || k >= d3)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static T foo;
-      return foo;
-    }
-  return Array2<T>::elem (i, d1*k+j);
-}
-
-template <class T>
-T
-Array3<T>::elem (int i, int j, int k) const
-{
-  return Array2<T>::elem (i, d2*k+j);
-}
-
-template <class T>
-T
-Array3<T>::checkelem (int i, int j, int k) const
-{
-  if (i < 0 || j < 0 || k < 0 || i >= d1 || j >= d2 || k >= d3)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return Array2<T>::elem (i, d1*k+j);
-}
-
-template <class T>
-T
-Array3<T>::operator () (int i, int j, int k) const
-{
-  if (i < 0 || j < 0 || k < 0 || i >= d1 || j >= d2 || k >= d3)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return Array2<T>::elem (i, d2*k+j);
-}
-
-template <class T>
-void
-Array3<T>::resize (int n, int m, int k)
-{
-  assert (0); // XXX FIXME XXX
-}
-
-template <class T>
-void
-Array3<T>::resize (int n, int m, int k, const T& val)
-{
-  assert (0); // XXX FIXME XXX
-}
-
-// A two-dimensional array with diagonal elements only.
-
-#ifndef NO_DIAG_ARRAY
-#if 1
-template <class T>
-T&
-DiagArray<T>::elem (int r, int c)
-{
-  static T foo (0);
-  return (r == c) ? Array<T>::elem (r) : foo;
-}
-
-template <class T>
-T&
-DiagArray<T>::checkelem (int r, int c)
-{
-  static T foo (0);
-  if (r < 0 || c < 0 || r >= nr || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return foo;
-    }
-  return (r == c) ? Array<T>::elem (r) : foo;
-}
-
-template <class T>
-T&
-DiagArray<T>::operator () (int r, int c)
-{
-  static T foo (0);
-  if (r < 0 || c < 0 || r >= nr || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return foo;
-    }
-  return (r == c) ? Array<T>::elem (r) : foo;
-}
-#endif
-
-template <class T>
-T&
-DiagArray<T>::xelem (int r, int c)
-{
-  static T foo (0);
-  return (r == c) ? Array<T>::xelem (r) : foo;
-}
-
-template <class T>
-T
-DiagArray<T>::elem (int r, int c) const
-{
-  return (r == c) ? Array<T>::elem (r) : T (0);
-}
-
-template <class T>
-T
-DiagArray<T>::checkelem (int r, int c) const
-{
-  if (r < 0 || c < 0 || r >= nr || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return (r == c) ? Array<T>::elem (r) : T (0);
-}
-
-template <class T>
-T
-DiagArray<T>::operator () (int r, int c) const
-{
-  if (r < 0 || c < 0 || r >= nr || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      T foo;
-      static T *bar = &foo;
-      return foo;
-    }
-  return (r == c) ? Array<T>::elem (r) : T (0);
-}
-
-template <class T>
-void
-DiagArray<T>::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimensions");
-      return;
-    }
-
-  if (r == dim1 () && c == dim2 ())
-    return;
-
-  ArrayRep *old_rep = rep;
-  const T *old_data = data ();
-  int old_len = length ();
-
-  int new_len = r < c ? r : c;
-
-  rep = new ArrayRep (new_len);
-
-  nr = r;
-  nc = c;
-
-  if (old_data && old_len > 0)
-    {
-      int min_len = old_len < new_len ? old_len : new_len;
-
-      for (int i = 0; i < min_len; i++)
-	xelem (i, i) = old_data[i];
-    }
-
-  if (--old_rep->count <= 0)
-    delete old_rep;
-}
-
-template <class T>
-void
-DiagArray<T>::resize (int r, int c, const T& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimensions");
-      return;
-    }
-
-  if (r == dim1 () && c == dim2 ())
-    return;
-
-  ArrayRep *old_rep = rep;
-  const T *old_data = data ();
-  int old_len = length ();
-
-  int new_len = r < c ? r : c;
-
-  rep = new ArrayRep (new_len);
-
-  nr = r;
-  nc = c;
-
-  int min_len = old_len < new_len ? old_len : new_len;
-
-  if (old_data && old_len > 0)
-    {
-      for (int i = 0; i < min_len; i++)
-	xelem (i, i) = old_data[i];
-    }
-
-  for (int i = min_len; i < new_len; i++)
-    xelem (i, i) = val;
-
-  if (--old_rep->count <= 0)
-    delete old_rep;
-}
-#endif
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -32,26 +32,16 @@ Software Foundation, 59 Temple Place - S
 
 #include <cassert>
 #include <cstdlib>
 
 #include "lo-error.h"
 
 class idx_vector;
 
-// Classes we declare.
-
-template <class T> class Array;
-template <class T> class Array2;
-template <class T> class Array3;
-
-#ifndef NO_DIAG_ARRAY
-template <class T> class DiagArray;
-#endif
-
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
 class Array
 {
 private:
 
@@ -168,23 +158,24 @@ public:
 	  rep = new ArrayRep (*rep);
 	}
       return rep->elem (n);
     }
 
   T& checkelem (int n);
   T& operator () (int n) { return checkelem (n); }
 
+  T elem (int n) const;
+  T checkelem (int n) const;
+  T operator () (int n) const;
+
   // No checking.
 
   T& xelem (int n) { return rep->elem (n); }
-
-  T elem (int n) const;
-  T checkelem (int n) const;
-  T operator () (int n) const;
+  T xelem (int n) const { return rep->elem (n); }
 
   void resize (int n);
   void resize (int n, const T& val);
 
   const T *data (void) const { return rep->data; }
 
   T *fortran_vec (void);
 
@@ -216,420 +207,16 @@ public:
 
   Array<T> value (void);
 #endif
 };
 
 template <class LT, class RT>
 int assign (Array<LT>& lhs, const Array<RT>& rhs);
 
-// Two dimensional array class.
-
-template <class T>
-class Array2 : public Array<T>
-{
-protected:
-
-  Array2 (T *d, int n, int m) : Array<T> (d, n*m)
-    {
-      d1 = n;
-      d2 = m;
-      set_max_indices (2);
-    }
-
-public:
-
-  // These really need to be protected (and they will be in the
-  // future, so don't depend on them being here!), but they can't be
-  // until template friends work correctly in g++.
-
-  int d1;
-  int d2;
-
-  Array2 (void) : Array<T> ()
-    {
-      d1 = 0;
-      d2 = 0;
-      set_max_indices (2);
-    }
-
-  Array2 (int n, int m) : Array<T> (n*m)
-    {
-      d1 = n;
-      d2 = m;
-      set_max_indices (2);
-    }
-
-  Array2 (int n, int m, const T& val) : Array<T> (n*m, val)
-    {
-      d1 = n;
-      d2 = m;
-      set_max_indices (2);
-    }
-
-  Array2 (const Array2<T>& a) : Array<T> (a)
-    {
-      d1 = a.d1;
-      d2 = a.d2;
-      set_max_indices (2);
-    }
-
-  Array2 (const Array<T>& a, int n, int m) : Array<T> (a)
-    {
-      d1 = n;
-      d2 = m;
-      set_max_indices (2);
-    }
-
-#ifndef NO_DIAG_ARRAY
-  Array2 (const DiagArray<T>& a) : Array<T> (a.rows () * a.cols (), T (0))
-    {
-      for (int i = 0; i < a.length (); i++)
-	elem (i, i) = a.elem (i, i);
-
-      set_max_indices (2);
-    }
-#endif
-
-  ~Array2 (void) { }
-
-  Array2<T>& operator = (const Array2<T>& a)
-    {
-      if (this != &a && rep != a.rep)
-	{
-	  Array<T>::operator = (a);
-	  d1 = a.d1;
-	  d2 = a.d2;
-	}
-
-      return *this;
-    }
-
-  int dim1 (void) const { return d1; }
-  int dim2 (void) const { return d2; }
-
-  int rows (void) const { return d1; }
-  int cols (void) const { return d2; }
-  int columns (void) const { return d2; }
-
-  T& elem (int i, int j) { return Array<T>::elem (d1*j+i); }
-  T& checkelem (int i, int j);
-  T& operator () (int i, int j) { return checkelem (i, j); }
-
-  // No checking.
-
-  T& xelem (int i, int j) { return Array<T>::xelem (d1*j+i); }
-
-  T elem (int i, int j) const;
-  T checkelem (int i, int j) const;
-  T operator () (int i, int j) const;
-
-  void resize (int n, int m);
-  void resize (int n, int m, const T& val);
-
-  Array2<T>& insert (const Array2<T>& a, int r, int c);
-
-#ifdef HEAVYWEIGHT_INDEXING
-  void maybe_delete_elements (idx_vector& i, idx_vector& j);
-
-  Array2<T> value (void);
-#endif
-};
-
-template <class LT, class RT>
-int assign (Array2<LT>& lhs, const Array2<RT>& rhs);
-
-// Three dimensional array class.
-
-template <class T>
-class Array3 : public Array2<T>
-{
-protected:
-
-  int d3;
-
-  Array3 (T *d, int n, int m, int k) : Array2<T> (d, n, m*k)
-    {
-      d2 = m;
-      d3 = k;
-      set_max_indices (3);
-    }
-
-public:
-
-  Array3 (void) : Array2<T> ()
-    {
-      d2 = 0;
-      d3 = 0;
-      set_max_indices (3);
-    }
-
-  Array3 (int n, int m, int k) : Array2<T> (n, m*k)
-    {
-      d2 = m;
-      d3 = k;
-      set_max_indices (3);
-    }
-
-  Array3 (int n, int m, int k, const T& val) : Array2<T> (n, m*k, val)
-    {
-      d2 = m;
-      d3 = k;
-      set_max_indices (3);
-    }
-
-  Array3 (const Array3<T>& a) : Array2<T> (a)
-    {
-      d2 = a.d2;
-      d3 = a.d3;
-      set_max_indices (3);
-    }
-
-  ~Array3 (void) { }
-
-  Array3<T>& operator = (const Array3<T>& a)
-    {
-      if (this != &a && rep != a.rep)
-	{
-	  Array<T>::operator = (a);
-	  d1 = a.d1;
-	  d2 = a.d2;
-	  d3 = a.d3;
-	}
-
-      return *this;
-    }
-
-  int dim3 (void) const { return d3; }
-
-  T& elem (int i, int j, int k) { return Array2<T>::elem (i, d2*k+j); }
-  T& checkelem (int i, int j, int k);
-  T& operator () (int i, int j, int k) { return checkelem (i, j, k); }
-
-  // No checking.
-
-  T& xelem (int i, int j, int k) { return Array2<T>::xelem (i, d2*k+j); }
-
-  T elem (int i, int j, int k) const;
-  T checkelem (int i, int j, int k) const;
-  T operator () (int i, int j, int k) const;
-
-  void resize (int n, int m, int k);
-  void resize (int n, int m, int k, const T& val);
-
-#ifdef HEAVYWEIGHT_INDEXING
-  void maybe_delete_elements (idx_vector& i, idx_vector& j, idx_vector& k);
-
-  Array3<T> value (void);
-#endif
-};
-
-template <class LT, class RT>
-int assign (Array3<LT>& lhs, const Array3<RT>& rhs);
-
-// A two-dimensional array with diagonal elements only.
-//
-// Idea and example code for Proxy class and functions from:
-//
-// From: kanze@us-es.sel.de (James Kanze)
-// Subject: Re: How to overload [] to do READ/WRITE differently ?
-// Message-ID: <KANZE.93Nov29151407@slsvhdt.us-es.sel.de>
-// Sender: news@us-es.sel.de
-// Date: 29 Nov 1993 14:14:07 GMT
-// --
-// James Kanze                             email: kanze@us-es.sel.de
-// GABI Software, Sarl., 8 rue du Faisan, F-67000 Strasbourg, France
-
-#ifndef NO_DIAG_ARRAY
-template <class T>
-class DiagArray : public Array<T>
-{
-private:
-  T get (int i) { return Array<T>::elem (i); }
-  void set (const T& val, int i) { Array<T>::elem (i) = val; }
-
-  class Proxy
-  {
-  public:
-
-    Proxy (DiagArray<T> *ref, int r, int c)
-      : i (r), j (c), object (ref) { } 
-
-    const Proxy& operator = (const T& val) const
-      {
-	if (i == j)
-	  {
-	    if (object)
-	      object->set (val, i);
-	  }
-	else
-	  (*current_liboctave_error_handler) ("invalid assignment to off-diagonal in diagonal array");
-
-	return *this;
-      }
-
-    operator T () const
-      {
-	if (object && i == j)
-	  return object->get (i);
-	else
-	  {
-	    static T foo (0);
-	    return foo;
-	  }
-      }
-
-  private:
-
-    // XXX FIXME XXX -- this is declared private to keep the user from
-    // taking the address of a Proxy.  Maybe it should be implemented
-    // by means of a companion function in the DiagArray class.
-
-    T *operator& () const { assert (0); return (T *) 0; }
-
-    int i;
-    int j;
-
-    DiagArray<T> *object;
-
-  };
-
-friend class Proxy;
-
-protected:
-
-  int nr;
-  int nc;
-
-  DiagArray (T *d, int r, int c) : Array<T> (d, r < c ? r : c)
-    {
-      nr = r;
-      nc = c;
-      set_max_indices (2);
-    }
-
-public:
-
-  DiagArray (void) : Array<T> ()
-    {
-      nr = 0;
-      nc = 0;
-      set_max_indices (2);
-    }
-
-  DiagArray (int n) : Array<T> (n)
-    {
-      nr = n;
-      nc = n;
-      set_max_indices (2);
-    }
-
-  DiagArray (int n, const T& val) : Array<T> (n, val)
-    {
-      nr = n;
-      nc = n;
-      set_max_indices (2);
-    }
-
-  DiagArray (int r, int c) : Array<T> (r < c ? r : c)
-    {
-      nr = r;
-      nc = c;
-      set_max_indices (2);
-    }
-
-  DiagArray (int r, int c, const T& val) : Array<T> (r < c ? r : c, val)
-    {
-      nr = r;
-      nc = c;
-      set_max_indices (2);
-    }
-
-  DiagArray (const Array<T>& a) : Array<T> (a)
-    {
-      nr = nc = a.length ();
-      set_max_indices (2);
-    }
-
-  DiagArray (const DiagArray<T>& a) : Array<T> (a)
-    {
-      nr = a.nr;
-      nc = a.nc;
-      set_max_indices (2);
-    }
-
-  ~DiagArray (void) { }
-
-  DiagArray<T>& operator = (const DiagArray<T>& a)
-    {
-      if (this != &a)
-	{
-	  Array<T>::operator = (a);
-	  nr = a.nr;
-	  nc = a.nc;
-	}
-
-      return *this;
-    }
-
-  int dim1 (void) const { return nr; }
-  int dim2 (void) const { return nc; }
-
-  int rows (void) const { return nr; }
-  int cols (void) const { return nc; }
-  int columns (void) const { return nc; }
-
-#if 0
-  Proxy elem (int r, int c)
-    {
-      return Proxy (this, r, c);
-    }
-
-  Proxy checkelem (int r, int c)
-    {
-      if (r < 0 || c < 0 || r >= nr || c >= nc)
-	{
-	  (*current_liboctave_error_handler) ("range error");
-	  return Proxy (0, r, c);
-	}
-      else
-	return Proxy (this, r, c);
-    }
-
-  Proxy operator () (int r, int c)
-    {
-      if (r < 0 || c < 0 || r >= nr || c >= nc)
-	{
-	  (*current_liboctave_error_handler) ("range error");
-	  return Proxy (0, r, c);
-	}
-      else
-	return Proxy (this, r, c);
-  }
-#else
-  T& elem (int r, int c);
-  T& checkelem (int r, int c);
-  T& operator () (int r, int c);
-#endif
-
-  // No checking.
-
-  T& xelem (int r, int c);
-
-  T elem (int r, int c) const;
-  T checkelem (int r, int c) const;
-  T operator () (int r, int c) const;
-
-  void resize (int n, int m);
-  void resize (int n, int m, const T& val);
-
-  void maybe_delete_elements (idx_vector& i, idx_vector& j);
-};
-#endif
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -33,32 +33,18 @@ Software Foundation, 59 Temple Place - S
 
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Complex Diagonal Matrix class
 
-ComplexDiagMatrix::ComplexDiagMatrix (const RowVector& a)
-  : MDiagArray<Complex> (a.length ())
-{
-  for (int i = 0; i < length (); i++)
-    elem (i, i) = a.elem (i);
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const ColumnVector& a)
-  : MDiagArray<Complex> (a.length ())
-{
-  for (int i = 0; i < length (); i++)
-    elem (i, i) = a.elem (i);
-}
-
 ComplexDiagMatrix::ComplexDiagMatrix (const DiagMatrix& a)
-  : MDiagArray<Complex> (a.rows (), a.cols ())
+  : MDiagArray2<Complex> (a.rows (), a.cols ())
 {
   for (int i = 0; i < length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 int
 ComplexDiagMatrix::operator == (const ComplexDiagMatrix& a) const
 {
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -23,49 +23,48 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_ComplexDiagMatrix_h)
 #define octave_ComplexDiagMatrix_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-#include "MArray.h"
+#include "MDiagArray2.h"
 
 #include "dRowVector.h"
 #include "CRowVector.h"
 #include "dColVector.h"
 #include "CColVector.h"
 
 #include "mx-defs.h"
 
-class ComplexDiagMatrix : public MDiagArray<Complex>
+class ComplexDiagMatrix : public MDiagArray2<Complex>
 {
 public:
 
-  ComplexDiagMatrix (void) : MDiagArray<Complex> () { }
-  ComplexDiagMatrix (int n) : MDiagArray<Complex> (n) { }
-  ComplexDiagMatrix (int n, const Complex& val)
-    : MDiagArray<Complex> (n, n, val) { }
-  ComplexDiagMatrix (int r, int c) : MDiagArray<Complex> (r, c) { }
+  ComplexDiagMatrix (void) : MDiagArray2<Complex> () { }
+  ComplexDiagMatrix (int r, int c) : MDiagArray2<Complex> (r, c) { }
   ComplexDiagMatrix (int r, int c, const Complex& val)
-    : MDiagArray<Complex> (r, c, val) { }
-  ComplexDiagMatrix (const RowVector& a);
-  ComplexDiagMatrix (const ComplexRowVector& a) : MDiagArray<Complex> (a) { }
-  ComplexDiagMatrix (const ColumnVector& a);
+    : MDiagArray2<Complex> (r, c, val) { }
+  ComplexDiagMatrix (const RowVector& a)
+    : MDiagArray2<Complex> (ComplexRowVector (a)) { }
+  ComplexDiagMatrix (const ComplexRowVector& a) : MDiagArray2<Complex> (a) { }
+  ComplexDiagMatrix (const ColumnVector& a)
+    : MDiagArray2<Complex> (ComplexColumnVector (a)) { }
   ComplexDiagMatrix (const ComplexColumnVector& a)
-    : MDiagArray<Complex> (a) { }
+    : MDiagArray2<Complex> (a) { }
   ComplexDiagMatrix (const DiagMatrix& a);
-  ComplexDiagMatrix (const MDiagArray<Complex>& a)
-    : MDiagArray<Complex> (a) { }
-  ComplexDiagMatrix (const ComplexDiagMatrix& a) : MDiagArray<Complex> (a) { }
+  ComplexDiagMatrix (const MDiagArray2<Complex>& a)
+    : MDiagArray2<Complex> (a) { }
+  ComplexDiagMatrix (const ComplexDiagMatrix& a) : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
     {
-      MDiagArray<Complex>::operator = (a);
+      MDiagArray2<Complex>::operator = (a);
       return *this;
     }
 
   int operator == (const ComplexDiagMatrix& a) const;
   int operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
@@ -154,17 +153,17 @@ public:
 
   // i/o
 
   friend ostream& operator << (ostream& os, const ComplexDiagMatrix& a);
 
 private:
 
   ComplexDiagMatrix (Complex *d, int nr, int nc)
-    : MDiagArray<Complex> (d, nr, nc) { }
+    : MDiagArray2<Complex> (d, nr, nc) { }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -23,17 +23,18 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_ComplexMatrix_h)
 #define octave_ComplexMatrix_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-#include "MArray.h"
+#include "MArray2.h"
+#include "MDiagArray2.h"
 
 #include "mx-defs.h"
 #include "oct-cmplx.h"
 
 class ComplexMatrix : public MArray2<Complex>
 {
 friend class Matrix;
 friend class ComplexCHOL;
@@ -49,17 +50,17 @@ public:
   ComplexMatrix (void) : MArray2<Complex> () { }
   ComplexMatrix (int r, int c) : MArray2<Complex> (r, c) { }
   ComplexMatrix (int r, int c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
   ComplexMatrix (const Matrix& a);
   ComplexMatrix (const MArray2<Complex>& a) : MArray2<Complex> (a) { }
   ComplexMatrix (const ComplexMatrix& a) : MArray2<Complex> (a) { }
   ComplexMatrix (const DiagMatrix& a);
-  ComplexMatrix (const MDiagArray<Complex>& a) : MArray2<Complex> (a) { }
+  //  ComplexMatrix (const MDiagArray2<Complex>& a) : MArray2<Complex> (a) { }
   ComplexMatrix (const ComplexDiagMatrix& a);
 
   ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
     {
       MArray2<Complex>::operator = (a);
       return *this;
diff --git a/liboctave/MArray-C.cc b/liboctave/MArray-C.cc
--- a/liboctave/MArray-C.cc
+++ b/liboctave/MArray-C.cc
@@ -18,27 +18,37 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate MArrays of Complex values.
 
+#include "oct-cmplx.h"
+
 #include "MArray.h"
 #include "MArray.cc"
 
-#include "oct-cmplx.h"
-
 template class MArray<Complex>;
-template class MArray2<Complex>;
-template class MDiagArray<Complex>;
 
 INSTANTIATE_MARRAY_FRIENDS (Complex)
+
+#include "MArray2.h"
+#include "MArray2.cc"
+
+template class MArray2<Complex>;
+
 INSTANTIATE_MARRAY2_FRIENDS (Complex)
+
+#include "MDiagArray2.h"
+#include "MDiagArray2.cc"
+
+template class MDiagArray2<Complex>;
+
 INSTANTIATE_MDIAGARRAY_FRIENDS (Complex)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-ch.cc b/liboctave/MArray-ch.cc
--- a/liboctave/MArray-ch.cc
+++ b/liboctave/MArray-ch.cc
@@ -18,31 +18,35 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate MArrays of char values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<char>;
+
+INSTANTIATE_MARRAY_FRIENDS (char)
+
+#include "MArray2.h"
+#include "MArray2.cc"
+
 template class MArray2<char>;
 
-INSTANTIATE_MARRAY_FRIENDS (char)
 INSTANTIATE_MARRAY2_FRIENDS (char)
 
-#ifndef NO_DIAG_ARRAY
-template class MDiagArray<char>;
+#include "MDiagArray2.h"
+#include "MDiagArray2.cc"
+
+template class MDiagArray2<char>;
 
 INSTANTIATE_MDIAGARRAY_FRIENDS (char)
-#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-d.cc b/liboctave/MArray-d.cc
--- a/liboctave/MArray-d.cc
+++ b/liboctave/MArray-d.cc
@@ -22,116 +22,31 @@ Software Foundation, 59 Temple Place - S
 */
 
 // Instantiate MArrays of double values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<double>;
-template class MArray2<double>;
-template class MDiagArray<double>;
 
-template MArray<double>
-operator + (const MArray<double>& a, const double& s);
-
-template MArray<double>
-operator - (const MArray<double>& a, const double& s);
-
-template MArray<double>
-operator * (const MArray<double>& a, const double& s);
-
-template MArray<double>
-operator / (const MArray<double>& a, const double& s);
-
-template MArray<double>
-operator + (const double& s, const MArray<double>& a);
-
-template MArray<double>
-operator - (const double& s, const MArray<double>& a);
-
-template MArray<double>
-operator * (const double& s, const MArray<double>& a);
+INSTANTIATE_MARRAY_FRIENDS (double)
 
-template MArray<double>
-operator / (const double& s, const MArray<double>& a);
-
-template MArray<double>
-operator + (const MArray<double>& a, const MArray<double>& b);
-
-template MArray<double>
-operator - (const MArray<double>& a, const MArray<double>& b);
-
-template MArray<double>
-product (const MArray<double>& a, const MArray<double>& b); 
+#include "MArray2.h"
+#include "MArray2.cc"
 
-template MArray<double>
-quotient (const MArray<double>& a, const MArray<double>& b);
-
-template MArray<double>
-operator - (const MArray<double>& a);
-
-template MArray2<double>
-operator + (const MArray2<double>& a, const double& s);
-
-template MArray2<double>
-operator - (const MArray2<double>& a, const double& s);
-
-template MArray2<double>
-operator * (const MArray2<double>& a, const double& s);
+template class MArray2<double>;
 
-template MArray2<double>
-operator / (const MArray2<double>& a, const double& s);
-
-template MArray2<double>
-operator + (const double& s, const MArray2<double>& a);
-
-template MArray2<double>
-operator - (const double& s, const MArray2<double>& a);
-
-template MArray2<double>
-operator * (const double& s, const MArray2<double>& a);
-
-template MArray2<double>
-operator / (const double& s, const MArray2<double>& a);
-
-template MArray2<double>
-operator + (const MArray2<double>& a, const MArray2<double>& b);
-
-template MArray2<double>
-operator - (const MArray2<double>& a, const MArray2<double>& b);
-
-template MArray2<double>
-product (const MArray2<double>& a, const MArray2<double>& b);
+INSTANTIATE_MARRAY2_FRIENDS (double)
 
-template MArray2<double>
-quotient (const MArray2<double>& a, const MArray2<double>& b);
-
-template MArray2<double>
-operator - (const MArray2<double>& a);
-
-template MDiagArray<double>
-operator * (const MDiagArray<double>& a, const double& s);
-
-template MDiagArray<double>
-operator / (const MDiagArray<double>& a, const double& s);
+#include "MDiagArray2.h"
+#include "MDiagArray2.cc"
 
-template MDiagArray<double>
-operator * (const double& s, const MDiagArray<double>& a);
-
-template MDiagArray<double>
-operator + (const MDiagArray<double>& a, const MDiagArray<double>& b);
+template class MDiagArray2<double>;
 
-template MDiagArray<double>
-operator - (const MDiagArray<double>& a, const MDiagArray<double>& b);
-
-template MDiagArray<double>
-product (const MDiagArray<double>& a, const MDiagArray<double>& b);
-
-template MDiagArray<double>
-operator - (const MDiagArray<double>& a);
+INSTANTIATE_MDIAGARRAY_FRIENDS (double)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -18,31 +18,35 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate MArrays of int values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<int>;
+
+INSTANTIATE_MARRAY_FRIENDS (int)
+
+#include "MArray2.h"
+#include "MArray2.cc"
+
 template class MArray2<int>;
 
-INSTANTIATE_MARRAY_FRIENDS (int)
 INSTANTIATE_MARRAY2_FRIENDS (int)
 
-#ifndef NO_DIAG_ARRAY
-template class MDiagArray<int>;
+#include "MDiagArray2.h"
+#include "MDiagArray2.cc"
+
+template class MDiagArray2<int>;
 
 INSTANTIATE_MDIAGARRAY_FRIENDS (int)
-#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray-s.cc b/liboctave/MArray-s.cc
--- a/liboctave/MArray-s.cc
+++ b/liboctave/MArray-s.cc
@@ -18,31 +18,35 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 // Instantiate MArrays of short int values.
 
-#define NO_DIAG_ARRAY 1
-
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<short>;
+
+INSTANTIATE_MARRAY_FRIENDS (short)
+
+#include "MArray2.h"
+#include "MArray2.cc"
+
 template class MArray2<short>;
 
-INSTANTIATE_MARRAY_FRIENDS (short)
 INSTANTIATE_MARRAY2_FRIENDS (short)
 
-#ifndef NO_DIAG_ARRAY
-template class MDiagArray<short>;
+#include "MDiagArray2.h"
+#include "MDiagArray2.cc"
+
+template class MDiagArray2<short>;
 
 INSTANTIATE_MDIAGARRAY_FRIENDS (short)
-#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -27,82 +27,17 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "MArray.h"
 #include "lo-error.h"
 
-// Nothing like a little CPP abuse to brighten everyone's day.  Would
-// have been nice to do this with template functions but as of 2.5.x,
-// g++ seems to fail to resolve them properly.
-
-#define DO_VS_OP(OP) \
-  int l = a.length (); \
-  T *result = 0; \
-  if (l > 0) \
-    { \
-      result = new T [l]; \
-      const T *x = a.data (); \
-      for (int i = 0; i < l; i++) \
-	result[i] = x[i] OP s; \
-    }
-
-#define DO_SV_OP(OP) \
-  int l = a.length (); \
-  T *result = 0; \
-  if (l > 0) \
-    { \
-      result = new T [l]; \
-      const T *x = a.data (); \
-      for (int i = 0; i < l; i++) \
-	result[i] = s OP x[i]; \
-    }
-
-#define DO_VV_OP(OP) \
-  T *result = 0; \
-  if (l > 0) \
-    { \
-      result = new T [l]; \
-      const T *x = a.data (); \
-      const T *y = b.data (); \
-      for (int i = 0; i < l; i++) \
-	result[i] = x[i] OP y[i]; \
-    }
-
-#define NEG_V \
-  int l = a.length (); \
-  T *result = 0; \
-  if (l > 0) \
-    { \
-      result = new T [l]; \
-      const T *x = a.data (); \
-      for (int i = 0; i < l; i++) \
-	result[i] = -x[i]; \
-    }
-
-#define DO_VS_OP2(OP) \
-  int l = a.length (); \
-  if (l > 0) \
-    { \
-      T *tmp = a.fortran_vec (); \
-      for (int i = 0; i < l; i++) \
-	tmp[i] OP s; \
-    }
-
-#define DO_VV_OP2(OP) \
-  do \
-    { \
-      T *a_tmp = a.fortran_vec (); \
-      const T *b_tmp = b.data (); \
-      for (int i = 0; i < l; i++) \
-	a_tmp[i] += b_tmp[i]; \
-    } \
-  while (0)
+#include "MArray-defs.h"
 
 // One dimensional array with math ops.
 
 // Element by element MArray by scalar ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
@@ -215,272 +150,14 @@ MARRAY_AA_OP (quotient,   /, "division")
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
   NEG_V;
   return MArray<T> (result, l);
 }
 
-// Two dimensional array with math ops.
-
-#ifndef NO_DIAG_ARRAY
-template <class T>
-MArray2<T>::MArray2 (const MDiagArray<T>& a)
-  : Array2<T> (a.rows (), a.cols (), T (0))
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i, i) = a.elem (i, i);
-}
-#endif
-
-// Element by element MArray2 by scalar ops.
-
-template <class T>
-MArray2<T>&
-operator += (MArray2<T>& a, const T& s)
-{
-  DO_VS_OP2 (+=)
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator -= (MArray2<T>& a, const T& s)
-{
-  DO_VS_OP2 (-=)
-  return a;
-}
-
-// Element by element MArray2 by MArray2 ops.
-
-template <class T>
-MArray2<T>&
-operator += (MArray2<T>& a, const MArray2<T>& b)
-{
-  int r = a.rows ();
-  int c = a.cols ();
-  if (r != b.rows () || c != b.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant += array operation attempted");
-    }
-  else
-    {
-      if (r > 0 && c > 0)
-	{
-	  int l = a.length ();
-	  DO_VV_OP2 (+=);
-	}
-    }
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator -= (MArray2<T>& a, const MArray2<T>& b)
-{
-  int r = a.rows ();
-  int c = a.cols ();
-  if (r != b.rows () || c != b.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant -= array operation attempted");
-    }
-  else
-    {
-      if (r > 0 && c > 0)
-	{
-	  int l = a.length ();
-	  DO_VV_OP2 (-=);
-	}
-    }
-  return a;
-}
-
-// Element by element MArray2 by scalar ops.
-
-#define MARRAY_A2S_OP(OP) \
-  template <class T> \
-  MArray2<T> \
-  operator OP (const MArray2<T>& a, const T& s) \
-  { \
-    DO_VS_OP (OP); \
-    return MArray2<T> (result, a.rows (), a.cols ()); \
-  }
-
-MARRAY_A2S_OP (+)
-MARRAY_A2S_OP (-)
-MARRAY_A2S_OP (*)
-MARRAY_A2S_OP (/)
-
-// Element by element scalar by MArray2 ops.
-
-#define MARRAY_SA2_OP(OP) \
-  template <class T> \
-  MArray2<T> \
-  operator OP (const T& s, const MArray2<T>& a) \
-  { \
-    DO_SV_OP (OP); \
-    return MArray2<T> (result, a.rows (), a.cols ()); \
-  }
-
-MARRAY_SA2_OP (+)
-MARRAY_SA2_OP (-)
-MARRAY_SA2_OP (*)
-MARRAY_SA2_OP (/)
-
-// Element by element MArray2 by MArray2 ops.
-
-#define MARRAY_A2A2_OP(FCN, OP, OP_STR) \
-  template <class T> \
-  MArray2<T> \
-  FCN (const MArray2<T>& a, const MArray2<T>& b) \
-  { \
-    int r = a.rows (); \
-    int c = a.cols (); \
-    if (r != b.rows () || c != b.cols ()) \
-      { \
-	(*current_liboctave_error_handler) \
-	  ("nonconformant array " OP_STR " attempted"); \
-	return MArray2<T> (); \
-      } \
-    if (r == 0 || c == 0) \
-      return MArray2<T> (); \
-    int l = a.length (); \
-    DO_VV_OP (OP); \
-    return MArray2<T> (result, r, c); \
-  }
-
-MARRAY_A2A2_OP (operator +, +, "addition")
-MARRAY_A2A2_OP (operator -, -, "subtraction")
-MARRAY_A2A2_OP (product,    *, "product")
-MARRAY_A2A2_OP (quotient,   /, "quotient")
-
-// Unary MArray2 ops.
-
-template <class T>
-MArray2<T>
-operator - (const MArray2<T>& a)
-{
-  NEG_V;
-  return MArray2<T> (result, a.rows (), a.cols ());
-}
-
-// Two dimensional diagonal array with math ops.
-
-#ifndef NO_DIAG_ARRAY
-
-// Element by element MDiagArray by MDiagArray ops.
-
-template <class T>
-MDiagArray<T>&
-operator += (MDiagArray<T>& a, const MDiagArray<T>& b)
-{
-  int r = a.rows ();
-  int c = a.cols ();
-  if (r != b.rows () || c != b.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant array " OP_STR " attempted");
-      return MArray2<T> ();
-    }
-  else
-    {
-      int l = a.length ();
-      T *a_tmp = a.fortran_vec ();
-      const T *b_tmp = b.data ();
-      for (int i = 0; i < l; i++)
-	a_tmp[i] += b_tmp[i];
-    }
-  return a;
-}
-
-template <class T>
-MDiagArray<T>&
-operator -= (MDiagArray<T>& a, const MDiagArray<T>& b)
-{
-  int r = a.rows ();
-  int c = a.cols ();
-  if (r != b.rows () || c != b.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant array " OP_STR " attempted");
-      return MArray2<T> ();
-    }
-  else
-    {
-      int l = a.length ();
-      T *a_tmp = a.fortran_vec ();
-      const T *b_tmp = b.data ();
-      for (int i = 0; i < l; i++)
-	a_tmp[i] -= b_tmp[i];
-    }
-  return a;
-}
-
-// Element by element MDiagArray by scalar ops.
-
-#define MARRAY_DAS_OP(OP) \
-  template <class T> \
-  MDiagArray<T> \
-  operator OP (const MDiagArray<T>& a, const T& s) \
-  { \
-    DO_VS_OP (OP); \
-    return MDiagArray<T> (result, a.rows (), a.cols ()); \
-  }
-
-MARRAY_DAS_OP (*)
-MARRAY_DAS_OP (/)
-
-// Element by element scalar by MDiagArray ops.
-
-template <class T>
-MDiagArray<T>
-operator * (const T& s, const MDiagArray<T>& a)
-{
-  DO_SV_OP (*);
-  return MDiagArray<T> (result, a.rows (), a.cols ());
-}
-
-// Element by element MDiagArray by MDiagArray ops.
-
-#define MARRAY_DADA_OP(FCN, OP, OP_STR) \
-  template <class T> \
-  MDiagArray<T> \
-  FCN (const MDiagArray<T>& a, const MDiagArray<T>& b) \
-  { \
-    int r = a.rows (); \
-    int c = a.cols (); \
-    if (r != b.rows () || c != b.cols ()) \
-      { \
-	(*current_liboctave_error_handler) \
-	  ("nonconformant diagonal array " OP_STR " attempted"); \
-	return MDiagArray<T> (); \
-      } \
-    if (c == 0 || r == 0) \
-      return MDiagArray<T> (); \
-    int l = a.length (); \
-    DO_VV_OP (OP); \
-    return MDiagArray<T> (result, r, c); \
-  }
-
-MARRAY_DADA_OP (operator +, +, "addition")
-MARRAY_DADA_OP (operator -, -, "subtraction")
-MARRAY_DADA_OP (product,    *, "product")
-
-// Unary MDiagArray ops.
-
-template <class T>
-MDiagArray<T>
-operator - (const MDiagArray<T>& a)
-{
-  NEG_V;
-  return MDiagArray<T> (result, a.rows (), a.cols ());
-}
-#endif
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -25,40 +25,31 @@ Software Foundation, 59 Temple Place - S
 #pragma interface
 #endif
 
 #if !defined (octave_MArray_h)
 #define octave_MArray_h 1
 
 #include "Array.h"
 
-// Classes we declare.
-
-template <class T> class MArray;
-template <class T> class MArray2;
-
-#ifndef NO_DIAG_ARRAY
-template <class T> class MDiagArray;
-#endif
-
 // One dimensional array with math ops.
 
 template <class T>
 class MArray : public Array<T>
 {
 protected:
 
   MArray (T *d, int l) : Array<T> (d, l) { }
 
 public:
   
   MArray (void) : Array<T> () { }
   MArray (int n) : Array<T> (n) { }
   MArray (int n, const T& val) : Array<T> (n, val) { }
-  MArray (const Array<T>& a) : Array<T> (a) { }
+//  MArray (const Array<T>& a) : Array<T> (a) { }
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
     {
       Array<T>::operator = (a);
       return *this;
@@ -95,137 +86,30 @@ public:
   friend MArray<T> operator - (const MArray<T>& a, const MArray<T>& b);
 
   friend MArray<T> product (const MArray<T>& a, const MArray<T>& b);
   friend MArray<T> quotient (const MArray<T>& a, const MArray<T>& b);
 
   friend MArray<T> operator - (const MArray<T>& a);
 };
 
-// Two dimensional array with math ops.
-
-template <class T>
-class MArray2 : public Array2<T>
-{
-protected:
-
-  MArray2 (T *d, int n, int m) : Array2<T> (d, n, m) { }
-
-public:
-
-  MArray2 (void) : Array2<T> () { }
-  MArray2 (int n, int m) : Array2<T> (n, m) { }
-  MArray2 (int n, int m, const T& val) : Array2<T> (n, m, val) { }
-  MArray2 (const Array2<T>& a) : Array2<T> (a) { }
-  MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
-
-#ifndef NO_DIAG_ARRAY
-  MArray2 (const MDiagArray<T>& a);
-#endif
-
-  ~MArray2 (void) { }
-
-  MArray2<T>& operator = (const MArray2<T>& a)
-    {
-      Array2<T>::operator = (a);
-      return *this;
-    }
-
-  // element by element MArray2 by scalar ops
-
-  friend MArray2<T>& operator += (MArray2<T>& a, const T& s);
-  friend MArray2<T>& operator -= (MArray2<T>& a, const T& s);
-
-  // element by element MArray2 by MArray2 ops
-
-  friend MArray2<T>& operator += (MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T>& operator -= (MArray2<T>& a, const MArray2<T>& b);
-
-  // element by element MArray2 by scalar ops
-
-  friend MArray2<T> operator + (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator - (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator * (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator / (const MArray2<T>& a, const T& s);
-
-  // element by element scalar by MArray2 ops
-
-  friend MArray2<T> operator + (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator - (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator * (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator / (const T& s, const MArray2<T>& a);
-
-  // element by element MArray2 by MArray2 ops
-
-  friend MArray2<T> operator + (const MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T> operator - (const MArray2<T>& a, const MArray2<T>& b);
-
-  friend MArray2<T> product (const MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T> quotient (const MArray2<T>& a, const MArray2<T>& b);
-
-  friend MArray2<T> operator - (const MArray2<T>& a);
-};
-
-// Two dimensional diagonal array with math ops.
-
-#ifndef NO_DIAG_ARRAY
-template <class T>
-class MDiagArray : public DiagArray<T>
-{
-protected:
-
-  MDiagArray (T *d, int r, int c) : DiagArray<T> (d, r, c) { }
-
-public:
-  
-  MDiagArray (void) : DiagArray<T> () { }
-  MDiagArray (int n) : DiagArray<T> (n) { }
-//  MDiagArray (int n, const T& val) : DiagArray<T> (n, val) { }
-  MDiagArray (int r, int c) : DiagArray<T> (r, c) { }
-  MDiagArray (int r, int c, const T& val) : DiagArray<T> (r, c, val) { }
-  MDiagArray (const DiagArray<T>& a) : DiagArray<T> (a) { }
-  MDiagArray (const MDiagArray<T>& a) : DiagArray<T> (a) { }
-  MDiagArray (const MArray<T>& a) : DiagArray<T> (a) { }
-
-  ~MDiagArray (void) { }
-
-  MDiagArray<T>& operator = (const MDiagArray<T>& a)
-    {
-      DiagArray<T>::operator = (a);
-      return *this;
-    }
-
-  // element by element MDiagArray by MDiagArray ops
-
-  friend MDiagArray<T>& operator += (MDiagArray<T>& a, const MDiagArray<T>& b);
-  friend MDiagArray<T>& operator -= (MDiagArray<T>& a, const MDiagArray<T>& b);
-
-  // element by element MDiagArray by scalar ops
-
-  friend MDiagArray<T> operator * (const MDiagArray<T>& a, const T& s);
-  friend MDiagArray<T> operator / (const MDiagArray<T>& a, const T& s);
-
-  // element by element scalar by MDiagArray ops
-
-  friend MDiagArray<T> operator * (const T& s, const MDiagArray<T>& a);
-
-  // element by element MDiagArray by MDiagArray ops
-
-  friend MDiagArray<T> operator + (const MDiagArray<T>& a,
-				   const MDiagArray<T>& b); 
-
-  friend MDiagArray<T> operator - (const MDiagArray<T>& a,
-				   const MDiagArray<T>& b);
-
-  friend MDiagArray<T> product (const MDiagArray<T>& a,
-				const MDiagArray<T>& b);
-
-  friend MDiagArray<T> operator - (const MDiagArray<T>& a);
-};
-#endif
+#define INSTANTIATE_MARRAY_FRIENDS(T) \
+  template MArray<T> operator + (const MArray<T>& a, const T& s); \
+  template MArray<T> operator - (const MArray<T>& a, const T& s); \
+  template MArray<T> operator * (const MArray<T>& a, const T& s); \
+  template MArray<T> operator / (const MArray<T>& a, const T& s); \
+  template MArray<T> operator + (const T& s, const MArray<T>& a); \
+  template MArray<T> operator - (const T& s, const MArray<T>& a); \
+  template MArray<T> operator * (const T& s, const MArray<T>& a); \
+  template MArray<T> operator / (const T& s, const MArray<T>& a); \
+  template MArray<T> operator + (const MArray<T>& a, const MArray<T>& b); \
+  template MArray<T> operator - (const MArray<T>& a, const MArray<T>& b); \
+  template MArray<T> product (const MArray<T>& a, const MArray<T>& b); \
+  template MArray<T> quotient (const MArray<T>& a, const MArray<T>& b); \
+  template MArray<T> operator - (const MArray<T>& a);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 #pragma interface
 #endif
 
 // For FILE...
 #include <cstdio>
 
 #include <string>
 
-#include "MArray.h"
+#include "MArray2.h"
 
 #include "mx-defs.h"
 
 class
 charMatrix : public MArray2<char>
 {
 friend class ComplexMatrix;
 
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -23,44 +23,41 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_DiagMatrix_h)
 #define octave_DiagMatrix_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-#include "MArray.h"
+#include "MDiagArray2.h"
 
 #include "dRowVector.h"
 #include "dColVector.h"
 
 #include "mx-defs.h"
 
-class DiagMatrix : public MDiagArray<double>
+class DiagMatrix : public MDiagArray2<double>
 {
 friend class SVD;
 friend class ComplexSVD;
 
 public:
 
-  DiagMatrix (void) : MDiagArray<double> () { }
-  DiagMatrix (int n) : MDiagArray<double> (n) { }
-  DiagMatrix (int n, double val) : MDiagArray<double> (n, n, val) { }
-  DiagMatrix (int r, int c) : MDiagArray<double> (r, c) { }
-  DiagMatrix (int r, int c, double val) : MDiagArray<double> (r, c, val) { }
-  DiagMatrix (const RowVector& a) : MDiagArray<double> (a) { }
-  DiagMatrix (const ColumnVector& a) : MDiagArray<double> (a) { }
-  DiagMatrix (const MDiagArray<double>& a) : MDiagArray<double> (a) { }
-  DiagMatrix (const DiagMatrix& a) : MDiagArray<double> (a) { }
-//  DiagMatrix (double a) : MDiagArray<double> (1, a) { }
+  DiagMatrix (void) : MDiagArray2<double> () { }
+  DiagMatrix (int r, int c) : MDiagArray2<double> (r, c) { }
+  DiagMatrix (int r, int c, double val) : MDiagArray2<double> (r, c, val) { }
+  DiagMatrix (const RowVector& a) : MDiagArray2<double> (a) { }
+  DiagMatrix (const ColumnVector& a) : MDiagArray2<double> (a) { }
+  DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
+  DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
     {
-      MDiagArray<double>::operator = (a);
+      MDiagArray2<double>::operator = (a);
       return *this;
     }
 
   int operator == (const DiagMatrix& a) const;
   int operator != (const DiagMatrix& a) const;
 
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, int beg, int end);
@@ -105,17 +102,17 @@ public:
   ColumnVector diag (int k) const;
 
   // i/o
 
   friend ostream& operator << (ostream& os, const DiagMatrix& a);
 
 private:
 
-  DiagMatrix (double *d, int nr, int nc) : MDiagArray<double> (d, nr, nc) { }
+  DiagMatrix (double *d, int nr, int nc) : MDiagArray2<double> (d, nr, nc) { }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -26,17 +26,18 @@ Software Foundation, 59 Temple Place - S
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 // For FILE...
 #include <cstdio>
 
-#include "MArray.h"
+#include "MArray2.h"
+#include "MDiagArray2.h"
 
 #include "mx-defs.h"
 
 class Matrix : public MArray2<double>
 {
 friend class ComplexMatrix;
 friend class AEPBAL;
 friend class CHOL;
@@ -50,17 +51,17 @@ friend class SVD;
 
 public:
 
   Matrix (void) : MArray2<double> () { }
   Matrix (int r, int c) : MArray2<double> (r, c) { }
   Matrix (int r, int c, double val) : MArray2<double> (r, c, val) { }
   Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
   Matrix (const Matrix& a) : MArray2<double> (a) { }
-  Matrix (const MDiagArray<double>& a) : MArray2<double> (a) { }
+  //  Matrix (const MDiagArray2<double>& a) : MArray2<double> (a) { }
   Matrix (const DiagMatrix& a);
 
   Matrix (const charMatrix& a);
 
   Matrix& operator = (const Matrix& a)
     {
       MArray2<double>::operator = (a);
       return *this;
