# HG changeset patch
# User jwe
# Date 1196354800 0
#      Thu Nov 29 16:46:40 2007 +0000
# Node ID dd88d61d443f5e895b708964160ea44ad149c6a5
# Parent  86d0b16f2bb2f91820ba01b9d66a6f5ea28486de
[project @ 2007-11-29 16:44:45 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,21 @@
+2007-11-28  David Bateman  <dbateman@free.fr>
+
+	* __plt_get_axis_handle__.m: Also allow hggroup and return axes
+	ancestor. If leading argument is logical set variable nogca to see
+	if gca() should be called if there is no active handle found.
+	* __bar__.m, caxis.m, scatter.m, contourf.m, __axes_limits__.m,
+	fill.m,  surf.m, meshz.m, axis.m, pie.m, contour.m,
+	quiver.m, area.m, grid.m, cylinder.m, contour3.m, surface.m,
+	patch.m, scatter3.m, plot.m, sphere.m, quiver3.m, plotyy.m,
+	xlabel.m, ylabel.m, surfnorm.m, zlabel.m: Adapt to use
+	__plt__get_axis_arg__ to find axis handle.
+	* polar.m: Typo.
+
 2007-11-28  John W. Eaton  <jwe@octave.org>
 
 	* plot/__go_draw_axes__.m (get_data_limits): Delete unused arg TX.
 
 2007-11-28  Michael Goffioul <michael.goffioul@gmail.com>
 
 	* plot/drawnow.m: Fix typo.
 
diff --git a/scripts/plot/__axes_limits__.m b/scripts/plot/__axes_limits__.m
--- a/scripts/plot/__axes_limits__.m
+++ b/scripts/plot/__axes_limits__.m
@@ -17,31 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 function retval = __axes_limits__ (fcn, varargin)
   retval = [];
   fcnmode = sprintf("%smode", fcn);
 
-  if (nargin > 1 && isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    off = 1;
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("%s: expecting first argument to be an axes object", fcn);
-    endif
-  else
-    off = 0;
-    h = gca ();
-  endif
+  [h, varargin, nargin] = __plt_get_axis_arg__ (fcn, varargin{:});
 
-  if (nargin == off + 1)
+  if (nargin == 0)
     retval = get (h, fcn);
   else
-    arg = varargin{off + 1};
+    arg = varargin{1};
 
     if (ischar (arg))
       arg = tolower (arg);
       if (strcmp ("mode", arg))
 
 	retval = get (h, fcnmode);
       elseif (strcmp ("auto", arg) ||  strcmp ("manual", arg))  
 	set (h, fcnmode, arg);
diff --git a/scripts/plot/__bar__.m b/scripts/plot/__bar__.m
--- a/scripts/plot/__bar__.m
+++ b/scripts/plot/__bar__.m
@@ -17,46 +17,27 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 ## Author: jwe
 
 function varargout = __bar__ (vertical, func, varargin)
 
-  varargout = cell (nargout, 1);
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("%s: expecting first argument to be an axes object", func);
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      [varargout{:}] = __bar2__ (h, vertical, func, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    [varargout{:}] = __bar2__ (gca (), vertical, func, varargin{:});
-  endif
-
-endfunction
-
-function varargout = __bar2__ (h, vertical, func, varargin)
+  [h, varargin] = __plt_get_axis_arg__ ((nargout > 1), func, varargin{:});
 
   ## Slightly smaller than 0.8 to avoid clipping issue in gnuplot 4.0
   width = 0.8 - 10 * eps; 
   group = true;
 
-  if (nargin < 4)
+  if (nargin < 3)
     print_usage ();
   endif
 
-  if (nargin > 4 && isnumeric (varargin{2}))
+  if (nargin > 3 && isnumeric (varargin{2}))
     x = varargin{1};
     if (isvector (x))
       x = x(:);
     endif
     y = varargin{2};
     if (isvector (y))
       y = y(:);
     endif
@@ -79,17 +60,17 @@ function varargout = __bar2__ (h, vertic
       y = y(:);
     endif
     x = [1:size(y,1)]';
     idx = 2;
   endif
       
   newargs = {};
   have_line_spec = false;
-  while (idx <= nargin - 3)
+  while (idx <= nargin - 2)
     if (isstr (varargin{idx}) && strcmp (varargin{idx}, "grouped"))
       group = true;
       idx++;
     elseif (isstr (varargin{idx}) && strcmp (varargin{idx}, "stacked"))
       group = false;
       idx++;
     else
       if ((isstr (varargin{idx}) || iscell (varargin{idx}))
@@ -99,17 +80,17 @@ function varargout = __bar2__ (h, vertic
 	  have_line_spec = true;
 	  newargs = [{linespec.color}, newargs];
 	  idx++;
 	  continue;
 	endif
       endif
       if (isscalar(varargin{idx}))
 	width = varargin{idx++};
-      elseif (idx == nargin - 3)
+      elseif (idx == nargin - 2)
 	newargs = [newargs,varargin(idx++)];
       else
 	newargs = [newargs,varargin(idx:idx+1)];
 	idx += 2;
       endif
     endif
   endwhile
 
@@ -153,22 +134,29 @@ function varargout = __bar2__ (h, vertic
   yb(2:4:4*ylen,:) = y1;
   yb(3:4:4*ylen,:) = y1;
   yb(4:4:4*ylen,:) = y0;
 
   xb = reshape (xb, [4, numel(xb) / 4 / ycols, ycols]);
   yb = reshape (yb, [4, numel(yb) / 4 / ycols, ycols]);
 
   if (nargout < 2)
-    newplot ();
-    tmp = __bars__ (h, vertical, x, y, xb, yb, width, group,
-		    have_line_spec, newargs{:});
-    if (nargout == 1)
-      varargout{1} = tmp;
-    endif
+    oldh = gca ();
+    unwind_protect
+      axes (h);
+      newplot ();
+
+      tmp = __bars__ (h, vertical, x, y, xb, yb, width, group,
+		      have_line_spec, newargs{:});
+      if (nargout == 1)
+	varargout{1} = tmp;
+      endif
+    unwind_protect_cleanup
+      axes (oldh);
+    end_unwind_protect
   else
     if (vertical)
       varargout{1} = xb;
       varargout{2} = yb;
     else
       varargout{1} = yb;
       varargout{2} = xb;
     endif
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -15,30 +15,47 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 ## Author: jwe
 
-function [h, varargin] = __plt_get_axis_arg__ (caller, varargin)
+function [h, varargin, narg] = __plt_get_axis_arg__ (caller, varargin)
+
+  if (islogical (caller))
+    nogca = caller;
+    caller = varargin{1};
+    varargin(1) = [];
+  else
+    nogca = false;
+  endif
 
   if (nargin > 1 && length (varargin) > 0 && ishandle (varargin{1}))
     tmp = varargin{1};
     obj = get (tmp);
-    if (strcmp (obj.type, "axes"))
-      h = tmp;
+    if (strcmp (obj.type, "axes") || strcmp (obj.type, "hggroup"))
+      h = ancestor (tmp, "axes");
       varargin(1) = [];
       if (isempty (varargin))
 	varargin = {};
       endif
     else
       error ("%s: expecting first argument to be axes handle", caller);
     endif
   else
-    h = gca ();
+    f = get (0, "currentfigure");
+    if (! isempty (f))
+      h = get (f, 'currentaxes');
+    elseif (nogca)
+      h = NaN;
+    else
+      h = gca ();
+    endif
     if (nargin < 2)
       varargin = {};
     endif
   endif
 
+  narg = length (varargin);
+
 endfunction
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -35,28 +35,23 @@
 ## Additional arguments to the @code{area} function are passed to the 
 ## @code{patch}. The optional return value @var{h} provides a handle to 
 ## the list of patch objects.
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
+  [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
+
   if (nargin > 0)
     idx = 1;
-    ax = [];
     x = y = [];
     bv = 0;
     args = {};
-    ## Check for axes parent.
-    if (ishandle (varargin{idx})
-	&& strcmp (get (varargin{idx}, "type"), "axes"))
-      ax = varargin{idx};
-      idx++;
-    endif
     ## Check for (X) or (X,Y) arguments and possible base value.
     if (nargin >= idx && ismatrix (varargin{idx}))
       y = varargin{idx};
       idx++;
       if (nargin >= idx)
         if (isscalar (varargin{idx}))
           bv = varargin{idx};
           idx++;
@@ -82,21 +77,23 @@ function h = area (varargin)
       y = y(:);
     endif
     if (isempty (x))
       x = repmat ([1:size(y, 1)]', 1, size (y, 2));
     elseif (isvector (x))
       x = repmat (x(:),  1, size (y, 2));
     endif
 
-    if (isempty (ax))
-      tmp = __area__ (gca (), x, y, bv, args{:});
-    else
+    oldax = gca ();
+    unwind_protect
+      axes (ax);
       tmp = __area__ (ax, x, y, bv, args{:});
-    endif
+    unwind_protect_cleanup
+      axes (oldax);
+    end_unwind_protect
 
     if (nargout > 0)
       h = tmp;
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -113,41 +113,29 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 ## PKG_ADD: mark_as_command axis
 
 function varargout = axis (varargin)
 
-  if (nargin > 0 && isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("axis: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      varargout = cell (max (nargin == 1, nargout), 1);
-      if (isempty (varargout))
-	__axis__ (h, varargin{2:end});
-      else
-        [varargout{:}] = __axis__ (h, varargin{2:end});
-      endif
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("axis", varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
     varargout = cell (max (nargin == 0, nargout), 1);
     if (isempty (varargout))
-      __axis__ (gca (), varargin{:});
+      __axis__ (h, varargin{:});
     else
-      [varargout{:}] = __axis__ (gca (), varargin{:});
+      [varargout{:}] = __axis__ (h, varargin{:});
     endif
-  endif
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
 endfunction
 
 function curr_axis = __axis__ (ca, ax, varargin)
 
   if (nargin == 1)
     if (nargout == 0)
       set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -34,41 +34,29 @@
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
 ## PKG_ADD: mark_as_command caxis
 
 function varargout = caxis (varargin)
 
-  if (nargin > 0 && isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("caxis: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      varargout = cell (max (nargin == 1, nargout), 1);
-      if (isempty (varargout))
-	__caxis__ (h, varargin{2:end});
-      else
-        [varargout{:}] = __caxis__ (h, varargin{2:end});
-      endif
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("caxis", varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
     varargout = cell (max (nargin == 0, nargout), 1);
     if (isempty (varargout))
-      __caxis__ (gca (), varargin{:});
+      __caxis__ (h, varargin{:});
     else
-      [varargout{:}] = __caxis__ (gca (), varargin{:});
+      [varargout{:}] = __caxis__ (h, varargin{:});
     endif
-  endif
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
 endfunction
 
 function [cmin, cmax] = __caxis__ (ca, ax, varargin)
 
   if (nargin == 1)
     cmin = get (ca, "clim");
     if (nargout > 1)
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -44,32 +44,24 @@
 ## returned.
 ## @seealso{contourc, patch, plot}
 ## @end deftypefn
 
 ## Author: shaia
 
 function [c, h] = contour (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("contour: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      [ctmp, htmp] = __contour__ (h, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
+  [h, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
     newplot ();
-    [ctmp, htmp] = __contour__ (gca (), NaN, varargin{:});
-  endif
+    [ctmp, htmp] = __contour__ (h, NaN, varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -41,37 +41,28 @@
 ## The optional input and output argument @var{h} allows an axis handle to 
 ## be passed to @code{contour} and the handles to the contour objects to be
 ## returned.
 ## @seealso{contourc, patch, plot}
 ## @end deftypefn
 
 function [c, h] = contour3 (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin{1};
-    if (! strcmp (get (ax, "type"), "axes"))
-      error ("contour: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ax);
-      newplot ();
-      [ctmp, htmp] = __contour__ (ax, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("contour3", varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
     newplot ();
-    ax = gca ();
-    [ctmp, htmp] = __contour__ (ax, "level", varargin{:});
-  endif
+    [ctmp, htmp] = __contour__ (h, "level", varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (! ishold ())
-    set (ax, "view", [-37.5, 30]);
+    set (h, "view", [-37.5, 30]);
   endif
 
   if (nargout > 0)
     c = ctmp;
     h = htmp
   endif
 
 endfunction
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -54,17 +54,18 @@
 ## @seealso{contour, contourc, patch}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Author: shaia
 
 function varargout = contourf (varargin)
 
-  [X, Y, Z, lvl, ax, patch_props] = parse_args (varargin);
+  [ax, varargin] = __plt_get_axis_arg__ ("contourf", varargin{:});
+  [X, Y, Z, lvl, patch_props] = parse_args (varargin);
   [nr, nc] = size (Z);
   [minx, maxx] = deal (min (X(:)), max (X(:)));
   [miny, maxy] = deal (min (Y(:)), max (Y(:)));
 
   if (diff (lvl) < 10*eps) 
     lvl_eps = 1e-6;
   else
     lvl_eps = min (diff (lvl)) / 1000.0;
@@ -178,29 +179,21 @@ function varargout = contourf (varargin)
 
   if (nargout > 0)
     varargout{2} = h;
     varargout{1} = c;
   endif
 
 endfunction
 
-function [X, Y, Z, lvl, ax, patch_props] = parse_args (arg)
+function [X, Y, Z, lvl, patch_props] = parse_args (arg)
 
   patch_props = {};
   nolvl = false;
 
-  if (isinteger (arg{1}) && ishandle (arg{1})
-      && strncmpi (get (arg{1}, "type"), "axis", 4))
-    ax = arg{1};
-    arg{1} = [];
-  else
-    ax = gca ();
-  endif
-
   for n = 1:numel (arg)
     if (ischar (arg{n}))
       patch_props = arg(n:end);
       arg(n:end) = [];
       break;
     endif
   endfor
 
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -40,28 +40,18 @@
 ## [x, y, z] = cylinder (10:-1:0,50);
 ## surf (x, y, z);
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
-  nargs = nargin;
-  args = varargin;
-  ax = [];
-
-  if (nargs > 0 && isscalar (args{1}) && ishandle (args{1}))
-    if (! strcmp (get (args{1}, "type"), "axes"))
-      error ("cylinder: expecting first argument to be an axes object");
-    endif
-    ax = args{1};
-    nargs--;
-    args(1) = [];
-  endif
+  [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder", 
+					    varargin{:});
 
   if (nargs == 0)
     n = 20;
     r = [1, 1];
   elseif (nargs == 1)
     n = 20;
     r = args{1};
   elseif (nargs == 2)
@@ -82,15 +72,12 @@ function [xx, yy, zz] = cylinder (vararg
   r = r(idx);
   [x, y] = pol2cart (phi, r);
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
-    if (! isempty (ax))
-      axes (ax);
-    endif
-    surf (x, y, z);
+    surf (ax, x, y, z);
   endif
 
 endfunction
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -22,64 +22,44 @@
 ## @deftypefnx {Function File} {} fill (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} fill (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} = } fill (@dots{})
 ## Create one or more filled patch objects, returning a patch object for each.
 ## @end deftypefn
 
 function h = fill (varargin)
 
+  [h, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
   htmp = [];
-
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("fill: expecting first argument to be an axes object");
-    endif
-
-    iargs = __find_patches__ (varargin{:}) + 1;
-    oldh = gca ();
-    unwind_protect
-      axes (h);
+  iargs = __find_patches__ (varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
 
-      for i = 1 : length (iargs)
-	if (i == length (iargs))
-	  args = varargin (iargs(i):end);
-        else
-	  args = varargin (iargs(i):iargs(i+1)-1);
-	endif
-	newplot ();
-	[tmp, fail] = __patch__ (h, args{:});
-	if (fail)
-	  print_usage();
-	endif
-	htmp (end + 1) = tmp;
-      endfor
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    iargs = __find_patches__ (varargin{:});
     for i = 1 : length (iargs)
       if (i == length (iargs))
 	args = varargin (iargs(i):end);
       else
         args = varargin (iargs(i):iargs(i+1)-1);
       endif
       newplot ();
-      [tmp, fail] = __patch__ (gca (), args{:});
+      [tmp, fail] = __patch__ (h, args{:});
       if (fail)
 	print_usage();
       endif
       htmp (end + 1) = tmp;
     endfor
-  endif
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
+
   if (nargout > 0)
     h = htmp;
   endif
+
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
     iargs (end + 1) = i;
     if (ischar (varargin{i}) && (strcmp (tolower (varargin{i}), "faces") || 
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -30,59 +30,44 @@
 ## the minor grid.
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## PKG_ADD: mark_as_command grid
 
-function grid (x, y)
+function grid (varargin)
 
   persistent grid_on = false;
   persistent minor_on = false;
 
-  nargs = nargin;
-
-  if (nargs == 2)
-    if (ishandle (x))
-      ax = x;
-      x = y;
-      nargs--;
-      if (! strcmp (get (ax, "type"), "axes"))
-	error ("grid: expecting first argument to be an axes object");
-      endif
-    else
-      print_usage ();
-    endif
+  [ax, varargin, nargs] = __plt_get_axis_arg__ ("grid", varargin{:});
+  if (nargs > 1)
+    print_usage ();
+  elseif (nargs == 0)
+    grid_on = ! grid_on;
   else
-    ax = gca ();
-  endif
-
-  if (nargs == 0)
-    grid_on = ! grid_on;
-  elseif (nargs == 1)
+    x = varargin{1};
     if (ischar (x))
       if (strcmp ("off", x))
 	grid_on = false;
       elseif (strcmp ("on", x))
 	grid_on = true;
       elseif (strcmp ("minor", x))
 	minor_on = ! minor_on;
 	if (minor_on)
 	  grid_on = true;
 	endif
       else
 	print_usage ();
       endif
     else
       error ("grid: argument must be a string");
     endif
-  else
-    print_usage ();
   endif
 
   if (grid_on)
     set (ax, "xgrid", "on", "ygrid", "on", "zgrid", "on");
     if (minor_on)
       set (ax, "xminorgrid", "on", "yminorgrid", "on", "zminorgrid", "on");
     else
       set (ax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -24,39 +24,17 @@
 ## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
 ## columns of @var{z} correspond to different @var{x} values and rows of 
 ## @var{z} correspond to different @var{y} values.
 ## @seealso{meshgrid, mesh, contour}
 ## @end deftypefn
  
 function retval = meshz (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("meshz: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      tmp = __meshz__ (varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    tmp = __meshz__ (varargin{:});
-  endif
-
-  if (nargout > 0)
-    retval = tmp;
-  endif
-
-endfunction
-
-function h = __meshz__ (varargin)
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("meshz", varargin{:});
 
   ioff = nargin + 1;
   for i = 1 : nargin
     if (ischar (varargin{i}))
       ioff = i;
       break;
     endif
   endfor
@@ -90,11 +68,21 @@ function h = __meshz__ (varargin)
 	 y(end, 1), y(end, :), y(end, end)]; 
   endif
 
   zref = min(z(isfinite(z)));
   z = [zref .* ones(1, size(z, 2) + 2);
        zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1); 
        zref.* ones(1, size(z, 2) + 2)];
 
-  h = mesh (x, y, z, varargin{ioff:end});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    tmp = mesh (x, y, z, varargin{ioff:end});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
+
+  if (nargout > 0)
+    retval = tmp;
+  endif
 
 endfunction
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -31,31 +31,27 @@
 ## scalar value referring to the current colormap, or string value (for
 ## example, "r" or "red"). 
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = patch (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes") && ! strcmp (get (h, "type"), "hggroup"))
-      error ("patch: expecting first argument to be an axes or hggroup object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ancestor (h, "axes"));
-      [tmp, fail] = __patch__ (h, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    [tmp, fail] = __patch__ (gca (), varargin{:});
+  [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
+  oldh = gca ();
+  if (isnan(h))
+    h = oldh;
   endif
+  unwind_protect
+    axes (h);
+    [tmp, fail] = __patch__ (h, varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (fail)
     print_usage ();
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -39,36 +39,32 @@
 ## @seealso{bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie (varargin)
 
+  [h, varargin] = __plt_get_axis_arg__ ("pie", varargin{:});
+
   if (nargin < 1)
     print_usage ();
-  elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("pie: expecting first argument to be an axes object");
-    endif
+  else
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
-      tmp = __pie__ (h, varargin{2:end});
+      tmp = __pie__ (h, varargin{:});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
-  else
-    newplot ();
-    tmp = __pie__ (gca (), varargin{:});
   endif
 
+
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 function hlist = __pie__ (varargin)
 
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -173,31 +173,23 @@
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
 ## stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("plot: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __plt__ ("plot", h, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
+  [h, varargin] = __plt_get_axis_arg__ ("plot", varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
     newplot ();
-    tmp = __plt__ ("plot", gca (), varargin{:});
-  endif
+    tmp = __plt__ ("plot", h, varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -50,39 +50,29 @@
 ## ylabel (ax(1), "Axis 1");
 ## ylabel (ax(2), "Axis 2");
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [Ax, H1, H2] = plotyy (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin{1};
-    if (! strcmp (get (ax, "type"), "axes"))
-      error ("plotyy: expecting first argument to be an axes object");
-    endif
-    if (nargin < 5)
-      print_usage ();
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ax);
-      newplot ();
-      [ax, h1, h2] = __plotyy__ (ax, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    if (nargin < 4)
-      print_usage ();
-    endif
+  [ax, varargin] = __plt_get_axis_arg__ ("plotyy", varargin{:});
+
+  if (nargin < 4)
+    print_usage ();
+  endif
+  oldh = gca ();
+  unwind_protect
+    axes (ax);
     newplot ();
-    [ax, h1, h2] = __plotyy__ (gca (), varargin{:});
-  endif
+    [ax, h1, h2] = __plotyy__ (ax, varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (nargout > 0)
     Ax = ax;
     H1 = h1;
     H2 = h2;
   endif
 
 endfunction
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -25,17 +25,17 @@
 ## The optional third argument specifies the line type.
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("loglogerr", varargin{:});
+  [h, varargin] = __plt_get_axis_arg__ ("polar", varargin{:});
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     nargs = numel (varargin);
 
     if (nargs == 3)
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -53,34 +53,29 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{plot}
 ## @end deftypefn
 
 function retval = quiver (varargin)
 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("quiver", varargin{:});
+
   if (nargin < 2)
     print_usage ();
-  elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("quiver: expecting first argument to be an axes object");
-    endif
+  else
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
-      tmp = __quiver__ (h, 0, varargin{2:end});
+      tmp = __quiver__ (h, 0, varargin{:});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
-  else
-    newplot ();
-    tmp = __quiver__ (gca (), 0, varargin{:});
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -56,34 +56,29 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{plot}
 ## @end deftypefn
 
 function retval = quiver3 (varargin)
 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("quiver3", varargin{:});
+
   if (nargin < 2)
     print_usage ();
-  elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("quiver: expecting first argument to be an axes object");
-    endif
+  else
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
-      tmp = __quiver__ (h, 1, varargin{2:end});
+      tmp = __quiver__ (h, 1, varargin{:});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
-  else
-    newplot ();
-    tmp = __quiver__ (gca (), 1, varargin{:});
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -51,33 +51,28 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, patch, scatter3}
 ## @end deftypefn
 
 function retval = scatter (varargin)
 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("scatter", varargin{:});
+
   if (nargin < 2)
     print_usage ();
-  elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("scatter: expecting first argument to be an axes object");
-    endif
+  else
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
-      tmp = __scatter__ (h, 2, "scatter", varargin{2:end});
+      tmp = __scatter__ (h, 2, "scatter", varargin{:});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
-  else
-    newplot ();
-    tmp = __scatter__ (gca (), 2, "scatter", varargin{:});
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -50,34 +50,29 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, patch, scatter}
 ## @end deftypefn
 
 function retval = scatter3 (varargin)
 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("scatter3", varargin{:});
+
   if (nargin < 2)
     print_usage ();
-  elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("scatter3: expecting first argument to be an axes object");
-    endif
+  else
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
-      tmp = __scatter__ (h, 3, "scatter3", varargin{2:end});
+      tmp = __scatter__ (h, 3, "scatter3", varargin{:});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
-  else
-    newplot ();
-    tmp = __scatter__ (gca (), 3, "scatter3", varargin{:});
   endif
 
   if (! ishold ())
     set (get (tmp, "parent"), "view", [-37.5, 30]);
   endif
 
   if (nargout > 0)
     retval = tmp;
diff --git a/scripts/plot/sphere.m b/scripts/plot/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/sphere.m
@@ -24,29 +24,24 @@
 ## omitted then a default value of 20 is assumed.
 ##
 ## Called with no return arguments, @code{sphere} call directly 
 ## @code{surf (@var{x}, @var{y}, @var{z})}. If an axes handle is passed
 ## as the first argument, the the surface is plotted to this set of axes.
 ## @seealso{peaks}
 ## @end deftypefn
 
-function [xx, yy, zz] = sphere (h, n)
+function [xx, yy, zz] = sphere (varargin)
 
-  have_h = false;
-  if (nargin > 1 && isscalar (h) && ishandle (h))
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("sphere: expecting first argument to be an axes object");
-    endif
-    if (nargin == 1)
-      n = 20;
-    endif
-    have_h = true;
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "sphere", 
+						varargin{:});
+  if (nargin > 1)
+    print_usage ();
   elseif (nargin == 1)
-    n = h;
+    n = varargin{1};
   else
     n = 20;
   endif
 
   theta = linspace (0, 2*pi, n+1);
   phi = linspace (-pi/2, pi/2, n+1);
   [theta,phi] = meshgrid (theta, phi);
 
@@ -54,22 +49,12 @@ function [xx, yy, zz] = sphere (h, n)
   y = cos (phi) .* sin (theta);
   z = sin (phi);
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
-    if (have_h)
-      oldh = gca ();
-      unwind_protect
-	axes (h);
-	surf (x, y, z);
-      unwind_protect_cleanup
-	axes (oldh);
-      end_unwind_protect
-    else
-      surf (x, y, z);
-    endif
+    surf (h, x, y, z);
   endif
 
 endfunction
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -26,24 +26,29 @@
 ## to different @var{y} values.
 ## @seealso{mesh, surface}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function h = surf (varargin)
 
-  newplot ();
+  [h, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
 
-  tmp = surface (varargin{:});
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    newplot ();
+    tmp = surface (varargin{:});
 
-  ax = get (tmp, "parent");
-
-  set (tmp, "facecolor", "flat");
-  if (! ishold ())
-    set (ax, "view", [-37.5, 30]);
-  endif
+    set (tmp, "facecolor", "flat");
+    if (! ishold ())
+      set (h, "view", [-37.5, 30]);
+    endif
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -36,31 +36,25 @@
 ## Any additional properties passed are assigned the the surface..
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = surface (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("surface: expecting first argument to be an axes object");
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      [tmp, bad_usage] = __surface__ (h, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    [tmp, bad_usage] = __surface__ (gca (), varargin{:});
-  endif
+  [h, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
+
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    [tmp, bad_usage] = __surface__ (h, varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
 
   if (bad_usage)
     print_usage ();
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -44,64 +44,37 @@
 ## An example of the use of @code{surfnorm} is
 ##
 ## @example
 ## surfnorm (peaks (25));
 ## @end example
 ## @seealso{surf, quiver3}
 ## @end deftypefn
 
-function varargout = surfnorm (varargin)
+function [Nx, Ny, Nz] = surfnorm (varargin)
 
-  if (nargout > 0)
-    varargout = cell (nargout, 1);
-  else
-    varargout = cell (0, 0);
-  endif
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
-      error ("surfnorm: expecting first argument to be an axes object");
-    endif
-    if (nargin != 2 && nargin != 4)
-      print_usage ();
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      [varargout{:}] = __surfnorm__ (h, varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    if (nargin != 1 && nargin != 3)
-      print_usage ();
-    endif
-    [varargout{:}] = __surfnorm__ (gca (), varargin{:});
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout != 0), "surfnorm", 
+						varargin{:});
+
+  if (nargin != 1 && nargin != 3)
+    print_usage ();
   endif
 
-endfunction
-
-function [Nx, Ny, Nz] = __surfnorm__ (h, varargin)
-
-  if (nargin == 2)
+  if (nargin == 1)
     z = varargin{1};
     [x, y] = meshgrid (1:size(z,1), 1:size(z,2));
     ioff = 2;
   else
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     ioff = 4;
   endif
 
   if (nargout == 0)
-    newplot ();
-    surf (x, y, z, varargin{ioff:end});
-    hold on;
   endif
 
   ## Make life easier, and avoid having to do the extrapolation later, do
   ## a simpler linear extrapolation here. This is approximative, and works
   ## badly for closed surfaces like spheres.
   xx = [2 .* x(:,1) - x(:,2), x, 2 .* x(:,end) - x(:,end-1)];
   xx = [2 .* xx(1,:) - xx(2,:); xx; 2 .* xx(end,:) - xx(end-1,:)];
   yy = [2 .* y(:,1) - y(:,2), y, 2 .* y(:,end) - y(:,end-1)];
@@ -131,20 +104,29 @@ function [Nx, Ny, Nz] = __surfnorm__ (h,
 
   ## Normalize the normal vectors
   len = sqrt (nx.^2 + ny.^2 + nz.^2);
   nx = nx ./ len;
   ny = ny ./ len;
   nz = nz ./ len;
 
   if (nargout == 0)
-    plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
-	   [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
-	   [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:), 
-	   varargin{ioff:end});
+    oldh = gca ();
+    unwind_protect
+      axes (h);
+      newplot ();
+      surf (x, y, z, varargin{ioff:end});
+      hold on;
+      plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
+	     [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
+	     [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:), 
+	     varargin{ioff:end});
+    unwind_protect_cleanup
+      axes (oldh);
+    end_unwind_protect
   else
     Nx = nx;
     Ny = ny;
     Nz = nz;
   endif
 endfunction
 
 %!demo
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -25,37 +25,29 @@
 ## Specify x, y, and z axis labels for the current figure. If @var{h} is
 ## specified then label the axis defined by @var{h}.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs,  ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
-function h = xlabel (varargin)
+function retval = xlabel (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin{1};
-    if (! strcmp (get (ax, "type"), "axes"))
-      error ("xlabel: expecting first argument to be an axes object");
-    endif
-    if (rem (nargin, 2) == 1)
-      print_usage ();
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ax);
-      tmp = __axis_label__ ("xlabel", varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    if (rem (nargin, 2) != 1)
-      print_usage ();
-    endif
-    tmp = __axis_label__ ("xlabel", varargin{1:end});
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
+
+  if (rem (nargin, 2) != 1)
+    print_usage ();
   endif
 
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    tmp = __axis_label__ ("xlabel", varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
+
   if (nargout > 0)
-    h = tmp;
+    retval = h;
   endif
 
 endfunction
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -20,37 +20,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{h}, @var{string})
 ## See xlabel.
 ## @end deftypefn
 
 ## Author: jwe
 
-function h = ylabel (varargin)
+function retval = ylabel (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin{1};
-    if (! strcmp (get (ax, "type"), "axes"))
-      error ("ylabel: expecting first argument to be an axes object");
-    endif
-    if (rem (nargin, 2) == 1)
-      print_usage ();
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ax);
-      tmp = __axis_label__ ("ylabel", varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    if (rem (nargin, 2) != 1)
-      print_usage ();
-    endif
-    tmp = __axis_label__ ("ylabel", varargin{1:end});
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
+
+  if (rem (nargin, 2) != 1)
+    print_usage ();
   endif
 
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    tmp = __axis_label__ ("ylabel", varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
+
   if (nargout > 0)
-    h = tmp;
+    retval = h;
   endif
 
 endfunction
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -20,37 +20,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} zlabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{h}, @var{string})
 ## See xlabel.
 ## @end deftypefn
 
 ## Author: jwe
 
-function h = zlabel (varargin)
+function retval = zlabel (varargin)
 
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin{1};
-    if (! strcmp (get (ax, "type"), "axes"))
-      error ("zlabel: expecting first argument to be an axes object");
-    endif
-    if (rem (nargin, 2) == 1)
-      print_usage ();
-    endif
-    oldh = gca ();
-    unwind_protect
-      axes (ax);
-      tmp = __axis_label__ ("zlabel", varargin{2:end});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
-  else
-    if (rem (nargin, 2) != 1)
-      print_usage ();
-    endif
-    tmp = __axis_label__ ("zlabel", varargin{1:end});
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
+
+  if (rem (nargin, 2) != 1)
+    print_usage ();
   endif
 
+  oldh = gca ();
+  unwind_protect
+    axes (h);
+    tmp = __axis_label__ ("zlabel", varargin{:});
+  unwind_protect_cleanup
+    axes (oldh);
+  end_unwind_protect
+
   if (nargout > 0)
-    h = tmp;
+    retval = h;
   endif
 
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,23 @@
+2007-11-29  John W. Eaton  <jwe@octave.org>
+
+	* pr-output.cc (octave_print_internal_template (std::ostream&,
+	const octave_int<T>&, bool)): Rename from octave_print_internal.
+	(PRINT_INT_SCALAR_INTERNAL): New macro.  Use it to define
+	non-template functions for printing scalar octave_int values.
+	(octave_print_internal_template (std::ostream&, const intNDArray<T>&,
+	bool, int)): Rename from octave_print_internal.
+	(PRINT_INT_ARRAY_INTERNAL): New macro.  Use it to define
+	non-template functions for printing scalar octave_int values.
+	* pr-output.h: Declare non-template functions for printing
+	octave_int scalar and array values.
+	Delete declarations of template funtions for printing octave_int
+	scalar and array values.
+
 2007-11-28  John W. Eaton  <jwe@octave.org>
 
 	* graphics.cc (base_properties::update_axis_limits,
 	axes::update_axis_limits): New functions.
 	* graphics.h.in (class data_property): New class.
 	(graphics_object::update_axis_limits): New function.
 	(base_graphics_object::update_axis_limits): New virtual function.
 	(base_properties::update_axis_limits, axes::update_axis_limits):
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2391,28 +2391,86 @@ INSTANTIATE_ABS(long long);
   }
 
 SPECIALIZE_UABS(char)
 SPECIALIZE_UABS(short)
 SPECIALIZE_UABS(int)
 SPECIALIZE_UABS(long)
 SPECIALIZE_UABS(long long)
 
+template void
+pr_int (std::ostream&, const octave_int8&, int);
+
+template void
+pr_int (std::ostream&, const octave_int16&, int);
+
+template void
+pr_int (std::ostream&, const octave_int32&, int);
+
+template void
+pr_int (std::ostream&, const octave_int64&, int);
+
+template void
+pr_int (std::ostream&, const octave_uint8&, int);
+
+template void
+pr_int (std::ostream&, const octave_uint16&, int);
+
+template void
+pr_int (std::ostream&, const octave_uint32&, int);
+
+template void
+pr_int (std::ostream&, const octave_uint64&, int);
+
 template <class T>
 void
-octave_print_internal (std::ostream& os, const intNDArray<T>& nda,
-		       bool pr_as_read_syntax, int extra_indent)
+octave_print_internal_template (std::ostream& os, const octave_int<T>& val,
+				bool)
+{
+  if (plus_format)
+    {
+      pr_plus_format (os, val);
+    }
+  else
+    {
+      if (free_format)
+	os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
+      else
+	pr_int (os, val);
+    }
+}
+
+#define PRINT_INT_SCALAR_INTERNAL(TYPE) \
+  OCTINTERP_API void \
+  octave_print_internal (std::ostream& os, const octave_int<TYPE>& val, bool dummy) \
+  { \
+    octave_print_internal_template (os, val, dummy); \
+  }
+
+PRINT_INT_SCALAR_INTERNAL (int8_t)
+PRINT_INT_SCALAR_INTERNAL (uint8_t)
+PRINT_INT_SCALAR_INTERNAL (int16_t)
+PRINT_INT_SCALAR_INTERNAL (uint16_t)
+PRINT_INT_SCALAR_INTERNAL (int32_t)
+PRINT_INT_SCALAR_INTERNAL (uint32_t)
+PRINT_INT_SCALAR_INTERNAL (int64_t)
+PRINT_INT_SCALAR_INTERNAL (uint64_t)
+
+template <class T>
+/* static */ inline void
+octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
+				bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
-    octave_print_internal (os, nda (0), pr_as_read_syntax);
+    octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
       Array<octave_idx_type> ra_idx (ndims, 0);
 
       dim_vector dims = nda.dims ();
 
@@ -2613,116 +2671,32 @@ octave_print_internal (std::ostream& os,
 	    {
 	      os << "\n";
 	      increment_index (ra_idx, dims, 2);
 	    }
 	}
     }
 }
 
-// FIXME -- this is not the right spot for this...
-
-template void
-pr_int (std::ostream&, const octave_int8&, int);
-
-template void
-pr_int (std::ostream&, const octave_int16&, int);
-
-template void
-pr_int (std::ostream&, const octave_int32&, int);
-
-template void
-pr_int (std::ostream&, const octave_int64&, int);
-
-template void
-pr_int (std::ostream&, const octave_uint8&, int);
-
-template void
-pr_int (std::ostream&, const octave_uint16&, int);
-
-template void
-pr_int (std::ostream&, const octave_uint32&, int);
-
-template void
-pr_int (std::ostream&, const octave_uint64&, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_int8>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_int16>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_int32>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_int64>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_uint8>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_uint16>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_uint32>&,
-		       bool, int);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const intNDArray<octave_uint64>&,
-		       bool, int);
-
-template <class T>
-void
-octave_print_internal (std::ostream& os, const octave_int<T>& val, bool)
-{
-  if (plus_format)
-    {
-      pr_plus_format (os, val);
-    }
-  else
-    {
-      if (free_format)
-	os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
-      else
-	pr_int (os, val);
-    }
-}
-
-// FIXME -- this is not the right spot for this...
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_int8&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_int16&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_int32&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_int64&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_uint8&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_uint16&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_uint32&, bool);
-
-template OCTINTERP_API void
-octave_print_internal (std::ostream&, const octave_uint64&, bool);
+#define PRINT_INT_ARRAY_INTERNAL(TYPE) \
+  OCTINTERP_API void \
+  octave_print_internal (std::ostream& os, const intNDArray<TYPE>& nda, \
+			 bool pr_as_read_syntax, int extra_indent) \
+  { \
+    octave_print_internal_template (os, nda, pr_as_read_syntax, extra_indent); \
+  }
+
+PRINT_INT_ARRAY_INTERNAL (octave_int8)
+PRINT_INT_ARRAY_INTERNAL (octave_uint8)
+PRINT_INT_ARRAY_INTERNAL (octave_int16)
+PRINT_INT_ARRAY_INTERNAL (octave_uint16)
+PRINT_INT_ARRAY_INTERNAL (octave_int32)
+PRINT_INT_ARRAY_INTERNAL (octave_uint32)
+PRINT_INT_ARRAY_INTERNAL (octave_int64)
+PRINT_INT_ARRAY_INTERNAL (octave_uint64)
 
 extern void
 octave_print_internal (std::ostream&, const Cell&, bool, int, bool)
 {
   panic_impossible ();
 }
 
 DEFUN (rats, args, nargout,
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -103,25 +103,86 @@ octave_print_internal (std::ostream& os,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const ArrayN<std::string>& sa,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
-template <class T>
-extern void
-octave_print_internal (std::ostream& os, const intNDArray<T>& sa,
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_int8>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_uint8>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_int16>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_uint16>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_int32>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_uint32>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_int64>& sa,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
-template <class T>
-extern void
-octave_print_internal (std::ostream& os, const octave_int<T>& sa,
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const intNDArray<octave_uint64>& sa,
+		       bool pr_as_read_syntax = false,
+		       int extra_indent = 0);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<int8_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<uint8_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<int16_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<uint16_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<int32_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<uint32_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<int64_t>& sa,
+		       bool pr_as_read_syntax = false);
+
+extern OCTINTERP_API void
+octave_print_internal (std::ostream& os, const octave_int<uint64_t>& sa,
 		       bool pr_as_read_syntax = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const Cell& cell,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
