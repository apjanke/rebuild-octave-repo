# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1520452563 18000
#      Wed Mar 07 14:56:03 2018 -0500
# Node ID 7620f1f5290dd6834d1929d493c3c6ae4e913fba
# Parent  578ebece3dc70f3725e159de8e3a7988c256027e
use m_ prefix for member variables in parse tree classes

* pt-arg-list.cc, pt-arg-list.h, pt-assign.cc, pt-assign.h,
pt-binop.cc, pt-binop.h, pt-bp.cc, pt-bp.h, pt-cbinop.cc, pt-cbinop.h,
pt-check.cc, pt-check.h, pt-classdef.cc, pt-classdef.h, pt-cmd.h,
pt-colon.cc, pt-colon.h, pt-const.cc, pt-const.h, pt-decl.cc,
pt-decl.h, pt-except.cc, pt-except.h, pt-fcn-handle.cc,
pt-fcn-handle.h, pt-funcall.cc, pt-funcall.h, pt-id.cc, pt-id.h,
pt-idx.cc, pt-idx.h, pt-jit.cc, pt-jit.h, pt-loop.cc, pt-loop.h,
pt-misc.h, pt-pr-code.cc, pt-pr-code.h, pt-select.cc, pt-select.h,
pt-stmt.cc, pt-stmt.h, pt-tm-const.cc, pt-tm-const.h, pt.cc, pt.h:
Use m_ prefix for member variables in parse tree classes.
Style fixes.

diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -71,23 +71,23 @@ namespace octave
     return false;
   }
 
   void
   tree_argument_list::append (const element_type& s)
   {
     base_list<tree_expression *>::append (s);
 
-    if (! list_includes_magic_end && s && s->has_magic_end ())
-      list_includes_magic_end = true;
+    if (! m_list_includes_magic_end && s && s->has_magic_end ())
+      m_list_includes_magic_end = true;
 
-    if (! list_includes_magic_tilde && s && s->is_identifier ())
+    if (! m_list_includes_magic_tilde && s && s->is_identifier ())
       {
         tree_identifier *id = dynamic_cast<tree_identifier *> (s);
-        list_includes_magic_tilde = id && id->is_black_hole ();
+        m_list_includes_magic_tilde = id && id->is_black_hole ();
       }
   }
 
   bool
   tree_argument_list::all_elements_are_constant (void) const
   {
     for (const tree_expression *elt : *this)
       {
@@ -114,16 +114,18 @@ namespace octave
             break;
           }
       }
 
     return retval;
   }
 }
 
+// FIXME: Is there a way to do this job without global data?
+
 static const octave_value *indexed_object = nullptr;
 static int index_position = 0;
 static int num_indices = 0;
 
 // END is documented in op-kw-docs.
 DEFCONSTMETHOD (end, interp, , ,
                 doc: /* -*- texinfo -*-
 @deftypefn {} {} end
@@ -206,17 +208,17 @@ namespace octave
 {
   octave_value_list
   tree_argument_list::convert_to_const_vector (tree_evaluator *tw,
                                                const octave_value *object)
   {
     // END doesn't make sense for functions.  Maybe we need a different
     // way of asking an octave_value object this question?
 
-    bool stash_object = (list_includes_magic_end
+    bool stash_object = (m_list_includes_magic_end
                          && object
                          && ! (object->is_function ()
                                || object->is_function_handle ()));
 
     unwind_protect frame;
 
     if (stash_object)
       {
@@ -302,17 +304,17 @@ namespace octave
     return retval;
   }
 
   tree_argument_list *
   tree_argument_list::dup (symbol_scope& scope) const
   {
     tree_argument_list *new_list = new tree_argument_list ();
 
-    new_list->list_includes_magic_end = list_includes_magic_end;
-    new_list->simple_assign_lhs = simple_assign_lhs;
+    new_list->m_list_includes_magic_end = m_list_includes_magic_end;
+    new_list->m_simple_assign_lhs = m_simple_assign_lhs;
 
     for (const tree_expression *elt : *this)
       new_list->append (elt ? elt->dup (scope) : nullptr);
 
     return new_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -46,50 +46,50 @@ namespace octave
 
   class tree_argument_list : public base_list<tree_expression *>
   {
   public:
 
     typedef tree_expression* element_type;
 
     tree_argument_list (void)
-      : list_includes_magic_end (false), list_includes_magic_tilde (false),
-        simple_assign_lhs (false) { }
+      : m_list_includes_magic_end (false), m_list_includes_magic_tilde (false),
+        m_simple_assign_lhs (false) { }
 
     tree_argument_list (tree_expression *t)
-      : list_includes_magic_end (false), list_includes_magic_tilde (false),
-        simple_assign_lhs (false)
+      : m_list_includes_magic_end (false), m_list_includes_magic_tilde (false),
+        m_simple_assign_lhs (false)
     { append (t); }
 
     // No copying!
 
     tree_argument_list (const tree_argument_list&) = delete;
 
     tree_argument_list& operator = (const tree_argument_list&) = delete;
 
     ~tree_argument_list (void);
 
     bool has_magic_end (void) const;
 
     bool has_magic_tilde (void) const
-    { return list_includes_magic_tilde; }
+    { return m_list_includes_magic_tilde; }
 
     tree_expression * remove_front (void)
     {
       iterator p = begin ();
       tree_expression *retval = *p;
       erase (p);
       return retval;
     }
 
     void append (const element_type& s);
 
-    void mark_as_simple_assign_lhs (void) { simple_assign_lhs = true; }
+    void mark_as_simple_assign_lhs (void) { m_simple_assign_lhs = true; }
 
-    bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
+    bool is_simple_assign_lhs (void) { return m_simple_assign_lhs; }
 
     bool all_elements_are_constant (void) const;
 
     bool is_valid_lvalue_list (void) const;
 
     octave_value_list
     convert_to_const_vector (tree_evaluator *tw,
                              const octave_value *object = nullptr);
@@ -102,21 +102,21 @@ namespace octave
 
     void accept (tree_walker& tw)
     {
       tw.visit_argument_list (*this);
     }
 
   private:
 
-    bool list_includes_magic_end;
+    bool m_list_includes_magic_end;
 
-    bool list_includes_magic_tilde;
+    bool m_list_includes_magic_tilde;
 
-    bool simple_assign_lhs;
+    bool m_simple_assign_lhs;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 // tree_argument_list is derived from a template.
 
 #endif
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -31,63 +31,65 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-assign.h"
 
 namespace octave
 {
   // Simple assignment expressions.
 
-  tree_simple_assignment::tree_simple_assignment
-  (tree_expression *le, tree_expression *re,
-   bool plhs, int l, int c, octave_value::assign_op t)
-    : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t)
+  tree_simple_assignment::tree_simple_assignment (tree_expression *le,
+                                                  tree_expression *re,
+                                                  bool plhs, int l, int c,
+                                                  octave_value::assign_op t)
+    : tree_expression (l, c), m_lhs (le), m_rhs (re), m_preserve (plhs),
+      m_etype (t)
   { }
 
   tree_simple_assignment::~tree_simple_assignment (void)
   {
-    if (! preserve)
-      delete lhs;
+    if (! m_preserve)
+      delete m_lhs;
 
-    delete rhs;
+    delete m_rhs;
   }
 
   std::string
   tree_simple_assignment::oper (void) const
   {
-    return octave_value::assign_op_as_string (etype);
+    return octave_value::assign_op_as_string (m_etype);
   }
 
   tree_expression *
   tree_simple_assignment::dup (symbol_scope& scope) const
   {
     tree_simple_assignment *new_sa
-      = new tree_simple_assignment (lhs ? lhs->dup (scope) : nullptr,
-                                    rhs ? rhs->dup (scope) : nullptr,
-                                    preserve, etype);
+      = new tree_simple_assignment (m_lhs ? m_lhs->dup (scope) : nullptr,
+                                    m_rhs ? m_rhs->dup (scope) : nullptr,
+                                    m_preserve, m_etype);
 
     new_sa->copy_base (*this);
 
     return new_sa;
   }
 
   // Multi-valued assignment expressions.
 
-  tree_multi_assignment::tree_multi_assignment
-  (tree_argument_list *lst, tree_expression *r,
-   bool plhs, int l, int c)
-    : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
+  tree_multi_assignment::tree_multi_assignment (tree_argument_list *lst,
+                                                tree_expression *r,
+                                                bool plhs, int l, int c)
+    : tree_expression (l, c), m_lhs (lst), m_rhs (r), m_preserve (plhs)
   { }
 
   tree_multi_assignment::~tree_multi_assignment (void)
   {
-    if (! preserve)
-      delete lhs;
+    if (! m_preserve)
+      delete m_lhs;
 
-    delete rhs;
+    delete m_rhs;
   }
 
   std::string
   tree_multi_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (op_type ());
   }
 
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -44,128 +44,135 @@ namespace octave
   // Simple assignment expressions.
 
   class tree_simple_assignment : public tree_expression
   {
   public:
 
     tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
                             octave_value::assign_op t = octave_value::op_asn_eq)
-      : tree_expression (l, c), lhs (nullptr), rhs (nullptr), preserve (plhs),
-        ans_ass (), etype (t) { }
+      : tree_expression (l, c), m_lhs (nullptr), m_rhs (nullptr),
+        m_preserve (plhs), m_ans_assign (), m_etype (t)
+    { }
 
     tree_simple_assignment (tree_expression *le, tree_expression *re,
                             bool plhs = false, int l = -1, int c = -1,
                             octave_value::assign_op t = octave_value::op_asn_eq);
 
     // No copying!
 
     tree_simple_assignment (const tree_simple_assignment&) = delete;
 
     tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
 
     ~tree_simple_assignment (void);
 
-    bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
+    bool has_magic_end (void) const { return (m_rhs && m_rhs->has_magic_end ()); }
 
     bool rvalue_ok (void) const { return true; }
 
     bool is_assignment_expression (void) const { return true; }
 
     std::string oper (void) const;
 
-    tree_expression * left_hand_side (void) { return lhs; }
+    tree_expression * left_hand_side (void) { return m_lhs; }
 
-    tree_expression * right_hand_side (void) { return rhs; }
+    tree_expression * right_hand_side (void) { return m_rhs; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_assignment (*this);
     }
 
-    octave_value::assign_op op_type (void) const { return etype; }
+    octave_value::assign_op op_type (void) const { return m_etype; }
 
   private:
 
     void do_assign (octave_lvalue& ult, const octave_value_list& args,
                     const octave_value& rhs_val);
 
     void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
 
     // The left hand side of the assignment.
-    tree_expression *lhs;
+    tree_expression *m_lhs;
 
     // The right hand side of the assignment.
-    tree_expression *rhs;
+    tree_expression *m_rhs;
 
     // True if we should not delete the lhs.
-    bool preserve;
+    bool m_preserve;
 
     // True if this is an assignment to the automatic variable ans.
-    bool ans_ass;
+    bool m_ans_assign;
 
     // The type of the expression.
-    octave_value::assign_op etype;
+    octave_value::assign_op m_etype;
   };
 
   // Multi-valued assignment expressions.
 
   class tree_multi_assignment : public tree_expression
   {
   public:
 
     tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
-      : tree_expression (l, c), lhs (nullptr), rhs (nullptr), preserve (plhs)
-      { }
+      : tree_expression (l, c), m_lhs (nullptr), m_rhs (nullptr),
+        m_preserve (plhs)
+    { }
 
     tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
                            bool plhs = false, int l = -1, int c = -1);
 
     // No copying!
 
     tree_multi_assignment (const tree_multi_assignment&) = delete;
 
     tree_multi_assignment& operator = (const tree_multi_assignment&) = delete;
 
     ~tree_multi_assignment (void);
 
-    bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
+    bool has_magic_end (void) const
+    {
+      return (m_rhs && m_rhs->has_magic_end ());
+    }
 
     bool is_assignment_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
-    tree_argument_list * left_hand_side (void) { return lhs; }
+    tree_argument_list * left_hand_side (void) { return m_lhs; }
 
-    tree_expression * right_hand_side (void) { return rhs; }
+    tree_expression * right_hand_side (void) { return m_rhs; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_multi_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const
-    { return octave_value::op_asn_eq; }
+    {
+      return octave_value::op_asn_eq;
+    }
 
   private:
 
     // The left hand side of the assignment.
-    tree_argument_list *lhs;
+    tree_argument_list *m_lhs;
 
     // The right hand side of the assignment.
-    tree_expression *rhs;
+    tree_expression *m_rhs;
 
     // True if we should not delete the lhs.
-    bool preserve;
+    bool m_preserve;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_simple_assignment' instead")
 typedef octave::tree_simple_assignment tree_simple_assignment;
 
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -35,46 +35,46 @@ namespace octave
 
   void
   tree_binary_expression::matlab_style_short_circuit_warning (const char *op)
   {
     warning_with_id ("Octave:possible-matlab-short-circuit-operator",
                      "Matlab-style short-circuit operation performed for operator %s",
                      op);
 
-    braindead_shortcircuit_warning_issued = true;
+    m_braindead_shortcircuit_warning_issued = true;
   }
 
   std::string
   tree_binary_expression::oper (void) const
   {
-    return octave_value::binary_op_as_string (etype);
+    return octave_value::binary_op_as_string (m_etype);
   }
 
   tree_expression *
   tree_binary_expression::dup (symbol_scope& scope) const
   {
     tree_binary_expression *new_be
-      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
-                                    op_rhs ? op_rhs->dup (scope) : nullptr,
-                                    line (), column (), etype);
+      = new tree_binary_expression (m_lhs ? m_lhs->dup (scope) : nullptr,
+                                    m_rhs ? m_rhs->dup (scope) : nullptr,
+                                    line (), column (), m_etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 
   // Boolean expressions.
 
   std::string
   tree_boolean_expression::oper (void) const
   {
     std::string retval = "<unknown>";
 
-    switch (etype)
+    switch (m_etype)
       {
       case bool_and:
         retval = "&&";
         break;
 
       case bool_or:
         retval = "||";
         break;
@@ -85,17 +85,17 @@ namespace octave
 
     return retval;
   }
 
   tree_expression *
   tree_boolean_expression::dup (symbol_scope& scope) const
   {
     tree_boolean_expression *new_be
-      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
-                                     op_rhs ? op_rhs->dup (scope) : nullptr,
-                                     line (), column (), etype);
+      = new tree_boolean_expression (m_lhs ? m_lhs->dup (scope) : nullptr,
+                                     m_rhs ? m_rhs->dup (scope) : nullptr,
+                                     line (), column (), m_etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 }
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -42,151 +42,151 @@ namespace octave
 
   class tree_binary_expression : public tree_expression
   {
   public:
 
     tree_binary_expression (int l = -1, int c = -1,
                             octave_value::binary_op t
                             = octave_value::unknown_binary_op)
-      : tree_expression (l, c), op_lhs (nullptr), op_rhs (nullptr), etype (t),
-        eligible_for_braindead_shortcircuit (false),
-        braindead_shortcircuit_warning_issued (false) { }
+      : tree_expression (l, c), m_lhs (nullptr), m_rhs (nullptr), m_etype (t),
+        m_eligible_for_braindead_shortcircuit (false),
+        m_braindead_shortcircuit_warning_issued (false) { }
 
     tree_binary_expression (tree_expression *a, tree_expression *b,
                             int l = -1, int c = -1,
                             octave_value::binary_op t
                             = octave_value::unknown_binary_op)
-      : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
-        eligible_for_braindead_shortcircuit (false),
-        braindead_shortcircuit_warning_issued (false) { }
+      : tree_expression (l, c), m_lhs (a), m_rhs (b), m_etype (t),
+        m_eligible_for_braindead_shortcircuit (false),
+        m_braindead_shortcircuit_warning_issued (false) { }
 
     // No copying!
 
     tree_binary_expression (const tree_binary_expression&) = delete;
 
     tree_binary_expression& operator = (const tree_binary_expression&) = delete;
 
     ~tree_binary_expression (void)
     {
-      delete op_lhs;
-      delete op_rhs;
+      delete m_lhs;
+      delete m_rhs;
     }
 
     void mark_braindead_shortcircuit (void)
     {
-      if (etype == octave_value::op_el_and || etype == octave_value::op_el_or)
+      if (m_etype == octave_value::op_el_and || m_etype == octave_value::op_el_or)
         {
-          eligible_for_braindead_shortcircuit = true;
+          m_eligible_for_braindead_shortcircuit = true;
 
-          op_lhs->mark_braindead_shortcircuit ();
-          op_rhs->mark_braindead_shortcircuit ();
+          m_lhs->mark_braindead_shortcircuit ();
+          m_rhs->mark_braindead_shortcircuit ();
         }
     }
 
     bool has_magic_end (void) const
     {
-      return ((op_lhs && op_lhs->has_magic_end ())
-              || (op_rhs && op_rhs->has_magic_end ()));
+      return ((m_lhs && m_lhs->has_magic_end ())
+              || (m_rhs && m_rhs->has_magic_end ()));
     }
 
     bool is_binary_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
-    octave_value::binary_op op_type (void) const { return etype; }
+    octave_value::binary_op op_type (void) const { return m_etype; }
 
-    tree_expression * lhs (void) { return op_lhs; }
-    tree_expression * rhs (void) { return op_rhs; }
+    tree_expression * lhs (void) { return m_lhs; }
+    tree_expression * rhs (void) { return m_rhs; }
 
     bool is_eligible_for_braindead_shortcircuit (void) const
     {
-      return eligible_for_braindead_shortcircuit;
+      return m_eligible_for_braindead_shortcircuit;
     }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_binary_expression (*this);
     }
 
     std::string profiler_name (void) const { return "binary " + oper (); }
 
     void matlab_style_short_circuit_warning (const char *op);
 
   protected:
 
     // The operands for the expression.
-    tree_expression *op_lhs;
-    tree_expression *op_rhs;
+    tree_expression *m_lhs;
+    tree_expression *m_rhs;
 
   private:
 
     // The type of the expression.
-    octave_value::binary_op etype;
+    octave_value::binary_op m_etype;
 
     // TRUE if this is an | or & expression in the condition of an IF
     // or WHILE statement.
-    bool eligible_for_braindead_shortcircuit;
+    bool m_eligible_for_braindead_shortcircuit;
 
     // TRUE if we have already issued a warning about short circuiting
     // for this operator.
-    bool braindead_shortcircuit_warning_issued;
+    bool m_braindead_shortcircuit_warning_issued;
   };
 
   // Boolean expressions.
 
   class tree_boolean_expression : public tree_binary_expression
   {
   public:
 
     enum type
       {
         unknown,
         bool_and,
         bool_or
       };
 
     tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
-      : tree_binary_expression (l, c), etype (t) { }
+      : tree_binary_expression (l, c), m_etype (t) { }
 
     tree_boolean_expression (tree_expression *a, tree_expression *b,
                              int l = -1, int c = -1, type t = unknown)
-      : tree_binary_expression (a, b, l, c), etype (t) { }
+      : tree_binary_expression (a, b, l, c), m_etype (t) { }
 
     // No copying!
 
     tree_boolean_expression (const tree_boolean_expression&) = delete;
 
     tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
 
     ~tree_boolean_expression (void) = default;
 
     bool is_boolean_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
-    type op_type (void) const { return etype; }
+    type op_type (void) const { return m_etype; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_boolean_expression (*this);
     }
 
   private:
 
     // The type of the expression.
-    type etype;
+    type m_etype;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_binary_expression' instead")
 typedef octave::tree_binary_expression tree_binary_expression;
 
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -32,41 +32,41 @@ namespace octave
 {
   // TRUE means SIGINT should put us in the debugger at the next
   // available breakpoint.
   bool octave_debug_on_interrupt_state = false;
 
   void
   tree_breakpoint::visit_while_command (tree_while_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
 
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *lst = cmd.body ();
 
         if (lst)
           lst->accept (*this);
       }
   }
 
   void
   tree_breakpoint::visit_do_until_command (tree_do_until_command& cmd)
   {
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *lst = cmd.body ();
 
         if (lst)
           lst->accept (*this);
 
-        if (! found)
+        if (! m_found)
           {
-            if (cmd.line () >= line)
+            if (cmd.line () >= m_line)
               take_action (cmd);
           }
       }
   }
 
   void
   tree_breakpoint::visit_argument_list (tree_argument_list&)
   {
@@ -77,37 +77,37 @@ namespace octave
   tree_breakpoint::visit_binary_expression (tree_binary_expression&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_break_command (tree_break_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
   }
 
   void
   tree_breakpoint::visit_colon_expression (tree_colon_expression&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_continue_command (tree_continue_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
   }
 
   void
   tree_breakpoint::visit_decl_command (tree_decl_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
   }
 
   void
   tree_breakpoint::visit_decl_init_list (tree_decl_init_list&)
   {
     panic_impossible ();
   }
@@ -116,35 +116,35 @@ namespace octave
   tree_breakpoint::visit_decl_elt (tree_decl_elt&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_simple_for_command (tree_simple_for_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
 
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *lst = cmd.body ();
 
         if (lst)
           lst->accept (*this);
       }
   }
 
   void
   tree_breakpoint::visit_complex_for_command (tree_complex_for_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
 
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *lst = cmd.body ();
 
         if (lst)
           lst->accept (*this);
       }
   }
 
@@ -210,28 +210,28 @@ namespace octave
       lst->accept (*this);
   }
 
   void
   tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
   {
     for (tree_if_clause *t : lst)
       {
-        if (t->line () >= line)
+        if (t->line () >= m_line)
           take_action (*t);
 
-        if (! found)
+        if (! m_found)
           {
             tree_statement_list *stmt_lst = t->commands ();
 
             if (stmt_lst)
               stmt_lst->accept (*this);
           }
 
-        if (found)
+        if (m_found)
           break;
       }
   }
 
   void
   tree_breakpoint::visit_index_expression (tree_index_expression&)
   {
     panic_impossible ();
@@ -253,17 +253,17 @@ namespace octave
   tree_breakpoint::visit_multi_assignment (tree_multi_assignment&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_no_op_command (tree_no_op_command& cmd)
   {
-    if (cmd.is_end_of_fcn_or_script () && cmd.line () >= line)
+    if (cmd.is_end_of_fcn_or_script () && cmd.line () >= m_line)
       take_action (cmd);
   }
 
   void
   tree_breakpoint::visit_anon_fcn_handle (tree_anon_fcn_handle&)
   {
     panic_impossible ();
   }
@@ -302,17 +302,17 @@ namespace octave
   tree_breakpoint::visit_prefix_expression (tree_prefix_expression&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_return_command (tree_return_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
   }
 
   void
   tree_breakpoint::visit_return_list (tree_return_list&)
   {
     panic_impossible ();
   }
@@ -329,167 +329,167 @@ namespace octave
     if (stmt.is_command ())
       {
         tree_command *cmd = stmt.command ();
 
         cmd->accept (*this);
       }
     else
       {
-        if (stmt.line () >= line)
+        if (stmt.line () >= m_line)
           take_action (stmt);
       }
   }
 
   // Called by
   //   tree_statement_list::set_breakpoint (int line, std::string& condition)
   // with <lst> consisting of a user function in which to set a breakpoint.
   void
   tree_breakpoint::visit_statement_list (tree_statement_list& lst)
   {
     for (tree_statement *elt : lst)
       {
         if (elt)
           {
             elt->accept (*this);
 
-            if (found)
+            if (m_found)
               break;
           }
       }
   }
 
   void
   tree_breakpoint::visit_switch_case (tree_switch_case&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
   {
     for (tree_switch_case *t : lst)
       {
-        if (t->line () >= line)
+        if (t->line () >= m_line)
           take_action (*t);
 
-        if (! found)
+        if (! m_found)
           {
             tree_statement_list *stmt_lst = t->commands ();
 
             if (stmt_lst)
               stmt_lst->accept (*this);
           }
 
-        if (found)
+        if (m_found)
           break;
       }
   }
 
   void
   tree_breakpoint::visit_switch_command (tree_switch_command& cmd)
   {
-    if (cmd.line () >= line)
+    if (cmd.line () >= m_line)
       take_action (cmd);
 
-    if (! found)
+    if (! m_found)
       {
         tree_switch_case_list *lst = cmd.case_list ();
 
         if (lst)
           lst->accept (*this);
       }
   }
 
   void
   tree_breakpoint::visit_try_catch_command (tree_try_catch_command& cmd)
   {
     tree_statement_list *try_code = cmd.body ();
 
     if (try_code)
       try_code->accept (*this);
 
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *catch_code = cmd.cleanup ();
 
         if (catch_code)
           catch_code->accept (*this);
       }
   }
 
   void
   tree_breakpoint::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
   {
     tree_statement_list *body = cmd.body ();
 
     if (body)
       body->accept (*this);
 
-    if (! found)
+    if (! m_found)
       {
         tree_statement_list *cleanup = cmd.cleanup ();
 
         if (cleanup)
           cleanup->accept (*this);
       }
   }
 
   void
   tree_breakpoint::take_action (tree& tr)
   {
-    if (act == set)
+    if (m_action == set)
       {
-        tr.set_breakpoint (condition);
-        line = tr.line ();
-        found = true;
+        tr.set_breakpoint (m_condition);
+        m_line = tr.line ();
+        m_found = true;
       }
-    else if (act == clear)
+    else if (m_action == clear)
       {
         if (tr.is_breakpoint ())
           {
             tr.delete_breakpoint ();
-            found = true;
+            m_found = true;
           }
       }
-    else if (act == list)
+    else if (m_action == list)
       {
         if (tr.is_breakpoint ())
           {
-            bp_list.append (octave_value (tr.line ()));
-            bp_cond_list.append (octave_value (tr.bp_cond ()));
+            m_bp_list.append (octave_value (tr.line ()));
+            m_bp_cond_list.append (octave_value (tr.bp_cond ()));
           }
       }
     else
       panic_impossible ();
   }
 
   void
   tree_breakpoint::take_action (tree_statement& stmt)
   {
     int lineno = stmt.line ();
 
-    if (act == set)
+    if (m_action == set)
       {
-        stmt.set_breakpoint (condition);
-        line = lineno;
-        found = true;
+        stmt.set_breakpoint (m_condition);
+        m_line = lineno;
+        m_found = true;
       }
-    else if (act == clear)
+    else if (m_action == clear)
       {
         if (stmt.is_breakpoint ())
           {
             stmt.delete_breakpoint ();
-            found = true;
+            m_found = true;
           }
       }
-    else if (act == list)
+    else if (m_action == list)
       {
         if (stmt.is_breakpoint ())
           {
-            bp_list.append (octave_value (lineno));
-            bp_cond_list.append (octave_value (stmt.bp_cond ()));
+            m_bp_list.append (octave_value (lineno));
+            m_bp_cond_list.append (octave_value (stmt.bp_cond ()));
           }
       }
     else
       panic_impossible ();
   }
 }
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -38,27 +38,29 @@ namespace octave
 
   class tree_breakpoint : public tree_walker
   {
   public:
 
     enum action { set = 1, clear = 2, list = 3 };
 
     tree_breakpoint (int l, action a, const std::string& c = "")
-      : line (l), act (a), condition (c), found (false), bp_list () { }
+      : m_line (l), m_action (a), m_condition (c), m_found (false),
+        m_bp_list (), m_bp_cond_list ()
+    { }
 
     // No copying!
 
     tree_breakpoint (const tree_breakpoint&) = delete;
 
     tree_breakpoint& operator = (const tree_breakpoint&) = delete;
 
     ~tree_breakpoint (void) = default;
 
-    bool success (void) const { return found; }
+    bool success (void) const { return m_found; }
 
     void visit_argument_list (tree_argument_list&);
 
     void visit_binary_expression (tree_binary_expression&);
 
     void visit_break_command (tree_break_command&);
 
     void visit_colon_expression (tree_colon_expression&);
@@ -136,44 +138,45 @@ namespace octave
     void visit_switch_case_list (tree_switch_case_list&);
 
     void visit_switch_command (tree_switch_command&);
 
     void visit_try_catch_command (tree_try_catch_command&);
 
     void visit_unwind_protect_command (tree_unwind_protect_command&);
 
-    octave_value_list get_list (void) { return bp_list; }
-    octave_value_list get_cond_list (void) { return bp_cond_list; }
+    octave_value_list get_list (void) { return m_bp_list; }
 
-    int get_line (void) { return found ? line : 0; }
+    octave_value_list get_cond_list (void) { return m_bp_cond_list; }
+
+    int get_line (void) { return m_found ? m_line : 0; }
 
   private:
 
     void take_action (tree& tr);
 
     void take_action (tree_statement& stmt);
 
     // Statement line number we are looking for.
-    int line;
+    int m_line;
 
     // What to do.
-    action act;
+    action m_action;
 
     // Expression which must be true to break
-    std::string condition;
+    std::string m_condition;
 
     // Have we already found the line?
-    bool found;
+    bool m_found;
 
     // List of breakpoint line numbers.
-    octave_value_list bp_list;
+    octave_value_list m_bp_list;
 
     // List of breakpoint conditions.
-    octave_value_list bp_cond_list;
+    octave_value_list m_bp_cond_list;
   };
 
   // TRUE means SIGINT should put us in the debugger at the next
   // available breakpoint.
   extern bool octave_debug_on_interrupt_state;
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -184,17 +184,16 @@ namespace octave
         ct = simplify_and_or_op (ca, cb, t);
         break;
 
       default:
         ct = octave_value::unknown_compound_binary_op;
         break;
       }
 
-    tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
-      ? new tree_binary_expression (a, b, l, c, t)
-      : new tree_compound_binary_expression (a, b, l,
-                                             c, t, ca,
-                                             cb, ct);
+    tree_binary_expression *ret
+      = (ct == octave_value::unknown_compound_binary_op
+         ? new tree_binary_expression (a, b, l, c, t)
+         : new tree_compound_binary_expression (a, b, l, c, t, ca, cb, ct));
 
     return ret;
   }
 }
diff --git a/libinterp/parse-tree/pt-cbinop.h b/libinterp/parse-tree/pt-cbinop.h
--- a/libinterp/parse-tree/pt-cbinop.h
+++ b/libinterp/parse-tree/pt-cbinop.h
@@ -42,37 +42,38 @@ namespace octave
   {
   public:
 
     tree_compound_binary_expression (tree_expression *a, tree_expression *b,
                                      int l, int c,
                                      octave_value::binary_op t,
                                      tree_expression *ca, tree_expression *cb,
                                      octave_value::compound_binary_op ct)
-      : tree_binary_expression (a, b, l, c, t), cop_lhs (ca), cop_rhs (cb),
-        etype (ct) { }
+      : tree_binary_expression (a, b, l, c, t), m_lhs (ca), m_rhs (cb),
+        m_etype (ct)
+    { }
 
-    octave_value::compound_binary_op cop_type (void) const { return etype; }
+    octave_value::compound_binary_op cop_type (void) const { return m_etype; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * clhs (void) { return cop_lhs; }
-    tree_expression * crhs (void) { return cop_rhs; }
+    tree_expression * clhs (void) { return m_lhs; }
+    tree_expression * crhs (void) { return m_rhs; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_compound_binary_expression (*this);
     }
 
   private:
 
-    tree_expression *cop_lhs;
-    tree_expression *cop_rhs;
+    tree_expression *m_lhs;
+    tree_expression *m_rhs;
 
-    octave_value::compound_binary_op etype;
+    octave_value::compound_binary_op m_etype;
 
     // No copying!
 
     tree_compound_binary_expression (const tree_compound_binary_expression&) = delete;
 
     tree_compound_binary_expression& operator =
     (const tree_compound_binary_expression&) = delete;
   };
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -37,17 +37,17 @@ namespace octave
     tree_argument_list::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_expression *elt = *p++;
 
         if (elt)
           {
-            if (do_lvalue_check && ! elt->lvalue_ok ())
+            if (m_do_lvalue_check && ! elt->lvalue_ok ())
               errmsg ("invalid lvalue in multiple assignment", elt->line ());
           }
       }
   }
 
   void
   tree_checker::visit_binary_expression (tree_binary_expression& expr)
   {
@@ -161,21 +161,21 @@ namespace octave
     if (lhs)
       {
         int len = lhs->length ();
 
         if (len == 0 || len > 2)
           errmsg ("invalid number of output arguments in for command",
                   cmd.line ());
 
-        do_lvalue_check = true;
+        m_do_lvalue_check = true;
 
         lhs->accept (*this);
 
-        do_lvalue_check = false;
+        m_do_lvalue_check = false;
       }
 
     tree_expression *expr = cmd.control_expr ();
 
     if (expr)
       expr->accept (*this);
 
     tree_statement_list *list = cmd.body ();
@@ -305,21 +305,21 @@ namespace octave
 
   void
   tree_checker::visit_multi_assignment (tree_multi_assignment& expr)
   {
     tree_argument_list *lhs = expr.left_hand_side ();
 
     if (lhs)
       {
-        do_lvalue_check = true;
+        m_do_lvalue_check = true;
 
         lhs->accept (*this);
 
-        do_lvalue_check = false;
+        m_do_lvalue_check = false;
       }
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       rhs->accept (*this);
   }
 
@@ -541,14 +541,14 @@ namespace octave
 
     if (expr)
       expr->accept (*this);
   }
 
   void
   tree_checker::errmsg (const std::string& msg, int line)
   {
-    if (file_name.empty ())
+    if (m_file_name.empty ())
       error ("%s", msg.c_str ());
     else
-      error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
+      error ("%s: %d: %s", m_file_name.c_str (), line, msg.c_str ());
   }
 }
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -35,17 +35,17 @@ namespace octave
 
   // How to check the semantics of the code that the parse trees represent.
 
   class tree_checker : public tree_walker
   {
   public:
 
     tree_checker (void)
-      : do_lvalue_check (false), file_name () { }
+      : m_do_lvalue_check (false), m_file_name () { }
 
     // No copying!
 
     tree_checker (const tree_checker&) = delete;
 
     tree_checker& operator = (const tree_checker&) = delete;
 
     ~tree_checker (void) = default;
@@ -129,19 +129,19 @@ namespace octave
     void visit_unwind_protect_command (tree_unwind_protect_command&);
 
     void visit_while_command (tree_while_command&);
 
     void visit_do_until_command (tree_do_until_command&);
 
   private:
 
-    bool do_lvalue_check;
+    bool m_do_lvalue_check;
 
-    std::string file_name;
+    std::string m_file_name;
 
     OCTAVE_NORETURN void errmsg (const std::string& msg, int line);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_checker' instead")
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -108,42 +108,42 @@ namespace octave
   }
 
   // Classdef enum_block
 
   // Classdef body
 
   tree_classdef_body::~tree_classdef_body (void)
   {
-    while (! properties_lst.empty ())
+    while (! m_properties_lst.empty ())
       {
-        properties_list_iterator p = properties_lst.begin ();
+        properties_list_iterator p = m_properties_lst.begin ();
         delete *p;
-        properties_lst.erase (p);
+        m_properties_lst.erase (p);
       }
 
-    while (! methods_lst.empty ())
+    while (! m_methods_lst.empty ())
       {
-        methods_list_iterator p = methods_lst.begin ();
+        methods_list_iterator p = m_methods_lst.begin ();
         delete *p;
-        methods_lst.erase (p);
+        m_methods_lst.erase (p);
       }
 
-    while (! events_lst.empty ())
+    while (! m_events_lst.empty ())
       {
-        events_list_iterator p = events_lst.begin ();
+        events_list_iterator p = m_events_lst.begin ();
         delete *p;
-        events_lst.erase (p);
+        m_events_lst.erase (p);
       }
 
-    while (! enum_lst.empty ())
+    while (! m_enum_lst.empty ())
       {
-        enum_list_iterator p = enum_lst.begin ();
+        enum_list_iterator p = m_enum_lst.begin ();
         delete *p;
-        enum_lst.erase (p);
+        m_enum_lst.erase (p);
       }
   }
 
   // Classdef
 
   octave_function*
   tree_classdef::make_meta_class (interpreter& interp, bool is_at_folder)
   {
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -42,61 +42,64 @@ namespace octave
   class interpreter;
 
   class tree_classdef_attribute
   {
   public:
 
     tree_classdef_attribute (tree_identifier *i = nullptr,
                              tree_expression *e = nullptr)
-      : id (i), expr (e), neg (false) { }
+      : m_id (i), m_expr (e), m_neg (false)
+    { }
 
     tree_classdef_attribute (tree_identifier *i, bool b)
-      : id (i), expr (nullptr), neg (b) { }
+      : m_id (i), m_expr (nullptr), m_neg (b)
+    { }
 
     // No copying!
 
     tree_classdef_attribute (const tree_classdef_attribute&) = delete;
 
     tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
 
     ~tree_classdef_attribute (void)
     {
-      delete id;
-      delete expr;
+      delete m_id;
+      delete m_expr;
     }
 
-    tree_identifier * ident (void) { return id; }
+    tree_identifier * ident (void) { return m_id; }
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expr; }
 
-    bool negate (void) { return neg; }
+    bool negate (void) { return m_neg; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_attribute (*this);
     }
 
   private:
 
-    tree_identifier *id;
-    tree_expression *expr;
-    bool neg;
+    tree_identifier *m_id;
+    tree_expression *m_expr;
+    bool m_neg;
   };
 
   class tree_classdef_attribute_list : public base_list<tree_classdef_attribute *>
   {
   public:
 
     tree_classdef_attribute_list (void) { }
 
     tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
 
     tree_classdef_attribute_list (const base_list<tree_classdef_attribute *>& a)
-      : base_list<tree_classdef_attribute *> (a) { }
+      : base_list<tree_classdef_attribute *> (a)
+    { }
 
     // No copying!
 
     tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
 
     tree_classdef_attribute_list&
     operator = (const tree_classdef_attribute_list&) = delete;
 
@@ -108,49 +111,54 @@ namespace octave
     }
   };
 
   class tree_classdef_superclass
   {
   public:
 
     tree_classdef_superclass (const std::string& cname)
-      : cls_name (cname) { }
+      : m_cls_name (cname)
+    { }
 
     // No copying!
 
     tree_classdef_superclass (const tree_classdef_superclass&) = delete;
 
     tree_classdef_superclass&
     operator = (const tree_classdef_superclass&) = delete;
 
     ~tree_classdef_superclass (void) = default;
 
-    std::string class_name (void) { return cls_name; }
+    std::string class_name (void) { return m_cls_name; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_superclass (*this);
     }
 
   private:
 
-    std::string cls_name;
+    std::string m_cls_name;
   };
 
   class tree_classdef_superclass_list : public base_list<tree_classdef_superclass *>
   {
   public:
 
     tree_classdef_superclass_list (void) { }
 
-    tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
+    tree_classdef_superclass_list (tree_classdef_superclass *sc)
+    {
+      append (sc);
+    }
 
     tree_classdef_superclass_list (const base_list<tree_classdef_superclass *>& a)
-      : base_list<tree_classdef_superclass *> (a) { }
+      : base_list<tree_classdef_superclass *> (a)
+    { }
 
     // No copying!
 
     tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
 
     tree_classdef_superclass_list&
     operator = (const tree_classdef_superclass_list&) = delete;
 
@@ -166,91 +174,93 @@ namespace octave
   class tree_classdef_element : public tree
   {
   public:
 
     tree_classdef_element (tree_classdef_attribute_list *a,
                            base_list<T> *elist,
                            comment_list *lc, comment_list *tc,
                            int l = -1, int c = -1)
-      : tree (l, c), attr_list (a), elt_list (elist),
-        lead_comm (lc), trail_comm (tc)
+      : tree (l, c), m_attr_list (a), m_elt_list (elist),
+        m_lead_comm (lc), m_trail_comm (tc)
     { }
 
     // No copying!
 
     tree_classdef_element (const tree_classdef_element&) = delete;
 
     tree_classdef_element& operator = (const tree_classdef_element&) = delete;
 
     ~tree_classdef_element (void)
     {
-      delete attr_list;
-      delete elt_list;
-      delete lead_comm;
-      delete trail_comm;
+      delete m_attr_list;
+      delete m_elt_list;
+      delete m_lead_comm;
+      delete m_trail_comm;
     }
 
-    tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
+    tree_classdef_attribute_list * attribute_list (void) { return m_attr_list; }
 
-    base_list<T> * element_list (void) { return elt_list; }
+    base_list<T> * element_list (void) { return m_elt_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker&) { }
 
   private:
 
     // List of attributes that apply to this class.
-    tree_classdef_attribute_list *attr_list;
+    tree_classdef_attribute_list *m_attr_list;
 
     // The list of objects contained in this block.
-    base_list<T> *elt_list;
+    base_list<T> *m_elt_list;
 
     // Comment preceding the token marking the beginning of the block.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding END token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 
   class tree_classdef_property
   {
   public:
 
-    tree_classdef_property (tree_identifier *i = nullptr, tree_expression *e = nullptr)
-      : id (i), expr (e) { }
+    tree_classdef_property (tree_identifier *i = nullptr,
+                            tree_expression *e = nullptr)
+      : m_id (i), m_expr (e)
+    { }
 
     // No copying!
 
     tree_classdef_property (const tree_classdef_property&) = delete;
 
     tree_classdef_property& operator = (const tree_classdef_property&) = delete;
 
     ~tree_classdef_property (void)
     {
-      delete id;
-      delete expr;
+      delete m_id;
+      delete m_expr;
     }
 
-    tree_identifier * ident (void) { return id; }
+    tree_identifier * ident (void) { return m_id; }
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expr; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_property (*this);
     }
 
   private:
 
-    tree_identifier *id;
-    tree_expression *expr;
+    tree_identifier *m_id;
+    tree_expression *m_expr;
   };
 
   class tree_classdef_property_list : public base_list<tree_classdef_property *>
   {
   public:
 
     tree_classdef_property_list (void) { }
 
@@ -279,17 +289,18 @@ namespace octave
   {
   public:
 
     tree_classdef_properties_block (tree_classdef_attribute_list *a,
                                     tree_classdef_property_list *plist,
                                     comment_list *lc,
                                     comment_list *tc,
                                     int l = -1, int c = -1)
-      : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
+      : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c)
+    { }
 
     // No copying!
 
     tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
 
     tree_classdef_properties_block&
     operator = (const tree_classdef_properties_block&) = delete;
 
@@ -330,17 +341,18 @@ namespace octave
   class tree_classdef_methods_block : public tree_classdef_element<octave_value>
   {
   public:
 
     tree_classdef_methods_block (tree_classdef_attribute_list *a,
                                  tree_classdef_methods_list *mlist,
                                  comment_list *lc,
                                  comment_list *tc, int l = -1, int c = -1)
-      : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
+      : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c)
+    { }
 
     // No copying!
 
     tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
 
     tree_classdef_methods_block&
     operator = (const tree_classdef_methods_block&) = delete;
 
@@ -351,51 +363,52 @@ namespace octave
       tw.visit_classdef_methods_block (*this);
     }
   };
 
   class tree_classdef_event
   {
   public:
 
-    tree_classdef_event (tree_identifier *i = nullptr) : id (i) { }
+    tree_classdef_event (tree_identifier *i = nullptr) : m_id (i) { }
 
     // No copying!
 
     tree_classdef_event (const tree_classdef_event&) = delete;
 
     tree_classdef_event& operator = (const tree_classdef_event&) = delete;
 
     ~tree_classdef_event (void)
     {
-      delete id;
+      delete m_id;
     }
 
-    tree_identifier * ident (void) { return id; }
+    tree_identifier * ident (void) { return m_id; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_event (*this);
     }
 
   private:
 
-    tree_identifier *id;
+    tree_identifier *m_id;
   };
 
   class tree_classdef_events_list : public base_list<tree_classdef_event *>
   {
   public:
 
     tree_classdef_events_list (void) { }
 
     tree_classdef_events_list (tree_classdef_event *e) { append (e); }
 
     tree_classdef_events_list (const base_list<tree_classdef_event *>& a)
-      : base_list<tree_classdef_event *> (a) { }
+      : base_list<tree_classdef_event *> (a)
+    { }
 
     // No copying!
 
     tree_classdef_events_list (const tree_classdef_events_list&) = delete;
 
     tree_classdef_events_list&
     operator = (const tree_classdef_events_list&) = delete;
 
@@ -411,17 +424,18 @@ namespace octave
     : public tree_classdef_element<tree_classdef_event *>
   {
   public:
 
     tree_classdef_events_block (tree_classdef_attribute_list *a,
                                 tree_classdef_events_list *elist,
                                 comment_list *lc,
                                 comment_list *tc, int l = -1, int c = -1)
-      : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
+      : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c)
+    { }
 
     // No copying!
 
     tree_classdef_events_block (const tree_classdef_events_block&) = delete;
 
     tree_classdef_events_block&
     operator = (const tree_classdef_events_block&) = delete;
 
@@ -432,58 +446,60 @@ namespace octave
       tw.visit_classdef_events_block (*this);
     }
   };
 
   class tree_classdef_enum
   {
   public:
 
-    tree_classdef_enum (void) : id (nullptr), expr (nullptr) { }
+    tree_classdef_enum (void) : m_id (nullptr), m_expr (nullptr) { }
 
     tree_classdef_enum (tree_identifier *i, tree_expression *e)
-      : id (i), expr (e) { }
+      : m_id (i), m_expr (e)
+    { }
 
     // No copying!
 
     tree_classdef_enum (const tree_classdef_enum&) = delete;
 
     tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
 
     ~tree_classdef_enum (void)
     {
-      delete id;
-      delete expr;
+      delete m_id;
+      delete m_expr;
     }
 
-    tree_identifier * ident (void) { return id; }
+    tree_identifier * ident (void) { return m_id; }
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expr; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_enum (*this);
     }
 
   private:
 
-    tree_identifier *id;
-    tree_expression *expr;
+    tree_identifier *m_id;
+    tree_expression *m_expr;
   };
 
   class tree_classdef_enum_list : public base_list<tree_classdef_enum *>
   {
   public:
 
     tree_classdef_enum_list (void) { }
 
     tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
 
     tree_classdef_enum_list (const base_list<tree_classdef_enum *>& a)
-      : base_list<tree_classdef_enum *> (a) { }
+      : base_list<tree_classdef_enum *> (a)
+    { }
 
     // No copying!
 
     tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
 
     tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
 
     ~tree_classdef_enum_list (void);
@@ -498,17 +514,18 @@ namespace octave
     : public tree_classdef_element<tree_classdef_enum *>
   {
   public:
 
     tree_classdef_enum_block (tree_classdef_attribute_list *a,
                               tree_classdef_enum_list *elist,
                               comment_list *lc,
                               comment_list *tc, int l = -1, int c = -1)
-      : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
+      : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c)
+    { }
 
     // No copying!
 
     tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
 
     tree_classdef_enum_block&
     operator = (const tree_classdef_enum_block&) = delete;
 
@@ -532,173 +549,177 @@ namespace octave
 
     typedef std::list<tree_classdef_events_block *>::iterator events_list_iterator;
     typedef std::list<tree_classdef_events_block *>::const_iterator events_list_const_iterator;
 
     typedef std::list<tree_classdef_enum_block *>::iterator enum_list_iterator;
     typedef std::list<tree_classdef_enum_block *>::const_iterator enum_list_const_iterator;
 
     tree_classdef_body (void)
-      : properties_lst (), methods_lst (), events_lst (), enum_lst () { }
+      : m_properties_lst (), m_methods_lst (), m_events_lst (), m_enum_lst ()
+    { }
 
     tree_classdef_body (tree_classdef_properties_block *pb)
-      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+      : m_properties_lst (), m_methods_lst (), m_events_lst (), m_enum_lst ()
     {
       append (pb);
     }
 
     tree_classdef_body (tree_classdef_methods_block *mb)
-      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+      : m_properties_lst (), m_methods_lst (), m_events_lst (), m_enum_lst ()
     {
       append (mb);
     }
 
     tree_classdef_body (tree_classdef_events_block *evb)
-      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+      : m_properties_lst (), m_methods_lst (), m_events_lst (), m_enum_lst ()
     {
       append (evb);
     }
 
     tree_classdef_body (tree_classdef_enum_block *enb)
-      : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+      : m_properties_lst (), m_methods_lst (), m_events_lst (), m_enum_lst ()
     {
       append (enb);
     }
 
     // No copying!
 
     tree_classdef_body (const tree_classdef_body&) = delete;
 
     tree_classdef_body& operator = (const tree_classdef_body&) = delete;
 
     ~tree_classdef_body (void);
 
     void append (tree_classdef_properties_block *pb)
     {
-      properties_lst.push_back (pb);
+      m_properties_lst.push_back (pb);
     }
 
     void append (tree_classdef_methods_block *mb)
     {
-      methods_lst.push_back (mb);
+      m_methods_lst.push_back (mb);
     }
 
     void append (tree_classdef_events_block *evb)
     {
-      events_lst.push_back (evb);
+      m_events_lst.push_back (evb);
     }
 
     void append (tree_classdef_enum_block *enb)
     {
-      enum_lst.push_back (enb);
+      m_enum_lst.push_back (enb);
     }
 
     std::list<tree_classdef_properties_block *> properties_list (void)
     {
-      return properties_lst;
+      return m_properties_lst;
     }
 
     std::list<tree_classdef_methods_block *> methods_list (void)
     {
-      return methods_lst;
+      return m_methods_lst;
     }
 
     std::list<tree_classdef_events_block *> events_list (void)
     {
-      return events_lst;
+      return m_events_lst;
     }
 
     std::list<tree_classdef_enum_block *> enum_list (void)
     {
-      return enum_lst;
+      return m_enum_lst;
     }
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_body (*this);
     }
 
   private:
 
-    std::list<tree_classdef_properties_block *> properties_lst;
+    std::list<tree_classdef_properties_block *> m_properties_lst;
 
-    std::list<tree_classdef_methods_block *> methods_lst;
+    std::list<tree_classdef_methods_block *> m_methods_lst;
 
-    std::list<tree_classdef_events_block *> events_lst;
+    std::list<tree_classdef_events_block *> m_events_lst;
 
-    std::list<tree_classdef_enum_block *> enum_lst;
+    std::list<tree_classdef_enum_block *> m_enum_lst;
   };
 
   // Classdef definition.
 
   class tree_classdef : public tree_command
   {
   public:
 
     tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
                    tree_classdef_superclass_list *sc,
                    tree_classdef_body *b, comment_list *lc,
                    comment_list *tc,
                    const std::string& pn = "", int l = -1,
                    int c = -1)
-      : tree_command (l, c), attr_list (a), id (i),
-        supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
-        pack_name (pn) { }
+      : tree_command (l, c), m_attr_list (a), m_id (i),
+        m_supclass_list (sc), m_element_list (b), m_lead_comm (lc),
+        m_trail_comm (tc), m_pack_name (pn)
+    { }
 
     // No copying!
 
     tree_classdef (const tree_classdef&) = delete;
 
     tree_classdef& operator = (const tree_classdef&) = delete;
 
     ~tree_classdef (void)
     {
-      delete attr_list;
-      delete id;
-      delete supclass_list;
-      delete element_list;
-      delete lead_comm;
-      delete trail_comm;
+      delete m_attr_list;
+      delete m_id;
+      delete m_supclass_list;
+      delete m_element_list;
+      delete m_lead_comm;
+      delete m_trail_comm;
     }
 
-    tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
+    tree_classdef_attribute_list *
+    attribute_list (void) { return m_attr_list; }
 
-    tree_identifier * ident (void) { return id; }
-
-    tree_classdef_superclass_list * superclass_list (void) { return supclass_list; }
+    tree_identifier * ident (void) { return m_id; }
 
-    tree_classdef_body * body (void) { return element_list; }
+    tree_classdef_superclass_list *
+    superclass_list (void) { return m_supclass_list; }
+
+    tree_classdef_body * body (void) { return m_element_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
-    const std::string& package_name (void) const { return pack_name; }
+    const std::string& package_name (void) const { return m_pack_name; }
 
     octave_function * make_meta_class (interpreter& interp,
                                        bool is_at_folder = false);
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef (*this);
     }
 
   private:
 
-    tree_classdef_attribute_list *attr_list;
+    tree_classdef_attribute_list *m_attr_list;
 
-    tree_identifier *id;
+    tree_identifier *m_id;
 
-    tree_classdef_superclass_list *supclass_list;
+    tree_classdef_superclass_list *m_supclass_list;
 
-    tree_classdef_body *element_list;
+    tree_classdef_body *m_element_list;
 
-    comment_list *lead_comm;
-    comment_list *trail_comm;
+    comment_list *m_lead_comm;
+    comment_list *m_trail_comm;
 
-    std::string pack_name;
+    std::string m_pack_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 // Hmm, a lot of these are templates, so not sure how to typedef them.
 
 #endif
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -55,77 +55,77 @@ namespace octave
   // No-op.
 
   class tree_no_op_command : public tree_command
   {
   public:
 
     tree_no_op_command (const std::string& cmd = "no_op", bool e = false,
                         int l = -1, int c = -1)
-      : tree_command (l, c), eof (e), orig_cmd (cmd) { }
+      : tree_command (l, c), m_eof (e), m_orig_cmd (cmd) { }
 
     // No copying!
 
     tree_no_op_command (const tree_no_op_command&) = delete;
 
     tree_no_op_command& operator = (const tree_no_op_command&) = delete;
 
     ~tree_no_op_command (void) = default;
 
     void accept (tree_walker& tw)
     {
       tw.visit_no_op_command (*this);
     }
 
     bool is_end_of_fcn_or_script (void) const
     {
-      return (orig_cmd == "endfunction" || orig_cmd == "endscript");
+      return (m_orig_cmd == "endfunction" || m_orig_cmd == "endscript");
     }
 
-    bool is_end_of_file (void) const { return eof; }
+    bool is_end_of_file (void) const { return m_eof; }
 
-    std::string original_command (void) { return orig_cmd; }
+    std::string original_command (void) { return m_orig_cmd; }
 
   private:
 
-    bool eof;
+    bool m_eof;
 
-    std::string orig_cmd;
+    std::string m_orig_cmd;
   };
 
   // Function definition.
 
   class tree_function_def : public tree_command
   {
   public:
 
     tree_function_def (octave_function *f, int l = -1, int c = -1)
-      : tree_command (l, c), fcn (f) { }
+      : tree_command (l, c), m_fcn (f) { }
 
     // No copying!
 
     tree_function_def (const tree_function_def&) = delete;
 
     tree_function_def& operator = (const tree_function_def&) = delete;
 
     ~tree_function_def (void) = default;
 
     void accept (tree_walker& tw)
     {
       tw.visit_function_def (*this);
     }
 
-    octave_value function (void) { return fcn; }
+    octave_value function (void) { return m_fcn; }
 
   private:
 
-    octave_value fcn;
+    octave_value m_fcn;
 
     tree_function_def (const octave_value& v, int l = -1, int c = -1)
-      : tree_command (l, c), fcn (v) { }
+      : tree_command (l, c), m_fcn (v) { }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_command' instead")
 typedef octave::tree_command tree_command;
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -29,18 +29,18 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   // Colon expressions.
 
   tree_expression *
   tree_colon_expression::dup (symbol_scope& scope) const
   {
     tree_colon_expression *new_ce
-      = new tree_colon_expression (op_base ? op_base->dup (scope) : nullptr,
-                                   op_limit ? op_limit->dup (scope) : nullptr,
-                                   op_increment ? op_increment->dup (scope) : nullptr,
+      = new tree_colon_expression (m_base ? m_base->dup (scope) : nullptr,
+                                   m_limit ? m_limit->dup (scope) : nullptr,
+                                   m_increment ? m_increment->dup (scope) : nullptr,
                                    line (), column ());
 
     new_ce->copy_base (*new_ce);
 
     return new_ce;
   }
 }
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -39,78 +39,78 @@ namespace octave
 
   // Colon expressions.
 
   class tree_colon_expression : public tree_expression
   {
   public:
 
     tree_colon_expression (int l = -1, int c = -1)
-      : tree_expression (l, c), op_base (nullptr), op_limit (nullptr),
-        op_increment (nullptr), save_base (false) { }
+      : tree_expression (l, c), m_base (nullptr), m_limit (nullptr),
+        m_increment (nullptr), m_save_base (false) { }
 
     tree_colon_expression (tree_expression *bas, tree_expression *lim,
                            int l = -1, int c = -1)
-      : tree_expression (l, c), op_base (bas), op_limit (lim),
-        op_increment (nullptr), save_base (false) { }
+      : tree_expression (l, c), m_base (bas), m_limit (lim),
+        m_increment (nullptr), m_save_base (false) { }
 
     tree_colon_expression (tree_expression *bas, tree_expression *lim,
                            tree_expression *inc, int l = -1, int c = -1)
-      : tree_expression (l, c), op_base (bas), op_limit (lim),
-        op_increment (inc), save_base (false) { }
+      : tree_expression (l, c), m_base (bas), m_limit (lim),
+        m_increment (inc), m_save_base (false) { }
 
     // No copying!
 
     tree_colon_expression (const tree_colon_expression&) = delete;
 
     tree_colon_expression& operator = (const tree_colon_expression&) = delete;
 
     ~tree_colon_expression (void)
     {
-      if (! save_base)
-        delete op_base;
+      if (! m_save_base)
+        delete m_base;
 
-      delete op_limit;
-      delete op_increment;
+      delete m_limit;
+      delete m_increment;
     }
 
     bool has_magic_end (void) const
     {
-      return ((op_base && op_base->has_magic_end ())
-              || (op_limit && op_limit->has_magic_end ())
-              || (op_increment && op_increment->has_magic_end ()));
+      return ((m_base && m_base->has_magic_end ())
+              || (m_limit && m_limit->has_magic_end ())
+              || (m_increment && m_increment->has_magic_end ()));
     }
 
-    void preserve_base (void) { save_base = true; }
+    void preserve_base (void) { m_save_base = true; }
 
     bool rvalue_ok (void) const { return true; }
 
     void eval_error (const std::string& s) const;
 
-    tree_expression * base (void) { return op_base; }
+    tree_expression * base (void) { return m_base; }
 
-    tree_expression * limit (void) { return op_limit; }
+    tree_expression * limit (void) { return m_limit; }
 
-    tree_expression * increment (void) { return op_increment; }
+    tree_expression * increment (void) { return m_increment; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_colon_expression (*this);
     }
 
   private:
 
     // The components of the expression.
-    tree_expression *op_base;
-    tree_expression *op_limit;
-    tree_expression *op_increment;
+    tree_expression *m_base;
+    tree_expression *m_limit;
+    tree_expression *m_increment;
 
-    bool save_base;
+    bool m_save_base;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_colon_expression' instead")
 typedef octave::tree_colon_expression tree_colon_expression;
 
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -36,35 +36,35 @@ namespace octave
 {
   // We are likely to have a lot of tree_constant objects to allocate,
   // so make the grow_size large.
 
   void
   tree_constant::print (std::ostream& os, bool pr_as_read_syntax,
                         bool pr_orig_text)
   {
-    if (pr_orig_text && ! orig_text.empty ())
-      os << orig_text;
+    if (pr_orig_text && ! m_orig_text.empty ())
+      os << m_orig_text;
     else
-      val.print (os, pr_as_read_syntax);
+      m_value.print (os, pr_as_read_syntax);
   }
 
   void
   tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
                             bool pr_orig_text)
   {
-    if (pr_orig_text && ! orig_text.empty ())
-      os << orig_text;
+    if (pr_orig_text && ! m_orig_text.empty ())
+      os << m_orig_text;
     else
-      val.print_raw (os, pr_as_read_syntax);
+      m_value.print_raw (os, pr_as_read_syntax);
   }
 
   tree_expression *
   tree_constant::dup (symbol_scope&) const
   {
     tree_constant *new_tc
-      = new tree_constant (val, orig_text, line (), column ());
+      = new tree_constant (m_value, m_orig_text, line (), column ());
 
     new_tc->copy_base (*this);
 
     return new_tc;
   }
 }
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -39,72 +39,75 @@ namespace octave
 {
   class symbol_scope;
 
   class tree_constant : public tree_expression
   {
   public:
 
     tree_constant (int l = -1, int c = -1)
-      : tree_expression (l, c), val (), orig_text () { }
+      : tree_expression (l, c), m_value (), m_orig_text ()
+    { }
 
     tree_constant (const octave_value& v, int l = -1, int c = -1)
-      : tree_expression (l, c), val (v), orig_text () { }
+      : tree_expression (l, c), m_value (v), m_orig_text ()
+    { }
 
     tree_constant (const octave_value& v, const std::string& ot,
                    int l = -1, int c = -1)
-      : tree_expression (l, c), val (v), orig_text (ot) { }
+      : tree_expression (l, c), m_value (v), m_orig_text (ot)
+    { }
 
     // No copying!
 
     tree_constant (const tree_constant&) = delete;
 
     tree_constant& operator = (const tree_constant&) = delete;
 
     ~tree_constant (void) = default;
 
     bool has_magic_end (void) const { return false; }
 
     // Type.  It would be nice to eliminate the need for this.
 
     bool is_constant (void) const { return true; }
 
-    void maybe_mutate (void) { val.maybe_mutate (); }
+    void maybe_mutate (void) { m_value.maybe_mutate (); }
 
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value value (void) { return val; }
+    octave_value value (void) { return m_value; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_constant (*this);
     }
 
     // Store the original text corresponding to this constant for later
     // pretty printing.
 
-    void stash_original_text (const std::string& s) { orig_text = s; }
+    void stash_original_text (const std::string& s) { m_orig_text = s; }
 
-    std::string original_text (void) const { return orig_text; }
+    std::string original_text (void) const { return m_orig_text; }
 
   private:
 
     // The actual value that this constant refers to.
-    octave_value val;
+    octave_value m_value;
 
     // The original text form of this constant.
-    std::string orig_text;
+    std::string m_orig_text;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_constant' instead")
 typedef octave::tree_constant tree_constant;
 
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -38,44 +38,44 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 namespace octave
 {
   // Declarations (global, static, etc.).
 
   tree_decl_elt::~tree_decl_elt (void)
   {
-    delete id;
-    delete expr;
+    delete m_id;
+    delete m_expr;
   }
 
   tree_decl_elt *
   tree_decl_elt::dup (symbol_scope& scope) const
   {
-    return new tree_decl_elt (id ? id->dup (scope) : nullptr,
-                              expr ? expr->dup (scope) : nullptr);
+    return new tree_decl_elt (m_id ? m_id->dup (scope) : nullptr,
+                              m_expr ? m_expr->dup (scope) : nullptr);
   }
 
   // Initializer lists for declaration statements.
 
   // Declaration commands (global, static).
 
   tree_decl_command::tree_decl_command (const std::string& n,
                                         tree_decl_init_list *t, int l, int c)
-    : tree_command (l, c), cmd_name (n), init_list (t)
+    : tree_command (l, c), m_cmd_name (n), m_init_list (t)
   {
     if (t)
       {
-        if (cmd_name == "global")
+        if (m_cmd_name == "global")
           mark_global ();
-        else if (cmd_name == "persistent")
+        else if (m_cmd_name == "persistent")
           mark_persistent ();
         else
           error ("tree_decl_command: unknown decl type: %s",
-                 cmd_name.c_str ());
+                 m_cmd_name.c_str ());
       }
   }
 
   tree_decl_command::~tree_decl_command (void)
   {
-    delete init_list;
+    delete m_init_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -51,77 +51,77 @@ namespace octave
     enum decl_type
       {
         unknown,
         global,
         persistent
       };
 
     tree_decl_elt (tree_identifier *i = nullptr, tree_expression *e = nullptr)
-      : type (unknown), id (i), expr (e) { }
+      : type (unknown), m_id (i), m_expr (e) { }
 
     // No copying!
 
     tree_decl_elt (const tree_decl_elt&) = delete;
 
     tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 
     ~tree_decl_elt (void);
 
     bool is_defined (symbol_record::context_id context)
     {
-      return id ? id->is_defined (context) : false;
+      return m_id ? m_id->is_defined (context) : false;
     }
 
     bool is_variable (symbol_record::context_id context)
     {
-      return id ? id->is_variable (context) : false;
+      return m_id ? m_id->is_variable (context) : false;
     }
 
     void mark_as_formal_parameter (void)
     {
-      if (id)
-        id->mark_as_formal_parameter ();
+      if (m_id)
+        m_id->mark_as_formal_parameter ();
     }
 
-    bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
+    bool lvalue_ok (void) { return m_id ? m_id->lvalue_ok () : false; }
 
     octave_lvalue lvalue (tree_evaluator *tw)
     {
-      return id ? id->lvalue (tw) : octave_lvalue ();
+      return m_id ? m_id->lvalue (tw) : octave_lvalue ();
     }
 
     void mark_global (void) { type = global; }
     bool is_global (void) const { return type == global; }
 
     void mark_persistent (void) { type = persistent; }
     bool is_persistent (void) const { return type == persistent; }
 
-    tree_identifier * ident (void) { return id; }
+    tree_identifier * ident (void) { return m_id; }
 
-    std::string name (void) const { return id ? id->name () : ""; }
+    std::string name (void) const { return m_id ? m_id->name () : ""; }
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expr; }
 
     tree_decl_elt * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_elt (*this);
     }
 
   private:
 
     decl_type type;
 
     // An identifier to tag with the declared property.
-    tree_identifier *id;
+    tree_identifier *m_id;
 
     // An initializer expression (may be zero);
-    tree_expression *expr;
+    tree_expression *m_expr;
   };
 
   class tree_decl_init_list : public base_list<tree_decl_elt *>
   {
   public:
 
     tree_decl_init_list (void) { }
 
@@ -178,57 +178,57 @@ namespace octave
 
   // Base class for declaration commands -- global, static, etc.
 
   class tree_decl_command : public tree_command
   {
   public:
 
     tree_decl_command (const std::string& n, int l = -1, int c = -1)
-      : tree_command (l, c), cmd_name (n), init_list (nullptr) { }
+      : tree_command (l, c), m_cmd_name (n), m_init_list (nullptr) { }
 
     tree_decl_command (const std::string& n, tree_decl_init_list *t,
                        int l = -1, int c = -1);
 
     // No copying!
 
     tree_decl_command (const tree_decl_command&) = delete;
 
     tree_decl_command& operator = (const tree_decl_command&) = delete;
 
     ~tree_decl_command (void);
 
     void mark_global (void)
     {
-      if (init_list)
-        init_list->mark_global ();
+      if (m_init_list)
+        m_init_list->mark_global ();
     }
 
     void mark_persistent (void)
     {
-      if (init_list)
-        init_list->mark_persistent ();
+      if (m_init_list)
+        m_init_list->mark_persistent ();
     }
 
-    tree_decl_init_list * initializer_list (void) { return init_list; }
+    tree_decl_init_list * initializer_list (void) { return m_init_list; }
 
-    std::string name (void) const { return cmd_name; }
+    std::string name (void) const { return m_cmd_name; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_command (*this);
     }
 
   private:
 
     // The name of this command -- global, static, etc.
-    std::string cmd_name;
+    std::string m_cmd_name;
 
     // The list of variables or initializers in this declaration command.
-    tree_decl_init_list *init_list;
+    tree_decl_init_list *m_init_list;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_decl_elt' instead")
 typedef octave::tree_decl_elt tree_decl_elt;
 
diff --git a/libinterp/parse-tree/pt-except.cc b/libinterp/parse-tree/pt-except.cc
--- a/libinterp/parse-tree/pt-except.cc
+++ b/libinterp/parse-tree/pt-except.cc
@@ -41,27 +41,27 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 namespace octave
 {
   // Simple exception handling.
 
   tree_try_catch_command::~tree_try_catch_command (void)
   {
-    delete expr_id;
-    delete try_code;
-    delete catch_code;
-    delete lead_comm;
-    delete mid_comm;
-    delete trail_comm;
+    delete m_expr_id;
+    delete m_try_code;
+    delete m_catch_code;
+    delete m_lead_comm;
+    delete m_mid_comm;
+    delete m_trail_comm;
   }
 
   // Simple exception handling.
 
   tree_unwind_protect_command::~tree_unwind_protect_command (void)
   {
-    delete unwind_protect_code;
-    delete cleanup_code;
-    delete lead_comm;
-    delete mid_comm;
-    delete trail_comm;
+    delete m_unwind_protect_code;
+    delete m_cleanup_code;
+    delete m_lead_comm;
+    delete m_mid_comm;
+    delete m_trail_comm;
   }
 }
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -36,136 +36,140 @@ namespace octave
 
   // Simple exception handling.
 
   class tree_try_catch_command : public tree_command
   {
   public:
 
     tree_try_catch_command (int l = -1, int c = -1)
-      : tree_command (l, c),
-        try_code (nullptr), catch_code (nullptr), expr_id (nullptr),
-        lead_comm (nullptr), mid_comm (nullptr), trail_comm (nullptr) { }
+      : tree_command (l, c), m_try_code (nullptr), m_catch_code (nullptr),
+        m_expr_id (nullptr), m_lead_comm (nullptr), m_mid_comm (nullptr),
+        m_trail_comm (nullptr)
+    { }
 
     tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
                             tree_identifier *id,
                             comment_list *cl = nullptr,
                             comment_list *cm = nullptr,
                             comment_list *ct = nullptr,
                             int l = -1, int c = -1)
-      : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
-        lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
+      : tree_command (l, c), m_try_code (tc), m_catch_code (cc),
+        m_expr_id (id), m_lead_comm (cl), m_mid_comm (cm), m_trail_comm (ct)
+    { }
 
     // No copying!
 
     tree_try_catch_command (const tree_try_catch_command&) = delete;
 
     tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
 
     ~tree_try_catch_command (void);
 
-    tree_identifier * identifier (void) { return expr_id; }
+    tree_identifier * identifier (void) { return m_expr_id; }
 
-    tree_statement_list * body (void) { return try_code; }
+    tree_statement_list * body (void) { return m_try_code; }
 
-    tree_statement_list * cleanup (void) { return catch_code; }
+    tree_statement_list * cleanup (void) { return m_catch_code; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * middle_comment (void) { return mid_comm; }
+    comment_list * middle_comment (void) { return m_mid_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_try_catch_command (*this);
     }
 
   private:
 
     // The first block of code to attempt to execute.
-    tree_statement_list *try_code;
+    tree_statement_list *m_try_code;
 
     // The code to execute if an error occurs in the first block.
-    tree_statement_list *catch_code;
+    tree_statement_list *m_catch_code;
 
     // Identifier to modify.
-    tree_identifier *expr_id;
+    tree_identifier *m_expr_id;
 
     // Comment preceding TRY token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding CATCH token.
-    comment_list *mid_comm;
+    comment_list *m_mid_comm;
 
     // Comment preceding END_TRY_CATCH token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 
   // Simple exception handling.
 
   class tree_unwind_protect_command : public tree_command
   {
   public:
 
     tree_unwind_protect_command (int l = -1, int c = -1)
       : tree_command (l, c),
-        unwind_protect_code (nullptr), cleanup_code (nullptr),
-        lead_comm (nullptr), mid_comm (nullptr), trail_comm (nullptr) { }
+        m_unwind_protect_code (nullptr), m_cleanup_code (nullptr),
+        m_lead_comm (nullptr), m_mid_comm (nullptr), m_trail_comm (nullptr)
+    { }
 
     tree_unwind_protect_command (tree_statement_list *tc,
                                  tree_statement_list *cc,
                                  comment_list *cl = nullptr,
                                  comment_list *cm = nullptr,
                                  comment_list *ct = nullptr,
                                  int l = -1, int c = -1)
-      : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
-        lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
+      : tree_command (l, c), m_unwind_protect_code (tc), m_cleanup_code (cc),
+        m_lead_comm (cl), m_mid_comm (cm), m_trail_comm (ct)
+    { }
 
     // No copying!
 
     tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
 
     tree_unwind_protect_command&
     operator = (const tree_unwind_protect_command&) = delete;
 
     ~tree_unwind_protect_command (void);
 
-    tree_statement_list * body (void) { return unwind_protect_code; }
+    tree_statement_list * body (void) { return m_unwind_protect_code; }
 
-    tree_statement_list * cleanup (void) { return cleanup_code; }
+    tree_statement_list * cleanup (void) { return m_cleanup_code; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * middle_comment (void) { return mid_comm; }
+    comment_list * middle_comment (void) { return m_mid_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_unwind_protect_command (*this);
     }
 
   private:
 
     // The first body of code to attempt to execute.
-    tree_statement_list *unwind_protect_code;
+    tree_statement_list *m_unwind_protect_code;
 
     // The body of code to execute no matter what happens in the first
     // body of code.
-    tree_statement_list *cleanup_code;
+    tree_statement_list *m_cleanup_code;
 
     // Comment preceding UNWIND_PROTECT token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding UNWIND_PROTECT_CLEANUP token.
-    comment_list *mid_comm;
+    comment_list *m_mid_comm;
 
     // Comment preceding END_UNWIND_PROTECT token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_try_catch_command' instead")
 typedef octave::tree_try_catch_command tree_try_catch_command;
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -37,23 +37,23 @@ namespace octave
   {
     print_raw (os, pr_as_read_syntax, pr_orig_text);
   }
 
   void
   tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
                               bool pr_orig_text)
   {
-    os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
+    os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << m_name;
   }
 
   tree_expression *
   tree_fcn_handle::dup (symbol_scope&) const
   {
-    tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
+    tree_fcn_handle *new_fh = new tree_fcn_handle (m_name, line (), column ());
 
     new_fh->copy_base (*this);
 
     return new_fh;
   }
 
   tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
   {
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -42,20 +42,20 @@ class octave_value_list;
 
 namespace octave
 {
   class tree_fcn_handle : public tree_expression
   {
   public:
 
     tree_fcn_handle (int l = -1, int c = -1)
-      : tree_expression (l, c), nm () { }
+      : tree_expression (l, c), m_name () { }
 
     tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
-      : tree_expression (l, c), nm (n) { }
+      : tree_expression (l, c), m_name (n) { }
 
     // No copying!
 
     tree_fcn_handle (const tree_fcn_handle&) = delete;
 
     tree_fcn_handle& operator = (const tree_fcn_handle&) = delete;
 
     ~tree_fcn_handle (void) = default;
@@ -63,31 +63,31 @@ namespace octave
     bool has_magic_end (void) const { return false; }
 
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
-    std::string name (void) const { return nm; }
+    std::string name (void) const { return m_name; }
 
     bool rvalue_ok (void) const { return true; }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_fcn_handle (*this);
     }
 
   private:
 
     // The name of this function handle.
-    std::string nm;
+    std::string m_name;
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (nullptr),
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -44,36 +44,37 @@ namespace octave
                            bool pr_orig_text)
   {
     if (pr_orig_text)
       {
         os << original_text ();
       }
     else
       {
-        octave_function *fp = fcn.function_value ();
+        octave_function *fp = m_fcn.function_value ();
         std::string nm = (fp ? fp->name () : "<invalid-function>");
 
         os << nm << " (";
 
-        octave_idx_type n = args.length ();
+        octave_idx_type n = m_args.length ();
         for (octave_idx_type i = 0; i < n; i++)
           {
-            args(i).print_raw (os, pr_as_read_syntax);
+            m_args(i).print_raw (os, pr_as_read_syntax);
 
             if (i < n - 1)
               os << ", ";
           }
 
         os << ')';
       }
   }
 
   tree_funcall *
   tree_funcall::dup (symbol_scope&) const
   {
-    tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
+    tree_funcall *new_fc
+      = new tree_funcall (m_fcn, m_args, line (), column ());
 
     new_fc->copy_base (*new_fc);
 
     return new_fc;
   }
 }
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -39,19 +39,19 @@ namespace octave
   // compile time.
 
   class tree_funcall : public tree_expression
   {
   public:
 
     tree_funcall (const octave_value& f, const octave_value_list& a,
                   int l = -1, int c = -1)
-      : tree_expression (l, c), fcn (f), args (a)
+      : tree_expression (l, c), m_fcn (f), m_args (a)
     {
-      if (! fcn.is_function ())
+      if (! m_fcn.is_function ())
         error ("tree_funcall: invalid function");
     }
 
     // No copying!
 
     tree_funcall (const tree_funcall&) = delete;
 
     tree_funcall& operator = (const tree_funcall&) = delete;
@@ -63,33 +63,33 @@ namespace octave
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     tree_funcall * dup (symbol_scope& scope) const;
 
-    octave_value function (void) const { return fcn; }
+    octave_value function (void) const { return m_fcn; }
 
-    octave_value_list arguments (void) const { return args; }
+    octave_value_list arguments (void) const { return m_args; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_funcall (*this);
     }
 
   private:
 
     // Function to call.  Error if not a valid function at time of
     // construction.
-    octave_value fcn;
+    octave_value m_fcn;
 
     // Argument list.
-    octave_value_list args;
+    octave_value_list m_args;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_funcall' instead")
 typedef octave::tree_funcall tree_funcall;
 
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -38,18 +38,18 @@ namespace octave
 {
   // Symbols from the symbol table.
 
   class tree_evaluator;
 
   void tree_identifier::link_to_global (const symbol_scope& global_scope,
                                         const symbol_record& global_sym)
   {
-    if (! sym.is_global ())
-      sym.bind_fwd_rep (global_scope.get_rep (), global_sym);
+    if (! m_sym.is_global ())
+      m_sym.bind_fwd_rep (global_scope.get_rep (), global_sym);
   }
 
   void
   tree_identifier::eval_undefined_error (void)
   {
     int l = line ();
     int c = column ();
 
@@ -62,22 +62,22 @@ namespace octave
       error_with_id ("Octave:undefined-function",
                      "'%s' undefined near line %d column %d",
                      name ().c_str (), l, c);
   }
 
   octave_lvalue
   tree_identifier::lvalue (tree_evaluator *tw)
   {
-    if (sym.is_added_static ())
+    if (m_sym.is_added_static ())
       static_workspace_error ();
 
     symbol_scope scope = tw->get_current_scope ();
 
-    return octave_lvalue (sym, scope.current_context ());
+    return octave_lvalue (m_sym, scope.current_context ());
   }
 
   tree_identifier *
   tree_identifier::dup (symbol_scope& scope) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -46,44 +46,44 @@ namespace octave
 
   class tree_identifier : public tree_expression
   {
     friend class tree_index_expression;
 
   public:
 
     tree_identifier (int l = -1, int c = -1)
-      : tree_expression (l, c) { }
+      : tree_expression (l, c), m_sym () { }
 
     tree_identifier (const symbol_record& s,
                      int l = -1, int c = -1)
-      : tree_expression (l, c), sym (s) { }
+      : tree_expression (l, c), m_sym (s) { }
 
     // No copying!
 
     tree_identifier (const tree_identifier&) = delete;
 
     tree_identifier& operator = (const tree_identifier&) = delete;
 
     ~tree_identifier (void) = default;
 
     bool has_magic_end (void) const { return (name () == "end"); }
 
     bool is_identifier (void) const { return true; }
 
-    std::string name (void) const { return sym.name (); }
+    std::string name (void) const { return m_sym.name (); }
 
     bool is_defined (symbol_record::context_id context)
     {
-      return sym.is_defined (context);
+      return m_sym.is_defined (context);
     }
 
     virtual bool is_variable (symbol_record::context_id context) const
     {
-      return sym.is_variable (context);
+      return m_sym.is_variable (context);
     }
 
     virtual bool is_black_hole (void) { return false; }
 
     // Try to find a definition for an identifier.  Here's how:
     //
     //   * If the identifier is already defined and is a function defined
     //     in an function file that has been modified since the last time
@@ -97,25 +97,25 @@ namespace octave
     //
     //   * On systems that support dynamic linking, we prefer .oct files,
     //     then .mex files, then .m files.
 
     octave_value
     do_lookup (symbol_record::context_id context,
                const octave_value_list& args = octave_value_list ())
     {
-      return sym.find (context, args);
+      return m_sym.find (context, args);
     }
 
     void link_to_global (const symbol_scope& global_scope,
                          const symbol_record& global_sym);
 
-    void mark_persistent (void) { sym.init_persistent (); }
+    void mark_persistent (void) { m_sym.init_persistent (); }
 
-    void mark_as_formal_parameter (void) { sym.mark_formal (); }
+    void mark_as_formal_parameter (void) { m_sym.mark_formal (); }
 
     // We really need to know whether this symbol referst to a variable
     // or a function, but we may not know that yet.
 
     bool lvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *);
 
@@ -129,25 +129,22 @@ namespace octave
 
     tree_identifier * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_identifier (*this);
     }
 
-    symbol_record symbol (void) const
-    {
-      return sym;
-    }
+    symbol_record symbol (void) const { return m_sym; }
 
   private:
 
     // The symbol record that this identifier references.
-    symbol_record sym;
+    symbol_record m_sym;
   };
 
   class tree_black_hole : public tree_identifier
   {
   public:
 
     tree_black_hole (int l = -1, int c = -1)
       : tree_identifier (l, c) { }
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -39,137 +39,137 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "errwarn.h"
 
 namespace octave
 {
   // Index expressions.
 
   tree_index_expression::tree_index_expression (int l, int c)
-    : tree_expression (l, c), expr (nullptr), args (0), type (),
-      arg_nm (), dyn_field () { }
+    : tree_expression (l, c), m_expr (nullptr), m_args (0), m_type (),
+      m_arg_nm (), m_dyn_field () { }
 
   tree_index_expression::tree_index_expression (tree_expression *e,
                                                 tree_argument_list *lst,
                                                 int l, int c, char t)
-    : tree_expression (l, c), expr (e), args (0), type (),
-      arg_nm (), dyn_field ()
+    : tree_expression (l, c), m_expr (e), m_args (0), m_type (),
+      m_arg_nm (), m_dyn_field ()
   {
     append (lst, t);
   }
 
   tree_index_expression::tree_index_expression (tree_expression *e,
                                                 const std::string& n,
                                                 int l, int c)
-    : tree_expression (l, c), expr (e), args (0), type (),
-      arg_nm (), dyn_field ()
+    : tree_expression (l, c), m_expr (e), m_args (0), m_type (),
+      m_arg_nm (), m_dyn_field ()
   {
     append (n);
   }
 
   tree_index_expression::tree_index_expression (tree_expression *e,
                                                 tree_expression *df,
                                                 int l, int c)
-    : tree_expression (l, c), expr (e), args (0), type (),
-      arg_nm (), dyn_field ()
+    : tree_expression (l, c), m_expr (e), m_args (0), m_type (),
+      m_arg_nm (), m_dyn_field ()
   {
     append (df);
   }
 
   void
   tree_index_expression::append (tree_argument_list *lst, char t)
   {
-    args.push_back (lst);
-    type.append (1, t);
-    arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
-    dyn_field.push_back (static_cast<tree_expression *> (nullptr));
+    m_args.push_back (lst);
+    m_type.append (1, t);
+    m_arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
+    m_dyn_field.push_back (static_cast<tree_expression *> (nullptr));
 
     if (lst && lst->has_magic_tilde ())
       error ("invalid use of empty argument (~) in index expression");
   }
 
   void
   tree_index_expression::append (const std::string& n)
   {
-    args.push_back (static_cast<tree_argument_list *> (nullptr));
-    type += '.';
-    arg_nm.push_back (n);
-    dyn_field.push_back (static_cast<tree_expression *> (nullptr));
+    m_args.push_back (static_cast<tree_argument_list *> (nullptr));
+    m_type += '.';
+    m_arg_nm.push_back (n);
+    m_dyn_field.push_back (static_cast<tree_expression *> (nullptr));
   }
 
   void
   tree_index_expression::append (tree_expression *df)
   {
-    args.push_back (static_cast<tree_argument_list *> (nullptr));
-    type += '.';
-    arg_nm.push_back ("");
-    dyn_field.push_back (df);
+    m_args.push_back (static_cast<tree_argument_list *> (nullptr));
+    m_type += '.';
+    m_arg_nm.push_back ("");
+    m_dyn_field.push_back (df);
   }
 
   tree_index_expression::~tree_index_expression (void)
   {
-    delete expr;
+    delete m_expr;
 
-    while (! args.empty ())
+    while (! m_args.empty ())
       {
-        std::list<tree_argument_list *>::iterator p = args.begin ();
+        std::list<tree_argument_list *>::iterator p = m_args.begin ();
         delete *p;
-        args.erase (p);
+        m_args.erase (p);
       }
 
-    while (! dyn_field.empty ())
+    while (! m_dyn_field.empty ())
       {
-        std::list<tree_expression *>::iterator p = dyn_field.begin ();
+        std::list<tree_expression *>::iterator p = m_dyn_field.begin ();
         delete *p;
-        dyn_field.erase (p);
+        m_dyn_field.erase (p);
       }
   }
 
   bool
   tree_index_expression::has_magic_end (void) const
   {
-    for (const tree_argument_list *elt : args)
+    for (const tree_argument_list *elt : m_args)
       {
         if (elt && elt->has_magic_end ())
           return true;
       }
 
     return false;
   }
 
   // This is useful for printing the name of the variable in an indexed
   // assignment.
 
   std::string
   tree_index_expression::name (void) const
   {
-    return expr->name ();
+    return m_expr->name ();
   }
 
   static inline octave_value_list
   make_value_list (octave::tree_evaluator *tw,
-                   octave::tree_argument_list *args,
-                   const string_vector& arg_nm, const octave_value *object,
+                   octave::tree_argument_list *m_args,
+                   const string_vector& m_arg_nm, const octave_value *object,
                    bool rvalue = true)
   {
     octave_value_list retval;
 
-    if (args)
+    if (m_args)
       {
-        if (rvalue && object && args->has_magic_end ()
+        if (rvalue && object && m_args->has_magic_end ()
             && object->is_undefined ())
           err_invalid_inquiry_subscript ();
 
-        retval = args->convert_to_const_vector (tw, object);
+        retval = m_args->convert_to_const_vector (tw, object);
       }
 
     octave_idx_type n = retval.length ();
 
     if (n > 0)
-      retval.stash_name_tags (arg_nm);
+      retval.stash_name_tags (m_arg_nm);
 
     return retval;
   }
 
   std::string
   tree_index_expression::get_struct_index
   (tree_evaluator *tw,
    std::list<string_vector>::const_iterator p_arg_nm,
@@ -235,60 +235,60 @@ namespace octave
   octave_lvalue
   tree_index_expression::lvalue (tree_evaluator *tw)
   {
     octave_lvalue retval;
 
     std::list<octave_value_list> idx;
     std::string tmp_type;
 
-    int n = args.size ();
+    int n = m_args.size ();
 
-    std::list<tree_argument_list *>::iterator p_args = args.begin ();
-    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+    std::list<tree_argument_list *>::iterator p_args = m_args.begin ();
+    std::list<string_vector>::iterator p_arg_nm = m_arg_nm.begin ();
+    std::list<tree_expression *>::iterator p_dyn_field = m_dyn_field.begin ();
 
-    retval = expr->lvalue (tw);
+    retval = m_expr->lvalue (tw);
 
     octave_value tmp = retval.value ();
 
     octave_idx_type tmpi = 0;
     std::list<octave_value_list> tmpidx;
 
     for (int i = 0; i < n; i++)
       {
         if (retval.numel () != 1)
           err_indexed_cs_list ();
 
         if (tmpi < i)
           {
             try
               {
-                tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
+                tmp = tmp.subsref (m_type.substr (tmpi, i-tmpi), tmpidx, true);
               }
             catch (index_exception& e)  // problems with range, invalid type etc.
               {
-                final_index_error (e, expr);
+                final_index_error (e, m_expr);
               }
 
             tmpidx.clear ();
           }
 
-        switch (type[i])
+        switch (m_type[i])
           {
           case '(':
             {
               octave_value_list tidx
                 = make_value_list (tw, *p_args, *p_arg_nm, &tmp, false);
 
               idx.push_back (tidx);
 
               if (i < n - 1)
                 {
-                  if (type[i+1] != '.')
+                  if (m_type[i+1] != '.')
                     error ("() must be followed by . or close the index chain");
 
                   tmpidx.push_back (tidx);
                   tmpi = i+1;
                 }
             }
             break;
 
@@ -321,17 +321,17 @@ namespace octave
           case '.':
             {
               octave_value tidx = get_struct_index (tw, p_arg_nm, p_dyn_field);
 
               bool autoconv = (tmp.is_zero_by_zero ()
                                && (tmp.is_matrix_type () || tmp.is_string ()
                                    || tmp.iscell ()));
 
-              if (i > 0 && type[i-1] == '(')
+              if (i > 0 && m_type[i-1] == '(')
                 {
                   octave_value_list pidx = idx.back ();
 
                   // Use octave_map, not octave_scalar_map so that the
                   // dimensions are 0x0, not 1x1.
                   if (tmp.is_undefined ())
                     {
                       if (pidx.has_magic_colon ())
@@ -374,46 +374,46 @@ namespace octave
         if (idx.back ().empty ())
           error ("invalid empty index list");
 
         p_args++;
         p_arg_nm++;
         p_dyn_field++;
       }
 
-    retval.set_index (type, idx);
+    retval.set_index (m_type, idx);
 
     return retval;
   }
 
   tree_index_expression *
   tree_index_expression::dup (symbol_scope& scope) const
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
-    new_idx_expr->expr = (expr ? expr->dup (scope) : nullptr);
+    new_idx_expr->m_expr = (m_expr ? m_expr->dup (scope) : nullptr);
 
     std::list<tree_argument_list *> new_args;
 
-    for (const tree_argument_list *elt : args)
+    for (const tree_argument_list *elt : m_args)
       new_args.push_back (elt ? elt->dup (scope) : nullptr);
 
-    new_idx_expr->args = new_args;
+    new_idx_expr->m_args = new_args;
 
-    new_idx_expr->type = type;
+    new_idx_expr->m_type = m_type;
 
-    new_idx_expr->arg_nm = arg_nm;
+    new_idx_expr->m_arg_nm = m_arg_nm;
 
     std::list<tree_expression *> new_dyn_field;
 
-    for (const tree_expression *elt : dyn_field)
+    for (const tree_expression *elt : m_dyn_field)
       new_dyn_field.push_back (elt ? elt->dup (scope) : nullptr);
 
-    new_idx_expr->dyn_field = new_dyn_field;
+    new_idx_expr->m_dyn_field = new_dyn_field;
 
     new_idx_expr->copy_base (*this);
 
     return new_idx_expr;
   }
 }
 
 /*
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -44,17 +44,18 @@ namespace octave
   class tree_evaluator;
 
   // Index expressions.
 
   class tree_index_expression : public tree_expression
   {
   public:
 
-    tree_index_expression (tree_expression *e = nullptr, tree_argument_list *lst = nullptr,
+    tree_index_expression (tree_expression *e = nullptr,
+                           tree_argument_list *lst = nullptr,
                            int l = -1, int c = -1, char t = '(');
 
     tree_index_expression (tree_expression *e, const std::string& n,
                            int l = -1, int c = -1);
 
     tree_index_expression (tree_expression *e, tree_expression *df,
                            int l = -1, int c = -1);
 
@@ -73,27 +74,27 @@ namespace octave
     void append (const std::string& n);
 
     void append (tree_expression *df);
 
     bool is_index_expression (void) const { return true; }
 
     std::string name (void) const;
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expr; }
 
-    std::list<tree_argument_list *> arg_lists (void) { return args; }
+    std::list<tree_argument_list *> arg_lists (void) { return m_args; }
 
-    std::string type_tags (void) { return type; }
+    std::string type_tags (void) { return m_type; }
 
-    std::list<string_vector> arg_names (void) { return arg_nm; }
+    std::list<string_vector> arg_names (void) { return m_arg_nm; }
 
-    std::list<tree_expression *> dyn_fields (void) { return dyn_field; }
+    std::list<tree_expression *> dyn_fields (void) { return m_dyn_field; }
 
-    bool lvalue_ok (void) const { return expr->lvalue_ok (); }
+    bool lvalue_ok (void) const { return m_expr->lvalue_ok (); }
 
     bool rvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *tw);
 
     tree_index_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
@@ -104,30 +105,30 @@ namespace octave
     std::string
     get_struct_index
     (tree_evaluator *tw, std::list<string_vector>::const_iterator p_arg_nm,
      std::list<tree_expression *>::const_iterator p_dyn_field) const;
 
   private:
 
     // The LHS of this index expression.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // The indices (only valid if type == paren || type == brace).
-    std::list<tree_argument_list *> args;
+    std::list<tree_argument_list *> m_args;
 
     // The type of this index expression.
-    std::string type;
+    std::string m_type;
 
     // The names of the arguments.  Used for constant struct element
     // references.
-    std::list<string_vector> arg_nm;
+    std::list<string_vector> m_arg_nm;
 
     // The list of dynamic field names, if any.
-    std::list<tree_expression *> dyn_field;
+    std::list<tree_expression *> m_dyn_field;
 
     tree_index_expression (int l, int c);
 
     octave_map make_arg_struct (void) const;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -39,16 +39,19 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "pt-all.h"
 #include "pt-jit.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "variables.h"
 #include "interpreter-private.h"
 
+// Programming Note: As of hg id 2b2c8ac44cd2, this file builds with
+// LLVM 3.8 but not with 3.9 (or probably any later version).
+
 #if defined (HAVE_LLVM)
 
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 
 #if defined (HAVE_LLVM_IR_VERIFIER_H)
 #  include <llvm/IR/Verifier.h>
 #else
@@ -125,51 +128,51 @@ namespace octave
   // jit_break is thrown whenever a branch we are converting has only breaks or
   // continues.  This is because all code that follows a break or continue
   // is dead.
   class jit_break_exception : public std::exception
   { };
 
   // -------------------- jit_convert --------------------
   jit_convert::jit_convert (tree& tee, jit_type *for_bounds)
-    : converting_function (false)
+    : m_converting_function (false)
   {
     initialize (__get_current_scope__ ("jit_convert::jit_convert"));
 
     if (for_bounds)
       create_variable (next_for_bounds (false), for_bounds);
 
     try
       {
         visit (tee);
       }
     catch (const jit_break_exception&)
       { }
 
     // breaks must have been handled by the top level loop
-    assert (breaks.empty ());
-    assert (continues.empty ());
-
-    block->append (factory.create<jit_branch> (final_block));
-    blocks.push_back (final_block);
-
-    for (variable_map::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+    assert (m_breaks.empty ());
+    assert (m_continues.empty ());
+
+    m_block->append (m_factory.create<jit_branch> (m_final_block));
+    m_blocks.push_back (m_final_block);
+
+    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
       {
         jit_variable *var = iter->second;
         const std::string& name = var->name ();
         if (name.size () && name[0] != '#')
-          final_block->append (factory.create<jit_store_argument> (var));
+          m_final_block->append (m_factory.create<jit_store_argument> (var));
       }
 
-    final_block->append (factory.create<jit_return> ());
+    m_final_block->append (m_factory.create<jit_return> ());
   }
 
   jit_convert::jit_convert (octave_user_function& fcn,
                             const std::vector<jit_type *>& args)
-    : converting_function (true)
+    : m_converting_function (true)
   {
     initialize (fcn.scope ());
 
     tree_parameter_list *plist = fcn.parameter_list ();
     tree_parameter_list *rlist = fcn.return_list ();
     if (plist && plist->takes_varargs ())
       throw jit_fail_exception ("varags not supported");
 
@@ -201,69 +204,69 @@ namespace octave
             jit_value *retval = nullptr;
             try
               {
                 retval = visit (expr);
               }
             catch (const jit_break_exception&)
               { }
 
-            if (breaks.size () || continues.size ())
+            if (m_breaks.size () || m_continues.size ())
               throw jit_fail_exception ("break/continue not supported in "
                                         "anonymous functions");
 
-            block->append (factory.create<jit_assign> (retvar, retval));
+            m_block->append (m_factory.create<jit_assign> (retvar, retval));
             return_value = retvar;
           }
       }
     else
       {
         try
           {
             visit_statement_list (*fcn.body ());
           }
         catch (const jit_break_exception&)
           {
             all_breaking = true;
           }
 
         // the user may use break or continue to exit the function
-        finish_breaks (final_block, continues);
-        finish_breaks (final_block, breaks);
+        finish_breaks (m_final_block, m_continues);
+        finish_breaks (m_final_block, m_breaks);
       }
 
     if (! all_breaking)
-      block->append (factory.create<jit_branch> (final_block));
-
-    blocks.push_back (final_block);
-    block = final_block;
+      m_block->append (m_factory.create<jit_branch> (m_final_block));
+
+    m_blocks.push_back (m_final_block);
+    m_block = m_final_block;
 
     if (! return_value && rlist && rlist->size () == 1)
       {
         tree_decl_elt *elt = rlist->front ();
         return_value = get_variable (elt->name ());
       }
 
     // FIXME: We should use live range analysis to delete variables where needed.
     // For now we just delete everything at the end of the function.
-    for (variable_map::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+    for (variable_map::iterator iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
       {
         if (iter->second != return_value)
           {
             jit_call *call;
-            call = factory.create<jit_call> (&jit_typeinfo::destroy,
+            call = m_factory.create<jit_call> (&jit_typeinfo::destroy,
                                              iter->second);
-            final_block->append (call);
+            m_final_block->append (call);
           }
       }
 
     if (return_value)
-      final_block->append (factory.create<jit_return> (return_value));
+      m_final_block->append (m_factory.create<jit_return> (return_value));
     else
-      final_block->append (factory.create<jit_return> ());
+      m_final_block->append (m_factory.create<jit_return> ());
   }
 
   void
   jit_convert::visit_anon_fcn_handle (tree_anon_fcn_handle&)
   {
     throw jit_fail_exception ("No visit_anon_fcn_handle implementation");
   }
 
@@ -278,94 +281,94 @@ namespace octave
   {
     tree_expression *lhs = be.lhs ();
     jit_value *lhsv = visit (lhs);
 
     tree_expression *rhs = be.rhs ();
     jit_value *rhsv = visit (rhs);
 
     const jit_operation& fn = jit_typeinfo::binary_op (be.op_type ());
-    result = create_checked (fn, lhsv, rhsv);
+    m_result = create_checked (fn, lhsv, rhsv);
   }
 
   void
   jit_convert::visit_boolean_expression (tree_boolean_expression& be)
   {
     bool is_and = be.op_type () == tree_boolean_expression::bool_and;
 
     std::string short_name = next_shortcircut_result ();
-    jit_variable *short_result = factory.create<jit_variable> (short_name);
-    vmap[short_name] = short_result;
-
-    jit_block *done = factory.create<jit_block> (block->name ());
+    jit_variable *short_result = m_factory.create<jit_variable> (short_name);
+    m_vmap[short_name] = short_result;
+
+    jit_block *done = m_factory.create<jit_block> (m_block->name ());
     tree_expression *lhs = be.lhs ();
     jit_value *lhsv = visit (lhs);
     lhsv = create_checked (&jit_typeinfo::logically_true, lhsv);
 
-    jit_block *short_early = factory.create<jit_block> ("short_early");
-    blocks.push_back (short_early);
-
-    jit_block *short_cont = factory.create<jit_block> ("short_cont");
+    jit_block *short_early = m_factory.create<jit_block> ("short_early");
+    m_blocks.push_back (short_early);
+
+    jit_block *short_cont = m_factory.create<jit_block> ("short_cont");
 
     if (is_and)
-      block->append (factory.create<jit_cond_branch> (lhsv, short_cont,
+      m_block->append (m_factory.create<jit_cond_branch> (lhsv, short_cont,
                                                       short_early));
     else
-      block->append (factory.create<jit_cond_branch> (lhsv, short_early,
+      m_block->append (m_factory.create<jit_cond_branch> (lhsv, short_early,
                                                       short_cont));
 
-    block = short_early;
-
-    jit_value *early_result = factory.create<jit_const_bool> (! is_and);
-    block->append (factory.create<jit_assign> (short_result, early_result));
-    block->append (factory.create<jit_branch> (done));
-
-    blocks.push_back (short_cont);
-    block = short_cont;
+    m_block = short_early;
+
+    jit_value *early_result = m_factory.create<jit_const_bool> (! is_and);
+    m_block->append (m_factory.create<jit_assign> (short_result, early_result));
+    m_block->append (m_factory.create<jit_branch> (done));
+
+    m_blocks.push_back (short_cont);
+    m_block = short_cont;
 
     tree_expression *rhs = be.rhs ();
     jit_value *rhsv = visit (rhs);
     rhsv = create_checked (&jit_typeinfo::logically_true, rhsv);
-    block->append (factory.create<jit_assign> (short_result, rhsv));
-    block->append (factory.create<jit_branch> (done));
-
-    blocks.push_back (done);
-    block = done;
-    result = short_result;
+    m_block->append (m_factory.create<jit_assign> (short_result, rhsv));
+    m_block->append (m_factory.create<jit_branch> (done));
+
+    m_blocks.push_back (done);
+    m_block = done;
+    m_result = short_result;
   }
 
   void
   jit_convert::visit_break_command (tree_break_command&)
   {
-    breaks.push_back (block);
+    m_breaks.push_back (m_block);
     throw jit_break_exception ();
   }
 
   void
   jit_convert::visit_colon_expression (tree_colon_expression& expr)
   {
     // in the futher we need to add support for classes and deal with rvalues
     jit_value *base = visit (expr.base ());
     jit_value *limit = visit (expr.limit ());
     jit_value *increment;
     tree_expression *tinc = expr.increment ();
 
     if (tinc)
       increment = visit (tinc);
     else
-      increment = factory.create<jit_const_scalar> (1);
-
-    result = block->append (factory.create<jit_call> (jit_typeinfo::make_range,
+      increment = m_factory.create<jit_const_scalar> (1);
+
+    m_result = m_block->append (m_factory.create<jit_call> (jit_typeinfo::make_range,
                                                       base, limit, increment));
   }
 
   void
   jit_convert::visit_continue_command (tree_continue_command&)
   {
-    continues.push_back (block);
+    m_continues.push_back (m_block);
     throw jit_break_exception ();
   }
 
   void
 jit_convert::visit_decl_command (tree_decl_command&)
 {
   throw jit_fail_exception ("No visit_decl_command implementation");
 }
@@ -386,108 +389,108 @@ void
   jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
   {
     // Note we do an initial check to see if the loop will run atleast once.
     // This allows us to get better type inference bounds on variables defined
     // and used only inside the for loop (e.g., the index variable)
 
     // If we are a nested for loop we need to store the previous breaks
     unwind_protect frame;
-    frame.protect_var (breaks);
-    frame.protect_var (continues);
-    breaks.clear ();
-    continues.clear ();
+    frame.protect_var (m_breaks);
+    frame.protect_var (m_continues);
+    m_breaks.clear ();
+    m_continues.clear ();
 
     // we need a variable for our iterator, because it is used in multiple blocks
     std::string iter_name = next_iterator ();
-    jit_variable *iterator = factory.create<jit_variable> (iter_name);
-    factory.create<jit_variable> (iter_name);
-    vmap[iter_name] = iterator;
-
-    jit_block *body = factory.create<jit_block> ("for_body");
-    jit_block *tail = factory.create<jit_block> ("for_tail");
+    jit_variable *iterator = m_factory.create<jit_variable> (iter_name);
+    m_factory.create<jit_variable> (iter_name);
+    m_vmap[iter_name] = iterator;
+
+    jit_block *body = m_factory.create<jit_block> ("for_body");
+    jit_block *tail = m_factory.create<jit_block> ("for_tail");
 
     // do control expression, iter init, and condition check in prev_block (block)
     // if we are the top level for loop, the bounds is an input argument.
     jit_value *control = find_variable (next_for_bounds ());
     if (! control)
       control = visit (cmd.control_expr ());
-    jit_call *init_iter = factory.create<jit_call> (jit_typeinfo::for_init,
+    jit_call *init_iter = m_factory.create<jit_call> (jit_typeinfo::for_init,
                                                     control);
-    block->append (init_iter);
-    block->append (factory.create<jit_assign> (iterator, init_iter));
-
-    jit_call *check = factory.create<jit_call> (jit_typeinfo::for_check, control,
+    m_block->append (init_iter);
+    m_block->append (m_factory.create<jit_assign> (iterator, init_iter));
+
+    jit_call *check = m_factory.create<jit_call> (jit_typeinfo::for_check, control,
                                                 iterator);
-    block->append (check);
-    block->append (factory.create<jit_cond_branch> (check, body, tail));
-
-    blocks.push_back (body);
-    block = body;
+    m_block->append (check);
+    m_block->append (m_factory.create<jit_cond_branch> (check, body, tail));
+
+    m_blocks.push_back (body);
+    m_block = body;
 
     // compute the syntactical iterator
-    jit_call *idx_rhs = factory.create<jit_call> (jit_typeinfo::for_index,
+    jit_call *idx_rhs = m_factory.create<jit_call> (jit_typeinfo::for_index,
                                                   control, iterator);
-    block->append (idx_rhs);
+    m_block->append (idx_rhs);
     do_assign (cmd.left_hand_side (), idx_rhs);
 
     // do loop
     tree_statement_list *pt_body = cmd.body ();
     bool all_breaking = false;
     try
       {
         pt_body->accept (*this);
       }
     catch (const jit_break_exception&)
       {
-        if (continues.empty ())
+        if (m_continues.empty ())
           {
             // WTF are you doing user? Every branch was a break, why did you have
             // a loop??? Users are silly people...
-            finish_breaks (tail, breaks);
-            blocks.push_back (tail);
-            block = tail;
+            finish_breaks (tail, m_breaks);
+            m_blocks.push_back (tail);
+            m_block = tail;
             return;
           }
 
         all_breaking = true;
       }
 
     // check our condition, continues jump to this block
-    jit_block *check_block = factory.create<jit_block> ("for_check");
-    blocks.push_back (check_block);
-
-    jit_block *interrupt_check = factory.create<jit_block> ("for_interrupt");
-    blocks.push_back (interrupt_check);
+    jit_block *check_block = m_factory.create<jit_block> ("for_check");
+    m_blocks.push_back (check_block);
+
+    jit_block *interrupt_check = m_factory.create<jit_block> ("for_interrupt");
+    m_blocks.push_back (interrupt_check);
 
     if (! all_breaking)
-      block->append (factory.create<jit_branch> (check_block));
-    finish_breaks (check_block, continues);
-
-    block = check_block;
+      m_block->append (m_factory.create<jit_branch> (check_block));
+    finish_breaks (check_block, m_continues);
+
+    m_block = check_block;
     const jit_operation& add_fn = jit_typeinfo::binary_op (octave_value::op_add);
-    jit_value *one = factory.create<jit_const_index> (1);
-    jit_call *iter_inc = factory.create<jit_call> (add_fn, iterator, one);
-    block->append (iter_inc);
-    block->append (factory.create<jit_assign> (iterator, iter_inc));
-    check = block->append (factory.create<jit_call> (jit_typeinfo::for_check,
+    jit_value *one = m_factory.create<jit_const_index> (1);
+    jit_call *iter_inc = m_factory.create<jit_call> (add_fn, iterator, one);
+    m_block->append (iter_inc);
+    m_block->append (m_factory.create<jit_assign> (iterator, iter_inc));
+    check = m_block->append (m_factory.create<jit_call> (jit_typeinfo::for_check,
                                                      control, iterator));
-    block->append (factory.create<jit_cond_branch> (check, interrupt_check,
+    m_block->append (m_factory.create<jit_cond_branch> (check, interrupt_check,
                                                     tail));
 
-    block = interrupt_check;
+    m_block = interrupt_check;
     jit_error_check *ec
-      = factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                         body, final_block);
-    block->append (ec);
+      = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
+                                         body, m_final_block);
+    m_block->append (ec);
 
     // breaks will go to our tail
-    blocks.push_back (tail);
-    finish_breaks (tail, breaks);
-    block = tail;
+    m_blocks.push_back (tail);
+    finish_breaks (tail, m_breaks);
+    m_block = tail;
   }
 
   void
   jit_convert::visit_complex_for_command (tree_complex_for_command&)
   {
     throw jit_fail_exception ("No visit_complex_for_command implementation");
   }
 
@@ -521,26 +524,26 @@ void
     throw jit_fail_exception ("No visit_function_def implementation");
   }
 
   void
   jit_convert::visit_identifier (tree_identifier& ti)
   {
     if (ti.has_magic_end ())
       {
-        if (! end_context.size ())
+        if (! m_end_context.size ())
           throw jit_fail_exception ("Illegal end");
-        result = block->append (factory.create<jit_magic_end> (end_context));
+        m_result = m_block->append (m_factory.create<jit_magic_end> (m_end_context));
       }
     else
       {
         jit_variable *var = get_variable (ti.name ());
         jit_instruction *instr;
-        instr = factory.create<jit_call> (&jit_typeinfo::grab, var);
-        result = block->append (instr);
+        instr = m_factory.create<jit_call> (&jit_typeinfo::grab, var);
+        m_result = m_block->append (instr);
       }
   }
 
   void
   jit_convert::visit_if_clause (tree_if_clause&)
   {
     throw jit_fail_exception ("No visit_if_clause implementation");
   }
@@ -558,100 +561,100 @@ void
   {
     tree_if_clause *last = lst.back ();
     size_t last_else = static_cast<size_t> (last->is_else_clause ());
 
     // entry_blocks represents the block you need to enter in order to execute
     // the condition check for the ith clause.  For the else, it is simple the
     // else body.  If there is no else body, then it is padded with the tail.
     std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
-    entry_blocks[0] = block;
+    entry_blocks[0] = m_block;
 
     // we need to construct blocks first, because they have jumps to each other.
     tree_if_command_list::iterator iter = lst.begin ();
     ++iter;
     for (size_t i = 1; iter != lst.end (); ++iter, ++i)
       {
         tree_if_clause *tic = *iter;
         if (tic->is_else_clause ())
-          entry_blocks[i] = factory.create<jit_block> ("else");
+          entry_blocks[i] = m_factory.create<jit_block> ("else");
         else
-          entry_blocks[i] = factory.create<jit_block> ("ifelse_cond");
+          entry_blocks[i] = m_factory.create<jit_block> ("ifelse_cond");
       }
 
-    jit_block *tail = factory.create<jit_block> ("if_tail");
+    jit_block *tail = m_factory.create<jit_block> ("if_tail");
     if (! last_else)
       entry_blocks[entry_blocks.size () - 1] = tail;
 
     // each branch in the if statement will have different breaks/continues
-    block_list current_breaks = breaks;
-    block_list current_continues = continues;
-    breaks.clear ();
-    continues.clear ();
+    block_list current_breaks = m_breaks;
+    block_list current_continues = m_continues;
+    m_breaks.clear ();
+    m_continues.clear ();
 
     size_t num_incomming = 0; // number of incomming blocks to our tail
     iter = lst.begin ();
     for (size_t i = 0; iter != lst.end (); ++iter, ++i)
       {
         tree_if_clause *tic = *iter;
-        block = entry_blocks[i];
-        assert (block);
+        m_block = entry_blocks[i];
+        assert (m_block);
 
         if (i) // the first block is prev_block, so it has already been added
-          blocks.push_back (entry_blocks[i]);
+          m_blocks.push_back (entry_blocks[i]);
 
         if (! tic->is_else_clause ())
           {
             tree_expression *expr = tic->condition ();
             jit_value *cond = visit (expr);
             jit_call *check = create_checked (&jit_typeinfo::logically_true,
                                               cond);
-            jit_block *body = factory.create<jit_block> (i == 0 ? "if_body"
+            jit_block *body = m_factory.create<jit_block> (i == 0 ? "if_body"
                                                          : "ifelse_body");
-            blocks.push_back (body);
-
-            jit_instruction *br = factory.create<jit_cond_branch> (check, body,
+            m_blocks.push_back (body);
+
+            jit_instruction *br = m_factory.create<jit_cond_branch> (check, body,
                                                                    entry_blocks[i + 1]);
-            block->append (br);
-            block = body;
+            m_block->append (br);
+            m_block = body;
           }
 
         tree_statement_list *stmt_lst = tic->commands ();
         assert (stmt_lst); // jwe: Can this be null?
 
         try
           {
             stmt_lst->accept (*this);
             ++num_incomming;
-            block->append (factory.create<jit_branch> (tail));
+            m_block->append (m_factory.create<jit_branch> (tail));
           }
         catch (const jit_break_exception&)
           { }
 
-        current_breaks.splice (current_breaks.end (), breaks);
-        current_continues.splice (current_continues.end (), continues);
+        current_breaks.splice (current_breaks.end (), m_breaks);
+        current_continues.splice (current_continues.end (), m_continues);
       }
 
-    breaks.splice (breaks.end (), current_breaks);
-    continues.splice (continues.end (), current_continues);
+    m_breaks.splice (m_breaks.end (), current_breaks);
+    m_continues.splice (m_continues.end (), current_continues);
 
     if (num_incomming || ! last_else)
       {
-        blocks.push_back (tail);
-        block = tail;
+        m_blocks.push_back (tail);
+        m_block = tail;
       }
     else
       // every branch broke, so we don't have a tail
       throw jit_break_exception ();
   }
 
   void
   jit_convert::visit_index_expression (tree_index_expression& exp)
   {
-    result = resolve (exp);
+    m_result = resolve (exp);
   }
 
   void
   jit_convert::visit_matrix (tree_matrix&)
   {
     throw jit_fail_exception ("No visit_matrix implementation");
   }
 
@@ -678,27 +681,27 @@ void
   {
     octave_value v = tc.value ();
 
     jit_type *ty = jit_typeinfo::type_of (v);
 
     if (ty == jit_typeinfo::get_scalar ())
       {
         double dv = v.double_value ();
-        result = factory.create<jit_const_scalar> (dv);
+        m_result = m_factory.create<jit_const_scalar> (dv);
       }
     else if (ty == jit_typeinfo::get_range ())
       {
         Range rv = v.range_value ();
-        result = factory.create<jit_const_range> (rv);
+        m_result = m_factory.create<jit_const_range> (rv);
       }
     else if (ty == jit_typeinfo::get_complex ())
       {
         Complex cv = v.complex_value ();
-        result = factory.create<jit_const_complex> (cv);
+        m_result = m_factory.create<jit_const_complex> (cv);
       }
     else
       throw jit_fail_exception ("Unknown constant");
   }
 
   void
   jit_convert::visit_fcn_handle (tree_fcn_handle&)
   {
@@ -720,36 +723,36 @@ void
   void
   jit_convert::visit_postfix_expression (tree_postfix_expression& tpe)
   {
     octave_value::unary_op etype = tpe.op_type ();
     tree_expression *operand = tpe.operand ();
     jit_value *operandv = visit (operand);
 
     const jit_operation& fn = jit_typeinfo::unary_op (etype);
-    result = create_checked (fn, operandv);
+    m_result = create_checked (fn, operandv);
 
     if (etype == octave_value::op_incr || etype == octave_value::op_decr)
       {
         jit_value *ret = create_checked (&jit_typeinfo::grab, operandv);
-        do_assign (operand, result);
-        result = ret;
+        do_assign (operand, m_result);
+        m_result = ret;
       }
   }
 
   void
   jit_convert::visit_prefix_expression (tree_prefix_expression& tpe)
   {
     octave_value::unary_op etype = tpe.op_type ();
     tree_expression *operand = tpe.operand ();
     const jit_operation& fn = jit_typeinfo::unary_op (etype);
-    result = create_checked (fn, visit (operand));
+    m_result = create_checked (fn, visit (operand));
 
     if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-      do_assign (operand, result);
+      do_assign (operand, m_result);
   }
 
   void
   jit_convert::visit_return_command (tree_return_command&)
   {
     throw jit_fail_exception ("No visit_return_command implementation");
   }
 
@@ -772,17 +775,17 @@ void
         // This is always correct, but it isn't always optimal.
         tree_expression *lhs = tsa.left_hand_side ();
         jit_value *lhsv = visit (lhs);
         octave_value::binary_op bop = octave_value::assign_op_to_binary_op (op);
         const jit_operation& fn = jit_typeinfo::binary_op (bop);
         rhsv = create_checked (fn, lhsv, rhsv);
       }
 
-    result = do_assign (tsa.left_hand_side (), rhsv);
+    m_result = do_assign (tsa.left_hand_side (), rhsv);
   }
 
   void
   jit_convert::visit_statement (tree_statement& stmt)
   {
     tree_command *cmd = stmt.command ();
     tree_expression *expr = stmt.expression ();
 
@@ -792,33 +795,33 @@ void
       {
         // stolen from octave::tree_evaluator::visit_statement
         bool do_bind_ans = false;
 
         if (expr->is_identifier ())
           {
             tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-            do_bind_ans = (! id->is_variable (scope.current_context ()));
+            do_bind_ans = (! id->is_variable (m_scope.current_context ()));
           }
         else
           do_bind_ans = (! expr->is_assignment_expression ());
 
         jit_value *expr_result = visit (expr);
 
         if (do_bind_ans)
           do_assign ("ans", expr_result, expr->print_result ());
         else if (expr->is_identifier () && expr->print_result ())
           {
             // FIXME: ugly hack, we need to come up with a way to pass
             // nargout to visit_identifier
             const jit_operation& fn = jit_typeinfo::print_value ();
-            jit_const_string *name = factory.create<jit_const_string>
+            jit_const_string *name = m_factory.create<jit_const_string>
               (expr->name ());
-            block->append (factory.create<jit_call> (fn, name, expr_result));
+            m_block->append (m_factory.create<jit_call> (fn, name, expr_result));
           }
       }
   }
 
   void
   jit_convert::visit_statement_list (tree_statement_list& lst)
   {
     for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
@@ -864,92 +867,92 @@ void
     tree_switch_case *last = lst->back ();
     if (last->is_default_case ())
       has_otherwise = 1;
 
     std::vector<jit_block *> entry_blocks (case_blocks_num + 1 - has_otherwise);
 
     // the first entry point is always the actual block.  Afterward, new blocks
     // are created for every case and the otherwise branch
-    entry_blocks[0] = block;
+    entry_blocks[0] = m_block;
     for (size_t i = 1; i < case_blocks_num; ++i)
-      entry_blocks[i] = factory.create<jit_block> ("case_cond");
-
-    jit_block *tail = factory.create<jit_block> ("switch_tail");
+      entry_blocks[i] = m_factory.create<jit_block> ("case_cond");
+
+    jit_block *tail = m_factory.create<jit_block> ("switch_tail");
 
     // if there's no otherwise branch, the 'else' of the last branch
     // has to point to the tail
     if (! has_otherwise)
       entry_blocks[entry_blocks.size()-1] = tail;
 
     // each branch in the case statement will have different breaks/continues
-    block_list current_breaks = breaks;
-    block_list current_continues = continues;
-    breaks.clear ();
-    continues.clear ();
+    block_list current_breaks = m_breaks;
+    block_list current_continues = m_continues;
+    m_breaks.clear ();
+    m_continues.clear ();
 
     size_t num_incomming = 0; // number of incomming blocks to our tail
 
     tree_switch_case_list::iterator iter = lst->begin ();
     for (size_t i = 0; i < case_blocks_num; ++iter, ++i)
       {
         tree_switch_case *twc = *iter;
-        block = entry_blocks[i]; // case_cond
-        assert (block);
+        m_block = entry_blocks[i]; // case_cond
+        assert (m_block);
 
         if (i)
-          blocks.push_back (entry_blocks[i]);  // first block already pushed
+          m_blocks.push_back (entry_blocks[i]);  // first block already pushed
 
         if (! twc->is_default_case ())
           {
             // compare result of switch expression with actual case label
             tree_expression *te = twc->case_label ();
             jit_value *label = visit (te);
             assert(label);
 
             const jit_operation& fn = jit_typeinfo::binary_op (octave_value::op_eq);
             jit_value *cond = create_checked (fn, value, label);
             assert(cond);
 
             jit_call *check = create_checked (&jit_typeinfo::logically_true,
                                               cond);
 
-            jit_block *body = factory.create<jit_block> ("case_body");
-            blocks.push_back (body);
-
-            block->append (factory.create<jit_cond_branch> (check, body,
+            jit_block *body = m_factory.create<jit_block> ("case_body");
+            m_blocks.push_back (body);
+
+            m_block->append (m_factory.create<jit_cond_branch> (check, body,
                                                             entry_blocks[i+1]));
-            block = body; // case_body
+            m_block = body; // case_body
           }
 
         tree_statement_list *stmt_lst = twc->commands ();
         assert(stmt_lst);
 
         try
           {
             stmt_lst->accept (*this);
             num_incomming++;
-            block->append (factory.create<jit_branch> (tail));
+            m_block->append (m_factory.create<jit_branch> (tail));
           }
         catch (const jit_break_exception&)
           { }
 
         // each branch in the case statement will have different breaks/continues
-        current_breaks.splice (current_breaks.end (), breaks);
-        current_continues.splice (current_continues.end (), continues);
+        current_breaks.splice (current_breaks.end (), m_breaks);
+        current_continues.splice (current_continues.end (), m_continues);
       }
 
     // each branch in the case statement will have different breaks/continues
-    breaks.splice (breaks.end (), current_breaks);
-    continues.splice (continues.end (), current_continues);
+    m_breaks.splice (m_breaks.end (), current_breaks);
+    m_continues.splice (m_continues.end (), current_continues);
 
     if (num_incomming || ! has_otherwise)
       {
-        blocks.push_back (tail);
-        block = tail; // switch_tail
+        m_blocks.push_back (tail);
+        m_block = tail; // switch_tail
       }
     else
       throw jit_break_exception ();   // every branch broke
   }
 
   void
   jit_convert::visit_try_catch_command (tree_try_catch_command&)
   {
@@ -961,226 +964,226 @@ void
   {
     throw jit_fail_exception ("No visit_unwind_protect_command implementation");
   }
 
   void
   jit_convert::visit_while_command (tree_while_command& wc)
   {
     unwind_protect frame;
-    frame.protect_var (breaks);
-    frame.protect_var (continues);
-    breaks.clear ();
-    continues.clear ();
-
-    jit_block *cond_check = factory.create<jit_block> ("while_cond_check");
-    block->append (factory.create<jit_branch> (cond_check));
-    blocks.push_back (cond_check);
-    block = cond_check;
+    frame.protect_var (m_breaks);
+    frame.protect_var (m_continues);
+    m_breaks.clear ();
+    m_continues.clear ();
+
+    jit_block *cond_check = m_factory.create<jit_block> ("while_cond_check");
+    m_block->append (m_factory.create<jit_branch> (cond_check));
+    m_blocks.push_back (cond_check);
+    m_block = cond_check;
 
     tree_expression *expr = wc.condition ();
     assert (expr && "While expression can not be null");
     jit_value *check = visit (expr);
     check = create_checked (&jit_typeinfo::logically_true, check);
 
-    jit_block *body = factory.create<jit_block> ("while_body");
-    blocks.push_back (body);
-
-    jit_block *tail = factory.create<jit_block> ("while_tail");
-    block->append (factory.create<jit_cond_branch> (check, body, tail));
-    block = body;
+    jit_block *body = m_factory.create<jit_block> ("while_body");
+    m_blocks.push_back (body);
+
+    jit_block *tail = m_factory.create<jit_block> ("while_tail");
+    m_block->append (m_factory.create<jit_cond_branch> (check, body, tail));
+    m_block = body;
 
     tree_statement_list *loop_body = wc.body ();
     bool all_breaking = false;
     if (loop_body)
       {
         try
           {
             loop_body->accept (*this);
           }
         catch (const jit_break_exception&)
           {
             all_breaking = true;
           }
       }
 
-    finish_breaks (tail, breaks);
-
-    if (! all_breaking || continues.size ())
+    finish_breaks (tail, m_breaks);
+
+    if (! all_breaking || m_continues.size ())
       {
         jit_block *interrupt_check
-          = factory.create<jit_block> ("interrupt_check");
-        blocks.push_back (interrupt_check);
-        finish_breaks (interrupt_check, continues);
+          = m_factory.create<jit_block> ("interrupt_check");
+        m_blocks.push_back (interrupt_check);
+        finish_breaks (interrupt_check, m_continues);
         if (! all_breaking)
-          block->append (factory.create<jit_branch> (interrupt_check));
-
-        block = interrupt_check;
+          m_block->append (m_factory.create<jit_branch> (interrupt_check));
+
+        m_block = interrupt_check;
         jit_error_check *ec
-          = factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                             cond_check, final_block);
-        block->append (ec);
+          = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
+                                             cond_check, m_final_block);
+        m_block->append (ec);
       }
 
-    blocks.push_back (tail);
-    block = tail;
+    m_blocks.push_back (tail);
+    m_block = tail;
   }
 
   void
   jit_convert::visit_do_until_command (tree_do_until_command& duc)
   {
     unwind_protect frame;
-    frame.protect_var (breaks);
-    frame.protect_var (continues);
-    breaks.clear ();
-    continues.clear ();
-
-    jit_block *body = factory.create<jit_block> ("do_until_body");
-    jit_block *cond_check = factory.create<jit_block> ("do_until_cond_check");
-    jit_block *tail = factory.create<jit_block> ("do_until_tail");
-
-    block->append (factory.create<jit_branch> (body));
-    blocks.push_back (body);
-    block = body;
+    frame.protect_var (m_breaks);
+    frame.protect_var (m_continues);
+    m_breaks.clear ();
+    m_continues.clear ();
+
+    jit_block *body = m_factory.create<jit_block> ("do_until_body");
+    jit_block *cond_check = m_factory.create<jit_block> ("do_until_cond_check");
+    jit_block *tail = m_factory.create<jit_block> ("do_until_tail");
+
+    m_block->append (m_factory.create<jit_branch> (body));
+    m_blocks.push_back (body);
+    m_block = body;
 
     tree_statement_list *loop_body = duc.body ();
     bool all_breaking = false;
     if (loop_body)
       {
         try
           {
             loop_body->accept (*this);
           }
         catch (const jit_break_exception&)
           {
             all_breaking = true;
           }
       }
 
-    finish_breaks (tail, breaks);
-
-    if (! all_breaking || continues.size ())
+    finish_breaks (tail, m_breaks);
+
+    if (! all_breaking || m_continues.size ())
       {
         jit_block *interrupt_check
-          = factory.create<jit_block> ("interrupt_check");
-        blocks.push_back (interrupt_check);
-        finish_breaks (interrupt_check, continues);
+          = m_factory.create<jit_block> ("interrupt_check");
+        m_blocks.push_back (interrupt_check);
+        finish_breaks (interrupt_check, m_continues);
         if (! all_breaking)
-          block->append (factory.create<jit_branch> (interrupt_check));
-
-        block = interrupt_check;
+          m_block->append (m_factory.create<jit_branch> (interrupt_check));
+
+        m_block = interrupt_check;
         jit_error_check *ec
-          = factory.create<jit_error_check> (jit_error_check::var_interrupt,
-                                             cond_check, final_block);
-        block->append (ec);
-
-        blocks.push_back (cond_check);
-        block = cond_check;
+          = m_factory.create<jit_error_check> (jit_error_check::var_interrupt,
+                                             cond_check, m_final_block);
+        m_block->append (ec);
+
+        m_blocks.push_back (cond_check);
+        m_block = cond_check;
 
         tree_expression *expr = duc.condition ();
         assert (expr && "Do-Until expression can not be null");
         jit_value *check = visit (expr);
         check = create_checked (&jit_typeinfo::logically_true, check);
 
-        block->append (factory.create<jit_cond_branch> (check, tail, body));
+        m_block->append (m_factory.create<jit_cond_branch> (check, tail, body));
       }
 
-    blocks.push_back (tail);
-    block = tail;
+    m_blocks.push_back (tail);
+    m_block = tail;
   }
 
   void
   jit_convert::initialize (const symbol_scope& s)
   {
-    scope = s;
-    iterator_count = 0;
-    for_bounds_count = 0;
-    short_count = 0;
+    m_scope = s;
+    m_iterator_count = 0;
+    m_for_bounds_count = 0;
+    m_short_count = 0;
     jit_instruction::reset_ids ();
 
-    entry_block = factory.create<jit_block> ("body");
-    final_block = factory.create<jit_block> ("final");
-    blocks.push_back (entry_block);
-    entry_block->mark_alive ();
-    block = entry_block;
+    m_entry_block = m_factory.create<jit_block> ("body");
+    m_final_block = m_factory.create<jit_block> ("final");
+    m_blocks.push_back (m_entry_block);
+    m_entry_block->mark_alive ();
+    m_block = m_entry_block;
   }
 
   jit_call *
   jit_convert::create_checked_impl (jit_call *ret)
   {
-    block->append (ret);
-
-    jit_block *normal = factory.create<jit_block> (block->name ());
+    m_block->append (ret);
+
+    jit_block *normal = m_factory.create<jit_block> (m_block->name ());
     jit_error_check *check
-      = factory.create<jit_error_check> (jit_error_check::var_error_state, ret,
-                                         normal, final_block);
-    block->append (check);
-    blocks.push_back (normal);
-    block = normal;
+      = m_factory.create<jit_error_check> (jit_error_check::var_error_state, ret,
+                                         normal, m_final_block);
+    m_block->append (check);
+    m_blocks.push_back (normal);
+    m_block = normal;
 
     return ret;
   }
 
   jit_variable *
   jit_convert::find_variable (const std::string& vname) const
   {
     variable_map::const_iterator iter;
-    iter = vmap.find (vname);
-    return iter != vmap.end () ? iter->second : nullptr;
+    iter = m_vmap.find (vname);
+    return iter != m_vmap.end () ? iter->second : nullptr;
   }
 
   jit_variable *
   jit_convert::get_variable (const std::string& vname)
   {
     jit_variable *ret = find_variable (vname);
     if (ret)
       return ret;
 
     symbol_table& symtab = __get_symbol_table__ ("jit_convert::find_variable");
 
-    symbol_record record = symtab.find_symbol (vname, scope);
+    symbol_record record = symtab.find_symbol (vname, m_scope);
     if (record.is_persistent () || record.is_global ())
       throw jit_fail_exception ("Persistent and global not yet supported");
 
-    if (converting_function)
+    if (m_converting_function)
       return create_variable (vname, jit_typeinfo::get_any (), false);
     else
       {
-        octave_value val = record.varval (scope.current_context ());
+        octave_value val = record.varval (m_scope.current_context ());
         if (val.is_undefined ())
           val = symtab.find_function (vname);
 
         jit_type *type = jit_typeinfo::type_of (val);
-        bounds.push_back (type_bound (type, vname));
+        m_bounds.push_back (type_bound (type, vname));
 
         return create_variable (vname, type);
       }
   }
 
   jit_variable *
   jit_convert::create_variable (const std::string& vname, jit_type *type,
                                 bool isarg)
   {
-    jit_variable *var = factory.create<jit_variable> (vname);
+    jit_variable *var = m_factory.create<jit_variable> (vname);
 
     if (isarg)
       {
         jit_extract_argument *extract;
-        extract = factory.create<jit_extract_argument> (type, var);
-        entry_block->prepend (extract);
+        extract = m_factory.create<jit_extract_argument> (type, var);
+        m_entry_block->prepend (extract);
       }
     else
       {
-        jit_call *init = factory.create<jit_call> (&jit_typeinfo::create_undef);
-        jit_assign *assign = factory.create<jit_assign> (var, init);
-        entry_block->prepend (assign);
-        entry_block->prepend (init);
+        jit_call *init = m_factory.create<jit_call> (&jit_typeinfo::create_undef);
+        jit_assign *assign = m_factory.create<jit_assign> (var, init);
+        m_entry_block->prepend (assign);
+        m_entry_block->prepend (init);
       }
 
-    return vmap[vname] = var;
+    return m_vmap[vname] = var;
   }
 
   std::string
   jit_convert::next_name (const char *prefix, size_t& count, bool inc)
   {
     std::stringstream ss;
     ss << prefix << count;
     if (inc)
@@ -1224,21 +1227,21 @@ void
     tree_argument_list::iterator iter = arg_list->begin ();
     bool have_extra = extra_arg;
     std::vector<jit_value *> call_args (narg + 1 + have_extra);
     call_args[0] = object;
 
     for (size_t idx = 0; iter != arg_list->end (); ++idx, ++iter)
       {
         unwind_protect frame;
-        frame.add_method (&end_context,
+        frame.add_method (&m_end_context,
                           &std::vector<jit_magic_end::context>::pop_back);
 
-        jit_magic_end::context ctx (factory, object, idx, narg);
-        end_context.push_back (ctx);
+        jit_magic_end::context ctx (m_factory, object, idx, narg);
+        m_end_context.push_back (ctx);
         call_args[idx + 1] = visit (*iter);
       }
 
     if (extra_arg)
       call_args[call_args.size () - 1] = extra_arg;
 
     const jit_operation& fres = (lhs ? jit_typeinfo::paren_subsasgn ()
                                  : jit_typeinfo::paren_subsref ());
@@ -1267,164 +1270,164 @@ void
       throw jit_fail_exception ("Unsupported assignment");
   }
 
   jit_value *
   jit_convert::do_assign (const std::string& lhs, jit_value *rhs,
                           bool print, bool artificial)
   {
     jit_variable *var = get_variable (lhs);
-    jit_assign *assign = block->append (factory.create<jit_assign> (var, rhs));
+    jit_assign *assign = m_block->append (m_factory.create<jit_assign> (var, rhs));
 
     if (artificial)
       assign->mark_artificial ();
 
     if (print)
       {
         const jit_operation& print_fn = jit_typeinfo::print_value ();
-        jit_const_string *name = factory.create<jit_const_string> (lhs);
-        block->append (factory.create<jit_call> (print_fn, name, var));
+        jit_const_string *name = m_factory.create<jit_const_string> (lhs);
+        m_block->append (m_factory.create<jit_call> (print_fn, name, var));
       }
 
     return var;
   }
 
   jit_value *
   jit_convert::visit (tree& tee)
   {
     unwind_protect frame;
-    frame.protect_var (result);
+    frame.protect_var (m_result);
 
     tee.accept (*this);
-    return result;
+    return m_result;
   }
 
   void
   jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
   {
     for (block_list::const_iterator iter = lst.begin (); iter != lst.end ();
          ++iter)
       {
         jit_block *b = *iter;
-        b->append (factory.create<jit_branch> (dest));
+        b->append (m_factory.create<jit_branch> (dest));
       }
   }
 
   // -------------------- jit_convert_llvm --------------------
   llvm::Function *
   jit_convert_llvm::convert_loop (const jit_module& module,
                                   const jit_block_list& blocks,
                                   const std::list<jit_value *>& constants,
                                   const std::string& llvm_function_name)
   {
-    converting_function = false;
+    m_converting_function = false;
 
     // for now just init arguments from entry, later we will have to do something
     // more interesting
-    jit_block *entry_block = blocks.front ();
-    for (jit_block::iterator iter = entry_block->begin ();
-         iter != entry_block->end (); ++iter)
+    jit_block *m_entry_block = blocks.front ();
+    for (jit_block::iterator iter = m_entry_block->begin ();
+         iter != m_entry_block->end (); ++iter)
       if (jit_extract_argument *extract
           = dynamic_cast<jit_extract_argument *> (*iter))
-        argument_vec.push_back (std::make_pair (extract->name (), true));
+        m_argument_vec.push_back (std::make_pair (extract->name (), true));
 
     jit_type *any = jit_typeinfo::get_any ();
 
     // argument is an array of octave_base_value*, or octave_base_value**
     llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
     llvm::FunctionType *ft;
     ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context),
                                   arg_type->getPointerTo (), false);
 
-    function = module.create_llvm_function (ft, llvm_function_name);
+    m_function = module.create_llvm_function (ft, llvm_function_name);
     try
       {
-        prelude = llvm::BasicBlock::Create (context, "prelude", function);
-        builder.SetInsertPoint (prelude);
+        m_prelude = llvm::BasicBlock::Create (context, "prelude", m_function);
+        builder.SetInsertPoint (m_prelude);
 
         // The jitted function will have only one function argument, of octave_base_value** type
-        llvm::Value *arg = &*(function->arg_begin ());
-
-        for (size_t i = 0; i < argument_vec.size (); ++i)
+        llvm::Value *arg = &*(m_function->arg_begin ());
+
+        for (size_t i = 0; i < m_argument_vec.size (); ++i)
           {
             // llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);         // LLVM <= 3.6
             llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg_type, arg, i);  // LLVM >= 3.7
 
-            arguments[argument_vec[i].first] = loaded_arg;
+            m_arguments[m_argument_vec[i].first] = loaded_arg;
           }
 
         convert (blocks, constants);
       }
     catch (const jit_fail_exception& e)
       {
-        function->eraseFromParent ();
+        m_function->eraseFromParent ();
         throw;
       }
 
-    return function;
+    return m_function;
   }
 
   jit_function
   jit_convert_llvm::convert_function (const jit_module& module,
                                       const jit_block_list& blocks,
                                       const std::list<jit_value *>& constants,
                                       octave_user_function& fcn,
                                       const std::vector<jit_type *>& args)
   {
-    converting_function = true;
-
-    jit_block *final_block = blocks.back ();
-    jit_return *ret = dynamic_cast<jit_return *> (final_block->back ());
+    m_converting_function = true;
+
+    jit_block *m_final_block = blocks.back ();
+    jit_return *ret = dynamic_cast<jit_return *> (m_final_block->back ());
     assert (ret);
 
-    creating = jit_function (&module, jit_convention::internal,
+    m_creating = jit_function (&module, jit_convention::internal,
                              "foobar", ret->result_type (), args);
-    function = creating.to_llvm ();
+    m_function = m_creating.to_llvm ();
 
     try
       {
-        prelude = creating.new_block ("prelude");
-        builder.SetInsertPoint (prelude);
+        m_prelude = m_creating.new_block ("prelude");
+        builder.SetInsertPoint (m_prelude);
 
         tree_parameter_list *plist = fcn.parameter_list ();
         if (plist)
           {
             tree_parameter_list::iterator piter = plist->begin ();
             tree_parameter_list::iterator pend = plist->end ();
             for (size_t i = 0; i < args.size () && piter != pend; ++i, ++piter)
               {
                 tree_decl_elt *elt = *piter;
                 std::string arg_name = elt->name ();
-                arguments[arg_name] = creating.argument (builder, i);
+                m_arguments[arg_name] = m_creating.argument (builder, i);
               }
           }
 
         convert (blocks, constants);
       }
     catch (const jit_fail_exception& e)
       {
-        function->eraseFromParent ();
+        m_function->eraseFromParent ();
         throw;
       }
 
-    return creating;
+    return m_creating;
   }
 
   void
   jit_convert_llvm::convert (const jit_block_list& blocks,
                              const std::list<jit_value *>& constants)
   {
     std::list<jit_block *>::const_iterator biter;
     for (biter = blocks.begin (); biter != blocks.end (); ++biter)
       {
         jit_block *jblock = *biter;
-        llvm::BasicBlock *block = llvm::BasicBlock::Create (context,
+        llvm::BasicBlock *m_block = llvm::BasicBlock::Create (context,
                                                             jblock->name (),
-                                                            function);
-        jblock->stash_llvm (block);
+                                                            m_function);
+        jblock->stash_llvm (m_block);
       }
 
     jit_block *first = *blocks.begin ();
     builder.CreateBr (first->to_llvm ());
 
     // constants aren't in the IR, we visit those first
     for (std::list<jit_value *>::const_iterator iter = constants.begin ();
          iter != constants.end (); ++iter)
@@ -1433,19 +1436,19 @@ void
 
     // convert all instructions
     for (biter = blocks.begin (); biter != blocks.end (); ++biter)
       visit (*biter);
 
     // now finish phi nodes
     for (biter = blocks.begin (); biter != blocks.end (); ++biter)
       {
-        jit_block& block = **biter;
-        for (jit_block::iterator piter = block.begin ();
-             piter != block.end () && isa<jit_phi> (*piter); ++piter)
+        jit_block& m_block = **biter;
+        for (jit_block::iterator piter = m_block.begin ();
+             piter != m_block.end () && isa<jit_phi> (*piter); ++piter)
           {
             jit_instruction *phi = *piter;
             finish_phi (static_cast<jit_phi *> (phi));
           }
       }
   }
 
   void
@@ -1510,18 +1513,18 @@ void
     as_llvm = llvm::ConstantStruct::get (stype,
                                          llvm::makeArrayRef (constants, 4));
     cr.stash_llvm (as_llvm);
   }
 
   void
   jit_convert_llvm::visit (jit_block& b)
   {
-    llvm::BasicBlock *block = b.to_llvm ();
-    builder.SetInsertPoint (block);
+    llvm::BasicBlock *m_block = b.to_llvm ();
+    builder.SetInsertPoint (m_block);
     for (jit_block::iterator iter = b.begin (); iter != b.end (); ++iter)
       visit (*iter);
   }
 
   void
   jit_convert_llvm::visit (jit_branch& b)
   {
     b.stash_llvm (builder.CreateBr (b.successor_llvm ()));
@@ -1548,46 +1551,46 @@ void
 
     llvm::Value *ret = ol.call (builder, args);
     call.stash_llvm (ret);
   }
 
   void
   jit_convert_llvm::visit (jit_extract_argument& extract)
   {
-    llvm::Value *arg = arguments[extract.name ()];
+    llvm::Value *arg = m_arguments[extract.name ()];
     assert (arg);
 
-    if (converting_function)
+    if (m_converting_function)
       extract.stash_llvm (arg);
     else
       {
         arg = builder.CreateLoad (arg);
 
         const jit_function& ol = extract.overload ();
         extract.stash_llvm (ol.call (builder, arg));
       }
   }
 
   void
   jit_convert_llvm::visit (jit_store_argument& store)
   {
     const jit_function& ol = store.overload ();
     llvm::Value *arg_value = ol.call (builder, store.result ());
-    llvm::Value *arg = arguments[store.name ()];
+    llvm::Value *arg = m_arguments[store.name ()];
     store.stash_llvm (builder.CreateStore (arg_value, arg));
   }
 
   void
   jit_convert_llvm::visit (jit_return& ret)
   {
     jit_value *res = ret.result ();
 
-    if (converting_function)
-      creating.do_return (builder, res->to_llvm (), false);
+    if (m_converting_function)
+      m_creating.do_return (builder, res->to_llvm (), false);
     else
       {
         if (res)
           builder.CreateRet (res->to_llvm ());
         else
           builder.CreateRetVoid ();
       }
   }
@@ -1661,52 +1664,52 @@ void
     jit_magic_end::context ctx = me.resolve_context ();
     llvm::Value *ret = ol.call (builder, ctx.value, ctx.index, ctx.count);
     me.stash_llvm (ret);
   }
 
   // -------------------- jit_infer --------------------
   jit_infer::jit_infer (jit_factory& afactory, jit_block_list& ablocks,
                         const variable_map& avmap)
-    : blocks (ablocks), factory (afactory), vmap (avmap) { }
+    : m_blocks (ablocks), m_factory (afactory), m_vmap (avmap) { }
 
   void
   jit_infer::infer (void)
   {
     construct_ssa ();
 
     // initialize the worklist to instructions derived from constants
-    const std::list<jit_value *>& constants = factory.constants ();
+    const std::list<jit_value *>& constants = m_factory.constants ();
     for (std::list<jit_value *>::const_iterator iter = constants.begin ();
          iter != constants.end (); ++iter)
       append_users (*iter);
 
     // the entry block terminator may be a regular branch statement
     if (entry_block ().terminator ())
       push_worklist (entry_block ().terminator ());
 
     // FIXME: Describe algorithm here
-    while (worklist.size ())
+    while (m_worklist.size ())
       {
-        jit_instruction *next = worklist.front ();
-        worklist.pop_front ();
+        jit_instruction *next = m_worklist.front ();
+        m_worklist.pop_front ();
         next->stash_in_worklist (false);
 
         if (next->infer ())
           {
             // terminators need to be handles specially
             if (jit_terminator *term = dynamic_cast<jit_terminator *> (next))
               append_users_term (term);
             else
               append_users (next);
           }
       }
 
     remove_dead ();
-    blocks.label ();
+    m_blocks.label ();
     place_releases ();
     simplify_phi ();
   }
 
   void
   jit_infer::append_users (jit_value *v)
   {
     for (jit_use *use = v->first_use (); use; use = use->next ())
@@ -1730,23 +1733,23 @@ void
               push_worklist (sterm);
           }
       }
   }
 
   void
   jit_infer::construct_ssa (void)
   {
-    blocks.label ();
+    m_blocks.label ();
     final_block ().compute_idom (entry_block ());
     entry_block ().compute_df ();
     entry_block ().create_dom_tree ();
 
     // insert phi nodes where needed, this is done on a per variable basis
-    for (variable_map::const_iterator iter = vmap.begin (); iter != vmap.end ();
+    for (variable_map::const_iterator iter = m_vmap.begin (); iter != m_vmap.end ();
          ++iter)
       {
         jit_block::df_set visited, added_phi;
         std::list<jit_block *> ssa_worklist;
         iter->second->use_blocks (visited);
         ssa_worklist.insert (ssa_worklist.begin (), visited.begin (),
                              visited.end ());
 
@@ -1756,17 +1759,17 @@ void
             ssa_worklist.pop_front ();
 
             for (jit_block::df_iterator diter = b->df_begin ();
                  diter != b->df_end (); ++diter)
               {
                 jit_block *dblock = *diter;
                 if (! added_phi.count (dblock))
                   {
-                    jit_phi *phi = factory.create<jit_phi> (iter->second,
+                    jit_phi *phi = m_factory.create<jit_phi> (iter->second,
                                                             dblock->use_count ());
                     dblock->prepend (phi);
                     added_phi.insert (dblock);
                   }
 
                 if (! visited.count (dblock))
                   {
                     ssa_worklist.push_back (dblock);
@@ -1823,17 +1826,17 @@ void
 
     ablock.pop_all ();
   }
 
   void
   jit_infer::place_releases (void)
   {
     std::set<jit_value *> temporaries;
-    for (jit_block_list::iterator iter = blocks.begin (); iter != blocks.end ();
+    for (jit_block_list::iterator iter = m_blocks.begin (); iter != m_blocks.end ();
          ++iter)
       {
         jit_block& ablock = **iter;
         if (ablock.id () != jit_block::NO_ID)
           {
             release_temp (ablock, temporaries);
             release_dead_phi (ablock);
           }
@@ -1841,66 +1844,66 @@ void
   }
 
   void
   jit_infer::push_worklist (jit_instruction *instr)
   {
     if (! instr->in_worklist ())
       {
         instr->stash_in_worklist (true);
-        worklist.push_back (instr);
+        m_worklist.push_back (instr);
       }
   }
 
   void
   jit_infer::remove_dead ()
   {
     jit_block_list::iterator biter;
-    for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    for (biter = m_blocks.begin (); biter != m_blocks.end (); ++biter)
       {
         jit_block *b = *biter;
         if (b->alive ())
           {
             for (jit_block::iterator iter = b->begin ();
                  iter != b->end () && isa<jit_phi> (*iter);)
               {
                 jit_phi *phi = static_cast<jit_phi *> (*iter);
                 if (phi->prune ())
                   iter = b->remove (iter);
                 else
                   ++iter;
               }
           }
       }
 
-    for (biter = blocks.begin (); biter != blocks.end ();)
+    for (biter = m_blocks.begin (); biter != m_blocks.end ();)
       {
         jit_block *b = *biter;
         if (b->alive ())
           {
             // FIXME: A special case for jit_error_check, if we generalize to
             // we will need to change!
             jit_terminator *term = b->terminator ();
             if (term && term->successor_count () == 2 && ! term->alive (0))
               {
                 jit_block *succ = term->successor (1);
                 term->remove ();
-                jit_branch *abreak = factory.create<jit_branch> (succ);
+                jit_branch *abreak = m_factory.create<jit_branch> (succ);
                 b->append (abreak);
                 abreak->infer ();
               }
 
             ++biter;
           }
         else
           {
             jit_terminator *term = b->terminator ();
             if (term)
               term->remove ();
-            biter = blocks.erase (biter);
+            biter = m_blocks.erase (biter);
           }
       }
   }
 
   void
   jit_infer::release_dead_phi (jit_block& ablock)
   {
     jit_block::iterator iter = ablock.begin ();
@@ -1916,20 +1919,20 @@ void
             // this can get rid of casts inside loops
             for (size_t i = 0; i < phi->argument_count (); ++i)
               {
                 jit_value *arg = phi->argument (i);
                 if (! arg->needs_release ())
                   continue;
 
                 jit_block *inc = phi->incomming (i);
-                jit_block *split = inc->maybe_split (factory, blocks, ablock);
+                jit_block *split = inc->maybe_split (m_factory, m_blocks, ablock);
                 jit_terminator *term = split->terminator ();
                 jit_call *release
-                  = factory.create<jit_call> (jit_typeinfo::release, arg);
+                  = m_factory.create<jit_call> (jit_typeinfo::release, arg);
                 release->infer ();
                 split->insert_before (term, release);
               }
 
             phi->replace_with (0);
             phi->remove ();
           }
       }
@@ -1957,47 +1960,47 @@ void
             // place releases for temporary arguments
             for (size_t i = 0; i < instr->argument_count (); ++i)
               {
                 jit_value *arg = instr->argument (i);
                 if (! arg->needs_release ())
                   continue;
 
                 jit_call *release
-                  = factory.create<jit_call> (&jit_typeinfo::release, arg);
+                  = m_factory.create<jit_call> (&jit_typeinfo::release, arg);
                 release->infer ();
                 ablock.insert_after (iter, release);
                 ++iter;
                 temp.erase (arg);
               }
           }
       }
 
     if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
       return;
 
     // FIXME: If we support try/catch or unwind_protect final_block
     //        may not be the destination
-    jit_block *split = ablock.maybe_split (factory, blocks, final_block ());
+    jit_block *split = ablock.maybe_split (m_factory, m_blocks, final_block ());
     jit_terminator *term = split->terminator ();
     for (std::set<jit_value *>::const_iterator iter = temp.begin ();
          iter != temp.end (); ++iter)
       {
         jit_value *value = *iter;
         jit_call *release
-          = factory.create<jit_call> (&jit_typeinfo::release, value);
+          = m_factory.create<jit_call> (&jit_typeinfo::release, value);
         split->insert_before (term, release);
         release->infer ();
       }
   }
 
   void
   jit_infer::simplify_phi (void)
   {
-    for (jit_block_list::iterator biter = blocks.begin (); biter != blocks.end ();
+    for (jit_block_list::iterator biter = m_blocks.begin (); biter != m_blocks.end ();
          ++biter)
       {
         jit_block &ablock = **biter;
         for (jit_block::iterator iter = ablock.begin ();
              iter != ablock.end () && isa<jit_phi> (*iter); ++iter)
           simplify_phi (*static_cast<jit_phi *> (*iter));
       }
   }
@@ -2009,20 +2012,20 @@ void
     const jit_operation& cast_fn = jit_typeinfo::cast (phi.type ());
     jit_variable *dest = phi.dest ();
     for (size_t i = 0; i < phi.argument_count (); ++i)
       {
         jit_value *arg = phi.argument (i);
         if (arg->type () != phi.type ())
           {
             jit_block *pred = phi.incomming (i);
-            jit_block *split = pred->maybe_split (factory, blocks, pblock);
+            jit_block *split = pred->maybe_split (m_factory, m_blocks, pblock);
             jit_terminator *term = split->terminator ();
-            jit_instruction *cast = factory.create<jit_call> (cast_fn, arg);
-            jit_assign *assign = factory.create<jit_assign> (dest, cast);
+            jit_instruction *cast = m_factory.create<jit_call> (cast_fn, arg);
+            jit_assign *assign = m_factory.create<jit_assign> (dest, cast);
 
             split->insert_before (term, cast);
             split->insert_before (term, assign);
             cast->infer ();
             assign->infer ();
             phi.stash_argument (i, assign);
           }
       }
@@ -2313,114 +2316,114 @@ void
     // unsupported type
     return 0;
   }
 
 
   // -------------------- jit_module --------------------
 
   jit_module::jit_module (const std::string& module_name)
-    : module (nullptr), engine (nullptr)
+    : m_module (nullptr), m_engine (nullptr)
   {
     jit::ModuleOwner module_owner = tree_jit::open_new_module (module_name);
     // FIXME: what if this fails? exception?
 
     // Get a pointer to the module before ownership is transfered to engine
-    module = module_owner.get ();
+    m_module = module_owner.get ();
 
     jit::EngineOwner engine_owner = std::move
       (tree_jit::create_new_engine (std::move (module_owner)));
     // FIXME: what if this fails? exception?
 
     // TODO?: Consider creating the engine just before jitting
 
     // We take responsibility for deleting the engine
-    engine = engine_owner.get ();
+    m_engine = engine_owner.get ();
     engine_owner.release ();
 
     tree_jit::register_jit_module (this);
   }
 
   jit_module::~jit_module ()
   {
     tree_jit::unregister_jit_module (this);
 
-    delete engine;
+    delete m_engine;
   }
 
   // Create an LLVM function in the module, with external linkage
   llvm::Function*
   jit_module::create_llvm_function (llvm::FunctionType *ftype,
                                     const llvm::Twine &name) const
   {
     // we mark all functinos as external linkage because this prevents
     // llvm from getting rid of always inline functions
 
     return llvm::Function::Create (ftype, llvm::Function::ExternalLinkage,
-                                   name, module);
+                                   name, m_module);
   }
 
   // Create or insert an LLVM Function declaration for an intrinsic and return it
   llvm::Function*
   jit_module::get_intrinsic_declaration (size_t id,
                                          std::vector<llvm::Type*> types) const
   {
     return llvm::Intrinsic::getDeclaration
-      (module, static_cast<llvm::Intrinsic::ID> (id), types);
+      (m_module, static_cast<llvm::Intrinsic::ID> (id), types);
   }
 
   // Create a global in the module
   llvm::GlobalVariable*
   jit_module::create_global_variable (llvm::Type *type, bool is_constant,
                                       const llvm::Twine& name) const
   {
-    return new llvm::GlobalVariable (*module, type, is_constant,
+    return new llvm::GlobalVariable (*m_module, type, is_constant,
                                      llvm::GlobalValue::ExternalLinkage,
                                      nullptr, name);
   }
 
   void
   jit_module::do_add_global_mapping (const llvm::GlobalValue* gv, void* p) const
   {
     assert (gv);
-    engine->addGlobalMapping (gv, p);
+    m_engine->addGlobalMapping (gv, p);
   }
 
   // Return the address of the specified function.
   uint64_t
   jit_module::getFunctionAddress (const std::string &name) const
   {
-    return engine->getFunctionAddress (name);
+    return m_engine->getFunctionAddress (name);
   }
 
   void
   jit_module::optimize (llvm::Function *fn) const
   {
     if (Vdebug_jit)
-      llvm::verifyModule (*module);
+      llvm::verifyModule (*m_module);
 
     // DOCUMENT-ME: Why do we need two separate pass managers?
 
     jit::PassManager *module_pass_manager = new jit::PassManager ();
-    jit::FunctionPassManager *pass_manager = new jit::FunctionPassManager (module);
+    jit::FunctionPassManager *pass_manager = new jit::FunctionPassManager (m_module);
 
     module_pass_manager->add (llvm::createAlwaysInlinerPass ());
 
     // In 3.6, a pass was inserted in the pipeline to make the DataLayout accessible:
     //    MyPassManager->add(new DataLayoutPass(MyTargetMachine->getDataLayout()));
     // In 3.7, you don’t need a pass, you set the DataLayout on the Module:
     //    MyModule->setDataLayout(MyTargetMachine->createDataLayout());
     //
     // FIXME: autoconf to support <= 3.6
     //
     // #if defined (HAVE_LLVM_DATALAYOUT)
-    //   pass_manager->add (new llvm::DataLayout (*engine->getDataLayout ()));
+    //   pass_manager->add (new llvm::DataLayout (*m_engine->getDataLayout ()));
     // #else
     //   // For very old LLVM releases ???
-    //   pass_manager->add (new llvm::TargetData (*engine->getTargetData ()));
+    //   pass_manager->add (new llvm::TargetData (*m_engine->getTargetData ()));
     // #endif
 
     // DOCUMENT-ME: What does each of these passes actually do?
 
     pass_manager->add (llvm::createCFGSimplificationPass ());
 
 #if defined (HAVE_LLVM_ANALYSIS_BASICALIASANALYSIS_H)
     pass_manager->add (llvm::createBasicAAWrapperPass ());
@@ -2430,17 +2433,17 @@ void
 
     pass_manager->add (llvm::createPromoteMemoryToRegisterPass ());
     pass_manager->add (llvm::createInstructionCombiningPass ());
     pass_manager->add (llvm::createReassociatePass ());
     pass_manager->add (llvm::createGVNPass ());
     pass_manager->add (llvm::createCFGSimplificationPass ());
     pass_manager->doInitialization ();
 
-    module_pass_manager->run (*module);
+    module_pass_manager->run (*m_module);
     pass_manager->run (*fn);
 
     delete module_pass_manager;
     delete pass_manager;
 
     if (Vdebug_jit)
       {
         // This should be OK in LLVM 3.6 -- 3.8 (and later ?)
@@ -2449,44 +2452,44 @@ void
 
         //      std::string error;
         //#if defined (RAW_FD_OSTREAM_ARG_IS_LLVM_SYS_FS)
         //      llvm::raw_fd_ostream fout ("test.bc", error, llvm::sys::fs::F_Binary);
         //#else
         //      llvm::raw_fd_ostream fout ("test.bc", error, llvm::raw_fd_ostream::F_Binary);
         //#endif
 
-        llvm::WriteBitcodeToFile (module, fout);
+        llvm::WriteBitcodeToFile (m_module, fout);
       }
   }
 
   void
   jit_module::finalizeObject (void)
   {
-    engine->finalizeObject ();
+    m_engine->finalizeObject ();
   }
 
 
   // -------------------- jit_function_info --------------------
   jit_function_info::jit_function_info (octave_user_function& fcn,
                                         const octave_value_list& ov_args)
-    : llvm_function_name (""),
-      function (nullptr),
-      argument_types (ov_args.length ())
+    : m_llvm_function_name (""),
+      m_function (nullptr),
+      m_argument_types (ov_args.length ())
   {
     size_t nargs = ov_args.length ();
     for (size_t i = 0; i < nargs; ++i)
-      argument_types[i] = jit_typeinfo::type_of (ov_args(i));
+      m_argument_types[i] = jit_typeinfo::type_of (ov_args(i));
 
     jit_function raw_fn;
     jit_function wrapper;
 
     try
       {
-        jit_convert conv (fcn, argument_types);
+        jit_convert conv (fcn, m_argument_types);
         jit_infer infer (conv.get_factory (), conv.get_blocks (),
                          conv.get_variable_map ());
         infer.infer ();
 
         if (Vdebug_jit)
           {
             jit_block_list& blocks = infer.get_blocks ();
             blocks.label ();
@@ -2499,45 +2502,45 @@ void
             tpc.visit_octave_user_function_trailer (fcn);
             blocks.print (std::cout, "octave jit ir");
           }
 
         jit_factory& factory = conv.get_factory ();
         jit_convert_llvm to_llvm;
         raw_fn = to_llvm.convert_function (*this, infer.get_blocks (),
                                            factory.constants (), fcn,
-                                           argument_types);
+                                           m_argument_types);
 
         if (Vdebug_jit)
           {
             std::cout << "-------------------- raw function ";
             std::cout << "--------------------\n";
             std::cout << *raw_fn.to_llvm () << std::endl;
             llvm::verifyFunction (*raw_fn.to_llvm ());
           }
 
-        llvm_function_name = fcn.name () + "_wrapper";
+        m_llvm_function_name = fcn.name () + "_wrapper";
         jit_type *any_t = jit_typeinfo::get_any ();
         std::vector<jit_type *> wrapper_args (1, jit_typeinfo::get_any_ptr ());
         wrapper = jit_function (this, jit_convention::internal,
-                                llvm_function_name, any_t, wrapper_args);
+                                m_llvm_function_name, any_t, wrapper_args);
 
         llvm::BasicBlock *wrapper_body = wrapper.new_block ();
         builder.SetInsertPoint (wrapper_body);
 
         llvm::Value *wrapper_arg = wrapper.argument (builder, 0);
         std::vector<llvm::Value *> raw_args (nargs);
         for (size_t i = 0; i < nargs; ++i)
           {
             llvm::Value *arg;
             // arg = builder.CreateConstInBoundsGEP1_32 (wrapper_arg, i);                  // LLVM <= 3.6
             arg = builder.CreateConstInBoundsGEP1_32 (any_t->to_llvm (), wrapper_arg, i);  // LLVM >= 3.7
             arg = builder.CreateLoad (arg);
 
-            jit_type *arg_type = argument_types[i];
+            jit_type *arg_type = m_argument_types[i];
             const jit_function& cast = jit_typeinfo::cast (arg_type, any_t);
             raw_args[i] = cast.call (builder, arg);
           }
 
         llvm::Value *result = raw_fn.call (builder, raw_args);
         if (raw_fn.result ())
           {
             jit_type *raw_result_t = raw_fn.result ();
@@ -2560,32 +2563,32 @@ void
             std::cout << "-------------------- optimized and wrapped ";
             std::cout << "--------------------\n";
             std::cout << *llvm_function << std::endl;
             llvm::verifyFunction (*llvm_function);
           }
 
         finalizeObject ();
 
-        uint64_t void_fn = getFunctionAddress (llvm_function_name);
+        uint64_t void_fn = getFunctionAddress (m_llvm_function_name);
 
         if (void_fn == 0)
           {
             llvm_function->eraseFromParent ();
             llvm_function = nullptr;
-            function = nullptr;
+            m_function = nullptr;
           }
         else
           {
-            function = reinterpret_cast<jited_function> (void_fn);
+            m_function = reinterpret_cast<jited_function> (void_fn);
           }
       }
     catch (const jit_fail_exception& e)
       {
-        argument_types.clear ();
+        m_argument_types.clear ();
 
         if (Vdebug_jit)
           {
             if (e.known ())
               std::cout << "jit fail: " << e.what () << std::endl;
           }
 
         Vjit_failcnt++;
@@ -2594,130 +2597,130 @@ void
         raw_fn.erase ();
       }
   }
 
   bool
   jit_function_info::execute (const octave_value_list& ov_args,
                               octave_value_list& retval) const
   {
-    if (! function)
+    if (! m_function)
       return false;
 
     // FIXME: figure out a way to delete ov_args so we avoid duplicating refcount
     size_t nargs = ov_args.length ();
     std::vector<octave_base_value *> args (nargs);
     for (size_t i = 0; i < nargs; ++i)
       {
         octave_base_value *obv = ov_args(i).internal_rep ();
         obv->grab ();
         args[i] = obv;
       }
 
-    octave_base_value *ret = function (&args[0]);
+    octave_base_value *ret = m_function (&args[0]);
     if (ret)
       retval(0) = octave_value (ret);
 
     octave_quit ();
 
     return true;
   }
 
   bool
   jit_function_info::match (const octave_value_list& ov_args) const
   {
-    if (! function)
+    if (! m_function)
       return true;
 
     size_t nargs = ov_args.length ();
-    if (nargs != argument_types.size ())
+    if (nargs != m_argument_types.size ())
       return false;
 
     for (size_t i = 0; i < nargs; ++i)
-      if (jit_typeinfo::type_of (ov_args(i)) != argument_types[i])
+      if (jit_typeinfo::type_of (ov_args(i)) != m_argument_types[i])
         return false;
 
     return true;
   }
 
 
   // -------------------- jit_info --------------------
   jit_info::jit_info (tree& tee)
-    : llvm_function_name (tree_jit::generate_unique_function_name ()),
-      function (nullptr)
+    : m_llvm_function_name (tree_jit::generate_unique_function_name ()),
+      m_function (nullptr)
   {
     compile (tee);
   }
 
   jit_info::jit_info (tree& tee, const octave_value& for_bounds)
-    : llvm_function_name (tree_jit::generate_unique_function_name ()),
-      function (nullptr)
+    : m_llvm_function_name (tree_jit::generate_unique_function_name ()),
+      m_function (nullptr)
   {
     compile (tee, jit_typeinfo::type_of (for_bounds));
   }
 
   jit_info::jit_info (tree_simple_for_command& tee, const octave_value& for_bounds)
-    : llvm_function_name (tree_jit::generate_unique_forloop_name ()),
-      function (nullptr)
+    : m_llvm_function_name (tree_jit::generate_unique_forloop_name ()),
+      m_function (nullptr)
   {
     compile (tee, jit_typeinfo::type_of (for_bounds));
   }
 
   bool
   jit_info::execute (const vmap& extra_vars) const
   {
-    if (! function)
+    if (! m_function)
       return false;
 
-    std::vector<octave_base_value *> real_arguments (arguments.size ());
-    for (size_t i = 0; i < arguments.size (); ++i)
+    std::vector<octave_base_value *> real_arguments (m_arguments.size ());
+    for (size_t i = 0; i < m_arguments.size (); ++i)
       {
-        if (arguments[i].second)
+        if (m_arguments[i].second)
           {
-            octave_value current = find (extra_vars, arguments[i].first);
+            octave_value current = find (extra_vars, m_arguments[i].first);
             octave_base_value *obv = current.internal_rep ();
 
             obv->grab ();
 
             real_arguments[i] = obv;
           }
       }
 
-    function (&real_arguments[0]);
+    m_function (&real_arguments[0]);
 
     symbol_scope scope = __require_current_scope__ ("jit_info::execute");
 
-    for (size_t i = 0; i < arguments.size (); ++i)
+    for (size_t i = 0; i < m_arguments.size (); ++i)
       {
-        const std::string& name = arguments[i].first;
+        const std::string& name = m_arguments[i].first;
 
         // do not store for loop bounds temporary
         if (name.size () && name[0] != '#')
-          scope.assign (arguments[i].first, real_arguments[i]);
+          scope.assign (m_arguments[i].first, real_arguments[i]);
       }
 
     octave_quit ();
 
     return true;
   }
 
   bool
   jit_info::match (const vmap& extra_vars) const
   {
-    if (! function)
+    if (! m_function)
       return true;
 
-    for (size_t i = 0; i < bounds.size (); ++i)
+    for (size_t i = 0; i < m_bounds.size (); ++i)
       {
-        const std::string& arg_name = bounds[i].second;
+        const std::string& arg_name = m_bounds[i].second;
         octave_value value = find (extra_vars, arg_name);
         jit_type *type = jit_typeinfo::type_of (value);
 
         // FIXME: Check for a parent relationship
-        if (type != bounds[i].first)
+        if (type != m_bounds[i].first)
           return false;
       }
 
     return true;
   }
 
   void
   jit_info::compile (tree& tee, jit_type *for_bounds)
@@ -2741,21 +2744,21 @@ void
             blocks.print (std::cout, "octave jit ir");
           }
 
         jit_factory& factory = conv.get_factory ();
         jit_convert_llvm to_llvm;
 
         llvm_function = to_llvm.convert_loop (*this, infer.get_blocks (),
                                               factory.constants (),
-                                              llvm_function_name);
-
-        arguments = to_llvm.get_arguments ();
-
-        bounds = conv.get_bounds ();
+                                              m_llvm_function_name);
+
+        m_arguments = to_llvm.get_arguments ();
+
+        m_bounds = conv.get_bounds ();
       }
     catch (const jit_fail_exception& e)
       {
         if (Vdebug_jit)
           {
             if (e.known ())
               std::cout << "jit fail: " << e.what () << std::endl;
           }
@@ -2779,27 +2782,27 @@ void
           {
             std::cout << "-------------------- optimized llvm ir "
                       << "--------------------\n";
             std::cout << *llvm_function << std::endl;
           }
 
         finalizeObject ();
 
-        uint64_t void_fn = getFunctionAddress (llvm_function_name);
+        uint64_t void_fn = getFunctionAddress (m_llvm_function_name);
 
         if (void_fn == 0)
           {
             llvm_function->eraseFromParent ();
             llvm_function = nullptr;
-            function = nullptr;
+            m_function = nullptr;
           }
         else
           {
-            function = reinterpret_cast<jited_function> (void_fn);
+            m_function = reinterpret_cast<jited_function> (void_fn);
           }
       }
   }
 
   octave_value
   jit_info::find (const vmap& extra_vars, const std::string& vname) const
   {
     vmap::const_iterator iter = extra_vars.find (vname);
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -36,59 +36,58 @@ along with Octave; see the file COPYING.
 
 // octave_value_list is not (yet) in the octave namespace
 class octave_value_list;
 
 namespace octave
 {
   namespace jit
   {
-
 #if defined (LEGACY_PASSMANAGER)
     typedef llvm::legacy::PassManager PassManager;
     typedef llvm::legacy::FunctionPassManager FunctionPassManager;
 #else
     typedef llvm::PassManager PassManager;
     typedef llvm::FunctionPassManager FunctionPassManager;
 #endif
 
     typedef std::unique_ptr<llvm::Module> ModuleOwner;
     typedef std::unique_ptr<llvm::ExecutionEngine> EngineOwner;
-
   }
 
   // Convert from the parse tree (AST) to the low level Octave IR.
   class
   jit_convert : public tree_walker
   {
   public:
+
     typedef std::pair<jit_type *, std::string> type_bound;
     typedef std::vector<type_bound> type_bound_vector;
     typedef std::map<std::string, jit_variable *> variable_map;
 
     jit_convert (tree& tee, jit_type *for_bounds = nullptr);
 
     jit_convert (octave_user_function& fcn, const std::vector<jit_type *>& args);
 
     template <typename ...Args>
     jit_call * create_checked (const Args&... args)
     {
-      jit_call *ret = factory.create<jit_call> (args...);
+      jit_call *ret = m_factory.create<jit_call> (args...);
       return create_checked_impl (ret);
     }
 
-    jit_block_list& get_blocks (void) { return blocks; }
+    jit_block_list& get_blocks (void) { return m_blocks; }
 
-    const type_bound_vector& get_bounds (void) const { return bounds; }
+    const type_bound_vector& get_bounds (void) const { return m_bounds; }
 
-    jit_factory& get_factory (void) { return factory; }
+    jit_factory& get_factory (void) { return m_factory; }
 
-    llvm::Function *get_function (void) const { return function; }
+    llvm::Function *get_function (void) const { return m_function; }
 
-    const variable_map& get_variable_map (void) const { return vmap; }
+    const variable_map& get_variable_map (void) const { return m_vmap; }
 
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_argument_list (tree_argument_list&);
 
     void visit_binary_expression (tree_binary_expression&);
 
     void visit_boolean_expression (tree_boolean_expression&);
@@ -167,47 +166,49 @@ namespace octave
 
     void visit_try_catch_command (tree_try_catch_command&);
 
     void visit_unwind_protect_command (tree_unwind_protect_command&);
 
     void visit_while_command (tree_while_command&);
 
     void visit_do_until_command (tree_do_until_command&);
+
   private:
-    std::vector<std::pair<std::string, bool>> arguments;
-    type_bound_vector bounds;
 
-    bool converting_function;
+    std::vector<std::pair<std::string, bool>> m_arguments;
+    type_bound_vector m_bounds;
+
+    bool m_converting_function;
 
     // the scope of the function we are converting, or the current scope
-    symbol_scope scope;
+    symbol_scope m_scope;
 
-    jit_factory factory;
+    jit_factory m_factory;
 
     // used instead of return values from visit_* functions
-    jit_value *result;
+    jit_value *m_result;
 
-    jit_block *entry_block;
+    jit_block *m_entry_block;
 
-    jit_block *final_block;
+    jit_block *m_final_block;
 
-    jit_block *block;
+    jit_block *m_block;
 
-    llvm::Function *function;
+    llvm::Function *m_function;
 
-    jit_block_list blocks;
+    jit_block_list m_blocks;
 
-    std::vector<jit_magic_end::context> end_context;
+    std::vector<jit_magic_end::context> m_end_context;
 
-    size_t iterator_count;
-    size_t for_bounds_count;
-    size_t short_count;
+    size_t m_iterator_count;
+    size_t m_for_bounds_count;
+    size_t m_short_count;
 
-    variable_map vmap;
+    variable_map m_vmap;
 
     void initialize (const symbol_scope& s);
 
     jit_call * create_checked_impl (jit_call *ret);
 
     // get an existing vairable.  If the variable does not exist, it will not be
     // created
     jit_variable * find_variable (const std::string& vname) const;
@@ -219,23 +220,23 @@ namespace octave
     // create a variable of the given name and given type.  Will also insert an
     // extract statement
     jit_variable * create_variable (const std::string& vname, jit_type *type,
                                     bool isarg = true);
 
     // The name of the next for loop iterator.  If inc is false, then the
     // iterator counter will not be incremented.
     std::string next_iterator (bool inc = true)
-    { return next_name ("#iter", iterator_count, inc); }
+    { return next_name ("#iter", m_iterator_count, inc); }
 
     std::string next_for_bounds (bool inc = true)
-    { return next_name ("#for_bounds", for_bounds_count, inc); }
+    { return next_name ("#for_bounds", m_for_bounds_count, inc); }
 
     std::string next_shortcircut_result (bool inc = true)
-    { return next_name ("#shortcircut_result", short_count, inc); }
+    { return next_name ("#shortcircut_result", m_short_count, inc); }
 
     std::string next_name (const char *prefix, size_t& count, bool inc);
 
     jit_instruction * resolve (tree_index_expression& exp,
                                jit_value *extra_arg = nullptr, bool lhs = false);
 
     jit_value * do_assign (tree_expression *exp, jit_value *rhs,
                            bool artificial = false);
@@ -243,64 +244,67 @@ namespace octave
     jit_value * do_assign (const std::string& lhs, jit_value *rhs, bool print,
                            bool artificial = false);
 
     jit_value * visit (tree *tee) { return visit (*tee); }
 
     jit_value * visit (tree& tee);
 
     typedef std::list<jit_block *> block_list;
-    block_list breaks;
-    block_list continues;
+    block_list m_breaks;
+    block_list m_continues;
 
     void finish_breaks (jit_block *dest, const block_list& lst);
   };
 
   // Convert from the low level Octave IR to LLVM
   class
   jit_convert_llvm : public jit_ir_walker
   {
   public:
+
     llvm::Function * convert_loop (const jit_module& module,
                                    const jit_block_list& blocks,
                                    const std::list<jit_value *>& constants,
                                    const std::string& llvm_function_name);
 
     jit_function convert_function (const jit_module& module,
                                    const jit_block_list& blocks,
                                    const std::list<jit_value *>& constants,
                                    octave_user_function& fcn,
                                    const std::vector<jit_type *>& args);
 
     // arguments to the llvm::Function for loops
     const std::vector<std::pair<std::string, bool>>& get_arguments(void) const
-    { return argument_vec; }
+    { return m_argument_vec; }
 
 #define JIT_METH(clname)                        \
     virtual void visit (jit_ ## clname&);
 
     JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
+
   private:
+
     // name -> argument index (used for compiling functions)
-    std::map<std::string, int> argument_index;
+    std::map<std::string, int> m_argument_index;
 
-    std::vector<std::pair<std::string, bool>> argument_vec;
+    std::vector<std::pair<std::string, bool>> m_argument_vec;
 
     // name -> llvm argument (used for compiling loops)
-    std::map<std::string, llvm::Value *> arguments;
+    std::map<std::string, llvm::Value *> m_arguments;
 
-    bool converting_function;
+    bool m_converting_function;
 
     // only used if we are converting a function
-    jit_function creating;
+    jit_function m_creating;
 
-    llvm::Function *function;
-    llvm::BasicBlock *prelude;
+    llvm::Function *m_function;
+    llvm::BasicBlock *m_prelude;
 
     void convert (const jit_block_list& blocks,
                   const std::list<jit_value *>& constants);
 
     void finish_phi (jit_phi *phi);
 
     void visit (jit_value *jvalue)
     {
@@ -313,43 +317,46 @@ namespace octave
     }
   };
 
   // type inference and SSA construction on the low level Octave IR
   class
   jit_infer
   {
   public:
+
     typedef jit_convert::variable_map variable_map;
 
     jit_infer (jit_factory& afactory, jit_block_list& ablocks,
                const variable_map& avmap);
 
-    jit_block_list& get_blocks (void) const { return blocks; }
+    jit_block_list& get_blocks (void) const { return m_blocks; }
 
-    jit_factory& get_factory (void) const { return factory; }
+    jit_factory& get_factory (void) const { return m_factory; }
 
     void infer (void);
+
   private:
-    jit_block_list& blocks;
-    jit_factory& factory;
-    const variable_map& vmap;
-    std::list<jit_instruction *> worklist;
+
+    jit_block_list& m_blocks;
+    jit_factory& m_factory;
+    const variable_map& m_vmap;
+    std::list<jit_instruction *> m_worklist;
 
     void append_users (jit_value *v);
 
     void append_users_term (jit_terminator *term);
 
     void construct_ssa (void);
 
     void do_construct_ssa (jit_block& block, size_t avisit_count);
 
-    jit_block& entry_block (void) { return *blocks.front (); }
+    jit_block& entry_block (void) { return *m_blocks.front (); }
 
-    jit_block& final_block (void) { return *blocks.back (); }
+    jit_block& final_block (void) { return *m_blocks.back (); }
 
     void place_releases (void);
 
     void push_worklist (jit_instruction *instr);
 
     void remove_dead ();
 
     void release_dead_phi (jit_block& ablock);
@@ -365,130 +372,148 @@ namespace octave
   class jit_module;
 
   class
   tree_jit
   {
     // ----- Constructor/destructor (singleton pattern) -----
 
   public:
+
     ~tree_jit (void);
 
   private:
+
     tree_jit (void);
     static tree_jit& instance (void);
 
     // ----- Initialization -----
 
   private:
+
     static bool initialized;
     bool do_initialize (void);
 
     // ----- Target machine ----
 
   public:
+
     static const llvm::TargetMachine* get_target_machine (void)
     { return instance ().target_machine; }
 
   private:
+
     llvm::TargetMachine *target_machine;
 
     // ----- Create LLVM modules and engines -----
 
   public:
+
     static jit::ModuleOwner
     open_new_module (const std::string& module_name = generate_unique_module_name ());
 
     static jit::EngineOwner
     create_new_engine (jit::ModuleOwner module_owner);
 
   private:
+
     jit::ModuleOwner
     do_open_new_module (const std::string& module_name) const;
 
     // ----- Registering JIT modules (module+engine pairs) -----
 
   public:
+
     static void register_jit_module (jit_module* jm)
     { instance ().do_register_jit_module (jm); }
+
     static void unregister_jit_module (jit_module* jm)
     { instance ().do_unregister_jit_module (jm); }
+
   private:
+
     // List of all currently registered jit modules
     std::list<jit_module*> jm_list;
     void do_register_jit_module (jit_module* jm);
     void do_unregister_jit_module (jit_module* jm);
     void do_dump_all_modules (void) const;
 
     // ----- Symbol resolution -----
 
   public:
+
     static void* getPointerToNamedFunction (const std::string &name)
     { return instance ().do_getPointerToNamedFunction (name); }
+
     static uint64_t getSymbolAddress (const std::string &name)
     { return instance ().do_getSymbolAddress (name); }
 
   private:
+
     void* do_getPointerToNamedFunction (const std::string &Name) const;
+
     uint64_t do_getSymbolAddress (const std::string &name) const;
 
     // ----- Generate unique identifiers -----
 
   public:
+
     static std::string generate_unique_forloop_name (void)
     { return std::string ("jittedForLoop")
         + std::to_string (next_forloop_number ++); }
     // FIXME: Check that the identifier does not exist
 
     static std::string generate_unique_function_name (void)
     { return std::string ("jittedFunction")
         + std::to_string (next_function_number ++); }
     // FIXME: Check that the identifier does not exist
 
     static std::string generate_unique_module_name (void)
     { return std::string ("octaveJITModule")
         + std::to_string (next_module_number ++); }
     // FIXME: Check that the identifier does not exist
 
   private:
+
     static int next_forloop_number;
     static int next_function_number;
     static int next_module_number;
 
     // ----- JIT and execute ASTs -----
 
   public:
+
     static bool execute (tree_simple_for_command& cmd,
                          const octave_value& bounds)
     { return instance ().do_execute (cmd, bounds); }
 
     static bool execute (tree_while_command& cmd)
     { return instance ().do_execute (cmd); }
 
     static bool execute (octave_user_function& fcn,
                          const octave_value_list& args,
                          octave_value_list& retval)
     { return instance ().do_execute (fcn, args, retval); }
 
   private:
+
     bool do_execute (tree_simple_for_command& cmd,
                      const octave_value& bounds);
 
     bool do_execute (tree_while_command& cmd);
 
     bool do_execute (octave_user_function& fcn,
                      const octave_value_list& args,
                      octave_value_list& retval);
 
     // ----- Miscellaneous -----
 
     bool enabled (void);
 
     size_t trip_count (const octave_value& bounds) const;
-
   };
 
 
   class
   jit_module
   {
     // TODO: Encapsulate all operations that can modify the module,
     //       and prevent them if the module has been finalized
@@ -538,75 +563,81 @@ namespace octave
     // Optimize a function in the LLVM module
     void optimize (llvm::Function *fn) const;
 
     // FIXME: Once this has been called, we should not be able
     // to change anything in the module...
     void finalizeObject (void);
 
   private:
+
     void do_add_global_mapping (const llvm::GlobalValue* gv, void* p) const;
 
-    llvm::Module *module;
-    llvm::ExecutionEngine *engine;
+    llvm::Module *m_module;
+    llvm::ExecutionEngine *m_engine;
   };
 
 
   class
   jit_info : public jit_module
   {
   public:
+
     // we use a pointer here so we don't have to include ov.h
     typedef std::map<std::string, const octave_value *> vmap;
 
     jit_info (tree& tee);
 
     jit_info (tree& tee, const octave_value& for_bounds);
 
     jit_info (tree_simple_for_command& tee, const octave_value& for_bounds);
 
     bool execute (const vmap& extra_vars = vmap ()) const;
 
     bool match (const vmap& extra_vars = vmap ()) const;
 
   private:
+
     typedef jit_convert::type_bound type_bound;
     typedef jit_convert::type_bound_vector type_bound_vector;
     typedef void (*jited_function)(octave_base_value**);
 
     void compile (tree& tee, jit_type *for_bounds = 0);
 
     octave_value find (const vmap& extra_vars, const std::string& vname) const;
 
     // LLVM function associated to this jit_info object
-    std::string llvm_function_name;
-    jited_function function;
+    std::string m_llvm_function_name;
+    jited_function m_function;
 
-    std::vector<std::pair<std::string, bool>> arguments;
-    type_bound_vector bounds;
+    std::vector<std::pair<std::string, bool>> m_arguments;
+    type_bound_vector m_bounds;
   };
 
 
   class
   jit_function_info : public jit_module
   {
   public:
+
     jit_function_info (octave_user_function& fcn,
                        const octave_value_list& ov_args);
 
     bool execute (const octave_value_list& ov_args,
                   octave_value_list& retval) const;
 
     bool match (const octave_value_list& ov_args) const;
+
   private:
+
     typedef octave_base_value *(*jited_function)(octave_base_value**);
 
     // LLVM function associated to this jit_info object
-    std::string llvm_function_name;
-    jited_function function;
+    std::string m_llvm_function_name;
+    jited_function m_function;
 
-    std::vector<jit_type *> argument_types;
+    std::vector<jit_type *> m_argument_types;
   };
-
 }
 
 #endif
+
 #endif
diff --git a/libinterp/parse-tree/pt-loop.cc b/libinterp/parse-tree/pt-loop.cc
--- a/libinterp/parse-tree/pt-loop.cc
+++ b/libinterp/parse-tree/pt-loop.cc
@@ -29,41 +29,41 @@ along with Octave; see the file COPYING.
 #include "pt-stmt.h"
 
 namespace octave
 {
   // While.
 
   tree_while_command::~tree_while_command (void)
   {
-    delete expr;
-    delete list;
-    delete lead_comm;
-    delete trail_comm;
+    delete m_expr;
+    delete m_list;
+    delete m_lead_comm;
+    delete m_trail_comm;
 #if defined (HAVE_LLVM)
-    delete compiled;
+    delete m_compiled;
 #endif
   }
 
   // For.
 
   tree_simple_for_command::~tree_simple_for_command (void)
   {
-    delete lhs;
-    delete expr;
-    delete maxproc;
-    delete list;
-    delete lead_comm;
-    delete trail_comm;
+    delete m_lhs;
+    delete m_expr;
+    delete m_maxproc;
+    delete m_list;
+    delete m_lead_comm;
+    delete m_trail_comm;
 #if defined (HAVE_LLVM)
-    delete compiled;
+    delete m_compiled;
 #endif
   }
 
   tree_complex_for_command::~tree_complex_for_command (void)
   {
-    delete lhs;
-    delete expr;
-    delete list;
-    delete lead_comm;
-    delete trail_comm;
+    delete m_lhs;
+    delete m_expr;
+    delete m_list;
+    delete m_lead_comm;
+    delete m_trail_comm;
   }
 }
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -40,121 +40,118 @@ namespace octave
 
   // While.
 
   class tree_while_command : public tree_command
   {
   public:
 
     tree_while_command (int l = -1, int c = -1)
-      : tree_command (l, c), expr (nullptr), list (nullptr),
-        lead_comm (nullptr), trail_comm (nullptr)
+      : tree_command (l, c), m_expr (nullptr), m_list (nullptr),
+        m_lead_comm (nullptr), m_trail_comm (nullptr)
 #if defined (HAVE_LLVM)
-      , compiled (nullptr)
+      , m_compiled (nullptr)
 #endif
     { }
 
     tree_while_command (tree_expression *e,
                         comment_list *lc = nullptr,
                         comment_list *tc = nullptr,
                         int l = -1, int c = -1)
-      : tree_command (l, c), expr (e), list (nullptr),
-        lead_comm (lc), trail_comm (tc)
+      : tree_command (l, c), m_expr (e), m_list (nullptr),
+        m_lead_comm (lc), m_trail_comm (tc)
 #if defined (HAVE_LLVM)
-      , compiled (nullptr)
+      , m_compiled (nullptr)
 #endif
     { }
 
     tree_while_command (tree_expression *e, tree_statement_list *lst,
                         comment_list *lc = nullptr,
                         comment_list *tc = nullptr,
                         int l = -1, int c = -1)
-      : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-        trail_comm (tc)
+      : tree_command (l, c), m_expr (e), m_list (lst), m_lead_comm (lc),
+        m_trail_comm (tc)
 #if defined (HAVE_LLVM)
-      , compiled (nullptr)
+      , m_compiled (nullptr)
 #endif
     { }
 
     // No copying!
 
     tree_while_command (const tree_while_command&) = delete;
 
     tree_while_command& operator = (const tree_while_command&) = delete;
 
     ~tree_while_command (void);
 
-    tree_expression * condition (void) { return expr; }
+    tree_expression * condition (void) { return m_expr; }
 
-    tree_statement_list * body (void) { return list; }
+    tree_statement_list * body (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_while_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
-    jit_info * get_info (void) const
-    {
-      return compiled;
-    }
+    jit_info * get_info (void) const { return m_compiled; }
 
-    void stash_info (jit_info *jinfo)
-    {
-      compiled = jinfo;
-    }
+    void stash_info (jit_info *jinfo) { m_compiled = jinfo; }
 #endif
 
   protected:
 
     // Expression to test.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // List of commands to execute.
-    tree_statement_list *list;
+    tree_statement_list *m_list;
 
     // Comment preceding WHILE token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding ENDWHILE token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
 
   private:
 
 #if defined (HAVE_LLVM)
     // compiled version of the loop
-    jit_info *compiled;
+    jit_info *m_compiled;
 #endif
   };
 
   // Do-Until.
 
   class tree_do_until_command : public tree_while_command
   {
   public:
 
     tree_do_until_command (int l = -1, int c = -1)
-      : tree_while_command (l, c) { }
+      : tree_while_command (l, c)
+    { }
 
     tree_do_until_command (tree_expression *e,
                            comment_list *lc = nullptr,
                            comment_list *tc = nullptr,
                            int l = -1, int c = -1)
-      : tree_while_command (e, lc, tc, l, c) { }
+      : tree_while_command (e, lc, tc, l, c)
+    { }
 
     tree_do_until_command (tree_expression *e, tree_statement_list *lst,
                            comment_list *lc = nullptr,
                            comment_list *tc = nullptr,
                            int l = -1, int c = -1)
-      : tree_while_command (e, lst, lc, tc, l, c) { }
+      : tree_while_command (e, lst, lc, tc, l, c)
+    { }
 
     // No copying!
 
     tree_do_until_command (const tree_do_until_command&) = delete;
 
     tree_do_until_command& operator = (const tree_do_until_command&) = delete;
 
     ~tree_do_until_command (void) = default;
@@ -167,164 +164,166 @@ namespace octave
 
   // For.
 
   class tree_simple_for_command : public tree_command
   {
   public:
 
     tree_simple_for_command (int l = -1, int c = -1)
-      : tree_command (l, c), parallel (false), lhs (nullptr), expr (nullptr),
-        maxproc (nullptr), list (nullptr), lead_comm (nullptr),
-        trail_comm (nullptr)
+      : tree_command (l, c), m_parallel (false), m_lhs (nullptr),
+        m_expr (nullptr), m_maxproc (nullptr), m_list (nullptr),
+        m_lead_comm (nullptr), m_trail_comm (nullptr)
 #if defined (HAVE_LLVM)
-      , compiled (nullptr)
+      , m_compiled (nullptr)
 #endif
     { }
 
     tree_simple_for_command (bool parallel_arg, tree_expression *le,
                              tree_expression *re,
                              tree_expression *maxproc_arg,
                              tree_statement_list *lst,
                              comment_list *lc = nullptr,
                              comment_list *tc = nullptr,
                              int l = -1, int c = -1)
-      : tree_command (l, c), parallel (parallel_arg), lhs (le),
-        expr (re), maxproc (maxproc_arg), list (lst),
-        lead_comm (lc), trail_comm (tc)
+      : tree_command (l, c), m_parallel (parallel_arg), m_lhs (le),
+        m_expr (re), m_maxproc (maxproc_arg), m_list (lst),
+        m_lead_comm (lc), m_trail_comm (tc)
 #if defined (HAVE_LLVM)
-      , compiled (0)
+      , m_compiled (0)
 #endif
     { }
 
     // No copying!
 
     tree_simple_for_command (const tree_simple_for_command&) = delete;
 
     tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
 
     ~tree_simple_for_command (void);
 
-    bool in_parallel (void) { return parallel; }
+    bool in_parallel (void) { return m_parallel; }
 
-    tree_expression * left_hand_side (void) { return lhs; }
+    tree_expression * left_hand_side (void) { return m_lhs; }
 
-    tree_expression * control_expr (void) { return expr; }
+    tree_expression * control_expr (void) { return m_expr; }
 
-    tree_expression * maxproc_expr (void) { return maxproc; }
+    tree_expression * maxproc_expr (void) { return m_maxproc; }
 
-    tree_statement_list * body (void) { return list; }
+    tree_statement_list * body (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_for_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
     jit_info * get_info (void) const
     {
-      return compiled;
+      return m_compiled;
     }
 
     void stash_info (jit_info *jinfo)
     {
-      compiled = jinfo;
+      m_compiled = jinfo;
     }
 #endif
 
   private:
     // TRUE means operate in parallel (subject to the value of the
     // maxproc expression).
-    bool parallel;
+    bool m_parallel;
 
     // Expression to modify.
-    tree_expression *lhs;
+    tree_expression *m_lhs;
 
     // Expression to evaluate.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // Expression to tell how many processors should be used (only valid
     // if parallel is TRUE).
-    tree_expression *maxproc;
+    tree_expression *m_maxproc;
 
     // List of commands to execute.
-    tree_statement_list *list;
+    tree_statement_list *m_list;
 
     // Comment preceding FOR token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding ENDFOR token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
 
 #if defined (HAVE_LLVM)
     // compiled version of the loop
-    jit_info *compiled;
+    jit_info *m_compiled;
 #endif
   };
 
   class tree_complex_for_command : public tree_command
   {
   public:
 
     tree_complex_for_command (int l = -1, int c = -1)
-      : tree_command (l, c), lhs (nullptr), expr (nullptr), list (nullptr),
-        lead_comm (nullptr), trail_comm (nullptr) { }
+      : tree_command (l, c), m_lhs (nullptr), m_expr (nullptr),
+        m_list (nullptr), m_lead_comm (nullptr), m_trail_comm (nullptr)
+    { }
 
     tree_complex_for_command (tree_argument_list *le, tree_expression *re,
                               tree_statement_list *lst,
                               comment_list *lc = nullptr,
                               comment_list *tc = nullptr,
                               int l = -1, int c = -1)
-      : tree_command (l, c), lhs (le), expr (re), list (lst),
-        lead_comm (lc), trail_comm (tc) { }
+      : tree_command (l, c), m_lhs (le), m_expr (re), m_list (lst),
+        m_lead_comm (lc), m_trail_comm (tc)
+    { }
 
     // No copying!
 
     tree_complex_for_command (const tree_complex_for_command&) = delete;
 
     tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
 
     ~tree_complex_for_command (void);
 
-    tree_argument_list * left_hand_side (void) { return lhs; }
+    tree_argument_list * left_hand_side (void) { return m_lhs; }
 
-    tree_expression * control_expr (void) { return expr; }
+    tree_expression * control_expr (void) { return m_expr; }
 
-    tree_statement_list * body (void) { return list; }
+    tree_statement_list * body (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_complex_for_command (*this);
     }
 
   private:
 
     // Expression to modify.
-    tree_argument_list *lhs;
+    tree_argument_list *m_lhs;
 
     // Expression to evaluate.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // List of commands to execute.
-    tree_statement_list *list;
+    tree_statement_list *m_list;
 
     // Comment preceding FOR token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding ENDFOR token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_while_command' instead")
 typedef octave::tree_while_command tree_while_command;
 
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -46,56 +46,56 @@ namespace octave
 
     enum in_or_out
       {
         in = 1,
         out = 2
       };
 
     tree_parameter_list (void)
-      : marked_for_varargs (0) { }
+      : m_marked_for_varargs (0) { }
 
     tree_parameter_list (tree_decl_elt *t)
-      : marked_for_varargs (0) { append (t); }
+      : m_marked_for_varargs (0) { append (t); }
 
     tree_parameter_list (tree_identifier *id)
-      : marked_for_varargs (0) { append (new tree_decl_elt (id)); }
+      : m_marked_for_varargs (0) { append (new tree_decl_elt (id)); }
 
     // No copying!
 
     tree_parameter_list (const tree_parameter_list&) = delete;
 
     tree_parameter_list& operator = (const tree_parameter_list&) = delete;
 
     ~tree_parameter_list (void);
 
     void mark_as_formal_parameters (void);
 
-    void mark_varargs (void) { marked_for_varargs = 1; }
+    void mark_varargs (void) { m_marked_for_varargs = 1; }
 
-    void mark_varargs_only (void) { marked_for_varargs = -1; }
+    void mark_varargs_only (void) { m_marked_for_varargs = -1; }
 
-    bool takes_varargs (void) const { return marked_for_varargs != 0; }
+    bool takes_varargs (void) const { return m_marked_for_varargs != 0; }
 
-    bool varargs_only (void) { return (marked_for_varargs < 0); }
+    bool varargs_only (void) { return (m_marked_for_varargs < 0); }
 
     bool is_defined (symbol_record::context_id context);
 
     std::list<std::string> variable_names (void) const;
 
     tree_parameter_list * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_parameter_list (*this);
     }
 
   private:
 
-    int marked_for_varargs;
+    int m_marked_for_varargs;
   };
 
   // Return lists.  Used to hold the right hand sides of multiple
   // assignment expressions.
 
   class tree_return_list : public base_list<tree_index_expression *>
   {
   public:
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -38,24 +38,24 @@ namespace octave
 {
   void
   tree_print_code::visit_anon_fcn_handle (tree_anon_fcn_handle& afh)
   {
     indent ();
 
     print_parens (afh, "(");
 
-    os << "@(";
+    m_os << "@(";
 
     tree_parameter_list *param_list = afh.parameter_list ();
 
     if (param_list)
       param_list->accept (*this);
 
-    os << ") ";
+    m_os << ") ";
 
     print_fcn_handle_body (afh.expression ());
 
     print_parens (afh, ")");
   }
 
   void
   tree_print_code::visit_argument_list (tree_argument_list& lst)
@@ -66,49 +66,49 @@ namespace octave
       {
         tree_expression *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << ", ";
+              m_os << ", ";
           }
       }
   }
 
   void
   tree_print_code::visit_binary_expression (tree_binary_expression& expr)
   {
     indent ();
 
     print_parens (expr, "(");
 
     tree_expression *op1 = expr.lhs ();
 
     if (op1)
       op1->accept (*this);
 
-    os << ' ' << expr.oper () << ' ';
+    m_os << ' ' << expr.oper () << ' ';
 
     tree_expression *op2 = expr.rhs ();
 
     if (op2)
       op2->accept (*this);
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_break_command (tree_break_command&)
   {
     indent ();
 
-    os << "break";
+    m_os << "break";
   }
 
   void
   tree_print_code::visit_colon_expression (tree_colon_expression& expr)
   {
     indent ();
 
     print_parens (expr, "(");
@@ -119,45 +119,45 @@ namespace octave
       op1->accept (*this);
 
     // Stupid syntax.
 
     tree_expression *op3 = expr.increment ();
 
     if (op3)
       {
-        os << ':';
+        m_os << ':';
         op3->accept (*this);
       }
 
     tree_expression *op2 = expr.limit ();
 
     if (op2)
       {
-        os << ':';
+        m_os << ':';
         op2->accept (*this);
       }
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_continue_command (tree_continue_command&)
   {
     indent ();
 
-    os << "continue";
+    m_os << "continue";
   }
 
   void
   tree_print_code::visit_decl_command (tree_decl_command& cmd)
   {
     indent ();
 
-    os << cmd.name () << ' ';
+    m_os << cmd.name () << ' ';
 
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       init_list->accept (*this);
   }
 
   void
@@ -169,70 +169,70 @@ namespace octave
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << ", ";
+              m_os << ", ";
           }
       }
   }
 
   void
   tree_print_code::visit_decl_elt (tree_decl_elt& cmd)
   {
     tree_identifier *id = cmd.ident ();
 
     if (id)
       id->accept (*this);
 
     tree_expression *expr = cmd.expression ();
 
     if (expr)
       {
-        os << " = ";
+        m_os << " = ";
 
         expr->accept (*this);
       }
   }
 
   void
   tree_print_code::visit_simple_for_command (tree_simple_for_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << (cmd.in_parallel () ? "parfor " : "for ");
+    m_os << (cmd.in_parallel () ? "parfor " : "for ");
 
     tree_expression *lhs = cmd.left_hand_side ();
 
     tree_expression *maxproc = cmd.maxproc_expr ();
 
     if (maxproc)
-      os << '(';
+      m_os << '(';
 
     if (lhs)
       lhs->accept (*this);
 
-    os << " = ";
+    m_os << " = ";
 
     tree_expression *expr = cmd.control_expr ();
 
     if (expr)
       expr->accept (*this);
 
     if (maxproc)
       {
-        os << ", ";
+        m_os << ", ";
         maxproc->accept (*this);
-        os << ')';
+        m_os << ')';
       }
 
     newline ();
 
     tree_statement_list *list = cmd.body ();
 
     if (list)
       {
@@ -242,36 +242,36 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << (cmd.in_parallel () ? "endparfor" : "endfor");
+    m_os << (cmd.in_parallel () ? "endparfor" : "endfor");
   }
 
   void
   tree_print_code::visit_complex_for_command (tree_complex_for_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "for [";
-    nesting.push ('[');
+    m_os << "for [";
+    m_nesting.push ('[');
 
     tree_argument_list *lhs = cmd.left_hand_side ();
 
     if (lhs)
       lhs->accept (*this);
 
-    nesting.pop ();
-    os << "] = ";
+    m_nesting.pop ();
+    m_os << "] = ";
 
     tree_expression *expr = cmd.control_expr ();
 
     if (expr)
       expr->accept (*this);
 
     newline ();
 
@@ -285,17 +285,17 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "endfor";
+    m_os << "endfor";
   }
 
   void
   tree_print_code::visit_octave_user_script (octave_user_script& fcn)
   {
     reset ();
 
     tree_statement_list *cmd_list = fcn.body ();
@@ -333,89 +333,89 @@ namespace octave
     if (leading_comment)
       {
         print_comment_list (leading_comment);
         newline ();
       }
 
     indent ();
 
-    os << "function ";
+    m_os << "function ";
 
     tree_parameter_list *ret_list = fcn.return_list ();
 
     if (ret_list)
       {
         bool takes_var_return = fcn.takes_var_return ();
 
         int len = ret_list->length ();
 
         if (len > 1 || takes_var_return)
           {
-            os << '[';
-            nesting.push ('[');
+            m_os << '[';
+            m_nesting.push ('[');
           }
 
         ret_list->accept (*this);
 
         if (takes_var_return)
           {
             if (len > 0)
-              os << ", ";
+              m_os << ", ";
 
-            os << "varargout";
+            m_os << "varargout";
           }
 
         if (len > 1 || takes_var_return)
           {
-            nesting.pop ();
-            os << ']';
+            m_nesting.pop ();
+            m_os << ']';
           }
 
-        os << " = ";
+        m_os << " = ";
       }
 
     std::string fcn_name = fcn.name ();
 
-    os << (fcn_name.empty () ? "(empty)" : fcn_name) << ' ';
+    m_os << (fcn_name.empty () ? "(empty)" : fcn_name) << ' ';
 
     tree_parameter_list *param_list = fcn.parameter_list ();
 
     if (param_list)
       {
         bool takes_varargs = fcn.takes_varargs ();
 
         int len = param_list->length ();
 
         if (len > 0 || takes_varargs)
           {
-            os << '(';
-            nesting.push ('(');
+            m_os << '(';
+            m_nesting.push ('(');
           }
 
         param_list->accept (*this);
 
         if (takes_varargs)
           {
             if (len > 0)
-              os << ", ";
+              m_os << ", ";
 
-            os << "varargin";
+            m_os << "varargin";
           }
 
         if (len > 0 || takes_varargs)
           {
-            nesting.pop ();
-            os << ')';
+            m_nesting.pop ();
+            m_os << ')';
             newline ();
           }
       }
     else
       {
-        os << "()";
+        m_os << "()";
         newline ();
       }
   }
 
   void
   tree_print_code::visit_octave_user_function_trailer (octave_user_function& fcn)
   {
     print_indented_comment (fcn.trailing_comment ());
@@ -439,17 +439,17 @@ namespace octave
   void
   tree_print_code::visit_identifier (tree_identifier& id)
   {
     indent ();
 
     print_parens (id, "(");
 
     std::string nm = id.name ();
-    os << (nm.empty () ? "(empty)" : nm);
+    m_os << (nm.empty () ? "(empty)" : nm);
 
     print_parens (id, ")");
   }
 
   void
   tree_print_code::visit_if_clause (tree_if_clause& cmd)
   {
     tree_expression *expr = cmd.condition ();
@@ -473,28 +473,28 @@ namespace octave
 
   void
   tree_print_code::visit_if_command (tree_if_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "if ";
+    m_os << "if ";
 
     tree_if_command_list *list = cmd.cmd_list ();
 
     if (list)
       list->accept (*this);
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "endif";
+    m_os << "endif";
   }
 
   void
   tree_print_code::visit_if_command_list (tree_if_command_list& lst)
   {
     tree_if_command_list::iterator p = lst.begin ();
 
     bool first_elt = true;
@@ -507,19 +507,19 @@ namespace octave
           {
             if (! first_elt)
               {
                 print_indented_comment (elt->leading_comment ());
 
                 indent ();
 
                 if (elt->is_else_clause ())
-                  os << "else";
+                  m_os << "else";
                 else
-                  os << "elseif ";
+                  m_os << "elseif ";
               }
 
             elt->accept (*this);
           }
 
         first_elt = false;
       }
   }
@@ -546,57 +546,57 @@ namespace octave
     std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
 
     for (int i = 0; i < n; i++)
       {
         switch (type_tags[i])
           {
           case '(':
             {
-              char nc = nesting.top ();
+              char nc = m_nesting.top ();
               if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-                os << '(';
+                m_os << '(';
               else
-                os << " (";
-              nesting.push ('(');
+                m_os << " (";
+              m_nesting.push ('(');
 
               tree_argument_list *l = *p_arg_lists;
               if (l)
                 l->accept (*this);
 
-              nesting.pop ();
-              os << ')';
+              m_nesting.pop ();
+              m_os << ')';
             }
             break;
 
           case '{':
             {
-              char nc = nesting.top ();
+              char nc = m_nesting.top ();
               if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-                os << '{';
+                m_os << '{';
               else
-                os << " {";
+                m_os << " {";
               // We only care about whitespace inside [] and {} when we
               // are defining matrix and cell objects, not when indexing.
-              nesting.push ('(');
+              m_nesting.push ('(');
 
               tree_argument_list *l = *p_arg_lists;
               if (l)
                 l->accept (*this);
 
-              nesting.pop ();
-              os << '}';
+              m_nesting.pop ();
+              m_os << '}';
             }
             break;
 
           case '.':
             {
               string_vector nm = *p_arg_names;
               assert (nm.numel () == 1);
-              os << '.' << nm(0);
+              m_os << '.' << nm(0);
             }
             break;
 
           default:
             panic_impossible ();
           }
 
         p_arg_lists++;
@@ -608,67 +608,67 @@ namespace octave
 
   void
   tree_print_code::visit_matrix (tree_matrix& lst)
   {
     indent ();
 
     print_parens (lst, "(");
 
-    os << '[';
-    nesting.push ('[');
+    m_os << '[';
+    m_nesting.push ('[');
 
     tree_matrix::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << "; ";
+              m_os << "; ";
           }
       }
 
-    nesting.pop ();
-    os << ']';
+    m_nesting.pop ();
+    m_os << ']';
 
     print_parens (lst, ")");
   }
 
   void
   tree_print_code::visit_cell (tree_cell& lst)
   {
     indent ();
 
     print_parens (lst, "(");
 
-    os << '{';
-    nesting.push ('{');
+    m_os << '{';
+    m_nesting.push ('{');
 
     tree_cell::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << "; ";
+              m_os << "; ";
           }
       }
 
-    nesting.pop ();
-    os << '}';
+    m_nesting.pop ();
+    m_os << '}';
 
     print_parens (lst, ")");
   }
 
   void
   tree_print_code::visit_multi_assignment (tree_multi_assignment& expr)
   {
     indent ();
@@ -678,82 +678,82 @@ namespace octave
     tree_argument_list *lhs = expr.left_hand_side ();
 
     if (lhs)
       {
         int len = lhs->length ();
 
         if (len > 1)
           {
-            os << '[';
-            nesting.push ('[');
+            m_os << '[';
+            m_nesting.push ('[');
           }
 
         lhs->accept (*this);
 
         if (len > 1)
           {
-            nesting.pop ();
-            os << ']';
+            m_nesting.pop ();
+            m_os << ']';
           }
       }
 
-    os << ' ' << expr.oper () << ' ';
+    m_os << ' ' << expr.oper () << ' ';
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       rhs->accept (*this);
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_no_op_command (tree_no_op_command& cmd)
   {
-    if (cmd.is_end_of_fcn_or_script () && curr_print_indent_level > 1)
+    if (cmd.is_end_of_fcn_or_script () && m_curr_print_indent_level > 1)
       decrement_indent_level ();
 
     indent ();
 
-    os << cmd.original_command ();
+    m_os << cmd.original_command ();
   }
 
   void
   tree_print_code::visit_constant (tree_constant& val)
   {
     indent ();
 
     print_parens (val, "(");
 
-    val.print_raw (os, true, print_original_text);
+    val.print_raw (m_os, true, m_print_original_text);
 
     print_parens (val, ")");
   }
 
   void
   tree_print_code::visit_fcn_handle (tree_fcn_handle& fh)
   {
     indent ();
 
     print_parens (fh, "(");
 
-    fh.print_raw (os, true, print_original_text);
+    fh.print_raw (m_os, true, m_print_original_text);
 
     print_parens (fh, ")");
   }
 
   void
   tree_print_code::visit_funcall (tree_funcall& fc)
   {
     indent ();
 
     print_parens (fc, "(");
 
-    fc.print_raw (os, true, print_original_text);
+    fc.print_raw (m_os, true, m_print_original_text);
 
     print_parens (fc, ")");
   }
 
   void
   tree_print_code::visit_parameter_list (tree_parameter_list& lst)
   {
     tree_parameter_list::iterator p = lst.begin ();
@@ -762,95 +762,95 @@ namespace octave
       {
         tree_decl_elt *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << ", ";
+              m_os << ", ";
           }
       }
   }
 
   void
   tree_print_code::visit_postfix_expression (tree_postfix_expression& expr)
   {
     indent ();
 
     print_parens (expr, "(");
 
     tree_expression *e = expr.operand ();
 
     if (e)
       e->accept (*this);
 
-    os << expr.oper ();
+    m_os << expr.oper ();
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_prefix_expression (tree_prefix_expression& expr)
   {
     indent ();
 
     print_parens (expr, "(");
 
-    os << expr.oper ();
+    m_os << expr.oper ();
 
     tree_expression *e = expr.operand ();
 
     if (e)
       e->accept (*this);
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_return_command (tree_return_command&)
   {
     indent ();
 
-    os << "return";
+    m_os << "return";
   }
 
   void
   tree_print_code::visit_return_list (tree_return_list& lst)
   {
     tree_return_list::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_index_expression *elt = *p++;
 
         if (elt)
           {
             elt->accept (*this);
 
             if (p != lst.end ())
-              os << ", ";
+              m_os << ", ";
           }
       }
   }
 
   void
   tree_print_code::visit_simple_assignment (tree_simple_assignment& expr)
   {
     indent ();
 
     print_parens (expr, "(");
 
     tree_expression *lhs = expr.left_hand_side ();
 
     if (lhs)
       lhs->accept (*this);
 
-    os << ' ' << expr.oper () << ' ';
+    m_os << ' ' << expr.oper () << ' ';
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       rhs->accept (*this);
 
     print_parens (expr, ")");
   }
@@ -873,17 +873,17 @@ namespace octave
         tree_expression *expr = stmt.expression ();
 
         if (expr)
           {
             expr->accept (*this);
 
             if (! stmt.print_result ())
               {
-                os << ';';
+                m_os << ';';
                 newline (" ");
               }
             else
               newline ();
           }
       }
   }
 
@@ -900,19 +900,19 @@ namespace octave
   void
   tree_print_code::visit_switch_case (tree_switch_case& cs)
   {
     print_comment_list (cs.leading_comment ());
 
     indent ();
 
     if (cs.is_default_case ())
-      os << "otherwise";
+      m_os << "otherwise";
     else
-      os << "case ";
+      m_os << "case ";
 
     tree_expression *label = cs.case_label ();
 
     if (label)
       label->accept (*this);
 
     newline ();
 
@@ -946,17 +946,17 @@ namespace octave
 
   void
   tree_print_code::visit_switch_command (tree_switch_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "switch ";
+    m_os << "switch ";
 
     tree_expression *expr = cmd.switch_value ();
 
     if (expr)
       expr->accept (*this);
 
     newline ();
 
@@ -970,27 +970,27 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.leading_comment ());
 
     indent ();
 
-    os << "endswitch";
+    m_os << "endswitch";
   }
 
   void
   tree_print_code::visit_try_catch_command (tree_try_catch_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "try";
+    m_os << "try";
 
     newline ();
 
     tree_statement_list *try_code = cmd.body ();
     tree_identifier *expr_id = cmd.identifier ();
 
     if (try_code)
       {
@@ -1000,21 +1000,21 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.middle_comment ());
 
     indent ();
 
-    os << "catch";
+    m_os << "catch";
 
     if (expr_id)
       {
-        os << ' ';
+        m_os << ' ';
         expr_id->accept (*this);
       }
 
     newline ();
 
     tree_statement_list *catch_code = cmd.cleanup ();
 
     if (catch_code)
@@ -1025,27 +1025,27 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "end_try_catch";
+    m_os << "end_try_catch";
   }
 
   void
   tree_print_code::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "unwind_protect";
+    m_os << "unwind_protect";
 
     newline ();
 
     tree_statement_list *unwind_protect_code = cmd.body ();
 
     if (unwind_protect_code)
       {
         increment_indent_level ();
@@ -1054,17 +1054,17 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.middle_comment ());
 
     indent ();
 
-    os << "unwind_protect_cleanup";
+    m_os << "unwind_protect_cleanup";
 
     newline ();
 
     tree_statement_list *cleanup_code = cmd.cleanup ();
 
     if (cleanup_code)
       {
         increment_indent_level ();
@@ -1073,27 +1073,27 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "end_unwind_protect";
+    m_os << "end_unwind_protect";
   }
 
   void
   tree_print_code::visit_while_command (tree_while_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "while ";
+    m_os << "while ";
 
     tree_expression *expr = cmd.condition ();
 
     if (expr)
       expr->accept (*this);
 
     newline ();
 
@@ -1107,27 +1107,27 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "endwhile";
+    m_os << "endwhile";
   }
 
   void
   tree_print_code::visit_do_until_command (tree_do_until_command& cmd)
   {
     print_comment_list (cmd.leading_comment ());
 
     indent ();
 
-    os << "do";
+    m_os << "do";
 
     newline ();
 
     tree_statement_list *list = cmd.body ();
 
     if (list)
       {
         increment_indent_level ();
@@ -1136,90 +1136,90 @@ namespace octave
 
         decrement_indent_level ();
       }
 
     print_indented_comment (cmd.trailing_comment ());
 
     indent ();
 
-    os << "until ";
+    m_os << "until ";
 
     tree_expression *expr = cmd.condition ();
 
     if (expr)
       expr->accept (*this);
 
     newline ();
   }
 
   void
   tree_print_code::print_fcn_handle_body (tree_expression *e)
   {
     if (e)
       {
-        suppress_newlines++;
+        m_suppress_newlines++;
         e->accept (*this);
-        suppress_newlines--;
+        m_suppress_newlines--;
       }
   }
 
   // Each print_code() function should call this before printing anything.
 
   void
   tree_print_code::indent (void)
   {
-    assert (curr_print_indent_level >= 0);
+    assert (m_curr_print_indent_level >= 0);
 
-    if (beginning_of_line)
+    if (m_beginning_of_line)
       {
-        os << prefix;
+        m_os << m_prefix;
 
-        os << std::string (curr_print_indent_level, ' ');
+        m_os << std::string (m_curr_print_indent_level, ' ');
 
-        beginning_of_line = false;
+        m_beginning_of_line = false;
       }
   }
 
   // All print_code() functions should use this to print new lines.
 
   void
   tree_print_code::newline (const char *alt_txt)
   {
-    if (suppress_newlines)
-      os << alt_txt;
+    if (m_suppress_newlines)
+      m_os << alt_txt;
     else
       {
         // Print prefix for blank lines.
         indent ();
 
-        os << "\n";
+        m_os << "\n";
 
-        beginning_of_line = true;
+        m_beginning_of_line = true;
       }
   }
 
   // For ressetting print_code state.
 
   void
   tree_print_code::reset (void)
   {
-    beginning_of_line = true;
-    curr_print_indent_level = 0;
-    while (nesting.top () != 'n')
-      nesting.pop ();
+    m_beginning_of_line = true;
+    m_curr_print_indent_level = 0;
+    while (m_nesting.top () != 'n')
+      m_nesting.pop ();
   }
 
   void
   tree_print_code::print_parens (const tree_expression& expr, const char *txt)
   {
     int n = expr.paren_count ();
 
     for (int i = 0; i < n; i++)
-      os << txt;
+      m_os << txt;
   }
 
   void
   tree_print_code::print_comment_elt (const comment_elt& elt)
   {
     bool printed_something = false;
 
     bool prev_char_was_newline = false;
@@ -1241,44 +1241,44 @@ namespace octave
         if (c == '\n')
           {
             if (prev_char_was_newline)
               {
                 printed_something = true;
 
                 indent ();
 
-                os << "##";
+                m_os << "##";
               }
 
             newline ();
 
             prev_char_was_newline = true;
           }
         else
           {
-            if (beginning_of_line)
+            if (m_beginning_of_line)
               {
                 printed_something = true;
 
                 indent ();
 
-                os << "##";
+                m_os << "##";
 
                 if (! (isspace (c) || c == '!'))
-                  os << ' ';
+                  m_os << ' ';
               }
 
-            os << static_cast<char> (c);
+            m_os << static_cast<char> (c);
 
             prev_char_was_newline = false;
           }
       }
 
-    if (printed_something && ! beginning_of_line)
+    if (printed_something && ! m_beginning_of_line)
       newline ();
   }
 
   void
   tree_print_code::print_comment_list (comment_list *comment_list)
   {
     if (comment_list)
       {
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -41,23 +41,23 @@ namespace octave
 
   class tree_print_code : public tree_walker
   {
   public:
 
     tree_print_code (std::ostream& os_arg,
                      const std::string& pfx = "",
                      bool pr_orig_txt = true)
-      : os (os_arg), prefix (pfx), nesting (),
-        print_original_text (pr_orig_txt),
-        curr_print_indent_level (0), beginning_of_line (true),
-        suppress_newlines (0)
+      : m_os (os_arg), m_prefix (pfx), m_nesting (),
+        m_print_original_text (pr_orig_txt),
+        m_curr_print_indent_level (0), m_beginning_of_line (true),
+        m_suppress_newlines (0)
     {
       // For "none".
-      nesting.push ('n');
+      m_nesting.push ('n');
     }
 
     // No copying!
 
     tree_print_code (const tree_print_code&) = delete;
 
     tree_print_code& operator = (const tree_print_code&) = delete;
 
@@ -148,38 +148,38 @@ namespace octave
     void visit_while_command (tree_while_command&);
 
     void visit_do_until_command (tree_do_until_command&);
 
     void print_fcn_handle_body (tree_expression *);
 
   private:
 
-    std::ostream& os;
+    std::ostream& m_os;
 
-    std::string prefix;
+    std::string m_prefix;
 
-    std::stack<char> nesting;
+    std::stack<char> m_nesting;
 
-    bool print_original_text;
+    bool m_print_original_text;
 
     // Current indentation.
-    int curr_print_indent_level;
+    int m_curr_print_indent_level;
 
     // TRUE means we are at the beginning of a line.
-    bool beginning_of_line;
+    bool m_beginning_of_line;
 
     // Nonzero means we are not printing newlines and indenting.
-    int suppress_newlines;
+    int m_suppress_newlines;
 
-    void reset_indent_level (void) { curr_print_indent_level = 0; }
+    void reset_indent_level (void) { m_curr_print_indent_level = 0; }
 
-    void increment_indent_level (void) { curr_print_indent_level += 2; }
+    void increment_indent_level (void) { m_curr_print_indent_level += 2; }
 
-    void decrement_indent_level (void) { curr_print_indent_level -= 2; }
+    void decrement_indent_level (void) { m_curr_print_indent_level -= 2; }
 
     void newline (const char *alt_txt = ", ");
 
     void indent (void);
 
     void reset (void);
 
     void print_parens (const tree_expression& expr, const char *txt);
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -28,41 +28,41 @@ along with Octave; see the file COPYING.
 #include "pt-stmt.h"
 
 namespace octave
 {
   // If clauses.
 
   tree_if_clause::~tree_if_clause (void)
   {
-    delete expr;
-    delete list;
-    delete lead_comm;
+    delete m_expr;
+    delete m_list;
+    delete m_lead_comm;
   }
 
   // If.
 
   tree_if_command::~tree_if_command (void)
   {
-    delete list;
-    delete lead_comm;
-    delete trail_comm;
+    delete m_list;
+    delete m_lead_comm;
+    delete m_trail_comm;
   }
 
   // Switch cases.
 
   tree_switch_case::~tree_switch_case (void)
   {
-    delete label;
-    delete list;
-    delete lead_comm;
+    delete m_label;
+    delete m_list;
+    delete m_lead_comm;
   }
 
   // Switch.
 
   tree_switch_command::~tree_switch_command (void)
   {
-    delete expr;
-    delete list;
-    delete lead_comm;
-    delete trail_comm;
+    delete m_expr;
+    delete m_list;
+    delete m_lead_comm;
+    delete m_trail_comm;
   }
 }
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -37,58 +37,58 @@ namespace octave
 
   // If.
 
   class tree_if_clause : public tree
   {
   public:
 
     tree_if_clause (int l = -1, int c = -1)
-      : tree (l, c), expr (nullptr), list (nullptr), lead_comm (nullptr) { }
+      : tree (l, c), m_expr (nullptr), m_list (nullptr), m_lead_comm (nullptr) { }
 
     tree_if_clause (tree_statement_list *sl, comment_list *lc = nullptr,
                     int l = -1, int c = -1)
-      : tree (l, c), expr (nullptr), list (sl), lead_comm (lc) { }
+      : tree (l, c), m_expr (nullptr), m_list (sl), m_lead_comm (lc) { }
 
     tree_if_clause (tree_expression *e, tree_statement_list *sl,
                     comment_list *lc = nullptr,
                     int l = -1, int c = -1)
-      : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
+      : tree (l, c), m_expr (e), m_list (sl), m_lead_comm (lc) { }
 
     // No copying!
 
     tree_if_clause (const tree_if_clause&) = delete;
 
     tree_if_clause& operator = (const tree_if_clause&) = delete;
 
     ~tree_if_clause (void);
 
-    bool is_else_clause (void) { return ! expr; }
+    bool is_else_clause (void) { return ! m_expr; }
 
-    tree_expression * condition (void) { return expr; }
+    tree_expression * condition (void) { return m_expr; }
 
-    tree_statement_list * commands (void) { return list; }
+    tree_statement_list * commands (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_clause (*this);
     }
 
   private:
 
     // The condition to test.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // The list of statements to evaluate if expr is true.
-    tree_statement_list *list;
+    tree_statement_list *m_list;
 
     // Comment preceding ELSE or ELSEIF token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
   };
 
   class tree_if_command_list : public base_list<tree_if_clause *>
   {
   public:
 
     tree_if_command_list (void) { }
 
@@ -116,104 +116,104 @@ namespace octave
     }
   };
 
   class tree_if_command : public tree_command
   {
   public:
 
     tree_if_command (int l = -1, int c = -1)
-      : tree_command (l, c), list (nullptr),
-        lead_comm (nullptr), trail_comm (nullptr)
+      : tree_command (l, c), m_list (nullptr),
+        m_lead_comm (nullptr), m_trail_comm (nullptr)
     { }
 
     tree_if_command (tree_if_command_list *lst, comment_list *lc,
                      comment_list *tc, int l = -1, int c = -1)
-      : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
+      : tree_command (l, c), m_list (lst), m_lead_comm (lc), m_trail_comm (tc) { }
 
     // No copying!
 
     tree_if_command (const tree_if_command&) = delete;
 
     tree_if_command& operator = (const tree_if_command&) = delete;
 
     ~tree_if_command (void);
 
-    tree_if_command_list * cmd_list (void) { return list; }
+    tree_if_command_list * cmd_list (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_command (*this);
     }
 
   private:
 
     // List of if commands (if, elseif, elseif, ... else, endif)
-    tree_if_command_list *list;
+    tree_if_command_list *m_list;
 
     // Comment preceding IF token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding ENDIF token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 
   // Switch.
 
   class tree_switch_case : public tree
   {
   public:
 
     tree_switch_case (int l = -1, int c = -1)
-      : tree (l, c), label (nullptr), list (nullptr), lead_comm (nullptr) { }
+      : tree (l, c), m_label (nullptr), m_list (nullptr), m_lead_comm (nullptr) { }
 
     tree_switch_case (tree_statement_list *sl, comment_list *lc = nullptr,
                       int l = -1, int c = -1)
-      : tree (l, c), label (nullptr), list (sl), lead_comm (lc) { }
+      : tree (l, c), m_label (nullptr), m_list (sl), m_lead_comm (lc) { }
 
     tree_switch_case (tree_expression *e, tree_statement_list *sl,
                       comment_list *lc = nullptr,
                       int l = -1, int c = -1)
-      : tree (l, c), label (e), list (sl), lead_comm (lc) { }
+      : tree (l, c), m_label (e), m_list (sl), m_lead_comm (lc) { }
 
     // No copying!
 
     tree_switch_case (const tree_switch_case&) = delete;
 
     tree_switch_case& operator = (const tree_switch_case&) = delete;
 
     ~tree_switch_case (void);
 
-    bool is_default_case (void) { return ! label; }
+    bool is_default_case (void) { return ! m_label; }
 
-    tree_expression * case_label (void) { return label; }
+    tree_expression * case_label (void) { return m_label; }
 
-    tree_statement_list * commands (void) { return list; }
+    tree_statement_list * commands (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_case (*this);
     }
 
   private:
 
     // The case label.
-    tree_expression *label;
+    tree_expression *m_label;
 
     // The list of statements to evaluate if the label matches.
-    tree_statement_list *list;
+    tree_statement_list *m_list;
 
     // Comment preceding CASE or OTHERWISE token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
   };
 
   class tree_switch_case_list : public base_list<tree_switch_case *>
   {
   public:
 
     tree_switch_case_list (void) { }
 
@@ -241,59 +241,59 @@ namespace octave
     }
   };
 
   class tree_switch_command : public tree_command
   {
   public:
 
     tree_switch_command (int l = -1, int c = -1)
-      : tree_command (l, c), expr (nullptr), list (nullptr),
-        lead_comm (nullptr), trail_comm (nullptr) { }
+      : tree_command (l, c), m_expr (nullptr), m_list (nullptr),
+        m_lead_comm (nullptr), m_trail_comm (nullptr) { }
 
     tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
                          comment_list *lc, comment_list *tc,
                          int l = -1, int c = -1)
-      : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-        trail_comm (tc) { }
+      : tree_command (l, c), m_expr (e), m_list (lst), m_lead_comm (lc),
+        m_trail_comm (tc) { }
 
     // No copying!
 
     tree_switch_command (const tree_switch_command&) = delete;
 
     tree_switch_command& operator = (const tree_switch_command&) = delete;
 
     ~tree_switch_command (void);
 
-    tree_expression * switch_value (void) { return expr; }
+    tree_expression * switch_value (void) { return m_expr; }
 
-    tree_switch_case_list * case_list (void) { return list; }
+    tree_switch_case_list * case_list (void) { return m_list; }
 
-    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return m_lead_comm; }
 
-    comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return m_trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_command (*this);
     }
 
   private:
 
     // Value on which to switch.
-    tree_expression *expr;
+    tree_expression *m_expr;
 
     // List of cases (case 1, case 2, ..., default)
-    tree_switch_case_list *list;
+    tree_switch_case_list *m_list;
 
     // Comment preceding SWITCH token.
-    comment_list *lead_comm;
+    comment_list *m_lead_comm;
 
     // Comment preceding ENDSWITCH token.
-    comment_list *trail_comm;
+    comment_list *m_trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_if_clause' instead")
 typedef octave::tree_if_clause tree_if_clause;
 
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -47,130 +47,138 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 namespace octave
 {
   // A list of commands to be executed.
 
   tree_statement::~tree_statement (void)
   {
-    delete cmd;
-    delete expr;
-    delete comm;
+    delete m_command;
+    delete m_expression;
+    delete m_comment_list;
   }
 
   void
   tree_statement::set_print_flag (bool print_flag)
   {
-    if (expr)
-      expr->set_print_flag (print_flag);
+    if (m_expression)
+      m_expression->set_print_flag (print_flag);
   }
 
   bool
   tree_statement::print_result (void)
   {
-    return expr && expr->print_result ();
+    return m_expression && m_expression->print_result ();
   }
 
   void
   tree_statement::set_breakpoint (const std::string& condition)
   {
-    if (cmd)
-      cmd->set_breakpoint (condition);
-    else if (expr)
-      expr->set_breakpoint (condition);
+    if (m_command)
+      m_command->set_breakpoint (condition);
+    else if (m_expression)
+      m_expression->set_breakpoint (condition);
   }
 
   void
   tree_statement::delete_breakpoint (void)
   {
-    if (cmd)
-      cmd->delete_breakpoint ();
-    else if (expr)
-      expr->delete_breakpoint ();
+    if (m_command)
+      m_command->delete_breakpoint ();
+    else if (m_expression)
+      m_expression->delete_breakpoint ();
   }
 
   bool
   tree_statement::is_breakpoint (bool check_active) const
   {
-    return cmd ? cmd->is_breakpoint (check_active)
-      : (expr ? expr->is_breakpoint (check_active) : false);
+    return m_command ? m_command->is_breakpoint (check_active)
+      : (m_expression ? m_expression->is_breakpoint (check_active) : false);
   }
 
   std::string
   tree_statement::bp_cond () const
   {
-    return cmd ? cmd->bp_cond () : (expr ? expr->bp_cond () : "0");
+    return (m_command
+            ? m_command->bp_cond ()
+            : (m_expression ? m_expression->bp_cond () : "0"));
   }
 
   int
   tree_statement::line (void) const
   {
-    return cmd ? cmd->line () : (expr ? expr->line () : -1);
+    return (m_command
+            ? m_command->line ()
+            : (m_expression ? m_expression->line () : -1));
   }
 
   int
   tree_statement::column (void) const
   {
-    return cmd ? cmd->column () : (expr ? expr->column () : -1);
+    return (m_command
+            ? m_command->column ()
+            : (m_expression ? m_expression->column () : -1));
   }
 
   void
   tree_statement::set_location (int l, int c)
   {
-    if (cmd)
-      cmd->set_location (l, c);
-    else if (expr)
-      expr->set_location (l, c);
+    if (m_command)
+      m_command->set_location (l, c);
+    else if (m_expression)
+      m_expression->set_location (l, c);
   }
 
   void
   tree_statement::echo_code (const std::string& prefix)
   {
     tree_print_code tpc (octave_stdout, prefix);
 
     accept (tpc);
   }
 
   bool
   tree_statement::is_end_of_fcn_or_script (void) const
   {
     bool retval = false;
 
-    if (cmd)
+    if (m_command)
       {
         tree_no_op_command *no_op_cmd
-          = dynamic_cast<tree_no_op_command *> (cmd);
+          = dynamic_cast<tree_no_op_command *> (m_command);
 
         if (no_op_cmd)
           retval = no_op_cmd->is_end_of_fcn_or_script ();
       }
 
     return retval;
   }
 
   bool
   tree_statement::is_end_of_file (void) const
   {
     bool retval = false;
 
-    if (cmd)
+    if (m_command)
       {
         tree_no_op_command *no_op_cmd
-          = dynamic_cast<tree_no_op_command *> (cmd);
+          = dynamic_cast<tree_no_op_command *> (m_command);
 
         if (no_op_cmd)
           retval = no_op_cmd->is_end_of_file ();
       }
 
     return retval;
   }
 
-  // Create a "breakpoint" tree-walker, and get it to "walk" this statement list
+  // Create a "breakpoint" tree-walker, and get it to "walk" this
+  // statement list
   // (FIXME: What does that do???)
+
   int
   tree_statement_list::set_breakpoint (int line, const std::string& condition)
   {
     tree_breakpoint tbp (line, tree_breakpoint::set, condition);
     accept (tbp);
 
     return tbp.get_line ();
   }
@@ -221,20 +229,21 @@ namespace octave
       {
         retval.push_back (bp_type (lines(i).double_value (),
                                    conds(i).string_value ()));
       }
 
     return retval;
   }
 
-  // Add breakpoints to  file  at multiple lines (the second arguments of  line),
-  // to stop only if  condition  is true.
+  // Add breakpoints to  file  at multiple lines (the second arguments
+  // of  line), to stop only if  condition  is true.
   // Updates GUI via  octave_link::update_breakpoint.
   // FIXME: COME BACK TO ME.
+
   bp_table::intmap
   tree_statement_list::add_breakpoint (const std::string& file,
                                        const bp_table::intmap& line,
                                        const std::string& condition)
   {
     bp_table::intmap retval;
 
     octave_idx_type len = line.size ();
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -43,106 +43,110 @@ namespace octave
   // A statement is either a command to execute or an expression to
   // evaluate.
 
   class tree_statement : public tree
   {
   public:
 
     tree_statement (void)
-      : cmd (nullptr), expr (nullptr), comm (nullptr) { }
+      : m_command (nullptr), m_expression (nullptr),
+        m_comment_list (nullptr) { }
 
     tree_statement (tree_command *c, comment_list *cl)
-      : cmd (c), expr (nullptr), comm (cl) { }
+      : m_command (c), m_expression (nullptr), m_comment_list (cl) { }
 
     tree_statement (tree_expression *e, comment_list *cl)
-      : cmd (nullptr), expr (e), comm (cl) { }
+      : m_command (nullptr), m_expression (e), m_comment_list (cl) { }
 
     // No copying!
 
     tree_statement (const tree_statement&) = delete;
 
     tree_statement& operator = (const tree_statement&) = delete;
 
     ~tree_statement (void);
 
     void set_print_flag (bool print_flag);
 
     bool print_result (void);
 
-    bool is_command (void) const { return cmd != nullptr; }
+    bool is_command (void) const { return m_command != nullptr; }
 
-    bool is_expression (void) const { return expr != nullptr; }
+    bool is_expression (void) const { return m_expression != nullptr; }
 
     void set_breakpoint (const std::string& condition);
 
     void delete_breakpoint (void);
 
     bool is_breakpoint (bool check_valid = false) const;
     std::string bp_cond () const;
 
     int line (void) const;
     int column (void) const;
 
     void set_location (int l, int c);
 
     void echo_code (const std::string& prefix);
 
-    tree_command * command (void) { return cmd; }
+    tree_command * command (void) { return m_command; }
 
-    tree_expression * expression (void) { return expr; }
+    tree_expression * expression (void) { return m_expression; }
 
-    comment_list * comment_text (void) { return comm; }
+    comment_list * comment_text (void) { return m_comment_list; }
 
-    bool is_null_statement (void) const { return ! (cmd || expr || comm); }
+    bool is_null_statement (void) const
+    {
+      return ! (m_command || m_expression || m_comment_list);
+    }
 
     bool is_end_of_fcn_or_script (void) const;
 
     bool is_end_of_file (void) const;
 
     // Allow modification of this statement.  Note that there is no
     // checking.  If you use these, are you sure you knwo what you are
     // doing?
 
-    void set_command (tree_command *c) { cmd = c; }
+    void set_command (tree_command *c) { m_command = c; }
 
-    void set_expression (tree_expression *e) { expr = e; }
+    void set_expression (tree_expression *e) { m_expression = e; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_statement (*this);
     }
 
   private:
 
     // Only one of cmd or expr can be valid at once.
 
     // Command to execute.
-    tree_command *cmd;
+    tree_command *m_command;
 
     // Expression to evaluate.
-    tree_expression *expr;
+    tree_expression *m_expression;
 
     // Comment associated with this statement.
-    comment_list *comm;
+    comment_list *m_comment_list;
   };
 
   // A list of statements to evaluate.
 
   class tree_statement_list : public base_list<tree_statement *>
   {
   public:
 
     tree_statement_list (void)
-      : function_body (false), anon_function_body (false),
-        script_body (false) { }
+      : m_function_body (false), m_anon_function_body (false),
+        m_script_body (false) { }
 
     tree_statement_list (tree_statement *s)
-      : function_body (false), anon_function_body (false),
-        script_body (false) { append (s); }
+      : m_function_body (false), m_anon_function_body (false),
+        m_script_body (false) { append (s); }
 
     // No copying!
 
     tree_statement_list (const tree_statement_list&) = delete;
 
     tree_statement_list& operator = (const tree_statement_list&) = delete;
 
     ~tree_statement_list (void)
@@ -150,27 +154,27 @@ namespace octave
       while (! empty ())
         {
           iterator p = begin ();
           delete *p;
           erase (p);
         }
     }
 
-    void mark_as_function_body (void) { function_body = true; }
+    void mark_as_function_body (void) { m_function_body = true; }
 
-    void mark_as_anon_function_body (void) { anon_function_body = true; }
+    void mark_as_anon_function_body (void) { m_anon_function_body = true; }
 
-    void mark_as_script_body (void) { script_body = true; }
+    void mark_as_script_body (void) { m_script_body = true; }
 
-    bool is_function_body (void) const { return function_body; }
+    bool is_function_body (void) const { return m_function_body; }
 
-    bool is_anon_function_body (void) const { return anon_function_body; }
+    bool is_anon_function_body (void) const { return m_anon_function_body; }
 
-    bool is_script_body (void) const { return script_body; }
+    bool is_script_body (void) const { return m_script_body; }
 
     int set_breakpoint (int line, const std::string& condition);
 
     void delete_breakpoint (int line);
 
     octave_value_list list_breakpoints (void);
 
     std::list<bp_type> breakpoints_and_conds (void);
@@ -184,23 +188,23 @@ namespace octave
     void accept (tree_walker& tw)
     {
       tw.visit_statement_list (*this);
     }
 
   private:
 
     // Does this list of statements make up the body of a function?
-    bool function_body;
+    bool m_function_body;
 
     // Does this list of statements make up the body of a function?
-    bool anon_function_body;
+    bool m_anon_function_body;
 
     // Does this list of statements make up the body of a script?
-    bool script_body;
+    bool m_script_body;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_statement' instead")
 typedef octave::tree_statement tree_statement;
 
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -61,92 +61,92 @@ namespace octave
 {
   void
   tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
                                                    bool& first_elem)
   {
     std::string this_elt_class_nm = val.isobject () ? "class"
                                                     : val.class_name ();
 
-    class_nm = get_concat_class (class_nm, this_elt_class_nm);
+    m_class_nm = get_concat_class (m_class_nm, this_elt_class_nm);
 
     dim_vector this_elt_dv = val.dims ();
 
     if (! this_elt_dv.zero_by_zero ())
       {
-        all_mt = false;
+        m_all_mt = false;
 
         if (first_elem)
           {
             if (val.isstruct ())
-              first_elem_is_struct = true;
+              m_first_elem_is_struct = true;
 
             first_elem = false;
           }
       }
     else if (val.iscell ())
       first_elem = false;
 
     append (val);
 
-    if (all_str && ! val.is_string ())
-      all_str = false;
+    if (m_all_str && ! val.is_string ())
+      m_all_str = false;
 
-    if (all_sq_str && ! val.is_sq_string ())
-      all_sq_str = false;
+    if (m_all_sq_str && ! val.is_sq_string ())
+      m_all_sq_str = false;
 
-    if (all_dq_str && ! val.is_dq_string ())
-      all_dq_str = false;
+    if (m_all_dq_str && ! val.is_dq_string ())
+      m_all_dq_str = false;
 
-    if (! some_str && val.is_string ())
-      some_str = true;
+    if (! m_some_str && val.is_string ())
+      m_some_str = true;
 
-    if (all_real && ! val.isreal ())
-      all_real = false;
+    if (m_all_real && ! val.isreal ())
+      m_all_real = false;
 
-    if (all_cmplx && ! (val.iscomplex () || val.isreal ()))
-      all_cmplx = false;
+    if (m_all_cmplx && ! (val.iscomplex () || val.isreal ()))
+      m_all_cmplx = false;
 
-    if (! any_cell && val.iscell ())
-      any_cell = true;
+    if (! m_any_cell && val.iscell ())
+      m_any_cell = true;
 
-    if (! any_sparse && val.issparse ())
-      any_sparse = true;
+    if (! m_any_sparse && val.issparse ())
+      m_any_sparse = true;
 
-    if (! any_class && val.isobject ())
-      any_class = true;
+    if (! m_any_class && val.isobject ())
+      m_any_class = true;
 
     // Special treatment of sparse matrices to avoid out-of-memory error
-    all_1x1 = all_1x1 && ! val.issparse () && val.numel () == 1;
+    m_all_1x1 = m_all_1x1 && ! val.issparse () && val.numel () == 1;
   }
 
   void
   tm_row_const::tm_row_const_rep::init (const tree_argument_list& row,
                                         tree_evaluator *tw)
   {
-    all_str = true;
-    all_sq_str = true;
-    all_dq_str = true;
-    all_real = true;
-    all_cmplx = true;
-    any_cell = false;
-    any_sparse = false;
-    any_class = false;
+    m_all_str = true;
+    m_all_sq_str = true;
+    m_all_dq_str = true;
+    m_all_real = true;
+    m_all_cmplx = true;
+    m_any_cell = false;
+    m_any_sparse = false;
+    m_any_class = false;
 
     bool first_elem = true;
 
     for (tree_expression* elt : row)
       {
         octave_quit ();
 
         octave_value tmp = tw->evaluate (elt);
 
         if (tmp.is_undefined ())
           {
-            ok = true;
+            m_ok = true;
             return;
           }
         else
           {
             if (tmp.is_cs_list ())
               {
                 octave_value_list tlst = tmp.list_value ();
 
@@ -157,42 +157,42 @@ namespace octave
                     do_init_element (tlst(i), first_elem);
                   }
               }
             else
               do_init_element (tmp, first_elem);
           }
       }
 
-    if (any_cell && ! any_class && ! first_elem_is_struct)
+    if (m_any_cell && ! m_any_class && ! m_first_elem_is_struct)
       cellify ();
 
     first_elem = true;
 
     for (const octave_value& val : *this)
       {
         octave_quit ();
 
         dim_vector this_elt_dv = val.dims ();
 
         if (! this_elt_dv.zero_by_zero ())
           {
-            all_mt = false;
+            m_all_mt = false;
 
             if (first_elem)
               {
                 first_elem = false;
-                dv = this_elt_dv;
+                m_dv = this_elt_dv;
               }
-            else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
-              eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+            else if ((! m_any_class) && (! m_dv.hvcat (this_elt_dv, 1)))
+              eval_error ("horizontal dimensions mismatch", m_dv, this_elt_dv);
           }
       }
 
-    ok = true;
+    m_ok = true;
   }
 
   void
   tm_row_const::tm_row_const_rep::cellify (void)
   {
     bool elt_changed = false;
 
     for (auto& elt : *this)
@@ -220,37 +220,37 @@ namespace octave
 
             dim_vector this_elt_dv = val.dims ();
 
             if (! this_elt_dv.zero_by_zero ())
               {
                 if (first_elem)
                   {
                     first_elem = false;
-                    dv = this_elt_dv;
+                    m_dv = this_elt_dv;
                   }
-                else if (! dv.hvcat (this_elt_dv, 1))
-                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+                else if (! m_dv.hvcat (this_elt_dv, 1))
+                  eval_error ("horizontal dimensions mismatch", m_dv, this_elt_dv);
               }
           }
       }
   }
 
   void
   tm_const::init (const tree_matrix& tm, tree_evaluator *tw)
   {
-    all_str = true;
-    all_sq_str = true;
-    all_dq_str = true;
-    all_real = true;
-    all_cmplx = true;
-    any_cell = false;
-    any_sparse = false;
-    any_class = false;
-    all_1x1 = ! tm.empty ();
+    m_all_str = true;
+    m_all_sq_str = true;
+    m_all_dq_str = true;
+    m_all_real = true;
+    m_all_cmplx = true;
+    m_any_cell = false;
+    m_any_sparse = false;
+    m_any_class = false;
+    m_all_1x1 = ! tm.empty ();
 
     bool first_elem = true;
     bool first_elem_is_struct = false;
 
     // Just eval and figure out if what we have is complex or all strings.
     // We can't check columns until we know that this is a numeric matrix --
     // collections of strings can have elements of different lengths.
     for (const tree_argument_list* elt : tm)
@@ -263,55 +263,55 @@ namespace octave
           {
             first_elem_is_struct = tmp.first_elem_struct_p ();
 
             first_elem = false;
           }
 
         if (tmp && ! tmp.empty ())
           {
-            if (all_str && ! tmp.all_strings_p ())
-              all_str = false;
+            if (m_all_str && ! tmp.all_strings_p ())
+              m_all_str = false;
 
-            if (all_sq_str && ! tmp.all_sq_strings_p ())
-              all_sq_str = false;
+            if (m_all_sq_str && ! tmp.all_sq_strings_p ())
+              m_all_sq_str = false;
 
-            if (all_dq_str && ! tmp.all_dq_strings_p ())
-              all_dq_str = false;
+            if (m_all_dq_str && ! tmp.all_dq_strings_p ())
+              m_all_dq_str = false;
 
-            if (! some_str && tmp.some_strings_p ())
-              some_str = true;
+            if (! m_some_str && tmp.some_strings_p ())
+              m_some_str = true;
 
-            if (all_real && ! tmp.all_real_p ())
-              all_real = false;
+            if (m_all_real && ! tmp.all_real_p ())
+              m_all_real = false;
 
-            if (all_cmplx && ! tmp.all_complex_p ())
-              all_cmplx = false;
+            if (m_all_cmplx && ! tmp.all_complex_p ())
+              m_all_cmplx = false;
 
-            if (all_mt && ! tmp.all_empty_p ())
-              all_mt = false;
+            if (m_all_mt && ! tmp.all_empty_p ())
+              m_all_mt = false;
 
-            if (! any_cell && tmp.any_cell_p ())
-              any_cell = true;
+            if (! m_any_cell && tmp.any_cell_p ())
+              m_any_cell = true;
 
-            if (! any_sparse && tmp.any_sparse_p ())
-              any_sparse = true;
+            if (! m_any_sparse && tmp.any_sparse_p ())
+              m_any_sparse = true;
 
-            if (! any_class && tmp.any_class_p ())
-              any_class = true;
+            if (! m_any_class && tmp.any_class_p ())
+              m_any_class = true;
 
-            all_1x1 = all_1x1 && tmp.all_1x1_p ();
+            m_all_1x1 = m_all_1x1 && tmp.all_1x1_p ();
 
             append (tmp);
           }
         else
           break;
       }
 
-    if (any_cell && ! any_class && ! first_elem_is_struct)
+    if (m_any_cell && ! m_any_class && ! first_elem_is_struct)
       {
         for (auto& elt : *this)
           {
             octave_quit ();
 
             elt.cellify ();
           }
       }
@@ -321,51 +321,51 @@ namespace octave
     for (tm_row_const& elt : *this)
       {
         octave_quit ();
 
         octave_idx_type this_elt_nr = elt.rows ();
         octave_idx_type this_elt_nc = elt.cols ();
 
         std::string this_elt_class_nm = elt.class_name ();
-        class_nm = get_concat_class (class_nm, this_elt_class_nm);
+        m_class_nm = get_concat_class (m_class_nm, this_elt_class_nm);
 
         dim_vector this_elt_dv = elt.dims ();
 
-        all_mt = false;
+        m_all_mt = false;
 
         if (first_elem)
           {
             first_elem = false;
 
-            dv = this_elt_dv;
+            m_dv = this_elt_dv;
           }
-        else if (all_str && dv.ndims () == 2
+        else if (m_all_str && m_dv.ndims () == 2
                  && this_elt_dv.ndims () == 2)
           {
             // This is Octave's specialty.
             // Character matrices support rows of unequal length.
-            if (dv.any_zero ())
+            if (m_dv.any_zero ())
               {
                 // Empty existing element (bug #52542).
                 // Replace empty element with non-empty one.
-                dv = this_elt_dv;
+                m_dv = this_elt_dv;
               }
             else
               {
                 if (this_elt_nc > cols ())
-                  dv(1) = this_elt_nc;
-                dv(0) += this_elt_nr;
+                  m_dv(1) = this_elt_nc;
+                m_dv(0) += this_elt_nr;
               }
           }
-        else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
-          eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
+        else if ((! m_any_class) && (! m_dv.hvcat (this_elt_dv, 0)))
+          eval_error ("vertical dimensions mismatch", m_dv, this_elt_dv);
       }
 
-    ok = true;
+    m_ok = true;
   }
 
   template <>
   octave_value
   do_single_type_concat<octave_map> (const dim_vector& dv,
                                      tm_const& tmp)
   {
     octave_map result;
diff --git a/libinterp/parse-tree/pt-tm-const.h b/libinterp/parse-tree/pt-tm-const.h
--- a/libinterp/parse-tree/pt-tm-const.h
+++ b/libinterp/parse-tree/pt-tm-const.h
@@ -55,54 +55,54 @@ namespace octave
   private:
 
     class
     tm_row_const_rep : public base_list<octave_value>
     {
     public:
 
       tm_row_const_rep (void)
-        : count (1), dv (0, 0), all_str (false),
-          all_sq_str (false), all_dq_str (false),
-          some_str (false), all_real (false), all_cmplx (false),
-          all_mt (true), any_cell (false), any_sparse (false),
-          any_class (false), all_1x1 (false),
-          first_elem_is_struct (false), class_nm (), ok (false)
+        : m_count (1), m_dv (0, 0), m_all_str (false),
+          m_all_sq_str (false), m_all_dq_str (false),
+          m_some_str (false), m_all_real (false), m_all_cmplx (false),
+          m_all_mt (true), m_any_cell (false), m_any_sparse (false),
+          m_any_class (false), m_all_1x1 (false),
+          m_first_elem_is_struct (false), m_class_nm (), m_ok (false)
       { }
 
       tm_row_const_rep (const tree_argument_list& row, tree_evaluator *tw)
-        : count (1), dv (0, 0), all_str (false), all_sq_str (false),
-          some_str (false), all_real (false), all_cmplx (false),
-          all_mt (true), any_cell (false), any_sparse (false),
-          any_class (false), all_1x1 (! row.empty ()),
-          first_elem_is_struct (false), class_nm (), ok (false)
+        : m_count (1), m_dv (0, 0), m_all_str (false), m_all_sq_str (false),
+          m_some_str (false), m_all_real (false), m_all_cmplx (false),
+          m_all_mt (true), m_any_cell (false), m_any_sparse (false),
+          m_any_class (false), m_all_1x1 (! row.empty ()),
+          m_first_elem_is_struct (false), m_class_nm (), m_ok (false)
       { init (row, tw); }
 
       ~tm_row_const_rep (void) = default;
 
-      refcount<int> count;
+      refcount<int> m_count;
 
-      dim_vector dv;
+      dim_vector m_dv;
 
-      bool all_str;
-      bool all_sq_str;
-      bool all_dq_str;
-      bool some_str;
-      bool all_real;
-      bool all_cmplx;
-      bool all_mt;
-      bool any_cell;
-      bool any_sparse;
-      bool any_class;
-      bool all_1x1;
-      bool first_elem_is_struct;
+      bool m_all_str;
+      bool m_all_sq_str;
+      bool m_all_dq_str;
+      bool m_some_str;
+      bool m_all_real;
+      bool m_all_cmplx;
+      bool m_all_mt;
+      bool m_any_cell;
+      bool m_any_sparse;
+      bool m_any_class;
+      bool m_all_1x1;
+      bool m_first_elem_is_struct;
 
-      std::string class_nm;
+      std::string m_class_nm;
 
-      bool ok;
+      bool m_ok;
 
       void do_init_element (const octave_value&, bool&);
 
       void init (const tree_argument_list&, tree_evaluator *tw);
 
       void cellify (void);
 
     private:
@@ -114,144 +114,144 @@ namespace octave
     };
 
   public:
 
     typedef tm_row_const_rep::iterator iterator;
     typedef tm_row_const_rep::const_iterator const_iterator;
 
     tm_row_const (void)
-      : rep (nullptr) { }
+      : m_rep (nullptr) { }
 
     tm_row_const (const tree_argument_list& row, tree_evaluator *tw)
-      : rep (new tm_row_const_rep (row, tw)) { }
+      : m_rep (new tm_row_const_rep (row, tw)) { }
 
     tm_row_const (const tm_row_const& x)
-      : rep (x.rep)
+      : m_rep (x.m_rep)
     {
-      if (rep)
-        rep->count++;
+      if (m_rep)
+        m_rep->m_count++;
     }
 
     tm_row_const& operator = (const tm_row_const& x)
     {
-      if (this != &x && rep != x.rep)
+      if (this != &x && m_rep != x.m_rep)
         {
-          if (rep && --rep->count == 0)
-            delete rep;
+          if (m_rep && --m_rep->m_count == 0)
+            delete m_rep;
 
-          rep = x.rep;
+          m_rep = x.m_rep;
 
-          if (rep)
-            rep->count++;
+          if (m_rep)
+            m_rep->m_count++;
         }
 
       return *this;
     }
 
     ~tm_row_const (void)
     {
-      if (rep && --rep->count == 0)
-        delete rep;
+      if (m_rep && --m_rep->m_count == 0)
+        delete m_rep;
     }
 
-    octave_idx_type rows (void) { return rep->dv(0); }
-    octave_idx_type cols (void) { return rep->dv(1); }
+    octave_idx_type rows (void) { return m_rep->m_dv(0); }
+    octave_idx_type cols (void) { return m_rep->m_dv(1); }
 
-    bool empty (void) const { return rep->empty (); }
+    bool empty (void) const { return m_rep->empty (); }
 
-    size_t length (void) const { return rep->length (); }
+    size_t length (void) const { return m_rep->length (); }
 
-    dim_vector dims (void) { return rep->dv; }
+    dim_vector dims (void) { return m_rep->m_dv; }
 
-    bool all_strings_p (void) const { return rep->all_str; }
-    bool all_sq_strings_p (void) const { return rep->all_sq_str; }
-    bool all_dq_strings_p (void) const { return rep->all_dq_str; }
-    bool some_strings_p (void) const { return rep->some_str; }
-    bool all_real_p (void) const { return rep->all_real; }
-    bool all_complex_p (void) const { return rep->all_cmplx; }
-    bool all_empty_p (void) const { return rep->all_mt; }
-    bool any_cell_p (void) const { return rep->any_cell; }
-    bool any_sparse_p (void) const { return rep->any_sparse; }
-    bool any_class_p (void) const { return rep->any_class; }
-    bool all_1x1_p (void) const { return rep->all_1x1; }
-    bool first_elem_struct_p (void) const { return rep->first_elem_is_struct; }
+    bool all_strings_p (void) const { return m_rep->m_all_str; }
+    bool all_sq_strings_p (void) const { return m_rep->m_all_sq_str; }
+    bool all_dq_strings_p (void) const { return m_rep->m_all_dq_str; }
+    bool some_strings_p (void) const { return m_rep->m_some_str; }
+    bool all_real_p (void) const { return m_rep->m_all_real; }
+    bool all_complex_p (void) const { return m_rep->m_all_cmplx; }
+    bool all_empty_p (void) const { return m_rep->m_all_mt; }
+    bool any_cell_p (void) const { return m_rep->m_any_cell; }
+    bool any_sparse_p (void) const { return m_rep->m_any_sparse; }
+    bool any_class_p (void) const { return m_rep->m_any_class; }
+    bool all_1x1_p (void) const { return m_rep->m_all_1x1; }
+    bool first_elem_struct_p (void) const { return m_rep->m_first_elem_is_struct; }
 
-    std::string class_name (void) const { return rep->class_nm; }
+    std::string class_name (void) const { return m_rep->m_class_nm; }
 
-    void cellify (void) { rep->cellify (); }
+    void cellify (void) { m_rep->cellify (); }
 
-    operator bool () const { return (rep && rep->ok); }
+    operator bool () const { return (m_rep && m_rep->m_ok); }
 
-    iterator begin (void) { return rep->begin (); }
-    const_iterator begin (void) const { return rep->begin (); }
+    iterator begin (void) { return m_rep->begin (); }
+    const_iterator begin (void) const { return m_rep->begin (); }
 
-    iterator end (void) { return rep->end (); }
-    const_iterator end (void) const { return rep->end (); }
+    iterator end (void) { return m_rep->end (); }
+    const_iterator end (void) const { return m_rep->end (); }
 
   private:
 
-    tm_row_const_rep *rep;
+    tm_row_const_rep *m_rep;
   };
 
   class
   tm_const : public base_list<tm_row_const>
   {
   public:
 
     tm_const (const tree_matrix& tm, tree_evaluator *tw = nullptr)
-      : dv (0, 0), all_str (false), all_sq_str (false),
-        all_dq_str (false),
-        some_str (false), all_real (false), all_cmplx (false),
-        all_mt (true), any_cell (false), any_sparse (false),
-        any_class (false), class_nm (), ok (false)
+      : m_dv (0, 0), m_all_str (false), m_all_sq_str (false),
+        m_all_dq_str (false),
+        m_some_str (false), m_all_real (false), m_all_cmplx (false),
+        m_all_mt (true), m_any_cell (false), m_any_sparse (false),
+        m_any_class (false), m_class_nm (), m_ok (false)
     { init (tm, tw); }
 
     ~tm_const (void) = default;
 
-    octave_idx_type rows (void) const { return dv.elem (0); }
-    octave_idx_type cols (void) const { return dv.elem (1); }
+    octave_idx_type rows (void) const { return m_dv.elem (0); }
+    octave_idx_type cols (void) const { return m_dv.elem (1); }
 
-    dim_vector dims (void) const { return dv; }
+    dim_vector dims (void) const { return m_dv; }
 
-    bool all_strings_p (void) const { return all_str; }
-    bool all_sq_strings_p (void) const { return all_sq_str; }
-    bool all_dq_strings_p (void) const { return all_dq_str; }
-    bool some_strings_p (void) const { return some_str; }
-    bool all_real_p (void) const { return all_real; }
-    bool all_complex_p (void) const { return all_cmplx; }
-    bool all_empty_p (void) const { return all_mt; }
-    bool any_cell_p (void) const { return any_cell; }
-    bool any_sparse_p (void) const { return any_sparse; }
-    bool any_class_p (void) const { return any_class; }
-    bool all_1x1_p (void) const { return all_1x1; }
+    bool all_strings_p (void) const { return m_all_str; }
+    bool all_sq_strings_p (void) const { return m_all_sq_str; }
+    bool all_dq_strings_p (void) const { return m_all_dq_str; }
+    bool some_strings_p (void) const { return m_some_str; }
+    bool all_real_p (void) const { return m_all_real; }
+    bool all_complex_p (void) const { return m_all_cmplx; }
+    bool all_empty_p (void) const { return m_all_mt; }
+    bool any_cell_p (void) const { return m_any_cell; }
+    bool any_sparse_p (void) const { return m_any_sparse; }
+    bool any_class_p (void) const { return m_any_class; }
+    bool all_1x1_p (void) const { return m_all_1x1; }
 
-    std::string class_name (void) const { return class_nm; }
+    std::string class_name (void) const { return m_class_nm; }
 
-    operator bool () const { return ok; }
+    operator bool () const { return m_ok; }
 
   private:
 
-    dim_vector dv;
+    dim_vector m_dv;
 
-    bool all_str;
-    bool all_sq_str;
-    bool all_dq_str;
-    bool some_str;
-    bool all_real;
-    bool all_cmplx;
-    bool all_mt;
-    bool any_cell;
-    bool any_sparse;
-    bool any_class;
-    bool all_1x1;
+    bool m_all_str;
+    bool m_all_sq_str;
+    bool m_all_dq_str;
+    bool m_some_str;
+    bool m_all_real;
+    bool m_all_cmplx;
+    bool m_all_mt;
+    bool m_any_cell;
+    bool m_any_sparse;
+    bool m_any_class;
+    bool m_all_1x1;
 
-    std::string class_nm;
+    std::string m_class_nm;
 
-    bool ok;
+    bool m_ok;
 
     tm_const (void);
 
     tm_const (const tm_const&);
 
     tm_const& operator = (const tm_const&);
 
     void init (const tree_matrix& tm, tree_evaluator *tw);
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -54,19 +54,19 @@ namespace octave
 
   // function from libinterp/parse-tree/oct-parse.cc, not listed in oct-parse.h
   octave_value_list eval_string (const std::string&, bool, int&, int);
   // Is the current breakpoint condition met?
   bool
   tree::meets_bp_condition () const
   {
     bool retval;
-    if (bp == nullptr)
+    if (m_bp_cond == nullptr)
       retval = false;
-    else if (bp->empty ())     // empty condition always met
+    else if (m_bp_cond->empty ())     // empty condition always met
       retval = true;
     else
       {
         int parse_status = 0;
 
         unwind_protect frame;
         frame.protect_var (buffer_error_messages);
         frame.protect_var (Vdebug_on_error);
@@ -74,17 +74,19 @@ namespace octave
 
         buffer_error_messages++;
         Vdebug_on_error = false;
         Vdebug_on_warning = false;
 
         retval = true;                // default to stopping if any error
         try
           {
-            octave_value_list val = eval_string (*bp, 1, parse_status, 1);
+            octave_value_list val
+              = eval_string (*m_bp_cond, 1, parse_status, 1);
+
             if (parse_status == 0)
               {
                 if (! val(0).is_scalar_type ())
                   warning ("Breakpoint condition must be a scalar, not size %s",
                            val(0).dims ().str ('x').c_str ());
                 else
                   retval = val(0).bool_value ();
               }
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -37,73 +37,86 @@ namespace octave
 
   // Base class for the parse tree.
 
   class tree
   {
   public:
 
     tree (int l = -1, int c = -1)
-      : line_num (l), column_num (c), bp (nullptr) { }
+      : m_line_num (l), m_column_num (c), m_bp_cond (nullptr)
+    { }
 
     // No copying!
 
     tree (const tree&) = delete;
 
     tree& operator = (const tree&) = delete;
 
     virtual ~tree (void) = default;
 
-    virtual int line (void) const { return line_num; }
+    virtual int line (void) const { return m_line_num; }
 
-    virtual int column (void) const { return column_num; }
+    virtual int column (void) const { return m_column_num; }
 
-    void line (int l) { line_num = l; }
+    void line (int l) { m_line_num = l; }
 
-    void column (int c) { column_num = c; }
+    void column (int c) { m_column_num = c; }
 
     void set_location (int l, int c)
     {
-      line_num = l;
-      column_num = c;
+      m_line_num = l;
+      m_column_num = c;
     }
 
     virtual void set_breakpoint (const std::string& condition)
     {
-      if (bp)
-        *bp = condition;
+      if (m_bp_cond)
+        *m_bp_cond = condition;
       else
-        bp = new std::string(condition);
+        m_bp_cond = new std::string (condition);
     }
 
-    virtual void delete_breakpoint (void) { if (bp) delete bp; bp = nullptr; }
+    virtual void delete_breakpoint (void)
+    {
+      if (m_bp_cond)
+        {
+          delete m_bp_cond;
+
+          m_bp_cond = nullptr;
+        }
+    }
 
     bool meets_bp_condition (void) const;
 
     bool is_breakpoint (bool check_active = false) const
-    { return bp && (! check_active || meets_bp_condition ()); }
+    {
+      return m_bp_cond && (! check_active || meets_bp_condition ());
+    }
 
     // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
     // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
     const std::string bp_cond (void) const
-    { return bp ? *bp : "0"; }
+    {
+      return m_bp_cond ? *m_bp_cond : "0";
+    }
 
     std::string str_print_code (void);
 
     virtual void accept (tree_walker& tw) = 0;
 
   private:
 
     // The input line and column where we found the text that was
     // eventually converted to this tree node.
-    int line_num;
-    int column_num;
+    int m_line_num;
+    int m_column_num;
 
-    // Breakpoint flag: NULL if no breakpoint, or the condition if there is one
-    std::string *bp;
+    // NULL if no breakpoint, or a breakpoint condition if there is one.
+    std::string *m_bp_cond;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree' instead")
 typedef octave::tree tree;
 
