# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1454766527 18000
#      Sat Feb 06 08:48:47 2016 -0500
# Node ID 2cf8bc5c70177cd35a8502c825ec7312ae342f1f
# Parent  4f7d3989c462cea36af4a5710f02f367605e561b
use "#if defined (HAVE_FOO)" instead of "#if HAVE_FOO" for feature tests

* configure.ac (HAVE_HDF5_INT2FLOAT_CONVERSIONS): AC_DEFINE here.
* ls-hdf5.cc (HAVE_HDF5_INT2FLOAT_CONVERSION): Delete definition.

* ls-hdf5.cc, ls-hdf5.h, ccolamd.cc, dmperm.cc, ov-base-int.cc,
ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc, ov-cell.cc,
ov-class.cc, ov-complex.cc, ov-cx-mat.cc, ov-cx-sparse.cc,
ov-fcn-handle.cc, ov-fcn-inline.cc, ov-float.cc, ov-flt-complex.cc,
ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-java.cc, ov-range.cc,
ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-str-mat.cc,
ov-struct.cc, pt-eval.cc:
Use #if defined (HAVE_FOO) instead of #if HAVE_FOO.

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -895,16 +895,24 @@ OCTAVE_CHECK_LIB(hdf5, HDF5,
      [Define to 1 if HDF5 is available and newer than version 1.6.])
    if test $have_msvc = yes; then
      OCTAVE_CHECK_LIB_HDF5_DLL
    fi
   ])
 CPPFLAGS="$save_CPPFLAGS"
 LIBS="$save_LIBS"
 
+dnl Should we check for this now, or wait until some version of
+dnl HDF5 actually supports this feature?
+have_hdf5_int2float_conversions=no
+if test "$have_hdf5_int2float_conversions" = yes; then
+  AC_DEFINE(HAVE_HDF5_INT2FLOAT_CONVERSIONS, 1,
+    [Define to 1 if/when HDF5 supports automatic conversion between integer and floating-point binary data.])
+fi
+
 ### Check for FFTW library.  Default to Fortran FFTPACK if it is not available.
 
 ## Check for FFTW header and library.
 OCTAVE_CHECK_LIB(fftw3, FFTW3,
   [FFTW3 library not found.  The slower FFTPACK library will be used instead.],
   [fftw3.h], [fftw_plan_dft_1d])
 
 OCTAVE_CHECK_LIB(fftw3f, FFTW3F,
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -140,20 +140,16 @@ make_valid_identifier (const std::string
           char c = nm[i];
           retval += (isalnum (c) || c == '_') ? c : '_';
         }
     }
 
   return retval;
 }
 
-// Define this to 1 if/when HDF5 supports automatic conversion between
-// integer and floating-point binary data:
-#define HAVE_HDF5_INT2FLOAT_CONVERSIONS 0
-
 // Given two compound types t1 and t2, determine whether they
 // are compatible for reading/writing.  This function only
 // works for non-nested types composed of simple elements (ints, floats...),
 // which is all we need it for
 
 bool
 hdf5_types_compatible (octave_hdf5_id t1, octave_hdf5_id t2)
 {
@@ -189,17 +185,17 @@ hdf5_check_attr (octave_hdf5_id loc_id, 
   // call H5Aopen for a non-existing attribute
 
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
   H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
 #else
   H5Eget_auto (&err_func, &err_func_data);
   H5Eset_auto (0, 0);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
@@ -207,17 +203,17 @@ hdf5_check_attr (octave_hdf5_id loc_id, 
   if (attr_id >= 0)
     {
       // successful
       retval = true;
       H5Aclose (attr_id);
     }
 
   // restore error reporting:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   H5Eset_auto (octave_H5E_DEFAULT, err_func, err_func_data);
 #else
   H5Eset_auto (err_func, err_func_data);
 #endif
   return retval;
 }
 
 bool
@@ -231,17 +227,17 @@ hdf5_get_scalar_attr (octave_hdf5_id loc
   // call H5Aopen for a non-existing attribute
 
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
   H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
 #else
   H5Eget_auto (&err_func, &err_func_data);
   H5Eset_auto (0, 0);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
@@ -253,17 +249,17 @@ hdf5_get_scalar_attr (octave_hdf5_id loc
       hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
       if (rank == 0)
         retval = H5Aread (attr_id, type_id, buf) >= 0;
       H5Aclose (attr_id);
     }
 
   // restore error reporting:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   H5Eset_auto (octave_H5E_DEFAULT, err_func, err_func_data);
 #else
   H5Eset_auto (err_func, err_func_data);
 #endif
   return retval;
 }
 
 
@@ -323,31 +319,31 @@ hdf5_read_next_data (octave_hdf5_id grou
       // check again (in case vname was null, empty, or some such thing):
       ident_valid = valid_identifier (vname);
     }
 
   H5Gget_objinfo (group_id, name, 1, &info);
 
   if (info.type == H5G_GROUP && ident_valid)
     {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       subgroup_id = H5Gopen (group_id, name, octave_H5P_DEFAULT);
 #else
       subgroup_id = H5Gopen (group_id, name);
 #endif
 
       if (subgroup_id < 0)
         {
           retval = subgroup_id;
           goto done;
         }
 
       if (hdf5_check_attr (subgroup_id, "OCTAVE_NEW_FORMAT"))
         {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
           data_id = H5Dopen (subgroup_id, "type", octave_H5P_DEFAULT);
 #else
           data_id = H5Dopen (subgroup_id, "type");
 #endif
 
           if (data_id < 0)
             {
               retval = data_id;
@@ -411,17 +407,17 @@ hdf5_read_next_data (octave_hdf5_id grou
 
           retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
         }
 
     }
   else if (info.type == H5G_DATASET && ident_valid)
     {
       // For backwards compatibility.
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       data_id = H5Dopen (group_id, name, octave_H5P_DEFAULT);
 #else
       data_id = H5Dopen (group_id, name);
 #endif
 
       if (data_id < 0)
         {
           retval = data_id;
@@ -646,17 +642,17 @@ read_hdf5_data (std::istream& is, const 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
   herr_t H5Giterate_retval = -1;
 
   hsize_t num_obj = 0;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_id = H5Gopen (hs.file_id, "/", octave_H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (hs.file_id, "/");
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // For large datasets and out-of-core functionality,
@@ -718,17 +714,17 @@ octave_hdf5_err
 hdf5_add_attr (octave_hdf5_id loc_id, const char *attr_name)
 {
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       hid_t a_id = H5Acreate (loc_id, attr_name, H5T_NATIVE_UCHAR,
                               as_id, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (loc_id, attr_name,
                               H5T_NATIVE_UCHAR, as_id, octave_H5P_DEFAULT);
 #endif
       if (a_id >= 0)
         {
@@ -754,17 +750,17 @@ hdf5_add_scalar_attr (octave_hdf5_id loc
                       const char *attr_name, void *buf)
 {
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       hid_t a_id = H5Acreate (loc_id, attr_name, type_id,
                               as_id, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (loc_id, attr_name,
                               type_id, as_id, octave_H5P_DEFAULT);
 #endif
       if (a_id >= 0)
         {
@@ -803,17 +799,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
         empty = true;
     }
 
   if (! empty)
     return 0;
 
   space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -839,17 +835,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
 //    < 0  Error condition
 int
 load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector &d)
 {
   if (! hdf5_check_attr (loc_id, "OCTAVE_EMPTY_MATRIX"))
     return 0;
 
   hsize_t hdims, maxdims;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
   H5Sget_simple_extent_dims (space_id, &hdims, &maxdims);
   int retval;
 
@@ -868,17 +864,17 @@ load_hdf5_empty (octave_hdf5_id loc_id, 
   H5Dclose (data_hid);
 
   return (retval == 0 ? hdims : retval);
 }
 
 // save_type_to_hdf5 is not currently used, since hdf5 doesn't yet support
 // automatic float<->integer conversions:
 
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
 
 // return the HDF5 type id corresponding to the Octave save_type
 
 octave_hdf5_id
 save_type_to_hdf5 (save_type st)
 {
   switch (st)
     {
@@ -929,17 +925,17 @@ add_hdf5_data (octave_hdf5_id loc_id, co
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
   std::string t = val.type_name ();
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_id = H5Gcreate (loc_id, name.c_str (), octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                        octave_H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
 #endif
   if (data_id < 0)
     goto error_cleanup;
 
@@ -947,17 +943,17 @@ add_hdf5_data (octave_hdf5_id loc_id, co
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
   if (type_id < 0)
     goto error_cleanup;
 
   dims[0] = 0;
   space_id = H5Screate_simple (0 , dims, 0);
   if (space_id < 0)
     goto error_cleanup;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
                             octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, octave_H5P_DEFAULT);
 #endif
   if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, octave_H5S_ALL, octave_H5S_ALL,
                                     octave_H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -105,17 +105,17 @@ hdf5_callback_data
 
   // the value of the variable, in Octave form
   octave_value tc;
 
   // a documentation string (NULL if none)
   std::string doc;
 };
 
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
 extern OCTINTERP_API octave_hdf5_id
 save_type_to_hdf5 (save_type st)
 #endif
 
 extern OCTINTERP_API octave_hdf5_id
 hdf5_make_complex_type (octave_hdf5_id num_type);
 
 extern OCTINTERP_API bool
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -394,17 +394,17 @@ The authors of the code itself are @nosp
 @nospell{J. Bilbert and E. Ng}.  Supported by the National Science Foundation\n\
 @nospell{(DMS-9504974, DMS-9803599, CCR-0203270)}, and a grant from\n\
 @nospell{Sandia} National Lab.\n\
 See @url{http://www.cise.ufl.edu/research/sparse} for\n\
 ccolamd, csymamd, amd, colamd, symamd, and other related orderings.\n\
 @seealso{symamd, ccolamd}\n\
 @end deftypefn")
 {
-#if HAVE_CCOLAMD
+#if defined (HAVE_CCOLAMD)
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
   int spumoni = 0;
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -46,17 +46,17 @@ static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
     ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
-#if HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 static octave_value_list
 dmperm_internal (bool rank, const octave_value arg, int nargout)
 {
   octave_value_list retval;
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
@@ -131,17 +131,17 @@ triangular form.  The values of @var{r} 
 of the blocks.  If @var{S} is square then @code{@var{r} == @var{S}}.\n\
 \n\
 The method used is described in: @nospell{A. Pothen & C.-J. Fan.}\n\
 @cite{Computing the Block Triangular Form of a Sparse Matrix}.\n\
 ACM Trans. Math. Software, 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
-#if HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (false, args(0), nargout));
 
 #else
   err_disabled_feature ("dmperm", "CXSparse");
@@ -174,17 +174,17 @@ Calculate the structural rank of the spa
 Note that only the structure of the matrix is used in this calculation based\n\
 on a @nospell{Dulmage-Mendelsohn} permutation to block triangular form.  As\n\
 such the numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
-#if HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (true, args(0), nargout));
 
 #else
   err_disabled_feature ("sprank", "CXSparse");
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -344,17 +344,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -386,17 +386,17 @@ octave_base_int_matrix<T>::load_hdf5 (oc
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     this->matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
@@ -551,17 +551,17 @@ octave_base_int_scalar<T>::save_hdf5 (oc
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -584,17 +584,17 @@ octave_base_int_scalar<T>::save_hdf5 (oc
 
 template <typename T>
 bool
 octave_base_int_scalar<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -390,17 +390,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -437,17 +437,17 @@ octave_bool_matrix::load_hdf5 (octave_hd
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -340,17 +340,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                                octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
@@ -361,17 +361,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -386,17 +386,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -411,17 +411,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -449,17 +449,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -487,17 +487,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -512,17 +512,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -561,24 +561,24 @@ octave_sparse_bool_matrix::load_hdf5 (oc
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nr", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -593,17 +593,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nc", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -618,17 +618,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nz", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -647,17 +647,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
     }
 
   H5Dclose (data_hid);
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
                       static_cast<octave_idx_type> (nc),
                       static_cast<octave_idx_type> (nz));
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "cidx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -690,17 +690,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "ridx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "ridx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -730,17 +730,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "data", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "data");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -164,17 +164,17 @@ octave_bool::save_hdf5 (octave_hdf5_id l
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -196,17 +196,17 @@ octave_bool::save_hdf5 (octave_hdf5_id l
   return retval;
 }
 
 bool
 octave_bool::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -971,17 +971,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   hsize_t rank = dv.length ();
   hid_t space_hid, data_hid, size_hid;
   space_hid = data_hid = size_hid = -1;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
 
   if (data_hid < 0)
     return false;
 
@@ -997,17 +997,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
     }
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (hsize_t i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (size_hid < 0)
     {
@@ -1071,26 +1071,26 @@ octave_cell::load_hdf5 (octave_hdf5_id l
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_id = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
 
   if (group_id < 0)
     return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (group_id, "dims", octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (group_id, "dims");
 #endif
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
   if (rank != 1)
     {
@@ -1128,17 +1128,17 @@ octave_cell::load_hdf5 (octave_hdf5_id l
 
   herr_t retval2 = -1;
 
   Cell m (dv);
 
   int current_item = 0;
 
   hsize_t num_obj = 0;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_id = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   for (octave_idx_type i = 0; i < dv.numel (); i++)
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1384,45 +1384,45 @@ octave_class::save_hdf5 (octave_hdf5_id 
   hid_t group_hid = -1;
   hid_t type_hid = -1;
   hid_t space_hid = -1;
   hid_t class_hid = -1;
   hid_t data_hid = -1;
   octave_map m;
   octave_map::iterator i;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     goto error_cleanup;
 
   // Add the class name to the group
   type_hid = H5Tcopy (H5T_C_S1); H5Tset_size (type_hid, c_name.length () + 1);
   if (type_hid < 0)
     goto error_cleanup;
 
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     goto error_cleanup;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          octave_H5P_DEFAULT);
 #endif
   if (class_hid < 0 || H5Dwrite (class_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                                  octave_H5P_DEFAULT, c_name.c_str ()) < 0)
     goto error_cleanup;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Gcreate (group_hid, "value", octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                         octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
@@ -1495,25 +1495,25 @@ octave_class::load_hdf5 (octave_hdf5_id 
 
   herr_t retval2 = 0;
   octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
   int slen = 0;
   hsize_t rank = 0;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0)
     goto error_cleanup;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "classname", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "classname");
 #endif
 
   if (data_hid < 0)
     goto error_cleanup;
 
@@ -1556,17 +1556,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
       H5Dclose (data_hid);
       data_hid = -1;
 
       c_name = classname;
     }
   while (0);
   reconstruct_exemplar ();
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   subgroup_hid = H5Gopen (group_hid, name, octave_H5P_DEFAULT);
 #else
   subgroup_hid = H5Gopen (group_hid, name);
 #endif
   H5Gget_num_objs (subgroup_hid, &num_obj);
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -358,17 +358,17 @@ octave_complex::save_hdf5 (octave_hdf5_i
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -393,17 +393,17 @@ octave_complex::save_hdf5 (octave_hdf5_i
 
 bool
 octave_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -558,17 +558,17 @@ octave_complex_matrix::save_hdf5 (octave
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         save_type_hid = H5T_NATIVE_FLOAT;
     }
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
@@ -576,17 +576,17 @@ octave_complex_matrix::save_hdf5 (octave
 #endif
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -630,17 +630,17 @@ octave_complex_matrix::load_hdf5 (octave
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -372,17 +372,17 @@ octave_sparse_complex_matrix::save_hdf5 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                                octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
@@ -394,17 +394,17 @@ octave_sparse_complex_matrix::save_hdf5 
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -419,17 +419,17 @@ octave_sparse_complex_matrix::save_hdf5 
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -444,17 +444,17 @@ octave_sparse_complex_matrix::save_hdf5 
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -482,17 +482,17 @@ octave_sparse_complex_matrix::save_hdf5 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -520,17 +520,17 @@ octave_sparse_complex_matrix::save_hdf5 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -557,17 +557,17 @@ octave_sparse_complex_matrix::save_hdf5 
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         save_type_hid = H5T_NATIVE_FLOAT;
     }
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
@@ -576,17 +576,17 @@ octave_sparse_complex_matrix::save_hdf5 
 
   hid_t type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -630,24 +630,24 @@ octave_sparse_complex_matrix::load_hdf5 
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nr", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -662,17 +662,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nc", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -687,17 +687,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nz", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -716,17 +716,17 @@ octave_sparse_complex_matrix::load_hdf5 
     }
 
   H5Dclose (data_hid);
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
                          static_cast<octave_idx_type> (nc),
                          static_cast<octave_idx_type> (nz));
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "cidx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -759,17 +759,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "ridx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "ridx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -799,17 +799,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "data", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "data");
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -683,17 +683,17 @@ bool
 octave_fcn_handle::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                               bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   bool retval = true;
 
   hid_t group_hid = -1;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid, type_hid;
@@ -713,17 +713,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
   hdims[1] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                                 octave_H5P_DEFAULT, nm.c_str ()) < 0)
     {
@@ -744,17 +744,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
       H5Tset_size (type_hid, stmp.length () + 1);
       if (type_hid < 0)
         {
           H5Sclose (space_hid);
           H5Gclose (group_hid);
           return false;
         }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
                             octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
                             octave_H5P_DEFAULT);
 #endif
       if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                                     octave_H5P_DEFAULT, stmp.c_str ()) < 0)
@@ -775,17 +775,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
             {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
               hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
                                       H5T_NATIVE_IDX, as_id,
                                       octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 
 #else
               hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
                                       H5T_NATIVE_IDX, as_id, octave_H5P_DEFAULT);
 #endif
@@ -798,17 +798,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
                 }
               else
                 retval = false;
 
               H5Sclose (as_id);
             }
           else
             retval = false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
           data_hid = H5Gcreate (group_hid, "symbol table",
                                 octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
           data_hid = H5Gcreate (group_hid, "symbol table", 0);
 #endif
           if (data_hid < 0)
             {
               H5Sclose (space_hid);
@@ -843,17 +843,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, octaveroot.length () + 1);
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
                               type_hid, space_hid, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
                               type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
 
       if (a_id >= 0)
@@ -880,17 +880,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Gclose (group_hid);
           return false;
         }
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, fpath.length () + 1);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
 
       if (a_id >= 0)
         {
@@ -920,25 +920,25 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 #if defined (HAVE_HDF5)
 
   bool success = true;
 
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0)
     return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nm", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nm");
 #endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
@@ -994,17 +994,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
   nm = nm_tmp;
 
   if (nm == anonymous)
     {
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       data_hid = H5Dopen (group_hid, "fcn", octave_H5P_DEFAULT);
 #else
       data_hid = H5Dopen (group_hid, "fcn");
 #endif
 
       if (data_hid < 0)
         {
           H5Sclose (space_hid);
@@ -1073,17 +1073,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
       H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
 #else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "SYMBOL_TABLE");
@@ -1092,17 +1092,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
         {
           if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
             success = false;
 
           H5Aclose (attr_id);
         }
 
       // restore error reporting:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       H5Eset_auto (octave_H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
       unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
@@ -1114,17 +1114,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
         {
           hsize_t num_obj = 0;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
           data_hid = H5Gopen (group_hid, "symbol table", octave_H5P_DEFAULT);
 #else
           data_hid = H5Gopen (group_hid, "symbol table");
 #endif
           H5Gget_num_objs (data_hid, &num_obj);
           H5Gclose (data_hid);
 
           if (num_obj != static_cast<hsize_t>(len))
@@ -1179,17 +1179,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
       H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
 #else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "OCTAVEROOT");
@@ -1245,17 +1245,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
                   H5Tclose (st_id);
                 }
 
               H5Aclose (attr_id);
             }
         }
 
       // restore error reporting:
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
       H5Eset_auto (octave_H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
       success = (success ? set_fcn (octaveroot, fpath) : success);
     }
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -278,17 +278,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
                               bool /* save_as_floats */)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t group_hid = -1;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.numel (); i++)
@@ -308,17 +308,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
   hdims[0] = len + 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -362,17 +362,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                                 octave_H5P_DEFAULT, nm.c_str ()) < 0)
     {
@@ -386,17 +386,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
   // attach the type of the variable
   H5Tset_size (type_hid, iftext.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                                 octave_H5P_DEFAULT, iftext.c_str ()) < 0)
@@ -423,24 +423,24 @@ bool
 octave_fcn_inline::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "args", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "args");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -470,17 +470,17 @@ octave_fcn_inline::load_hdf5 (octave_hdf
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   for (size_t i = 0; i < hdims[1]; i++)
     ifargs(i) = std::string (s1 + i*hdims[0]);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nm", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nm");
 #endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
@@ -532,17 +532,17 @@ octave_fcn_inline::load_hdf5 (octave_hdf
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
   nm = nm_tmp;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "iftext", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "iftext");
 #endif
 
   if (data_hid < 0)
     {
       H5Gclose (group_hid);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -189,17 +189,17 @@ octave_float_scalar::save_hdf5 (octave_h
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -221,17 +221,17 @@ octave_float_scalar::save_hdf5 (octave_h
   return retval;
 }
 
 bool
 octave_float_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -309,17 +309,17 @@ octave_float_complex::save_hdf5 (octave_
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -344,17 +344,17 @@ octave_float_complex::save_hdf5 (octave_
 
 bool
 octave_float_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -510,17 +510,17 @@ octave_float_complex_matrix::save_hdf5 (
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       float max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
@@ -528,17 +528,17 @@ octave_float_complex_matrix::save_hdf5 (
 #endif
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -581,17 +581,17 @@ octave_float_complex_matrix::load_hdf5 (
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -533,28 +533,28 @@ octave_float_matrix::save_hdf5 (octave_h
     hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       float max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -585,17 +585,17 @@ octave_float_matrix::load_hdf5 (octave_h
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "fpucw.h"
 
-#if HAVE_FPU_CONTROL_H
+#if defined (HAVE_FPU_CONTROL_H)
 #  include <fpu_control.h>
 #endif
 
 #if defined HAVE_JAVA
 
 #if defined (HAVE_WINDOWS_H)
 #  include <windows.h>
 #endif
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -560,17 +560,17 @@ octave_range::save_hdf5 (octave_hdf5_id 
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
@@ -607,17 +607,17 @@ octave_range::save_hdf5 (octave_hdf5_id 
 
 bool
 octave_range::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t range_type = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -655,29 +655,29 @@ octave_matrix::save_hdf5 (octave_hdf5_id
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         save_type_hid = H5T_NATIVE_FLOAT;
     }
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -708,17 +708,17 @@ octave_matrix::load_hdf5 (octave_hdf5_id
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -394,17 +394,17 @@ octave_sparse_matrix::save_hdf5 (octave_
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                                octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
@@ -415,17 +415,17 @@ octave_sparse_matrix::save_hdf5 (octave_
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -439,17 +439,17 @@ octave_sparse_matrix::save_hdf5 (octave_
                      &tmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -464,17 +464,17 @@ octave_sparse_matrix::save_hdf5 (octave_
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -502,17 +502,17 @@ octave_sparse_matrix::save_hdf5 (octave_
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -539,17 +539,17 @@ octave_sparse_matrix::save_hdf5 (octave_
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -576,29 +576,29 @@ octave_sparse_matrix::save_hdf5 (octave_
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         save_type_hid = H5T_NATIVE_FLOAT;
     }
-#if HAVE_HDF5_INT2FLOAT_CONVERSIONS
+#if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -634,24 +634,24 @@ octave_sparse_matrix::load_hdf5 (octave_
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   group_hid = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nr", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -666,17 +666,17 @@ octave_sparse_matrix::load_hdf5 (octave_
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nc", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -691,17 +691,17 @@ octave_sparse_matrix::load_hdf5 (octave_
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "nz", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
@@ -720,17 +720,17 @@ octave_sparse_matrix::load_hdf5 (octave_
     }
 
   H5Dclose (data_hid);
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
                   static_cast<octave_idx_type> (nc),
                   static_cast<octave_idx_type> (nz));
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "cidx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -763,17 +763,17 @@ octave_sparse_matrix::load_hdf5 (octave_
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "ridx", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "ridx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
@@ -802,17 +802,17 @@ octave_sparse_matrix::load_hdf5 (octave_
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dopen (group_hid, "data", octave_H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "data");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -206,17 +206,17 @@ octave_scalar::save_hdf5 (octave_hdf5_id
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -238,17 +238,17 @@ octave_scalar::save_hdf5 (octave_hdf5_id
   return retval;
 }
 
 bool
 octave_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -551,17 +551,17 @@ octave_char_matrix_str::save_hdf5 (octav
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0)
     return false;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
@@ -596,17 +596,17 @@ octave_char_matrix_str::load_hdf5 (octav
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
   hid_t type_hid = H5Dget_type (data_hid);
   hid_t type_class_hid = H5Tget_class (type_hid);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -872,17 +872,17 @@ octave_struct::load_binary (std::istream
 
 bool
 octave_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   hid_t data_hid = -1;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the structure to this group
   octave_map m = map_value ();
@@ -924,17 +924,17 @@ octave_struct::load_hdf5 (octave_hdf5_id
 #if defined (HAVE_HDF5)
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_id = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // FIXME: fields appear to be sorted alphabetically on loading.
@@ -1469,17 +1469,17 @@ octave_scalar_struct::load_binary (std::
 bool
 octave_scalar_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                                  bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   hid_t data_hid = -1;
 
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the structure to this group
   octave_scalar_map m = scalar_map_value ();
@@ -1521,17 +1521,17 @@ octave_scalar_struct::load_hdf5 (octave_
 #if defined (HAVE_HDF5)
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_scalar_map m;
   int current_item = 0;
   hsize_t num_obj = 0;
-#if HAVE_HDF5_18
+#if defined (HAVE_HDF5_18)
   hid_t group_id = H5Gopen (loc_id, name, octave_H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // FIXME: fields appear to be sorted alphabetically on loading.
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -292,17 +292,17 @@ tree_evaluator::visit_simple_for_command
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
-#if HAVE_LLVM
+#if defined (HAVE_LLVM)
   if (tree_jit::execute (cmd, rhs))
     return;
 #endif
 
   if (rhs.is_undefined ())
     return;
 
   tree_expression *lhs = cmd.left_hand_side ();
@@ -1011,17 +1011,17 @@ tree_evaluator::visit_unwind_protect_com
       // unwind_protect block runs without error.
       do_unwind_protect_cleanup_code (cleanup_code);
     }
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
-#if HAVE_LLVM
+#if defined (HAVE_LLVM)
   if (tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
@@ -1050,17 +1050,17 @@ tree_evaluator::visit_while_command (tre
       else
         break;
     }
 }
 
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
-#if HAVE_LLVM
+#if defined (HAVE_LLVM)
   if (tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
