# HG changeset patch
# User jwe
# Date 1194553106 0
#      Thu Nov 08 20:18:26 2007 +0000
# Node ID 59dcf01bb3e38c2fcc51fd64a724368ca4027916
# Parent  8aa770b6c5bfd5771bd12c4b5b0532bbf5e1f899
[project @ 2007-11-08 20:18:25 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -13,31 +13,51 @@ 2007-11-08  John W. Eaton  <jwe@octave.o
 	control/hinf/hinfnorm.m, control/hinf/hinfsyn.m,
 	control/hinf/hinfsyn_chk.m, control/hinf/is_dgkf.m,
 	control/hinf/wgt1o.m, control/obsolete/dezero.m,
 	control/obsolete/dlqg.m, control/obsolete/minfo.m,
 	control/obsolete/packsys.m, control/obsolete/qzval.m,
 	control/obsolete/rotg.m, control/obsolete/series.m,
 	control/obsolete/swapcols.m, control/obsolete/swaprows.m,
 	control/obsolete/syschnames.m, control/obsolete/unpacksys.m,
-	control/system/buildssic.m, control/system/c2d.m,
-	control/system/d2c.m, control/system/dmr2d.m, control/system/ss.m,
-	control/system/ss2sys.m, control/system/sysadd.m,
-	control/system/sysappend.m, control/system/sysconnect.m,
+	control/system/__syschnamesl__.m,
+	control/system/__syscont_disc__.m,
+	control/system/__sysdefioname__.m, control/system/__sysgroupn__.m,
+	control/system/__tf2sysl__.m, control/system/__zp2ssg2__.m,
+	control/system/abcddim.m, control/system/buildssic.m,
+	control/system/c2d.m, control/system/cellidx.m,
+	control/system/d2c.m, control/system/dmr2d.m,
+	control/system/fir2sys.m, control/system/is_abcd.m,
+	control/system/is_controllable.m, control/system/is_detectable.m,
+	control/system/is_digital.m, control/system/is_observable.m,
+	control/system/is_stabilizable.m, control/system/is_stable.m,
+	control/system/jet707.m, control/system/listidx.m,
+	control/system/parallel.m, control/system/ss.m,
+	control/system/ss2sys.m, control/system/ss2zp.m,
+	control/system/starp.m, control/system/sys2ss.m,
+	control/system/sys2tf.m, control/system/sys2zp.m,
+	control/system/sysadd.m, control/system/sysappend.m,
+	control/system/sysconnect.m, control/system/syscont.m,
+	control/system/sysdimensions.m, control/system/sysdisc.m,
 	control/system/sysdup.m, control/system/sysgetsignals.m,
 	control/system/sysgroup.m, control/system/sysmin.m,
-	control/system/sysout.m, control/system/sysprune.m,
+	control/system/sysmult.m, control/system/sysout.m,
+	control/system/sysprune.m, control/system/sysreorder.m,
 	control/system/sysscale.m, control/system/syssetsignals.m,
-	control/system/tf.m, control/system/zp2ss.m,
-	control/util/__outlist__.m, control/util/__zgpbal__.m,
-	control/util/axis2dlim.m, control/util/prompt.m,
-	control/util/sortcom.m, control/util/zgfmul.m,
-	control/util/zgfslv.m, control/util/zginit.m,
-	control/util/zgreduce.m, control/util/zgrownorm.m,
-	control/util/zgscal.m: Style fixes.
+	control/system/syssub.m, control/system/sysupdate.m,
+	control/system/tf.m, control/system/tf2ss.m,
+	control/system/tf2sys.m, control/system/tfout.m,
+	control/system/zp.m, control/system/zp2ss.m,
+	control/system/zp2sys.m, control/system/zp2tf.m,
+	control/system/zpout.m, control/util/__outlist__.m,
+	control/util/__zgpbal__.m, control/util/axis2dlim.m,
+	control/util/prompt.m, control/util/sortcom.m,
+	control/util/zgfmul.m, control/util/zgfslv.m,
+	control/util/zginit.m, control/util/zgreduce.m,
+	control/util/zgrownorm.m, control/util/zgscal.m: Style fixes.
 
 2007-11-08  David Bateman  <dbateman@free.fr>
 
 	* plot/quiver.m: Fix arrowheads.
 
 2007-11-07  Ben Abbott  <bpabbott@mac.com>
 
 	* set/ismember.m: Call cell_ismember to handle cellstr args.
diff --git a/scripts/control/system/__syschnamesl__.m b/scripts/control/system/__syschnamesl__.m
--- a/scripts/control/system/__syschnamesl__.m
+++ b/scripts/control/system/__syschnamesl__.m
@@ -28,92 +28,93 @@
 ## listname: name of index list
 ##
 ## combines the two string lists old_names and inames
 ## @end deftypefn
 
 function old_names = __syschnamesl__ (olist, old_names, inames, listname)
 
   probstr = [];
-  if( max(olist) > rows(old_names) )
-    probstr = ["index list value(s) exceed(s) number of signals (", ...
-      num2str(rows(old_names)),")"];
+
+  if (max (olist) > rows (old_names))
+    probstr = sprintf ("index list value(s) exceed(s) number of signals (%d)",
+		       rows (old_names));
 
-  elseif( length(olist) > rows(inames) )
-    probstr = ["index list dimension exceeds number of replacement names (", ...
-      num2str(rows(inames)),")"];
+  elseif (length (olist) > rows (inames))
+    probstr = sprintf ("index list dimension exceeds number of replacement names (%d)",
+		       rows (inames));
 
-  elseif(isempty(olist))
+  elseif (isempty (olist))
     probstr = [];    # do nothing, no changes
 
-  elseif(min(size(olist)) != 1 )
+  elseif (min (size (olist)) != 1)
     probstr = "index list must be either a vector or an empty matrix";
 
-  elseif(max(olist) > rows(old_names))
-    probstr = ["max(",listname,")=",num2str(max(olist))," > ", ...
-        num2str(rows(old_names)),", too big"];
+  elseif (max (olist) > rows (old_names))
+    probstr = sprintf ("max(%s)=%d > %d, too big", listname,
+		       max (olist), rows (old_names));
 
-  elseif(min(olist) < 1)
-    probstr = ["min(",listname,")=",num2str(min(olist))," < 1, too small"];
+  elseif (min (olist) < 1)
+    probstr = sprintf ("min(%s)=%d < 1, too small", listname, min (olist));
 
   else
-    if( length(olist)  == 1)
-        len_in = columns(inames);
-        len_out = columns(old_names);
+    if (length(olist) == 1)
+        len_in = columns (inames);
+        len_out = columns (old_names);
 
       if (len_in < len_out)
-        inames(1,(len_in+1):(len_out)) = zeros(1,(len_out - len_in));
+        inames(1,(len_in+1):(len_out)) = zeros (1, len_out-len_in);
       endif
 
       old_names(olist,1:length(inames)) = inames;
-    elseif(length(olist) > 1)
-      for ii=1:length(olist)
+    elseif (length(olist) > 1)
+      for ii = 1:length(olist)
         mystr = inames(ii,:);
-        len_my = columns(mystr);
-        len_out = columns(old_names);
+        len_my = columns (mystr);
+        len_out = columns (old_names);
 
         if (len_my < len_out)
-          mystr(1,(len_my+1):(len_out)) = " "*ones(1,(len_out - len_my));
+          mystr(1,(len_my+1):len_out) = repmat (" ", 1, len_out-len_my);
           len_my = len_out;
         endif
 
         old_names(olist(ii),1:len_my) = mystr;
       endfor
     endif
   endif
-  if(!isempty(probstr))
+  if (! isempty (probstr))
     ## the following lines are NOT debugging code!
-    disp("Problem in syschnames: old names are")
-    __outlist__(old_names," ")
-    disp("new names are")
+    disp ("Problem in syschnames: old names are")
+    __outlist__ (old_names," ")
+    disp ("new names are")
     __outlist__(inames,"    ")
-    disp("list indices are")
-    disp(olist)
-    error(sprintf("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
-        listname, rows(olist), columns(olist),probstr));
+    disp ("list indices are")
+    disp (olist)
+    error (sprintf ("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
+		    listname, rows (olist), columns (olist), probstr));
   endif
 
   ## change zeros  to blanks
-  if( find(old_names == 0) )
+  if (find (old_names == 0))
     ## disp("__syschnamesl__: old_names contains zeros ")
     ## old_names
     ## disp("/__syschnamesl__");
 
-    [ii,jj] = find(old_names == 0);
-    for idx=1:length(ii)
+    [ii, jj] = find (old_names == 0);
+    for idx = 1:length(ii)
       old_names(ii(idx),jj(idx)) = " ";
     endfor
 
     ## disp("__syschnamesl__: old_names fixed zeros ")
     ## old_names
     ## disp("/__syschnamesl__");
   endif
 
   ## just in case it's not a string anymore
-  if( !ischar(old_names) )
-    old_names = char(old_names);
+  if (! ischar (old_names))
+    old_names = char (old_names);
   endif
 
   ## disp("__syschnamesl__: exit, old_names=")
   ## old_names
   ## disp("/__syschnamesl__: exiting")
 
 endfunction
diff --git a/scripts/control/system/__syscont_disc__.m b/scripts/control/system/__syscont_disc__.m
--- a/scripts/control/system/__syscont_disc__.m
+++ b/scripts/control/system/__syscont_disc__.m
@@ -42,16 +42,16 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: February 1997
 
 function [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys)
 
   ## get ranges for discrete/continuous states and outputs
-  [nn,nz,mm,pp,yd] = sysdimensions(sys);
+  [nn, nz, mm, pp, yd] = sysdimensions (sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
-  y_c = find(yd == 0);          # y_c, y_d will be empty if there are none.
-  y_d = find(yd == 1);
+  y_c = find (yd == 0);          # y_c, y_d will be empty if there are none.
+  y_d = find (yd == 1);
 
 endfunction
diff --git a/scripts/control/system/__sysdefioname__.m b/scripts/control/system/__sysdefioname__.m
--- a/scripts/control/system/__sysdefioname__.m
+++ b/scripts/control/system/__sysdefioname__.m
@@ -36,25 +36,27 @@
 ##   [2] = u_4
 ##   [3] = u_5
 ## )
 ## @end example
 ## @end deftypefn
 
 function ioname = __sysdefioname__ (n, str, m)
 
-  if (nargin < 2 | nargin > 3)
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  if (nargin == 2)           m = min(1,n);            endif
+  if (nargin == 2)
+    m = min (1, n);
+  endif
 
   ioname = {};
   jj = 1;
-  if(n > 0 & m > 0 & m <= n)
+  if (n > 0 && m > 0 && m <= n)
     for ii = m:n
-      ioname{ii+1-m} = sprintf("%s_%d",str,ii);
+      ioname{ii+1-m} = sprintf ("%s_%d", str, ii);
     endfor
-  elseif(m > n)
-    error("str=%s; start value m=%d > final value n=%d",str,m,n);
+  elseif (m > n)
+    error ("str=%s; start value m=%d > final value n=%d", str, m, n);
   endif
 
 endfunction
diff --git a/scripts/control/system/__sysgroupn__.m b/scripts/control/system/__sysgroupn__.m
--- a/scripts/control/system/__sysgroupn__.m
+++ b/scripts/control/system/__sysgroupn__.m
@@ -30,30 +30,30 @@
 ## message is printed to inform the user of the new signal name
 ##
 ## used internally in sysgroup and elsewhere.
 ## @end deftypefn
 
 function names = __sysgroupn__ (names, kind)
 
   ## check for duplicate names
-  l = length(names);
+  l = length (names);
   ii = 1;
-  while(ii <= l-1)
+  while (ii <= l-1)
     st1 = names{ii};
     jj = ii+1;
-    while ( jj <= l)
+    while (jj <= l)
       st2 = names{jj};
-      if(strcmp(st1,st2))
-        suffix = ["_",num2str(jj)];
-        warning("sysgroup: %s name(%d) = %s name(%d) = %s", ...
-          kind,ii,kind,jj,st1);
-        strval = sprintf("%s%s",st2,suffix);
+      if (strcmp (st1, st2))
+        warning ("sysgroup: %s name(%d) = %s name(%d) = %s",
+		 kind, ii, kind, jj, st1);
+        strval = sprintf ("%s_%d", st2, jj)
         names{jj} = strval;
-        warning("sysgroup:     changed %s name %d to %s",kind,jj,strval);
+        warning ("sysgroup:     changed %s name %d to %s", kind, jj, strval);
         ## restart the check (just to be sure there's no further duplications)
-        ii = 0; jj = l;
+        ii = 0;
+	jj = l;
       endif
-      jj = jj+1;
+      jj++;
     endwhile
-    ii = ii+1;
+    ii++;
   endwhile
 endfunction
diff --git a/scripts/control/system/__tf2sysl__.m b/scripts/control/system/__tf2sysl__.m
--- a/scripts/control/system/__tf2sysl__.m
+++ b/scripts/control/system/__tf2sysl__.m
@@ -22,11 +22,11 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __tf2sysl__ (@var{vec})
 ## used internally in tf2sys.
 ## strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
 function vec = __tf2sysl__ (vec)
 
-  error("__tf2sysl__ no longer used; use the tf function.");
+  error ("__tf2sysl__ no longer used; use the tf function.");
 
 endfunction
diff --git a/scripts/control/system/__zp2ssg2__.m b/scripts/control/system/__zp2ssg2__.m
--- a/scripts/control/system/__zp2ssg2__.m
+++ b/scripts/control/system/__zp2ssg2__.m
@@ -27,45 +27,48 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1996
 
 function [poly, rvals] = __zp2ssg2__ (rvals)
 
   ## locate imaginary roots (if any)
-  cidx = find(imag(rvals));
+  cidx = find (imag (rvals));
 
-  if(!isempty(cidx))
+  if (! isempty (cidx))
     ## select first complex root, omit from cidx
-    r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
+    r1i = cidx(1);
+    r1 = rvals(r1i);
+    cidx = complement (r1i, cidx);
 
     ## locate conjugate root (must be in cidx list, just in case there's
     ## roundoff)
-    err = abs(rvals(cidx) - r1');
-    minerr = min(err);
-    c2i = find(err == minerr, 1);
+    err = abs (rvals(cidx) - r1');
+    minerr = min (err);
+    c2i = find (err == minerr, 1);
     r2i = cidx(c2i);
     r2 = rvals(r2i);
-    cidx = complement(r2i,cidx);
+    cidx = complement (r2i, cidx);
 
     ## don't check for divide by zero, since 0 is not complex.
-    if(abs(r2 - r1')/abs(r1) > 1e-12)
-      error(sprintf("r1=(%f,%f); r2=(%f,%f), not conjugates.", ...
-        real(r1),imag(r1),real(r2),imag(r2)));
+    if (abs (r2-r1') / abs (r1) > 1e-12)
+      error ("r1=(%f,%f); r2=(%f,%f), not conjugates.",
+             real (r1), imag (r1), real (r2), imag(r2));
     endif
 
     ## complex conjugate pair
     poly = [1, -2*real(r1), real(r1)^2+imag(r1)^2];
   else
     ## select two roots (they're all real)
     r1 = rvals(1);
     r2 = rvals(2);
     poly = [1, -(r1+r2), (r1*r2)];
-    r1i = 1;  r2i = 2;
+    r1i = 1;
+    r2i = 2;
   endif
 
   ## remove roots used
-  idx = complement([r1i, r2i],1:length(rvals));
+  idx = complement ([r1i, r2i], 1:length(rvals));
   rvals = rvals(idx);
 
 endfunction
 
diff --git a/scripts/control/system/abcddim.m b/scripts/control/system/abcddim.m
--- a/scripts/control/system/abcddim.m
+++ b/scripts/control/system/abcddim.m
@@ -63,67 +63,68 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993.
 ## a s hodel: modified to accept pure-gain systems aug 1996
 
 function [n, m, p] = abcddim (a, b, c, d)
 
   if (nargin != 4)
-    error ("abcddim: four arguments required");
+    print_usage ();
   endif
 
   n = m = p = -1;
 
   [a, an, am] = __abcddims__ (a);
   [b, bn, bm] = __abcddims__ (b);
   [c, cn, cm] = __abcddims__ (c);
   [d, dn, dm] = __abcddims__ (d);
 
-  if ( (!issquare(a)) & (!isempty(a)) )
-    warning (["abcddim: a is not square (",num2str(an),"x",num2str(am),")"]);
-    return
+  if (! issquare (a) && ! isempty (a))
+    warning ("abcddim: a is not square (%dx%d)", an, am);
+    return;
   endif
 
-  if( (bm == 0) & (dm == 0) )
-    warning("abcddim: no inputs");
+  if (bm == 0 && dm == 0)
+    warning ("abcddim: no inputs");
   elseif (bn != am)
-    warning (["abcddim: a(",num2str(an),"x",num2str(am), ...
-      " and b(",num2str(bn),"x",num2str(bm),") are not compatible"]);
-    return
+    warning ("abcddim: a(%dx%d) and b(%dx%d) are not compatible",
+	     an, am, bn, bm);
+    return;
   endif
 
-  if( (cn == 0) & (dn == 0 ) )
-    warning("abcddim: no outputs");
+  if (cn == 0 && dn == 0)
+    warning ("abcddim: no outputs");
   elseif (cm != an)
-    warning (["abcddim: a(",num2str(an),"x",num2str(am), ...
-        " and c(",num2str(cn),"x",num2str(cm),") are not compatible"]);
-    return
+    warning ("abcddim: a(%dx%d) and c(%dx%d) are not compatible",
+	     an, am, cn, cm);
+    return;
   endif
 
   have_connections = (bn*cn != 0);
 
-  if( (dn == 0) & have_connections)
-    warning("abcddim: empty d matrix passed; setting compatibly with b, c");
+  if (dn == 0 && have_connections)
+    warning ("abcddim: empty d matrix passed; setting compatibly with b, c");
     [d, dn, dm] = __abcddims__ (zeros (cn, bm));
   endif
 
-  if(an > 0)
-    [dn, dm] = size(d);
-    if ( (cn != dn) & have_connections )
-      warning (["abcddim: c(",num2str(cn),"x",num2str(cm), ...
-        " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
-      return
+  if (an > 0)
+    [dn, dm] = size (d);
+    if (cn != dn && have_connections)
+      warning ("abcddim: c(%dx%d) and d(%dx%d) are not compatible",
+	       cn, cm, dn, dm);
+      return;
     endif
 
-    if ( (bm != dm) & have_connections )
-      warning (["abcddim: b(",num2str(bn),"x",num2str(bm), ...
-          " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
-      return
+    if (bm != dm && have_connections)
+      warning ("abcddim: b(",num2str(bn),"x",num2str(bm), ...
+          " and d(",num2str(dn),"x",num2str(dm),") are not compatible");
+      return;
     endif
 
     m = bm;
     p = cn;
   else
-    [p,m] = size(d);
+    [p, m] = size (d);
   endif
   n = an;
+
 endfunction
diff --git a/scripts/control/system/cellidx.m b/scripts/control/system/cellidx.m
--- a/scripts/control/system/cellidx.m
+++ b/scripts/control/system/cellidx.m
@@ -29,70 +29,72 @@
 ## The first output is the vector of indices in @var{listvar}.
 ##
 ## If @var{strlist} contains a string not in @var{listvar}, then
 ## an error message is returned in @var{errmsg}.  If only one output
 ## argument is requested, then @var{cellidx} prints @var{errmsg} to the
 ## screen and exits with an error.
 ## @end deftypefn
 
-function [idxvec,errmsg]  = cellidx(listvar,strlist)
+function [idxvec,errmsg]  = cellidx (listvar, strlist)
 
-if(nargin != 2)
-  print_usage ();
-endif
+  if (nargin != 2)
+    print_usage ();
+  endif
 
-if(ischar(strlist))
-  tmp = strlist;
-  strlist = {};
-  for kk=1:rows(tmp)
-    strlist{kk} = deblank(tmp(kk,:));
-  endfor
-endif
+  if (ischar (strlist))
+    tmp = strlist;
+    strlist = {};
+    for kk = 1:rows(tmp)
+      strlist{kk} = deblank (tmp(kk,:));
+    endfor
+  endif
 
-if(ischar(listvar))
-  tmp = listvar;
-  listvar = {};
-  for kk=1:rows(tmp)
-    listvar{kk} = deblank(tmp(kk,:));
-  endfor
-endif
+  if (ischar (listvar))
+    tmp = listvar;
+    listvar = {};
+    for kk = 1:rows(tmp)
+      listvar{kk} = deblank (tmp(kk,:));
+    endfor
+  endif
+
+  ## initialize size of idxvec (for premature return)
+  idxvec = zeros (length(strlist), 1);
 
-## initialize size of idxvec (for premature return)
-idxvec = zeros(length(strlist),1);
+  errmsg = "";
+  if (! is_signal_list (listvar))
+    errmsg = "listvar must be a list of strings";
+  elseif (! is_signal_list (strlist))
+    errmsg = "strlist must be a list of strings";
+  endif
 
-errmsg = "";
-if(!is_signal_list(listvar))
-  errmsg = "listvar must be a list of strings";
-elseif(!is_signal_list(strlist))
-  errmsg = "strlist must be a list of strings";
-endif
+  if (length (errmsg))
+    if (nargout < 2)
+      error (errmsg);
+    else
+      return;
+    endif
+  endif
 
-if(length(errmsg))
-  if(nargout < 2) error(errmsg);
-  else return;
-  endif
-endif
-
-nsigs = length(listvar);
-for idx = 1:length(strlist)
-  signame = strlist{idx};
-  for jdx = 1:nsigs
-    if( strcmp(signame,listvar{jdx}) )
-      if(idxvec(idx) != 0)
-        warning("Duplicate signal name %s (%d,%d)\n", ...
-          listvar{jdx},jdx,idxvec(idx));
+  nsigs = length(listvar);
+  for idx = 1:length(strlist)
+    signame = strlist{idx};
+    for jdx = 1:nsigs
+      if (strcmp (signame, listvar{jdx}) )
+	if (idxvec(idx) != 0)
+	  warning ("Duplicate signal name %s (%d,%d)\n",
+		   listvar{jdx}, jdx, idxvec(idx));
+	else
+	  idxvec(idx) = jdx;
+	endif
+      endif
+    endfor
+    if (idxvec(idx) == 0)
+      errmsg = sprintf ("Did not find %s", signame);
+      if (nargout == 1)
+	error (errmsg);
       else
-        idxvec(idx) = jdx;
+	break;
       endif
     endif
   endfor
-  if(idxvec(idx) == 0)
-    errmsg = sprintf("Did not find %s",signame);
-    if(nargout == 1)
-      error(errmsg);
-    else
-      break
-    end
-  endif
-endfor
 
 endfunction
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -82,28 +82,26 @@
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## adapted from tf2sys july 1996
 
 function sys = fir2sys (num, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
-  if (nargin < 1 | nargin > 4)
+  if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   ## let tf do the argument checking
-  den = [1,zeros(1,length(num)-1)];
+  den = [1, zeros(1,length(num)-1)];
 
   ## check sampling interval (if any)
-  if (nargin <= 1)
+  if (nargin < 2 || isempty (tsam))
     tsam = 1;           # default
-  elseif (isempty(tsam))
-    tsam = 1;
   endif
 
   ## Set name of input
   if (nargin < 3)
     inname = __sysdefioname__ (1, "u");
   endif
 
   ## Set name of output
diff --git a/scripts/control/system/is_abcd.m b/scripts/control/system/is_abcd.m
--- a/scripts/control/system/is_abcd.m
+++ b/scripts/control/system/is_abcd.m
@@ -27,71 +27,78 @@
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function retval = is_abcd (a, b, c, d)
 
   retval = 0;
+
   switch (nargin)
-    case (1)
+    case 1
       ## A only
-      [na, ma] = size(a);
+      [na, ma] = size (a);
       if (na != ma)
-        disp("Matrix A ist not square.")
+        disp ("Matrix A ist not square.")
       endif
-    case (2)
+    case 2
       ## A, B only
-      [na, ma] = size(a);  [nb, mb] = size(b);
+      [na, ma] = size (a);
+      [nb, mb] = size(b);
       if (na != ma)
-        disp("Matrix A ist not square.")
+        disp ("Matrix A ist not square.")
         return;
       endif
       if (na != nb)
-        disp("A and B column dimension different.")
+        disp ("A and B column dimension different.")
         return;
       endif
-    case (3)
+    case 3
       ## A, B, C only
-      [na, ma] = size(a);  [nb, mb] = size(b);  [nc, mc] = size(c);
+      [na, ma] = size(a);
+      [nb, mb] = size(b);
+      [nc, mc] = size(c);
       if (na != ma)
-        disp("Matrix A ist not square.")
+        disp ("Matrix A ist not square.")
         return;
       endif
       if (na != nb)
-        disp("A and B column dimensions not compatible.")
+        disp ("A and B column dimensions not compatible.")
         return;
       endif
       if (ma != mc)
-        disp("A and C row dimensions not compatible.")
+        disp ("A and C row dimensions not compatible.")
         return;
       endif
-    case (4)
+    case 4
       ## all matrices A, B, C, D
-      [na, ma] = size(a);  [nb, mb] = size(b);
-      [nc, mc] = size(c);  [nd, md] = size(d);
+      [na, ma] = size(a);
+      [nb, mb] = size(b);
+      [nc, mc] = size(c);
+      [nd, md] = size(d);
       if (na != ma)
-        disp("Matrix A ist not square.")
+        disp ("Matrix A ist not square.")
         return;
       endif
       if (na != nb)
-        disp("A and B column dimensions not compatible.")
+        disp ("A and B column dimensions not compatible.")
         return;
       endif
       if (ma != mc)
-        disp("A and C row dimensions not compatible.")
+        disp ("A and C row dimensions not compatible.")
         return;
       endif
       if (mb != md)
-        disp("B and D row dimensions not compatible.")
+        disp ("B and D row dimensions not compatible.")
         return;
       endif
       if (nc != nd)
-        disp("C and D column dimensions not compatible.")
+        disp ("C and D column dimensions not compatible.")
         return;
       endif
     otherwise
       print_usage ();
   endswitch
   ## all tests passed, signal ok.
   retval = 1;
+
 endfunction
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -60,55 +60,59 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
   deftol = 1;    # assume default tolerance
-  if(nargin < 1 | nargin > 3)
+
+  if (nargin < 1 || nargin > 3)
     print_usage ();
-  elseif(isstruct(a))
+  elseif (isstruct (a))
     ## system structure passed.
-    sys = sysupdate(a,"ss");
-    [a,bs] = sys2ss(sys);
-    if(nargin > 2)
+    sys = sysupdate (a, "ss");
+    [a, bs] = sys2ss (sys);
+    if (nargin > 2)
       print_usage ();
-    elseif(nargin == 2)
+    elseif (nargin == 2)
       tol = b;          % get tolerance
       deftol = 0;
     endif
     b = bs;
   else
     ## a,b arguments sent directly.
-    if(nargin < 2)
+    if (nargin < 2)
       print_usage ();
     else
       deftol = 1;
     endif
   endif
 
   ## check for default tolerance
-  if(deftol) tol = 1000*eps; endif
+  if (deftol)
+    tol = 1000*eps;
+  endif
 
   ## check tol dimensions
-  if( !isscalar(tol) )
-    error("is_controllable: tol(%dx%d) must be a scalar", ...
-        rows(tol),columns(tol));
-  elseif( !is_sample(tol) )
-    error("is_controllable: tol=%e must be positive",tol);
+  if (! isscalar (tol))
+    error ("is_controllable: tol(%dx%d) must be a scalar", ...
+           rows (tol), columns (tol));
+  elseif (! is_sample (tol))
+    error ("is_controllable: tol=%e must be positive",tol);
   endif
 
   ## check dimensions compatibility
   n = issquare (a);
   [nr, nc] = size (b);
 
-  if (n == 0 | n != nr | nc == 0)
-    warning("is_controllable: a=(%dx%d), b(%dx%d)",rows(a),columns(a),nr,nc);
+  if (n == 0 || n != nr || nc == 0)
+    warning ("is_controllable: a=(%dx%d), b(%dx%d)",rows(a),columns(a),nr,nc);
     retval = 0;
   else
     ## call block-krylov subspace routine to get an orthogonal basis
     ## of the controllable subspace.
-    [U,H,Ucols] = krylov(a,b,n,tol,1);
+    [U, H, Ucols] = krylov (a, b, n, tol, 1);
     retval = (Ucols == n);
   endif
+
 endfunction
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -33,35 +33,36 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol, dflg)
 
-  if( nargin < 1)
+  if (nargin < 1)
     print_usage ();
-  elseif(isstruct(a))
+  elseif (isstruct (a))
     ## system form
-    if(nargin == 2)
+    if (nargin == 2)
       tol = c;
-    elseif(nargin > 2)
+    elseif (nargin > 2)
       print_usage ();
     endif
-    dflg = is_digital(a);
-    [a,b,c] = sys2ss(a);
+    dflg = is_digital (a);
+    [a,b,c] = sys2ss (a);
   else
-    if ((nargin > 4)||(nargin == 1))
+    if (nargin > 4 || nargin == 1)
       print_usage ();
     endif
-    if (~exist("dflg"))
+    if (! exist ("dflg"))
       dflg = 0;
-    end
-  end
+    endif
+  endif
 
-  if(~exist("tol"))
+  if (! exist ("tol"))
     tol = 200*eps;
   end    
-  retval = is_stabilizable(a',c',tol,dflg);
+
+  retval = is_stabilizable (a', c', tol, dflg);
 
 endfunction
 
diff --git a/scripts/control/system/is_digital.m b/scripts/control/system/is_digital.m
--- a/scripts/control/system/is_digital.m
+++ b/scripts/control/system/is_digital.m
@@ -42,41 +42,42 @@
 ## Exits with an error if @var{sys} is a mixed (continuous and discrete) system.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function DIGITAL = is_digital (sys, eflg)
 
-  switch(nargin)
-  case(1),  eflg = 0;
-  case(2),
-    if( isempty(find(eflg == [0, 1, 2])) )
-      error("invalid value of eflg=%d (%e)",eflg,eflg);
+  switch (nargin)
+  case 1
+    eflg = 0;
+  case 2
+    if (isempty (find (eflg == [0, 1, 2])))
+      error ("invalid value of eflg=%g", eflg);
     endif
   otherwise,
     print_usage ();
   endswitch
 
   ## checked for sampled data system (mixed)
   ## discrete system
-  sysyd = sysgetsignals(sys,"yd");
-  [nn,nz] = sysdimensions(sys);
-  cont = sum(sysyd == 0) + nn;
-  tsam = sysgettsam(sys);
-  dig = sum(sysyd != 0) + nz + tsam;
+  sysyd = sysgetsignals (sys, "yd");
+  [nn, nz] = sysdimensions (sys);
+  cont = sum (sysyd == 0) + nn;
+  tsam = sysgettsam (sys);
+  dig = sum (sysyd != 0) + nz + tsam;
 
   ## check for mixed system
-  if( cont*dig != 0)
-   switch(eflg)
-   case(0),
-     error("continuous/discrete system; use syscont, sysdisc, or c2d first");
-   case(1),
-     warning("is_digital: mixed continuous/discrete system");
+  if (cont*dig != 0)
+   switch (eflg)
+   case 0
+     error ("continuous/discrete system; use syscont, sysdisc, or c2d first");
+   case 1
+     warning ("is_digital: mixed continuous/discrete system");
    endswitch
    dig_sign = -1;
   else
    dig_sign = 1;
   endif
 
   DIGITAL = dig_sign*(tsam > 0);
 
diff --git a/scripts/control/system/is_observable.m b/scripts/control/system/is_observable.m
--- a/scripts/control/system/is_observable.m
+++ b/scripts/control/system/is_observable.m
@@ -33,29 +33,29 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
-  if( nargin < 1)
+  if (nargin < 1)
     print_usage ();
-  elseif(isstruct(a))
+  elseif (isstruct (a))
     ## system form
-    if(nargin == 2)
+    if (nargin == 2)
       tol = c;
-    elseif(nargin > 2)
+    elseif (nargin > 2)
       print_usage ();
     endif
-    [a,b,c] = sys2ss(a);
-  elseif(nargin > 3)
+    [a, b, c] = sys2ss (a);
+  elseif (nargin > 3)
     print_usage ();
   endif
-  if(exist("tol"))
-    [retval,U] = is_controllable (a', c', tol);
+  if (exist ("tol"))
+    [retval, U] = is_controllable (a', c', tol);
   else
-    [retval,U] = is_controllable (a', c');
+    [retval, U] = is_controllable (a', c');
   endif
 
 endfunction
 
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -41,84 +41,86 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function retval = is_stabilizable (a, b, tol, dflg)
 
-  if(nargin < 1)        
+  if (nargin < 1)        
     print_usage ();
-  elseif(isstruct(a))
+  elseif (isstruct (a))
     ## system passed.
-    if(nargin == 2)
+    if (nargin == 2)
       tol = b;          % get tolerance
-    elseif(nargin > 2)
+    elseif (nargin > 2)
       print_usage ();
     endif
     disc = is_digital(a);
-    [a,b] = sys2ss(a);
+    [a, b] = sys2ss (a);
   else
     ## a,b arguments sent directly.
-    if ((nargin > 4)||(nargin == 1))
+    if (nargin > 4 || nargin == 1)
       print_usage ();
     endif
-    if(exist("dflg"))
+    if (exist ("dflg"))
       disc = dflg;
     else
       disc = 0;
     end
   endif
 
-  if(~exist("tol"))
+  if (! exist ("tol"))
     tol = 200*eps;
-  end    
+  endif
 
 
   ## Checking dimensions
-  n = is_square(a);
-  if (n==0)
-    error("is_stabilizable: a must be square");
-  end
-  [nr,m] = size(b);
-  if (nr!=n)
-    error("is_stabilizable:  (a,b) not conformal");
-  end
+  n = is_square (a);
+  if (n == 0)
+    error ("is_stabilizable: a must be square");
+  endif
+  [nr, m] = size (b);
+  if (nr != n)
+    error ("is_stabilizable:  (a,b) not conformal");
+  endif
   
   ##Computing the eigenvalue of A
-  L = eig(a);
+  L = eig (a);
   retval = 1;
   specflag = 0;
-  for i=1:n
-    if (disc==0)
+  for i = 1:n
+    if (disc == 0)
       ## Continuous time case
-      rL = real(L(i));
-      if (rL>=0)
+      rL = real (L(i));
+      if (rL >= 0)
 	H = [eye(n)*L(i)-a, b];
-	f = (rank(H,tol)==n);
-	if (f==0)
+	f = (rank (H, tol) == n);
+	if (f == 0)
 	  retval = 0;
-	  if (rL==0)
+	  if (rL == 0)
 	    specflag = 1;
-	  end
-	end
-      end
+	  endif
+	endif
+      endif
     else
       ## Discrete time case
-      rL = abs(L(i));
-      if (rL>=1)
+      rL = abs (L(i));
+      if (rL >= 1)
 	H = [eye(n)*L(i)-a, b];
-	f = (rank(H,tol)==n);
-	if (f==0)
+	f = (rank (H, tol) == n);
+	if (f == 0)
 	  retval = 0;
-	  if (rL==1)
+	  if (rL == 1)
 	    specflag = 1;
-	  end
-	end
-      end
-    end
-  end
-  if (specflag==1)
+	  endif
+	endif
+      endif
+    endif
+  endfor
+  if (specflag == 1)
     ## This means that the system has uncontrollable modes at the imaginary axis 
     ## (or at the unit circle for discrete time systems)
     retval = -1;
-  end
+  endif
+
+endfunction
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -43,35 +43,44 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
-  if( (nargin < 1) | (nargin > 3) )   print_usage ();
-  elseif(isstruct(a))
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  elseif (isstruct (a))
     ## system was passed
-    if(nargin < 3)                      disc = is_digital(a);
-    elseif(disc != is_digital(a))
-      warning("is_stable: disc =%d does not match system",disc)
+    if (nargin < 3)
+      disc = is_digital(a);
+    elseif (disc != is_digital (a))
+      warning ("is_stable: disc =%d does not match system", disc)
     endif
-    sys = sysupdate(a,"ss");
-    a = sys2ss(sys);
+    sys = sysupdate (a, "ss");
+    a = sys2ss (sys);
   else
-    if(nargin < 3)              disc = 0;               endif
-    if(issquare(a) == 0)
-      error("A(%dx%d) must be square",rows(A), columns(A));
+    if (nargin < 3)
+      disc = 0;
+    endif
+    if (issquare (a) == 0)
+      error ("A(%dx%d) must be square", rows (A), columns (A));
     endif
   endif
 
-  if(nargin < 2)                tol = 200*eps;
-  elseif( !isscalar(tol) )
-    error("is_stable: tol(%dx%d) must be a scalar",rows(tol),columns(tol));
+  if (nargin < 2)
+    tol = 200*eps;
+  elseif (! isscalar (tol))
+    error ("is_stable: tol(%dx%d) must be a scalar", rows (tol),
+	   columns (tol));
   endif
 
-  l = eig(a);
-  if(disc)      nbad = sum(abs(l)*(1+tol) > 1);
-  else          nbad = sum(real(l)+tol > 0);            endif
+  l = eig (a);
+  if (disc)
+    nbad = sum (abs(l)*(1+tol) > 1);
+  else
+    nbad = sum (real(l)+tol > 0);
+  endif
   retval = (nbad == 0);
 
 endfunction
diff --git a/scripts/control/system/jet707.m b/scripts/control/system/jet707.m
--- a/scripts/control/system/jet707.m
+++ b/scripts/control/system/jet707.m
@@ -28,41 +28,44 @@
 ## @ifinfo
 ## (@var{M} = 0.26, @var{Ga0} = -3 deg, @var{alpha0} = 4 deg, @var{kappa} = 50 deg).
 ## @end ifinfo
 ##
 ## System inputs: (1) thrust and (2) elevator angle.
 ##
 ## System outputs:  (1) airspeed and (2) pitch angle.
 ##
-## @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight Control), Springer, 1994.
+## @strong{Reference}: R. Brockhaus: @cite{Flugregelung} (Flight
+## Control), Springer, 1994.
 ## @seealso{ord2}
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = jet707 ()
 
   if (nargin != 0)
     print_usage ();
   endif
-  if (nargin > 1)
-    print_usage ();
-  endif
+
+  a = [-0.46E-01,            0.10681415316, 0.0,   -0.17121680433;
+       -0.1675901504661613, -0.515,         1.0,    0.6420630320636088E-02;
+        0.1543104215347786, -0.547945,     -0.906, -0.1521689385990753E-02;
+        0.0,                 0.0,           1.0,    0.0];
+
+  b = [0.1602300107479095,      0.2111848453E-02;
+       0.8196877780963616E-02, -0.3025E-01;
+       0.9173594317692437E-01, -0.75283075;
+       0.0,                     0.0];
 
-  a = [ -0.46E-01,            0.10681415316, 0.0,   -0.17121680433;
-        -0.1675901504661613, -0.515,         1.0,    0.6420630320636088E-02;
-         0.1543104215347786, -0.547945,     -0.906, -0.1521689385990753E-02;
-         0.0,                 0.0,           1.0,    0.0 ];
-  b = [ 0.1602300107479095,      0.2111848453E-02;
-        0.8196877780963616E-02, -0.3025E-01;
-        0.9173594317692437E-01, -0.75283075;
-        0.0,                     0.0 ];
-  c = [ 1.0,  0.0,  0.0,  0.0;
-        0.0,  0.0,  0.0,  1.0 ];
-  d=zeros(2,2);
-  inam = ["thrust"; "rudder"];
-  onam = ["speed"; "pitch"];
-  snam = ["x1"; "x2"; "x3"; "x4"];
-  outsys = ss(a, b, c, d, 0.0, 4, 0, snam, inam, onam);
+  c = [1.0, 0.0, 0.0, 0.0;
+       0.0, 0.0, 0.0, 1.0];
+
+  d = zeros(2,2);
+
+  inam = {"thrust"; "rudder"};
+  onam = {"speed"; "pitch"};
+  snam = {"x1"; "x2"; "x3"; "x4"};
+
+  outsys = ss (a, b, c, d, 0.0, 4, 0, snam, inam, onam);
 
 endfunction
diff --git a/scripts/control/system/listidx.m b/scripts/control/system/listidx.m
--- a/scripts/control/system/listidx.m
+++ b/scripts/control/system/listidx.m
@@ -29,71 +29,74 @@
 ## The first output is the vector of indices in @var{listvar}.
 ##
 ## If @var{strlist} contains a string not in @var{listvar}, then
 ## an error message is returned in @var{errmsg}.  If only one output
 ## argument is requested, then @var{listidx} prints @var{errmsg} to the
 ## screen and exits with an error.
 ## @end deftypefn
 
-function [idxvec,errmsg]  = listidx(listvar,strlist)
-  error("listidx: don't use this anymore, ok?\n");
+function [idxvec, errmsg]  = listidx (listvar, strlist)
+
+  error ("listidx: don't use this anymore, ok?");
 
-if(nargin != 2)
-  print_usage ();
-endif
+  if (nargin != 2)
+    print_usage ();
+  endif
 
-if(ischar(strlist))
-  tmp = strlist;
-  strlist = list();
-  for kk=1:rows(tmp)
-    strlist(kk) = deblank(tmp(kk,:));
-  endfor
-endif
+  if (ischar (strlist))
+    tmp = strlist;
+    strlist = list();
+    for kk = 1:rows(tmp)
+      strlist(kk) = deblank (tmp(kk,:));
+    endfor
+  endif
 
-if(ischar(listvar))
-  tmp = listvar;
-  listvar = list();
-  for kk=1:rows(tmp)
-    listvar(kk) = deblank(tmp(kk,:));
-  endfor
-endif
+  if (ischar (listvar))
+    tmp = listvar;
+    listvar = list();
+    for kk = 1:rows(tmp)
+      listvar(kk) = deblank (tmp(kk,:));
+    endfor
+  endif
+
+  ## initialize size of idxvec (for premature return)
+  idxvec = zeros (length(strlist), 1);
 
-## initialize size of idxvec (for premature return)
-idxvec = zeros(length(strlist),1);
+  errmsg = "";
+  if (! is_signal_list (listvar))
+    errmsg = "listvar must be a list of strings";
+  elseif (! is_signal_list(strlist))
+    errmsg = "strlist must be a list of strings";
+  endif
 
-errmsg = "";
-if(!is_signal_list(listvar))
-  errmsg = "listvar must be a list of strings";
-elseif(!is_signal_list(strlist))
-  errmsg = "strlist must be a list of strings";
-endif
+  if (length (errmsg))
+    if (nargout < 2)
+      error(errmsg);
+    else
+      return;
+    endif
+  endif
 
-if(length(errmsg))
-  if(nargout < 2) error(errmsg);
-  else return;
-  endif
-endif
-
-nsigs = length(listvar);
-for idx = 1:length(strlist)
-  signame = strlist{idx};
-  for jdx = 1:nsigs
-    if( strcmp(signame,listvar{jdx}) )
-      if(idxvec(idx) != 0)
-        warning("Duplicate signal name %s (%d,%d)\n", ...
-          listvar{jdx},jdx,idxvec(idx));
+  nsigs = length (listvar);
+  for idx = 1:length(strlist)
+    signame = strlist{idx};
+    for jdx = 1:nsigs
+      if (strcmp (signame, listvar{jdx}))
+	if (idxvec(idx) != 0)
+	  warning ("Duplicate signal name %s (%d,%d)\n",
+		   listvar{jdx}, jdx, idxvec(idx));
+	else
+	  idxvec(idx) = jdx;
+	endif
+      endif
+    endfor
+    if (idxvec (idx) == 0)
+      errmsg = sprintf ("Did not find %s", signame);
+      if (nargout == 1)
+	error (errmsg);
       else
-        idxvec(idx) = jdx;
+	break;
       endif
     endif
   endfor
-  if(idxvec(idx) == 0)
-    errmsg = sprintf("Did not find %s",signame);
-    if(nargout == 1)
-      error(errmsg);
-    else
-      break
-    end
-  endif
-endfor
 
 endfunction
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -41,33 +41,33 @@
 ## completely rewritten Oct 1996 a s hodel
 ## SYS_INTERNAL accesses members of system structure
 
 function sysp = parallel (Asys, Bsys)
 
   if(nargin != 2)
     print_usage ();
   endif
-  if(! isstruct(Asys) )
-    error("1st input argument is not a system data structure")
+  if (! isstruct(Asys) )
+    error ("1st input argument is not a system data structure");
   elseif (! isstruct(Bsys) )
-    error("2nd input argument is not a system data structure")
+    error ("2nd input argument is not a system data structure");
   endif
-  [Ann,Anz,mA] = sysdimensions(Asys);
-  [Bnn,Bnz,mB] = sysdimensions(Bsys);
-  if(mA != mB)
-    error(["Asys has ",num2str(mA)," inputs, Bsys has ",num2str(mB)," inputs"]);
+  [Ann, Anz, mA] = sysdimensions(Asys);
+  [Bnn, Bnz, mB] = sysdimensions(Bsys);
+  if (mA != mB)
+    error ("Asys has %d inputs, Bsys has %d inputs", mA, mB);
   endif
 
   ## save signal names
-  Ain = sysgetsignals(Asys,"in");
+  Ain = sysgetsignals (Asys, "in");
 
   ## change signal names to avoid warning messages from sysgroup
-  Asys = syssetsignals(Asys,"in",__sysdefioname__(length(Ain),"Ain_u"));
-  Bsys = syssetsignals(Bsys,"in",__sysdefioname__(length(Ain),"Bin_u"));
+  Asys = syssetsignals (Asys, "in", __sysdefioname__ (length (Ain), "Ain_u"));
+  Bsys = syssetsignals (Bsys, "in", __sysdefioname__ (length (Ain), "Bin_u"));
 
-  sysp = sysgroup(Asys,Bsys);
-  sysD = ss([],[],[],[eye(mA);eye(mA)]);
+  sysp = sysgroup (Asys, Bsys);
+  sysD = ss ([], [], [], [eye(mA); eye(mA)]);
 
-  sysp = sysmult(sysp,sysD);
-  sysp = syssetsignals(sysp,"in",Ain);
+  sysp = sysmult (sysp, sysD);
+  sysp = syssetsignals (sysp, "in", Ain);
 
 endfunction
diff --git a/scripts/control/system/ss2zp.m b/scripts/control/system/ss2zp.m
--- a/scripts/control/system/ss2zp.m
+++ b/scripts/control/system/ss2zp.m
@@ -27,30 +27,30 @@
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Hodel: changed order of output arguments to zer, pol, k. July 1996
 ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
 function [zer, pol, k] = ss2zp (a, b, c, d)
 
-  if(nargin != 4)
+  if (nargin != 4)
     print_usage ();
   endif
 
-  [n,m,p] = abcddim(a,b,c,d);
+  [n, m, p] = abcddim (a, b, c, d);
   if (n == -1)
-    error("ss2tf: Non compatible matrix arguments");
-  elseif ( (m != 1) | (p != 1))
-    error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
+    error ("ss2tf: Non compatible matrix arguments");
+  elseif (m != 1 || p != 1)
+    error ("ss2tf: not SISO system: m=%d p=%d", m, p);
   endif
 
-  if(n == 0)
+  if (n == 0)
     ## gain block only
     k = d;
     zer = pol = [];
   else
     ## First, get the denominator coefficients
-    [zer,k] = tzero(a,b,c,d);
-    pol = eig(a);
+    [zer, k] = tzero (a, b, c, d);
+    pol = eig (a);
   endif
+
 endfunction
-
diff --git a/scripts/control/system/starp.m b/scripts/control/system/starp.m
--- a/scripts/control/system/starp.m
+++ b/scripts/control/system/starp.m
@@ -48,78 +48,86 @@
 ## @var{ny} and/or @var{nu} may be negative (i.e. negative feedback).
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: May 1998
 
 function sys = starp (P, K, ny, nu);
 
-  if((nargin != 2) && (nargin != 4))
+  if (nargin != 2 && nargin != 4)
     print_usage ();
   endif
-  if (!isstruct(P))
-    error("---> P must be in system data structure");
+  if (! isstruct (P))
+    error ("---> P must be in system data structure");
   endif
-  if (!isstruct(K))
-    error("---> K must be in system data structure");
+  if (! isstruct (K))
+    error ("---> K must be in system data structure");
   endif
 
-  P = sysupdate(P, "ss");
-  [n, nz, mp, pp] = sysdimensions(P);
+  P = sysupdate (P, "ss");
+  [n, nz, mp, pp] = sysdimensions (P);
   np = n + nz;
-  K = sysupdate(K, "ss");
-  [n, nz, mk, pk] = sysdimensions(K);
+  K = sysupdate (K, "ss");
+  [n, nz, mk, pk] = sysdimensions (K);
   nk = n + nz;
   ny_sign = 1;
   nu_sign = 1;
   if (nargin == 2)
     ## perform a LFT of P and K (upper or lower)
-    ny = min([pp, mk]);
-    nu = min([pk, mp]);
+    ny = min ([pp, mk]);
+    nu = min ([pk, mp]);
   else
     if (ny < 0)
       ny = -ny;
       ny_sign = -1;
     endif
     if (nu < 0)
       nu = -nu;
       nu_sign = -1;
     endif
   endif
   if (ny > pp)
-    error("---> P has not enough outputs.");
+    error ("---> P has not enough outputs.");
   endif
   if (nu > mp)
-    error("---> P has not enough inputs.");
+    error ("---> P has not enough inputs.");
   endif
   if (ny > mk)
-    error("---> K has not enough inputs.");
+    error ("---> K has not enough inputs.");
   endif
   if (nu > pk)
-    error("---> K has not enough outputs.");
+    error ("---> K has not enough outputs.");
   endif
   nwp  = mp - nu;
   nzp  = pp - ny;
   nwk  = mk - ny;
   nzk  = pk - nu;
-  if ((nwp + nwk) < 1)
-    error("---> no inputs left for star product.");
+  if (nwp + nwk < 1)
+    error ("---> no inputs left for star product.");
   endif
-  if ((nzp + nzk) < 1)
-    error("---> no outputs left for star product.");
+  if (nzp + nzk < 1)
+    error ("---> no outputs left for star product.");
   endif
 
   ## checks done, form sys
-  if (nzp)  Olst = [1:nzp];  endif
-  if (nzk)  Olst = [Olst, pp+nu+1:pp+pk];  endif
-  if (nwp)  Ilst = [1:nwp];  endif
-  if (nwk)  Ilst = [Ilst, mp+ny+1:mp+mk];  endif
-  Clst = zeros(ny+nu,2);
+  if (nzp)
+    Olst = 1:nzp;
+  endif
+  if (nzk)
+    Olst = [Olst, pp+nu+1:pp+pk];
+  endif
+  if (nwp)
+    Ilst = 1:nwp;
+  endif
+  if (nwk)
+    Ilst = [Ilst, mp+ny+1:mp+mk];
+  endif
+  Clst = zeros (ny+nu, 2);
   for ii = 1:nu
     Clst(ii,:) = [nwp+ii, nu_sign*(pp+ii)];
   endfor
   for ii = 1:ny
     Clst(nu+ii,:) = [mp+ii, ny_sign*(nzp+ii)];
   endfor
-  sys = buildssic(Clst,[],Olst,Ilst,P,K);
+  sys = buildssic (Clst, [], Olst, Ilst, P, K);
 
 endfunction
diff --git a/scripts/control/system/sys2ss.m b/scripts/control/system/sys2ss.m
--- a/scripts/control/system/sys2ss.m
+++ b/scripts/control/system/sys2ss.m
@@ -77,29 +77,29 @@
 ## Updates by John Ingram July 14, 1996
 
 function [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if( ! isstruct(sys) )
-    error("input argument must be a system data structure");
+  if (! isstruct (sys))
+    error ("input argument must be a system data structure");
   endif
 
-  sys = sysupdate(sys,"ss");        # make sure state space data is there
-  [n,nz,m,p] = sysdimensions(sys);
-  [stname,inname,outname,yd] = sysgetsignals(sys);
-  tsam = sysgettsam(sys);
+  sys = sysupdate (sys, "ss");        # make sure state space data is there
+  [n, nz, m, p] = sysdimensions (sys);
+  [stname, inname, outname, yd] = sysgetsignals (sys);
+  tsam = sysgettsam (sys);
 
-  cont = sum(yd == 0) + n;
-  dig = sum(yd != 0) + nz + tsam;
-  if(cont*dig)
-    warning("sys2ss: input system is mixed continuous/discrete");
+  cont = sum (yd == 0) + n;
+  dig = sum (yd != 0) + nz + tsam;
+  if (cont*dig)
+    warning ("sys2ss: input system is mixed continuous/discrete");
   endif
 
   a = sys.a;
   b = sys.b;
   c = sys.c;
   d = sys.d;
 
 endfunction
diff --git a/scripts/control/system/sys2tf.m b/scripts/control/system/sys2tf.m
--- a/scripts/control/system/sys2tf.m
+++ b/scripts/control/system/sys2tf.m
@@ -34,31 +34,30 @@
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
 ## modified to make sys2tf by A. S. Hodel Aug 1995
 ## modified again for updated system format by John Ingram July 1996
 
 function [num, den, tsam, inname, outname] = sys2tf (Asys)
 
-  if(nargin != 1)
+  if (nargin != 1)
     print_usage ();
   endif
 
-  if( !isstruct(Asys))
-    error("Asys must be a system data structure (see ss, tf, zp)");
-  elseif (! is_siso(Asys) )
-    [n, nz, m, p] = sysdimensions(Asys);
-    error(["system is not SISO (",num2str(m)," inputs, ...
-        ", num2str(p)," outputs"]);
+  if (! isstruct (Asys))
+    error ("Asys must be a system data structure (see ss, tf, zp)");
+  elseif (! is_siso (Asys))
+    [n, nz, m, p] = sysdimensions (Asys);
+    error ("system is not SISO: %d inputs, %d outputs", m, p);
   endif
 
-  Asys = sysupdate(Asys,"tf");          # just in case
+  Asys = sysupdate (Asys, "tf");          # just in case
 
   num = Asys.num;
   den = Asys.den;
 
-  tsam = sysgettsam(Asys);
-  inname = sysgetsignals(Asys,"in");
-  outname = sysgetsignals(Asys,"out");
+  tsam = sysgettsam (Asys);
+  inname = sysgetsignals (Asys, "in");
+  outname = sysgetsignals (Asys, "out");
 
 endfunction
 
diff --git a/scripts/control/system/sys2zp.m b/scripts/control/system/sys2zp.m
--- a/scripts/control/system/sys2zp.m
+++ b/scripts/control/system/sys2zp.m
@@ -36,31 +36,30 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 15, 1996
 
 function [zer, pol, k, tsam, inname, outname] = sys2zp (sys)
 
-  if(nargin != 1)
+  if (nargin != 1)
     print_usage ();
-  elseif( !isstruct(sys))
-    error("sysconnect: sys must be in system data structure form")
-  elseif (! is_siso(sys) )
-    [n, nz, m, p] = sysdimensions(sys);
-    error(["system is not SISO (",num2str(m)," inputs, ...
-        ", num2str(p)," outputs"]);
+  elseif (! isstruct (sys))
+    error ("sysconnect: sys must be in system data structure form")
+  elseif (! is_siso (sys))
+    [n, nz, m, p] = sysdimensions (sys);
+    error ("system is not SISO: %d inputs, %d outputs", m, p);
   endif
 
   ## update zero-pole form
-  sys = sysupdate(sys,"zp");
+  sys = sysupdate (sys, "zp");
 
   zer = sys.zer;
   pol = sys.pol;
   k = sys.k;
-  tsam    = sysgettsam(sys);
-  inname  = sysgetsignals(sys,"in");
-  outname = sysgetsignals(sys,"out");
+  tsam    = sysgettsam (sys);
+  inname  = sysgetsignals (sys, "in");
+  outname = sysgetsignals (sys, "out");
 
 endfunction
 
 
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -42,46 +42,46 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function [csys, Acd, Ccd] = syscont (sys)
 
   if (nargin != 1)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be in system data structure form");
+  elseif (! isstruct (sys))
+    error ("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
-  if(isempty(st_c) & isempty(y_c))
-    error("syscont: expecting continuous states and/or continuous outputs");
-  elseif (isempty(st_c))
-    warning("syscont: no continuous states");
-  elseif(isempty(y_c))
-    warning("syscont: no continuous outputs");
+  if (isempty (st_c) && isempty (y_c))
+    error ("syscont: expecting continuous states and/or continuous outputs");
+  elseif (isempty (st_c))
+    warning ("syscont: no continuous states");
+  elseif (isempty (y_c))
+    warning ("syscont: no continuous outputs");
   endif
 
-  [sys_a, sys_b, sys_c, sys_d ] = sys2ss(sys);
-  [sys_stname, sys_inname, sys_outname] = sysgetsignals(sys);
-  [sys_n, sys_nz, sys_m, sys_p] = sysdimensions(sys);
-  if(!isempty(st_c))
+  [sys_a, sys_b, sys_c, sys_d ] = sys2ss (sys);
+  [sys_stname, sys_inname, sys_outname] = sysgetsignals (sys);
+  [sys_n, sys_nz, sys_m, sys_p] = sysdimensions (sys);
+  if (! isempty (st_c))
     Acc = sys_a(st_c,st_c);
     stname = sys_stname(st_c);
     Bcc = sys_b(st_c,:);
     Ccc = sys_c(y_c,st_c);
     Acd = sys_a(st_c,st_d);
   else
-    stname=[];
+    stname = [];
   endif
   outname = sys_outname(y_c);
   Dcc = sys_d(y_c,:);
   Ccd = sys_c(y_c,st_d);
   inname = sys_inname;
 
-  csys = ss(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
+  csys = ss (Acc, Bcc, Ccc, Dcc, 0, sys_n, 0, stname, inname, outname);
 
 endfunction
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -73,29 +73,29 @@ function [n, nz, m, p, yd] = sysdimensio
   elseif (! isstruct (sys))
     error ("sysdimensions: expecting system structure as first argument");
   elseif (nargin == 1)
     opt = "all";
   endif
 
   n = sys.n;
   nz = sys.nz;
-  m = length(sysgetsignals(sys,"in"));
-  p = length(sysgetsignals(sys,"out"));
+  m = length (sysgetsignals (sys, "in"));
+  p = length (sysgetsignals (sys, "out"));
   yd = sys.yd;
-  valid_options = {"all","cst","dst","st","in","out"};
+  valid_options = {"all", "cst", "dst", "st", "in", "out"};
   valid_values = {n,n,nz,n+nz,m,p};
 
   valid_opt = 0;
-  for ii=1:length(valid_options)
-    if(strcmp(valid_options{ii},opt))
+  for ii = 1:length(valid_options)
+    if (strcmp(valid_options{ii}, opt))
       n = valid_values{ii};
       valid_opt = 1;
-      if(ii > 1 & nargout > 1)
-        warning("opt=%s, %d output arguments requested",opt,nargout);
+      if (ii > 1 && nargout > 1)
+        warning ("opt=%s, %d output arguments requested", opt, nargout);
       endif
     endif
   endfor
 
   if (! valid_opt)
     error ("invalid option passed = %s", opt);
   endif
 
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -37,61 +37,62 @@
 ## outputs, respectively.
 ## @end table
 ## @end deftypefn
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   if (nargin != 1)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be in system data structure form");
+  elseif (! isstruct (sys))
+    error ("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
 
-  if(isempty(st_d) & isempty(y_d))
-    error("sysdisc: expecting discrete states and/or continuous outputs");
-  elseif (isempty(st_d))
-    warning("sysdisc: no discrete states");
-  elseif(isempty(y_d))
-    warning("sysdisc: no discrete outputs");
+  if (isempty (st_d) && isempty (y_d))
+    error ("sysdisc: expecting discrete states and/or continuous outputs");
+  elseif (isempty (st_d))
+    warning ("sysdisc: no discrete states");
+  elseif (isempty (y_d))
+    warning ("sysdisc: no discrete outputs");
   endif
 
-  [aa,bb,cc,dd] = sys2ss(sys);
-  if(!isempty(st_d) )
-    Add = aa( st_d , st_d);
-    stname = sysgetsignals(sys,"st",st_d);
-    Bdd = bb( st_d , :);
-    if(!isempty(st_c))
-	Adc = aa( st_d , st_c);
+  [aa, bb, cc, dd] = sys2ss (sys);
+  if (! isempty(st_d))
+    Add = aa(st_d,st_d);
+    stname = sysgetsignals (sys, "st", st_d);
+    Bdd = bb(st_d,:);
+    if (! isempty (st_c))
+      Adc = aa(st_d,st_c);
     endif
-    if(!isempty(y_d))
-	Cdd = cc(y_d , st_d);
+    if (! isempty (y_d))
+	Cdd = cc(y_d,st_d);
     endif
   else
     stname = [];
   endif
-  if(!isempty(y_d))
+  if (! isempty (y_d))
     Ddd = dd(y_d , :);
-    outname = sysgetsignals(sys,"out",y_d);
-    if(!isempty(st_c))
-	Cdc = cc(y_d , st_c);
+    outname = sysgetsignals (sys, "out", y_d);
+    if (! isempty (st_c))
+	Cdc = cc(y_d,st_c);
     endif
   else
-    outname=[];
+    outname = [];
   endif
-  inname = sysgetsignals(sys,"in");
+  inname = sysgetsignals (sys, "in");
   outlist = 1:rows(outname);
 
-  if(!isempty(outname))
-    tsam = sysgettsam(sys);
-    [nc,nz] = sysdimensions(sys);
-    dsys = ss(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
+  if (! isempty (outname))
+    tsam = sysgettsam (sys);
+    [nc, nz] = sysdimensions (sys);
+    dsys = ss (Add, Bdd, Cdd, Ddd, tsam, 0, nz, stname, inname,
+	       outname, outlist);
   else
-    dsys=[];
+    dsys = [];
   endif
 
 endfunction
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -34,82 +34,88 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable number of arguments by A. S. Hodel July 1999
 
 function sys = sysmult (varargin)
 
-  if(nargin < 1)
+  if (nargin < 1)
     print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
-  for kk=1:nargin
+  for kk = 1:nargin
     arglist{kk} = varargin{kk};
-    if(!isstruct(arglist{kk}))
-      error("sysadd: argument %d is not a data structure",kk);
+    if (! isstruct (arglist{kk}))
+      error ("sysadd: argument %d is not a data structure", kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
-  for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
+  [n, nz, mg, pg, Gyd] = sysdimensions (arglist{1});
+  for kk = 2:nargin
+    [n, nz, mh, ph, Hyd] = sysdimensions (arglist{kk});
     if(ph != mg)
-      error("arg %d has %d outputs; arg %d has %d inputs",kk,ph,kk-1,mg);
+      error ("arg %d has %d outputs; arg %d has %d inputs", kk, ph, kk-1, mg);
     endif
-    [n,nz,mg,pg,Gyd] = sysdimensions(arglist{kk});   # for next iteration
+    [n, nz, mg, pg, Gyd] = sysdimensions (arglist{kk});   # for next iteration
   endfor
 
   ## perform the multiply
-  if(nargin == 2)
+  if (nargin == 2)
     Asys = arglist{1};
     Bsys = arglist{2};
 
-    [An,Anz,Am,Ap] = sysdimensions(Asys);
-    [Bn,Bnz,Bm,Bp] = sysdimensions(Bsys);
+    [An, Anz, Am, Ap] = sysdimensions (Asys);
+    [Bn, Bnz, Bm, Bp] = sysdimensions (Bsys);
 
-    [Aa,Ab,Ac,Ad,Atsam,An,Anz,Astname,Ainname,Aoutname,Ayd] = sys2ss(Asys);
-    [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bstname,Binname,Boutname,Byd] = sys2ss(Bsys);
+    [Aa, Ab, Ac, Ad, Atsam, An, Anz, ...
+     Astname, Ainname, Aoutname, Ayd] = sys2ss(Asys);
 
-    if(Byd)
+    [Ba, Bb, Bc, Bd, Btsam, Bn, Bnz, ...
+     Bstname, Binname, Boutname, Byd] = sys2ss(Bsys);
+
+    if (Byd)
       ## check direct feed-through of inputs through discrete outputs
-      alist = find(Byd);
-      if(An)
-        bd = Ab(1:An)* Bd(alist,:);
-        if(norm(bd,1))
-          warning("sysmult: inputs -> Bsys discrete outputs -> continuous states of Asys");
+      alist = find (Byd);
+      if (An)
+        bd = Ab(1:An) * Bd(alist,:);
+        if (norm (bd, 1))
+          warning ("sysmult: inputs -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
       ## check direct feed-through of continuous state through discrete outputs
-      if(Bn)
-        bc = Ab(1:An)* Bc(alist,1:(Bn));
-        if( norm(bc,1) )
-          warning("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
+      if (Bn)
+        bc = Ab(1:An) * Bc(alist,1:(Bn));
+        if (norm (bc, 1))
+          warning ("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
     endif
 
     ## change signal names to avoid spurious warnings from sysgroup
-    Asys = syssetsignals(Asys,"in",__sysdefioname__(Am,"A_sysmult_tmp_name"));
-    Bsys = syssetsignals(Bsys,"out",__sysdefioname__(Bp,"B_sysmult_tmp_name"));
+    Asys = syssetsignals (Asys, "in",
+			  __sysdefioname__ (Am, "A_sysmult_tmp_name"));
 
-    sys = sysgroup(Asys,Bsys);
+    Bsys = syssetsignals (Bsys, "out",
+			  __sysdefioname__ (Bp, "B_sysmult_tmp_name"));
+
+    sys = sysgroup (Asys, Bsys);
 
     ## connect outputs of B to inputs of A
-    sys = sysconnect(sys,Ap+(1:Bp),1:Am);
+    sys = sysconnect (sys, Ap+(1:Bp), 1:Am);
 
     ## now keep only  outputs of A and inputs of B
-    sys = sysprune(sys,1:Ap,Am+(1:Bm));
+    sys = sysprune (sys, 1:Ap, Am+(1:Bm));
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = arglist{1};
-    for kk=2:length(arglist)
-      sys = sysmult(sys,arglist{kk});
+    for kk = 2:length(arglist)
+      sys = sysmult (sys, arglist{kk});
     endfor
   endif
 
 endfunction
 
diff --git a/scripts/control/system/sysreorder.m b/scripts/control/system/sysreorder.m
--- a/scripts/control/system/sysreorder.m
+++ b/scripts/control/system/sysreorder.m
@@ -48,24 +48,24 @@ function pv = sysreorder (vlen, list)
     print_usage ();
   endif
 
   ## disp('sysreorder: entry')
 
   pv = 1:vlen;
   ## make it a row vector
   list = reshape(list,1,length(list));
-  A = pv'*ones(size(list));
-  B = ones(size(pv'))*list;
+  A = pv' * ones (size (list));
+  B = ones (size (pv')) * list;
   X = (A != B);
-  if(!isvector(X))
-    y = min(X');
+  if (! isvector (X))
+    y = min (X');
   else
    y = X';
   endif
-  z = find(y == 1);
-  if(!isempty(z))
+  z = find (y == 1);
+  if (! isempty (z))
     pv = [z, list];
   else
     pv = list;
   endif
 
 endfunction
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -42,78 +42,85 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
 
 function sys = syssub (varargin)
 
-  if(nargin < 1)
+  if (nargin < 1)
     print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
-  for kk=1:nargin
+  for kk = 1:nargin
     arglist{kk} = varargin{kk};
-    if(!isstruct(arglist{kk}))
-      error("syssub: argument %d is not a data structure",kk);
+    if (! isstruct (arglist{kk}))
+      error ("syssub: argument %d is not a data structure", kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
-  for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
-    if(mg != mh)
-      error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
-    elseif(pg != ph)
-      error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
-    elseif(norm(Gyd - Hyd))
-      warning("cannot add a discrete output to a continuous output");
-      error("Output type mismatch: arguments 1 and %d\n",kk);
+  [n, nz, mg, pg, Gyd] = sysdimensions (arglist{1});
+  for kk = 2:nargin
+    [n, nz, mh, ph, Hyd] = sysdimensions (arglist{kk});
+    if (mg != mh)
+      error ("arg 1 has %d inputs; arg %d has vs %d inputs", mg, kk, mh);
+    elseif (pg != ph)
+      error ("arg 1 has %d outputs; arg %d has vs %d outputs", pg, kk, ph);
+    elseif (norm (Gyd - Hyd))
+      warning ("cannot add a discrete output to a continuous output");
+      error ("Output type mismatch: arguments 1 and %d", kk);
     endif
   endfor
 
   ## perform the subtract
-  if(nargin == 2)
+  if (nargin == 2)
     Gsys = arglist{1};
     Hsys = arglist{2};
-    if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
+    if (strcmp (sysgettype (Gsys), "tf") || strcmp (sysgettype (Hsys), "tf"))
       ## see if subtracting  transfer functions with identical denominators
-      [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
-      [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
-      if(length(Hden) == length(Gden) )
-        if( (Hden == Gden) & (HT == GT) )
-          sys = tf(Gnum-Hnum,Gden,GT,Gin,Gout);
-          return
+      [Gnum, Gden, GT, Gin, Gout] = sys2tf (Gsys);
+      [Hnum, Hden, HT, Hin, Hout] = sys2tf (Hsys);
+      if (length (Hden) == length (Gden))
+        if ((Hden == Gden) & (HT == GT))
+          sys = tf (Gnum-Hnum, Gden, GT, Gin, Gout);
+          return;
         endif
         ## if not, we go on and do the usual thing...
       endif
     endif
 
     ## make sure in ss form
-    Gsys = sysupdate(Gsys,"ss");
-    Hsys = sysupdate(Hsys,"ss");
+    Gsys = sysupdate (Gsys, "ss");
+    Hsys = sysupdate (Hsys, "ss");
 
     ## change signal names to avoid warning messages from sysgroup
-    Gsys = syssetsignals(Gsys,"in",__sysdefioname__(length(Gin),"Gin_u"));
-    Gsys = syssetsignals(Gsys,"out",__sysdefioname__(length(Gout),"Gout_u"));
-    Hsys = syssetsignals(Hsys,"in",__sysdefioname__(length(Hin),"Hin_u"));
-    Hsys = syssetsignals(Hsys,"out",__sysdefioname__(length(Hout),"Hout_u"));
+    Gsys = syssetsignals (Gsys, "in",
+			  __sysdefioname__(length(Gin), "Gin_u"));
+
+    Gsys = syssetsignals (Gsys, "out",
+			  __sysdefioname__(length(Gout), "Gout_u"));
 
-    sys = sysgroup(Gsys,Hsys);
+    Hsys = syssetsignals (Hsys, "in",
+			  __sysdefioname__(length(Hin), "Hin_u"));
 
-    eyin = eye(mg);
-    eyout = eye(pg);
+    Hsys = syssetsignals (Hsys, "out",
+			  __sysdefioname__(length(Hout), "Hout_u"));
+
+    sys = sysgroup (Gsys, Hsys);
+
+    eyin = eye (mg);
+    eyout = eye (pg);
 
     sys = sysscale (sys, [eyout, -eyout], [eyin; eyin], Gout, Gin);
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = arglist{1};
-    for kk=2:length(arglist)
-      sys = syssub(sys,arglist{kk});
+    for kk = 2:length(arglist)
+      sys = syssub (sys, arglist{kk});
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -54,73 +54,71 @@
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs
   if (nargin != 2)
     print_usage ();
-  elseif(! isstruct(sys) )
-   error("1st argument must be system data structure")
-  elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
-        strcmp(opt,"ss") + strcmp(opt,"all")) )
-    error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
+  elseif (! isstruct (sys))
+   error ("first argument must be system data structure");
+  elseif (! (strcmp (opt, "tf") || strcmp (opt, "zp")
+             || strcmp (opt, "ss") || strcmp (opt, "all")))
+    error ("second argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
   ## check to make sure not trying to make a SISO system out of a MIMO sys
-  if ( (strcmp(opt,"tf") + strcmp(opt,"zp") + strcmp(opt,"all")) ...
-        & strcmp(sysgettype(sys),"ss") &  (! is_siso(sys) ) )
-    error("MIMO -> SISO update requested");
+  if ((strcmp (opt, "tf") || strcmp(opt,"zp") || strcmp (opt, "all"))
+      && strcmp (sysgettype (sys), "ss") && ! is_siso (sys))
+    error ("MIMO -> SISO update requested");
   endif
 
   ## update transfer function if desired
-  if ( (strcmp(opt, "tf") + strcmp(opt,"all"))&&  (!sys.sys(2)))
+  if ((strcmp (opt, "tf") || strcmp (opt, "all")) && (! sys.sys(2)))
     ## check to make sure the system is not discrete and continuous
-    is_digital(sys);
+    is_digital (sys);
 
     ## if original system zero-pole
-    if strcmp(sysgettype(sys),"zp")
-      [sys.num,sys.den] = zp2tf(sys.zer,sys.pol,sys.k);
+    if (strcmp (sysgettype (sys), "zp"))
+      [sys.num, sys.den] = zp2tf (sys.zer, sys.pol, sys.k);
       sys.sys(2) = 1;
     ## if original system is state-space
-    elseif(sys.sys(1) == 2)
-      [sys.num,sys.den] = ss2tf(sys.a,sys.b,sys.c,sys.d);
+    elseif (sys.sys(1) == 2)
+      [sys.num, sys.den] = ss2tf (sys.a, sys.b, sys.c, sys.d);
       sys.sys(2) = 1;
     endif
   endif
 
 
   ## update zero-pole if desired
-  if ( (strcmp(opt, "zp") + strcmp(opt,"all")) && (! sys.sys(3)) )
+  if ((strcmp (opt, "zp") || strcmp (opt, "all")) && ! sys.sys(3))
     ## check to make sure the system is not discrete and continuous
-    is_digital(sys);
+    is_digital (sys);
 
     ## original system is transfer function
     if (sys.sys(1) == 0)
-      [sys.zer,sys.pol,sys.k] = tf2zp(sys.num,sys.den);
+      [sys.zer, sys.pol, sys.k] = tf2zp (sys.num, sys.den);
       sys.sys(3) = 1;
     ## original system is state-space
-
-    elseif(sys.sys(1) == 2)
-      [sys.zer,sys.pol,sys.k] = ss2zp(sys.a,sys.b,sys.c,sys.d);
+    elseif (sys.sys(1) == 2)
+      [sys.zer, sys.pol, sys.k] = ss2zp (sys.a, sys.b, sys.c, sys.d);
       sys.sys(3) = 1;
     endif
-
   endif
 
   ## update state-space if desired
-  if ( (strcmp(opt, "ss") + strcmp(opt,"all")) && (! sys.sys(4)) )
+  if ((strcmp (opt, "ss") || strcmp (opt, "all")) && ! sys.sys(4))
     ## original system is transfer function
     if (sys.sys(1) == 0)
-      [sys.a,sys.b,sys.c,sys.d] = tf2ss(sys.num,sys.den);
+      [sys.a, sys.b, sys.c, sys.d] = tf2ss (sys.num, sys.den);
       sys.sys(4) = 1;
     ## original system is zero-pole
-    elseif(sys.sys(1) == 1)
-      [sys.a,sys.b,sys.c,sys.d] = zp2ss(sys.zer,sys.pol,sys.k);
+    elseif (sys.sys(1) == 1)
+      [sys.a, sys.b, sys.c, sys.d] = zp2ss (sys.zer, sys.pol, sys.k);
       sys.sys(4) = 1;
     endif
 
     ## create new state names
     sys.stname = __sysdefstname__ (sys.n, sys.nz);
   endif
 
 endfunction
diff --git a/scripts/control/system/tf2ss.m b/scripts/control/system/tf2ss.m
--- a/scripts/control/system/tf2ss.m
+++ b/scripts/control/system/tf2ss.m
@@ -56,56 +56,80 @@
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 22, 1994
 ## mod A S Hodel July, Aug  1995
 
 function [a, b, c, d] = tf2ss (num, den)
 
-  if(nargin != 2)        error("tf2ss: wrong number of input arguments")
-  elseif(isempty(num))   error("tf2ss: empty numerator");
-  elseif(isempty(den))   error("tf2ss: empy denominator");
-  elseif(!isvector(num))
-    error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
-  elseif(!isvector(den))
-    error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
+  if (nargin != 2)
+    print_usage ();
+  elseif (isempty (num))
+    error ("tf2ss: empty numerator");
+  elseif (isempty (den))
+    error ("tf2ss: empy denominator");
+  elseif (! isvector (num))
+    error ("num(%dx%d) must be a vector", rows (num), columns (num));
+  elseif (! isvector (den))
+    error ("den(%dx%d) must be a vector", rows (den), columns (den));
   endif
 
   ## strip leading zeros from num, den
-  nz = find(num != 0);
-  if(isempty(nz)) num = 0;
-  else num = num(nz(1):length(num));         endif
-  nz = find(den != 0);
-  if(isempty(nz)) error("denominator is 0.");
-  else den = den(nz(1):length(den));         endif
+  nz = find (num != 0);
+  if (isempty (nz))
+    num = 0;
+  else
+    num = num(nz(1):length(num));
+  endif
+  nz = find (den != 0);
+  if (isempty (nz))
+    error ("denominator is 0.");
+  else
+    den = den(nz(1):length(den));
+  endif
 
   ## force num, den to be row vectors
-  num = vec(num)';        den = vec(den)';
-  nn = length(num);       nd = length(den);
-  if(nn > nd) error(sprintf("deg(num)=%d > deg(den)= %d",nn,nd)); endif
+  num = vec (num)';
+  den = vec (den)';
+  nn = length (num);
+  nd = length (den);
+  if (nn > nd)
+    error ("deg(num)=%d > deg(den)= %d", nn, nd));
+  endif
 
    ## Check sizes
-   if (nd == 1)      a = []; b = []; c = []; d = num(:,1) / den(1);
+   if (nd == 1)
+     a = b = c = [];
+     d = num(:,1) / den(1);
    else
     ## Pad num so that length(num) = length(den)
-    if (nd-nn > 0) num = [zeros(1,nd-nn), num]; endif
+    if (nd-nn > 0)
+      num = [zeros(1,nd-nn), num];
+    endif
 
     ## Normalize the numerator and denominator vector w.r.t. the leading
     ## coefficient
-    d1 = den(1);    num = num / d1;    den = den(2:nd)/d1;
+    d1 = den(1);
+    num = num / d1;
+    den = den(2:nd)/d1;
     sw = nd-1:-1:1;
 
     ## Form the A matrix
-    if(nd > 2)      a = [zeros(nd-2,1),eye(nd-2,nd-2);-den(sw)];
-    else            a = -den(sw);                                endif
+    if (nd > 2)
+      a = [zeros(nd-2,1), eye(nd-2,nd-2); -den(sw)];
+    else
+      a = -den(sw);
+    endif
 
     ## Form the B matrix
-    b = zeros(nd-1,1);           b(nd-1,1) = 1;
+    b = zeros (nd-1, 1);
+    b(nd-1,1) = 1;
 
     ## Form the C matrix
-    c = num(:,2:nd)-num(:,1)*den;        c = c(:,sw);
+    c = num(:,2:nd)-num(:,1)*den;
+    c = c(:,sw);
 
     ## Form the D matrix
     d = num(:,1);
   endif
 
 endfunction
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -59,12 +59,12 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## name changed to tf Feb 2004
 
 function outsys = tf2sys (varargin)
 
-  warning("tf2sys is deprecated.  Use tf() instead.");
-  outsys = tf(varargin{:});
+  warning ("tf2sys is deprecated.  Use tf instead.");
+  outsys = tf (varargin{:});
 
 endfunction
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -29,31 +29,31 @@
 ## Created: June 1995
 
 function tfout (num, denom, x)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  if ( (!isvector(num)) | (!isvector(denom)) )
-    error("tfout: first two argument must be vectors");
+  if (! isvector (num) || ! isvector (denom))
+    error ("tfout: first two argument must be vectors");
   endif
 
   if (nargin == 2)
     x = "s";
-  elseif( ! ischar(x) )
-    error("tfout: third argument must be a string");
+  elseif (! ischar (x))
+    error ("tfout: third argument must be a string");
   endif
 
-  numstring = polyout(num,x);
-  denomstring = polyout(denom,x);
-  len = max(length(numstring),length(denomstring));
-  if(len > 0)
-    y = strrep(blanks(len)," ","-");
-    disp(numstring)
-    disp(y)
-    disp(denomstring)
+  numstring = polyout (num, x);
+  denomstring = polyout (denom, x);
+  len = max (length (numstring), length (denomstring));
+  if (len > 0)
+    y = strrep (blanks (len), " ", "-");
+    disp (numstring)
+    disp (y)
+    disp (denomstring)
   else
     error ("tfout: empty transfer function")
   end
 
 endfunction
diff --git a/scripts/control/system/zp.m b/scripts/control/system/zp.m
--- a/scripts/control/system/zp.m
+++ b/scripts/control/system/zp.m
@@ -54,99 +54,99 @@
 ## @end example
 ## @end deftypefn
 
 ## Modified by John Ingram  July 20, 1996
 
 function outsys = zp (zer, pol, k, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
-  if ((nargin < 3) || (nargin > 6))
+  if (nargin < 3 || nargin > 6)
     print_usage ();
   endif
 
   ## check input format
-  if( ! (isvector(zer) | isempty(zer) ) )
-    error("zer must be a vector or empty");
+  if (! (isvector (zer) || isempty (zer)))
+    error ("zer must be a vector or empty");
   endif
-  if(!isempty(zer))
-    zer = reshape(zer,1,length(zer));           # make it a row vector
+  if (! isempty (zer))
+    zer = reshape (zer, 1, length (zer));           # make it a row vector
   endif
 
-  if( ! (isvector(pol) | isempty(pol)))
-    error("pol must be a vector");
+  if (! (isvector (pol) || isempty (pol)))
+    error ("pol must be a vector");
   endif
-  if(!isempty(pol))
-    pol = reshape(pol,1,length(pol));
+  if (! isempty (pol))
+    pol = reshape (pol, 1, length (pol));
   endif
 
-  if (! isscalar(k))
-     error("k must be a scalar");
+  if (! isscalar (k))
+    error ("k must be a scalar");
   endif
 
   ## Test proper numbers of poles and zeros.  The number of poles must be
   ## greater than or equal to the number of zeros.
-  if (length(zer) >  length(pol))
-    error(["number of poles (", num2str(length(pol)), ...
-        ") < number of zeros (", num2str(length(zer)),")"]);
+  if (length (zer) > length (pol))
+    error ("number of poles (%d) < number of zeros (%d)",
+	   length (pol), length (zer));
   endif
 
   ## Set the system transfer function
   outsys.zer = zer;
   outsys.pol = pol;
   outsys.k = k;
 
   ## Set the system vector:  active = 1, updated = [0 1 0];
   outsys.sys = [1, 0, 1, 0];
 
   ## Set defaults
   outsys.tsam = 0;
-  outsys.n = length(pol);
+  outsys.n = length (pol);
   outsys.nz = 0;
   outsys.yd = 0;        # assume (for now) continuous time outputs
 
   ## Set the type of system
   if (nargin > 3)
-    if( !isscalar(tsam) )
-      error("tsam must be a nonnegative scalar");
+    if (! isscalar (tsam))
+      error ("tsam must be a nonnegative scalar");
     endif
     if (tsam < 0)
-      error("sampling time must be positve")
+      error ("sampling time must be positve")
     elseif (tsam > 0)
-      [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
+      [outsys.n, outsys.nz] = swap (outsys.n, outsys.nz);
       outsys.yd = 1;            # discrete-time output
     endif
 
     outsys.tsam = tsam;
   endif
 
   outsys.inname = __sysdefioname__ (1, "u");
   outsys.outname = __sysdefioname__ (1, "y");
   outsys.stname = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 4)
     ## make sure its a string
-    if(!isempty(inname))
-      if(!iscell(inname))
+    if (! isempty (inname))
+      if (! iscell (inname))
         inname = {inname}; 
       endif
-      if(!is_signal_list(inname))
-        error("inname must be a single signal name");
+      if (! is_signal_list (inname))
+        error ("inname must be a single signal name");
       endif
       outsys.inname = inname(1);
     endif
   endif
 
   ## Set name of output
   if (nargin > 5)
-    if(!isempty(outname))
-      if(!iscell(outname))
+    if (! isempty (outname))
+      if (! iscell (outname))
         outname = {outname};
       endif
-      if(!is_signal_list(outname))
-        error("outname must be a single signal name");
+      if (! is_signal_list (outname))
+        error ("outname must be a single signal name");
       endif
       outsys.outname = outname(1);
     endif
   endif
 
 endfunction
diff --git a/scripts/control/system/zp2sys.m b/scripts/control/system/zp2sys.m
--- a/scripts/control/system/zp2sys.m
+++ b/scripts/control/system/zp2sys.m
@@ -56,12 +56,12 @@
 ## s (s + 2) (s + 2)
 ## @end example
 ## @end deftypefn
 
 ## Modified by John Ingram  July 20, 1996
 
 function outsys = zp2sys ( varargin )
 
-  warning("zp2sys is deprecated.  Use zp() instead.");
-  outsys = zp(varargin{:});
+  warning ("zp2sys is deprecated.  Use zp instead.");
+  outsys = zp (varargin{:});
 
 endfunction
diff --git a/scripts/control/system/zp2tf.m b/scripts/control/system/zp2tf.m
--- a/scripts/control/system/zp2tf.m
+++ b/scripts/control/system/zp2tf.m
@@ -44,30 +44,31 @@ function [num, den] = zp2tf (zer, pol, k
   ## Find out whether data was entered as a row or a column vector and
   ## convert to a column vector if necessary.
 
   [rp, cp] = size (pol);
   [rz, cz] = size (zer);
 
   if (! (isvector (zer) || isempty (zer)))
     error ("zer(%dx%d) must be a vector", rz, cz);
-  elseif(! (isvector (pol) || isempty (pol)))
+  elseif (! (isvector (pol) || isempty (pol)))
     error ("pol(%dx%d) must be a vector", rp, cp);
   elseif (length (zer) > length (pol))
     error ("zer(%dx%d) longer than pol(%dx%d)", rz, cz, rp, cp);
   endif
 
   ## initialize converted polynomials
 
-  num = k;  den = 1;
+  num = k;
+  den = 1;
 
   ## call __zp2ssg2__ if there are complex conjugate pairs left, otherwise
   ## construct real zeros one by one.  Repeat for poles.
 
-  while(! isempty (zer))
+  while (! isempty (zer))
     if (max (abs (imag (zer))))
       [poly, zer] = __zp2ssg2__ (zer);
     else
       poly = [1, -zer(1)];
       zer = zer(2:length(zer));
     endif
     num = conv (num, poly);
   endwhile
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -29,75 +29,77 @@
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
-  if( !(isvector(zer) | isempty(zer)) | !(isvector(pol) | isempty(pol)) )
-    error("zer, pol must be vectors or empty");
+  if (! (isvector (zer) || isempty (zer))
+      || ! (isvector (pol) || isempty(pol)))
+    error ("zer, pol must be vectors or empty");
   endif
 
-  if(!isscalar(k))
+  if (! isscalar(k))
     error("zpout: argument k must be a scalar.")
   endif
 
   if (nargin == 3)
     x = "s";
-  elseif( ! ischar(x) )
-    error("zpout: third argument must be a string");
+  elseif (! ischar (x))
+    error ("zpout: third argument must be a string");
   endif
 
-  numstring = num2str(k);
+  numstring = num2str (k);
 
-  if(length(zer))
+  if (length (zer))
     ## find roots at z,s = 0
-    nzr = sum(zer == 0);
-    if(nzr)
-	if(nzr > 1)
-	  numstring = [numstring,sprintf(" %s^%d",x,nzr)];
-	else
-	  numstring = [numstring,sprintf(" %s",x)];
-	endif
+    nzr = sum (zer == 0);
+    if (nzr)
+      if (nzr > 1)
+	numstring = sprintf ("%s %s^%d", numstring, x, nzr);
+      else
+	numstring = strcat (numstring, x);
+      endif
     endif
-    zer = sortcom(-zer);
-    for ii=1:length(zer)
-	if(zer(ii) != 0)
-	  numstring = [numstring,sprintf(" (%s %s)",x,com2str(zer(ii),1) ) ];
-	endif
+    zer = sortcom (-zer);
+    for ii = 1:length(zer)
+      if (zer(ii) != 0)
+	numstring = sprintf ("%s (%s %s)", numstring, x, com2str (zer(ii), 1));
+      endif
     endfor
   endif
 
-  if(length(pol))
+  if (length (pol))
     ## find roots at z,s = 0
-    nzr = sum(pol == 0);
-    if(nzr)
-	if(nzr > 1)
-	  denomstring = [sprintf("%s^%d",x,nzr)];
-	else
-	  denomstring = [sprintf("%s",x)];
-	endif
+    nzr = sum (pol == 0);
+    if (nzr)
+      if (nzr > 1)
+	denomstring = sprintf("%s^%d", x, nzr);
+      else
+	denomstring = sprintf ("%s", x);
+      endif
     else
-	denomstring = " ";
+      denomstring = " ";
     endif
-    pol = sortcom(-pol);
-    for ii=1:length(pol)
-	if(pol(ii) != 0)
-	  denomstring = [denomstring,sprintf(" (%s %s)",x,com2str(pol(ii),1))];
-	endif
+    pol = sortcom (-pol);
+    for ii = 1:length(pol)
+      if (pol(ii) != 0)
+	denomstring = sprintf ("%s (%s %s)", denomstring, x,
+			       com2str (pol(ii), 1));
+      endif
     endfor
   endif
 
-  len = max(length(numstring),length(denomstring));
+  len = max (length (numstring), length (denomstring));
   if(len > 0)
-    y = strrep(blanks(len)," ","-");
-    disp(numstring)
-    if(length(denomstring))
-	disp(y)
-	disp(denomstring)
+    y = strrep (blanks (len), " ", "-");
+    disp (numstring)
+    if (length (denomstring))
+	disp (y)
+	disp (denomstring)
     endif
   else
     error ("zpout: empty transfer function")
-  end
+  endif
 
 endfunction
