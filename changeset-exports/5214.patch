# HG changeset patch
# User jwe
# Date 1110993252 0
#      Wed Mar 16 17:14:12 2005 +0000
# Node ID eecc24b92d97776524dcfd741bc1c4a30fb7329d
# Parent  390f13fc0f4a4a4e291ae1e622cf8726998e23f8
[project @ 2005-03-16 17:14:12 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,23 @@
+2005-03-16  John W. Eaton  <jwe@octave.org>
+
+	* __axis_label__.m, __errplot__.m, __plt__.m, axis.m, bar.m,
+	bottom_title.m, contour.m, errorbar.m, figure.m, grid.m, loglog.m,
+	loglogerr.m, mesh.m, meshgrid.m, mplot.m, multiplot.m, oneplot.m,
+	plot.m, plot_border.m, polar.m, semilogx.m, semilogxerr.m,
+	semilogy.m, semilogyerr.m, shg.m, stairs.m, subplot.m,
+	subwindow.m, title.m, top_title.m, xlabel.m: Use __gplot__ instead
+	of gplot, __gsplot__ instead of gsplot, __gset__ instead of gset.
+	Remove gplot, gsplot from @seealso docs.
+
+2005-03-16  John W. Eaton  <jwe@octave.org>
+
+	* plot/replot.m: New file.
+
 2005-03-15  David Bateman  <dbateman@free.fr>
 
 	* set/unique.m, set/ismember.m: Handle cell arrays.
 
 2005-03-09  John W. Eaton  <jwe@octave.org>
 
 	* statistics/Makefile.in (bin-dist): Delete target.
 	(BINDISTSUBDIRS): Delete variable.
diff --git a/scripts/plot/__axis_label__.m b/scripts/plot/__axis_label__.m
--- a/scripts/plot/__axis_label__.m
+++ b/scripts/plot/__axis_label__.m
@@ -25,20 +25,20 @@
 ## Author: jwe
 
 function h = __axis_label__ (caller, text)
 
   if (nargin == 0)
     usage ("__axis_label__ (caller, text)");
   elseif (nargin == 2)
     if (isstr (text))
-      eval (sprintf ("gset %s \"%s\"", caller,
+      eval (sprintf ("__gset__ %s \"%s\"", caller,
 		     undo_string_escapes (undo_string_escapes (text))));
       if (automatic_replot)
-	replot
+	replot ();
       endif
     else
       error ("%s: text must be a string", caller);
     endif
   else
     usage ("%s (text)", caller);
   endif
 
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -23,17 +23,17 @@
 ##
 ## @example
 ## __errplot__ (@var{arg1}, @var{arg2}, ..., @var{fmt})
 ## @end example
 ##
 ## @end deftypefn
 ##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, errorbar, replot, xlabel, ylabel, and title}
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function __errplot__ (fstr,a1,a2,a3,a4,a5,a6)
 
   if (nargin < 3 || nargin > 7) # at least three data arguments needed
@@ -62,13 +62,13 @@ function __errplot__ (fstr,a1,a2,a3,a4,a
       case 5
 	error ("error plot requires 2, 3, 4 or 6 columns");
 	## tmp = [a1(:,i), a2(:,i), a3(:,i), a4(:,i), a5(:,i)];
       case 6
 	tmp = [a1(:,i), a2(:,i), ...
 	       a1(:,i)-a3(:,i), a1(:,i)+a4(:,i), ...
 	       a2(:,i)-a5(:,i), a2(:,i)+a6(:,i)];
     endswitch
-    cmd = sprintf ("gplot tmp %s", ifmt);
+    cmd = sprintf ("__gplot__ tmp %s", ifmt);
     eval (cmd);
 endfor
 
 endfunction
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -31,17 +31,17 @@ function __plt__ (caller, varargin)
 
     k = 1;
     j = 1;
 
     x_set = false;
     y_set = false;
     have_gp_cmd = false;
 
-    gp_cmd = "gplot";
+    gp_cmd = "__gplot__";
     sep = "";
 
     ## Gather arguments, decode format, gather plot strings, and plot lines.
 
     while (--nargs > 0 || x_set)
 
       if (nargs == 0)
 	## Force the last plot when input variables run out.
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -124,116 +124,116 @@ function curr_axis = axis (ax, varargin)
   ## It isn't hard to compute good axis limits:
   ##   scale = 10 ^ floor (log10 (max - min) - 1);
   ##   r = scale * [floor (min / scale), ceil (max / scale)];
   ## However, with axis("manual") there is little need to know the current
   ## limits.
 
   if (nargin == 0)
     if (nargout == 0)
-      gset autoscale;
+      __gset__ autoscale;
     else
       curr_axis = __current_axis__;
     endif
 
   elseif (isstr (ax))
     ax = tolower (ax);
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
     if (strcmp (ax, "ij"))
-      gset yrange [] reverse; 
+      __gset__ yrange [] reverse; 
     elseif (strcmp (ax, "xy"))
-      gset yrange [] noreverse;
+      __gset__ yrange [] noreverse;
 
       ## aspect ratio
     elseif (strcmp (ax, "image"))
-      gset size ratio -1; 
-      gset autoscale; ## XXX FIXME XXX should be the same as "tight"
+      __gset__ size ratio -1; 
+      __gset__ autoscale; ## XXX FIXME XXX should be the same as "tight"
     elseif (strcmp (ax, "equal"))
-      gset size ratio -1;
+      __gset__ size ratio -1;
     elseif (strcmp (ax, "square"))
-      gset size ratio 1;
+      __gset__ size ratio 1;
     elseif (strcmp (ax, "normal"))
-      gset size noratio;
+      __gset__ size noratio;
 
 
       ## axis limits
     elseif (len >= 4 && strcmp (ax(1:4), "auto"))
       if (len > 4)
-      	eval (sprintf ("gset autoscale %s;", ax(5:len)));
+      	eval (sprintf ("__gset__ autoscale %s;", ax(5:len)));
       else
-	gset autoscale;
+	__gset__ autoscale;
       endif
     elseif (strcmp (ax, "manual"))
       ## fixes the axis limits, like axis(axis) should;
-      gset xrange [] writeback;
-      gset yrange [] writeback;
-      gset zrange [] writeback;
+      __gset__ xrange [] writeback;
+      __gset__ yrange [] writeback;
+      __gset__ zrange [] writeback;
       ## XXX FIXME XXX if writeback were set in plot, no need to replot here.
-      replot
-      gset noautoscale x;
-      gset noautoscale y;
-      gset noautoscale z;
+      replot ();
+      __gset__ noautoscale x;
+      __gset__ noautoscale y;
+      __gset__ noautoscale z;
     elseif (strcmp (ax, "tight"))
       ## XXX FIXME XXX if tight, plot must set ranges to limits of the
       ## all the data on the current plot, even if from a previous call.
       ## Instead, just let gnuplot do as it likes.
-      gset autoscale;
+      __gset__ autoscale;
 
 
       ## tic marks
     elseif (strcmp (ax, "on"))
-      gset xtics;
-      gset ytics;
-      gset ztics;
-      gset format;
+      __gset__ xtics;
+      __gset__ ytics;
+      __gset__ ztics;
+      __gset__ format;
     elseif (strcmp (ax, "off"))
-      gset noxtics;
-      gset noytics;
-      gset noztics;
+      __gset__ noxtics;
+      __gset__ noytics;
+      __gset__ noztics;
     elseif (strcmp (ax, "tic"))
-      gset xtics;
-      gset ytics;
-      gset ztics;
+      __gset__ xtics;
+      __gset__ ytics;
+      __gset__ ztics;
     elseif (len > 3 && strcmp (ax(1:3), "tic"))
       if (any (ax == "x"))
-	gset xtics;
+	__gset__ xtics;
       else
-	gset noxtics;
+	__gset__ noxtics;
       endif
       if (any (ax == "y"))
-	gset ytics;
+	__gset__ ytics;
       else
-	gset noytics;
+	__gset__ noytics;
       endif
       if (any (ax == "z"))
-	gset ztics;
+	__gset__ ztics;
       else
-	gset noztics;
+	__gset__ noztics;
       endif
     elseif (strcmp (ax, "label"))
-      gset format;
+      __gset__ format;
     elseif (strcmp (ax, "nolabel"))
-      gset format "\\0";
+      __gset__ format "\\0";
     elseif (len > 5 && strcmp (ax(1:5), "label"))
       if (any (ax == "x"))
-	gset format x;
+	__gset__ format x;
       else
-	gset format x "\\0";
+	__gset__ format x "\\0";
       endif
       if (any (ax == "y"))
-	gset format y;
+	__gset__ format y;
       else
-	gset format y "\\0";
+	__gset__ format y "\\0";
       endif
       if (any (ax == "z"))
-	gset format z;
+	__gset__ format z;
       else
-	gset format z "\\0";
+	__gset__ format z "\\0";
       endif
 
     else
       warning ("unknown axis option '%s'", ax);
     endif
 
   elseif (isvector (ax))
 
@@ -241,35 +241,35 @@ function curr_axis = axis (ax, varargin)
 
     if (len != 2 && len != 4 && len != 6)
       error ("axis: expecting vector with 2, 4, or 6 elements");
     endif
 
     __current_axis__ = reshape (ax, 1, len);
 
     if (len > 1)
-      eval (sprintf ("gset xrange [%g:%g];", ax(1), ax(2)));
+      eval (sprintf ("__gset__ xrange [%g:%g];", ax(1), ax(2)));
     endif
 
     if (len > 3)
-      eval (sprintf ("gset yrange [%g:%g];", ax(3), ax(4)));
+      eval (sprintf ("__gset__ yrange [%g:%g];", ax(3), ax(4)));
     endif
 
     if (len > 5)
-      eval (sprintf ("gset zrange [%g:%g];", ax(5), ax(6)));
+      eval (sprintf ("__gset__ zrange [%g:%g];", ax(5), ax(6)));
     endif
 
   else
     error ("axis: expecting no args, or a vector with 2, 4, or 6 elements");
   endif
 
   if (nargin > 1)
     axis (varargin{:});
   elseif (automatic_replot)
-    replot
+    replot ();
   endif
 endfunction
 
 %!demo
 %! t=0:0.01:2*pi; x=sin(t);
 %!
 %! subplot(221);    title("normal plot");
 %! plot(t, x, ";;");
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -39,17 +39,17 @@
 ## plot (xb, yb);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
     if (isvector (x))
       len = 3 * length (x) + 1;
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -27,17 +27,17 @@
 
 function bottom_title (text)
 
   if (nargin != 1)
     usage ("bottom_title (text)");
   endif
 
   if (isstr (text))
-    gset top_title;
-    gset title;
-    eval (sprintf ("gset bottom_title \"%s\"",
+    __gset__ top_title;
+    __gset__ title;
+    eval (sprintf ("__gset__ bottom_title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
   else
     error ("bottom_title: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} contour (@var{z}, @var{n})
 ## @deftypefnx {Function File} {} contour (@var{x}, @var{y}, @var{z}, @var{n})
 ## Make a contour plot of the three-dimensional surface described by
 ## @var{z}.  Someone needs to improve @code{gnuplot}'s contour routines
 ## before this will be very useful.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function contour (x, y, z, n)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
@@ -39,34 +39,34 @@ function contour (x, y, z, n)
   if (nargin == 1 || nargin == 2)
     z = x;
     if (nargin == 1) 
       n = 10;
     else
       n = y; 
     endif
     if (ismatrix (z))
-      gset nosurface;
-      gset contour;
-      gset cntrparam bspline;
+      __gset__ nosurface;
+      __gset__ contour;
+      __gset__ cntrparam bspline;
       if (isscalar (n))
-        command = sprintf ("gset cntrparam levels %d", n);
+        command = sprintf ("__gset__ cntrparam levels %d", n);
       elseif (isvector (n))
         tmp = sprintf ("%f", n(1));
         for i = 2:length (n)
           tmp = sprintf ("%s, %f", tmp, n(i));
         endfor
-        command = sprintf ("gset cntrparam levels discrete %s", tmp);
+        command = sprintf ("__gset__ cntrparam levels discrete %s", tmp);
       else
 	error ("contour: levels must be a scalar or vector") ;
       endif
       eval (command);
-      gset noparametric;
-      gset view 0, 0, 1, 1;
-      gsplot z w l 1;
+      __gset__ noparametric;
+      __gset__ view 0, 0, 1, 1;
+      __gsplot__ z w l 1;
     else
       error ("contour: z of contour (z, levels) must be a matrix");
     endif
   elseif (nargin == 3 || nargin == 4)
     if (nargin == 3)
       n = 10;
     endif
     if (ismatrix (z))
@@ -99,34 +99,34 @@ function contour (x, y, z, n)
 	  zz = zeros (z_size(2), nc);
 	  zz(:,1:3:nc) = x';
 	  zz(:,2:3:nc) = y';
 	  zz(:,3:3:nc) = z';
 	else
 	  error (size_msg);
 	endif
       endif
-      gset nosurface;
-      gset contour;
-      gset cntrparam bspline;
+      __gset__ nosurface;
+      __gset__ contour;
+      __gset__ cntrparam bspline;
       if (isscalar (n))
-        command = sprintf ("gset cntrparam levels %d", n);
+        command = sprintf ("__gset__ cntrparam levels %d", n);
       elseif (isvector (n))
         tmp = sprintf ("%f", n(1));
         for i = 2:length (n)
           tmp = sprintf ("%s, %f", tmp, n(i));
         endfor
-        command = sprintf ("gset cntrparam levels discrete %s", tmp);
+        command = sprintf ("__gset__ cntrparam levels discrete %s", tmp);
       else
 	error ("contour: levels must be a scalar or vector") ;
       endif
       eval (command);
-      gset parametric;
-      gset view 0, 0, 1, 1;
-      gsplot zz w l 1;
+      __gset__ parametric;
+      __gset__ view 0, 0, 1, 1;
+      __gsplot__ zz w l 1;
     else
       error ("contour: x and y must be vectors and z must be a matrix");
     endif
   else
     usage ("contour (x, y, z, levels) or contour (z, levels)");
   endif
 
 endfunction
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -100,27 +100,27 @@
 ##
 ## xyerrorbar plot of @var{y} versus @var{x} where @var{x} errorbars
 ## are drawn from @var{x}-@var{lx} to @var{x}+@var{ux} and @var{y} errorbars
 ## from @var{y}-@var{ly} to @var{y}+@var{uy}.
 ##
 ## @end deftypefn
 ##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function errorbar (varargin)
 
   if (nargin < 2)
     usage ("errorbar (...)");
   endif
 
-  gset nologscale x;
-  gset nologscale y;
-  gset nopolar;
+  __gset__ nologscale x;
+  __gset__ nologscale y;
+  __gset__ nopolar;
 
   __errcomm__ ("errorbar", varargin{:});
 
 endfunction
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -42,17 +42,17 @@ function f = figure (n)
     if (gnuplot_has_frames)
       gnuterm = getenv ("GNUTERM");
       if (isempty (gnuterm) && ! isempty ("DISPLAY"))
 	gnuterm = "x11";
       endif
       if (! isempty (gnuterm))
         oneplot ();
         figure_list = union (figure_list, f);
-        eval (sprintf ("gset term %s %d\n", gnuterm, f));
+        eval (sprintf ("__gset__ term %s %d\n", gnuterm, f));
       else
         error ("figure: requires GNUTERM (Aqua) or DISPLAY (X11)");
       endif
     else
       error ("figure: gnuplot doesn't appear to support this feature");
     endif
   elseif (rem (nargin, 2) == 0)
     if (! figure_called)
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -20,46 +20,46 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} grid (@var{arg})
 ## For two-dimensional plotting, force the display of a grid on the plot.
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, @code{"on"} is assumed.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 ## PKG_ADD: mark_as_command grid
 
 function grid (x)
 
   usage_msg = "grid (\"on\" | \"off\")";
 
   do_replot = false;
 
   if (nargin == 0)
-    gset grid;
+    __gset__ grid;
     do_replot = true;
   elseif (nargin == 1)
     if (isstr (x))
       if (strcmp ("off", x))
-        gset nogrid;
+        __gset__ nogrid;
 	do_replot = true;
       elseif (strcmp ("on", x))
-        gset grid;
+        __gset__ grid;
 	do_replot = true;
       else
 	usage (usage_msg);
       endif
     else
       error ("grid: argument must be a string");
     endif
   else
     usage (usage_msg);
   endif
 
   if (do_replot && automatic_replot)
-    replot
+    replot ();
   endif
 
 endfunction
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -20,25 +20,25 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} loglog (@var{args})
 ## Make a two-dimensional plot using log scales for both axes.  See the
 ## description of @code{plot} for a description of the arguments that
 ## @code{loglog} will accept.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, and title}
+## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function loglog (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  gset logscale x;
-  gset logscale y;
-  gset nopolar;
+  __gset__ logscale x;
+  __gset__ logscale y;
+  __gset__ nopolar;
 
   __plt__ ("loglog", varargin{:});
 
 endfunction
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -31,27 +31,27 @@
 ## which produces a double logarithm plot of @var{y} versus @var{x} 
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ##
 ## @end deftypefn
 ##
 ## @seealso{errorbar, semilogxerr, semilogyerr, polar, mesh, contour, 
-## __pltopt__, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## __pltopt__, bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function loglogerr (varargin)
 
   if (nargin < 2)
     usage ("loglogerr(...)");
   endif
 
-  gset logscale x;
-  gset logscale y;
-  gset nopolar;
+  __gset__ logscale x;
+  __gset__ logscale y;
+  __gset__ nopolar;
 
   __errcomm__ ("loglogerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -23,37 +23,37 @@
 ## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, meshgrid, meshdom,
-## contour, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## contour, bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function mesh (x, y, z)
 
   ## XXX FIXME XXX -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   if (nargin == 1)
     z = x;
     if (ismatrix (z))
-      gset hidden3d;
-      gset data style lines;
-      gset surface;
-      gset nocontour;
-      gset noparametric;
-      gset nologscale;
-      gset view 60, 30, 1, 1
-      gsplot (z');
+      __gset__ hidden3d;
+      __gset__ data style lines;
+      __gset__ surface;
+      __gset__ nocontour;
+      __gset__ noparametric;
+      __gset__ nologscale;
+      __gset__ view 60, 30, 1, 1
+      __gsplot__ (z');
     else
       error ("mesh: argument must be a matrix");
     endif
   elseif (nargin == 3)
     if (isvector (x) && isvector (y) && ismatrix (z))
       xlen = length (x);
       ylen = length (y);
       if (xlen == columns (z) && ylen == rows (z))
@@ -64,25 +64,25 @@ function mesh (x, y, z)
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(k) * ones (ylen, 1);
           zz(:,i+1) = y;
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-        gset hidden3d;
-        gset data style lines;
-        gset surface;
-        gset nocontour;
-        gset nologscale;
-        gset parametric;
-        gset view 60, 30, 1, 1
-        gsplot (zz);
-        gset noparametric;
+        __gset__ hidden3d;
+        __gset__ data style lines;
+        __gset__ surface;
+        __gset__ nocontour;
+        __gset__ nologscale;
+        __gset__ parametric;
+        __gset__ view 60, 30, 1, 1
+        __gsplot__ (zz);
+        __gset__ noparametric;
       else
         msg = "mesh: rows (z) must be the same as length (y) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (x)", msg);
         error (msg);
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       xlen = columns (z);
       ylen = rows (z);
@@ -92,25 +92,25 @@ function mesh (x, y, z)
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(:,k);
           zz(:,i+1) = y(:,k);
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-        gset hidden3d;
-        gset data style lines;
-        gset surface;
-        gset nocontour;
-        gset nologscale;
-        gset parametric;
-        gset view 60, 30, 1, 1
-        gsplot (zz);
-        gset noparametric;
+        __gset__ hidden3d;
+        __gset__ data style lines;
+        __gset__ surface;
+        __gset__ nocontour;
+        __gset__ nologscale;
+        __gset__ parametric;
+        __gset__ view 60, 30, 1, 1
+        __gsplot__ (zz);
+        __gset__ noparametric;
       else
         error ("mesh: x, y, and z must have same dimensions");
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif
   else
     usage ("mesh (z)");
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -20,18 +20,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x}, @var{y})
 ## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x})
 ## Given vectors of @var{x} and @var{y} coordinates, return two matrices corresponding
 ## to the @var{x} and @var{y} coordinates of a mesh.  The rows of @var{xx} are copies of @var{x},
 ## and the columns of @var{yy} are copies of @var{y}.
 ## @end deftypefn
 ##
-## @seealso{sombrero, plot, semilogx, semilogy, loglog, polar, mesh, meshdom, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## @seealso{sombrero, plot, semilogx, semilogy, loglog, polar, mesh,
+## meshdom, contour, bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xx, yy] = meshgrid (x, y)
 
   if (nargin == 1)
     y = x;
   endif
diff --git a/scripts/plot/mplot.m b/scripts/plot/mplot.m
--- a/scripts/plot/mplot.m
+++ b/scripts/plot/mplot.m
@@ -39,18 +39,18 @@ function mplot (varargin)
   global __multiplot_mode__ = 0;
   global __multiplot_xsize__;
   global __multiplot_ysize__;
   global __multiplot_xn__;
   global __multiplot_yn__;
   global __multiplot_xi__;
   global __multiplot_yi__;
 
-  gset nologscale;
-  gset nopolar;
+  __gset__ nologscale;
+  __gset__ nopolar;
 
   __plt__ ("plot", varargin{:});
 
   ## update the plot position
 
   if (__multiplot_mode__)
 
     if (__multiplot_xi__ < __multiplot_xn__)
@@ -62,13 +62,13 @@ function mplot (varargin)
       else
         __multiplot_yi__ = 1;
       endif
     endif
 
     xo = (__multiplot_xi__ - 1.0) * __multiplot_xsize__;
     yo = (__multiplot_yn__ - __multiplot_yi__) * __multiplot_ysize__;
 
-    eval (sprintf ("gset origin %g, %g", xo, yo));
+    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
 
   endif
 
 endfunction
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -68,27 +68,27 @@ function multiplot (xn, yn)
     __multiplot_yi__ = 1;
 
   else
 
     if (xn < 1 || yn < 1)
       error ("multiplot: xn and yn have to be positive integers");
     endif
 
-    gset multiplot;
+    __gset__ multiplot;
 
     xsize = 1.0 ./ xn;
     ysize = 1.0 ./ yn;
 
-    eval (sprintf ("gset size %g, %g", xsize, ysize));
+    eval (sprintf ("__gset__ size %g, %g", xsize, ysize));
 
     xo = 0.0;
     yo = (yn - 1.0)*ysize;
 
-    eval (sprintf ("gset origin %g, %g", xo, yo));
+    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
 
     __multiplot_mode__ = 1;
     __multiplot_xsize__ = xsize;
     __multiplot_ysize__ = ysize;
     __multiplot_xn__ = xn;
     __multiplot_yn__ = yn;
     __multiplot_xi__ = 1;
     __multiplot_yi__ = 1;
diff --git a/scripts/plot/oneplot.m b/scripts/plot/oneplot.m
--- a/scripts/plot/oneplot.m
+++ b/scripts/plot/oneplot.m
@@ -26,16 +26,16 @@
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function oneplot ()
 
   global __multiplot_mode__ = 0;
 
   if (__multiplot_mode__)
-    gset nomultiplot;
-    gset size 1, 1;
-    gset origin 0, 0;
+    __gset__ nomultiplot;
+    __gset__ size 1, 1;
+    __gset__ origin 0, 0;
     __multiplot_mode__ = 0;
     gnuplot_command_replot = "rep";
   endif
 
 endfunction
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -160,24 +160,24 @@
 ## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ## @end deftypefn
 ##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, errorbar, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function plot (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  gset nologscale;
-  gset nopolar;
+  __gset__ nologscale;
+  __gset__ nopolar;
 
   __plt__ ("plot", varargin{:});
 
 endfunction
diff --git a/scripts/plot/plot_border.m b/scripts/plot/plot_border.m
--- a/scripts/plot/plot_border.m
+++ b/scripts/plot/plot_border.m
@@ -95,23 +95,23 @@ function plot_border (varargin)
       elseif (strcmp (arg, "all") || strcmp (arg, "ALL")
               || strcmp (arg, "a") || strcmp (arg, "A"))
         all = 1;
       endif
     endif
   endwhile
 
   if (none)
-    gset noborder;
+    __gset__ noborder;
   else
     if (all)
       border = 15;
     else
       border = south + west + north + east;
     endif
-    eval (sprintf ("gset border %d", border));
+    eval (sprintf ("__gset__ border %d", border));
   endif
 
   if (automatic_replot)
-    replot
+    replot ();
   endif
 
 endfunction
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -21,28 +21,28 @@
 ## @deftypefn {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## Make a two-dimensional plot given polar the coordinates @var{theta} and
 ## @var{rho}.
 ##
 ## The optional third argument specifies the line type.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
-## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## stairs, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  gset nologscale;
-  gset nopolar;
+  __gset__ nologscale;
+  __gset__ nopolar;
 
   if (nargin == 3)
     if (isstr (fmt))
       fmt = __pltopt__ ("polar", fmt);
     else
       error ("polar: third argument must be a string");
     endif
     __plr2__ (x1, x2, fmt);
diff --git a/scripts/plot/replot.m b/scripts/plot/replot.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/replot.m
@@ -0,0 +1,37 @@
+## Copyright (C) 2005 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+## 02111-1307, USA.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} replot ()
+## Refressh the plot window.
+## @end deftypefn
+
+## Author: jwe
+
+function replot ()
+
+  if (nargin == 0)
+    ## No semicolon following the __greplot__ line unless you also fix
+    ## gplot.l to allow it.
+    __greplot__
+  else
+    usage ("replot ()");
+  endif
+
+endfunction
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -20,25 +20,25 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogx (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{x} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogx} will accept.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, and title}
+## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogx (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  gset logscale x;
-  gset nologscale y;
-  gset nopolar;
+  __gset__ logscale x;
+  __gset__ nologscale y;
+  __gset__ nopolar;
 
   __plt__ ("semilogx", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -31,27 +31,27 @@
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ##
 ## @end deftypefn
 ##
 ## @seealso{errorbar, loglogerr semilogyerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogxerr (varargin)
 
   if (nargin < 2)
     usage ("semilogxerr (...)");
   endif
 
-  gset logscale x;
-  gset nologscale y;
-  gset nopolar;
+  __gset__ logscale x;
+  __gset__ nologscale y;
+  __gset__ nopolar;
 
   __errcomm__ ("semilogxerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -20,25 +20,25 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogy (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{y} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogy} will accept.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
-## gplot, gsplot, replot, xlabel, ylabel, and title}
+## replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function semilogy (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  gset nologscale x;
-  gset logscale y;
-  gset nopolar;
+  __gset__ nologscale x;
+  __gset__ logscale y;
+  __gset__ nopolar;
 
   __plt__ ("semilogy", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -31,27 +31,27 @@
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ##
 ## @end deftypefn
 ##
 ## @seealso{errorbar, loglogerr semilogxerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, stairs, replot, xlabel, ylabel, and title}
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogyerr (varargin)
 
   if (nargin < 2)
     usage ("semilogyerr (...)");
   endif
 
-  gset nologscale x;
-  gset logscale y;
-  gset nopolar;
+  __gset__ nologscale x;
+  __gset__ logscale y;
+  __gset__ nopolar;
 
   __errcomm__ ("semilogyerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -16,26 +16,26 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} shg
 ##
 ## Show the graph window.  Currently, this is the same as executing
-## replot without any arguments.
+## replot.
 ##
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, and ylabel}
+## bar, stairs, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
     warning ("shg: ignoring extra arguments");
   endif
 
-  replot
+  replot ();
 
 endfunction
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -39,17 +39,17 @@
 ## plot (xs, ys);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, gplot, gsplot, replot, xlabel, ylabel, and title}
+## bar, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
 
   if (nargin == 1)
     if (isvector (x))
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
 ## Sets @code{gnuplot} in multiplot mode and plots in location
 ## given by index (there are @var{cols} by @var{rows} subwindows).
 ##
 ## The global variable @var{__multiplot_scale__} should be used when the
-## command @code{gset size xsize, ysize} has been used prior to calling
+## command @code{__gset__ size xsize, ysize} has been used prior to calling
 ## @code{subplot}.
 ##
 ## The value of @var{__multiplot_scale__} should be a vector with two
 ## elements, the first set equal to @var{xsize} and the second to
 ## @var{ysize}.
 ##
 ## Input:
 ##
@@ -152,31 +152,31 @@ function subplot (rows, columns, index)
       __multiplot_mode__ = 1;
       __multiplot_xn__ = columns;
       __multiplot_yn__ = rows;
       __multiplot_xsize__ = __multiplot_scale__(1) ./ columns;
       __multiplot_ysize__ = __multiplot_scale__(2) ./ rows;
 
       gnuplot_command_replot = "cle;rep";
 
-      gset multiplot;
+      __gset__ multiplot;
 
-      eval (sprintf ("gset size %g, %g", __multiplot_xsize__,
+      eval (sprintf ("__gset__ size %g, %g", __multiplot_xsize__,
                      __multiplot_ysize__));
     endif
 
     ## get the sub plot location
 
     yp = fix ((index-1)/columns);
     xp = index - yp*columns - 1;
     __multiplot_xi__ = ++xp;
     __multiplot_yi__ = ++yp;
 
     ## set the origin
 
     xo = (xp - 1.0) * __multiplot_xsize__;
     yo = (rows - yp) * __multiplot_ysize__;
 
-    eval (sprintf ("gset origin %g, %g", xo, yo));
+    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
 
   endif
 
 endfunction
diff --git a/scripts/plot/subwindow.m b/scripts/plot/subwindow.m
--- a/scripts/plot/subwindow.m
+++ b/scripts/plot/subwindow.m
@@ -66,13 +66,13 @@ function subwindow (xn, yn)
 
   if (xn < 1 || xn > __multiplot_xn__ || yn < 1 || yn > __multiplot_yn__)
     error ("subwindow: incorrect xn and yn");
   endif
 
   xo = (xn - 1.0) * __multiplot_xsize__;
   yo = (__multiplot_yn__ - yn) * __multiplot_ysize__;
 
-  eval (sprintf ("gset origin %g, %g", xo, yo));
+  eval (sprintf ("__gset__ origin %g, %g", xo, yo));
 
   clearplot;
 
 endfunction
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -18,31 +18,31 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} title (@var{string})
 ## Specify a title for a plot.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, xlabel, and ylabel}
+## bar, stairs, replot, xlabel, and ylabel}
 
 ## Author: jwe
 
 function h = title (text)
 
   if (nargin != 1)
     usage ("title (text)");
   endif
 
   if (isstr (text))
-    eval (sprintf ("gset title \"%s\"",
+    eval (sprintf ("__gset__ title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
     if (automatic_replot)
-      replot
+      replot ();
     endif
   else
     error ("title: text must be a string");
   endif
 
   ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
diff --git a/scripts/plot/top_title.m b/scripts/plot/top_title.m
--- a/scripts/plot/top_title.m
+++ b/scripts/plot/top_title.m
@@ -29,20 +29,20 @@
 
 function top_title (text)
 
   if (nargin != 1)
     usage ("top_title (text)");
   endif
 
   if (isstr (text))
-    gset bottom_title;
-    gset title;
-    eval (sprintf ("gset top_title \"%s\"",
+    __gset__ bottom_title;
+    __gset__ title;
+    eval (sprintf ("__gset__ top_title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
     if (automatic_replot)
-      replot
+      replot ();
     endif
   else
     error ("error: top_title: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{string})
 ## Specify x, y, and z axis labels for the plot.  If you already have a plot
 ## displayed, use the command @code{replot} to redisplay it with the new
 ## labels.
 ## @end deftypefn
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, gplot, gsplot, replot, ylabel, and title}
+## bar, stairs, replot, ylabel, and title}
 
 ## Author: jwe
 
 function h = xlabel (varargin)
 
   ## XXX FIXME XXX -- eventually, we will return a graphics handle.  For
   ## now, return something, so that calls that expect a handle won't
   ## fail (at least immediately).
