# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1456811990 18000
#      Tue Mar 01 00:59:50 2016 -0500
# Node ID 93c489ca8a6be5f67b280a4a9adab3c47b180e0f
# Parent  172479a97e6c1c171014b78aa478144d759df41d
elimnate HAVE_JAVA from ov-java.h

* ov-class.cc: Don't inlcude ov-java.h.
* ov.cc: Include ov-java.h unconditionally.
(install_types): Call octave_java::register_type unconditionally.

* ov-java.h: Don't include <jni.h>.  Eliminate HAVE_JAVA conditional.
(class java_local_ref): Move definition and typedefs to ov-java.cc.
(jstring_to_string, jstring_to_string, box, box_more, unbox): Delete
declarations.  Make definitions static in ov-java.cc.
* ov-java.h, ov-java.cc: Use void pointers instead of specific Java
types.
(octave_java::thread_jni_env): Convert to non-class static function in
ov-java.cc.
(octave_java::octave_java): Throw error if Java is not available.
In all other class methods, call panic_impossible if Java is not
available.

diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -41,19 +41,16 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ov-class.h"
-#ifdef HAVE_JAVA
-#  include "ov-java.h"
-#endif
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "variables.h"
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -21,24 +21,23 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
 
 #include "defun.h"
 #include "error.h"
+#include "errwarn.h"
 #include "fpucw.h"
 
 #if defined (HAVE_FPU_CONTROL_H)
 #  include <fpu_control.h>
 #endif
 
-#if defined HAVE_JAVA
-
 #if defined (HAVE_WINDOWS_H)
 #  include <windows.h>
 #endif
 
 #include <algorithm>
 #include <map>
 #include <iostream>
 #include <fstream>
@@ -53,22 +52,111 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-shlib.h"
 #include "ov-java.h"
 #include "parse.h"
 #include "variables.h"
 
+#if defined (HAVE_JAVA)
+#include <jni.h>
+#endif
+
+#if defined (HAVE_JAVA)
+
+#define TO_JOBJECT(obj) reinterpret_cast<jobject> (obj)
+#define TO_JCLASS(obj) reinterpret_cast<jclass> (obj)
+
+#define TO_JNIENV(env) reinterpret_cast<JNIEnv *> (env)
+
 typedef jint (JNICALL *JNI_CreateJavaVM_t) (JavaVM **pvm, JNIEnv **penv,
                                             void *args);
 
 typedef jint (JNICALL *JNI_GetCreatedJavaVMs_t) (JavaVM **pvm, jsize bufLen,
                                                  jsize *nVMs);
 
+template <typename T>
+class java_local_ref
+{
+public:
+
+  java_local_ref (JNIEnv *_env)
+    : jobj (0), detached (false), env (_env) { }
+
+  java_local_ref (JNIEnv *_env, T obj)
+    : jobj (obj), detached (false), env (_env) { }
+
+  ~java_local_ref (void) { release (); }
+
+  T& operator = (T obj)
+  {
+    release ();
+
+    jobj = obj;
+    detached = false;
+
+    return jobj;
+  }
+
+  operator bool () const { return (jobj != 0); }
+  operator T () { return jobj; }
+
+  void detach (void) { detached = true; }
+
+private:
+
+  void release (void)
+  {
+    if (env && jobj && ! detached)
+      env->DeleteLocalRef (jobj);
+
+    jobj = 0;
+  }
+
+  java_local_ref (void)
+    : jobj (0), detached (false), env (0)
+  { }
+
+protected:
+
+  T jobj;
+  bool detached;
+  JNIEnv *env;
+};
+
+typedef java_local_ref<jobject> jobject_ref;
+typedef java_local_ref<jclass> jclass_ref;
+typedef java_local_ref<jstring> jstring_ref;
+typedef java_local_ref<jobjectArray> jobjectArray_ref;
+typedef java_local_ref<jintArray> jintArray_ref;
+typedef java_local_ref<jbyteArray> jbyteArray_ref;
+typedef java_local_ref<jdoubleArray> jdoubleArray_ref;
+typedef java_local_ref<jthrowable> jthrowable_ref;
+
+static std::string
+jstring_to_string (JNIEnv* jni_env, jstring s);
+
+static std::string
+jstring_to_string (JNIEnv* jni_env, jobject obj);
+
+static octave_value
+box (JNIEnv* jni_env, void *jobj, void *jcls_arg = 0);
+
+static octave_value
+box_more (JNIEnv* jni_env, void *jobj_arg, void *jcls_arg = 0);
+
+static bool
+unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
+       jclass_ref& jcls);
+
+static bool
+unbox (JNIEnv* jni_env, const octave_value_list& args,
+       jobjectArray_ref& jobjs, jobjectArray_ref& jclss);
+
 extern "C"
 {
   JNIEXPORT jboolean JNICALL
   Java_org_octave_Octave_call (JNIEnv *, jclass, jstring, jobjectArray,
                                jobjectArray);
 
   JNIEXPORT void JNICALL
   Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint);
@@ -637,32 +725,32 @@ terminate_jvm (void)
 
       if (jvm_lib)
         jvm_lib.close ();
 
       restore_fpu_state ();
     }
 }
 
-std::string
+static std::string
 jstring_to_string (JNIEnv *jni_env, jstring s)
 {
   std::string retval;
 
   if (jni_env)
     {
       const char *cstr = jni_env->GetStringUTFChars (s, 0);
       retval = cstr;
       jni_env->ReleaseStringUTFChars (s, cstr);
     }
 
   return retval;
 }
 
-std::string
+static std::string
 jstring_to_string (JNIEnv *jni_env, jobject obj)
 {
   std::string retval;
 
   if (jni_env && obj)
     {
       jclass_ref cls (jni_env, jni_env->FindClass ("java/lang/String"));
       if (cls)
@@ -671,49 +759,82 @@ jstring_to_string (JNIEnv *jni_env, jobj
             retval = jstring_to_string (jni_env,
                                         reinterpret_cast<jstring> (obj));
         }
     }
 
   return retval;
 }
 
+static inline JNIEnv *
+thread_jni_env (void)
+{
+  JNIEnv *env = 0;
+
+  if (jvm)
+    jvm->GetEnv (reinterpret_cast<void **> (&env), JNI_VERSION_1_2);
+
+  return env;
+}
+
+#endif
+
 bool
 octave_java::is_java_string (void) const
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env && java_object)
     {
       jclass_ref cls (current_env, current_env->FindClass ("java/lang/String"));
-      return current_env->IsInstanceOf (java_object, cls);
+      return current_env->IsInstanceOf (TO_JOBJECT (java_object), cls);
     }
 
   return false;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 bool
 octave_java::is_instance_of (const std::string& cls_name) const
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   std::string cls_cpp = cls_name;
   std::replace (cls_cpp.begin (), cls_cpp.end (), '.', '/');
 
   if (current_env && java_object)
     {
       jclass_ref cls (current_env, current_env->FindClass (cls_cpp.c_str ()));
       if (current_env->ExceptionCheck ())
         current_env->ExceptionClear ();
       else
-        return current_env->IsInstanceOf (java_object, cls);
+        return current_env->IsInstanceOf (TO_JOBJECT (java_object), cls);
     }
   return false;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
+#if defined (HAVE_JAVA)
+
 static octave_value
 check_exception (JNIEnv *jni_env)
 {
   octave_value retval;
 
   jthrowable_ref ex (jni_env, jni_env->ExceptionOccurred ());
 
   if (ex)
@@ -909,18 +1030,20 @@ set_array_elements (JNIEnv *jni_env, job
     retval = check_exception (jni_env);
 
   restore_fpu_state ();
 
   return retval;
 }
 
 static string_vector
-get_invoke_list (JNIEnv *jni_env, jobject jobj)
+get_invoke_list (JNIEnv *jni_env, void *jobj_arg)
 {
+  jobject jobj = TO_JOBJECT (jobj_arg);
+
   std::list<std::string> name_list;
 
   if (jni_env)
     {
       jclass_ref cls (jni_env, jni_env->GetObjectClass (jobj));
       jclass_ref ccls (jni_env, jni_env->GetObjectClass (cls));
       jmethodID getMethods_ID = jni_env->GetMethodID (ccls, "getMethods", "()[Ljava/lang/reflect/Method;");
       jmethodID getFields_ID = jni_env->GetMethodID (ccls, "getFields", "()[Ljava/lang/reflect/Field;");
@@ -1006,20 +1129,24 @@ convert_to_string (JNIEnv *jni_env, jobj
       restore_fpu_state ();
     }
 
   return retval;
 }
 
 #define TO_JAVA(obj) dynamic_cast<octave_java*> ((obj).internal_rep ())
 
-octave_value
-box (JNIEnv *jni_env, jobject jobj, jclass jcls)
+static octave_value
+box (JNIEnv *jni_env, void *jobj_arg, void *jcls_arg)
 {
   octave_value retval;
+
+  jobject jobj = TO_JOBJECT (jobj_arg);
+  jclass jcls = TO_JCLASS (jcls_arg);
+
   jclass_ref cls (jni_env);
 
   if (! jobj)
     retval = Matrix ();
 
   while (retval.is_undefined ())
     {
       // Convert a scalar of any numeric class (byte, short, integer, long,
@@ -1171,19 +1298,22 @@ box (JNIEnv *jni_env, jobject jobj, jcla
       // No suitable class found.  Return a generic octave_java object
       retval = octave_value (new octave_java (jobj, jcls));
       break;
     }
 
   return retval;
 }
 
-octave_value
-box_more (JNIEnv *jni_env, jobject jobj, jclass jcls)
+static octave_value
+box_more (JNIEnv *jni_env, void *jobj_arg, void *jcls_arg)
 {
+  jobject jobj = TO_JOBJECT (jobj_arg);
+  jclass jcls = TO_JCLASS (jcls_arg);
+
   octave_value retval = box (jni_env, jobj, jcls);
 
   if (retval.is_java ())
     {
       retval = octave_value ();
 
       jclass_ref cls (jni_env);
 
@@ -1265,26 +1395,26 @@ box_more (JNIEnv *jni_env, jobject jobj,
   if (retval.is_undefined ())
     retval = octave_value (new octave_java (jobj, jcls));
 
   restore_fpu_state ();
 
   return retval;
 }
 
-bool
+static bool
 unbox (JNIEnv *jni_env, const octave_value& val, jobject_ref& jobj,
        jclass_ref& jcls)
 {
   bool found = true;
 
   if (val.is_java ())
     {
       octave_java *ovj = TO_JAVA (val);
-      jobj = ovj->to_java ();
+      jobj = TO_JOBJECT (ovj->to_java ());
       jobj.detach ();
       jcls = jni_env->GetObjectClass (jobj);
     }
   else if (val.is_string ())
     {
       std::string s = val.string_value ();
 
       jobj = jni_env->NewStringUTF (s.c_str ());
@@ -1480,17 +1610,17 @@ unbox (JNIEnv *jni_env, const octave_val
       jobj = jni_env->NewObject (rcls, mID, ID);
       jcls = rcls;
       octave_ref_map[ID] = val;
     }
 
   return found;
 }
 
-bool
+static bool
 unbox (JNIEnv *jni_env, const octave_value_list& args,
        jobjectArray_ref& jobjs, jobjectArray_ref& jclss)
 {
   bool found = true;
 
   jclass_ref ocls (jni_env, jni_env->FindClass ("java/lang/Object"));
   jclass_ref ccls (jni_env, jni_env->FindClass ("java/lang/Class"));
 
@@ -1536,17 +1666,17 @@ get_current_thread_ID (JNIEnv *jni_env)
     }
 
   return -1;
 }
 
 static int
 java_event_hook (void)
 {
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     {
       jclass_ref cls (current_env, find_octave_class (current_env, "org/octave/Octave"));
       jmethodID mID = current_env->GetStaticMethodID (cls, "checkPendingAction", "()V");
       current_env->CallStaticVoidMethod (cls, mID);
 
       restore_fpu_state ();
@@ -1559,17 +1689,17 @@ static void
 initialize_java (void)
 {
   if (! jvm)
     {
       try
         {
           initialize_jvm ();
 
-          JNIEnv *current_env = octave_java::thread_jni_env ();
+          JNIEnv *current_env = thread_jni_env ();
 
           command_editor::add_event_hook (java_event_hook);
 
           octave_thread_ID = get_current_thread_ID (current_env);
           //printf ("octave thread ID=%ld\n", octave_thread_ID);
         }
       catch (std::string msg)
         {
@@ -1660,56 +1790,85 @@ Java_org_octave_Octave_doEvalString (JNI
 }
 
 JNIEXPORT jboolean JNICALL
 Java_org_octave_Octave_needThreadedInvokation (JNIEnv *env, jclass)
 {
   return (get_current_thread_ID (env) != octave_thread_ID);
 }
 
+#endif
+
 // octave_java class definition
 
+octave_java::octave_java (void)
+  : octave_base_value (), java_object (0), java_class (0)
+{
+#if ! defined (HAVE_JAVA)
+
+  err_disabled_feature ("Java Objects", "Java");
+
+#endif
+}
+
+octave_java::octave_java (const voidptr& jobj, void *jcls)
+  : octave_base_value (), java_object (0), java_class (0)
+{
+#if defined (HAVE_JAVA)
+
+  init (jobj, jcls);
+
+#else
+
+  err_disabled_feature ("Java Objects", "Java");
+
+#endif
+}
 
 int octave_java::t_id (-1);
 
 const std::string octave_java::t_name ("octave_java");
 
 void
 octave_java::register_type (void)
 {
+#if defined (HAVE_JAVA)
+
   t_id = octave_value_typeinfo::register_type
          (octave_java::t_name, "<unknown>", octave_value (new octave_java ()));
+
+#endif
 }
 
 dim_vector
 octave_java::dims (void) const
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env && java_object)
-    return compute_array_dimensions (current_env, java_object);
+    return compute_array_dimensions (current_env, TO_JOBJECT (java_object));
   else
     return dim_vector (1, 1);
-}
-
-JNIEnv *
-octave_java::thread_jni_env (void)
-{
-  JNIEnv *env = 0;
-
-  if (jvm)
-    jvm->GetEnv (reinterpret_cast<void **> (&env), JNI_VERSION_1_2);
-
-  return env;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value_list
 octave_java::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx, int nargout)
 {
+#if defined (HAVE_JAVA)
+
   octave_value_list retval;
   int skip = 1;
 
   JNIEnv *current_env = thread_jni_env ();
 
   switch (type[0])
     {
     case '.':
@@ -1731,35 +1890,44 @@ octave_java::subsref (const std::string&
           ovl(0) = octave_value (this);
           ovl(1) = (idx.front ())(0);
           retval = feval (std::string ("__java_get__"), ovl, 1);
         }
       break;
 
     case '(':
       if (current_env)
-        retval = get_array_elements (current_env, to_java (), idx.front ());
+        retval = get_array_elements (current_env, TO_JOBJECT (to_java ()), idx.front ());
       break;
 
     default:
       error ("subsref: Java object cannot be indexed with %c", type[0]);
       break;
     }
 
   if (idx.size () > 1 && type.length () > 1)
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
 octave_java::subsasgn (const std::string& type,
                        const std::list<octave_value_list>&idx,
                        const octave_value &rhs)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
   JNIEnv *current_env = thread_jni_env ();
 
   switch (type[0])
     {
     case '.':
       if (type.length () == 1)
@@ -1804,51 +1972,76 @@ octave_java::subsasgn (const std::string
         }
       else
         error ("invalid indexing/assignment on Java object");
       break;
 
     case '(':
       if (current_env)
         {
-          set_array_elements (current_env, to_java (), idx.front (), rhs);
+          set_array_elements (current_env, TO_JOBJECT (to_java ()), idx.front (), rhs);
 
           count++;
           retval = octave_value (this);
         }
       break;
 
     default:
       error ("Java object cannot be indexed with %c", type[0]);
       break;
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 string_vector
 octave_java::map_keys (void) const
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     return get_invoke_list (current_env, to_java ());
   else
     return string_vector ();
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
 octave_java::convert_to_str_internal (bool, bool force, char type) const
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
-    return convert_to_string (current_env, to_java (), force, type);
+    return convert_to_string (current_env, TO_JOBJECT (to_java ()), force, type);
   else
     return octave_value ("");
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 void
 octave_java::print (std::ostream& os, bool)
 {
   print_raw (os);
   newline (os);
 }
@@ -1905,21 +2098,25 @@ octave_java::save_hdf5 (octave_hdf5_id /
 bool
 octave_java::load_hdf5 (octave_hdf5_id /* loc_id */, const char * /* name */)
 {
   // Silently skip object that was not saved
   return true;
 }
 
 octave_value
-octave_java::do_javaMethod (JNIEnv *jni_env, const std::string& name,
+octave_java::do_javaMethod (void *jni_env_arg, const std::string& name,
                             const octave_value_list& args)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
       if (unbox (jni_env, args, arg_objs, arg_types))
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeMethod",
                                                       "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
@@ -1931,26 +2128,52 @@ octave_java::do_javaMethod (JNIEnv *jni_
           else
             retval = check_exception (jni_env);
         }
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java:: do_javaMethod (JNIEnv *jni_env,
+octave_java::do_javaMethod (const std::string& name, const octave_value_list& args)
+{
+#if defined (HAVE_JAVA)
+
+  return do_javaMethod (thread_jni_env (), name, args);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java:: do_javaMethod (void *jni_env_arg,
                              const std::string& class_name,
                              const std::string& name,
                              const octave_value_list& args)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
       if (unbox (jni_env, args, arg_objs, arg_types))
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeStaticMethod",
                                                       "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
@@ -1963,24 +2186,51 @@ octave_java:: do_javaMethod (JNIEnv *jni
           else
             retval = check_exception (jni_env);
         }
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java::do_javaObject (JNIEnv *jni_env, const std::string& name,
+octave_java::do_javaMethod (const std::string& class_name, const std::string& name,
                             const octave_value_list& args)
 {
+#if defined (HAVE_JAVA)
+
+  return do_javaMethod (thread_jni_env (), class_name, name, args);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_javaObject (void *jni_env_arg, const std::string& name,
+                            const octave_value_list& args)
+{
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
 
       if (unbox (jni_env, args, arg_objs, arg_types))
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeConstructor",
@@ -1994,23 +2244,49 @@ octave_java::do_javaObject (JNIEnv *jni_
           else
             check_exception (jni_env);
         }
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java::do_java_get (JNIEnv *jni_env, const std::string& name)
+octave_java::do_javaObject (const std::string& name, const octave_value_list& args)
 {
+#if defined (HAVE_JAVA)
+
+  return do_javaObject (thread_jni_env (), name, args);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_java_get (void *jni_env_arg, const std::string& name)
+{
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
       jmethodID mID = jni_env->GetStaticMethodID (helperClass, "getField",
           "(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;");
       jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
       jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
           to_java (), jstring (fName)));
@@ -2019,24 +2295,50 @@ octave_java::do_java_get (JNIEnv *jni_en
         retval = box (jni_env, resObj);
       else
         retval = check_exception (jni_env);
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java::do_java_get (JNIEnv *jni_env, const std::string& class_name,
+octave_java::do_java_get (const std::string& name)
+{
+#if defined (HAVE_JAVA)
+
+  return do_java_get (thread_jni_env (), name);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_java_get (void *jni_env_arg, const std::string& class_name,
                           const std::string& name)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
       jmethodID mID = jni_env->GetStaticMethodID (helperClass, "getStaticField",
           "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;");
       jstring_ref cName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
       jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
       jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
@@ -2045,24 +2347,50 @@ octave_java::do_java_get (JNIEnv *jni_en
         retval = box (jni_env, resObj);
       else
         retval = check_exception (jni_env);
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java::do_java_set (JNIEnv *jni_env, const std::string& name,
+octave_java::do_java_get (const std::string& class_name, const std::string& name)
+{
+#if defined (HAVE_JAVA)
+
+  return do_java_get (thread_jni_env (), class_name, name);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_java_set (void *jni_env_arg, const std::string& name,
                           const octave_value& val)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jobject_ref jobj (jni_env);
       jclass_ref jcls (jni_env);
 
       if (unbox (jni_env, val, jobj, jcls))
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
@@ -2072,24 +2400,50 @@ octave_java::do_java_set (JNIEnv *jni_en
           jni_env->CallStaticObjectMethod (helperClass, mID, to_java (), jstring (fName), jobject (jobj));
           check_exception (jni_env);
         }
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 octave_value
-octave_java::do_java_set (JNIEnv *jni_env, const std::string& class_name,
+octave_java::do_java_set (const std::string& name, const octave_value& val)
+{
+#if defined (HAVE_JAVA)
+
+  return do_java_set (thread_jni_env (), name, val);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_java_set (void *jni_env_arg, const std::string& class_name,
                           const std::string& name, const octave_value& val)
 {
+#if defined (HAVE_JAVA)
+
   octave_value retval;
 
+  JNIEnv *jni_env = TO_JNIENV (jni_env_arg);
+
   if (jni_env)
     {
       jobject_ref jobj (jni_env);
       jclass_ref jcls (jni_env);
 
       if (unbox (jni_env, val, jobj, jcls))
         {
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
@@ -2100,108 +2454,150 @@ octave_java::do_java_set (JNIEnv *jni_en
           jni_env->CallStaticObjectMethod (helperClass, mID, jstring (cName), jstring (fName), jobject (jobj));
           check_exception (jni_env);
         }
 
       restore_fpu_state ();
     }
 
   return retval;
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
+}
+
+octave_value
+octave_java::do_java_set (const std::string& class_name, const std::string& name,
+                          const octave_value& val)
+{
+#if defined (HAVE_JAVA)
+
+  return do_java_set (thread_jni_env (), class_name, name, val);
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 void
-octave_java::init (jobject jobj, jclass jcls)
+octave_java::init (void *jobj_arg, void *jcls_arg)
 {
+#if defined (HAVE_JAVA)
+
+  jobject jobj = TO_JOBJECT (jobj_arg);
+  jclass jcls = TO_JCLASS (jcls_arg);
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     {
       if (jobj)
         java_object = current_env->NewGlobalRef (jobj);
 
       if (jcls)
-        java_class = reinterpret_cast<jclass> (current_env->NewGlobalRef (jcls));
+        java_class = current_env->NewGlobalRef (jcls);
       else if (java_object)
         {
-          jclass_ref ocls (current_env, current_env->GetObjectClass (java_object));
-          java_class = reinterpret_cast<jclass> (current_env->NewGlobalRef (jclass (ocls)));
+          jclass_ref ocls (current_env, current_env->GetObjectClass (TO_JOBJECT (java_object)));
+          java_class = current_env->NewGlobalRef (jclass (ocls));
         }
 
       if (java_class)
         {
-          jclass_ref clsCls (current_env, current_env->GetObjectClass (java_class));
+          jclass_ref clsCls (current_env, current_env->GetObjectClass (TO_JCLASS (java_class)));
           jmethodID mID = current_env->GetMethodID (clsCls, "getCanonicalName", "()Ljava/lang/String;");
-          jobject_ref resObj (current_env, current_env->CallObjectMethod (java_class, mID));
+          jobject_ref resObj (current_env, current_env->CallObjectMethod (TO_JCLASS (java_class), mID));
           java_classname = jstring_to_string (current_env, resObj);
         }
     }
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
 void
 octave_java::release (void)
 {
+#if defined (HAVE_JAVA)
+
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     {
       if (java_object)
-        current_env->DeleteGlobalRef (java_object);
+        current_env->DeleteGlobalRef (TO_JOBJECT (java_object));
 
       if (java_class)
-        current_env->DeleteGlobalRef (java_class);
+        current_env->DeleteGlobalRef (TO_JCLASS (java_class));
 
       java_object = 0;
       java_class = 0;
     }
+
+#else
+  // This shouldn't happen because construction of octave_java
+  // objects is supposed to be impossible if Java is not available.
+
+  panic_impossible ();
+#endif
 }
 
-#endif
-
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
 DEFUN (__java_init__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __java_init__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call initialize_java to create an instance of a JVM.\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
   octave_value retval;
 
   retval = 0;
 
   initialize_java ();
 
   retval = 1;
 
   return retval;
 #else
-  error ("__java_init__: Octave was not compiled with Java interface");
+  err_disabled_feature ("__java_init__", "Java");
 #endif
 }
 
 DEFUN (__java_exit__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __java_exit__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call terminate_jvm to destroy the current JVM\n\
 instance.\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
   terminate_jvm ();
 
   return ovl ();
 
 #else
-  error ("__java_init__: Octave was not compiled with Java interface");
+  error ("__java_init__", "Java");
 #endif
 }
 
 DEFUN (javaObject, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{jobj} =} javaObject (@var{classname})\n\
 @deftypefnx {} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
@@ -2215,35 +2611,37 @@ example supplies an initial argument to 
 x = javaObject (\"java.lang.StringBuffer\")\n\
 x = javaObject (\"java.lang.StringBuffer\", \"Initial string\")\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{javaMethod, javaArray}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
 
   if (args.length () == 0)
     print_usage ();
 
   std::string classname = args(0).xstring_value ("javaObject: CLASSNAME must be a string");
 
   initialize_java ();
 
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   octave_value_list tmp;
   for (int i=1; i<args.length (); i++)
     tmp(i-1) = args(i);
 
   return ovl (octave_java::do_javaObject (current_env, classname, tmp));
 
 #else
-  error ("javaObject: Octave was not compiled with Java interface");
+
+  err_disabled_feature ("javaObject", "Java");
+
 #endif
 }
 
 /*
 ## The tests below merely check if javaObject works at all.  Whether
 ## it works properly, i.e., creates the right values, is a matter of
 ## Java itself.  Create a Short and check if it really is a short, i.e.,
 ## whether it overflows.
@@ -2272,26 +2670,26 @@ equivalent\n\
 @end group\n\
 @end example\n\
 \n\
 @code{javaMethod} returns the result of the method invocation.\n\
 \n\
 @seealso{methods, javaObject}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
 
   if (args.length () < 2)
     print_usage ();
 
   std::string methodname = args(0).xstring_value ("javaMethod: METHODNAME must be a string");
 
   initialize_java ();
 
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   octave_value retval;
 
   octave_value_list tmp;
   for (int i=2; i<args.length (); i++)
     tmp(i-2) = args(i);
 
   if (args(1).is_java ())
@@ -2305,17 +2703,19 @@ equivalent\n\
       retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
     }
   else
     error ("javaMethod: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
-  error ("javaMethod: Octave was not compiled with Java interface");
+
+  err_disabled_feature ("javaMethod", "Java");
+
 #endif
 }
 
 /*
 %!testif HAVE_JAVA
 %! ## Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ("getProperty", "java.lang.System", "java.version"), ".");
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
@@ -2338,26 +2738,26 @@ equivalent\n\
   __java_get__ (x, \"field1\")\n\
   x.field1\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_set__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
 
   if (args.length () != 2)
     print_usage ();
 
   std::string name = args(1).string_value ("__java_get__: NAME must be a string");
 
   initialize_java ();
 
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   octave_value retval;
 
   if (args(0).is_java ())
     {
       octave_java *jobj = TO_JAVA (args(0));
       retval = jobj->do_java_get (current_env, name);
     }
@@ -2367,17 +2767,19 @@ equivalent\n\
       retval = octave_java::do_java_get (current_env, cls, name);
     }
   else
     error ("__java_get__: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
-  error ("__java_get__: Octave was not compiled with Java interface");
+
+  err_disabled_feature ("__java_get__", "Java");
+
 #endif
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
 @var{val}.\n\
@@ -2394,26 +2796,26 @@ equivalent\n\
   __java_set__ (x, \"field1\", val)\n\
   x.field1 = val\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_get__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
 
   if (args.length () != 3)
     print_usage ();
 
   std::string name = args(1).xstring_value ("__java_set__: NAME must be a string");
 
   initialize_java ();
 
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   octave_value retval;
 
   if (args(0).is_java ())
     {
       octave_java *jobj = TO_JAVA (args(0));
       retval = jobj->do_java_set (current_env, name, args(2));
     }
@@ -2423,49 +2825,53 @@ equivalent\n\
       retval = octave_java::do_java_set (current_env, cls, name, args(2));
     }
   else
     error ("__java_set__: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
-  error ("__java_set__: Octave was not compiled with Java interface");
+
+  err_disabled_feature ("__java_set__", "Java");
+
 #endif
 }
 
 DEFUN (java2mat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} java2mat (@var{javaobj})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
 
   if (args.length () != 1)
     print_usage ();
 
   initialize_java ();
 
-  JNIEnv *current_env = octave_java::thread_jni_env ();
+  JNIEnv *current_env = thread_jni_env ();
 
   octave_value_list retval;
 
   if (args(0).is_java ())
     {
       octave_java *jobj = TO_JAVA (args(0));
       retval = ovl (box_more (current_env, jobj->to_java (), 0));
     }
   else
     retval = ovl (args(0));
 
   return retval;
 
 #else
-  error ("java2mat: Octave was not compiled with Java interface");
+
+  err_disabled_feature ("java2mat", "Java");
+
 #endif
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
@@ -2475,20 +2881,20 @@ automatically converted to Octave matric
 The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
   return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
-  error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
+  err_disabled_feature ("java_matrix_autoconversion", "Java");
 #endif
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
@@ -2499,20 +2905,20 @@ When enabled, Java arrays of class Byte 
 of class uint8 or uint32 respectively.  The default value is true.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, debug_java}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
 #else
-  error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
+  err_disabled_feature ("java_unsigned_autoconversion", "Java");
 #endif
 }
 
 DEFUN (debug_java, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} debug_java ()\n\
 @deftypefnx {} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {} {} debug_java (@var{new_val}, \"local\")\n\
@@ -2521,25 +2927,27 @@ information regarding the initialization
 is printed.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
 @end deftypefn")
 {
-#ifdef HAVE_JAVA
+#if defined (HAVE_JAVA)
   return SET_INTERNAL_VARIABLE (debug_java);
 #else
-  error ("debug_java: Octave was not compiled with Java interface");
+  err_disabled_feature ("debug_java", "Java");
 #endif
 }
 
-// Outside of #ifdef HAVE_JAVA because it is desirable to be able to
-// test for the presence of a Java object without having Java installed.
+// Outside of #if defined (HAVE_JAVA) because it is desirable to be able
+// to test for the presence of a Java object without having Java
+// installed.
+
 DEFUN (isjava, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isjava (@var{x})\n\
 Return true if @var{x} is a Java object.\n\
 @seealso{class, typeinfo, isa, javaObject}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -20,129 +20,39 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_ov_java_h)
 #define octave_ov_java_h 1
 
 #include "octave-config.h"
 
-#include <jni.h>
-
 #include <ovl.h>
 #include <ov.h>
 
-template <typename T>
-class java_local_ref
-{
-public:
-
-  java_local_ref (JNIEnv *_env)
-    : jobj (0), detached (false), env (_env) { }
-
-  java_local_ref (JNIEnv *_env, T obj)
-    : jobj (obj), detached (false), env (_env) { }
-
-  ~java_local_ref (void) { release (); }
-
-  T& operator = (T obj)
-  {
-    release ();
-
-    jobj = obj;
-    detached = false;
-
-    return jobj;
-  }
-
-  operator bool () const { return (jobj != 0); }
-  operator T () { return jobj; }
-
-  void detach (void) { detached = true; }
-
-private:
-
-  void release (void)
-  {
-    if (env && jobj && ! detached)
-      env->DeleteLocalRef (jobj);
-
-    jobj = 0;
-  }
-
-  java_local_ref (void)
-    : jobj (0), detached (false), env (0)
-  { }
-
-protected:
-
-  T jobj;
-  bool detached;
-  JNIEnv *env;
-};
-
-typedef java_local_ref<jobject> jobject_ref;
-typedef java_local_ref<jclass> jclass_ref;
-typedef java_local_ref<jstring> jstring_ref;
-typedef java_local_ref<jobjectArray> jobjectArray_ref;
-typedef java_local_ref<jintArray> jintArray_ref;
-typedef java_local_ref<jbyteArray> jbyteArray_ref;
-typedef java_local_ref<jdoubleArray> jdoubleArray_ref;
-typedef java_local_ref<jthrowable> jthrowable_ref;
-
-extern OCTINTERP_API std::string
-jstring_to_string (JNIEnv* jni_env, jstring s);
-
-extern OCTINTERP_API std::string
-jstring_to_string (JNIEnv* jni_env, jobject obj);
-
-extern OCTINTERP_API octave_value
-box (JNIEnv* jni_env, jobject jobj, jclass jcls = 0);
-
-extern OCTINTERP_API octave_value
-box_more (JNIEnv* jni_env, jobject jobj, jclass jcls = 0);
-
-extern OCTINTERP_API bool
-unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
-       jclass_ref& jcls);
-
-extern OCTINTERP_API bool
-unbox (JNIEnv* jni_env, const octave_value_list& args,
-       jobjectArray_ref& jobjs, jobjectArray_ref& jclss);
-
-extern OCTINTERP_API bool Vjava_matrix_autoconversion;
-
-extern OCTINTERP_API bool Vjava_unsigned_autoconversion;
-
-extern OCTINTERP_API bool Vdebug_java;
+typedef void *voidptr;
 
 class OCTINTERP_API octave_java : public octave_base_value
 {
 public:
 
-  octave_java (void)
-    : octave_base_value (), java_object (0), java_class (0)
-  { }
+  octave_java (void);
+
+  octave_java (const voidptr& obj, void *cls = 0);
 
   octave_java (const octave_java& jobj)
     : octave_base_value (jobj), java_object (0), java_class (0)
   {
     init (jobj.java_object, jobj.java_class);
   }
 
-  octave_java (const jobject& obj, jclass cls = 0)
-    : octave_base_value (), java_object (0)
-  {
-    init (obj, cls);
-  }
-
   ~octave_java (void) { release (); }
 
-  jobject to_java (void) const { return java_object; }
-  jclass to_class (void) const { return java_class; }
+  void *to_java (void) const { return java_object; }
+  void *to_class (void) const { return java_class; }
 
   std::string java_class_name (void) const { return java_classname; }
 
   octave_base_value* clone (void) const { return new octave_java (*this); }
   octave_base_value* empty_clone (void) const { return new octave_java (); }
 
   bool is_instance_of (const std::string&) const;
 
@@ -190,95 +100,72 @@ public:
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool is_java_string (void) const;
 
-  static JNIEnv* thread_jni_env (void);
-
-  octave_value do_javaMethod (JNIEnv* jni_env, const std::string& name,
+  octave_value do_javaMethod (void *jni_env, const std::string& name,
                               const octave_value_list& args);
 
   octave_value
-  do_javaMethod (const std::string& name, const octave_value_list& args)
-  {
-    return do_javaMethod (thread_jni_env (), name, args);
-  }
+  do_javaMethod (const std::string& name, const octave_value_list& args);
 
   static octave_value
-  do_javaMethod (JNIEnv* jni_env, const std::string& class_name,
+  do_javaMethod (void *jni_env, const std::string& class_name,
                  const std::string& name, const octave_value_list& args);
 
   static octave_value
   do_javaMethod (const std::string& class_name, const std::string& name,
-                 const octave_value_list& args)
-  {
-    return do_javaMethod (thread_jni_env (), class_name, name, args);
-  }
+                 const octave_value_list& args);
 
   static octave_value
-  do_javaObject (JNIEnv* jni_env, const std::string& name,
+  do_javaObject (void *jni_env, const std::string& name,
                  const octave_value_list& args);
 
   static octave_value
-  do_javaObject (const std::string& name, const octave_value_list& args)
-  {
-    return do_javaObject (thread_jni_env (), name, args);
-  }
+  do_javaObject (const std::string& name, const octave_value_list& args);
 
-  octave_value do_java_get (JNIEnv* jni_env, const std::string& name);
+  octave_value do_java_get (void *jni_env, const std::string& name);
 
-  octave_value do_java_get (const std::string& name)
-  {
-    return do_java_get (thread_jni_env (), name);
-  }
+  octave_value do_java_get (const std::string& name);
 
   static octave_value
-  do_java_get (JNIEnv* jni_env, const std::string& class_name,
+  do_java_get (void *jni_env, const std::string& class_name,
                const std::string& name);
 
   static octave_value
-  do_java_get (const std::string& class_name, const std::string& name)
-  {
-    return do_java_get (thread_jni_env (), class_name, name);
-  }
+  do_java_get (const std::string& class_name, const std::string& name);
 
-  octave_value do_java_set (JNIEnv* jni_env, const std::string& name,
+  octave_value do_java_set (void *jni_env, const std::string& name,
                             const octave_value& val);
 
-  octave_value do_java_set (const std::string& name, const octave_value& val)
-  {
-    return do_java_set (thread_jni_env (), name, val);
-  }
+  octave_value do_java_set (const std::string& name, const octave_value& val);
 
   static octave_value
-  do_java_set (JNIEnv* jni_env, const std::string& class_name,
+  do_java_set (void *jni_env, const std::string& class_name,
                const std::string& name, const octave_value& val);
 
   static octave_value
   do_java_set (const std::string& class_name, const std::string& name,
-               const octave_value& val)
-  {
-    return do_java_set (thread_jni_env (), class_name, name, val);
-  }
+               const octave_value& val);
 
 private:
 
-  void init (jobject jobj, jclass jcls);
+  void init (void *jobj, void *jcls);
 
   void release (void);
 
 private:
 
-  jobject java_object;
+  void *java_object;
 
-  jclass java_class;
+  void *java_class;
 
   std::string java_classname;
 
 public:
 
   int type_id (void) const { return t_id; }
   std::string type_name (void) const { return t_name; }
   std::string class_name (void) const { return java_classname; }
@@ -289,9 +176,15 @@ public:
   static void register_type (void);
 
 private:
 
   static int t_id;
   static const std::string t_name;
 };
 
+extern OCTINTERP_API bool Vjava_matrix_autoconversion;
+
+extern OCTINTERP_API bool Vjava_unsigned_autoconversion;
+
+extern OCTINTERP_API bool Vdebug_java;
+
 #endif
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -72,19 +72,17 @@ along with Octave; see the file COPYING.
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-fcn-inline.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ov-lazy-idx.h"
-#ifdef HAVE_JAVA
-#  include "ov-java.h"
-#endif
+#include "ov-java.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "symtab.h"
@@ -2699,19 +2697,17 @@ install_types (void)
   octave_float_complex_matrix::register_type ();
   octave_float_complex_diag_matrix::register_type ();
   octave_perm_matrix::register_type ();
   octave_null_matrix::register_type ();
   octave_null_str::register_type ();
   octave_null_sq_str::register_type ();
   octave_lazy_index::register_type ();
   octave_oncleanup::register_type ();
-#ifdef HAVE_JAVA
   octave_java::register_type ();
-#endif
 }
 
 DEFUN (sizeof, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
