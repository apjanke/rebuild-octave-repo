# HG changeset patch
# User jwe
# Date 810331641 0
#      Tue Sep 05 20:07:21 1995 +0000
# Node ID 94697d007075a9ea64dc2613c2ef8b2b703f8532
# Parent  5b54091471dd3e295d7e54ae18730ce644daac62
[project @ 1995-09-05 20:04:15 by jwe]

diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -56,36 +56,37 @@ DLD_SRC := f-balance.cc f-chol.cc f-coll
 	f-qzval.cc f-rand.cc f-schur.cc f-sort.cc f-svd.cc f-syl.cc
 
 DLD_OBJ := $(patsubst %.cc, %.o, $(DLD_SRC))
 
 INCLUDES := arith-ops.h builtins.h defaults.h.in defun.h defun-dld.h \
 	defun-int.h dirfns.h dynamic-ld.h error.h file-io.h fnmatch.h \
 	getopt.h gripes.h help.h idx-vector.h input.h lex.h \
 	load-save.h mappers.h missing-math.h octave.h octave-hist.h \
-	oct-map.h oct-obj.h pager.h parse.h pathsearch.h pr-output.h \
-	procstream.h sighandlers.h statdefs.h symtab.h sysdep.h \
-	systime.h token.h tree-base.h tree-cmd.h tree-const.h \
-	tree-expr.h tree-misc.h	tree-plot.h tc-inlines.h tc-rep.h \
-	unwind-prot.h user-prefs.h utils.h variables.h version.h \
-	xdiv.h xpow.h Map.h SLStack.h Stack.h
+	oct-map.h oct-obj.h oct-str.h pager.h parse.h pathlen.h \
+	pathsearch.h pr-output.h procstream.h sighandlers.h \
+	statdefs.h symtab.h sysdep.h sysdir.h systime.h syswait.h \
+	token.h tree-base.h tree-cmd.h tree-const.h tree-expr.h \
+	tree-misc.h tree-plot.h tc-inlines.h tc-rep.h unwind-prot.h \
+	user-prefs.h utils.h variables.h version.h xdiv.h xpow.h \
+	Map.h SLStack.h Stack.h 
 
-TI_SRC := Array-tc.cc Map-tc.cc DLList-fi.cc \
+TI_SRC := Array-string.cc Array-tc.cc Map-tc.cc DLList-fi.cc \
 	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-tc.cc \
 	SLStack-i.cc SLStack-pc.cc SLStack-sym.cc SLStack-tok.cc \
 	SLStack-tm.cc SLStack-ue.cc SLStack-ui.cc
 
 TI_OBJ := $(patsubst %.cc, %.o, $(TI_SRC))
 
 SOURCES := acosh.c arith-ops.cc asinh.c atanh.c data.cc dirfns.cc \
 	dynamic-ld.cc erf.c erfc.c error.cc file-io.cc fnmatch.c \
 	getopt.c getopt1.c gripes.cc help.cc idx-vector.cc \
 	input.cc lex.l load-save.cc mappers.cc octave.cc \
-	octave-hist.cc oct-map.cc oct-obj.cc pager.cc parse.y \
-	pr-output.cc procstream.cc resource.cc sighandlers.cc \
+	octave-hist.cc oct-map.cc oct-obj.cc oct-str.cc pager.cc \
+	parse.y pr-output.cc procstream.cc resource.cc sighandlers.cc \
 	strcasecmp.c strncase.c strfns.cc strftime.c symtab.cc \
 	sysdep.cc tempname.c timefns.cc tempnam.c token.cc \
 	tree-base.cc tree-cmd.cc tree-const.cc tree-expr.cc \
 	tree-misc.cc tree-plot.cc unwind-prot.cc user-prefs.cc \
 	utils.cc variables.cc xdiv.cc xpow.cc Map.cc SLStack.cc
 
 TEMPLATE_SRC = Map.cc SLStack.cc
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -39,65 +39,39 @@ Free Software Foundation, Inc.
 #endif
 
 #include <cerrno>
 #include <cstdio>
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
 
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
 #include <strstream.h>
-#include <sys/param.h>
 
-// This mess suggested by the autoconf manual.
-// unistd.h defines _POSIX_VERSION on POSIX.1 systems.
-#if defined (HAVE_DIRENT_H) || defined (_POSIX_VERSION)
-#include <dirent.h>
-#define NLENGTH(dirent) (strlen((dirent)->d_name))
-#else
-#define dirent direct
-#define NLENGTH(dirent) ((dirent)->d_namlen)
-#if defined (HAVE_SYS_NDIR_H)
-#include <sys/ndir.h>
-#endif
-#if defined (HAVE_SYS_DIR_H)
-#include <sys/dir.h>
-#endif
-#if defined (HAVE_NDIR_H)
-#include <ndir.h>
-#endif
-#endif
-
+#include "defun.h"
+#include "dirfns.h"
+#include "error.h"
+#include "oct-obj.h"
+#include "octave.h"
+#include "pager.h"
+#include "pathlen.h"
+#include "procstream.h"
 #include "statdefs.h"
-#include "procstream.h"
+#include "sysdep.h"
+#include "sysdir.h"
 #include "tree-const.h"
 #include "tree-plot.h"
-#include "oct-obj.h"
-#include "sysdep.h"
-#include "octave.h"
-#include "dirfns.h"
-#include "pager.h"
-#include "error.h"
 #include "utils.h"
-#include "defun.h"
 
 extern "C"
 {
 #include <readline/tilde.h>
 extern char *strerror (int);
 }
 
-#ifndef MAXPATHLEN
-#define MAXPATHLEN 1024
-#endif
-
 // Temp storage for a path.
 static char tdir[MAXPATHLEN];
 
 // Non-zero means follow symbolic links that point to directories just
 // as if they are real directories.
 static int follow_symbolic_links = 1;
 
 // Non-zero means that pwd always give verbatim directory, regardless
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -33,33 +33,33 @@ Software Foundation, 59 Temple Place - S
 
 #include <cctype>
 #include <cstring>
 
 #include <strstream.h>
 
 #include "SLStack.h"
 
+#include "error.h"
 #include "input.h"
-#include "token.h"
-#include "user-prefs.h"
-#include "variables.h"
+#include "lex.h"
 #include "octave.h"
+#include "parse.h"
 #include "symtab.h"
-#include "error.h"
-#include "utils.h"
+#include "token.h"
 #include "tree-base.h"
+#include "tree-cmd.h"
+#include "tree-const.h"
 #include "tree-expr.h"
-#include "tree-cmd.h"
 #include "tree-misc.h"
 #include "tree-plot.h"
-#include "tree-const.h"
+#include "user-prefs.h"
+#include "utils.h"
+#include "variables.h"
 #include "y.tab.h"
-#include "parse.h"
-#include "lex.h"
 
 // Stack to hold tokens so that we can delete them when the parser is
 // reset and avoid growing forever just because we are stashing some
 // information.  This has to appear before lex.h is included, because
 // one of the macros defined there uses token_stack.
 static SLStack <token*> token_stack;
 
 // Nonzero means we think we are looking at a set command.
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -22,65 +22,65 @@ Software Foundation, 59 Temple Place - S
 */
 
 // Born February 20, 1992.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <cassert>
+#include <csetjmp>
+#include <csignal>
+#include <cstdlib>
+#include <cstring>
+#include <ctime>
+
+#include <fstream.h>
+#include <iostream.h>
+#include <strstream.h>
+
+#ifdef HAVE_UNISTD_H
 #include <sys/types.h>
-#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#include <sys/stat.h>
-#include <time.h>
+
 #include <pwd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include <assert.h>
-#include <iostream.h>
-#include <strstream.h>
-#include <fstream.h>
-
-extern "C"
-{
-#include <setjmp.h>
-}
 
 #include "getopt.h"
 
 #include "lo-error.h"
 
-#include "sighandlers.h"
-#include "variables.h"
-#include "error.h"
+#include "builtins.h"
+#include "defaults.h"
+#include "defun.h"
 #include "dynamic-ld.h"
-#include "tree-misc.h"
-#include "tree-const.h"
-#include "tree-plot.h"
-#include "utils.h"
+#include "error.h"
+#include "file-io.h"
+#include "help.h"
 #include "input.h"
-#include "pager.h"
 #include "lex.h"
-#include "help.h"
+#include "oct-str.h"
+#include "octave-hist.h"
 #include "octave.h"
+#include "pager.h"
 #include "parse.h"
-#include "defaults.h"
-#include "user-prefs.h"
+#include "pathsearch.h"
 #include "procstream.h"
+#include "sighandlers.h"
+#include "statdefs.h"
+#include "sysdep.h"
+#include "tree-const.h"
+#include "tree-misc.h"
+#include "tree-plot.h"
 #include "unwind-prot.h"
-#include "octave-hist.h"
-#include "pathsearch.h"
-#include "builtins.h"
+#include "user-prefs.h"
+#include "utils.h"
+#include "variables.h"
 #include "version.h"
-#include "file-io.h"
-#include "sysdep.h"
-#include "defun.h"
 
 #if !defined (HAVE_ATEXIT) && defined (HAVE_ON_EXIT)
 extern "C" { int on_exit (); }
 #define atexit on_exit
 #endif
 
 // argv[0] for this program.
 char *raw_prog_name = 0;
@@ -127,16 +127,19 @@ int quitting_gracefully = 0;
 tree_statement_list *global_command = 0;
 
 // Pointer to function that is currently being evaluated.
 tree_function *curr_function = 0;
 
 // Nonzero means input is coming from startup file.
 int input_from_startup_file = 0;
 
+// The command-line options.
+Octave_str_obj octave_argv;
+
 // Top level context (?)
 jmp_buf toplevel;
 
 // This is not really the right place to do this...
 typedef void (*one_arg_error_handler_t) (const char*);
 extern one_arg_error_handler_t set_Complex_error_handler
   (one_arg_error_handler_t f);
 
@@ -185,21 +188,43 @@ static struct option long_opts[] =
     { "quiet",            no_argument,       0, 'q' },
     { "silent",           no_argument,       0, 'q' },
     { "verbose",          no_argument,       0, 'V' },
     { "version",          no_argument,       0, 'v' },
     { "echo-commands",    no_argument,       0, 'x' },
     { 0,                  0,                 0, 0 }
   };
 
+// Store the command-line options for later use.
+
+static void
+intern_argv (int argc, char **argv)
+{
+  if (argc > 1)
+    {
+      octave_argv.resize (argc-1);
+      for (int i = 1; i < argc; i++)
+	octave_argv.elem (i-1) = argv[i];
+    }
+
+  tree_constant *tmp = new tree_constant (octave_argv);
+  bind_builtin_variable ("argv", tmp, 1, 1, 0);
+}
+
 // Initialize some global variables for later use.
 
 static void
 initialize_globals (char *name)
 {
+  raw_prog_name = strsave (name);
+  char *tmp = strrchr (raw_prog_name, '/');
+  prog_name = tmp ? strsave (tmp+1) : strsave (raw_prog_name);
+
+  kpse_set_progname (name);
+
   struct passwd *entry = getpwuid (getuid ());
   if (entry)
     user_name = strsave (entry->pw_name);
   else
     user_name = strsave ("I have no name!");
   endpwent ();
 
   char hostname[256];
@@ -255,21 +280,16 @@ initialize_globals (char *name)
 	  putenv_cmd = new char [len];
 	  sprintf (putenv_cmd, "TEXMF=%s/lib/octave", oh);
 	  putenv (putenv_cmd);
 	}
       else  
 	putenv (strsave ("TEXMF=" OCTAVE_DATADIR "/octave"));
     }
 
-  raw_prog_name = strsave (name);
-  prog_name = strsave ("octave");
-
-  kpse_set_progname (name);
-
   load_path = default_path ();
 
   info_file = default_info_file ();
 
   editor = default_editor ();
 }
 
 void
@@ -473,17 +493,17 @@ initialize_error_handlers ()
   set_liboctave_error_handler (error);
 }
 
 // You guessed it.
 
 int
 main (int argc, char **argv)
 {
-// The order of these calls is important, and initialize globals must
+// The order of these calls is important, and initialize_globals must
 // come before the options are processed because some command line
 // options override defaults.
 
   init_user_prefs ();
 
   initialize_pager ();
 
   sysdep_init ();
@@ -582,43 +602,48 @@ main (int argc, char **argv)
 
   if (! inhibit_startup_message && reading_startup_message_printed)
     cout << endl;
 
 // Avoid counting commands executed from startup files.
   current_command_number = 1;
 
 // If there is an extra argument, see if it names a file to read.
+// Additional arguments are taken as command line options for the
+// script.
 
   int remaining_args = argc - optind;
-  if (remaining_args > 1)
+  if (remaining_args > 0)
     {
-      usage ();
-    }
-  else if (remaining_args == 1)
-    {
+      if (remaining_args == 1)
+	intern_argv (argc, argv);
+      else
+	intern_argv (remaining_args, argv+optind);
+
       reading_script_file = 1;
       curr_fcn_file_name = argv[optind];
       FILE *infile = get_input_from_file (curr_fcn_file_name);
       if (infile)
 	{
 	  rl_blink_matching_paren = 0;
 	  switch_to_buffer (create_buffer (infile));
 	}
       else
 	clean_up_and_exit (1);
     }
   else
     {
-      switch_to_buffer (create_buffer (get_input_from_stdin ()));
-
-// Is input coming from a terminal?  If so, we are probably
-// interactive.
+      // Is input coming from a terminal?  If so, we are probably
+      // interactive.
 
       interactive = (isatty (fileno (stdin)) && isatty (fileno (stdout)));
+
+      intern_argv (argc, argv);
+
+      switch_to_buffer (create_buffer (get_input_from_stdin ()));
     }
 
 // Force input to be echoed if not really interactive, but the user
 // has forced interactive behavior.
 
   if (!interactive && forced_interactive)
     {
       rl_blink_matching_paren = 0;
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -25,32 +25,36 @@ Software Foundation, 59 Temple Place - S
 #define octave_pr_output_h 1
 
 class ostream;
 
 class Matrix;
 class Complex;
 class ComplexMatrix;
 class Range;
+class Octave_str_obj;
 
 extern void octave_print_internal (ostream& os, double d,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Matrix& m,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Complex& c,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const ComplexMatrix& cm,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const Range& r,
 				   int pr_as_read_syntax = 0);
 
+extern void octave_print_internal (ostream& os, Octave_str_obj& s,
+				   int pr_as_read_syntax = 0);
+
 extern void set_format_style (int argc, char **argv);
 
 // XXX FIXME XXX -- these should probably be somewhere else.
 
 extern int any_element_is_inf_or_nan (const Matrix& a);
 
 extern int any_element_is_inf_or_nan (const ComplexMatrix& a);
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -24,26 +24,28 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <string.h>
+#include <cstring>
+
 #include <iostream.h>
 #include <strstream.h>
 
-#include "tree-const.h"
-#include "user-prefs.h"
-#include "pager.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
+#include "oct-str.h"
+#include "pager.h"
+#include "tree-const.h"
+#include "user-prefs.h"
 
 // The following three variables could be made static members of the
 // tree_constant class.
 
 // Pointer to the blocks of memory we manage.
 static tree_constant *tc_newlist = 0;
 
 // Multiplier for allocating new blocks.
@@ -305,17 +307,17 @@ tree_constant::print_code (ostream& os)
 }
 
 int
 print_as_scalar (const tree_constant& val)
 {
   int nr = val.rows ();
   int nc = val.columns ();
   return (val.is_scalar_type ()
-	  || val.is_string ()
+	  || (val.is_string () && nr <= 1)
 	  || (val.is_matrix_type ()
 	      && ((nr == 1 && nc == 1)
 		  || nr == 0
 		  || nc == 0)));
 }
 
 int
 print_as_structure (const tree_constant& val)
@@ -358,18 +360,19 @@ vector_of_empties (int nargout, const ch
 // out again, should we want to do that.
 //
 // -------------------------------------------------------------------
 
 // #ifdef HAVE_CONFIG_H
 // #include <config.h>
 // #endif
 
-#include <ctype.h>
-// #include <string.h>
+#include <cctype>
+// #include <cstring>
+
 #include <fstream.h>
 // #include <iostream.h>
 
 #include "mx-base.h"
 #include "Range.h"
 
 #include "arith-ops.h"
 #include "variables.h"
@@ -639,17 +642,24 @@ TC_REP::tree_constant_rep (const Complex
 	  type_tag = complex_matrix_constant;
 	}
     }
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const char *s)
 {
-  string = strsave (s);
+  str_obj = new Octave_str_obj (s);
+  type_tag = string_constant;
+  orig_text = 0;
+}
+
+TC_REP::tree_constant_rep (const Octave_str_obj& s)
+{
+  str_obj = new Octave_str_obj (s);
   type_tag = string_constant;
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
@@ -737,17 +747,17 @@ TC_REP::tree_constant_rep (const tree_co
       scalar = t.scalar;
       break;
 
     case matrix_constant:
       matrix = new Matrix (*(t.matrix));
       break;
 
     case string_constant:
-      string = strsave (t.string);
+      str_obj = new Octave_str_obj (*(t.str_obj));
       break;
 
     case complex_matrix_constant:
       complex_matrix = new ComplexMatrix (*(t.complex_matrix));
       break;
 
     case complex_scalar_constant:
       complex_scalar = new Complex (*(t.complex_scalar));
@@ -781,17 +791,17 @@ TC_REP::~tree_constant_rep (void)
       delete complex_scalar;
       break;
 
     case complex_matrix_constant:
       delete complex_matrix;
       break;
 
     case string_constant:
-      delete [] string;
+      delete str_obj;
       break;
 
     case range_constant:
       delete range;
       break;
 
     case map_constant:
       delete a_map;
@@ -846,16 +856,19 @@ TC_REP::rows (void) const
   switch (type_tag)
     {
     case scalar_constant:
     case complex_scalar_constant:
       retval = 1;
       break;
 
     case string_constant:
+      retval = str_obj->num_strings ();
+      break;
+
     case range_constant:
       retval = (columns () > 0);
       break;
 
     case matrix_constant:
       retval = matrix->rows ();
       break;
 
@@ -886,17 +899,17 @@ TC_REP::columns (void) const
       retval = matrix->columns ();
       break;
 
     case complex_matrix_constant:
       retval = complex_matrix->columns ();
       break;
 
     case string_constant:
-      retval = strlen (string);
+      retval = str_obj->max_length ();
       break;
 
     case range_constant:
       retval = range->nelem ();
       break;
 
     default:
       break;
@@ -921,41 +934,29 @@ TC_REP::all (void) const
 	return retval;
 
       return tmp.all ();
     }
 
   switch (type_tag)
     {
     case scalar_constant:
-      {
-	double status = (scalar != 0.0);
-	retval = tree_constant (status);
-      }
+      retval = (double) (scalar != 0.0);
       break;
 
     case matrix_constant:
-      {
-	Matrix m = matrix->all ();
-	retval = tree_constant (m);
-      }
+      retval = matrix->all ();
       break;
 
     case complex_scalar_constant:
-      {
-	double status = (*complex_scalar != 0.0);
-	retval = tree_constant (status);
-      }
+      retval = (double) (*complex_scalar != 0.0);
       break;
 
     case complex_matrix_constant:
-      {
-	Matrix m = complex_matrix->all ();
-	retval = tree_constant (m);
-      }
+      retval = complex_matrix->all ();
       break;
 
     default:
       gripe_wrong_type_arg ("all", *this);
       break;
     }
 
   return retval;
@@ -977,41 +978,29 @@ TC_REP::any (void) const
 	return retval;
 
       return tmp.any ();
     }
 
   switch (type_tag)
     {
     case scalar_constant:
-      {
-	double status = (scalar != 0.0);
-	retval = tree_constant (status);
-      }
+      retval = (double) (scalar != 0.0);
       break;
 
     case matrix_constant:
-      {
-	Matrix m = matrix->any ();
-	retval = tree_constant (m);
-      }
+      retval = matrix->any ();
       break;
 
     case complex_scalar_constant:
-      {
-	double status = (*complex_scalar != 0.0);
-	retval = tree_constant (status);
-      }
+      retval = (double) (*complex_scalar != 0.0);
       break;
 
     case complex_matrix_constant:
-      {
-	Matrix m = complex_matrix->any ();
-	retval = tree_constant (m);
-      }
+      retval = complex_matrix->any ();
       break;
 
     default:
       gripe_wrong_type_arg ("any", *this);
       break;
     }
 
   return retval;
@@ -1157,19 +1146,21 @@ TC_REP::double_value (int force_string_c
       {
 	int flag = force_string_conversion;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real scalar");
 
-	int len = strlen (string);
-	if (flag && (len == 1 || (len > 1 && user_pref.do_fortran_indexing)))
-	  retval = toascii ((int) string[0]);
+	int len = str_obj->max_length ();
+	if (flag
+	    && ((str_obj->num_strings () == 1 && len == 1)
+		|| (len > 1 && user_pref.do_fortran_indexing)))
+	  retval = toascii ((int) str_obj->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "real scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1230,27 +1221,34 @@ TC_REP::matrix_value (int force_string_c
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "real matrix");
 
 	if (flag)
 	  {
-	    int len = strlen (string);
-
-	    if (len > 0)
+	    int nr = str_obj->num_strings ();
+	    int nc = str_obj->max_length ();
+
+	    if (nr > 0 && nc > 0)
 	      {
-		retval.resize (1, len);
-
-		for (int i = 0; i < len; i++)
-		  retval.elem (0, i) = toascii ((int) string[i]);
+		retval.resize (nr, nc);
+
+		for (int i = 0; i < nr; i++)
+		  {
+		    for (int j = 0; j < nc; j++)
+		      {
+			int c = (int) str_obj->elem (i, j);
+			retval.elem (i, j) = toascii (c);
+		      }
+		  }
 	      }
 	    else
-	      retval = Matrix ();
+	      retval = Matrix ();  // XXX FIXME XXX -- is this correct?
 	  }
 	else
 	  gripe_invalid_conversion ("string", "real matrix");
       }
       break;
 
     case range_constant:
       retval = range->matrix_value ();
@@ -1298,19 +1296,21 @@ TC_REP::complex_value (int force_string_
       {
 	int flag = force_string_conversion;
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex scalar");
 
-	int len = strlen (string);
-	if (flag && (len == 1 || (len > 1 && user_pref.do_fortran_indexing)))
-	  retval = toascii ((int) string[0]);
+	int len = str_obj->max_length ();
+	if (flag
+	    && ((str_obj->num_strings () == 1 && len == 1)
+		|| (len > 1 && user_pref.do_fortran_indexing)))
+	  retval = toascii ((int) str_obj->elem (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "complex scalar");
       }
       break;
 
     case range_constant:
       {
 	int nel = range->nelem ();
@@ -1358,27 +1358,32 @@ TC_REP::complex_matrix_value (int force_
 	if (! flag)
 	  flag = user_pref.implicit_str_to_num_ok;
 
 	if (flag < 0)
 	  warn_implicit_conversion ("string", "complex matrix");
 
 	if (flag)
 	  {
-	    int len = strlen (string);
-
-	    retval.resize (1, len);
-
-	    if (len > 1)
+	    int nr = str_obj->num_strings ();
+	    int nc = str_obj->max_length ();
+
+	    if (nr > 0 && nc > 0)
 	      {
-		for (int i = 0; i < len; i++)
-		  retval.elem (0, i) = toascii ((int) string[i]);
+		retval.resize (nr, nc);
+
+		for (int i = 0; i < nr; i++)
+		  {
+		    for (int j = 0; j < nc; j++)
+		      {
+			int c = (int) str_obj->elem (i, j);
+			retval.elem (i, j) = toascii (c);
+		      }
+		  }
 	      }
-	    else if (len == 1)
-	      retval.elem (0, 0) = toascii ((int) string[0]);
 	    else
 	      panic_impossible ();
 	  }
 	else
 	  gripe_invalid_conversion ("string", "real matrix");
       }
       break;
 
@@ -1389,21 +1394,33 @@ TC_REP::complex_matrix_value (int force_
     default:
       gripe_invalid_conversion (type_as_string (), "complex matrix");
       break;
     }
 
   return retval;
 }
 
-char *
+Octave_str_obj
+TC_REP::all_strings (void) const
+{
+  if (type_tag == string_constant)
+    return *str_obj;
+  else
+    {
+      gripe_invalid_conversion (type_as_string (), "string");
+      return 0;
+    }
+}
+
+const char *
 TC_REP::string_value (void) const
 {
   if (type_tag == string_constant)
-    return string;
+    return str_obj->elem (0).c_str ();  // XXX FIXME??? XXX
   else
     {
       gripe_invalid_conversion (type_as_string (), "string");
       return 0;
     }
 }
 
 Range
@@ -1548,61 +1565,72 @@ TC_REP::convert_to_str (void) const
 	  }
 	else
 	  {
 	    int i = NINT (d);
 // Warn about out of range conversions?
 	    char s[2];
 	    s[0] = (char) i;
 	    s[1] = '\0';
-	    retval = tree_constant (s);
+	    retval = s;
 	  }
       }
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
 	if (rows () == 0 && columns () == 0)
 	  {
 	    char s = '\0';
-	    retval = tree_constant (&s);
+	    retval = &s;
 	  }
 	else
 	  {
-	    ColumnVector v = vector_value ();
-	    int len = v.length ();
-	    if (len == 0)
+	    Matrix m = matrix_value ();
+
+	    int nr = m.rows ();
+	    int nc = m.columns ();
+
+	    if (nr == 0 || nc == 0)
 	      {
 		char s = '\0';
-		retval = tree_constant (&s);
+		retval = &s;
 	      }
 	    else
 	      {
-		char *s = new char [len+1];
-		s[len] = '\0';
-		for (int i = 0; i < len; i++)
+		Octave_str_obj s (nr);
+
+		for (int i = 0; i < nr; i++)
 		  {
-		    double d = v.elem (i);
-
-		    if (xisnan (d))
+		    char buf[nc+1];
+		    buf[nc] = '\0';
+
+		    for (int j = 0; j < nc; j++)
 		      {
-			::error ("invalid conversion from NaN to character");
-			delete [] s;
-			return retval;
+			double d = m.elem (i, j);
+
+			if (xisnan (d))
+			  {
+			    ::error ("invalid conversion from NaN to character");
+			    return retval;
+			  }
+			else
+			  {
+			    // Warn about out of range conversions?
+
+			    int ival = NINT (d);
+			    buf[j] = (char) ival;
+			  }
 		      }
-		    else
-		      {
-			int ival = NINT (d);
-// Warn about out of range conversions?
-			s[i] = (char) ival;
-		      }
+
+		    s.elem (i).assign (buf, nc);
 		  }
-		retval = tree_constant (s);
-		delete [] s;
+
+		retval = s;
 	      }
 	  }
       }
       break;
 
     case range_constant:
       {
 	Range r = range_value ();
@@ -1623,23 +1651,23 @@ TC_REP::convert_to_str (void) const
 	      }
 	    else
 	      {
 		int ival = NINT (d);
 // Warn about out of range conversions?
 		s[i] = (char) ival;
 	      }
 	  }
-	retval = tree_constant (s);
+	retval = s;
 	delete [] s;
       }
       break;
 
     case string_constant:
-      retval = string;
+      retval = *str_obj;
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "string");
       break;
     }
 
   return retval;
@@ -1714,41 +1742,51 @@ TC_REP::force_numeric (int force_str_con
     case complex_scalar_constant:
     case complex_matrix_constant:
       break;
 
     case string_constant:
       {
 	if (! force_str_conv && ! user_pref.implicit_str_to_num_ok)
 	  {
-	    ::error ("failed to convert `%s' to a numeric type --", string);
+	    ::error ("failed to convert `%s' to a numeric type --", str_obj);
 	    ::error ("default conversion turned off");
 
 	    return;
 	  }
 
-	int len = strlen (string);
-	if (len > 1)
-	  {
-	    type_tag = matrix_constant;
-	    Matrix *tm = new Matrix (1, len);
-	    for (int i = 0; i < len; i++)
-	      tm->elem (0, i) = toascii ((int) string[i]);
-	    matrix = tm;
-	  }
-	else if (len == 1)
+	int nr = str_obj->num_strings ();
+	int nc = str_obj->max_length ();
+
+	if (nr == 1 && nc == 1)
 	  {
 	    type_tag = scalar_constant;
-	    scalar = toascii ((int) string[0]);
+	    scalar = toascii ((int) str_obj->elem (0, 0));
 	  }
-	else if (len == 0)
+	else if (nr == 0 || nc == 0)
 	  {
 	    type_tag = matrix_constant;
 	    matrix = new Matrix (0, 0);
 	  }
+	else if (nr > 0 && nc > 0)
+	  {
+	    type_tag = matrix_constant;
+
+	    Matrix *tm = new Matrix (nr, nc);
+
+	    for (int i = 0; i < nr; i++)
+	      {
+		for (int j = 0; j < nc; j++)
+		  {
+		    int c = (int) str_obj->elem (i, j);
+		    tm->elem (i, j) = toascii (c);
+		  }
+	      }
+	    matrix = tm;
+	  }
 	else
 	  panic_impossible ();
       }
       break;
 
     case range_constant:
       {
 	int len = range->nelem ();
@@ -1779,38 +1817,38 @@ TC_REP::force_numeric (int force_str_con
 tree_constant
 TC_REP::make_numeric (int force_str_conv) const
 {
   tree_constant retval;
 
   switch (type_tag)
     {
     case scalar_constant:
-      retval = tree_constant (scalar);
+      retval = scalar;
       break;
 
     case matrix_constant:
-      retval = tree_constant (*matrix);
+      retval = *matrix;
       break;
 
     case complex_scalar_constant:
-      retval = tree_constant (*complex_scalar);
+      retval = *complex_scalar;
       break;
 
     case complex_matrix_constant:
-      retval = tree_constant (*complex_matrix);
+      retval = *complex_matrix;
       break;
 
     case string_constant:
-      retval = tree_constant (string);
+      retval = *str_obj;
       retval.force_numeric (force_str_conv);
       break;
 
     case range_constant:
-      retval = tree_constant (*range);
+      retval = *range;
       retval.force_numeric (force_str_conv);
       break;
 
     default:
       gripe_invalid_conversion (type_as_string (), "numeric value");
       break;
     }
 
@@ -2102,17 +2140,17 @@ TC_REP::print (ostream& output_buf)
       octave_print_internal (output_buf, *complex_scalar);
       break;
 
     case complex_matrix_constant:
       octave_print_internal (output_buf, *complex_matrix);
       break;
 
     case string_constant:
-      output_buf << string << "\n";
+      octave_print_internal (output_buf, *str_obj);
       break;
 
     case range_constant:
       octave_print_internal (output_buf, *range);
       break;
 
     case map_constant:
       {
@@ -2195,23 +2233,17 @@ TC_REP::print_code (ostream& os)
       }
       break;
 
     case complex_matrix_constant:
       octave_print_internal (os, *complex_matrix, 1);
       break;
 
     case string_constant:
-      {
-	os << "\"";
-	char *s, *t = string;
-	while ((s = undo_string_escape (*t++)))
-	  os << s;
-	os << "\"";
-      }
+      octave_print_internal (os, *str_obj, 1);
       break;
 
     case range_constant:
       octave_print_internal (os, *range, 1);
       break;
 
     case magic_colon:
       os << ":";
@@ -2507,18 +2539,19 @@ do_unary_op (tree_constant& a, tree_expr
 // out again, should we want to do that.
 //
 // -------------------------------------------------------------------
 
 // #ifdef HAVE_CONFIG_H
 // #include <config.h>
 // #endif
 
-// #include <ctype.h>
-// #include <string.h>
+// #include <cctype>
+// #include <cstring>
+
 // #include <fstream.h>
 // #include <iostream.h>
 // #include <strstream.h>
 
 // #include "mx-base.h"
 // #include "Range.h"
 
 // #include "arith-ops.h"
@@ -2859,17 +2892,17 @@ TC_REP::do_matrix_index (const tree_cons
 	Matrix mi = tmp_i.matrix_value ();
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "row", rows ());
 	if (! iv)
 	  return tree_constant ();
 
 	if (iv.length () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  retval = do_matrix_index (iv, j_arg);
       }
       break;
 
     case string_constant:
       gripe_string_invalid ();
@@ -2975,17 +3008,17 @@ TC_REP::fortran_style_matrix_index (cons
 
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	if (mi.rows () == 0 || mi.columns () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 // Yes, we really do want to call this with mi.
 	    retval = fortran_style_matrix_index (mi);
 	  }
       }
       break;
@@ -3181,17 +3214,17 @@ TC_REP::do_vector_index (const tree_cons
 
     case complex_matrix_constant:
     case matrix_constant:
       {
         Matrix mi = tmp_i.matrix_value ();
 	if (mi.rows () == 0 || mi.columns () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 	    idx_vector iv (mi, user_pref.do_fortran_indexing, "", len);
 	    if (! iv)
 	      return tree_constant ();
 
 	    if (swap_indices)
@@ -3302,17 +3335,17 @@ TC_REP::do_matrix_index (int i, const tr
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (! jv)
 	  return tree_constant ();
 
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 	    if (range_max_check (i, jv.max (), nr, nc) < 0)
 	      return tree_constant ();
 	    retval = do_matrix_index (i, jv);
 	  }
       }
@@ -3399,17 +3432,17 @@ TC_REP::do_matrix_index (const idx_vecto
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (! jv)
 	  return tree_constant ();
 
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 	    if (range_max_check (iv.max (), jv.max (), nr, nc) < 0)
 	      return tree_constant ();
 	    retval = do_matrix_index (iv, jv);
 	  }
       }
@@ -3492,17 +3525,17 @@ TC_REP::do_matrix_index (const Range& ri
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (! jv)
 	  return tree_constant ();
 
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 	    if (range_max_check (tree_to_mat_idx (ri.max ()),
 				 jv.max (), nr, nc) < 0)
 	      return tree_constant ();
 	    retval = do_matrix_index (ri, jv);
 	  }
@@ -3592,17 +3625,17 @@ TC_REP::do_matrix_index (TC_REP::constan
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (! jv)
 	  return tree_constant ();
 
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
+	    retval = mtmp;
 	  }
 	else
 	  {
 	    if (range_max_check (0, jv.max (), nr, nc) < 0)
 	      return tree_constant ();
 	    retval = do_matrix_index (magic_colon, jv);
 	  }
       }
@@ -3647,19 +3680,19 @@ TC_REP::do_matrix_index (TC_REP::constan
 }
 
 tree_constant
 TC_REP::do_matrix_index (int i, int j) const
 {
   tree_constant retval;
 
   if (type_tag == matrix_constant)
-    retval = tree_constant (matrix->elem (i, j));
+    retval = matrix->elem (i, j);
   else
-    retval = tree_constant (complex_matrix->elem (i, j));
+    retval = complex_matrix->elem (i, j);
 
   return retval;
 }
 
 tree_constant
 TC_REP::do_matrix_index (int i, const idx_vector& jv) const
 {
   tree_constant retval;
@@ -4043,17 +4076,17 @@ TC_REP::do_matrix_index (TC_REP::constan
       retval = *matrix;
       break;
 
     case range_constant:
       retval = *range;
       break;
 
     case string_constant:
-      retval = string;
+      retval = *str_obj;
       break;
 
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 
@@ -4068,18 +4101,19 @@ TC_REP::do_matrix_index (TC_REP::constan
 // out again, should we want to do that.
 //
 // -------------------------------------------------------------------
 
 // #ifdef HAVE_CONFIG_H
 // #include <config.h>
 // #endif
 
-// #include <ctype.h>
-// #include <string.h>
+// #include <cctype>
+// #include <cstring>
+
 // #include <fstream.h>
 // #include <iostream.h>
 // #include <strstream.h>
 
 // #include "mx-base.h"
 // #include "Range.h"
 
 // #include "arith-ops.h"
@@ -6158,17 +6192,17 @@ TC_REP::do_matrix_assignment (const tree
       delete complex_scalar;
       break;
 
     case complex_matrix_constant:
       delete complex_matrix;
       break;
 
     case string_constant:
-      delete [] string;
+      delete str_obj;
       break;
 
     case range_constant:
       delete range;
       break;
 
     case magic_colon:
     default:
@@ -6184,17 +6218,17 @@ TC_REP::do_matrix_assignment (const tree
       scalar = rhs.double_value ();
       break;
 
     case matrix_constant:
       matrix = new Matrix (rhs.matrix_value ());
       break;
 
     case string_constant:
-      string = strsave (rhs.string_value ());
+      str_obj = new Octave_str_obj (rhs.string_value ());
       break;
 
     case complex_matrix_constant:
       complex_matrix = new ComplexMatrix (rhs.complex_matrix_value ());
       break;
 
     case complex_scalar_constant:
       complex_scalar = new Complex (rhs.complex_value ());
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -23,26 +23,27 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_const_h)
 #define octave_tree_const_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <cstdlib>
+
 #include <iostream.h>
 
-#include <stdlib.h>
-
+#include "Range.h"
 #include "mx-base.h"
-#include "Range.h"
 
+#include "oct-obj.h"
+#include "oct-str.h"
 #include "tree-base.h"
 #include "tree-expr.h"
-#include "oct-obj.h"
 
 class idx_vector;
 class Octave_map;
 
 struct Mapper_fcn;
 
 // Constants.
 
@@ -78,18 +79,20 @@ public:
 //                  RowVector
 //                  ColumnVector
 // complex scalar   Complex
 // complex matrix   ComplexMatrix
 //                  ComplexDiagMatrix
 //                  ComplexRowVector
 //                  ComplexColumnVector
 // string           char* (null terminated)
-// range            double, double, dobule
+//                  Octave_str_obj
+// range            double, double, double
 //                  Range
+// map              Octave_map
 // magic colon      tree_constant::magic_colon
 // all_va_args      tree_constant::all_va_args
 
   tree_constant (void) : tree_fvc ()
     { rep = new tree_constant_rep (); rep->count = 1; }
 
   tree_constant (double d) : tree_fvc ()
     { rep = new tree_constant_rep (d); rep->count = 1; }
@@ -119,16 +122,19 @@ public:
       { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
       { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const char *s) : tree_fvc ()
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
+  tree_constant (const Octave_str_obj& s) : tree_fvc ()
+    { rep = new tree_constant_rep (s); rep->count = 1; }
+
   tree_constant (double base, double limit, double inc) : tree_fvc ()
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
 
   tree_constant (const Range& r) : tree_fvc ()
     { rep = new tree_constant_rep (r); rep->count = 1; }
 
   tree_constant (const Octave_map& m) : tree_fvc ()
     { rep = new tree_constant_rep (m); rep->count = 1; }
@@ -278,17 +284,20 @@ public:
     { return rep->matrix_value (force_string_conversion); }
 
   Complex complex_value (int force_string_conversion = 0) const
     { return rep->complex_value (force_string_conversion); }
 
   ComplexMatrix complex_matrix_value (int force_string_conversion = 0) const
     { return rep->complex_matrix_value (force_string_conversion); }
 
-  char *string_value (void) const
+  Octave_str_obj all_strings (void) const
+    { return rep->all_strings (); }
+
+  const char *string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
   Octave_map map_value (void) const;
 
   tree_constant lookup_map_element (const char *ref, int insert = 0,
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -20,28 +20,27 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <ctype.h>
-#include <string.h>
+#include <cctype>
 
 #include "dMatrix.h"
 
-#include "tree-const.h"
-#include "oct-obj.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
-#include "defun.h"
+#include "help.h"
+#include "oct-obj.h"
+#include "tree-const.h"
 #include "utils.h"
-#include "help.h"
 
 DEFUN ("isstr", Fisstr, Sisstr, 1, 1,
   "isstr (X): return 1 if X is a string, 0 otherwise")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -76,24 +75,31 @@ DEFUN ("toascii", Ftoascii, Stoascii, 1,
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       tree_constant arg = args(0);
 
       if (arg.is_string ())
 	{
-	  char *str = args(0).string_value ();
+	  Octave_str_obj str = args(0).all_strings ();
 
-	  int len = strlen (str);
+	  int nr = str.num_strings ();
+	  int nc = str.max_length ();
+
+// XXX FIXME XXX -- should fill with user-specified value.
 
-	  Matrix m (1, len);
+	  Matrix m (nr, nc, 0);
 
-	  for (int i = 0; i < len; i++)
-	    m (0, i) = toascii (str[i]);
+	  for (int i = 0; i < nr; i++)
+	    {
+	      nc = str.elem (i).length ();
+	      for (int j = 0; j < nc; j++)
+		m (i, j) = toascii (str.elem (i) [j]);
+	    }
 
 	  retval = m;
 	}
       else
 	gripe_wrong_type_arg ("toascii", arg);
     }
   else
     print_usage ("toascii");
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -64,16 +64,17 @@ private:
 
   tree_constant_rep (const Complex& c);
   tree_constant_rep (const ComplexMatrix& m);
   tree_constant_rep (const ComplexDiagMatrix& d);
   tree_constant_rep (const ComplexRowVector& v, int pcv);
   tree_constant_rep (const ComplexColumnVector& v, int pcv);
 
   tree_constant_rep (const char *s);
+  tree_constant_rep (const Octave_str_obj& s);
 
   tree_constant_rep (double base, double limit, double inc);
   tree_constant_rep (const Range& r);
 
   tree_constant_rep (const Octave_map& m);
 
   tree_constant_rep (tree_constant_rep::constant_type t);
 
@@ -181,17 +182,18 @@ private:
       return ((! (is_magic_colon () || is_all_va_args () || is_unknown ()))
 	      && (rows () == 0 || columns () == 0));
     }
 
   double double_value (int force_string_conversion = 0) const;
   Matrix matrix_value (int force_string_conversion = 0) const;
   Complex complex_value (int force_string_conversion = 0) const;
   ComplexMatrix complex_matrix_value (int force_string_conversion = 0) const;
-  char *string_value (void) const;
+  Octave_str_obj all_strings (void) const;
+  const char *string_value (void) const;
   Range range_value (void) const;
   Octave_map map_value (void) const;
 
   tree_constant& lookup_map_element (const char *name, int insert = 0,
 				     int silent = 0);
 
   ColumnVector vector_value (int force_string_conversion = 0,
 			     int force_vector_conversion = 0) const;
@@ -380,17 +382,17 @@ private:
 // Data.
 
   union
     {
       double scalar;		      // A real scalar constant.
       Matrix *matrix;		      // A real matrix constant.
       Complex *complex_scalar;	      // A real scalar constant.
       ComplexMatrix *complex_matrix;  // A real matrix constant.
-      char *string;		      // A character string constant.
+      Octave_str_obj *str_obj;	      // A character string constant.
       Range *range;		      // A set of evenly spaced values.
       Octave_map *a_map;	      // An associative array.
 
       tree_constant_rep *freeptr;     // For custom memory management.
     };
 
   constant_type type_tag;
 
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -19,20 +19,21 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_octave_h)
 #define octave_octave_h 1
 
-#include <stdio.h>
+#include <cstdio>
 
 class tree_statement_list;
 class tree_function;
+class Octave_str_obj;
 
 // Tell g++ that clean_up_and_exit doesn't return;
 
 #ifdef __GNUG__
 typedef void v_fcn_i (int);
 volatile v_fcn_i clean_up_and_exit;
 #endif
 
@@ -84,16 +85,19 @@ extern int quitting_gracefully;
 extern tree_statement_list *global_command;
 
 // Pointer to function that is currently being evaluated.
 extern tree_function *curr_function;
 
 // Nonzero means input is coming from startup file.
 extern int input_from_startup_file;
 
+// The command-line options.
+extern Octave_str_obj octave_argv;
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
