# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1264279263 -3600
#      Sat Jan 23 21:41:03 2010 +0100
# Node ID 12884915a8e46a2a876d47083ea8c788e2ed1126
# Parent  d4d13389c957fa79527ae6980ef8a5f5e2eb28b5
merge MArray classes & improve Array interface

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -197,28 +197,28 @@ compute_index (const Array<octave_idx_ty
       ("ArrayN<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
-  Array<octave_idx_type> retval (a.length ());
+  Array<octave_idx_type> retval (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     retval (i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
-  Array<idx_vector> retval (len);
+  Array<idx_vector> retval (len, 1);
 
   for (octave_idx_type i = 0; i < len; i++)
       retval (i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
@@ -342,32 +342,32 @@ all_ones (const Array<octave_idx_type>& 
 }
 
 Array<octave_idx_type>
 get_elt_idx (const Array<idx_vector>& ra_idx,
              const Array<octave_idx_type>& result_idx)
 {
   octave_idx_type n = ra_idx.length ();
 
-  Array<octave_idx_type> retval (n);
+  Array<octave_idx_type> retval (n, 1);
 
   for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
   return retval;
 }
 
 Array<octave_idx_type>
 get_ra_idx (octave_idx_type idx, const dim_vector& dims)
 {
   Array<octave_idx_type> retval;
 
   int n_dims = dims.length ();
 
-  retval.resize (n_dims);
+  retval.resize (n_dims, 1);
 
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
   for (octave_idx_type i = 0; i < idx; i++)
     increment_index (retval, dims);
@@ -559,17 +559,17 @@ idx_vector sub2ind (const dim_vector& dv
     current_liboctave_error_handler ("sub2ind: needs at least 2 indices");
 
   return retval;
 }
 
 Array<idx_vector> ind2sub (const dim_vector& dv, const idx_vector& idx)
 {
   octave_idx_type len = idx.length (0), n = dv.length ();
-  Array<idx_vector> retval(n);
+  Array<idx_vector> retval(n, 1);
   octave_idx_type numel = dv.numel ();
 
   if (idx.extent (numel) > numel)
     current_liboctave_error_handler ("ind2sub: index out of range");
   else
     {
       if (idx.is_scalar ())
         {
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -871,27 +871,28 @@ static void gripe_invalid_resize (void)
 {
   (*current_liboctave_error_handler)
     ("resize: Invalid resizing operation or ambiguous assignment to an out-of-bounds array element.");
 }
 
 // The default fill value.  Override if you want a different one.
 
 template <class T>
-T Array<T>::resize_fill_value ()
+const T& Array<T>::resize_fill_value ()
 {
-  return T ();
+  static T zero = T ();
+  return zero;
 }
 
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
 template <class T>
 void
-Array<T>::resize_fill (octave_idx_type n, const T& rfv)
+Array<T>::resize1 (octave_idx_type n, const T& rfv)
 {
   if (n >= 0 && ndims () == 2)
     {
       dim_vector dv;
       // This is driven by Matlab's behaviour of giving a *row* vector
       // on some out-of-bounds assignments.  Specifically, Matlab
       // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
       // 1x1, 0xN, and gives a row vector in all cases (yes, even the
@@ -926,17 +927,17 @@ Array<T>::resize_fill (octave_idx_type n
                 {
                   slice_data[slice_len++] = rfv;
                   dimensions = dv;
                 }
               else
                 {
                   static const octave_idx_type max_stack_chunk = 1024;
                   octave_idx_type nn = n + std::min (nx, max_stack_chunk);
-                  Array<T> tmp (Array<T> (nn), dv, 0, n);
+                  Array<T> tmp (Array<T> (nn, 1), dv, 0, n);
                   T *dest = tmp.fortran_vec ();
 
                   copy_or_memcpy (nx, data (), dest);
                   dest[nx] = rfv;
 
                   *this = tmp;
                 }
             }
@@ -954,17 +955,17 @@ Array<T>::resize_fill (octave_idx_type n
         }
     }
   else
     gripe_invalid_resize ();
 }
 
 template <class T>
 void
-Array<T>::resize_fill (octave_idx_type r, octave_idx_type c, const T& rfv)
+Array<T>::resize (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r >= 0 && c >= 0 && ndims () == 2)
     {
       octave_idx_type rx = rows (), cx = columns ();
       if (r != rx || c != cx)
         {
           Array<T> tmp = Array<T> (dim_vector (r, c));
           T *dest = tmp.fortran_vec ();
@@ -996,17 +997,17 @@ Array<T>::resize_fill (octave_idx_type r
     }
   else
     gripe_invalid_resize ();
 
 }
 
 template<class T>
 void
-Array<T>::resize_fill (const dim_vector& dv, const T& rfv)
+Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.length ();
   if (dvl == 2)
     resize (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
       if (dimensions.length () <= dvl && ! dv.any_neg ())
         {
@@ -1029,19 +1030,19 @@ Array<T>::index (const idx_vector& i, bo
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       octave_idx_type n = numel (), nx = i.extent (n);
       if (n != nx)
         {
           if (i.is_scalar ())
-            return Array<T> (1, rfv);
+            return Array<T> (1, 1, rfv);
           else
-            tmp.resize_fill (nx, rfv);
+            tmp.resize1 (nx, rfv);
         }
 
       if (tmp.numel () != nx)
         return Array<T> ();
     }
 
   return tmp.index (i);
 }
@@ -1055,19 +1056,19 @@ Array<T>::index (const idx_vector& i, co
   if (resize_ok)
     {
       dim_vector dv = dimensions.redim (2);
       octave_idx_type r = dv(0), c = dv(1);
       octave_idx_type rx = i.extent (r), cx = j.extent (c);
       if (r != rx || c != cx)
         {
           if (i.is_scalar () && j.is_scalar ())
-            return Array<T> (1, rfv);
+            return Array<T> (1, 1, rfv);
           else
-            tmp.resize_fill (rx, cx, rfv);
+            tmp.resize (rx, cx, rfv);
         }
 
       if (tmp.rows () != rx || tmp.columns () != cx)
         return Array<T> ();
     }
 
   return tmp.index (i, j);  
 }
@@ -1085,19 +1086,19 @@ Array<T>::index (const Array<idx_vector>
       dim_vector dvx = dim_vector::alloc (ial);
       for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv (i));
       if (! (dvx == dv))
         {
           bool all_scalars = true;
           for (int i = 0; i < ial; i++) 
             all_scalars = all_scalars && ia(i).is_scalar ();
           if (all_scalars)
-            return Array<T> (1, rfv);
+            return Array<T> (1, 1, rfv);
           else
-            tmp.resize_fill (dvx, rfv);
+            tmp.resize (dvx, rfv);
         }
 
       if (tmp.dimensions != dvx)
         return Array<T> ();
     }
 
   return tmp.index (ia);  
 }
@@ -1135,17 +1136,17 @@ Array<T>::assign (const idx_vector& i, c
             {
               if (rhl == 1)
                 *this = Array<T> (dim_vector (1, nx), rhs(0));
               else
                 *this = Array<T> (rhs, dim_vector (1, nx));
               return;
             }
 
-          resize_fill (nx, rfv);      
+          resize1 (nx, rfv);      
           n = numel ();
         }
 
       if (colon)
         {
           // A(:) = X makes a full fill or a shallow copy.
           if (rhl == 1)
             fill (rhs(0));
@@ -1320,17 +1321,17 @@ Array<T>::assign (const Array<idx_vector
                   rdv.chop_trailing_singletons ();
                   if (isfill)
                     *this = Array<T> (rdv, rhs(0));
                   else
                     *this = Array<T> (rhs, rdv);
                   return;
                 }
 
-              resize_fill (rdv, rfv);
+              resize (rdv, rfv);
               dv = rdv;
             }
 
           if (all_colons)
             {
               // A(:,:,...,:) = X makes a full fill or a shallow copy.
               if (isfill)
                 fill (rhs(0));
@@ -1371,17 +1372,17 @@ Array<T>::delete_elements (const idx_vec
     }
   else if (i.length (n) != 0)
     {
       octave_idx_type l, u;
       bool col_vec = ndims () == 2 && columns () == 1 && rows () != 1;
       if (i.is_scalar () && i(0) == n-1)
         {
           // Stack "pop" operation.
-          resize (n-1);
+          resize1 (n-1);
         }
       else if (i.is_cont_range (n, l, u))
         {
           // Special case deleting a contiguous range.
           octave_idx_type m = n + l - u;
           Array<T> tmp (dim_vector (col_vec ? m : 1, !col_vec ? m : 1));
           const T *src = data ();
           T *dest = tmp.fortran_vec ();
@@ -1444,17 +1445,17 @@ Array<T>::delete_elements (int dim, cons
               src += n;
             }
 
           *this = tmp;
         }
       else
         {
           // Use index.
-          Array<idx_vector> ia (ndims (), idx_vector::colon);
+          Array<idx_vector> ia (ndims (), 1, idx_vector::colon);
           ia (dim) = i.complement (n);
           *this = index (ia);
         }
     }
 }
 
 template <class T>
 void 
@@ -1499,33 +1500,33 @@ Array<T>&
 Array<T>::insert (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
   idx_vector i (r, r + a.rows ());
   idx_vector j (c, c + a.columns ());
   if (ndims () == 2 && a.ndims () == 2)
     assign (i, j, a);
   else
     {
-      Array<idx_vector> idx (a.ndims ());
+      Array<idx_vector> idx (a.ndims (), 1);
       idx(0) = i;
       idx(1) = j;
       for (int k = 0; k < a.ndims (); k++)
         idx(k) = idx_vector (0, a.dimensions(k));
       assign (idx, a);
     }
 
   return *this;
 }
 
 template <class T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type n = ra_idx.length ();
-  Array<idx_vector> idx (n);
+  Array<idx_vector> idx (n, 1);
   const dim_vector dva = a.dims ().redim (n);
   for (octave_idx_type k = 0; k < n; k++)
     idx(k) = idx_vector (ra_idx (k), ra_idx (k) + dva(k));
 
   assign (idx, a);
 
   return *this;
 }
@@ -2037,17 +2038,17 @@ Array<octave_idx_type>
 Array<T>::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> idx;
 
   octave_sort<T> lsort (safe_comparator (mode, *this, true));
 
   octave_idx_type r = rows (), c = cols ();
 
-  idx = Array<octave_idx_type> (r);
+  idx = Array<octave_idx_type> (r, 1);
 
   lsort.sort_rows (data (), idx.fortran_vec (), r, c);
 
   return idx;
 }
 
 
 template <class T>
@@ -2197,58 +2198,58 @@ Array<T>::find (octave_idx_type n, bool 
   if (n < 0 || n >= nel)
     {
       // We want all elements, which means we'll almost surely need
       // to resize. So count first, then allocate array of exact size.
       octave_idx_type cnt = 0;
       for (octave_idx_type i = 0; i < nel; i++)
         cnt += src[i] != zero;
 
-      retval = Array<octave_idx_type> (cnt);
+      retval.clear (cnt, 1);
       octave_idx_type *dest = retval.fortran_vec ();
       for (octave_idx_type i = 0; i < nel; i++)
         if (src[i] != zero) *dest++ = i;
     }
   else
     {
       // We want a fixed max number of elements, usually small. So be
       // optimistic, alloc the array in advance, and then resize if
       // needed.
-      retval = Array<octave_idx_type> (n);
+      retval.clear (n, 1);
       if (backward)
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0, l = nel - 1;
           for (; k < n; k++)
             {
               for (;l >= 0 && src[l] == zero; l--) ;
               if (l >= 0)
                 retval(k) = l--;
               else
                 break;
             }
           if (k < n)
-            retval.resize (k);
+            retval.resize (k, 1);
           octave_idx_type *rdata = retval.fortran_vec ();
           std::reverse (rdata, rdata + k);
         }
       else
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0, l = 0;
           for (; k < n; k++)
             {
               for (;l != nel && src[l] == zero; l++) ;
               if (l != nel)
                 retval(k) = l++;
               else
                 break;
             }
           if (k < n)
-            retval.resize (k);
+            retval.resize (k, 1);
         }
     }
 
   // Fixup return dimensions, for Matlab compatibility.
   // find(zeros(0,0)) -> zeros(0,0)
   // find(zeros(1,0)) -> zeros(1,0)
   // find(zeros(0,1)) -> zeros(0,1)
   // find(zeros(0,X)) -> zeros(0,1)
@@ -2594,17 +2595,17 @@ operator << (std::ostream& os, const Arr
     os << " (" << a_dims.str () << ")";
 
   os <<"\n\n";
 
   if (n_dims)
     {
       os << "data:";
 
-      Array<octave_idx_type> ra_idx (n_dims, 0);
+      Array<octave_idx_type> ra_idx (n_dims, 1, 0);
 
       // Number of times the first 2d-array is to be displayed.
 
       octave_idx_type m = 1;
       for (int i = 2; i < n_dims; i++)
         m *= a_dims(i);
 
       if (m == 1)
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -127,18 +127,18 @@ protected:
   // actual portion of the data referenced by this Array<T> object. This allows
   // to make shallow copies not only of a whole array, but also of contiguous
   // subranges. Every time rep is directly manipulated, slice_data and slice_len
   // need to be properly updated.
 
   T* slice_data;
   octave_idx_type slice_len;
 
-  Array (T *d, octave_idx_type n)
-    : rep (new typename Array<T>::ArrayRep (d, n)), dimensions (n) 
+  Array (T *d, octave_idx_type m, octave_idx_type n)
+    : rep (new typename Array<T>::ArrayRep (d, m*n)), dimensions (m, n) 
     { 
       slice_data = rep->data;
       slice_len = rep->len;
     }
 
   Array (T *d, const dim_vector& dv)
     : rep (new typename Array<T>::ArrayRep (d, dv.numel ())),
       dimensions (dv) 
@@ -178,39 +178,77 @@ private:
     for (octave_idx_type i = 0; i < len; i++)
       retval[i] = T (a[i]);
 
     return retval;
   }
 
 public:
 
+  // Empty ctor (0x0).
+
   Array (void)
     : rep (nil_rep ()), dimensions () 
     { 
       rep->count++; 
       slice_data = rep->data;
       slice_len = rep->len;
     }
 
-  explicit Array (octave_idx_type n)
-    : rep (new typename Array<T>::ArrayRep (n)), dimensions (n) 
+  // Obsolete 1D ctor (there are no 1D arrays).
+  explicit Array (octave_idx_type n) GCC_ATTR_DEPRECATED
+    : rep (new typename Array<T>::ArrayRep (n)), dimensions (n, 1) 
     { 
       slice_data = rep->data;
       slice_len = rep->len;
     }
 
-  explicit Array (octave_idx_type n, const T& val)
-    : rep (new typename Array<T>::ArrayRep (n)), dimensions (n)
+  // 2D uninitialized ctor.
+  explicit Array (octave_idx_type m, octave_idx_type n)
+    : rep (), dimensions (m, n) 
+    { 
+      rep = new typename Array<T>::ArrayRep (dimensions.safe_numel ());
+      slice_data = rep->data;
+      slice_len = rep->len;
+    }
+
+  // 2D initialized ctor.
+  explicit Array (octave_idx_type m, octave_idx_type n, const T& val)
+    : rep (), dimensions (m, n) 
+    { 
+      rep = new typename Array<T>::ArrayRep (dimensions.safe_numel ());
+      slice_data = rep->data;
+      slice_len = rep->len;
+      fill (val);
+    }
+
+  // nD uninitialized ctor.
+  explicit Array (const dim_vector& dv)
+    : rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
+      dimensions (dv) 
+    { 
+      slice_data = rep->data;
+      slice_len = rep->len;
+      dimensions.chop_trailing_singletons ();
+    }
+
+  // nD initialized ctor.
+  explicit Array (const dim_vector& dv, const T& val)
+    : rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
+      dimensions (dv)
     {
       slice_data = rep->data;
       slice_len = rep->len;
       fill (val);
+      dimensions.chop_trailing_singletons ();
     }
 
+  // Reshape constructor.
+  Array (const Array<T>& a, const dim_vector& dv);
+
   // Type conversion case.
   template <class U>
   Array (const Array<U>& a)
     : rep (new typename Array<T>::ArrayRep (coerce (a.data (), a.length ()), a.length ())),
       dimensions (a.dims ())
     {
       slice_data = rep->data;
       slice_len = rep->len;
@@ -222,38 +260,16 @@ public:
     {
       rep->count++;
       slice_data = a.slice_data;
       slice_len = a.slice_len;
     }
 
 public:
 
-  Array (const dim_vector& dv)
-    : rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
-      dimensions (dv) 
-    { 
-      slice_data = rep->data;
-      slice_len = rep->len;
-      dimensions.chop_trailing_singletons ();
-    }
-
-  Array (const dim_vector& dv, const T& val)
-    : rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
-      dimensions (dv)
-    {
-      slice_data = rep->data;
-      slice_len = rep->len;
-      fill (val);
-      dimensions.chop_trailing_singletons ();
-    }
-
-  // Reshape constructor.
-  Array (const Array<T>& a, const dim_vector& dv);
-
   ~Array (void)
     {
       if (--rep->count <= 0)
         delete rep;
     }
 
   Array<T>& operator = (const Array<T>& a)
     {
@@ -272,31 +288,59 @@ public:
 
       return *this;
     }
 
   void fill (const T& val); 
 
   void clear (void);
   void clear (const dim_vector& dv);
-  void clear (octave_idx_type n)
-    { clear (dim_vector (n)); }
 
   void clear (octave_idx_type r, octave_idx_type c)
     { clear (dim_vector (r, c)); }
 
   octave_idx_type capacity (void) const { return slice_len; }
   octave_idx_type length (void) const { return capacity (); }
   octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
   octave_idx_type dim3 (void) const { return dimensions(2); }
 
+  // Return the array as a column vector.
+  Array<T> as_column (void) const
+    {
+      Array<T> retval (*this);
+      if (dimensions.length () != 2 || dimensions(1) != 1)
+        retval.dimensions = dim_vector (numel (), 1);
+
+      return retval;
+    }
+
+  // Return the array as a row vector.
+  Array<T> as_row (void) const
+    {
+      Array<T> retval (*this);
+      if (dimensions.length () != 2 || dimensions(0) != 1)
+        retval.dimensions = dim_vector (1, numel ());
+
+      return retval;
+    }
+
+  // Return the array as a matrix.
+  Array<T> as_matrix (void) const
+    {
+      Array<T> retval (*this);
+      if (dimensions.length () != 2)
+        retval.dimensions = dimensions.redim (2);
+
+      return retval;
+    }
+
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
   octave_idx_type pages (void) const { return dim3 (); }
 
   size_t byte_size (void) const { return numel () * sizeof (T); }
 
   // Return a const-reference so that dims ()(i) works efficiently.
@@ -500,60 +544,29 @@ public:
   // Indexing without resizing.
 
   Array<T> index (const idx_vector& i) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j) const;
 
   Array<T> index (const Array<idx_vector>& ia) const;
 
-  static T resize_fill_value (); 
+  static const T& resize_fill_value (); 
 
   // Resizing (with fill).
 
-  void resize_fill (octave_idx_type n, const T& rfv);
-
-  void resize_fill (octave_idx_type nr, octave_idx_type nc, const T& rfv);
-
-  void resize_fill (const dim_vector& dv, const T& rfv);
+  void resize1 (octave_idx_type n, const T& rfv = resize_fill_value ());
 
-  // Resizing with default fill.
-  // Rationale: 
-  // These use the default fill value rather than leaving memory uninitialized.
-  // Resizing without fill leaves the resulting array in a rather weird state,
-  // where part of the data is initialized an part isn't.
-
-  void resize (octave_idx_type n)
-    { resize_fill (n, resize_fill_value ()); }
+  void resize (octave_idx_type n) GCC_ATTR_DEPRECATED
+    { resize1 (n); }
 
-  // FIXME -- this method cannot be defined here because it would
-  // clash with
-  //
-  //   void resize (octave_idx_type, const T&)
-  //
-  // (these become indistinguishable when T = octave_idx_type).
-  // In the future, I think the resize (.., const T& rfv) overloads
-  // should go away in favor of using resize_fill.
-
-  // void resize (octave_idx_type nr, octave_idx_type nc)
-  //  { resize_fill (nr, nc, resize_fill_value ()); }
+  void resize (octave_idx_type nr, octave_idx_type nc, 
+               const T& rfv = resize_fill_value ());
 
-  void resize (dim_vector dv)
-    { resize_fill (dv, resize_fill_value ()); }
-
-  // FIXME -- these are here for backward compatibility. They should
-  // go away in favor of using resize_fill directly.
-  void resize (octave_idx_type n, const T& rfv)
-    { resize_fill (n, static_cast<T> (rfv)); }
-
-  void resize (octave_idx_type nr, octave_idx_type nc, const T& rfv)
-    { resize_fill (nr, nc, rfv); }
-
-  void resize (dim_vector dv, const T& rfv)
-    { resize_fill (dv, rfv); }
+  void resize (const dim_vector& dv, const T& rfv = resize_fill_value ());
 
   // Indexing with possible resizing and fill
   // FIXME -- this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
   Array<T> index (const idx_vector& i, bool resize_ok,
                   const T& rfv = resize_fill_value ()) const;
 
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -86,20 +86,20 @@ public:
     {
       if (this != &a)
         Array<T>::operator = (a);
 
       return *this;
     }
 
   void resize (octave_idx_type r, octave_idx_type c)
-    { Array<T>::resize_fill (r, c, Array<T>::resize_fill_value ()); }
+    { Array<T>::resize (r, c, Array<T>::resize_fill_value ()); }
 
   void resize (octave_idx_type r, octave_idx_type c, const T& val)
-    { Array<T>::resize_fill (r, c, val); }
+    { Array<T>::resize (r, c, val); }
 
   Array2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
     {
       Array<T>::insert (a, r, c);
       return *this;
     }
 
   Array2<T> transpose (void) const
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -67,17 +67,17 @@ public:
 
       return *this;
     }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p) 
     { Array<T>::resize (dim_vector (r, c, p)); }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
-    { Array<T>::resize_fill (dim_vector (r, c, p), val); }
+    { Array<T>::resize (dim_vector (r, c, p), val); }
 
   Array3<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (dim, mode);
       return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
     }
 
   Array3<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -46,20 +46,18 @@ extern "C"
                            const Complex*, const octave_idx_type&, const Complex*,
                            const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
-   : MArray<Complex> (a.length ())
+   : MArray<Complex> (a)
 {
-  for (octave_idx_type i = 0; i < length (); i++)
-    elem (i) = a.elem (i);
 }
 
 bool
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -32,28 +32,30 @@ class
 OCTAVE_API
 ComplexColumnVector : public MArray<Complex>
 {
 friend class ComplexMatrix;
 friend class ComplexRowVector;
 
 public:
 
-  ComplexColumnVector (void) : MArray<Complex> () { }
+  ComplexColumnVector (void) : MArray<Complex> (0, 1) { }
 
-  explicit ComplexColumnVector (octave_idx_type n) : MArray<Complex> (n) { }
+  explicit ComplexColumnVector (octave_idx_type n) : MArray<Complex> (n, 1) { }
 
-  explicit ComplexColumnVector (const dim_vector& dv) : MArray<Complex> (dv) { }
+  explicit ComplexColumnVector (const dim_vector& dv) 
+    : MArray<Complex> (dv.as_column ()) { }
 
   ComplexColumnVector (octave_idx_type n, const Complex& val)
-    : MArray<Complex> (n, val) { }
+    : MArray<Complex> (n, 1, val) { }
 
   ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
 
-  ComplexColumnVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
+  ComplexColumnVector (const MArray<Complex>& a) : MArray<Complex> (a.as_column ()) { }
+  ComplexColumnVector (const Array<Complex>& a) : MArray<Complex> (a.as_column ()) { }
 
   explicit ComplexColumnVector (const ColumnVector& a);
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
@@ -119,16 +121,22 @@ public:
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
+  void resize (octave_idx_type n, const Complex& rfv = Array<Complex>::resize_fill_value ())
+    { Array<Complex>::resize (n, 1, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<Complex>::clear (n, 1); }
+
 private:
 
-  ComplexColumnVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, l) { }
+  ComplexColumnVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, l, 1) { }
 };
 
 MARRAY_FORWARD_DEFS (MArray, ComplexColumnVector, Complex)
 
 #endif
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -228,82 +228,72 @@ extern "C"
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
-  : MArray2<Complex> (a.rows (), a.cols ())
+  : MArray<Complex> (a)
 {
-  for (octave_idx_type j = 0; j < cols (); j++)
-    for (octave_idx_type i = 0; i < rows (); i++)
-      elem (i, j) = a.elem (i, j);
 }
 
 ComplexMatrix::ComplexMatrix (const RowVector& rv)
-  : MArray2<Complex> (1, rv.length (), 0.0)
+  : MArray<Complex> (rv)
 {
-  for (octave_idx_type i = 0; i < rv.length (); i++)
-    elem (0, i) = rv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const ColumnVector& cv)
-  : MArray2<Complex> (cv.length (), 1, 0.0)
+  : MArray<Complex> (cv)
 {
-  for (octave_idx_type i = 0; i < cv.length (); i++)
-    elem (i, 0) = cv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const DiagMatrix& a)
-  : MArray2<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexRowVector& rv)
-  : MArray2<Complex> (Array2<Complex> (rv, 1, rv.length ()))
+  : MArray<Complex> (rv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexColumnVector& cv)
-  : MArray2<Complex> (Array2<Complex> (cv, cv.length (), 1))
+  : MArray<Complex> (cv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
-  : MArray2<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
-  : MArray2<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a)
 {
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    for (octave_idx_type j = 0; j < a.cols (); j++)
-      elem (i, j) = a.elem (i, j);
 }
 
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
-  : MArray2<Complex> (a.rows (), a.cols (), 0.0)
+  : MArray<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 ComplexMatrix::ComplexMatrix (const Matrix& re, const Matrix& im)
-  : MArray2<Complex> (re.rows (), re.cols ())
+  : MArray<Complex> (re.rows (), re.cols ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = Complex (re(i), im(i));
 }
@@ -437,17 +427,17 @@ ComplexMatrix::insert (const DiagMatrix&
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  Array2<Complex>::insert (a, r, c);
+  Array<Complex>::insert (a, r, c);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
@@ -938,23 +928,23 @@ ComplexMatrix::extract_n (octave_idx_typ
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexMatrix::row (octave_idx_type i) const
 {
-  return MArray<Complex> (index (idx_vector (i), idx_vector::colon));
+  return index (idx_vector (i), idx_vector::colon);
 }
 
 ComplexColumnVector
 ComplexMatrix::column (octave_idx_type i) const
 {
-  return MArray<Complex> (index (idx_vector::colon, idx_vector (i)));
+  return index (idx_vector::colon, idx_vector (i));
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (void) const
 {
   octave_idx_type info;
   double rcon;
   MatrixType mattype (*this);
@@ -1057,33 +1047,33 @@ ComplexMatrix::finverse (MatrixType &mat
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr);
+      Array<octave_idx_type> ipvt (nr, 1);
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
-      Array<Complex> z(1);
+      Array<Complex> z(1, 1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (lwork);
+      z.resize (lwork, 1);
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1094,17 +1084,17 @@ ComplexMatrix::finverse (MatrixType &mat
       rcon = 0.0;
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
-          Array<double> rz (2 * nc);
+          Array<double> rz (2 * nc, 1);
           double *prz = rz.fortran_vec ();
           F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (zgecon_info != 0) 
             info = -1;
@@ -1335,17 +1325,17 @@ ComplexMatrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1376,17 +1366,17 @@ ComplexMatrix::ifourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1420,17 +1410,17 @@ ComplexMatrix::fourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1439,20 +1429,20 @@ ComplexMatrix::fourier2d (void) const
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts);
+  Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1486,17 +1476,17 @@ ComplexMatrix::ifourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1508,20 +1498,20 @@ ComplexMatrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts);
+  Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1609,19 +1599,19 @@ ComplexMatrix::determinant (MatrixType& 
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<Complex> z (2 * nc);
+              Array<Complex> z (2 * nc, 1);
               Complex *pz = z.fortran_vec ();
-              Array<double> rz (nc);
+              Array<double> rz (nc, 1);
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1633,17 +1623,17 @@ ComplexMatrix::determinant (MatrixType& 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1660,19 +1650,19 @@ ComplexMatrix::determinant (MatrixType& 
               retval = ComplexDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<Complex> z (2 * nc);
+                  Array<Complex> z (2 * nc, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (2 * nc);
+                  Array<double> rz (2 * nc, 1);
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1725,19 +1715,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
       if (typ == MatrixType::Upper)
         {
           const Complex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<Complex> z (2 * nc);
+          Array<Complex> z (2 * nc, 1);
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (nc);
+          Array<double> rz (nc, 1);
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1753,19 +1743,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
       else if (typ == MatrixType::Lower)
         {
           const Complex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<Complex> z (2 * nc);
+          Array<Complex> z (2 * nc, 1);
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (nc);
+          Array<double> rz (nc, 1);
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1799,19 +1789,19 @@ ComplexMatrix::rcond (MatrixType &mattyp
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<Complex> z (2 * nc);
+                  Array<Complex> z (2 * nc, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc);
+                  Array<double> rz (nc, 1);
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1819,26 +1809,26 @@ ComplexMatrix::rcond (MatrixType &mattyp
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr);
+              Array<octave_idx_type> ipvt (nr, 1);
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<Complex> z (2 * nc);
+              Array<Complex> z (2 * nc, 1);
               Complex *pz = z.fortran_vec ();
-              Array<double> rz (2 * nc);
+              Array<double> rz (2 * nc, 1);
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 { 
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1900,19 +1890,19 @@ ComplexMatrix::utsolve (MatrixType &matt
               const Complex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<Complex> z (2 * nc);
+                  Array<Complex> z (2 * nc, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc);
+                  Array<double> rz (nc, 1);
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2001,19 +1991,19 @@ ComplexMatrix::ltsolve (MatrixType &matt
               const Complex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<Complex> z (2 * nc);
+                  Array<Complex> z (2 * nc, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc);
+                  Array<double> rz (nc, 1);
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2109,19 +2099,19 @@ ComplexMatrix::fsolve (MatrixType &matty
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nc);
+                  Array<Complex> z (2 * nc, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> rz (nc);
+                  Array<double> rz (nc, 1);
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -2161,25 +2151,25 @@ ComplexMatrix::fsolve (MatrixType &matty
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
-          Array<Complex> z (2 * nc);
+          Array<Complex> z (2 * nc, 1);
           Complex *pz = z.fortran_vec ();
-          Array<double> rz (2 * nc);
+          Array<double> rz (2 * nc, 1);
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2615,23 +2605,23 @@ ComplexMatrix::lssolve (const ComplexMat
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
-      Array<double> s (minmn);
+      Array<double> s (minmn, 1);
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<Complex> work (1);
+      Array<Complex> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2655,23 +2645,23 @@ ComplexMatrix::lssolve (const ComplexMat
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<double> rwork (lrwork);
+      Array<double> rwork (lrwork, 1);
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2699,17 +2689,17 @@ ComplexMatrix::lssolve (const ComplexMat
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         (*current_liboctave_warning_handler) 
@@ -2816,23 +2806,23 @@ ComplexMatrix::lssolve (const ComplexCol
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
-      Array<double> s (minmn);
+      Array<double> s (minmn, 1);
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<Complex> work (1);
+      Array<Complex> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2849,33 +2839,33 @@ ComplexMatrix::lssolve (const ComplexCol
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<double> rwork (lrwork);
+      Array<double> rwork (lrwork, 1);
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork);
-      rwork.resize (static_cast<octave_idx_type> (rwork(0)));
-      iwork.resize (iwork(0));
+      work.resize (lwork, 1);
+      rwork.resize (static_cast<octave_idx_type> (rwork(0)), 1);
+      iwork.resize (iwork(0), 1);
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
@@ -3254,17 +3244,17 @@ Matrix ComplexMatrix::abs (void) const
 {
   return Matrix (mx_inline_cabs_dup (data (), length ()),
                  rows (), cols ());
 }
 
 ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
-  return MArray2<Complex>::diag (k);
+  return MArray<Complex>::diag (k);
 }
 
 bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
@@ -3313,17 +3303,17 @@ ComplexMatrix::row_min (Array<octave_idx
   ComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_min;
@@ -3387,17 +3377,17 @@ ComplexMatrix::row_max (Array<octave_idx
   ComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_max;
@@ -3461,17 +3451,17 @@ ComplexMatrix::column_min (Array<octave_
   ComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_min;
@@ -3535,17 +3525,17 @@ ComplexMatrix::column_max (Array<octave_
   ComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_max;
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -19,58 +19,59 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ComplexMatrix_h)
 #define octave_ComplexMatrix_h 1
 
-#include "MArray2.h"
+#include "Array2.h"
+#include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-ComplexMatrix : public MArray2<Complex>
+ComplexMatrix : public MArray<Complex>
 {
 public:
  
   typedef ComplexColumnVector column_vector_type;
   typedef ComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
-  ComplexMatrix (void) : MArray2<Complex> () { }
+  ComplexMatrix (void) : MArray<Complex> () { }
 
-  ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<Complex> (r, c) { }
+  ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray<Complex> (r, c) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
-    : MArray2<Complex> (r, c, val) { }
+    : MArray<Complex> (r, c, val) { }
 
-  ComplexMatrix (const dim_vector& dv) : MArray2<Complex> (dv) { }
+  ComplexMatrix (const dim_vector& dv) : MArray<Complex> (dv.redim (2)) { }
 
   ComplexMatrix (const dim_vector& dv, const Complex& val) 
-    : MArray2<Complex> (dv, val) { }
+    : MArray<Complex> (dv.redim (2), val) { }
 
-  ComplexMatrix (const ComplexMatrix& a) : MArray2<Complex> (a) { }
+  ComplexMatrix (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
   template <class U>
-  ComplexMatrix (const MArray2<U>& a) : MArray2<Complex> (a) { }
+  ComplexMatrix (const MArray<U>& a) : MArray<Complex> (a.as_matrix ()) { }
 
   template <class U>
-  ComplexMatrix (const Array2<U>& a) : MArray2<Complex> (a) { }
+  ComplexMatrix (const Array2<U>& a) : MArray<Complex> (a) { }
 
   template <class U>
-  ComplexMatrix (const Array<U>& a) : MArray2<Complex> (a) { }
+  ComplexMatrix (const Array<U>& a) : MArray<Complex> (a.as_matrix ()) { }
 
   ComplexMatrix (const Matrix& re, const Matrix& im);
 
   explicit ComplexMatrix (const Matrix& a);
 
   explicit ComplexMatrix (const RowVector& rv);
 
   explicit ComplexMatrix (const ColumnVector& cv);
@@ -84,17 +85,17 @@ public:
   explicit ComplexMatrix (const ComplexDiagMatrix& a);
 
   explicit ComplexMatrix (const boolMatrix& a);
 
   explicit ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
     {
-      MArray2<Complex>::operator = (a);
+      MArray<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexMatrix& a) const;
   bool operator != (const ComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
@@ -131,19 +132,19 @@ public:
   ComplexMatrix stack (const DiagMatrix& a) const;
 
   ComplexMatrix stack (const ComplexMatrix& a) const;
   ComplexMatrix stack (const ComplexRowVector& a) const;
   ComplexMatrix stack (const ComplexColumnVector& a) const;
   ComplexMatrix stack (const ComplexDiagMatrix& a) const;
 
   ComplexMatrix hermitian (void) const
-    { return MArray2<Complex>::hermitian (std::conj); }
+    { return MArray<Complex>::hermitian (std::conj); }
   ComplexMatrix transpose (void) const
-    { return MArray2<Complex>::transpose (); }
+    { return MArray<Complex>::transpose (); }
 
   friend OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
   // resize is the destructive equivalent for this one
 
   ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   ComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
@@ -373,17 +374,17 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexMatrix& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
 private:
 
-  ComplexMatrix (Complex *d, octave_idx_type r, octave_idx_type c) : MArray2<Complex> (d, r, c) { }
+  ComplexMatrix (Complex *d, octave_idx_type r, octave_idx_type c) : MArray<Complex> (d, r, c) { }
 };
 
 extern OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API ComplexMatrix
 operator * (const ColumnVector& a, const ComplexRowVector& b);
@@ -426,11 +427,11 @@ MS_CMP_OP_DECLS (ComplexMatrix, Complex,
 MS_BOOL_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArray2, ComplexMatrix, Complex)
+MARRAY_FORWARD_DEFS (MArray, ComplexMatrix, Complex)
 
 #endif
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 #include "bsxfun-defs.cc"
 
 ComplexNDArray::ComplexNDArray (const charNDArray& a)
-  : MArrayN<Complex> (a.dims ())
+  : MArray<Complex> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
 #if defined (HAVE_FFTW)
 
@@ -212,17 +212,17 @@ ComplexNDArray::fourier (int dim) const
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -259,17 +259,17 @@ ComplexNDArray::ifourier (int dim) const
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -309,19 +309,19 @@ ComplexNDArray::fourier2d (void) const
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn);
+      Array<Complex> wsave (nn, 1);
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts);
+      Array<Complex> row (npts, 1);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -357,19 +357,19 @@ ComplexNDArray::ifourier2d (void) const
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn);
+      Array<Complex> wsave (nn, 1);
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts);
+      Array<Complex> row (npts, 1);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -405,19 +405,19 @@ ComplexNDArray::fourierNd (void) const
   int rank = dv.length ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn);
+      Array<Complex> wsave (nn, 1);
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts);
+      Array<Complex> row (npts, 1);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -452,19 +452,19 @@ ComplexNDArray::ifourierNd (void) const
   int rank = dv.length ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (nn);
+      Array<Complex> wsave (nn, 1);
       Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (npts);
+      Array<Complex> row (npts, 1);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -781,17 +781,17 @@ ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
   
   if (n == dimensions.length ())
     {
-      Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
+      Array<octave_idx_type> a_ra_idx (a_dv.length (), 1, 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
@@ -868,17 +868,17 @@ ComplexNDArray::compute_index (Array<oct
                                const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 ComplexNDArray
 ComplexNDArray::diag (octave_idx_type k) const
 {
-  return MArrayN<Complex>::diag (k);
+  return MArray<Complex>::diag (k);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -18,53 +18,53 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ComplexNDArray_h)
 #define octave_ComplexNDArray_h 1
 
-#include "MArrayN.h"
+#include "MArray.h"
 #include "CMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
-ComplexNDArray : public MArrayN<Complex>
+ComplexNDArray : public MArray<Complex>
 {
 public:
 
   typedef ComplexMatrix matrix_type;
 
-  ComplexNDArray (void) : MArrayN<Complex> () { }
+  ComplexNDArray (void) : MArray<Complex> () { }
 
-  ComplexNDArray (const dim_vector& dv) : MArrayN<Complex> (dv) { }
+  ComplexNDArray (const dim_vector& dv) : MArray<Complex> (dv) { }
 
   ComplexNDArray (const dim_vector& dv, const Complex& val)
-    : MArrayN<Complex> (dv, val) { }
+    : MArray<Complex> (dv, val) { }
   
-  ComplexNDArray (const ComplexNDArray& a) : MArrayN<Complex> (a) { }
+  ComplexNDArray (const ComplexNDArray& a) : MArray<Complex> (a) { }
 
-  ComplexNDArray (const ComplexMatrix& a) : MArrayN<Complex> (a) { }
+  ComplexNDArray (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
   template <class U>
-  ComplexNDArray (const MArrayN<U>& a) : MArrayN<Complex> (a) { }
+  ComplexNDArray (const MArray<U>& a) : MArray<Complex> (a) { }
 
   template <class U>
-  ComplexNDArray (const Array<U>& a) : MArrayN<Complex> (a) { }
+  ComplexNDArray (const Array<U>& a) : MArray<Complex> (a) { }
 
   ComplexNDArray (const charNDArray&); 
 
   ComplexNDArray& operator = (const ComplexNDArray& a)
     {
-      MArrayN<Complex>::operator = (a);
+      MArray<Complex>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   // FIXME -- this is not quite the right thing.
@@ -116,17 +116,17 @@ public:
   ComplexNDArray fourier2d (void) const;
   ComplexNDArray ifourier2d (void) const;
 
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   ComplexMatrix matrix_value (void) const;
 
-  ComplexNDArray squeeze (void) const { return MArrayN<Complex>::squeeze (); }
+  ComplexNDArray squeeze (void) const { return MArray<Complex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
@@ -139,40 +139,40 @@ public:
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
   ComplexNDArray& changesign (void) 
     { 
-      MArrayN<Complex>::changesign (); 
+      MArray<Complex>::changesign (); 
       return *this; 
     }
 
 private:
 
   ComplexNDArray (Complex *d, const dim_vector& dv)
-    : MArrayN<Complex> (d, dv) { }
+    : MArray<Complex> (d, dv) { }
 };
 
 extern OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
 MINMAX_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 
 NDS_CMP_OP_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 NDS_BOOL_OP_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 
 SND_CMP_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, ComplexNDArray, Complex)
+MARRAY_FORWARD_DEFS (MArray, ComplexNDArray, Complex)
 
 extern OCTAVE_API ComplexNDArray& operator *= (ComplexNDArray& a, double s);
 extern OCTAVE_API ComplexNDArray& operator /= (ComplexNDArray& a, double s);
 
 BSXFUN_STDOP_DECLS (ComplexNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (ComplexNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, ComplexNDArray, OCTAVE_API)
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -49,23 +49,16 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (xzdotu, XZDOTU) (const octave_idx_type&, const Complex*, const octave_idx_type&,
                              const Complex*, const octave_idx_type&, Complex&);
 }
 
 // Complex Row Vector class
 
-ComplexRowVector::ComplexRowVector (const RowVector& a)
-  : MArray<Complex> (a.length ())
-{
-  for (octave_idx_type i = 0; i < length (); i++)
-    elem (i) = a.elem (i);
-}
-
 bool
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -20,40 +20,42 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ComplexRowVector_h)
 #define octave_ComplexRowVector_h 1
 
 #include "MArray.h"
+#include "dRowVector.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 ComplexRowVector : public MArray<Complex>
 {
 friend class ComplexColumnVector;
 
 public:
 
-  ComplexRowVector (void) : MArray<Complex> () { }
+  ComplexRowVector (void) : MArray<Complex> (1, 0) { }
 
-  explicit ComplexRowVector (octave_idx_type n) : MArray<Complex> (n) { }
+  explicit ComplexRowVector (octave_idx_type n) : MArray<Complex> (1, n) { }
 
   explicit ComplexRowVector (const dim_vector& dv) : MArray<Complex> (dv) { }
 
-  ComplexRowVector (octave_idx_type n, const Complex& val) : MArray<Complex> (n, val) { }
+  ComplexRowVector (octave_idx_type n, const Complex& val) : MArray<Complex> (1, n, val) { }
 
   ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
 
-  ComplexRowVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
+  ComplexRowVector (const MArray<Complex>& a) : MArray<Complex> (a.as_row ()) { }
+  ComplexRowVector (const Array<Complex>& a) : MArray<Complex> (a.as_row ()) { }
 
-  explicit ComplexRowVector (const RowVector& a);
+  explicit ComplexRowVector (const RowVector& a) : MArray<Complex> (a) { }
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexRowVector& a) const;
@@ -101,19 +103,25 @@ public:
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
+  void resize (octave_idx_type n, const Complex& rfv = Array<Complex>::resize_fill_value ())
+    { Array<Complex>::resize (1, n, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<Complex>::clear (1, n); }
+
 private:
 
-  ComplexRowVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, l) { }
+  ComplexRowVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, 1, l) { }
 };
 
 // row vector by column vector -> scalar
 
 Complex operator * (const ComplexRowVector& a, const ColumnVector& b);
 
 Complex operator * (const ComplexRowVector& a, const ComplexColumnVector& b);
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -320,17 +320,17 @@ SparseComplexMatrix::max (Array<octave_i
               result.xdata (ii) = tmp;
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
-      idx_arg.resize_fill (nr, 1, 0);
+      idx_arg.resize (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -475,17 +475,17 @@ SparseComplexMatrix::min (Array<octave_i
               result.xdata (ii) = tmp;
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
-      idx_arg.resize_fill (nr, 1, 0);
+      idx_arg.resize (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -3917,17 +3917,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4217,17 +4217,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4411,19 +4411,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4505,17 +4505,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           // Throw-away extra info LAPACK gives so as to not 
           // change output.
           if (err != 0) 
@@ -4532,19 +4532,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4658,19 +4658,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4787,17 +4787,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               rcond = 0.0;
@@ -4813,19 +4813,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4978,19 +4978,19 @@ SparseComplexMatrix::bsolve (MatrixType 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5072,17 +5072,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5097,19 +5097,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5225,19 +5225,19 @@ SparseComplexMatrix::bsolve (MatrixType 
 
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5359,17 +5359,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += std::abs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5385,19 +5385,19 @@ SparseComplexMatrix::bsolve (MatrixType 
                   ("matrix singular to machine precision");
 
             }
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<Complex> z (2 * nr);
+                  Array<Complex> z (2 * nr, 1);
                   Complex *pz = z.fortran_vec ();
-                  Array<double> iz (nr);
+                  Array<double> iz (nr, 1);
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,138 @@
+2010-02-23  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Array.h (Array): Define 2D constructors. Remove conflicting 1D
+	initialized constructor. Deprecate 1D constructor. Deprecate 1D resize. 
+	Add 2D resize, resize1. Remove resize_fill. Make resize_fill_value
+	return a reference. Remove 1D clear.
+	
+	* MArray.h (MArray): Merge with MArrayN. Define 2D constructors, sync
+	with Array changes.
+
+	* MArrayN.h, MArray2.h: Deprecate headers, use compatibility #defines.
+	* MArrayN.cc, MArray2.cc: Remove sources.
+	* Makefile.am: Update.
+
+	* fCMatrix.h (FloatComplexMatrix): Rebase on MArray.
+	* fMatrix.h (FloatMatrix): Ditto.
+	* dMatrix.h (Matrix): Ditto.
+	* CMatrix.h (ComplexMatrix): Ditto.
+	* fCNDArray.h (FloatComplexNDArray): Rebase on MArray.
+	* fNDArray.h (FloatNDArray): Ditto.
+	* dNDArray.h (NDArray): Ditto.
+	* CNDArray.h (ComplexNDArray): Ditto.
+
+	* Array-util.cc: Update.
+	* Array.cc: Ditto.
+	* Array2.h: Ditto.
+	* Array3.h: Ditto.
+	* CColVector.cc: Ditto.
+	* CColVector.h: Ditto.
+	* CMatrix.cc: Ditto.
+	* CNDArray.cc: Ditto.
+	* CRowVector.cc: Ditto.
+	* CSparse.cc: Ditto.
+	* ChangeLog: Ditto.
+	* CmplxCHOL.cc: Ditto.
+	* CmplxHESS.cc: Ditto.
+	* CmplxLU.cc: Ditto.
+	* CmplxQRP.cc: Ditto.
+	* CmplxSCHUR.cc: Ditto.
+	* CmplxSVD.cc: Ditto.
+	* CollocWt.cc: Ditto.
+	* DASPK-opts.in: Ditto.
+	* DASPK.cc: Ditto.
+	* DASRT-opts.in: Ditto.
+	* DASRT.cc: Ditto.
+	* DASSL-opts.in: Ditto.
+	* DASSL.cc: Ditto.
+	* DiagArray2.cc: Ditto.
+	* DiagArray2.h: Ditto.
+	* EIG.cc: Ditto.
+	* LSODE-opts.in: Ditto.
+	* LSODE.cc: Ditto.
+	* MArray-C.cc: Ditto.
+	* MArray-d.cc: Ditto.
+	* MArray-defs.h: Ditto.
+	* MArray-f.cc: Ditto.
+	* MArray-fC.cc: Ditto.
+	* MArray-i.cc: Ditto.
+	* MArray-s.cc: Ditto.
+	* MArray.cc: Ditto.
+	* MDiagArray2.h: Ditto.
+	* MSparse-defs.h: Ditto.
+	* MSparse.cc: Ditto.
+	* MSparse.h: Ditto.
+	* Makefile.am: Ditto.
+	* MatrixType.cc: Ditto.
+	* PermMatrix.cc: Ditto.
+	* Quad.cc: Ditto.
+	* SparseCmplxLU.cc: Ditto.
+	* SparseCmplxQR.cc: Ditto.
+	* SparseCmplxQR.h: Ditto.
+	* SparseQR.cc: Ditto.
+	* SparseQR.h: Ditto.
+	* SparsedbleLU.cc: Ditto.
+	* base-lu.cc: Ditto.
+	* dColVector.h: Ditto.
+	* dMatrix.cc: Ditto.
+	* dNDArray.cc: Ditto.
+	* dRowVector.h: Ditto.
+	* dSparse.cc: Ditto.
+	* dbleCHOL.cc: Ditto.
+	* dbleHESS.cc: Ditto.
+	* dbleLU.cc: Ditto.
+	* dbleQRP.cc: Ditto.
+	* dbleSCHUR.cc: Ditto.
+	* dbleSVD.cc: Ditto.
+	* dim-vector.h: Ditto.
+	* eigs-base.cc: Ditto.
+	* fCColVector.cc: Ditto.
+	* fCColVector.h: Ditto.
+	* fCMatrix.cc: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fCRowVector.cc: Ditto.
+	* fCRowVector.h: Ditto.
+	* fCmplxCHOL.cc: Ditto.
+	* fCmplxHESS.cc: Ditto.
+	* fCmplxLU.cc: Ditto.
+	* fCmplxQRP.cc: Ditto.
+	* fCmplxSCHUR.cc: Ditto.
+	* fCmplxSVD.cc: Ditto.
+	* fColVector.h: Ditto.
+	* fEIG.cc: Ditto.
+	* fMatrix.cc: Ditto.
+	* fNDArray.cc: Ditto.
+	* fRowVector.h: Ditto.
+	* floatCHOL.cc: Ditto.
+	* floatHESS.cc: Ditto.
+	* floatLU.cc: Ditto.
+	* floatQRP.cc: Ditto.
+	* floatSCHUR.cc: Ditto.
+	* floatSVD.cc: Ditto.
+	* glob-match.h: Ditto.
+	* int16NDArray.h: Ditto.
+	* int32NDArray.h: Ditto.
+	* int64NDArray.h: Ditto.
+	* int8NDArray.h: Ditto.
+	* intNDArray.cc: Ditto.
+	* intNDArray.h: Ditto.
+	* oct-fftw.cc: Ditto.
+	* oct-norm.cc: Ditto.
+	* oct-rand.cc: Ditto.
+	* regex-match.cc: Ditto.
+	* sparse-dmsolve.cc: Ditto.
+	* str-vec.cc: Ditto.
+	* str-vec.h: Ditto.
+	* uint16NDArray.h: Ditto.
+	* uint32NDArray.h: Ditto.
+	* uint64NDArray.h: Ditto.
+	* uint8NDArray.h: Ditto.
+
 2010-02-22  John W. Eaton  <jwe@octave.org>
 
 	* data-conv.cc, data-conv.h (read_floats, read_doubles,
 	do_float_format_conversion, do_double_format_conversion):
 	Declare len arg and loop counter as octave_idx_type, not int.
 	(strip_spaces): Use size_t for string dimension and index, not int.
 	(LS_DO_READ, LS_DO_WRITE): Declare loop counter as
 	octave_idx_type, not int.
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -118,19 +118,19 @@ ComplexCHOL::init (const ComplexMatrix& 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type zpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<Complex> z (2*n);
+      Array<Complex> z (2*n, 1);
       Complex *pz = z.fortran_vec ();
-      Array<double> rz (n);
+      Array<double> rz (n, 1);
       double *prz = rz.fortran_vec ();
       F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, zpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zpocon_info != 0) 
         info = -1;
     }
@@ -410,17 +410,17 @@ ComplexCHOL::shift_sym (octave_idx_type 
 
   octave_idx_type n = chol_mat.rows ();
   
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (n);
+      Array<octave_idx_type> p (n, 1);
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -76,27 +76,27 @@ ComplexHESS::init (const ComplexMatrix& 
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
-  Array<double> scale (n);
+  Array<double> scale (n, 1);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<Complex> tau (n-1);
+  Array<Complex> tau (n-1, 1);
   Complex *ptau = tau.fortran_vec ();
 
-  Array<Complex> work (lwork);
+  Array<Complex> work (lwork, 1);
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   Complex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn);
+  ipvt.resize (mn, 1);
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   Complex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -60,17 +60,17 @@ ComplexQRP::init (const ComplexMatrix& a
   OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   ComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 0);
+  MArray<octave_idx_type> jpvt (n, 1, 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rwork, 2*n);
 
       // workspace query.
       Complex clwork;
       F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -104,27 +104,27 @@ ComplexSCHUR::init (const ComplexMatrix&
 
   schur_mat = a;
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
   Complex *s = schur_mat.fortran_vec ();
   Complex *q = unitary_mat.fortran_vec ();
 
-  Array<double> rwork (n);
+  Array<double> rwork (n, 1);
   double *prwork = rwork.fortran_vec ();
 
-  Array<Complex> w (n);
+  Array<Complex> w (n, 1);
   Complex *pw = w.fortran_vec ();
 
-  Array<Complex> work (lwork);
+  Array<Complex> work (lwork, 1);
   Complex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pw, q, n, rconde, rcondv,
                              pwork, lwork, prwork, pbwork, info
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -128,37 +128,37 @@ ComplexSVD::init (const ComplexMatrix& a
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   Complex *vt = right_sm.fortran_vec ();
 
   octave_idx_type lrwork = 5*max_mn;
 
-  Array<double> rwork (lrwork);
+  Array<double> rwork (lrwork, 1);
 
   // Ask ZGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<Complex> work (1);
+  Array<Complex> work (1, 1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork,
                              rwork.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0).real ());
-  work.resize (lwork);
+  work.resize (lwork, 1);
 
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork,
                              rwork.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -97,30 +97,30 @@ CollocWt::init (void)
   if (nt < 0)
     {
       error ("total number of collocation points less than zero");
       return;
     }
   else if (nt == 0)
     return;
 
-  Array<double> dif1 (nt);
+  Array<double> dif1 (nt, 1);
   double *pdif1 = dif1.fortran_vec ();
 
-  Array<double> dif2 (nt);
+  Array<double> dif2 (nt, 1);
   double *pdif2 = dif2.fortran_vec ();
 
-  Array<double> dif3 (nt);
+  Array<double> dif3 (nt, 1);
   double *pdif3 = dif3.fortran_vec ();
 
-  Array<double> vect (nt);
+  Array<double> vect (nt, 1);
   double *pvect = vect.fortran_vec ();
 
-  r.resize (nt);
-  q.resize (nt);
+  r.resize (nt, 1);
+  q.resize (nt, 1);
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
 
   // Compute roots.
 
   F77_FUNC (jcobi, JCOBI) (nt, n, inc_left, inc_right, Alpha, Beta,
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -25,23 +25,23 @@ OPTION
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -60,23 +60,23 @@ The local error test applied at each int
   abs (local error in x(i))
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -151,17 +151,17 @@ Jacobian.  For convergence, the weighted
 (scaled by the error weights) must be less than @code{EPINIT*EPCON},
 where @code{EPCON} = 0.33 is the analogous test constant used in the
 time steps.  The default is @code{EPINIT} = 0.01.
 @end table
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (6);
+    $OPTVAR.resize (6, 1);
     $OPTVAR(0) = 5.0;
     $OPTVAR(1) = 6.0;
     $OPTVAR(2) = 5.0;
     $OPTVAR(3) = 0.0;
     $OPTVAR(4) = ::pow (DBL_EPSILON, 2.0/3.0);
     $OPTVAR(5) = 0.01;
   END_INIT_BODY
   SET_EXPR = "val"
@@ -200,23 +200,23 @@ in the equation set.
 
 This option is required by the
 @code{compute consistent initial condition\"} and
 @code{\"exclude algebraic variables from error test\"} options.
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
     void set_$OPT (int val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = val;
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -261,23 +261,23 @@ Greater than zero.
 @end table
 
 This option only has an effect if the
 @code{\"enforce inequality constraints\"} option is nonzero.
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
     void set_$OPT (octave_idx_type val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = val;
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -155,17 +155,17 @@ DASPK::do_integrate (double tout)
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASPK_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (20);
+      info.resize (20, 1);
 
       for (octave_idx_type i = 0; i < 20; i++)
         info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
@@ -226,18 +226,18 @@ DASPK::do_integrate (double tout)
         liw += n;
       if (ccic == 1 || eavfet == 1)
         liw += n;
 
       lrw = 50 + 9*n + n*n;
       if (eavfet == 1)
         lrw += n;
 
-      iwork.resize (liw);
-      rwork.resize (lrw);
+      iwork.resize (liw, 1);
+      rwork.resize (lrw, 1);
 
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -25,23 +25,23 @@ OPTION
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -59,23 +59,23 @@ The local error test applied at each int
   abs (local error in x(i)) <= ...
       rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -151,17 +151,17 @@ DASRT::integrate (double tout)
 
   if (! initialized || restart
       || DAEFunc::reset || DAERTFunc::reset || DASRT_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (15);
+      info.resize (15, 1);
 
       for (octave_idx_type i = 0; i < 15; i++)
         info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
@@ -194,18 +194,18 @@ DASRT::integrate (double tout)
               integration_error = true;
               return;
             }
         }
 
       liw = 21 + n;
       lrw = 50 + 9*n + n*n + 3*ng;
 
-      iwork.resize (liw);
-      rwork.resize (lrw);
+      iwork.resize (liw, 1);
+      rwork.resize (lrw, 1);
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           info(3) = 1;
           rwork(0) = stop_time;
         }
@@ -248,17 +248,17 @@ DASRT::integrate (double tout)
           integration_error = true;
           return;
         }
 
       info(4) = user_jsub ? 1 : 0;
 
       DAEFunc::reset = false;
 
-      jroot.resize (ng, 1);
+      jroot.resize (ng, 1, 1);
 
       pjroot = jroot.fortran_vec ();
 
       DAERTFunc::reset = false;
 
       // DASRT_options
 
       double mss = maximum_step_size ();
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -25,23 +25,23 @@ OPTION
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the relative
 tolerance must also be a vector of the same length.
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
@@ -60,23 +60,23 @@ The local error test applied at each int
   abs (local error in x(i))
        <= rtol(i) * abs (Y(i)) + atol(i)
 @end group
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -127,32 +127,32 @@ DASSL::do_integrate (double tout)
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASSL_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
-      info.resize (15);
+      info.resize (15, 1);
 
       for (octave_idx_type i = 0; i < 15; i++)
         info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
       octave_idx_type n = size ();
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
-      iwork.resize (liw);
-      rwork.resize (lrw);
+      iwork.resize (liw, 1);
+      rwork.resize (lrw, 1);
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           rwork(0) = stop_time;
           info(3) = 1;
         }
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -69,19 +69,19 @@ Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   Array<T> d;
 
   if (k == 0)
     // The main diagonal is shallow-copied.
     d = *this;
   else if (k > 0 && k < cols ())
-    d = Array<T> (std::min (cols () - k, rows ()), T ());
+    d = Array<T> (std::min (cols () - k, rows ()), 1, T ());
   else if (k < 0 && -k < rows ())
-    d = Array<T> (std::min (rows () + k, cols ()), T ());
+    d = Array<T> (std::min (rows () + k, cols ()), 1, T ());
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 template <class T>
@@ -130,44 +130,28 @@ DiagArray2<T>::checkelem (octave_idx_typ
       return Proxy (0, r, c);
     }
   else
     return Proxy (this, r, c);
 }
 
 template <class T>
 void
-DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c)
+DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
+                       const T& rfv)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
   if (r != dim1 () || c != dim2 ())
     {
-      Array<T>::resize (std::min (r, c));
-      d1 = r; d2 = c;
-    }
-}
-
-template <class T>
-void
-DiagArray2<T>::resize_fill (octave_idx_type r, octave_idx_type c, const T& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimensions");
-      return;
-    }
-
-  if (r != dim1 () || c != dim2 ())
-    {
-      Array<T>::resize_fill (std::min (r, c), val);
+      Array<T>::resize (std::min (r, c), 1, rfv);
       d1 = r; d2 = c;
     }
 }
 
 template <class T>
 DiagArray2<T>::operator Array2<T> (void) const
 {
   Array2<T> result (dim1 (), dim2 ());
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -85,40 +85,40 @@ private:
   };
 
   friend class Proxy;
 
 protected:
   octave_idx_type d1, d2;
 
   DiagArray2 (T *d, octave_idx_type r, octave_idx_type c) 
-    : Array<T> (d, std::min (r, c)), d1 (r), d2 (c) { }
+    : Array<T> (d, std::min (r, c), 1), d1 (r), d2 (c) { }
 
 public:
 
   using Array<T>::element_type;
 
   DiagArray2 (void) 
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c) 
-    : Array<T> (std::min (r, c)), d1 (r), d2 (c) { }
+    : Array<T> (std::min (r, c), 1), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) 
-    : Array<T> (std::min (r, c), val), d1 (r), d2 (c) { }
+    : Array<T> (std::min (r, c), 1, val), d1 (r), d2 (c) { }
 
   DiagArray2 (const dim_vector& dv)
-    : Array<T> (std::min (dv(0), dv(1))), d1 (dv(0)), d2 (dv(0))
+    : Array<T> (std::min (dv(0), dv(1)), 1), d1 (dv(0)), d2 (dv(0))
     {
       if (dv.length () != 2)
         (*current_liboctave_error_handler) ("too many dimensions");
     }
 
   DiagArray2 (const Array<T>& a) 
-    : Array<T> (a), d1 (a.numel ()), d2 (a.numel ()) { }
+    : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
   DiagArray2 (const DiagArray2<T>& a) 
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a) 
   : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
@@ -208,18 +208,18 @@ public:
     }
 
   T& dgxelem (octave_idx_type i)
     { return Array<T>::xelem (i); }
 
   T dgxelem (octave_idx_type i) const
     { return Array<T>::xelem (i); }
 
-  void resize (octave_idx_type n, octave_idx_type m);
-  void resize_fill (octave_idx_type n, octave_idx_type m, const T& val);
+  void resize (octave_idx_type n, octave_idx_type m, 
+               const T& rfv = Array<T>::resize_fill_value ());
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   operator Array2<T> (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
 
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -150,20 +150,20 @@ EIG::init (const Matrix& a, bool calc_ev
       return -1;
     }
 
   octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
-  Array<double> wr (n);
+  Array<double> wr (n, 1);
   double *pwr = wr.fortran_vec ();
 
-  Array<double> wi (n);
+  Array<double> wi (n, 1);
   double *pwi = wi.fortran_vec ();
 
   octave_idx_type tnvr = calc_ev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
@@ -176,17 +176,17 @@ EIG::init (const Matrix& a, bool calc_ev
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork);
+      Array<double> work (lwork, 1);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pwr, pwi, dummy,
                                idummy, pvr, n, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -269,17 +269,17 @@ EIG::symmetric_init (const Matrix& a, bo
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork);
+      Array<double> work (lwork, 1);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -336,33 +336,33 @@ EIG::init (const ComplexMatrix& a, bool 
   octave_idx_type nvr = calc_ev ? n : 0;
   ComplexMatrix vtmp (nvr, nvr);
   Complex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 2*n;
-  Array<double> rwork (lrwork);
+  Array<double> rwork (lrwork, 1);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork);
+      Array<Complex> work (lwork, 1);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pw, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -406,30 +406,30 @@ EIG::hermitian_init (const ComplexMatrix
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<double> rwork (lrwork);
+  Array<double> rwork (lrwork, 1);
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork);
+      Array<Complex> work (lwork, 1);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -494,23 +494,23 @@ EIG::init (const Matrix& a, const Matrix
     return symmetric_init (a, b, calc_ev);
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
   double *btmp_data = btmp.fortran_vec ();
 
-  Array<double> ar (n);
+  Array<double> ar (n, 1);
   double *par = ar.fortran_vec ();
 
-  Array<double> ai (n);
+  Array<double> ai (n, 1);
   double *pai = ai.fortran_vec ();
 
-  Array<double> beta (n);
+  Array<double> beta (n, 1);
   double *pbeta = beta.fortran_vec ();
 
   octave_idx_type tnvr = calc_ev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
@@ -525,17 +525,17 @@ EIG::init (const Matrix& a, const Matrix
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork);
+      Array<double> work (lwork, 1);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
@@ -634,17 +634,17 @@ EIG::symmetric_init (const Matrix& a, co
                            btmp_data, n, 
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (lwork);
+      Array<double> work (lwork, 1);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -725,34 +725,34 @@ EIG::init (const ComplexMatrix& a, const
   octave_idx_type nvr = calc_ev ? n : 0;
   ComplexMatrix vtmp (nvr, nvr);
   Complex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 8*n;
-  Array<double> rwork (lrwork);
+  Array<double> rwork (lrwork, 1);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n, 
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork);
+      Array<Complex> work (lwork, 1);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -811,32 +811,32 @@ EIG::hermitian_init (const ComplexMatrix
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<double> rwork (lrwork);
+  Array<double> rwork (lrwork, 1);
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n, 
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (lwork);
+      Array<Complex> work (lwork, 1);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -24,23 +24,23 @@ OPTION
   NAME = "absolute tolerance"
   DOC_ITEM
 Absolute tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector.
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
-    $OPTVAR.resize (1);
+    $OPTVAR.resize (1, 1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
       {
-        $OPTVAR.resize (1);
+        $OPTVAR.resize (1, 1);
         $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -145,22 +145,22 @@ LSODE::do_integrate (double tout)
           method_flag = 10;
 
           liw = 20;
           lrw = 22 + 16 * n;
         }
 
       maxord = maximum_order ();
 
-      iwork.resize (liw);
+      iwork.resize (liw, 1);
 
       for (octave_idx_type i = 4; i < 9; i++)
         iwork(i) = 0;
 
-      rwork.resize (lrw);
+      rwork.resize (lrw, 1);
 
       for (octave_idx_type i = 4; i < 9; i++)
         rwork(i) = 0;
 
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
diff --git a/liboctave/MArray-C.cc b/liboctave/MArray-C.cc
--- a/liboctave/MArray-C.cc
+++ b/liboctave/MArray-C.cc
@@ -26,43 +26,19 @@ along with Octave; see the file COPYING.
 #endif
 
 // Instantiate MArrays of Complex values.
 
 #include "oct-cmplx.h"
 
 #include "MArray.h"
 #include "MArray.cc"
-template <> OCTAVE_API double MArray<Complex>::norm (double p) const;
-#include "CColVector.h"
-#include "oct-norm.h"
-
-template <>
-OCTAVE_API double
-MArray<Complex>::norm (double p) const
-{
-  return xnorm (ComplexColumnVector (*this), p);
-}
 
 template class OCTAVE_API MArray<Complex>;
 
 INSTANTIATE_MARRAY_FRIENDS (Complex, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<Complex>;
-
-INSTANTIATE_MARRAY2_FRIENDS (Complex, OCTAVE_API)
-
-#include "MArrayN.h"
-#include "MArrayN.cc"
-
-template class OCTAVE_API MArrayN<Complex>;
-
-INSTANTIATE_MARRAYN_FRIENDS (Complex, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<Complex>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (Complex, OCTAVE_API)
diff --git a/liboctave/MArray-d.cc b/liboctave/MArray-d.cc
--- a/liboctave/MArray-d.cc
+++ b/liboctave/MArray-d.cc
@@ -23,43 +23,19 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 // Instantiate MArrays of double values.
 
 #include "MArray.h"
 #include "MArray.cc"
-template <> OCTAVE_API double MArray<double>::norm (double p) const;
-#include "dColVector.h"
-#include "oct-norm.h"
-
-template <>
-OCTAVE_API double
-MArray<double>::norm (double p) const
-{
-  return xnorm (ColumnVector (*this), p);
-}
 
 template class OCTAVE_API MArray<double>;
 
 INSTANTIATE_MARRAY_FRIENDS (double, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<double>;
-
-INSTANTIATE_MARRAY2_FRIENDS (double, OCTAVE_API)
-
-#include "MArrayN.h"
-#include "MArrayN.cc"
-
-template class OCTAVE_API MArrayN<double>;
-
-INSTANTIATE_MARRAYN_FRIENDS (double, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<double>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (double, OCTAVE_API)
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -53,30 +53,16 @@ along with Octave; see the file COPYING.
 
 // Instantiate all the MArray friends for MArray element type T.
 #define INSTANTIATE_MARRAY_FRIENDS(T, API) \
   MARRAY_OP_ASSIGN_DEFS1 (MArray, T, T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArray, T, MArray<T>, API) \
   MARRAY_UNOP_DEFS (MArray, T, API) \
   MARRAY_BINOP_DEFS (MArray, T, API)
 
-// Instantiate all the MArray2 friends for MArray2 element type T.
-#define INSTANTIATE_MARRAY2_FRIENDS(T, API) \
-  MARRAY_OP_ASSIGN_DEFS1 (MArray2, T, T, API) \
-  MARRAY_OP_ASSIGN_DEFS (MArray2, T, MArray2<T>, API) \
-  MARRAY_UNOP_DEFS (MArray2, T, API) \
-  MARRAY_BINOP_DEFS (MArray2, T, API)
-
-// Instantiate all the MArrayN friends for MArrayN element type T.
-#define INSTANTIATE_MARRAYN_FRIENDS(T, API) \
-  MARRAY_OP_ASSIGN_DEFS1 (MArrayN, T, T, API) \
-  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, MArrayN<T>, API) \
-  MARRAY_UNOP_DEFS (MArrayN, T, API) \
-  MARRAY_BINOP_DEFS (MArrayN, T, API)
-
 // Instantiate all the MDiagArray2 friends for MDiagArray2 element type T.
 #define INSTANTIATE_MDIAGARRAY2_FRIENDS(T, API) \
   MARRAY_UNOP_DEFS (MDiagArray2, T, API) \
   MDIAGARRAY2_BINOP_DEFS (MDiagArray2, T, API)
 
 // Now we have all the definitions we need.
 
 #endif
diff --git a/liboctave/MArray-f.cc b/liboctave/MArray-f.cc
--- a/liboctave/MArray-f.cc
+++ b/liboctave/MArray-f.cc
@@ -24,43 +24,19 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 // Instantiate MArrays of float values.
 
 #include "MArray.h"
 #include "MArray.cc"
-template <> OCTAVE_API float MArray<float>::norm (float p) const;
-#include "fColVector.h"
-#include "oct-norm.h"
-
-template <>
-OCTAVE_API float
-MArray<float>::norm (float p) const
-{
-  return xnorm (FloatColumnVector (*this), p);
-}
 
 template class OCTAVE_API MArray<float>;
 
 INSTANTIATE_MARRAY_FRIENDS (float, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<float>;
-
-INSTANTIATE_MARRAY2_FRIENDS (float, OCTAVE_API)
-
-#include "MArrayN.h"
-#include "MArrayN.cc"
-
-template class OCTAVE_API MArrayN<float>;
-
-INSTANTIATE_MARRAYN_FRIENDS (float, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<float>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (float, OCTAVE_API)
diff --git a/liboctave/MArray-fC.cc b/liboctave/MArray-fC.cc
--- a/liboctave/MArray-fC.cc
+++ b/liboctave/MArray-fC.cc
@@ -26,43 +26,19 @@ along with Octave; see the file COPYING.
 #endif
 
 // Instantiate MArrays of FloatComplex values.
 
 #include "oct-cmplx.h"
 
 #include "MArray.h"
 #include "MArray.cc"
-template <> OCTAVE_API float MArray<FloatComplex>::norm (float p) const;
-#include "fCColVector.h"
-#include "oct-norm.h"
-
-template <>
-OCTAVE_API float
-MArray<FloatComplex>::norm (float p) const
-{
-  return xnorm (FloatComplexColumnVector (*this), p);
-}
 
 template class OCTAVE_API MArray<FloatComplex>;
 
 INSTANTIATE_MARRAY_FRIENDS (FloatComplex, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<FloatComplex>;
-
-INSTANTIATE_MARRAY2_FRIENDS (FloatComplex, OCTAVE_API)
-
-#include "MArrayN.h"
-#include "MArrayN.cc"
-
-template class OCTAVE_API MArrayN<FloatComplex>;
-
-INSTANTIATE_MARRAYN_FRIENDS (FloatComplex, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<FloatComplex>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (FloatComplex, OCTAVE_API)
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -52,48 +52,14 @@ template class OCTAVE_API MArray<octave_
 template class OCTAVE_API MArray<octave_uint32>;
 template class OCTAVE_API MArray<octave_uint64>;
 
 INSTANTIATE_MARRAY_FRIENDS (octave_uint8, OCTAVE_API)
 INSTANTIATE_MARRAY_FRIENDS (octave_uint16, OCTAVE_API)
 INSTANTIATE_MARRAY_FRIENDS (octave_uint32, OCTAVE_API)
 INSTANTIATE_MARRAY_FRIENDS (octave_uint64, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<int>;
-
-INSTANTIATE_MARRAY2_FRIENDS (int, OCTAVE_API)
-
-#include "MArrayN.h"
-#include "MArrayN.cc"
-
-template class OCTAVE_API MArrayN<int>;
-
-INSTANTIATE_MARRAYN_FRIENDS (int, OCTAVE_API)
-
-template class OCTAVE_API MArrayN<octave_int8>;
-template class OCTAVE_API MArrayN<octave_int16>;
-template class OCTAVE_API MArrayN<octave_int32>;
-template class OCTAVE_API MArrayN<octave_int64>;
-
-INSTANTIATE_MARRAYN_FRIENDS (octave_int8, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int16, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int32, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_int64, OCTAVE_API)
-
-template class OCTAVE_API MArrayN<octave_uint8>;
-template class OCTAVE_API MArrayN<octave_uint16>;
-template class OCTAVE_API MArrayN<octave_uint32>;
-template class OCTAVE_API MArrayN<octave_uint64>;
-
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint8, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint16, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint32, OCTAVE_API)
-INSTANTIATE_MARRAYN_FRIENDS (octave_uint64, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<int>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (int, OCTAVE_API)
diff --git a/liboctave/MArray-s.cc b/liboctave/MArray-s.cc
--- a/liboctave/MArray-s.cc
+++ b/liboctave/MArray-s.cc
@@ -28,21 +28,14 @@ along with Octave; see the file COPYING.
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template class OCTAVE_API MArray<short>;
 
 INSTANTIATE_MARRAY_FRIENDS (short, OCTAVE_API)
 
-#include "MArray2.h"
-#include "MArray2.cc"
-
-template class OCTAVE_API MArray2<short>;
-
-INSTANTIATE_MARRAY2_FRIENDS (short, OCTAVE_API)
-
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<short>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (short, OCTAVE_API)
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -26,37 +26,129 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "MArray.h"
 #include "Array-util.h"
 #include "lo-error.h"
 
 #include "MArray-defs.h"
+#include "mx-inlines.cc"
 
-// One dimensional array with math ops.
+template <class T>
+struct _idxadds_helper
+{
+  T *array;
+  T val;
+  _idxadds_helper (T *a, T v) : array (a), val (v) { }
+  void operator () (octave_idx_type i)
+    { array[i] += val; }
+};
 
 template <class T>
-double
-MArray<T>::norm (double) const
+struct _idxadda_helper
+{
+  T *array;
+  const T *vals;
+  _idxadda_helper (T *a, const T *v) : array (a), vals (v) { }
+  void operator () (octave_idx_type i)
+    { array[i] += *vals++; }
+};
+
+template <class T>
+void
+MArray<T>::idx_add (const idx_vector& idx, T val)
 {
-  (*current_liboctave_error_handler)
-    ("norm: only implemented for double and complex values");
+  octave_idx_type n = this->length ();
+  octave_idx_type ext = idx.extent (n);
+  if (ext > n)
+    {
+      this->resize1 (ext);
+      n = ext;
+    }
 
-  return 0;
+  octave_quit ();
+
+  octave_idx_type len = idx.length (n);
+  idx.loop (len, _idxadds_helper<T> (this->fortran_vec (), val));
 }
 
 template <class T>
-float
-MArray<T>::norm (float) const
+void
+MArray<T>::idx_add (const idx_vector& idx, const MArray<T>& vals)
+{
+  octave_idx_type n = this->length ();
+  octave_idx_type ext = idx.extent (n);
+  if (ext > n)
+    {
+      this->resize1 (ext);
+      n = ext;
+    }
+
+  octave_quit ();
+
+  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
+}
+
+template <class T, T op (typename ref_param<T>::type, typename ref_param<T>::type)>
+struct _idxbinop_helper
+{
+  T *array;
+  const T *vals;
+  _idxbinop_helper (T *a, const T *v) : array (a), vals (v) { }
+  void operator () (octave_idx_type i)
+    { array[i] = op (array[i], *vals++); }
+};
+
+template <class T>
+void
+MArray<T>::idx_min (const idx_vector& idx, const MArray<T>& vals)
 {
-  (*current_liboctave_error_handler)
-    ("norm: only implemented for double and complex values");
+  octave_idx_type n = this->length ();
+  octave_idx_type ext = idx.extent (n);
+  if (ext > n)
+    {
+      this->resize1 (ext);
+      n = ext;
+    }
+
+  octave_quit ();
+
+  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (), vals.data ()));
+}
 
-  return 0;
+template <class T>
+void
+MArray<T>::idx_max (const idx_vector& idx, const MArray<T>& vals)
+{
+  octave_idx_type n = this->length ();
+  octave_idx_type ext = idx.extent (n);
+  if (ext > n)
+    {
+      this->resize1 (ext);
+      n = ext;
+    }
+
+  octave_quit ();
+
+  octave_idx_type len = std::min (idx.length (n), vals.length ());
+  idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (), vals.data ()));
+}
+
+// N-dimensional array with math ops.
+template <class T>
+void
+MArray<T>::changesign (void)
+{
+  if (Array<T>::is_shared ())
+    *this = - *this;
+  else
+    do_mx_inplace_op<MArray<T> > (*this, mx_inline_uminus2);
 }
 
 // Element by element MArray by scalar ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
 {
@@ -119,16 +211,17 @@ operator -= (MArray<T>& a, const MArray<
 {
   if (a.is_shared ())
     a = a - b;
   else
     do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_sub2, "-=");
   return a;
 }
 
+
 template <class T>
 MArray<T>&
 product_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = product (a, b);
   else
     do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_mul2, ".*=");
@@ -143,60 +236,58 @@ quotient_eq (MArray<T>& a, const MArray<
     return a = quotient (a, b);
   else
     do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_div2, "./=");
   return a;
 }
 
 // Element by element MArray by scalar ops.
 
-#define MARRAY_AS_OP(OP, FN) \
+#define MARRAY_NDS_OP(OP, FN) \
   template <class T> \
   MArray<T> \
   operator OP (const MArray<T>& a, const T& s) \
   { \
     return do_ms_binary_op<MArray<T>, MArray<T>, T> (a, s, FN); \
   }
 
-MARRAY_AS_OP (+, mx_inline_add)
-MARRAY_AS_OP (-, mx_inline_sub)
-MARRAY_AS_OP (*, mx_inline_mul)
-MARRAY_AS_OP (/, mx_inline_div)
+MARRAY_NDS_OP (+, mx_inline_add)
+MARRAY_NDS_OP (-, mx_inline_sub)
+MARRAY_NDS_OP (*, mx_inline_mul)
+MARRAY_NDS_OP (/, mx_inline_div)
 
 // Element by element scalar by MArray ops.
 
-#define MARRAY_SA_OP(OP, FN) \
+#define MARRAY_SND_OP(OP, FN) \
   template <class T> \
   MArray<T> \
   operator OP (const T& s, const MArray<T>& a) \
   { \
     return do_sm_binary_op<MArray<T>, T, MArray<T> > (s, a, FN); \
   }
 
-MARRAY_SA_OP(+, mx_inline_add)
-MARRAY_SA_OP(-, mx_inline_sub)
-MARRAY_SA_OP(*, mx_inline_mul)
-MARRAY_SA_OP(/, mx_inline_div)
+MARRAY_SND_OP (+, mx_inline_add)
+MARRAY_SND_OP (-, mx_inline_sub)
+MARRAY_SND_OP (*, mx_inline_mul)
+MARRAY_SND_OP (/, mx_inline_div)
 
 // Element by element MArray by MArray ops.
 
-#define MARRAY_AA_OP(FCN, OP, FN) \
+#define MARRAY_NDND_OP(FCN, OP, FN) \
   template <class T> \
   MArray<T> \
   FCN (const MArray<T>& a, const MArray<T>& b) \
   { \
     return do_mm_binary_op<MArray<T>, MArray<T>, MArray<T> > (a, b, FN, #FCN); \
   }
 
-MARRAY_AA_OP (operator +, +, mx_inline_add)
-MARRAY_AA_OP (operator -, -, mx_inline_sub)
-MARRAY_AA_OP (product,    *, mx_inline_mul)
-MARRAY_AA_OP (quotient,   /, mx_inline_div)
-
-// Unary MArray ops.
+MARRAY_NDND_OP (operator +, +, mx_inline_add)
+MARRAY_NDND_OP (operator -, -, mx_inline_sub)
+MARRAY_NDND_OP (product,    *, mx_inline_mul)
+MARRAY_NDND_OP (quotient,   /, mx_inline_div)
 
 template <class T>
 MArray<T>
 operator + (const MArray<T>& a)
 {
   return a;
 }
 
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -22,75 +22,86 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_MArray_h)
 #define octave_MArray_h 1
 
 #include "Array.h"
 
-// One dimensional array with math ops.
+// N-dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
 protected:
 
-  MArray (T *d, octave_idx_type l) : Array<T> (d, l) { }
+  MArray (T *d, octave_idx_type m, octave_idx_type n) : Array<T> (d, m, n) { }
+  MArray (T *d, const dim_vector& dv) : Array<T> (d, dv) { }
 
 public:
   
-  MArray (void) : Array<T> () { }
+  MArray (void) : Array<T> () {}
+  
+  explicit MArray (octave_idx_type m, octave_idx_type n) 
+    : Array<T> (m, n) { }
 
-  explicit MArray (octave_idx_type n) : Array<T> (n) { }
+  explicit MArray (octave_idx_type m, octave_idx_type n, const T& val) 
+    : Array<T> (m, n, val) { }
 
-  MArray (octave_idx_type n, const T& val) : Array<T> (n, val) { }
+  explicit MArray (const dim_vector& dv) 
+    : Array<T> (dv) { }
+  
+  explicit MArray (const dim_vector& dv, const T& val) 
+    : Array<T> (dv, val) { }
 
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
-  // FIXME: kluge.
-  MArray (const Array<T>& a) : Array<T> (a, dim_vector (a.length ())) { }
-
-  MArray (const dim_vector& dv) : Array<T> (dv) { }
+  template <class U>
+  MArray (const Array<U>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
     {
       Array<T>::operator = (a);
       return *this;
     }
 
-  // FIXME: kluge again. This design really sucks.
-  void resize (octave_idx_type n, const T& val = Array<T>::resize_fill_value ())
-    { Array<T>::resize_fill (n, 1, val); }
+  MArray<T> reshape (const dim_vector& new_dims) const
+    { return Array<T>::reshape (new_dims); }
+
+  MArray<T> permute (const Array<octave_idx_type>& vec, 
+                      bool inv = false) const
+    { return Array<T>::permute (vec, inv); }
 
-  MArray<T> transpose (void) const { return Array<T>::transpose (); }
-  MArray<T> hermitian (T (*fcn) (const T&) = 0) const { return Array<T>::hermitian (fcn); }
+  MArray<T> ipermute (const Array<octave_idx_type>& vec) const
+    { return Array<T>::ipermute (vec); }
 
-  double norm (double p) const;
-  float norm (float p) const;
+  MArray squeeze (void) const { return Array<T>::squeeze (); }
+
+  MArray<T> transpose (void) const
+    { return Array<T>::transpose (); }
 
-  // FIXME: should go away.
-  template <class U>
-  MArray<U>
-  map (U (&fcn) (T)) const
-  { return Array<T>::template map<U> (fcn); }
+  MArray<T> hermitian (T (*fcn) (const T&) = 0) const
+    { return Array<T>::hermitian (fcn); }
+
+  // Performs indexed accumulative addition.
+
+  void idx_add (const idx_vector& idx, T val);
 
-  template <class U>
-  MArray<U>
-  map (U (&fcn) (const T&)) const
-  { return Array<T>::template map<U> (fcn); }
+  void idx_add (const idx_vector& idx, const MArray<T>& vals);
+
+  void idx_min (const idx_vector& idx, const MArray<T>& vals);
 
-  // Currently, the OPS functions don't need to be friends, but that
-  // may change.
+  void idx_max (const idx_vector& idx, const MArray<T>& vals);
 
-  // MARRAY_OPS_FRIEND_DECLS (MArray)
+  void changesign (void);
 };
 
 #endif
diff --git a/liboctave/MArray2.cc b/liboctave/MArray2.cc
deleted file mode 100644
--- a/liboctave/MArray2.cc
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007
-              John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "MArray2.h"
-#include "Array-util.h"
-#include "lo-error.h"
-
-#include "MArray-defs.h"
-
-// Two dimensional array with math ops.
-
-// Element by element MArray2 by scalar ops.
-
-template <class T>
-MArray2<T>&
-operator += (MArray2<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a + s;
-  else
-    do_ms_inplace_op<MArray2<T>, T> (a, s, mx_inline_add2);
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator -= (MArray2<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a - s;
-  else
-    do_ms_inplace_op<MArray2<T>, T> (a, s, mx_inline_sub2);
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator *= (MArray2<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a * s;
-  else
-    do_ms_inplace_op<MArray2<T>, T> (a, s, mx_inline_mul2);
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator /= (MArray2<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a / s;
-  else
-    do_ms_inplace_op<MArray2<T>, T> (a, s, mx_inline_div2);
-  return a;
-}
-
-// Element by element MArray2 by MArray2 ops.
-
-template <class T>
-MArray2<T>&
-operator += (MArray2<T>& a, const MArray2<T>& b)
-{
-  if (a.is_shared ())
-    a = a + b;
-  else
-    do_mm_inplace_op<MArray2<T>, MArray2<T> > (a, b, mx_inline_add2, "+=");
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-operator -= (MArray2<T>& a, const MArray2<T>& b)
-{
-  if (a.is_shared ())
-    a = a - b;
-  else
-    do_mm_inplace_op<MArray2<T>, MArray2<T> > (a, b, mx_inline_sub2, "-=");
-  return a;
-}
-
-
-template <class T>
-MArray2<T>&
-product_eq (MArray2<T>& a, const MArray2<T>& b)
-{
-  if (a.is_shared ())
-    return a = product (a, b);
-  else
-    do_mm_inplace_op<MArray2<T>, MArray2<T> > (a, b, mx_inline_mul2, ".*=");
-  return a;
-}
-
-template <class T>
-MArray2<T>&
-quotient_eq (MArray2<T>& a, const MArray2<T>& b)
-{
-  if (a.is_shared ())
-    return a = quotient (a, b);
-  else
-    do_mm_inplace_op<MArray2<T>, MArray2<T> > (a, b, mx_inline_div2, "./=");
-  return a;
-}
-
-// Element by element MArray2 by scalar ops.
-
-#define MARRAY_A2S_OP(OP, FN) \
-  template <class T> \
-  MArray2<T> \
-  operator OP (const MArray2<T>& a, const T& s) \
-  { \
-    return do_ms_binary_op<MArray2<T>, MArray2<T>, T> (a, s, FN); \
-  }
-
-MARRAY_A2S_OP (+, mx_inline_add)
-MARRAY_A2S_OP (-, mx_inline_sub)
-MARRAY_A2S_OP (*, mx_inline_mul)
-MARRAY_A2S_OP (/, mx_inline_div)
-
-// Element by element scalar by MArray2 ops.
-
-#define MARRAY_SA2_OP(OP, FN) \
-  template <class T> \
-  MArray2<T> \
-  operator OP (const T& s, const MArray2<T>& a) \
-  { \
-    return do_sm_binary_op<MArray2<T>, T, MArray2<T> > (s, a, FN); \
-  }
-
-MARRAY_SA2_OP (+, mx_inline_add)
-MARRAY_SA2_OP (-, mx_inline_sub)
-MARRAY_SA2_OP (*, mx_inline_mul)
-MARRAY_SA2_OP (/, mx_inline_div)
-
-// Element by element MArray2 by MArray2 ops.
-
-#define MARRAY_A2A2_OP(FCN, OP, FN) \
-  template <class T> \
-  MArray2<T> \
-  FCN (const MArray2<T>& a, const MArray2<T>& b) \
-  { \
-    return do_mm_binary_op<MArray2<T>, MArray2<T>, MArray2<T> > (a, b, FN, #FCN); \
-  }
-
-MARRAY_A2A2_OP (operator +, +, mx_inline_add)
-MARRAY_A2A2_OP (operator -, -, mx_inline_sub)
-MARRAY_A2A2_OP (product,    *, mx_inline_mul)
-MARRAY_A2A2_OP (quotient,   /, mx_inline_div)
-
-// Unary MArray2 ops.
-
-template <class T>
-MArray2<T>
-operator + (const MArray2<T>& a)
-{
-  return a;
-}
-
-template <class T>
-MArray2<T>
-operator - (const MArray2<T>& a)
-{
-  return do_mx_unary_op<MArray2<T>, MArray2<T> > (a, mx_inline_uminus); 
-}
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -20,88 +20,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_MArray2_h)
 #define octave_MArray2_h 1
 
-#include "Array2.h"
-
-// Two dimensional array with math ops.
-
-// But first, some preprocessor abuse...
-
-#include "MArray-decl.h"
-
-MARRAY_OPS_FORWARD_DECLS (MArray2, )
-
-template <class T>
-class
-MArray2 : public Array2<T>
-{
-protected:
-
-  MArray2 (T *d, octave_idx_type n, octave_idx_type m) : Array2<T> (d, n, m) { }
-
-public:
-
-  MArray2 (void) : Array2<T> () { }
-
-  MArray2 (octave_idx_type n, octave_idx_type m) : Array2<T> (n, m) { }
-
-  MArray2 (octave_idx_type n, octave_idx_type m, const T& val) : Array2<T> (n, m, val) { }
-
-  MArray2 (const dim_vector& dv) : Array2<T> (dv) { }
-
-  MArray2 (const dim_vector& dv, const T& val) : Array2<T> (dv, val) { }
-
-  MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
-
-  MArray2 (const Array2<T>& a) : Array2<T> (a) { }
-
-  template <class U>
-  MArray2 (const Array2<U>& a) : Array2<T> (a) { }
+#include "MArray.h"
+#define MArray2 MArray
 
-  template <class U>
-  MArray2 (const MArray2<U>& a) : Array2<T> (a) { }
-
-  ~MArray2 (void) { }
-
-  MArray2<T>& operator = (const MArray2<T>& a)
-    {
-      Array2<T>::operator = (a);
-      return *this;
-    }
-
-  MArray2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
-  {
-    Array2<T>::insert (a, r, c);
-    return *this;
-  }
-
-  MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
-  MArray2<T> hermitian (T (*fcn) (const T&) = 0) const { return Array2<T>::hermitian (fcn); }
+// If we're with GNU C++, issue a warning.
+#ifdef __GNUC__
+#warning Using MArray2<T> is deprecated. Use MArray<T>.
+#endif
 
-  MArray2<T> diag (octave_idx_type k) const
-  {
-    return Array2<T>::diag (k);
-  }
 
-  // FIXME: should go away.
-  template <class U>
-  MArray2<U>
-  map (U (&fcn) (T)) const
-  { return Array2<T>::template map<U> (fcn); }
-
-  template <class U>
-  MArray2<U>
-  map (U (&fcn) (const T&)) const
-  { return Array2<T>::template map<U> (fcn); }
-
-  // Currently, the OPS functions don't need to be friends, but that
-  // may change.
-
-  // MARRAY_OPS_FRIEND_DECLS (MArray2)
-};
 
 #endif
diff --git a/liboctave/MArrayN.cc b/liboctave/MArrayN.cc
deleted file mode 100644
--- a/liboctave/MArrayN.cc
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997, 2003, 2004, 2005, 2007, 2009 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "MArrayN.h"
-#include "Array-util.h"
-#include "lo-error.h"
-
-#include "MArray-defs.h"
-#include "mx-inlines.cc"
-
-template <class T>
-struct _idxadds_helper
-{
-  T *array;
-  T val;
-  _idxadds_helper (T *a, T v) : array (a), val (v) { }
-  void operator () (octave_idx_type i)
-    { array[i] += val; }
-};
-
-template <class T>
-struct _idxadda_helper
-{
-  T *array;
-  const T *vals;
-  _idxadda_helper (T *a, const T *v) : array (a), vals (v) { }
-  void operator () (octave_idx_type i)
-    { array[i] += *vals++; }
-};
-
-template <class T>
-void
-MArrayN<T>::idx_add (const idx_vector& idx, T val)
-{
-  octave_idx_type n = this->length ();
-  octave_idx_type ext = idx.extent (n);
-  if (ext > n)
-    {
-      this->resize (ext);
-      n = ext;
-    }
-
-  octave_quit ();
-
-  octave_idx_type len = idx.length (n);
-  idx.loop (len, _idxadds_helper<T> (this->fortran_vec (), val));
-}
-
-template <class T>
-void
-MArrayN<T>::idx_add (const idx_vector& idx, const MArrayN<T>& vals)
-{
-  octave_idx_type n = this->length ();
-  octave_idx_type ext = idx.extent (n);
-  if (ext > n)
-    {
-      this->resize (ext);
-      n = ext;
-    }
-
-  octave_quit ();
-
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
-  idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
-}
-
-template <class T, T op (typename ref_param<T>::type, typename ref_param<T>::type)>
-struct _idxbinop_helper
-{
-  T *array;
-  const T *vals;
-  _idxbinop_helper (T *a, const T *v) : array (a), vals (v) { }
-  void operator () (octave_idx_type i)
-    { array[i] = op (array[i], *vals++); }
-};
-
-template <class T>
-void
-MArrayN<T>::idx_min (const idx_vector& idx, const MArrayN<T>& vals)
-{
-  octave_idx_type n = this->length ();
-  octave_idx_type ext = idx.extent (n);
-  if (ext > n)
-    {
-      this->resize (ext);
-      n = ext;
-    }
-
-  octave_quit ();
-
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
-  idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (), vals.data ()));
-}
-
-template <class T>
-void
-MArrayN<T>::idx_max (const idx_vector& idx, const MArrayN<T>& vals)
-{
-  octave_idx_type n = this->length ();
-  octave_idx_type ext = idx.extent (n);
-  if (ext > n)
-    {
-      this->resize (ext);
-      n = ext;
-    }
-
-  octave_quit ();
-
-  octave_idx_type len = std::min (idx.length (n), vals.length ());
-  idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (), vals.data ()));
-}
-
-// N-dimensional array with math ops.
-template <class T>
-void
-MArrayN<T>::changesign (void)
-{
-  if (Array<T>::is_shared ())
-    *this = - *this;
-  else
-    do_mx_inplace_op<MArrayN<T> > (*this, mx_inline_uminus2);
-}
-
-// Element by element MArrayN by scalar ops.
-
-template <class T>
-MArrayN<T>&
-operator += (MArrayN<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a + s;
-  else
-    do_ms_inplace_op<MArrayN<T>, T> (a, s, mx_inline_add2);
-  return a;
-}
-
-template <class T>
-MArrayN<T>&
-operator -= (MArrayN<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a - s;
-  else
-    do_ms_inplace_op<MArrayN<T>, T> (a, s, mx_inline_sub2);
-  return a;
-}
-
-template <class T>
-MArrayN<T>&
-operator *= (MArrayN<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a * s;
-  else
-    do_ms_inplace_op<MArrayN<T>, T> (a, s, mx_inline_mul2);
-  return a;
-}
-
-template <class T>
-MArrayN<T>&
-operator /= (MArrayN<T>& a, const T& s)
-{
-  if (a.is_shared ())
-    a = a / s;
-  else
-    do_ms_inplace_op<MArrayN<T>, T> (a, s, mx_inline_div2);
-  return a;
-}
-
-// Element by element MArrayN by MArrayN ops.
-
-template <class T>
-MArrayN<T>&
-operator += (MArrayN<T>& a, const MArrayN<T>& b)
-{
-  if (a.is_shared ())
-    a = a + b;
-  else
-    do_mm_inplace_op<MArrayN<T>, MArrayN<T> > (a, b, mx_inline_add2, "+=");
-  return a;
-}
-
-template <class T>
-MArrayN<T>&
-operator -= (MArrayN<T>& a, const MArrayN<T>& b)
-{
-  if (a.is_shared ())
-    a = a - b;
-  else
-    do_mm_inplace_op<MArrayN<T>, MArrayN<T> > (a, b, mx_inline_sub2, "-=");
-  return a;
-}
-
-
-template <class T>
-MArrayN<T>&
-product_eq (MArrayN<T>& a, const MArrayN<T>& b)
-{
-  if (a.is_shared ())
-    return a = product (a, b);
-  else
-    do_mm_inplace_op<MArrayN<T>, MArrayN<T> > (a, b, mx_inline_mul2, ".*=");
-  return a;
-}
-
-template <class T>
-MArrayN<T>&
-quotient_eq (MArrayN<T>& a, const MArrayN<T>& b)
-{
-  if (a.is_shared ())
-    return a = quotient (a, b);
-  else
-    do_mm_inplace_op<MArrayN<T>, MArrayN<T> > (a, b, mx_inline_div2, "./=");
-  return a;
-}
-
-// Element by element MArrayN by scalar ops.
-
-#define MARRAY_NDS_OP(OP, FN) \
-  template <class T> \
-  MArrayN<T> \
-  operator OP (const MArrayN<T>& a, const T& s) \
-  { \
-    return do_ms_binary_op<MArrayN<T>, MArrayN<T>, T> (a, s, FN); \
-  }
-
-MARRAY_NDS_OP (+, mx_inline_add)
-MARRAY_NDS_OP (-, mx_inline_sub)
-MARRAY_NDS_OP (*, mx_inline_mul)
-MARRAY_NDS_OP (/, mx_inline_div)
-
-// Element by element scalar by MArrayN ops.
-
-#define MARRAY_SND_OP(OP, FN) \
-  template <class T> \
-  MArrayN<T> \
-  operator OP (const T& s, const MArrayN<T>& a) \
-  { \
-    return do_sm_binary_op<MArrayN<T>, T, MArrayN<T> > (s, a, FN); \
-  }
-
-MARRAY_SND_OP (+, mx_inline_add)
-MARRAY_SND_OP (-, mx_inline_sub)
-MARRAY_SND_OP (*, mx_inline_mul)
-MARRAY_SND_OP (/, mx_inline_div)
-
-// Element by element MArrayN by MArrayN ops.
-
-#define MARRAY_NDND_OP(FCN, OP, FN) \
-  template <class T> \
-  MArrayN<T> \
-  FCN (const MArrayN<T>& a, const MArrayN<T>& b) \
-  { \
-    return do_mm_binary_op<MArrayN<T>, MArrayN<T>, MArrayN<T> > (a, b, FN, #FCN); \
-  }
-
-MARRAY_NDND_OP (operator +, +, mx_inline_add)
-MARRAY_NDND_OP (operator -, -, mx_inline_sub)
-MARRAY_NDND_OP (product,    *, mx_inline_mul)
-MARRAY_NDND_OP (quotient,   /, mx_inline_div)
-
-template <class T>
-MArrayN<T>
-operator + (const MArrayN<T>& a)
-{
-  return a;
-}
-
-template <class T>
-MArrayN<T>
-operator - (const MArrayN<T>& a)
-{
-  return do_mx_unary_op<MArrayN<T>, MArrayN<T> > (a, mx_inline_uminus); 
-}
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -20,84 +20,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_MArrayN_h)
 #define octave_MArrayN_h 1
 
-#include "Array.h"
-#include "MArray2.h"
-#include "dim-vector.h"
-
-// N-dimensional array with math ops.
-
-// But first, some preprocessor abuse...
-
-#include "MArray-decl.h"
-
-MARRAY_OPS_FORWARD_DECLS (MArrayN, )
-
-template <class T>
-class
-MArrayN : public Array<T>
-{
-protected:
-
-  MArrayN (T *d, const dim_vector& dv) : Array<T> (d, dv) { }
-
-public:
-  
-  MArrayN (void) : Array<T> () {}
-  
-  MArrayN (const dim_vector& dv) : Array<T> (dv) { }
-  
-  MArrayN (const dim_vector& dv, const T& val) : Array<T> (dv, val) { }
-
-  template <class U>
-  explicit MArrayN (const Array2<U>& a) : Array<T> (a) { }
-
-  template <class U>
-  MArrayN (const Array<U>& a) : Array<T> (a) { }
-
-  template <class U>
-  MArrayN (const MArrayN<U>& a) : Array<T> (a) { }
+#include "MArray.h"
+#define MArrayN MArray
 
-  ~MArrayN (void) { }
-
-  MArrayN<T>& operator = (const MArrayN<T>& a)
-    {
-      Array<T>::operator = (a);
-      return *this;
-    }
-
-  MArrayN<T> reshape (const dim_vector& new_dims) const
-    { return Array<T>::reshape (new_dims); }
-
-  MArrayN<T> permute (const Array<octave_idx_type>& vec, 
-                      bool inv = false) const
-    { return Array<T>::permute (vec, inv); }
-
-  MArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return Array<T>::ipermute (vec); }
-
-  MArrayN squeeze (void) const { return Array<T>::squeeze (); }
-
-  MArrayN<T> diag (octave_idx_type k) const
-  {
-    return Array<T>::diag (k);
-  }
-
-  // Performs indexed accumulative addition.
-
-  void idx_add (const idx_vector& idx, T val);
-
-  void idx_add (const idx_vector& idx, const MArrayN<T>& vals);
-
-  void idx_min (const idx_vector& idx, const MArrayN<T>& vals);
-
-  void idx_max (const idx_vector& idx, const MArrayN<T>& vals);
-
-  void changesign (void);
-};
+// If we're with GNU C++, issue a warning.
+#ifdef __GNUC__
+#warning Using MArrayN<T> is deprecated. Use MArray<T>.
+#endif
 
 #endif
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_MDiagArray2_h)
 #define octave_MDiagArray2_h 1
 
 #include "DiagArray2.h"
-#include "MArray2.h"
 #include "MArray.h"
 
 // Two dimensional diagonal array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-decl.h"
 
@@ -67,17 +66,17 @@ public:
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
 
-  operator MArray2<T> () const
+  operator MArray<T> () const
     {
       return DiagArray2<T>::operator Array2<T> ();
     }
 
   octave_idx_type nnz (void) const
     {
       octave_idx_type retval = 0;
 
diff --git a/liboctave/MSparse-defs.h b/liboctave/MSparse-defs.h
--- a/liboctave/MSparse-defs.h
+++ b/liboctave/MSparse-defs.h
@@ -179,17 +179,17 @@ along with Octave; see the file COPYING.
 
 // The following macros are for external use.
 
 // Instantiate all the MSparse friends for MSparse element type T.
 #define INSTANTIATE_SPARSE_FRIENDS(T, API) \
   /* SPARSE_OP_ASSIGN_DEFS (MSparse, T, T) */ \
   SPARSE_OP_ASSIGN_DEFS (MSparse, T, MSparse<T>, API) \
   SPARSE_UNOP_DEFS (MSparse, T, API) \
-  SPARSE_BINOP_DEFS (MSparse, MArray2, T, API)
+  SPARSE_BINOP_DEFS (MSparse, MArray, T, API)
 
 // Define all the MSparse forwarding functions for return type R and
 // MSparse element type T
 #define SPARSE_FORWARD_DEFS(B, R, F, T)         \
   /* SPARSE_OP_ASSIGN_FWD_DEFS  */ \
   /* (R, T, dynamic_cast<B<T>&>, R, , T) */     \
  \
   SPARSE_OP_ASSIGN_FWD_DEFS \
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 #include "lo-error.h"
-#include "MArray2.h"
+#include "MArray.h"
 #include "Array-util.h"
 
 #include "MSparse.h"
 #include "MSparse-defs.h"
 
 // sparse array with math ops.
 
 // Element by element MSparse by MSparse ops.
@@ -182,23 +182,23 @@ operator -= (MSparse<T>& a, const MSpars
 
     return a;
 }
 
 // Element by element MSparse by scalar ops.
 
 #define SPARSE_A2S_OP_1(OP) \
   template <class T> \
-  MArray2<T> \
+  MArray<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray2<T> r (nr, nc, (0.0 OP s));  \
+    MArray<T> r (nr, nc, (0.0 OP s));  \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
         r.elem (a.ridx (i), j) = a.data (i) OP s;       \
     return r; \
   }
 
 #define SPARSE_A2S_OP_2(OP) \
@@ -228,23 +228,23 @@ SPARSE_A2S_OP_1 (+)
 SPARSE_A2S_OP_1 (-)
 SPARSE_A2S_OP_2 (*)
 SPARSE_A2S_OP_2 (/)
 
 // Element by element scalar by MSparse ops.
 
 #define SPARSE_SA2_OP_1(OP) \
   template <class T> \
-  MArray2<T> \
+  MArray<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
  \
-    MArray2<T> r (nr, nc, (s OP 0.0));  \
+    MArray<T> r (nr, nc, (s OP 0.0));  \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) \
         r.elem (a.ridx (i), j) = s OP a.data (i);       \
     return r; \
   }
 
 #define SPARSE_SA2_OP_2(OP) \
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -19,27 +19,27 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_MSparse_h)
 #define octave_MSparse_h 1
 
-#include "MArray2.h"
+#include "MArray.h"
 
 #include "Sparse.h"
 
 // Two dimensional sparse array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MSparse-defs.h"
 
-SPARSE_OPS_FORWARD_DECLS (MSparse, MArray2, )
+SPARSE_OPS_FORWARD_DECLS (MSparse, MArray, )
 
 template <class T>
 class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
@@ -126,12 +126,12 @@ public:
   template <class U>
   MSparse<U>
   map (U (&fcn) (const T&)) const
   { return Sparse<T>::template map<U> (fcn); }
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
-  // SPARSE_OPS_FRIEND_DECLS (MSparse, MArray2)
+  // SPARSE_OPS_FRIEND_DECLS (MSparse, MArray)
 };
 
 #endif
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -266,18 +266,16 @@ BUILT_INCS = \
   $(SMX_OP_INC)
 
 BUILT_SOURCES = $(BUILT_INCS)
 
 TEMPLATE_SRC = \
   Array.cc \
   DiagArray2.cc \
   MArray.cc \
-  MArray2.cc \
-  MArrayN.cc \
   MDiagArray2.cc \
   base-lu.cc \
   base-qr.cc \
   bsxfun-defs.cc \
   eigs-base.cc \
   oct-sort.cc \
   sparse-base-chol.cc \
   sparse-base-lu.cc \
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -53,17 +53,17 @@ MatrixType::MatrixType (const MatrixType
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
 template<class T> 
 MatrixType::matrix_type 
-matrix_real_probe (const MArray2<T>& a)
+matrix_real_probe (const MArray<T>& a)
 {
   MatrixType::matrix_type typ;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const T zero = 0;
  
   if (ncols == nrows)
@@ -110,17 +110,17 @@ matrix_real_probe (const MArray2<T>& a)
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
 template<class T> 
 MatrixType::matrix_type 
-matrix_complex_probe (const MArray2<T>& a)
+matrix_complex_probe (const MArray<T>& a)
 {
   MatrixType::matrix_type typ;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const typename T::value_type zero = 0;
 
   if (ncols == nrows)
diff --git a/liboctave/PermMatrix.cc b/liboctave/PermMatrix.cc
--- a/liboctave/PermMatrix.cc
+++ b/liboctave/PermMatrix.cc
@@ -52,24 +52,24 @@ PermMatrix::PermMatrix (const Array<octa
 PermMatrix::PermMatrix (const idx_vector& idx, bool colp, octave_idx_type n)
   : Array<octave_idx_type> (), _colp(colp)
 {
   octave_idx_type len = idx.length (n);
   if (! idx.is_permutation (len))
     gripe_invalid_permutation ();
   else
     {
-      Array<octave_idx_type> idxa (len);
+      Array<octave_idx_type> idxa (len, 1);
       for (octave_idx_type i = 0; i < len; i++) idxa(i) = idx(i);
       Array<octave_idx_type>::operator = (idxa);
     }
 }
 
 PermMatrix::PermMatrix (octave_idx_type n)
-  : Array<octave_idx_type> (n), _colp (false)
+  : Array<octave_idx_type> (n, 1), _colp (false)
 {
   for (octave_idx_type i = 0; i < n; i++) xelem (i) = i;
 }
 
 octave_idx_type 
 PermMatrix::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   octave_idx_type len = Array<octave_idx_type>::length ();
@@ -140,17 +140,17 @@ PermMatrix::power (octave_idx_type m) co
     {
       res_colp = ! res_colp;
       m = -m;
     }
   else if (m == 0)
     return PermMatrix (n);
 
   const octave_idx_type *p = data ();
-  Array<octave_idx_type> res_pvec (n, -1);
+  Array<octave_idx_type> res_pvec (n, 1, -1);
   octave_idx_type *q = res_pvec.fortran_vec ();
 
   for (octave_idx_type ics = 0; ics < n; ics++)
     {
       if (q[ics] > 0)
         continue;
 
       // go forward m steps or until a cycle is found.
@@ -176,17 +176,17 @@ PermMatrix::power (octave_idx_type m) co
     }
 
   return PermMatrix (res_pvec, res_colp, false);
 }
 
 PermMatrix
 PermMatrix::eye (octave_idx_type n)
 {
-  Array<octave_idx_type> p(n);
+  Array<octave_idx_type> p(n, 1);
   for (octave_idx_type i = 0; i < n; i++)
     p(i) = i;
 
   return PermMatrix (p, false, false);
 }
 
 PermMatrix 
 operator *(const PermMatrix& a, const PermMatrix& b)
@@ -199,17 +199,17 @@ operator *(const PermMatrix& a, const Pe
   else if (a._colp == b._colp)
     {
       r = PermMatrix ((a._colp 
                        ? ia.index (idx_vector (ib)) 
                        : ib.index (idx_vector (ia))), a._colp, false);
     }
   else
     {
-      Array<octave_idx_type> ra (n);
+      Array<octave_idx_type> ra (n, 1);
       if (a._colp)
         ra.assign (idx_vector (ib), ia);
       else
         ra.assign (idx_vector (ia), ib);
       r = PermMatrix (ra, a._colp, false);
     }
 
   return r;
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -121,21 +121,21 @@ float_user_function (float *x, int& ierr
 double
 DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   double *points = singularities.fortran_vec ();
   double result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
-  Array<octave_idx_type> iwork (leniw);
+  Array<octave_idx_type> iwork (leniw, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 2*leniw - npts;
-  Array<double> work (lenw);
+  Array<double> work (lenw, 1);
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
   octave_idx_type last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
@@ -155,21 +155,21 @@ DefQuad::do_integrate (octave_idx_type&,
 }
 
 double
 IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   double result = 0.0;
 
   octave_idx_type leniw = 128;
-  Array<octave_idx_type> iwork (leniw);
+  Array<octave_idx_type> iwork (leniw, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
-  Array<double> work (lenw);
+  Array<double> work (lenw, 1);
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
   octave_idx_type last;
 
   octave_idx_type inf;
   switch (type)
     {
@@ -217,21 +217,21 @@ FloatDefQuad::do_integrate (octave_idx_t
 float
 FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   float *points = singularities.fortran_vec ();
   float result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
-  Array<octave_idx_type> iwork (leniw);
+  Array<octave_idx_type> iwork (leniw, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 2*leniw - npts;
-  Array<float> work (lenw);
+  Array<float> work (lenw, 1);
   float *pwork = work.fortran_vec ();
 
   float_user_fcn = ff;
   octave_idx_type last;
 
   float abs_tol = single_precision_absolute_tolerance ();
   float rel_tol = single_precision_relative_tolerance ();
 
@@ -251,21 +251,21 @@ FloatIndefQuad::do_integrate (octave_idx
 }
 
 float
 FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
   float result = 0.0;
 
   octave_idx_type leniw = 128;
-  Array<octave_idx_type> iwork (leniw);
+  Array<octave_idx_type> iwork (leniw, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
-  Array<float> work (lenw);
+  Array<float> work (lenw, 1);
   float *pwork = work.fortran_vec ();
 
   float_user_fcn = ff;
   octave_idx_type last;
 
   octave_idx_type inf;
   switch (type)
     {
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -185,20 +185,20 @@ SparseComplexLU::SparseComplexLU (const 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   Rfact.xridx (i) = i;
                   Rfact.xcidx (i) = i;
                 }
               Rfact.xcidx (nr) = nr;
               double *Rx = Rfact.data ();
 
-              P.resize (nr);
+              P.resize (nr, 1);
               octave_idx_type *p = P.fortran_vec ();
 
-              Q.resize (nc);
+              Q.resize (nc, 1);
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
                                                     reinterpret_cast<double *> (Ltx),
                                                     0, Up, Uj,
                                                     reinterpret_cast <double *> (Ux),
                                                     0, p, q, 0, 0,
@@ -412,20 +412,20 @@ SparseComplexLU::SparseComplexLU (const 
                   for (octave_idx_type i = 0; i < nr; i++)
                     {
                       Rfact.xridx (i) = i;
                       Rfact.xcidx (i) = i;
                     }
                   Rfact.xcidx (nr) = nr;
                   double *Rx = Rfact.data ();
 
-                  P.resize (nr);
+                  P.resize (nr, 1);
                   octave_idx_type *p = P.fortran_vec ();
 
-                  Q.resize (nc);
+                  Q.resize (nc, 1);
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = 
                     UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
                                             reinterpret_cast<double *> (Ltx),
                                             0, Up, Uj,
                                             reinterpret_cast<double *> (Ux), 
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -877,20 +877,20 @@ qrsolve(const SparseComplexMatrix&a, con
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix 
-qrsolve (const SparseComplexMatrix &a, const MArray2<double> &b, 
+qrsolve (const SparseComplexMatrix &a, const MArray<double> &b, 
          octave_idx_type &info)
 {
   return qrsolve (a, Matrix (b), info);
 }
 
 ComplexMatrix 
-qrsolve (const SparseComplexMatrix &a, const MArray2<Complex> &b, 
+qrsolve (const SparseComplexMatrix &a, const MArray<Complex> &b, 
          octave_idx_type &info)
 {
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -145,27 +145,27 @@ protected:
 
 
 // Publish externally used friend functions.
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                               octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-                              const MArray2<double> &b, 
+                              const MArray<double> &b, 
                               octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
                                     const SparseMatrix &b,
                                     octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
                               const ComplexMatrix &b,
                               octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-                              const MArray2<Complex> &b, 
+                              const MArray<Complex> &b, 
                               octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
                                     const SparseComplexMatrix &b,
                                     octave_idx_type &info);
 #endif
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -893,20 +893,20 @@ qrsolve(const SparseMatrix&a, const Spar
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 Matrix 
-qrsolve(const SparseMatrix &a, const MArray2<double> &b, 
+qrsolve(const SparseMatrix &a, const MArray<double> &b, 
         octave_idx_type &info)
 { 
   return qrsolve (a, Matrix (b), info); 
 }
 
 ComplexMatrix 
-qrsolve(const SparseMatrix &a, const MArray2<Complex> &b, 
+qrsolve(const SparseMatrix &a, const MArray<Complex> &b, 
         octave_idx_type &info)
 { 
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -140,25 +140,25 @@ protected:
 };
 
 
 // Publish externally used friend functions.
 
 extern Matrix qrsolve (const SparseMatrix &a, const Matrix &b, 
                        octave_idx_type &info);
 
-extern Matrix qrsolve (const SparseMatrix &a, const MArray2<double> &b, 
+extern Matrix qrsolve (const SparseMatrix &a, const MArray<double> &b, 
                        octave_idx_type &info);
 
 extern SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
                              octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
                               octave_idx_type &info);
 
-extern ComplexMatrix qrsolve (const SparseMatrix &a, const MArray2<Complex> &b, 
+extern ComplexMatrix qrsolve (const SparseMatrix &a, const MArray<Complex> &b, 
                               octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseMatrix &a, 
                                     const SparseComplexMatrix &b,
                                     octave_idx_type &info);
 
 #endif
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -178,20 +178,20 @@ SparseLU::SparseLU (const SparseMatrix& 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   Rfact.xridx (i) = i;
                   Rfact.xcidx (i) = i;
                 }
               Rfact.xcidx (nr) = nr;
               double *Rx = Rfact.data ();
 
-              P.resize (nr);
+              P.resize (nr, 1);
               octave_idx_type *p = P.fortran_vec ();
 
-              Q.resize (nc);
+              Q.resize (nc, 1);
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
                                                Up, Uj, Ux, p, q, 0,
                                                &do_recip, Rx, 
                                                Numeric) ;
 
@@ -394,20 +394,20 @@ SparseLU::SparseLU (const SparseMatrix& 
                   for (octave_idx_type i = 0; i < nr; i++)
                     {
                       Rfact.xridx (i) = i;
                       Rfact.xcidx (i) = i;
                     }
                   Rfact.xcidx (nr) = nr;
                   double *Rx = Rfact.data ();
 
-                  P.resize (nr);
+                  P.resize (nr, 1);
                   octave_idx_type *p = P.fortran_vec ();
 
-                  Q.resize (nc);
+                  Q.resize (nc, 1);
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
                                                    Ltx, Up, Uj, Ux, p, q, 
                                                    0, &do_recip, 
                                                    Rx, Numeric) ;
 
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -117,17 +117,17 @@ base_lu <lu_type> :: Y (void) const
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
 
-      Array<octave_idx_type> pvt (a_nr);
+      Array<octave_idx_type> pvt (a_nr, 1);
 
       for (octave_idx_type i = 0; i < a_nr; i++)
         pvt.xelem (i) = i;
 
       for (octave_idx_type i = 0; i < ipvt.length(); i++)
         {
           octave_idx_type k = ipvt.xelem (i);
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -29,27 +29,29 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 ColumnVector : public MArray<double>
 {
 public:
 
-  ColumnVector (void) : MArray<double> () { }
+  ColumnVector (void) : MArray<double> (0, 1) { }
 
-  explicit ColumnVector (octave_idx_type n) : MArray<double> (n) { }
+  explicit ColumnVector (octave_idx_type n) : MArray<double> (n, 1) { }
 
-  explicit ColumnVector (const dim_vector& dv) : MArray<double> (dv) { }
+  explicit ColumnVector (const dim_vector& dv) 
+    : MArray<double> (dv.as_column ()) { }
 
-  ColumnVector (octave_idx_type n, double val) : MArray<double> (n, val) { }
+  ColumnVector (octave_idx_type n, double val) : MArray<double> (n, 1, val) { }
 
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
-  ColumnVector (const MArray<double>& a) : MArray<double> (a) { }
+  ColumnVector (const MArray<double>& a) : MArray<double> (a.as_column ()) { }
+  ColumnVector (const Array<double>& a) : MArray<double> (a.as_column ()) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const ColumnVector& a) const;
@@ -88,19 +90,25 @@ public:
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
+  void resize (octave_idx_type n, const double& rfv = Array<double>::resize_fill_value ())
+    { Array<double>::resize (n, 1, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<double>::clear (n, 1); }
+
 private:
 
-  ColumnVector (double *d, octave_idx_type l) : MArray<double> (d, l) { }
+  ColumnVector (double *d, octave_idx_type l) : MArray<double> (d, l, 1) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API ColumnVector real (const ComplexColumnVector& a);
 extern OCTAVE_API ColumnVector imag (const ComplexColumnVector& a);
 
 MARRAY_FORWARD_DEFS (MArray, ColumnVector, double)
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -209,58 +209,55 @@ extern "C"
                                const octave_idx_type&, const double*,
                                const octave_idx_type&, double*, double&
                                F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
-  : MArray2<double> (Array2<double> (rv, 1, rv.length ()))
+  : MArray<double> (rv)
 {
 }
 
 Matrix::Matrix (const ColumnVector& cv)
-  : MArray2<double> (Array2<double> (cv, cv.length (), 1))
+  : MArray<double> (cv)
 {
 }
 
 Matrix::Matrix (const DiagMatrix& a)
-  : MArray2<double> (a.rows (), a.cols (), 0.0)
+  : MArray<double> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 Matrix::Matrix (const PermMatrix& a)
-  : MArray2<double> (a.rows (), a.cols (), 0.0)
+  : MArray<double> (a.rows (), a.cols (), 0.0)
 {
   const Array<octave_idx_type> ia (a.pvec ());
   octave_idx_type len = a.rows ();
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
       elem (i, ia(i)) = 1.0;
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 Matrix::Matrix (const boolMatrix& a)
-  : MArray2<double> (a.rows (), a.cols ())
+  : MArray<double> (a)
 {
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    for (octave_idx_type j = 0; j < a.cols (); j++)
-      elem (i, j) = a.elem (i, j);
 }
 
 Matrix::Matrix (const charMatrix& a)
-  : MArray2<double> (a.rows (), a.cols ())
+  : MArray<double> (a.rows (), a.cols ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 Matrix::operator == (const Matrix& a) const
@@ -291,17 +288,17 @@ Matrix::is_symmetric (void) const
     }
 
   return false;
 }
 
 Matrix&
 Matrix::insert (const Matrix& a, octave_idx_type r, octave_idx_type c)
 {
-  Array2<double>::insert (a, r, c);
+  Array<double>::insert (a, r, c);
   return *this;
 }
 
 Matrix&
 Matrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
@@ -609,23 +606,23 @@ Matrix::extract_n (octave_idx_type r1, o
   return result;
 }
 
 // extract row or column i.
 
 RowVector
 Matrix::row (octave_idx_type i) const
 {
-  return MArray<double> (index (idx_vector (i), idx_vector::colon));
+  return index (idx_vector (i), idx_vector::colon);
 }
 
 ColumnVector
 Matrix::column (octave_idx_type i) const
 {
-  return MArray<double> (index (idx_vector::colon, idx_vector (i)));
+  return index (idx_vector::colon, idx_vector (i));
 }
 
 Matrix
 Matrix::inverse (void) const
 {
   octave_idx_type info;
   double rcon;
   MatrixType mattype (*this);
@@ -729,32 +726,32 @@ Matrix::finverse (MatrixType &mattype, o
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr);
+      Array<octave_idx_type> ipvt (nr, 1);
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
-      Array<double> z(1);
+      Array<double> z(1, 1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (lwork);
+      z.resize (lwork, 1);
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -766,17 +763,17 @@ Matrix::finverse (MatrixType &mattype, o
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (dgecon_info != 0) 
             info = -1;
@@ -1001,17 +998,17 @@ Matrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1042,17 +1039,17 @@ Matrix::ifourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1086,17 +1083,17 @@ Matrix::fourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1105,20 +1102,20 @@ Matrix::fourier2d (void) const
 
       F77_FUNC (zfftf, ZFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts);
+  Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1152,17 +1149,17 @@ Matrix::ifourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<Complex> wsave (nn);
+  Array<Complex> wsave (nn, 1);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1174,20 +1171,20 @@ Matrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<Complex> tmp (npts);
+  Array<Complex> tmp (npts, 1);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1274,19 +1271,19 @@ Matrix::determinant (MatrixType& mattype
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<double> z (3 * nc);
+              Array<double> z (3 * nc, 1);
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc);
+              Array<octave_idx_type> iz (nc, 1);
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1298,17 +1295,17 @@ Matrix::determinant (MatrixType& mattype
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1325,19 +1322,19 @@ Matrix::determinant (MatrixType& mattype
               retval = DET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<double> z (4 * nc);
+                  Array<double> z (4 * nc, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1390,19 +1387,19 @@ Matrix::rcond (MatrixType &mattype) cons
       if (typ == MatrixType::Upper)
         {
           const double *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<double> z (3 * nc);
+          Array<double> z (3 * nc, 1);
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1418,19 +1415,19 @@ Matrix::rcond (MatrixType &mattype) cons
       else if (typ == MatrixType::Lower)
         {
           const double *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<double> z (3 * nc);
+          Array<double> z (3 * nc, 1);
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1463,45 +1460,45 @@ Matrix::rcond (MatrixType &mattype) cons
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<double> z (3 * nc);
+                  Array<double> z (3 * nc, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr);
+              Array<octave_idx_type> ipvt (nr, 1);
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<double> z (4 * nc);
+              Array<double> z (4 * nc, 1);
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc);
+              Array<octave_idx_type> iz (nc, 1);
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1562,19 +1559,19 @@ Matrix::utsolve (MatrixType &mattype, co
               const double *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<double> z (3 * nc);
+                  Array<double> z (3 * nc, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1662,19 +1659,19 @@ Matrix::ltsolve (MatrixType &mattype, co
               const double *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<double> z (3 * nc);
+                  Array<double> z (3 * nc, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1768,19 +1765,19 @@ Matrix::fsolve (MatrixType &mattype, con
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nc);
+                  Array<double> z (3 * nc, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1820,27 +1817,27 @@ Matrix::fsolve (MatrixType &mattype, con
                 }                   
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          Array<double> z (4 * nc);
+          Array<double> z (4 * nc, 1);
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0) 
             {
@@ -2259,23 +2256,23 @@ Matrix::lssolve (const Matrix& b, octave
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
-      Array<double> s (minmn);
+      Array<double> s (minmn, 1);
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<double> work (1);
+      Array<double> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2297,17 +2294,17 @@ Matrix::lssolve (const Matrix& b, octave
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2342,17 +2339,17 @@ Matrix::lssolve (const Matrix& b, octave
           octave_idx_type lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         (*current_liboctave_warning_handler) 
@@ -2460,23 +2457,23 @@ Matrix::lssolve (const ColumnVector& b, 
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
-      Array<double> s (minmn);
+      Array<double> s (minmn, 1);
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<double> work (1);
+      Array<double> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2491,25 +2488,25 @@ Matrix::lssolve (const ColumnVector& b, 
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         {
@@ -2826,17 +2823,17 @@ Matrix::abs (void) const
 {
   return Matrix (mx_inline_fabs_dup (data (), length ()),
                  rows (), cols ());
 }
 
 Matrix
 Matrix::diag (octave_idx_type k) const
 {
-  return MArray2<double>::diag (k);
+  return MArray<double>::diag (k);
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -2847,17 +2844,17 @@ Matrix::row_min (Array<octave_idx_type>&
   ColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           double tmp_min = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2902,17 +2899,17 @@ Matrix::row_max (Array<octave_idx_type>&
   ColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           double tmp_max = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2957,17 +2954,17 @@ Matrix::column_min (Array<octave_idx_typ
   RowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           double tmp_min = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
@@ -3012,17 +3009,17 @@ Matrix::column_max (Array<octave_idx_typ
   RowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           double tmp_max = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -19,71 +19,72 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_Matrix_int_h)
 #define octave_Matrix_int_h 1
 
-#include "MArray2.h"
+#include "MArray.h"
+#include "Array2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-Matrix : public MArray2<double>
+Matrix : public MArray<double>
 {
 public:
 
   typedef ColumnVector column_vector_type;
   typedef RowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
-  Matrix (void) : MArray2<double> () { }
+  Matrix (void) : MArray<double> () { }
 
-  Matrix (octave_idx_type r, octave_idx_type c) : MArray2<double> (r, c) { }
+  Matrix (octave_idx_type r, octave_idx_type c) : MArray<double> (r, c) { }
 
-  Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray2<double> (r, c, val) { }
+  Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray<double> (r, c, val) { }
 
-  Matrix (const dim_vector& dv) : MArray2<double> (dv) { }
+  Matrix (const dim_vector& dv) : MArray<double> (dv.redim (2)) { }
 
-  Matrix (const dim_vector& dv, double val) : MArray2<double> (dv, val) { }
+  Matrix (const dim_vector& dv, double val) : MArray<double> (dv.redim (2), val) { }
 
-  Matrix (const Matrix& a) : MArray2<double> (a) { }
+  Matrix (const Matrix& a) : MArray<double> (a) { }
 
   template <class U>
-  Matrix (const MArray2<U>& a) : MArray2<double> (a) { }
+  Matrix (const MArray<U>& a) : MArray<double> (a.as_matrix ()) { }
 
   template <class U>
-  Matrix (const Array2<U>& a) : MArray2<double> (a) { }
+  Matrix (const Array2<U>& a) : MArray<double> (a) { }
 
   template <class U>
-  Matrix (const Array<U>& a) : MArray2<double> (a) { }
+  Matrix (const Array<U>& a) : MArray<double> (a.as_matrix ()) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
 
   explicit Matrix (const DiagMatrix& a);
 
   explicit Matrix (const PermMatrix& a);
 
   explicit Matrix (const boolMatrix& a);
 
   explicit Matrix (const charMatrix& a);
 
   Matrix& operator = (const Matrix& a)
     {
-      MArray2<double>::operator = (a);
+      MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const Matrix& a) const;
   bool operator != (const Matrix& a) const;
 
   bool is_symmetric (void) const;
 
@@ -107,17 +108,17 @@ public:
   Matrix stack (const ColumnVector& a) const;
   Matrix stack (const DiagMatrix& a) const;
 
   friend OCTAVE_API Matrix real (const ComplexMatrix& a);
   friend OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
   friend class ComplexMatrix;
 
-  Matrix transpose (void) const { return MArray2<double>::transpose (); }
+  Matrix transpose (void) const { return MArray<double>::transpose (); }
 
   // resize is the destructive equivalent for this one
 
   Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
@@ -326,17 +327,17 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Matrix& a);
 
   static double resize_fill_value (void) { return 0; }
 
 private:
 
-  Matrix (double *d, octave_idx_type r, octave_idx_type c) : MArray2<double> (d, r, c) { }
+  Matrix (double *d, octave_idx_type r, octave_idx_type c) : MArray<double> (d, r, c) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API Matrix real (const ComplexMatrix& a);
 extern OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
@@ -371,14 +372,14 @@ MS_CMP_OP_DECLS (Matrix, double, OCTAVE_
 MS_BOOL_OP_DECLS (Matrix, double, OCTAVE_API)
 
 SM_CMP_OP_DECLS (double, Matrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (double, Matrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArray2, Matrix, double)
+MARRAY_FORWARD_DEFS (MArray, Matrix, double)
 
 template <class T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -83,17 +83,17 @@ NDArray::NDArray (const Array<octave_idx
             (pa[i] + static_cast<octave_idx_type> (1));
       else
         for (octave_idx_type i = 0; i < a.numel (); i++)
           ptmp[i] = static_cast<double> (pa[i]);
     }
 }
 
 NDArray::NDArray (const charNDArray& a)
-  : MArrayN<double> (a.dims ())
+  : MArray<double> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
 #if defined (HAVE_FFTW)
 
@@ -935,17 +935,17 @@ NDArray::compute_index (Array<octave_idx
                         const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 NDArray
 NDArray::diag (octave_idx_type k) const
 {
-  return MArrayN<double>::diag (k);
+  return MArray<double>::diag (k);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -19,60 +19,60 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_NDArray_h)
 #define octave_NDArray_h 1
 
-#include "MArrayN.h"
+#include "MArray.h"
 #include "dMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
-NDArray : public MArrayN<double>
+NDArray : public MArray<double>
 {
 public:
 
   typedef Matrix matrix_type;
 
-  NDArray (void) : MArrayN<double> () { }
+  NDArray (void) : MArray<double> () { }
 
-  NDArray (const dim_vector& dv) : MArrayN<double> (dv) { }
+  NDArray (const dim_vector& dv) : MArray<double> (dv) { }
 
   NDArray (const dim_vector& dv, double val)
-    : MArrayN<double> (dv, val) { }
+    : MArray<double> (dv, val) { }
   
-  NDArray (const NDArray& a) : MArrayN<double> (a) { }
+  NDArray (const NDArray& a) : MArray<double> (a) { }
 
-  NDArray (const Matrix& a) : MArrayN<double> (a) { }
+  NDArray (const Matrix& a) : MArray<double> (a) { }
 
   NDArray (const Array<octave_idx_type>& a, bool zero_based = false, 
            bool negative_to_nan = false);
 
   template <class U>
-  NDArray (const MArrayN<U>& a) : MArrayN<double> (a) { }
+  NDArray (const MArray<U>& a) : MArray<double> (a) { }
 
   template <class U>
-  NDArray (const Array<U>& a) : MArrayN<double> (a) { }
+  NDArray (const Array<U>& a) : MArray<double> (a) { }
 
   template <class U>
-  explicit NDArray (const intNDArray<U>& a) : MArrayN<double> (a) { }
+  explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
   NDArray (const charNDArray&); 
 
   NDArray& operator = (const NDArray& a)
     {
-      MArrayN<double>::operator = (a);
+      MArray<double>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_negative (bool = false) const;
@@ -131,17 +131,17 @@ public:
 
   friend OCTAVE_API NDArray real (const ComplexNDArray& a);
   friend OCTAVE_API NDArray imag (const ComplexNDArray& a);
 
   friend class ComplexNDArray;
 
   Matrix matrix_value (void) const;
 
-  NDArray squeeze (void) const { return MArrayN<double>::squeeze (); }
+  NDArray squeeze (void) const { return MArray<double>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
@@ -151,23 +151,23 @@ public:
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
   NDArray diag (octave_idx_type k = 0) const;
 
   NDArray& changesign (void) 
     { 
-      MArrayN<double>::changesign (); 
+      MArray<double>::changesign (); 
       return *this; 
     }
 
 private:
 
-  NDArray (double *d, const dim_vector& dv) : MArrayN<double> (d, dv) { }
+  NDArray (double *d, const dim_vector& dv) : MArray<double> (d, dv) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API NDArray real (const ComplexNDArray& a);
 extern OCTAVE_API NDArray imag (const ComplexNDArray& a);
 
 MINMAX_DECLS (NDArray, double, OCTAVE_API)
@@ -176,17 +176,17 @@ NDS_CMP_OP_DECLS (NDArray, double, OCTAV
 NDS_BOOL_OP_DECLS (NDArray, double, OCTAVE_API)
 
 SND_CMP_OP_DECLS (double, NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (double, NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, NDArray, double)
+MARRAY_FORWARD_DEFS (MArray, NDArray, double)
 
 BSXFUN_STDOP_DECLS (NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (NDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, NDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, ComplexNDArray, ComplexNDArray, 
                  NDArray, OCTAVE_API)
 
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -29,27 +29,28 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 RowVector : public MArray<double>
 {
 public:
 
-  RowVector (void) : MArray<double> () { }
+  RowVector (void) : MArray<double> (1, 0) { }
 
-  explicit RowVector (octave_idx_type n) : MArray<double> (n) { }
+  explicit RowVector (octave_idx_type n) : MArray<double> (1, n) { }
 
-  explicit RowVector (const dim_vector& dv) : MArray<double> (dv) { }
+  explicit RowVector (const dim_vector& dv) : MArray<double> (dv.as_row ()) { }
 
-  RowVector (octave_idx_type n, double val) : MArray<double> (n, val) { }
+  RowVector (octave_idx_type n, double val) : MArray<double> (1, n, val) { }
 
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
-  RowVector (const MArray<double>& a) : MArray<double> (a) { }
+  RowVector (const MArray<double>& a) : MArray<double> (a.as_row ()) { }
+  RowVector (const Array<double>& a) : MArray<double> (a.as_row ()) { }
 
   RowVector& operator = (const RowVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const RowVector& a) const;
@@ -84,19 +85,25 @@ public:
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
+  void resize (octave_idx_type n, const double& rfv = Array<double>::resize_fill_value ())
+    { Array<double>::resize (1, n, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<double>::clear (1, n); }
+
 private:
 
-  RowVector (double *d, octave_idx_type l) : MArray<double> (d, l) { }
+  RowVector (double *d, octave_idx_type l) : MArray<double> (d, 1, l) { }
 };
 
 // row vector by column vector -> scalar
 
 double OCTAVE_API operator * (const RowVector& a, const ColumnVector& b);
 
 Complex OCTAVE_API operator * (const RowVector& a, const ComplexColumnVector& b);
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -344,17 +344,17 @@ SparseMatrix::max (Array<octave_idx_type
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
-      idx_arg.resize_fill (nr, 1, 0);
+      idx_arg.resize (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -493,17 +493,17 @@ SparseMatrix::min (Array<octave_idx_type
               result.xridx (ii++) = 0;
             }
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
-      idx_arg.resize_fill (nr, 1, 0);
+      idx_arg.resize (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
         idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
             if (idx_arg.elem(i) != -1)
@@ -4014,17 +4014,17 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4313,17 +4313,17 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
@@ -4528,19 +4528,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4622,17 +4622,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           // Throw-away extra info LAPACK gives so as to not 
           // change output.
           if (err != 0) 
@@ -4650,19 +4650,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4776,19 +4776,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -4905,17 +4905,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -4931,19 +4931,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5096,19 +5096,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5221,17 +5221,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5247,19 +5247,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5396,19 +5396,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
               rcond = 0.0;
               err = 0;
             } 
           else 
             {
               if (calc_cond)
                 {
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
@@ -5551,17 +5551,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                     atmp += fabs(data(i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
                                      ldm, pipvt, err));
             
           if (err != 0) 
             {
               err = -2;
@@ -5577,19 +5577,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   ("matrix singular to machine precision");
 
             } 
           else 
             {
               if (calc_cond)
                 {
                   char job = '1';
-                  Array<double> z (3 * nr);
+                  Array<double> z (3 * nr, 1);
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nr);
+                  Array<octave_idx_type> iz (nr, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON, 
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -118,19 +118,19 @@ CHOL::init (const Matrix& a, bool calc_c
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type dpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<double> z (3*n);
+      Array<double> z (3*n, 1);
       double *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (n);
+      Array<octave_idx_type> iz (n, 1);
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, dpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (dpocon_info != 0) 
         info = -1;
     }
@@ -411,17 +411,17 @@ CHOL::shift_sym (octave_idx_type i, octa
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       Matrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (n);
+      Array<octave_idx_type> p (n, 1);
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -75,27 +75,27 @@ HESS::init (const Matrix& a)
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   double *h = hess_mat.fortran_vec ();
 
-  Array<double> scale (n);
+  Array<double> scale (n, 1);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<double> tau (n-1);
+  Array<double> tau (n-1, 1);
   double *ptau = tau.fortran_vec ();
 
-  Array<double> work (lwork);
+  Array<double> work (lwork, 1);
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
                              lwork, info));
 
   unitary_hess_mat = hess_mat;
   double *z = unitary_hess_mat.fortran_vec ();
 
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 LU::LU (const Matrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn);
+  ipvt.resize (mn, 1);
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   double *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (dgetrf, DGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -60,17 +60,17 @@ QRP::init (const Matrix& a, qr_type_t qr
   OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
   octave_idx_type info = 0;
 
   Matrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 0);
+  MArray<octave_idx_type> jpvt (n, 1, 0);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
       F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
                                  tau, &rlwork, -1, info));
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -106,30 +106,30 @@ SCHUR::init (const Matrix& a, const std:
   schur_mat = a;
 
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
   double *s = schur_mat.fortran_vec ();
   double *q = unitary_mat.fortran_vec ();
 
-  Array<double> wr (n);
+  Array<double> wr (n, 1);
   double *pwr = wr.fortran_vec ();
 
-  Array<double> wi (n);
+  Array<double> wi (n, 1);
   double *pwi = wi.fortran_vec ();
 
-  Array<double> work (lwork);
+  Array<double> work (lwork, 1);
   double *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for the non-ordered Schur routine.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
-  Array<octave_idx_type> iwork (liwork);
+  Array<octave_idx_type> iwork (liwork, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (dgeesx, DGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
                              pwork, lwork, piwork, liwork, pbwork, info
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -130,30 +130,30 @@ SVD::init (const Matrix& a, SVD::type sv
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<double> work (1);
+  Array<double> work (1, 1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0));
-  work.resize (lwork);
+  work.resize (lwork, 1);
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -128,17 +128,17 @@ private:
       {
         --count();
         rep = clonerep ();
       }
   }
 
 public:
 
-  explicit dim_vector (octave_idx_type n)
+  explicit dim_vector (octave_idx_type n) GCC_ATTR_DEPRECATED
     : rep (newrep (2))
   {
     rep[0] = n;
     rep[1] = 1;
   }
 
   explicit dim_vector (octave_idx_type r, octave_idx_type c)
     : rep (newrep (2))
@@ -550,16 +550,32 @@ public:
             k *= rep[i];
 
           retval.rep[n-1] = k;
 
           return retval;
         }
     }
 
+  dim_vector as_column (void) const
+    {
+      if (length () == 2 && elem (1) == 1)
+        return *this;
+      else
+        return dim_vector (numel (), 1);
+    }
+
+  dim_vector as_row (void) const
+    {
+      if (length () == 2 && elem (0) == 1)
+        return *this;
+      else
+        return dim_vector (1, numel ());
+    }
+
   bool is_vector (void) const
     {
       return (length () == 2 && (elem (0) == 1 || elem (1) == 1));
     }
 
   int first_non_singleton (int def = 0) const
     {
       for (int i = 0; i < length (); i++)
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -823,17 +823,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked(n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -881,33 +881,33 @@ EigsRealSymmetricMatrix (const M& m, con
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
@@ -984,17 +984,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1146,17 +1146,17 @@ EigsRealSymmetricMatrixShift (const M& m
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked (n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -1166,33 +1166,33 @@ EigsRealSymmetricMatrixShift (const M& m
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -1321,17 +1321,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
                         
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1475,33 +1475,33 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
@@ -1579,17 +1579,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
                         
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
@@ -1737,17 +1737,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked (n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -1795,33 +1795,33 @@ EigsRealNonSymmetricMatrix (const M& m, 
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
@@ -1898,17 +1898,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2102,17 +2102,17 @@ EigsRealNonSymmetricMatrixShift (const M
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked (n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -2122,33 +2122,33 @@ EigsRealNonSymmetricMatrixShift (const M
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -2277,17 +2277,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
                         
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2479,33 +2479,33 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   else if (! std::abs (sigmar))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
@@ -2582,17 +2582,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
@@ -2784,17 +2784,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) 
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked (n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -2842,33 +2842,33 @@ EigsComplexNonSymmetricMatrix (const M& 
             {
               (*current_liboctave_error_handler) 
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
               
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
@@ -2945,17 +2945,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
@@ -3108,17 +3108,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
-          Array<bool> checked(n,false);
+          Array<bool> checked (n, 1, false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx = 
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler) 
@@ -3128,33 +3128,33 @@ EigsComplexNonSymmetricMatrixShift (cons
             }
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
 
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
@@ -3285,17 +3285,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   // We have a problem in that the size of the C++ bool 
   // type relative to the fortran logical type. It appears 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
   // per bool, though this might be system dependent. As 
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to 
   // avoid problems.
-  Array<octave_idx_type> s (p);
+  Array<octave_idx_type> s (p, 1);
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
@@ -3445,33 +3445,33 @@ EigsComplexNonSymmetricFunc (EigsComplex
   else if (! std::abs (sigma))
     typ = "SM";
   else
     {
       typ = "LM";
       mode = 3;
     }
 
-  Array<octave_idx_type> ip (11);
+  Array<octave_idx_type> ip (11, 1);
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
   ip(2) = maxit; // mxiter, maximum number of iterations
   ip(3) = 1; // NB blocksize in recurrence
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
  
-  Array<octave_idx_type> iptr (14);
+  Array<octave_idx_type> iptr (14, 1);
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
               
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -46,20 +46,18 @@ extern "C"
                            const FloatComplex*, const octave_idx_type&, const FloatComplex*,
                            const octave_idx_type&, const FloatComplex&, FloatComplex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // FloatComplex Column Vector class
 
 FloatComplexColumnVector::FloatComplexColumnVector (const FloatColumnVector& a)
-   : MArray<FloatComplex> (a.length ())
+   : MArray<FloatComplex> (a)
 {
-  for (octave_idx_type i = 0; i < length (); i++)
-    elem (i) = a.elem (i);
 }
 
 bool
 FloatComplexColumnVector::operator == (const FloatComplexColumnVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -32,28 +32,30 @@ class
 OCTAVE_API
 FloatComplexColumnVector : public MArray<FloatComplex>
 {
 friend class FloatComplexMatrix;
 friend class FloatComplexRowVector;
 
 public:
 
-  FloatComplexColumnVector (void) : MArray<FloatComplex> () { }
+  FloatComplexColumnVector (void) : MArray<FloatComplex> (0, 1) { }
 
-  explicit FloatComplexColumnVector (octave_idx_type n) : MArray<FloatComplex> (n) { }
+  explicit FloatComplexColumnVector (octave_idx_type n) : MArray<FloatComplex> (n, 1) { }
 
-  explicit FloatComplexColumnVector (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
+  explicit FloatComplexColumnVector (const dim_vector& dv) 
+    : MArray<FloatComplex> (dv.as_column ()) { }
 
   FloatComplexColumnVector (octave_idx_type n, const FloatComplex& val)
-    : MArray<FloatComplex> (n, val) { }
+    : MArray<FloatComplex> (n, 1, val) { }
 
   FloatComplexColumnVector (const FloatComplexColumnVector& a) : MArray<FloatComplex> (a) { }
 
-  FloatComplexColumnVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a) { }
+  FloatComplexColumnVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a.as_column ()) { }
+  FloatComplexColumnVector (const Array<FloatComplex>& a) : MArray<FloatComplex> (a.as_column ()) { }
 
   explicit FloatComplexColumnVector (const FloatColumnVector& a);
 
   FloatComplexColumnVector& operator = (const FloatComplexColumnVector& a)
     {
       MArray<FloatComplex>::operator = (a);
       return *this;
     }
@@ -119,16 +121,22 @@ public:
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
+  void resize (octave_idx_type n, const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+    { Array<FloatComplex>::resize (n, 1, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<FloatComplex>::clear (n, 1); }
+
 private:
 
-  FloatComplexColumnVector (FloatComplex *d, octave_idx_type l) : MArray<FloatComplex> (d, l) { }
+  FloatComplexColumnVector (FloatComplex *d, octave_idx_type l) : MArray<FloatComplex> (d, l, 1) { }
 };
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexColumnVector, FloatComplex)
 
 #endif
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -227,82 +227,72 @@ extern "C"
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN, octave_Float_NaN);
 
 // FloatComplex Matrix class
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& a)
-  : MArray2<FloatComplex> (a.rows (), a.cols ())
+  : MArray<FloatComplex> (a)
 {
-  for (octave_idx_type j = 0; j < cols (); j++)
-    for (octave_idx_type i = 0; i < rows (); i++)
-      elem (i, j) = a.elem (i, j);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatRowVector& rv)
-  : MArray2<FloatComplex> (1, rv.length (), 0.0)
+  : MArray<FloatComplex> (rv)
 {
-  for (octave_idx_type i = 0; i < rv.length (); i++)
-    elem (0, i) = rv.elem (i);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatColumnVector& cv)
-  : MArray2<FloatComplex> (cv.length (), 1, 0.0)
+  : MArray<FloatComplex> (cv)
 {
-  for (octave_idx_type i = 0; i < cv.length (); i++)
-    elem (i, 0) = cv.elem (i);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatDiagMatrix& a)
-  : MArray2<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexRowVector& rv)
-  : MArray2<FloatComplex> (Array2<FloatComplex> (rv, 1, rv.length ()))
+  : MArray<FloatComplex> (rv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexColumnVector& cv)
-  : MArray2<FloatComplex> (Array2<FloatComplex> (cv, cv.length (), 1))
+  : MArray<FloatComplex> (cv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexDiagMatrix& a)
-  : MArray2<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 FloatComplexMatrix::FloatComplexMatrix (const boolMatrix& a)
-  : MArray2<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a)
 {
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    for (octave_idx_type j = 0; j < a.cols (); j++)
-      elem (i, j) = a.elem (i, j);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const charMatrix& a)
-  : MArray2<FloatComplex> (a.rows (), a.cols (), 0.0)
+  : MArray<FloatComplex> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& re, const FloatMatrix& im)
-  : MArray2<FloatComplex> (re.rows (), re.cols ())
+  : MArray<FloatComplex> (re.rows (), re.cols ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = FloatComplex (re(i), im(i));
 }
@@ -436,17 +426,17 @@ FloatComplexMatrix::insert (const FloatD
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  Array2<FloatComplex>::insert (a, r, c);
+  Array<FloatComplex>::insert (a, r, c);
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexRowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
@@ -937,23 +927,23 @@ FloatComplexMatrix::extract_n (octave_id
   return result;
 }
 
 // extract row or column i.
 
 FloatComplexRowVector
 FloatComplexMatrix::row (octave_idx_type i) const
 {
-  return MArray<FloatComplex> (index (idx_vector (i), idx_vector::colon));
+  return index (idx_vector (i), idx_vector::colon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::column (octave_idx_type i) const
 {
-  return MArray<FloatComplex> (index (idx_vector::colon, idx_vector (i)));
+  return index (idx_vector::colon, idx_vector (i));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (void) const
 {
   octave_idx_type info;
   float rcon;
   MatrixType mattype (*this);
@@ -1056,33 +1046,33 @@ FloatComplexMatrix::finverse (MatrixType
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr);
+      Array<octave_idx_type> ipvt (nr, 1);
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       FloatComplex *tmp_data = retval.fortran_vec ();
 
-      Array<FloatComplex> z(1);
+      Array<FloatComplex> z(1, 1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (lwork);
+      z.resize (lwork, 1);
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -1093,17 +1083,17 @@ FloatComplexMatrix::finverse (MatrixType
       rcon = 0.0;
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
-          Array<float> rz (2 * nc);
+          Array<float> rz (2 * nc, 1);
           float *prz = rz.fortran_vec ();
           F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (zgecon_info != 0) 
             info = -1;
@@ -1329,17 +1319,17 @@ FloatComplexMatrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1370,17 +1360,17 @@ FloatComplexMatrix::ifourier (void) cons
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1414,17 +1404,17 @@ FloatComplexMatrix::fourier2d (void) con
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1433,20 +1423,20 @@ FloatComplexMatrix::fourier2d (void) con
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts);
+  Array<FloatComplex> tmp (npts, 1);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1480,17 +1470,17 @@ FloatComplexMatrix::ifourier2d (void) co
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1502,20 +1492,20 @@ FloatComplexMatrix::ifourier2d (void) co
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts);
+  Array<FloatComplex> tmp (npts, 1);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1602,19 +1592,19 @@ FloatComplexMatrix::determinant (MatrixT
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<FloatComplex> z (2 * nc);
+              Array<FloatComplex> z (2 * nc, 1);
               FloatComplex *pz = z.fortran_vec ();
-              Array<float> rz (nc);
+              Array<float> rz (nc, 1);
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1626,17 +1616,17 @@ FloatComplexMatrix::determinant (MatrixT
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1653,19 +1643,19 @@ FloatComplexMatrix::determinant (MatrixT
               retval = FloatComplexDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<FloatComplex> z (2 * nc);
+                  Array<FloatComplex> z (2 * nc, 1);
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (2 * nc);
+                  Array<float> rz (2 * nc, 1);
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1718,19 +1708,19 @@ FloatComplexMatrix::rcond (MatrixType &m
       if (typ == MatrixType::Upper)
         {
           const FloatComplex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<FloatComplex> z (2 * nc);
+          Array<FloatComplex> z (2 * nc, 1);
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (nc);
+          Array<float> rz (nc, 1);
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1746,19 +1736,19 @@ FloatComplexMatrix::rcond (MatrixType &m
       else if (typ == MatrixType::Lower)
         {
           const FloatComplex *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<FloatComplex> z (2 * nc);
+          Array<FloatComplex> z (2 * nc, 1);
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (nc);
+          Array<float> rz (nc, 1);
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1792,19 +1782,19 @@ FloatComplexMatrix::rcond (MatrixType &m
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<FloatComplex> z (2 * nc);
+                  Array<FloatComplex> z (2 * nc, 1);
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc);
+                  Array<float> rz (nc, 1);
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1812,26 +1802,26 @@ FloatComplexMatrix::rcond (MatrixType &m
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr);
+              Array<octave_idx_type> ipvt (nr, 1);
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<FloatComplex> z (2 * nc);
+              Array<FloatComplex> z (2 * nc, 1);
               FloatComplex *pz = z.fortran_vec ();
-              Array<float> rz (2 * nc);
+              Array<float> rz (2 * nc, 1);
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 { 
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1893,19 +1883,19 @@ FloatComplexMatrix::utsolve (MatrixType 
               const FloatComplex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<FloatComplex> z (2 * nc);
+                  Array<FloatComplex> z (2 * nc, 1);
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc);
+                  Array<float> rz (nc, 1);
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1994,19 +1984,19 @@ FloatComplexMatrix::ltsolve (MatrixType 
               const FloatComplex *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<FloatComplex> z (2 * nc);
+                  Array<FloatComplex> z (2 * nc, 1);
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc);
+                  Array<float> rz (nc, 1);
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -2102,19 +2092,19 @@ FloatComplexMatrix::fsolve (MatrixType &
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<FloatComplex> z (2 * nc);
+                  Array<FloatComplex> z (2 * nc, 1);
                   FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (nc);
+                  Array<float> rz (nc, 1);
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -2154,25 +2144,25 @@ FloatComplexMatrix::fsolve (MatrixType &
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
-          Array<FloatComplex> z (2 * nc);
+          Array<FloatComplex> z (2 * nc, 1);
           FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (2 * nc);
+          Array<float> rz (2 * nc, 1);
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2608,23 +2598,23 @@ FloatComplexMatrix::lssolve (const Float
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
-      Array<float> s (minmn);
+      Array<float> s (minmn, 1);
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<FloatComplex> work (1);
+      Array<FloatComplex> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2648,23 +2638,23 @@ FloatComplexMatrix::lssolve (const Float
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<float> rwork (lrwork);
+      Array<float> rwork (lrwork, 1);
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2692,17 +2682,17 @@ FloatComplexMatrix::lssolve (const Float
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         (*current_liboctave_warning_handler) 
@@ -2809,23 +2799,23 @@ FloatComplexMatrix::lssolve (const Float
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
-      Array<float> s (minmn);
+      Array<float> s (minmn, 1);
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<FloatComplex> work (1);
+      Array<FloatComplex> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2842,33 +2832,33 @@ FloatComplexMatrix::lssolve (const Float
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
         + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
-      Array<float> rwork (lrwork);
+      Array<float> rwork (lrwork, 1);
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
-      work.resize (lwork);
-      rwork.resize (static_cast<octave_idx_type> (rwork(0)));
-      iwork.resize (iwork(0));
+      work.resize (lwork, 1);
+      rwork.resize (static_cast<octave_idx_type> (rwork(0)), 1);
+      iwork.resize (iwork(0), 1);
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
@@ -3247,17 +3237,17 @@ FloatMatrix FloatComplexMatrix::abs (voi
 {
   return FloatMatrix (mx_inline_cabs_dup (data (), length ()),
                       rows (), cols ());
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::diag (octave_idx_type k) const
 {
-  return MArray2<FloatComplex>::diag (k);
+  return MArray<FloatComplex>::diag (k);
 }
 
 bool
 FloatComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
@@ -3306,17 +3296,17 @@ FloatComplexMatrix::row_min (Array<octav
   FloatComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_min;
@@ -3380,17 +3370,17 @@ FloatComplexMatrix::row_max (Array<octav
   FloatComplexColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_max;
@@ -3454,17 +3444,17 @@ FloatComplexMatrix::column_min (Array<oc
   FloatComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_min;
@@ -3528,17 +3518,17 @@ FloatComplexMatrix::column_max (Array<oc
   FloatComplexRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_max;
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -19,58 +19,58 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatComplexMatrix_h)
 #define octave_FloatComplexMatrix_h 1
 
-#include "MArray2.h"
+#include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-FloatComplexMatrix : public MArray2<FloatComplex>
+FloatComplexMatrix : public MArray<FloatComplex>
 {
 public:
  
   typedef FloatComplexColumnVector column_vector_type;
   typedef FloatComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
-  FloatComplexMatrix (void) : MArray2<FloatComplex> () { }
+  FloatComplexMatrix (void) : MArray<FloatComplex> () { }
 
-  FloatComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<FloatComplex> (r, c) { }
+  FloatComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray<FloatComplex> (r, c) { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
-    : MArray2<FloatComplex> (r, c, val) { }
+    : MArray<FloatComplex> (r, c, val) { }
 
-  FloatComplexMatrix (const dim_vector& dv) : MArray2<FloatComplex> (dv) { }
+  FloatComplexMatrix (const dim_vector& dv) : MArray<FloatComplex> (dv.redim (2)) { }
 
   FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val) 
-    : MArray2<FloatComplex> (dv, val) { }
+    : MArray<FloatComplex> (dv.redim (2), val) { }
 
-  FloatComplexMatrix (const FloatComplexMatrix& a) : MArray2<FloatComplex> (a) { }
+  FloatComplexMatrix (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexMatrix (const MArray2<U>& a) : MArray2<FloatComplex> (a) { }
+  FloatComplexMatrix (const MArray<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
 
   template <class U>
-  FloatComplexMatrix (const Array2<U>& a) : MArray2<FloatComplex> (a) { }
+  FloatComplexMatrix (const Array2<U>& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexMatrix (const Array<U>& a) : MArray2<FloatComplex> (a) { }
+  FloatComplexMatrix (const Array<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
 
   explicit FloatComplexMatrix (const FloatMatrix& a);
 
   explicit FloatComplexMatrix (const FloatRowVector& rv);
 
   explicit FloatComplexMatrix (const FloatColumnVector& cv);
 
   explicit FloatComplexMatrix (const FloatDiagMatrix& a);
@@ -84,17 +84,17 @@ public:
   explicit FloatComplexMatrix (const boolMatrix& a);
 
   explicit FloatComplexMatrix (const charMatrix& a);
 
   FloatComplexMatrix (const FloatMatrix& re, const FloatMatrix& im);
 
   FloatComplexMatrix& operator = (const FloatComplexMatrix& a)
     {
-      MArray2<FloatComplex>::operator = (a);
+      MArray<FloatComplex>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatComplexMatrix& a) const;
   bool operator != (const FloatComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
@@ -131,19 +131,19 @@ public:
   FloatComplexMatrix stack (const FloatDiagMatrix& a) const;
 
   FloatComplexMatrix stack (const FloatComplexMatrix& a) const;
   FloatComplexMatrix stack (const FloatComplexRowVector& a) const;
   FloatComplexMatrix stack (const FloatComplexColumnVector& a) const;
   FloatComplexMatrix stack (const FloatComplexDiagMatrix& a) const;
 
   FloatComplexMatrix hermitian (void) const
-    { return MArray2<FloatComplex>::hermitian (std::conj); }
+    { return MArray<FloatComplex>::hermitian (std::conj); }
   FloatComplexMatrix transpose (void) const
-    { return MArray2<FloatComplex>::transpose (); }
+    { return MArray<FloatComplex>::transpose (); }
 
   friend OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
   // resize is the destructive equivalent for this one
 
   FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   FloatComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
@@ -373,17 +373,17 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexMatrix& a);
 
   static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
 
 private:
 
-  FloatComplexMatrix (FloatComplex *d, octave_idx_type r, octave_idx_type c) : MArray2<FloatComplex> (d, r, c) { }
+  FloatComplexMatrix (FloatComplex *d, octave_idx_type r, octave_idx_type c) : MArray<FloatComplex> (d, r, c) { }
 };
 
 extern OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatColumnVector& a, const FloatComplexRowVector& b);
@@ -425,11 +425,11 @@ MS_CMP_OP_DECLS (FloatComplexMatrix, Flo
 MS_BOOL_OP_DECLS (FloatComplexMatrix, FloatComplex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatComplexMatrix, FloatComplexMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (FloatComplexMatrix, FloatComplexMatrix, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArray2, FloatComplexMatrix, FloatComplex)
+MARRAY_FORWARD_DEFS (MArray, FloatComplexMatrix, FloatComplex)
 
 #endif
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 #include "bsxfun-defs.cc"
 
 FloatComplexNDArray::FloatComplexNDArray (const charNDArray& a)
-  : MArrayN<FloatComplex> (a.dims ())
+  : MArray<FloatComplex> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
 #if defined (HAVE_FFTW)
 
@@ -207,17 +207,17 @@ FloatComplexNDArray::fourier (int dim) c
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -254,17 +254,17 @@ FloatComplexNDArray::ifourier (int dim) 
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
 
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -304,19 +304,19 @@ FloatComplexNDArray::fourier2d (void) co
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (nn);
+      Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (npts);
+      Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -352,19 +352,19 @@ FloatComplexNDArray::ifourier2d (void) c
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (nn);
+      Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (npts);
+      Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -400,19 +400,19 @@ FloatComplexNDArray::fourierNd (void) co
   int rank = dv.length ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (nn);
+      Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (npts);
+      Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -447,19 +447,19 @@ FloatComplexNDArray::ifourierNd (void) c
   int rank = dv.length ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (nn);
+      Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (npts);
+      Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
@@ -776,17 +776,17 @@ FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
   
   if (n == dimensions.length ())
     {
-      Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
+      Array<octave_idx_type> a_ra_idx (a_dv.length (), 1, 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
@@ -863,17 +863,17 @@ FloatComplexNDArray::compute_index (Arra
                                const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
 {
-  return MArrayN<FloatComplex>::diag (k);
+  return MArray<FloatComplex>::diag (k);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -18,53 +18,53 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatComplexNDArray_h)
 #define octave_FloatComplexNDArray_h 1
 
-#include "MArrayN.h"
+#include "MArray.h"
 #include "fCMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
-FloatComplexNDArray : public MArrayN<FloatComplex>
+FloatComplexNDArray : public MArray<FloatComplex>
 {
 public:
 
   typedef FloatComplexMatrix matrix_type;
 
-  FloatComplexNDArray (void) : MArrayN<FloatComplex> () { }
+  FloatComplexNDArray (void) : MArray<FloatComplex> () { }
 
-  FloatComplexNDArray (const dim_vector& dv) : MArrayN<FloatComplex> (dv) { }
+  FloatComplexNDArray (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
 
   FloatComplexNDArray (const dim_vector& dv, const FloatComplex& val)
-    : MArrayN<FloatComplex> (dv, val) { }
+    : MArray<FloatComplex> (dv, val) { }
   
-  FloatComplexNDArray (const FloatComplexNDArray& a) : MArrayN<FloatComplex> (a) { }
+  FloatComplexNDArray (const FloatComplexNDArray& a) : MArray<FloatComplex> (a) { }
 
-  FloatComplexNDArray (const FloatComplexMatrix& a) : MArrayN<FloatComplex> (a) { }
+  FloatComplexNDArray (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexNDArray (const MArrayN<U>& a) : MArrayN<FloatComplex> (a) { }
+  FloatComplexNDArray (const MArray<U>& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexNDArray (const Array<U>& a) : MArrayN<FloatComplex> (a) { }
+  FloatComplexNDArray (const Array<U>& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexNDArray (const charNDArray&); 
 
   FloatComplexNDArray& operator = (const FloatComplexNDArray& a)
     {
-      MArrayN<FloatComplex>::operator = (a);
+      MArray<FloatComplex>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   // FIXME -- this is not quite the right thing.
@@ -116,17 +116,17 @@ public:
   FloatComplexNDArray fourier2d (void) const;
   FloatComplexNDArray ifourier2d (void) const;
 
   FloatComplexNDArray fourierNd (void) const;
   FloatComplexNDArray ifourierNd (void) const;
 
   FloatComplexMatrix matrix_value (void) const;
 
-  FloatComplexNDArray squeeze (void) const { return MArrayN<FloatComplex>::squeeze (); }
+  FloatComplexNDArray squeeze (void) const { return MArray<FloatComplex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
@@ -139,40 +139,40 @@ public:
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
   FloatComplexNDArray& changesign (void) 
     { 
-      MArrayN<FloatComplex>::changesign (); 
+      MArray<FloatComplex>::changesign (); 
       return *this; 
     }
 
 private:
 
   FloatComplexNDArray (FloatComplex *d, const dim_vector& dv)
-    : MArrayN<FloatComplex> (d, dv) { }
+    : MArray<FloatComplex> (d, dv) { }
 };
 
 extern OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
 MINMAX_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
 
 NDS_CMP_OP_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
 NDS_BOOL_OP_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
 
 SND_CMP_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, FloatComplexNDArray, FloatComplex)
+MARRAY_FORWARD_DEFS (MArray, FloatComplexNDArray, FloatComplex)
 
 extern OCTAVE_API FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s);
 extern OCTAVE_API FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s);
 
 BSXFUN_STDOP_DECLS (FloatComplexNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatComplexNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatComplexNDArray, OCTAVE_API)
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -49,23 +49,16 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (xcdotu, XCDOTU) (const octave_idx_type&, const FloatComplex*, const octave_idx_type&,
                              const FloatComplex*, const octave_idx_type&, FloatComplex&);
 }
 
 // FloatComplex Row Vector class
 
-FloatComplexRowVector::FloatComplexRowVector (const FloatRowVector& a)
-  : MArray<FloatComplex> (a.length ())
-{
-  for (octave_idx_type i = 0; i < length (); i++)
-    elem (i) = a.elem (i);
-}
-
 bool
 FloatComplexRowVector::operator == (const FloatComplexRowVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (len, data (), a.data ());
 }
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -20,40 +20,43 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatComplexRowVector_h)
 #define octave_FloatComplexRowVector_h 1
 
 #include "MArray.h"
+#include "fRowVector.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatComplexRowVector : public MArray<FloatComplex>
 {
 friend class FloatComplexColumnVector;
 
 public:
 
-  FloatComplexRowVector (void) : MArray<FloatComplex> () { }
+  FloatComplexRowVector (void) : MArray<FloatComplex> (1, 0) { }
 
-  explicit FloatComplexRowVector (octave_idx_type n) : MArray<FloatComplex> (n) { }
+  explicit FloatComplexRowVector (octave_idx_type n) : MArray<FloatComplex> (1, n) { }
 
-  explicit FloatComplexRowVector (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
+  explicit FloatComplexRowVector (const dim_vector& dv) : MArray<FloatComplex> (dv.as_row ()) { }
 
-  FloatComplexRowVector (octave_idx_type n, const FloatComplex& val) : MArray<FloatComplex> (n, val) { }
+  FloatComplexRowVector (octave_idx_type n, const FloatComplex& val) 
+    : MArray<FloatComplex> (1, n, val) { }
 
   FloatComplexRowVector (const FloatComplexRowVector& a) : MArray<FloatComplex> (a) { }
 
-  FloatComplexRowVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a) { }
+  FloatComplexRowVector (const MArray<FloatComplex>& a) : MArray<FloatComplex> (a.as_row ()) { }
+  FloatComplexRowVector (const Array<FloatComplex>& a) : MArray<FloatComplex> (a.as_row ()) { }
 
-  explicit FloatComplexRowVector (const FloatRowVector& a);
+  explicit FloatComplexRowVector (const FloatRowVector& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexRowVector& operator = (const FloatComplexRowVector& a)
     {
       MArray<FloatComplex>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatComplexRowVector& a) const;
@@ -101,19 +104,25 @@ public:
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
 
+  void resize (octave_idx_type n, const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+    { Array<FloatComplex>::resize (1, n, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<FloatComplex>::clear (1, n); }
+
 private:
 
-  FloatComplexRowVector (FloatComplex *d, octave_idx_type l) : MArray<FloatComplex> (d, l) { }
+  FloatComplexRowVector (FloatComplex *d, octave_idx_type l) : MArray<FloatComplex> (d, 1, l) { }
 };
 
 // row vector by column vector -> scalar
 
 FloatComplex operator * (const FloatComplexRowVector& a, const ColumnVector& b);
 
 FloatComplex operator * (const FloatComplexRowVector& a, const FloatComplexColumnVector& b);
 
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -118,19 +118,19 @@ FloatComplexCHOL::init (const FloatCompl
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type cpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<FloatComplex> z (2*n);
+      Array<FloatComplex> z (2*n, 1);
       FloatComplex *pz = z.fortran_vec ();
-      Array<float> rz (n);
+      Array<float> rz (n, 1);
       float *prz = rz.fortran_vec ();
       F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, cpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (cpocon_info != 0) 
         info = -1;
     }
@@ -410,17 +410,17 @@ FloatComplexCHOL::shift_sym (octave_idx_
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (n);
+      Array<octave_idx_type> p (n, 1);
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -76,27 +76,27 @@ FloatComplexHESS::init (const FloatCompl
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   FloatComplex *h = hess_mat.fortran_vec ();
 
-  Array<float> scale (n);
+  Array<float> scale (n, 1);
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<FloatComplex> tau (n-1);
+  Array<FloatComplex> tau (n-1, 1);
   FloatComplex *ptau = tau.fortran_vec ();
 
-  Array<FloatComplex> work (lwork);
+  Array<FloatComplex> work (lwork, 1);
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
   unitary_hess_mat = hess_mat;
   FloatComplex *z = unitary_hess_mat.fortran_vec ();
 
   F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
diff --git a/liboctave/fCmplxLU.cc b/liboctave/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/fCmplxLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 FloatComplexLU::FloatComplexLU (const FloatComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn);
+  ipvt.resize (mn, 1);
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   FloatComplex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -60,17 +60,17 @@ FloatComplexQRP::init (const FloatComple
   OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 0);
+  MArray<octave_idx_type> jpvt (n, 1, 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rwork, 2*n);
 
       // workspace query.
       FloatComplex clwork;
       F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -104,27 +104,27 @@ FloatComplexSCHUR::init (const FloatComp
 
   schur_mat = a;
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
   FloatComplex *s = schur_mat.fortran_vec ();
   FloatComplex *q = unitary_mat.fortran_vec ();
 
-  Array<float> rwork (n);
+  Array<float> rwork (n, 1);
   float *prwork = rwork.fortran_vec ();
 
-  Array<FloatComplex> w (n);
+  Array<FloatComplex> w (n, 1);
   FloatComplex *pw = w.fortran_vec ();
 
-  Array<FloatComplex> work (lwork);
+  Array<FloatComplex> work (lwork, 1);
   FloatComplex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pw, q, n, rconde, rcondv,
                              pwork, lwork, prwork, pbwork, info
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -128,37 +128,37 @@ FloatComplexSVD::init (const FloatComple
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   FloatComplex *vt = right_sm.fortran_vec ();
 
   octave_idx_type lrwork = 5*max_mn;
 
-  Array<float> rwork (lrwork);
+  Array<float> rwork (lrwork, 1);
 
   // Ask ZGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<FloatComplex> work (1);
+  Array<FloatComplex> work (1, 1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork,
                              rwork.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0).real ());
-  work.resize (lwork);
+  work.resize (lwork, 1);
 
   F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork,
                              rwork.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -29,27 +29,29 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatColumnVector : public MArray<float>
 {
 public:
 
-  FloatColumnVector (void) : MArray<float> () { }
+  FloatColumnVector (void) : MArray<float> (0, 1) { }
 
-  explicit FloatColumnVector (octave_idx_type n) : MArray<float> (n) { }
+  explicit FloatColumnVector (octave_idx_type n) : MArray<float> (n, 1) { }
 
-  explicit FloatColumnVector (const dim_vector& dv) : MArray<float> (dv) { }
+  explicit FloatColumnVector (const dim_vector& dv) 
+    : MArray<float> (dv.as_column ()) { }
 
-  FloatColumnVector (octave_idx_type n, float val) : MArray<float> (n, val) { }
+  FloatColumnVector (octave_idx_type n, float val) : MArray<float> (n, 1, val) { }
 
   FloatColumnVector (const FloatColumnVector& a) : MArray<float> (a) { }
 
-  FloatColumnVector (const MArray<float>& a) : MArray<float> (a) { }
+  FloatColumnVector (const MArray<float>& a) : MArray<float> (a.as_column ()) { }
+  FloatColumnVector (const Array<float>& a) : MArray<float> (a.as_column ()) { }
 
   FloatColumnVector& operator = (const FloatColumnVector& a)
     {
       MArray<float>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatColumnVector& a) const;
@@ -88,19 +90,25 @@ public:
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
+  void resize (octave_idx_type n, const float& rfv = Array<float>::resize_fill_value ())
+    { Array<float>::resize (n, 1, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<float>::clear (n, 1); }
+
 private:
 
-  FloatColumnVector (float *d, octave_idx_type l) : MArray<float> (d, l) { }
+  FloatColumnVector (float *d, octave_idx_type l) : MArray<float> (d, l, 1) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatColumnVector real (const FloatComplexColumnVector& a);
 extern OCTAVE_API FloatColumnVector imag (const FloatComplexColumnVector& a);
 
 MARRAY_FORWARD_DEFS (MArray, FloatColumnVector, float)
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -150,20 +150,20 @@ FloatEIG::init (const FloatMatrix& a, bo
       return -1;
     }
 
   octave_idx_type info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
-  Array<float> wr (n);
+  Array<float> wr (n, 1);
   float *pwr = wr.fortran_vec ();
 
-  Array<float> wi (n);
+  Array<float> wi (n, 1);
   float *pwi = wi.fortran_vec ();
 
   volatile octave_idx_type nvr = calc_ev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
@@ -176,17 +176,17 @@ FloatEIG::init (const FloatMatrix& a, bo
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork);
+      Array<float> work (lwork, 1);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pwr, pwi, dummy,
                                idummy, pvr, n, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -268,17 +268,17 @@ FloatEIG::symmetric_init (const FloatMat
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork);
+      Array<float> work (lwork, 1);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -335,33 +335,33 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type nvr = calc_ev ? n : 0;
   FloatComplexMatrix vtmp (nvr, nvr);
   FloatComplex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 2*n;
-  Array<float> rwork (lrwork);
+  Array<float> rwork (lrwork, 1);
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork);
+      Array<FloatComplex> work (lwork, 1);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, tmp_data, n, pw, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
@@ -405,30 +405,30 @@ FloatEIG::hermitian_init (const FloatCom
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<float> rwork (lrwork);
+  Array<float> rwork (lrwork, 1);
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork);
+      Array<FloatComplex> work (lwork, 1);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, tmp_data, n, pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
@@ -493,23 +493,23 @@ FloatEIG::init (const FloatMatrix& a, co
     return symmetric_init (a, b, calc_ev);
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
   float *btmp_data = btmp.fortran_vec ();
 
-  Array<float> ar (n);
+  Array<float> ar (n, 1);
   float *par = ar.fortran_vec ();
 
-  Array<float> ai (n);
+  Array<float> ai (n, 1);
   float *pai = ai.fortran_vec ();
 
-  Array<float> beta (n);
+  Array<float> beta (n, 1);
   float *pbeta = beta.fortran_vec ();
 
   volatile octave_idx_type nvr = calc_ev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
@@ -524,17 +524,17 @@ FloatEIG::init (const FloatMatrix& a, co
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork);
+      Array<float> work (lwork, 1);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
@@ -632,17 +632,17 @@ FloatEIG::symmetric_init (const FloatMat
                            btmp_data, n, 
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (lwork);
+      Array<float> work (lwork, 1);
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -723,34 +723,34 @@ FloatEIG::init (const FloatComplexMatrix
   octave_idx_type nvr = calc_ev ? n : 0;
   FloatComplexMatrix vtmp (nvr, nvr);
   FloatComplex *pv = vtmp.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 8*n;
-  Array<float> rwork (lrwork);
+  Array<float> rwork (lrwork, 1);
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n, 
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork);
+      Array<FloatComplex> work (lwork, 1);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                n, atmp_data, n, btmp_data, n, 
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
@@ -809,32 +809,32 @@ FloatEIG::hermitian_init (const FloatCom
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
-  Array<float> rwork (lrwork);
+  Array<float> rwork (lrwork, 1);
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n, 
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (lwork);
+      Array<FloatComplex> work (lwork, 1);
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
                                n, atmp_data, n, 
                                btmp_data, n, 
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -208,58 +208,55 @@ extern "C"
                                const octave_idx_type&, const float*,
                                const octave_idx_type&, float*, float&
                                F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 FloatMatrix::FloatMatrix (const FloatRowVector& rv)
-  : MArray2<float> (Array2<float> (rv, 1, rv.length ()))
+  : MArray<float> (rv)
 {
 }
 
 FloatMatrix::FloatMatrix (const FloatColumnVector& cv)
-  : MArray2<float> (Array2<float> (cv, cv.length (), 1))
+  : MArray<float> (cv)
 {
 }
 
 FloatMatrix::FloatMatrix (const FloatDiagMatrix& a)
-  : MArray2<float> (a.rows (), a.cols (), 0.0)
+  : MArray<float> (a.rows (), a.cols (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatMatrix::FloatMatrix (const PermMatrix& a)
-  : MArray2<float> (a.rows (), a.cols (), 0.0)
+  : MArray<float> (a.rows (), a.cols (), 0.0)
 {
   const Array<octave_idx_type> ia (a.pvec ());
   octave_idx_type len = a.rows ();
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
       elem (i, ia(i)) = 1.0;
 }
 
 // FIXME -- could we use a templated mixed-type copy function
 // here?
 
 FloatMatrix::FloatMatrix (const boolMatrix& a)
-  : MArray2<float> (a.rows (), a.cols ())
+  : MArray<float> (a)
 {
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    for (octave_idx_type j = 0; j < a.cols (); j++)
-      elem (i, j) = a.elem (i, j);
 }
 
 FloatMatrix::FloatMatrix (const charMatrix& a)
-  : MArray2<float> (a.rows (), a.cols ())
+  : MArray<float> (a.rows (), a.cols ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 FloatMatrix::operator == (const FloatMatrix& a) const
@@ -290,17 +287,17 @@ FloatMatrix::is_symmetric (void) const
     }
 
   return false;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  Array2<float>::insert (a, r, c);
+  Array<float>::insert (a, r, c);
   return *this;
 }
 
 FloatMatrix&
 FloatMatrix::insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
@@ -608,23 +605,23 @@ FloatMatrix::extract_n (octave_idx_type 
   return result;
 }
 
 // extract row or column i.
 
 FloatRowVector
 FloatMatrix::row (octave_idx_type i) const
 {
-  return MArray<float> (index (idx_vector (i), idx_vector::colon));
+  return index (idx_vector (i), idx_vector::colon);
 }
 
 FloatColumnVector
 FloatMatrix::column (octave_idx_type i) const
 {
-  return MArray<float> (index (idx_vector::colon, idx_vector (i)));
+  return index (idx_vector::colon, idx_vector (i));
 }
 
 FloatMatrix
 FloatMatrix::inverse (void) const
 {
   octave_idx_type info;
   float rcon;
   MatrixType mattype (*this);
@@ -728,32 +725,32 @@ FloatMatrix::finverse (MatrixType &matty
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<octave_idx_type> ipvt (nr);
+      Array<octave_idx_type> ipvt (nr, 1);
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
-      Array<float> z(1);
+      Array<float> z(1, 1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt, 
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (lwork);
+      z.resize (lwork, 1);
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
@@ -765,17 +762,17 @@ FloatMatrix::finverse (MatrixType &matty
       if (info != 0) 
         info = -1;
       else if (calc_cond) 
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nc, tmp_data, nr, anorm, 
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (dgecon_info != 0) 
             info = -1;
@@ -1000,17 +997,17 @@ FloatMatrix::fourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1041,17 +1038,17 @@ FloatMatrix::ifourier (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1085,17 +1082,17 @@ FloatMatrix::fourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1104,20 +1101,20 @@ FloatMatrix::fourier2d (void) const
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts);
+  Array<FloatComplex> tmp (npts, 1);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1151,17 +1148,17 @@ FloatMatrix::ifourier2d (void) const
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
-  Array<FloatComplex> wsave (nn);
+  Array<FloatComplex> wsave (nn, 1);
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
@@ -1173,20 +1170,20 @@ FloatMatrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
-  wsave.resize (nn);
+  wsave.resize (nn, 1);
   pwsave = wsave.fortran_vec ();
 
-  Array<FloatComplex> tmp (npts);
+  Array<FloatComplex> tmp (npts, 1);
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
@@ -1273,19 +1270,19 @@ FloatMatrix::determinant (MatrixType& ma
           if (info != 0) 
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
-              Array<float> z (3 * nc);
+              Array<float> z (3 * nc, 1);
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc);
+              Array<octave_idx_type> iz (nc, 1);
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0) 
@@ -1297,17 +1294,17 @@ FloatMatrix::determinant (MatrixType& ma
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
       if (typ == MatrixType::Full)
         {
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
@@ -1324,19 +1321,19 @@ FloatMatrix::determinant (MatrixType& ma
               retval = FloatDET ();
             } 
           else 
             {
               if (calc_cond) 
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
-                  Array<float> z (4 * nc);
+                  Array<float> z (4 * nc, 1);
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm, 
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
@@ -1389,19 +1386,19 @@ FloatMatrix::rcond (MatrixType &mattype)
       if (typ == MatrixType::Upper)
         {
           const float *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
-          Array<float> z (3 * nc);
+          Array<float> z (3 * nc, 1);
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1417,19 +1414,19 @@ FloatMatrix::rcond (MatrixType &mattype)
       else if (typ == MatrixType::Lower)
         {
           const float *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
-          Array<float> z (3 * nc);
+          Array<float> z (3 * nc, 1);
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                      F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                      F77_CONST_CHAR_ARG2 (&dia, 1), 
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
@@ -1462,45 +1459,45 @@ FloatMatrix::rcond (MatrixType &mattype)
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else 
                 {
-                  Array<float> z (3 * nc);
+                  Array<float> z (3 * nc, 1);
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
-              Array<octave_idx_type> ipvt (nr);
+              Array<octave_idx_type> ipvt (nr, 1);
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
                 anorm = atmp.abs().sum().
                   row(static_cast<octave_idx_type>(0)).max();
 
-              Array<float> z (4 * nc);
+              Array<float> z (4 * nc, 1);
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (nc);
+              Array<octave_idx_type> iz (nc, 1);
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0) 
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1561,19 +1558,19 @@ FloatMatrix::utsolve (MatrixType &mattyp
               const float *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'U';
                   char dia = 'N';
 
-                  Array<float> z (3 * nc);
+                  Array<float> z (3 * nc, 1);
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1661,19 +1658,19 @@ FloatMatrix::ltsolve (MatrixType &mattyp
               const float *tmp_data = fortran_vec ();
 
               if (calc_cond)
                 {
                   char norm = '1';
                   char uplo = 'L';
                   char dia = 'N';
 
-                  Array<float> z (3 * nc);
+                  Array<float> z (3 * nc, 1);
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
                                              F77_CONST_CHAR_ARG2 (&uplo, 1), 
                                              F77_CONST_CHAR_ARG2 (&dia, 1), 
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
@@ -1767,19 +1764,19 @@ FloatMatrix::fsolve (MatrixType &mattype
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else 
             {
               if (calc_cond)
                 {
-                  Array<float> z (3 * nc);
+                  Array<float> z (3 * nc, 1);
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (nc);
+                  Array<octave_idx_type> iz (nc, 1);
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0) 
@@ -1819,27 +1816,27 @@ FloatMatrix::fsolve (MatrixType &mattype
                 }                   
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (nr);
+          Array<octave_idx_type> ipvt (nr, 1);
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          Array<float> z (4 * nc);
+          Array<float> z (4 * nc, 1);
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (nc);
+          Array<octave_idx_type> iz (nc, 1);
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0) 
             {
@@ -2258,23 +2255,23 @@ FloatMatrix::lssolve (const FloatMatrix&
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
-      Array<float> s (minmn);
+      Array<float> s (minmn, 1);
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<float> work (1);
+      Array<float> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2296,17 +2293,17 @@ FloatMatrix::lssolve (const FloatMatrix&
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
@@ -2341,17 +2338,17 @@ FloatMatrix::lssolve (const FloatMatrix&
           octave_idx_type lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         (*current_liboctave_warning_handler) 
@@ -2459,23 +2456,23 @@ FloatMatrix::lssolve (const FloatColumnV
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
-      Array<float> s (minmn);
+      Array<float> s (minmn, 1);
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
       octave_idx_type lwork = -1;
 
-      Array<float> work (1);
+      Array<float> work (1, 1);
 
       octave_idx_type smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
@@ -2490,25 +2487,25 @@ FloatMatrix::lssolve (const FloatColumnV
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (liwork);
+      Array<octave_idx_type> iwork (liwork, 1);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork);
+      work.resize (lwork, 1);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
                                  work.fortran_vec (), lwork, 
                                  piwork, info));
 
       if (rank < minmn)
         {
@@ -2825,17 +2822,17 @@ FloatMatrix::abs (void) const
 {
   return FloatMatrix (mx_inline_fabs_dup (data (), length ()),
                       rows (), cols ());
 }
 
 FloatMatrix
 FloatMatrix::diag (octave_idx_type k) const
 {
-  return MArray2<float>::diag (k);
+  return MArray<float>::diag (k);
 }
 
 FloatColumnVector
 FloatMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -2846,17 +2843,17 @@ FloatMatrix::row_min (Array<octave_idx_t
   FloatColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           float tmp_min = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2901,17 +2898,17 @@ FloatMatrix::row_max (Array<octave_idx_t
   FloatColumnVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
-      idx_arg.resize (nr);
+      idx_arg.resize (nr, 1);
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
           float tmp_max = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
@@ -2956,17 +2953,17 @@ FloatMatrix::column_min (Array<octave_id
   FloatRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           float tmp_min = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
@@ -3011,17 +3008,17 @@ FloatMatrix::column_max (Array<octave_id
   FloatRowVector result;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
-      idx_arg.resize (nc);
+      idx_arg.resize (1, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
           float tmp_max = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -19,72 +19,73 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatMatrix_int_h)
 #define octave_FloatMatrix_int_h 1
 
-#include "MArray2.h"
+#include "Array2.h"
+#include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-FloatMatrix : public MArray2<float>
+FloatMatrix : public MArray<float>
 {
 public:
 
   typedef FloatColumnVector column_vector_type;
   typedef FloatRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
-  FloatMatrix (void) : MArray2<float> () { }
+  FloatMatrix (void) : MArray<float> () { }
 
-  FloatMatrix (octave_idx_type r, octave_idx_type c) : MArray2<float> (r, c) { }
+  FloatMatrix (octave_idx_type r, octave_idx_type c) : MArray<float> (r, c) { }
 
-  FloatMatrix (octave_idx_type r, octave_idx_type c, float val) : MArray2<float> (r, c, val) { }
+  FloatMatrix (octave_idx_type r, octave_idx_type c, float val) : MArray<float> (r, c, val) { }
 
-  FloatMatrix (const dim_vector& dv) : MArray2<float> (dv) { }
+  FloatMatrix (const dim_vector& dv) : MArray<float> (dv.redim (2)) { }
 
-  FloatMatrix (const dim_vector& dv, float val) : MArray2<float> (dv, val) { }
+  FloatMatrix (const dim_vector& dv, float val) : MArray<float> (dv.redim (2), val) { }
 
-  FloatMatrix (const FloatMatrix& a) : MArray2<float> (a) { }
+  FloatMatrix (const FloatMatrix& a) : MArray<float> (a) { }
 
   template <class U>
-  FloatMatrix (const MArray2<U>& a) : MArray2<float> (a) { }
+  FloatMatrix (const MArray<U>& a) : MArray<float> (a.as_matrix ()) { }
 
   template <class U>
-  FloatMatrix (const Array2<U>& a) : MArray2<float> (a) { }
+  FloatMatrix (const Array2<U>& a) : MArray<float> (a) { }
 
   template <class U>
-  FloatMatrix (const Array<U>& a) : MArray2<float> (a) { }
+  FloatMatrix (const Array<U>& a) : MArray<float> (a.as_matrix ()) { }
 
   explicit FloatMatrix (const FloatRowVector& rv);
 
   explicit FloatMatrix (const FloatColumnVector& cv);
 
   explicit FloatMatrix (const FloatDiagMatrix& a);
 
   explicit FloatMatrix (const PermMatrix& a);
 
   explicit FloatMatrix (const boolMatrix& a);
 
   explicit FloatMatrix (const charMatrix& a);
 
 
   FloatMatrix& operator = (const FloatMatrix& a)
     {
-      MArray2<float>::operator = (a);
+      MArray<float>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatMatrix& a) const;
   bool operator != (const FloatMatrix& a) const;
 
   bool is_symmetric (void) const;
 
@@ -108,17 +109,17 @@ public:
   FloatMatrix stack (const FloatColumnVector& a) const;
   FloatMatrix stack (const FloatDiagMatrix& a) const;
 
   friend OCTAVE_API FloatMatrix real (const FloatComplexMatrix& a);
   friend OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
   friend class FloatComplexMatrix;
 
-  FloatMatrix transpose (void) const { return MArray2<float>::transpose (); }
+  FloatMatrix transpose (void) const { return MArray<float>::transpose (); }
 
   // resize is the destructive equivalent for this one
 
   FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
@@ -326,17 +327,17 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatMatrix& a);
 
   static float resize_fill_value (void) { return 0; }
 
 private:
 
-  FloatMatrix (float *d, octave_idx_type r, octave_idx_type c) : MArray2<float> (d, r, c) { }
+  FloatMatrix (float *d, octave_idx_type r, octave_idx_type c) : MArray<float> (d, r, c) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatMatrix real (const FloatComplexMatrix& a);
 extern OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
@@ -372,14 +373,14 @@ MS_CMP_OP_DECLS (FloatMatrix, float, OCT
 MS_BOOL_OP_DECLS (FloatMatrix, float, OCTAVE_API)
 
 SM_CMP_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArray2, FloatMatrix, float)
+MARRAY_FORWARD_DEFS (MArray, FloatMatrix, float)
 
 template <class T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 #include "bsxfun-defs.cc"
 
 FloatNDArray::FloatNDArray (const charNDArray& a)
-  : MArrayN<float> (a.dims ())
+  : MArray<float> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
 #if defined (HAVE_FFTW)
 
@@ -893,17 +893,17 @@ FloatNDArray::compute_index (Array<octav
                         const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatNDArray
 FloatNDArray::diag (octave_idx_type k) const
 {
-  return MArrayN<float>::diag (k);
+  return MArray<float>::diag (k);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -19,57 +19,57 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatNDArray_h)
 #define octave_FloatNDArray_h 1
 
-#include "MArrayN.h"
+#include "MArray.h"
 #include "fMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
-FloatNDArray : public MArrayN<float>
+FloatNDArray : public MArray<float>
 {
 public:
 
   typedef FloatMatrix matrix_type;
 
-  FloatNDArray (void) : MArrayN<float> () { }
+  FloatNDArray (void) : MArray<float> () { }
 
-  FloatNDArray (const dim_vector& dv) : MArrayN<float> (dv) { }
+  FloatNDArray (const dim_vector& dv) : MArray<float> (dv) { }
 
   FloatNDArray (const dim_vector& dv, float val)
-    : MArrayN<float> (dv, val) { }
+    : MArray<float> (dv, val) { }
   
-  FloatNDArray (const FloatNDArray& a) : MArrayN<float> (a) { }
+  FloatNDArray (const FloatNDArray& a) : MArray<float> (a) { }
 
-  FloatNDArray (const FloatMatrix& a) : MArrayN<float> (a) { }
+  FloatNDArray (const FloatMatrix& a) : MArray<float> (a) { }
 
   template <class U>
-  FloatNDArray (const MArrayN<U>& a) : MArrayN<float> (a) { }
+  FloatNDArray (const MArray<U>& a) : MArray<float> (a) { }
 
   template <class U>
-  FloatNDArray (const Array<U>& a) : MArrayN<float> (a) { }
+  FloatNDArray (const Array<U>& a) : MArray<float> (a) { }
 
   template <class U>
-  explicit FloatNDArray (const intNDArray<U>& a) : MArrayN<float> (a) { }
+  explicit FloatNDArray (const intNDArray<U>& a) : MArray<float> (a) { }
 
   FloatNDArray (const charNDArray&); 
 
   FloatNDArray& operator = (const FloatNDArray& a)
     {
-      MArrayN<float>::operator = (a);
+      MArray<float>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_negative (bool = false) const;
@@ -128,17 +128,17 @@ public:
 
   friend OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
   friend OCTAVE_API FloatNDArray imag (const FloatComplexNDArray& a);
 
   friend class FloatComplexNDArray;
 
   FloatMatrix matrix_value (void) const;
 
-  FloatNDArray squeeze (void) const { return MArrayN<float>::squeeze (); }
+  FloatNDArray squeeze (void) const { return MArray<float>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
@@ -148,23 +148,23 @@ public:
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
   static float resize_fill_value (void) { return 0; }
 
   FloatNDArray diag (octave_idx_type k = 0) const;
 
   FloatNDArray& changesign (void) 
     { 
-      MArrayN<float>::changesign (); 
+      MArray<float>::changesign (); 
       return *this; 
     }
 
 private:
 
-  FloatNDArray (float *d, const dim_vector& dv) : MArrayN<float> (d, dv) { }
+  FloatNDArray (float *d, const dim_vector& dv) : MArray<float> (d, dv) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
 extern OCTAVE_API FloatNDArray imag (const FloatComplexNDArray& a);
 
 MINMAX_DECLS (FloatNDArray, float, OCTAVE_API)
@@ -173,17 +173,17 @@ NDS_CMP_OP_DECLS (FloatNDArray, float, O
 NDS_BOOL_OP_DECLS (FloatNDArray, float, OCTAVE_API)
 
 SND_CMP_OP_DECLS (float, FloatNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (float, FloatNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (FloatNDArray, FloatNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatNDArray, FloatNDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, FloatNDArray, float)
+MARRAY_FORWARD_DEFS (MArray, FloatNDArray, float)
 
 BSXFUN_STDOP_DECLS (FloatNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatNDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatComplexNDArray, 
                  FloatNDArray, OCTAVE_API)
 
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -29,27 +29,28 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatRowVector : public MArray<float>
 {
 public:
 
-  FloatRowVector (void) : MArray<float> () { }
+  FloatRowVector (void) : MArray<float> (1, 0) { }
 
-  explicit FloatRowVector (octave_idx_type n) : MArray<float> (n) { }
+  explicit FloatRowVector (octave_idx_type n) : MArray<float> (1, n) { }
 
-  explicit FloatRowVector (const dim_vector& dv) : MArray<float> (dv) { }
+  explicit FloatRowVector (const dim_vector& dv) : MArray<float> (dv.as_row ()) { }
 
-  FloatRowVector (octave_idx_type n, float val) : MArray<float> (n, val) { }
+  FloatRowVector (octave_idx_type n, float val) : MArray<float> (1, n, val) { }
 
   FloatRowVector (const FloatRowVector& a) : MArray<float> (a) { }
 
-  FloatRowVector (const MArray<float>& a) : MArray<float> (a) { }
+  FloatRowVector (const MArray<float>& a) : MArray<float> (a.as_row ()) { }
+  FloatRowVector (const Array<float>& a) : MArray<float> (a.as_row ()) { }
 
   FloatRowVector& operator = (const FloatRowVector& a)
     {
       MArray<float>::operator = (a);
       return *this;
     }
 
   bool operator == (const FloatRowVector& a) const;
@@ -84,19 +85,25 @@ public:
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
 
+  void resize (octave_idx_type n, const float& rfv = Array<float>::resize_fill_value ())
+    { Array<float>::resize (1, n, rfv); }
+
+  void clear (octave_idx_type n)
+    { Array<float>::clear (1, n); }
+
 private:
 
-  FloatRowVector (float *d, octave_idx_type l) : MArray<float> (d, l) { }
+  FloatRowVector (float *d, octave_idx_type l) : MArray<float> (d, 1, l) { }
 };
 
 // row vector by column vector -> scalar
 
 float OCTAVE_API operator * (const FloatRowVector& a, const FloatColumnVector& b);
 
 Complex OCTAVE_API operator * (const FloatRowVector& a, const ComplexColumnVector& b);
 
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -118,19 +118,19 @@ FloatCHOL::init (const FloatMatrix& a, b
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond) 
     {
       octave_idx_type spocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
-      Array<float> z (3*n);
+      Array<float> z (3*n, 1);
       float *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (n);
+      Array<octave_idx_type> iz (n, 1);
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, spocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (spocon_info != 0) 
         info = -1;
     }
@@ -411,17 +411,17 @@ FloatCHOL::shift_sym (octave_idx_type i,
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1) 
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatMatrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (n);
+      Array<octave_idx_type> p (n, 1);
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
           for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
           p(j) = i;
         }
       else if (j < i)
         {
diff --git a/liboctave/floatHESS.cc b/liboctave/floatHESS.cc
--- a/liboctave/floatHESS.cc
+++ b/liboctave/floatHESS.cc
@@ -75,27 +75,27 @@ FloatHESS::init (const FloatMatrix& a)
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   hess_mat = a;
   float *h = hess_mat.fortran_vec ();
 
-  Array<float> scale (n);
+  Array<float> scale (n, 1);
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (sgebal, SGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
                              n, h, n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
-  Array<float> tau (n-1);
+  Array<float> tau (n-1, 1);
   float *ptau = tau.fortran_vec ();
 
-  Array<float> work (lwork);
+  Array<float> work (lwork, 1);
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (sgehrd, SGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
                              lwork, info));
 
   unitary_hess_mat = hess_mat;
   float *z = unitary_hess_mat.fortran_vec ();
 
diff --git a/liboctave/floatLU.cc b/liboctave/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/floatLU.cc
@@ -64,17 +64,17 @@ extern "C"
 }
 
 FloatLU::FloatLU (const FloatMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
   octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
-  ipvt.resize (mn);
+  ipvt.resize (mn, 1);
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   float *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (sgetrf, SGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -60,17 +60,17 @@ FloatQRP::init (const FloatMatrix& a, qr
   OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
   octave_idx_type info = 0;
 
   FloatMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
-  MArray<octave_idx_type> jpvt (n, 0);
+  MArray<octave_idx_type> jpvt (n, 1, 0);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
       F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
                                  tau, &rlwork, -1, info));
 
diff --git a/liboctave/floatSCHUR.cc b/liboctave/floatSCHUR.cc
--- a/liboctave/floatSCHUR.cc
+++ b/liboctave/floatSCHUR.cc
@@ -106,30 +106,30 @@ FloatSCHUR::init (const FloatMatrix& a, 
   schur_mat = a;
 
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
   float *s = schur_mat.fortran_vec ();
   float *q = unitary_mat.fortran_vec ();
 
-  Array<float> wr (n);
+  Array<float> wr (n, 1);
   float *pwr = wr.fortran_vec ();
 
-  Array<float> wi (n);
+  Array<float> wi (n, 1);
   float *pwi = wi.fortran_vec ();
 
-  Array<float> work (lwork);
+  Array<float> work (lwork, 1);
   float *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for the non-ordered Schur routine.
-  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n, 1);
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
-  Array<octave_idx_type> iwork (liwork);
+  Array<octave_idx_type> iwork (liwork, 1);
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (sgeesx, SGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
                              n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
                              pwork, lwork, piwork, liwork, pbwork, info
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -130,30 +130,30 @@ FloatSVD::init (const FloatMatrix& a, SV
     right_sm.resize (nrow_vt, n);
 
   float *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
   octave_idx_type lwork = -1;
 
-  Array<float> work (1);
+  Array<float> work (1, 1);
 
   octave_idx_type one = 1;
   octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
 
   F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   lwork = static_cast<octave_idx_type> (work(0));
-  work.resize (lwork);
+  work.resize (lwork, 1);
 
   F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              m, n, tmp_data, m1, s_vec, u, m1, vt,
                              nrow_vt1, work.fortran_vec (), lwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -69,17 +69,17 @@ public:
   void set_pattern (const string_vector& p) { pat = p; }
 
   bool match (const std::string& str) const;
 
   Array<bool> match (const string_vector& str) const
   {
     int n = str.length ();
 
-    Array<bool> retval (n);
+    Array<bool> retval (n, 1);
 
     for (int i = 0; i < n; i++)
       retval(i) = match (str[i]);
 
     return retval;
   }
 
   // We forward to glob_internal here to avoid problems with gnulib's
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (int16NDArray, octave_i
 NDS_BOOL_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, int16NDArray, octave_int16)
+MARRAY_FORWARD_DEFS (MArray, int16NDArray, octave_int16)
 
 MINMAX_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int16NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (int32NDArray, octave_i
 NDS_BOOL_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, int32NDArray, octave_int32)
+MARRAY_FORWARD_DEFS (MArray, int32NDArray, octave_int32)
 
 MINMAX_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int32NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (int64NDArray, octave_i
 NDS_BOOL_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, int64NDArray, octave_int64)
+MARRAY_FORWARD_DEFS (MArray, int64NDArray, octave_int64)
 
 MINMAX_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int64NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (int8NDArray, octave_in
 NDS_BOOL_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, int8NDArray, octave_int8)
+MARRAY_FORWARD_DEFS (MArray, int8NDArray, octave_int8)
 
 MINMAX_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int8NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -61,17 +61,17 @@ intNDArray<T>::any_element_not_one_or_ze
 
   return false;
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type k) const
 {
-  return MArrayN<T>::diag (k);
+  return MArray<T>::diag (k);
 }
 
 // FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -18,62 +18,62 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_intNDArray_h)
 #define octave_intNDArray_h 1
 
-#include "MArrayN.h"
+#include "MArray.h"
 #include "boolNDArray.h"
 class NDArray;
 
 template <class T>
 class
-intNDArray : public MArrayN<T>
+intNDArray : public MArray<T>
 {
 public:
 
-  using MArrayN<T>::element_type;
+  using MArray<T>::element_type;
   
-  intNDArray (void) : MArrayN<T> () { }
+  intNDArray (void) : MArray<T> () { }
 
-  intNDArray (T val) : MArrayN<T> (dim_vector (1, 1), val) { }
+  intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
-  intNDArray (const dim_vector& dv) : MArrayN<T> (dv) { }
+  intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
   
   intNDArray (const dim_vector& dv, T val)
-    : MArrayN<T> (dv, val) { }
+    : MArray<T> (dv, val) { }
   
   template <class U>
-  explicit intNDArray (const Array<U>& a) : MArrayN<T> (a) { }
+  intNDArray (const Array<U>& a) : MArray<T> (a) { }
 
   template <class U>
-  intNDArray (const MArrayN<U>& a) : MArrayN<T> (a) { }
+  intNDArray (const MArray<U>& a) : MArray<T> (a) { }
 
   template <class U>
-  intNDArray (const intNDArray<U>& a) : MArrayN<T> (a) { }
+  intNDArray (const intNDArray<U>& a) : MArray<T> (a) { }
 
   intNDArray& operator = (const intNDArray<T>& a)
     {
-      MArrayN<T>::operator = (a);
+      MArray<T>::operator = (a);
       return *this;
     }
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_nan (void) const { return false; }
   bool any_element_not_one_or_zero (void) const;
 
   intNDArray diag (octave_idx_type k = 0) const;
 
   intNDArray& changesign (void) 
     { 
-      MArrayN<T>::changesign (); 
+      MArray<T>::changesign (); 
       return *this; 
     }
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
@@ -92,20 +92,20 @@ public:
   intNDArray cumsum (int dim) const;
 
   intNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   intNDArray abs (void) const;
   intNDArray signum (void) const;
 
   intNDArray squeeze (void) const
-    { return intNDArray<T> (MArrayN<T>::squeeze ()); }
+    { return intNDArray<T> (MArray<T>::squeeze ()); }
 
   intNDArray transpose (void) const
-    { return intNDArray<T> (MArrayN<T>::transpose ()); }
+    { return intNDArray<T> (MArray<T>::transpose ()); }
 
   intNDArray concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx);
 
   intNDArray& insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c);
   intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
@@ -113,17 +113,17 @@ public:
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   static T resize_fill_value (void) { return 0; }
 
 protected:
 
-  intNDArray (T *d, dim_vector& dv) : MArrayN<T> (d, dv) { }
+  intNDArray (T *d, dim_vector& dv) : MArray<T> (d, dv) { }
 };
 
 // i/o
 
 template <class T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
 template <class T>
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -758,17 +758,17 @@ convert_packcomplex_Nd (T *out, const di
 }
 
 int
 octave_fftw::fft (const double *in, Complex *out, size_t npts, 
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (1, dv, nsamples,
                                                      stride, dist, in, out);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
                          reinterpret_cast<fftw_complex *> (out));
 
   // Need to create other half of the transform.
 
@@ -778,17 +778,17 @@ octave_fftw::fft (const double *in, Comp
 }
 
 int
 octave_fftw::fft (const Complex *in, Complex *out, size_t npts, 
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
   fftw_execute_dft (plan, 
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
@@ -796,17 +796,17 @@ octave_fftw::fft (const Complex *in, Com
 }
 
 int
 octave_fftw::ifft (const Complex *in, Complex *out, size_t npts, 
                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
   fftw_execute_dft (plan, 
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
@@ -886,17 +886,17 @@ octave_fftw::ifftNd (const Complex *in, 
 }
 
 int
 octave_fftw::fft (const float *in, FloatComplex *out, size_t npts, 
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (1, dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
                         reinterpret_cast<fftwf_complex *> (out));
 
   // Need to create other half of the transform.
@@ -907,17 +907,17 @@ octave_fftw::fft (const float *in, Float
 }
 
 int
 octave_fftw::fft (const FloatComplex *in, FloatComplex *out, size_t npts, 
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft (plan, 
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
@@ -926,17 +926,17 @@ octave_fftw::fft (const FloatComplex *in
 }
 
 int
 octave_fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts, 
                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
-  dim_vector dv (npts);
+  dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft (plan, 
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -219,63 +219,63 @@ inline void vector_norm (const Array<T>&
   for (octave_idx_type i = 0; i < v.numel (); i++)
     acc.accum (v(i));
 
   res = acc;
 }
 
 // dense versions
 template <class T, class R, class ACC>
-void column_norms (const MArray2<T>& m, MArray<R>& res, ACC acc)
+void column_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray2<R> (1, m.columns ());
+  res = MArray<R> (1, m.columns ());
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type i = 0; i < m.rows (); i++)
         accj.accum (m(i, j));
 
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
-void row_norms (const MArray2<T>& m, MArray<R>& res, ACC acc)
+void row_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray2<R> (m.rows (), 1);
+  res = MArray<R> (m.rows (), 1);
   std::vector<ACC> acci (m.rows (), acc); 
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type i = 0; i < m.rows (); i++)
         acci[i].accum (m(i, j));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
 }
 
 // sparse versions
 template <class T, class R, class ACC>
 void column_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray2<R> (1, m.columns ());
+  res = MArray<R> (1, m.columns ());
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         accj.accum (m.data (k));
 
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
 void row_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
-  res = MArray2<R> (m.rows (), 1);
+  res = MArray<R> (m.rows (), 1);
   std::vector<ACC> acci (m.rows (), acc); 
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         acci[m.ridx (k)].accum (m.data (k));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
@@ -304,19 +304,18 @@ RES_TYPE FUNC_NAME (const ARG_TYPE& v, R
   else if (p > 0) \
     FUNC_NAME (v, res, norm_accumulator_p<R> (p)); \
   else \
     FUNC_NAME (v, res, norm_accumulator_mp<R> (p)); \
   return res; \
 }
 
 DEFINE_DISPATCHER (vector_norm, MArray<T>, R)
-DEFINE_DISPATCHER (vector_norm, MArray2<T>, R)
-DEFINE_DISPATCHER (column_norms, MArray2<T>, MArray<R>)
-DEFINE_DISPATCHER (row_norms, MArray2<T>, MArray<R>)
+DEFINE_DISPATCHER (column_norms, MArray<T>, MArray<R>)
+DEFINE_DISPATCHER (row_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (column_norms, MSparse<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MSparse<T>, MArray<R>)
 
 // The approximate subproblem in Higham's method. Find lambda and mu such that
 // norm ([lambda, mu], p) == 1 and norm (y*lambda + col*mu, p) is maximized.
 // Real version. As in Higham's paper.
 template <class ColVectorT, class R>
 static void 
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -420,17 +420,17 @@ octave_rand::do_nd_array (const dim_vect
 
 Array<double>
 octave_rand::do_vector (octave_idx_type n, double a)
 {
   Array<double> retval;
 
   if (n > 0)
     {
-      retval.clear (n);
+      retval.clear (n, 1);
 
       fill (retval.capacity (), retval.fortran_vec (), a);
     }
   else if (n < 0)
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
diff --git a/liboctave/regex-match.cc b/liboctave/regex-match.cc
--- a/liboctave/regex-match.cc
+++ b/liboctave/regex-match.cc
@@ -135,15 +135,15 @@ regex_match::match (const std::string& s
   return false;
 }
 
 Array<bool>
 regex_match::match (const string_vector& s)
 {
   int n = s.length ();
 
-  Array<bool> retval (n);
+  Array<bool> retval (n, 1);
 
   for (int i = 0; i < n; i++)
     retval(i) = match (s[i]);
 
   return retval;
 }
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <vector>
 
-#include "MArray2.h"
+#include "MArray.h"
 #include "MSparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
 template <class T>
@@ -111,56 +111,56 @@ static MSparse<Complex>
 dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv, 
                 const octave_idx_type *Q, octave_idx_type rst, 
                 octave_idx_type rend, octave_idx_type cst, 
                 octave_idx_type cend, octave_idx_type maxnz,
                 bool lazy);
 #endif
 
 template <class T>
-static MArray2<T>
-dmsolve_extract (const MArray2<T> &m, const octave_idx_type *, 
+static MArray<T>
+dmsolve_extract (const MArray<T> &m, const octave_idx_type *, 
                  const octave_idx_type *, octave_idx_type r1, 
                  octave_idx_type r2, octave_idx_type c1, 
                  octave_idx_type c2)
 {
   r2 -= 1;
   c2 -= 1;
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
-  MArray2<T> result (new_r, new_c);
+  MArray<T> result (new_r, new_c);
 
   for (octave_idx_type j = 0; j < new_c; j++)
     for (octave_idx_type i = 0; i < new_r; i++)
       result.xelem (i, j) = m.elem (r1+i, c1+j);
 
   return result;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-static MArray2<double>
-dmsolve_extract (const MArray2<double> &m, const octave_idx_type *, 
+static MArray<double>
+dmsolve_extract (const MArray<double> &m, const octave_idx_type *, 
                  const octave_idx_type *, octave_idx_type r1, 
                  octave_idx_type r2, octave_idx_type c1, 
                  octave_idx_type c2)
 
-static MArray2<Complex>
-dmsolve_extract (const MArray2<Complex> &m, const octave_idx_type *, 
+static MArray<Complex>
+dmsolve_extract (const MArray<Complex> &m, const octave_idx_type *, 
                  const octave_idx_type *, octave_idx_type r1, 
                  octave_idx_type r2, octave_idx_type c1, 
                  octave_idx_type c2)
 #endif
 
 template <class T>
 static void
-dmsolve_insert (MArray2<T> &a, const MArray2<T> &b, const octave_idx_type *Q,
+dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                octave_idx_type r, octave_idx_type c)
 {
   T *ax = a.fortran_vec();
   const T *bx = b.fortran_vec();
   octave_idx_type anr = a.rows();
   octave_idx_type nr = b.rows();
   octave_idx_type nc = b.cols();
   for (octave_idx_type j = 0; j < nc; j++)
@@ -172,21 +172,21 @@ dmsolve_insert (MArray2<T> &a, const MAr
           octave_quit ();
           ax [Q [r + i] + aoff] = bx [i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
-dmsolve_insert (MArray2<double> &a, const MArray2<double> &b, 
+dmsolve_insert (MArray<double> &a, const MArray<double> &b, 
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
-dmsolve_insert (MArray2<Complex> &a, const MArray2<Complex> &b,
+dmsolve_insert (MArray<Complex> &a, const MArray<Complex> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MSparse<T> &a, const MSparse<T> &b, const octave_idx_type *Q,
                octave_idx_type r, octave_idx_type c)
 {
@@ -269,17 +269,17 @@ dmsolve_insert (MSparse<double> &a, cons
 
 static void
 dmsolve_insert (MSparse<Complex> &a, const MSparse<Complex> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T, class RT>
 static void
-dmsolve_permute (MArray2<RT> &a, const MArray2<T>& b, const octave_idx_type *p)
+dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   const T *Bx = b.fortran_vec();
   a.resize(b_nr, b_nc);
   RT *Btx = a.fortran_vec();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
@@ -289,25 +289,25 @@ dmsolve_permute (MArray2<RT> &a, const M
           octave_quit ();
           Btx [p [i] + off] = Bx [ i + off];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
-dmsolve_permute (MArray2<double> &a, const MArray2<double>& b,
+dmsolve_permute (MArray<double> &a, const MArray<double>& b,
                  const octave_idx_type *p);
 
 static void
-dmsolve_permute (MArray2<Complex> &a, const MArray2<double>& b,
+dmsolve_permute (MArray<Complex> &a, const MArray<double>& b,
                  const octave_idx_type *p);
 
 static void
-dmsolve_permute (MArray2<Complex> &a, const MArray2<Complex>& b,
+dmsolve_permute (MArray<Complex> &a, const MArray<Complex>& b,
                  const octave_idx_type *p);
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -90,17 +90,17 @@ string_vector::string_vector (const char
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 // Create a string vector from up to N C strings.  Assumes that N is
 // nonnegative.
 
 string_vector::string_vector (const char * const *s, octave_idx_type n)
-  : Array<std::string> (n)
+  : Array<std::string> (1, n)
 {
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 string_vector&
 string_vector::sort (bool make_uniq)
 {
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -34,21 +34,21 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 string_vector : public Array<std::string>
 {
 public:
 
   string_vector (void) : Array<std::string> () { }
 
-  explicit string_vector (octave_idx_type n) : Array<std::string> (n) { }
+  explicit string_vector (octave_idx_type n) : Array<std::string> (1, n) { }
 
-  string_vector (const char *s) : Array<std::string> (1, s) { }
+  string_vector (const char *s) : Array<std::string> (1, 1, s) { }
 
-  string_vector (const std::string& s) : Array<std::string> (1, s) { }
+  string_vector (const std::string& s) : Array<std::string> (1, 1, s) { }
 
   string_vector (const string_vector& s) : Array<std::string> (s) { }
 
   string_vector (const std::list<std::string>& lst);
 
   string_vector (const std::set<std::string>& lst);
 
   string_vector (const char * const *s);
@@ -78,16 +78,19 @@ public:
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
+  void resize (octave_idx_type n, const std::string& rfv = resize_fill_value ())
+    { Array<std::string>::resize (1, n, rfv); }
+
   std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
 
   string_vector& sort (bool make_uniq = false);
 
   string_vector& uniq (void);
 
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (uint16NDArray, octave_
 NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, uint16NDArray, octave_uint16)
+MARRAY_FORWARD_DEFS (MArray, uint16NDArray, octave_uint16)
 
 MINMAX_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint16NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (uint32NDArray, octave_
 NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, uint32NDArray, octave_uint32)
+MARRAY_FORWARD_DEFS (MArray, uint32NDArray, octave_uint32)
 
 MINMAX_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint32NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (uint64NDArray, octave_
 NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, uint64NDArray, octave_uint64)
+MARRAY_FORWARD_DEFS (MArray, uint64NDArray, octave_uint64)
 
 MINMAX_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint64NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -34,16 +34,16 @@ NDS_CMP_OP_DECLS (uint8NDArray, octave_u
 NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 
-MARRAY_FORWARD_DEFS (MArrayN, uint8NDArray, octave_uint8)
+MARRAY_FORWARD_DEFS (MArray, uint8NDArray, octave_uint8)
 
 MINMAX_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint8NDArray, OCTAVE_API)
 
 #endif
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -170,17 +170,17 @@ Cell::index (const octave_value_list& id
               retval = Array<octave_value>::index (i, j, resize_ok,
                                                     resize_fill_value ());
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> iv (n);
+        Array<idx_vector> iv (n, 1);
 
         for (octave_idx_type i = 0; i < n; i++)
           {
             iv(i) = idx_arg(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -197,33 +197,33 @@ Cell::index (const octave_value_list& id
 
 Cell&
 Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
               const octave_value& fill_val)
 
 {
   octave_idx_type len = idx_arg.length ();
 
-  Array<idx_vector> ra_idx (len);
+  Array<idx_vector> ra_idx (len, 1);
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx_arg(i).index_vector ();
 
   Array<octave_value>::assign (ra_idx, rhs, fill_val);
 
   return *this;
 }
 
 Cell&
 Cell::delete_elements (const octave_value_list& idx_arg)
 
 {
   octave_idx_type len = idx_arg.length ();
 
-  Array<idx_vector> ra_idx (len);
+  Array<idx_vector> ra_idx (len, 1);
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx.xelem (i) = idx_arg(i).index_vector ();
 
   Array<octave_value>::delete_elements (ra_idx);
 
   return *this;
 }
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,44 @@
+2010-02-23  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Cell.cc: Reflect Array API changes.
+	* DLD-FUNCTIONS/__convn__.cc: Ditto.
+	* DLD-FUNCTIONS/__glpk__.cc: Ditto.
+	* DLD-FUNCTIONS/__magick_read__.cc: Ditto.
+	* DLD-FUNCTIONS/bsxfun.cc: Ditto.
+	* DLD-FUNCTIONS/cellfun.cc: Ditto.
+	* DLD-FUNCTIONS/conv2.cc: Ditto.
+	* DLD-FUNCTIONS/dlmread.cc: Ditto.
+	* DLD-FUNCTIONS/filter.cc: Ditto.
+	* DLD-FUNCTIONS/kron.cc: Ditto.
+	* DLD-FUNCTIONS/qz.cc: Ditto.
+	* DLD-FUNCTIONS/regexp.cc: Ditto.
+	* DLD-FUNCTIONS/sub2ind.cc: Ditto.
+	* data.cc: Ditto.
+	* file-io.cc: Ditto.
+	* gl-render.cc: Ditto.
+	* ls-mat5.cc: Ditto.
+	* oct-map.cc: Ditto.
+	* oct-obj.h: Ditto.
+	* oct-parse.yy: Ditto.
+	* oct-stream.cc: Ditto.
+	* ov-base-mat.cc: Ditto.
+	* ov-base-sparse.cc: Ditto.
+	* ov-perm.cc: Ditto.
+	* ov-struct.cc: Ditto.
+	* ov-typeinfo.cc: Ditto.
+	* ov-typeinfo.h: Ditto.
+	* ov.cc: Ditto.
+	* pr-output.cc: Ditto.
+	* pt-mat.cc: Ditto.
+	* strfns.cc: Ditto.
+	* txt-eng-ft.cc: Ditto.
+	* variables.cc: Ditto.
+
 2010-02-22  John W. Eaton  <jwe@octave.org>
 
 	* ls-mat5.cc: Use numel instead of nelem consistently and where
 	appropriate in all functions.
 	(read_mat5_binary_element): Declare ridx and cidx as pointer to
 	octave_idx_type, not int.
 	(read_mat5_integer_data): Declare count as octave_idx_type, not int.
 	(READ_INTEGER_DATA): Loop counter is octave_idx_type, not int.
diff --git a/src/DLD-FUNCTIONS/__convn__.cc b/src/DLD-FUNCTIONS/__convn__.cc
--- a/src/DLD-FUNCTIONS/__convn__.cc
+++ b/src/DLD-FUNCTIONS/__convn__.cc
@@ -86,17 +86,17 @@ convn (const MTa& a, const MTb& b)
 
   typedef typename octave_convn_traits<MTa, MTb>::TR MTout;
 
   MTout out (out_size);
 
   const octave_idx_type out_numel = out.numel ();
   
   // Iterate over every element of 'out'.
-  dim_vector idx_dim (ndims);
+  dim_vector idx_dim (ndims, 1);
 
   Array<octave_idx_type> a_idx (idx_dim);
   Array<octave_idx_type> b_idx (idx_dim);
   Array<octave_idx_type> out_idx (idx_dim, 0);
 
   for (octave_idx_type i = 0; i < out_numel; i++)
     {
       OCTAVE_QUIT;
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -515,18 +515,18 @@ Undocumented internal function.\n\
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nzmax ();
-      rn.resize (Anz+1);
-      cn.resize (Anz+1);
+      rn.resize (Anz+1, 1);
+      cn.resize (Anz+1, 1);
       a.resize (Anz+1, 0.0);
 
       if (Anc != mrowsc)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
@@ -545,18 +545,18 @@ Undocumented internal function.\n\
 
       if (error_state)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       mrowsA = A.rows ();
-      rn.resize (mrowsA*mrowsc+1);
-      cn.resize (mrowsA*mrowsc+1);
+      rn.resize (mrowsA*mrowsc+1, 1);
+      cn.resize (mrowsA*mrowsc+1, 1);
       a.resize (mrowsA*mrowsc+1, 0.0);
 
       for (int i = 0; i < mrowsA; i++)
         {
           for (int j = 0; j < mrowsc; j++)
             {
               if (A(i,j) != 0)
                 {
@@ -590,17 +590,17 @@ Undocumented internal function.\n\
     {
       error ("__glpk__: invalid value of lb");
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
-  Array<int> freeLB (mrowsc);
+  Array<int> freeLB (mrowsc, 1);
   for (int i = 0; i < mrowsc; i++)
      {
        if (xisinf (lb[i]))
          {
            freeLB(i) = 1;
            lb[i] = -octave_Inf;
          }
        else
@@ -614,17 +614,17 @@ Undocumented internal function.\n\
   if (error_state || UB.length () < mrowsc)
     {
       error ("__glpk__: invalid value of ub");
       return retval;
     }
 
   double *ub = UB.fortran_vec ();
 
-  Array<int> freeUB (mrowsc);
+  Array<int> freeUB (mrowsc, 1);
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (ub[i]))
         {
           freeUB(i) = 1;
           ub[i] = octave_Inf;
         }
       else
@@ -647,17 +647,17 @@ Undocumented internal function.\n\
   charMatrix VTYPE (args(6).char_matrix_value ());
 
   if (error_state)
     {
       error ("__glpk__: invalid value of vtype");
       return retval;
     }
 
-  Array<int> vartype (mrowsc);
+  Array<int> vartype (mrowsc, 1);
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
           vartype(i) = LPX_IV;
         }
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -51,17 +51,17 @@ read_indexed_images (std::vector<Magick:
 
   dim_vector idim = dim_vector ();
   idim.resize (4);
   idim(0) = rows;
   idim(1) = columns;
   idim(2) = 1;
   idim(3) = nframes;
 
-  Array<int> idx (dim_vector (4));
+  Array<int> idx (dim_vector (4, 1));
 
   Magick::ImageType type = imvec[0].type ();
 
   unsigned int mapsize = imvec[0].colorMapSize ();
   unsigned int i = mapsize;
   unsigned int depth = 0;
   while (i >>= 1)
     depth++;
@@ -391,17 +391,17 @@ Instead you should use @code{imread}.\n\
     }
 
   Array<int> frameidx;
 
   if (args.length () == 2 && args(1).is_real_type ())
     frameidx = args(1).int_vector_value();
   else
     {
-      frameidx = Array<int> (1);
+      frameidx = Array<int> (1, 1);
       frameidx(0) = 1;
     }
 
   std::vector<Magick::Image> imvec;
 
   try
     {
       // Read a file into vector of image objects
@@ -529,17 +529,17 @@ encode_bool_image (std::vector<Magick::I
 {
   unsigned int nframes = 1;
   boolNDArray m = img.bool_array_value ();
 
   dim_vector dsizes = m.dims ();
   if (dsizes.length () == 4)
     nframes = dsizes(3);
 
-  Array<octave_idx_type> idx (dsizes.length ());
+  Array<octave_idx_type> idx (dsizes.length (), 1);
 
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
       Magick::Image im(Magick::Geometry (columns, rows), "black");
       im.classType (Magick::DirectClass);
@@ -588,17 +588,17 @@ encode_uint_image (std::vector<Magick::I
 
   dim_vector dsizes = m.dims ();
   unsigned int nframes = 1;
   if (dsizes.length () == 4)
     nframes = dsizes(3);
   bool is_color = ((dsizes.length () > 2) && (dsizes(2) > 2));
   bool has_alpha = (dsizes.length () > 2 && (dsizes(2) == 2 || dsizes(2) == 4));
 
-  Array<octave_idx_type> idx (dsizes.length ());
+  Array<octave_idx_type> idx (dsizes.length (), 1);
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   // FIXME -- maybe simply using bit shifting would be better?
   unsigned int div_factor = pow (2.0, static_cast<int> (bitdepth)) - 1;
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -434,17 +434,17 @@ dimensionality as the other matrix.\n\
                   BSXDEF(uint64NDArray);
 
                   octave_value Ac ;
                   octave_value_list idxA;
                   octave_value Bc;
                   octave_value_list idxB;
                   octave_value C;
                   octave_value_list inputs;
-                  Array<int> ra_idx (dvc.length(), 0);
+                  Array<int> ra_idx (dvc.length(), 1, 0);
 
 
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1025,17 +1025,17 @@ do_num2cell_helper (const dim_vector& dv
   for (int i = 0; i < dvl; i++)
     maxd = std::max (maxd, dimv(i));
   if (maxd > dv.length ())
     celldv.resize (maxd, 1);
   arraydv = celldv;
 
   OCTAVE_LOCAL_BUFFER_INIT (bool, sing, maxd, false);
 
-  perm.clear (maxd);
+  perm.clear (maxd, 1);
   for (int i = 0; i < dvl; i++)
     {
       int k = dimv(i) - 1;
       if (k < 0)
         {
           error ("num2cell: dimension indices must be positive");
           return;
         }
@@ -1470,17 +1470,17 @@ do_cellslices_nda (const NDA& array,
   else
     {
       const dim_vector dv = array.dims ();
       int ndims = dv.length ();
       if (dim < 0)
         dim = dv.first_non_singleton ();
       ndims = std::max (ndims, dim + 1);
 
-      Array<idx_vector> idx (ndims, idx_vector::colon);
+      Array<idx_vector> idx (ndims, 1, idx_vector::colon);
 
       for (octave_idx_type i = 0; i < n && ! error_state; i++)
         {
           idx(dim) = idx_vector (lb(i) - 1, ub(i));
           retval(i) = array.index (idx);
         }
     }
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -30,32 +30,32 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "utils.h"
 
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-extern MArray2<double>
-conv2 (MArray<double>&, MArray<double>&, MArray2<double>&, Shape);
+extern MArray<double>
+conv2 (MArray<double>&, MArray<double>&, MArray<double>&, Shape);
 
-extern MArray2<Complex>
-conv2 (MArray<Complex>&, MArray<Complex>&, MArray2<Complex>&, Shape);
+extern MArray<Complex>
+conv2 (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&, Shape);
 
-extern MArray2<float>
-conv2 (MArray<float>&, MArray<float>&, MArray2<float>&, Shape);
+extern MArray<float>
+conv2 (MArray<float>&, MArray<float>&, MArray<float>&, Shape);
 
-extern MArray2<FloatComplex>
-conv2 (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray2<FloatComplex>&, Shape);
+extern MArray<FloatComplex>
+conv2 (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, Shape);
 #endif
 
 template <class T>
-MArray2<T>
-conv2 (MArray<T>& R, MArray<T>& C, MArray2<T>& A, Shape ishape)
+MArray<T>
+conv2 (MArray<T>& R, MArray<T>& C, MArray<T>& A, Shape ishape)
 {
   octave_idx_type  Rn =  R.length ();
   octave_idx_type  Cm =  C.length ();
   octave_idx_type  Am = A.rows ();
   octave_idx_type  An = A.columns ();
 
   // Calculate the size of the output matrix:
   // in order to stay Matlab compatible, it is based
@@ -93,24 +93,24 @@ conv2 (MArray<T>& R, MArray<T>& C, MArra
           outN = 0;
         edgM = edgN = 0;
         break;
 
       default:
         error ("conv2: invalid value of parameter ishape");
     }
 
-  MArray2<T> O (outM, outN);
+  MArray<T> O (outM, outN);
 
   // X accumulates the 1-D conv for each row, before calculating
   //    the convolution in the other direction
   // There is no efficiency advantage to doing it in either direction
   //     first
 
-  MArray<T> X (An);
+  MArray<T> X (An, 1);
 
   for (octave_idx_type oi = 0; oi < outM; oi++)
     {
       for (octave_idx_type oj = 0; oj < An; oj++)
         {
           T sum = 0;
 
           octave_idx_type ci = Cm - 1 - MAX(0, edgM-oi);
@@ -138,32 +138,32 @@ conv2 (MArray<T>& R, MArray<T>& C, MArra
           O(oi,oj)=  sum;
         }
     }
 
   return O;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-extern MArray2<double>
-conv2 (MArray2<double>&, MArray2<double>&, Shape);
+extern MArray<double>
+conv2 (MArray<double>&, MArray<double>&, Shape);
 
-extern MArray2<Complex>
-conv2 (MArray2<Complex>&, MArray2<Complex>&, Shape);
+extern MArray<Complex>
+conv2 (MArray<Complex>&, MArray<Complex>&, Shape);
 
-extern MArray2<float>
-conv2 (MArray2<float>&, MArray2<float>&, Shape);
+extern MArray<float>
+conv2 (MArray<float>&, MArray<float>&, Shape);
 
-extern MArray2<FloatComplex>
-conv2 (MArray2<FloatComplex>&, MArray2<FloatComplex>&, Shape);
+extern MArray<FloatComplex>
+conv2 (MArray<FloatComplex>&, MArray<FloatComplex>&, Shape);
 #endif
 
 template <class T>
-MArray2<T>
-conv2 (MArray2<T>&A, MArray2<T>&B, Shape ishape)
+MArray<T>
+conv2 (MArray<T>&A, MArray<T>&B, Shape ishape)
 {
   // Convolution works fastest if we choose the A matrix to be
   // the largest.
 
   // Here we calculate the size of the output matrix,
   // in order to stay Matlab compatible, it is based
   // on the third parameter if it's separable, and the
   // first if it's not
@@ -203,17 +203,17 @@ conv2 (MArray2<T>&A, MArray2<T>&B, Shape
         if (outM < 0)
           outM = 0;
         if (outN < 0)
           outN = 0;
         edgM = edgN = 0;
         break;
     }
 
-  MArray2<T> O (outM, outN);
+  MArray<T> O (outM, outN);
 
   for (octave_idx_type oi = 0; oi < outM; oi++)
     {
       for (octave_idx_type oj = 0; oj < outN; oj++)
         {
           T sum = 0;
 
           for (octave_idx_type bj = Bn - 1 - MAX (0, edgN-oj), aj= MAX (0, oj-edgN);
@@ -413,19 +413,19 @@ in the column direction and by vector @v
              }
          }
 
      } // if (separable)
 
    return retval;
 }
 
-template MArray2<double>
-conv2 (MArray<double>&, MArray<double>&, MArray2<double>&, Shape);
+template MArray<double>
+conv2 (MArray<double>&, MArray<double>&, MArray<double>&, Shape);
 
-template MArray2<double>
-conv2 (MArray2<double>&, MArray2<double>&, Shape);
+template MArray<double>
+conv2 (MArray<double>&, MArray<double>&, Shape);
 
-template MArray2<Complex>
-conv2 (MArray<Complex>&, MArray<Complex>&, MArray2<Complex>&, Shape);
+template MArray<Complex>
+conv2 (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&, Shape);
 
-template MArray2<Complex>
-conv2 (MArray2<Complex>&, MArray2<Complex>&, Shape);
+template MArray<Complex>
+conv2 (MArray<Complex>&, MArray<Complex>&, Shape);
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -299,19 +299,19 @@ a spreadsheet style range such as 'A2..Q
                 pos2 = line.find_first_not_of (sep, pos2) - 1;
 
               c = (c > j + 1 ? c : j + 1);
               if (r > rmax || c > cmax)
                 { 
                   // Use resize_and_fill for the case of not-equal
                   // length rows.
                   if (iscmplx)
-                    cdata.resize_fill (r, c, 0);
+                    cdata.resize (r, c, 0);
                   else
-                    rdata.resize_fill (r, c, 0);
+                    rdata.resize (r, c, 0);
                   rmax = r;
                   cmax = c;
                 }
 
               std::istringstream tmp_stream (str);
               double x = octave_read_double (tmp_stream);
               if (tmp_stream)
                 {
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -35,44 +35,44 @@ along with Octave; see the file COPYING.
 
 #include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-extern MArrayN<double>
-filter (MArray<double>&, MArray<double>&, MArrayN<double>&, int dim);
+extern MArray<double>
+filter (MArray<double>&, MArray<double>&, MArray<double>&, int dim);
 
-extern MArrayN<Complex>
-filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&, int dim);
+extern MArray<Complex>
+filter (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&, int dim);
 
-extern MArrayN<float>
-filter (MArray<float>&, MArray<float>&, MArrayN<float>&, int dim);
+extern MArray<float>
+filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
-extern MArrayN<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&, int dim);
+extern MArray<FloatComplex>
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
 #endif
 
 template <class T>
-MArrayN<T>
-filter (MArray<T>& b, MArray<T>& a, MArrayN<T>& x, MArrayN<T>& si, 
+MArray<T>
+filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si, 
         int dim = 0)
 {
-  MArrayN<T> y;
+  MArray<T> y;
 
   octave_idx_type a_len  = a.length ();
   octave_idx_type b_len  = b.length ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
-  b.resize (ab_len, 0.0);
+  b.resize (ab_len, 1, 0.0);
   if (a_len > 1)
-    a.resize (ab_len, 0.0);
+    a.resize (ab_len, 1, 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T>(0.0))
     {
       error ("filter: the first element of a must be non-zero");
       return y;
     }
@@ -222,36 +222,36 @@ filter (MArray<T>& b, MArray<T>& a, MArr
             }
         }
     }
   
   return y;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-extern MArrayN<double>
-filter (MArray<double>&, MArray<double>&, MArrayN<double>&,
-        MArrayN<double>&, int dim);
+extern MArray<double>
+filter (MArray<double>&, MArray<double>&, MArray<double>&,
+        MArray<double>&, int dim);
 
-extern MArrayN<Complex>
-filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&,
-        MArrayN<Complex>&, int dim);
+extern MArray<Complex>
+filter (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&,
+        MArray<Complex>&, int dim);
 
-extern MArrayN<float>
-filter (MArray<float>&, MArray<float>&, MArrayN<float>&,
-        MArrayN<float>&, int dim);
+extern MArray<float>
+filter (MArray<float>&, MArray<float>&, MArray<float>&,
+        MArray<float>&, int dim);
 
-extern MArrayN<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&,
-        MArrayN<FloatComplex>&, int dim);
+extern MArray<FloatComplex>
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
+        MArray<FloatComplex>&, int dim);
 #endif
 
 template <class T>
-MArrayN<T>
-filter (MArray<T>& b, MArray<T>& a, MArrayN<T>& x, int dim = -1)
+MArray<T>
+filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, int dim = -1)
 {
   dim_vector x_dims = x.dims();
 
   if (dim < 0)
     {
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
@@ -259,29 +259,29 @@ filter (MArray<T>& b, MArray<T>& a, MArr
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
   else
     if (dim < 0 || dim > x_dims.length ())
       {
         error ("filter: filtering over invalid dimension");
-        return MArrayN<T> ();
+        return MArray<T> ();
       }
 
   octave_idx_type a_len = a.length ();
   octave_idx_type b_len = b.length ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
   
-  MArrayN<T> si (si_dims, T (0.0));
+  MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
 DEFUN_DLD (filter, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
@@ -649,43 +649,43 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
           else
             error (errmsg);
         }
     }
 
   return retval;
 }
 
-template MArrayN<double>
-filter (MArray<double>&, MArray<double>&, MArrayN<double>&,
-        MArrayN<double>&, int dim);
+template MArray<double>
+filter (MArray<double>&, MArray<double>&, MArray<double>&,
+        MArray<double>&, int dim);
 
-template MArrayN<double>
-filter (MArray<double>&, MArray<double>&, MArrayN<double>&, int dim);
+template MArray<double>
+filter (MArray<double>&, MArray<double>&, MArray<double>&, int dim);
 
-template MArrayN<Complex>
-filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&,
-        MArrayN<Complex>&, int dim);
+template MArray<Complex>
+filter (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&,
+        MArray<Complex>&, int dim);
 
-template MArrayN<Complex>
-filter (MArray<Complex>&, MArray<Complex>&, MArrayN<Complex>&, int dim);
+template MArray<Complex>
+filter (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&, int dim);
 
-template MArrayN<float>
-filter (MArray<float>&, MArray<float>&, MArrayN<float>&,
-        MArrayN<float>&, int dim);
+template MArray<float>
+filter (MArray<float>&, MArray<float>&, MArray<float>&,
+        MArray<float>&, int dim);
 
-template MArrayN<float>
-filter (MArray<float>&, MArray<float>&, MArrayN<float>&, int dim);
+template MArray<float>
+filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
-template MArrayN<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&,
-        MArrayN<FloatComplex>&, int dim);
+template MArray<FloatComplex>
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
+        MArray<FloatComplex>&, int dim);
 
-template MArrayN<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArrayN<FloatComplex>&, int dim);
+template MArray<FloatComplex>
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
 
 /*
 %!shared a, b, x, r
 %!test
 %!  a = [1 1];
 %!  b = [1 1];
 %!  x = zeros(1,10); x(1) = 1;
 %!  assert(all(filter(b,   [1], x  ) == [1 1 0 0 0 0 0 0 0 0]  ))
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -31,32 +31,32 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern void
-kron (const Array2<double>&, const Array2<double>&, Array2<double>&);
+kron (const Array<double>&, const Array<double>&, Array<double>&);
 
 extern void
-kron (const Array2<Complex>&, const Array2<Complex>&, Array2<Complex>&);
+kron (const Array<Complex>&, const Array<Complex>&, Array<Complex>&);
 
 extern void
-kron (const Array2<float>&, const Array2<float>&, Array2<float>&);
+kron (const Array<float>&, const Array<float>&, Array<float>&);
 
 extern void
-kron (const Array2<FlaotComplex>&, const Array2<FloatComplex>&, 
-      Array2<FloatComplex>&);
+kron (const Array<FlaotComplex>&, const Array<FloatComplex>&, 
+      Array<FloatComplex>&);
 #endif
 
 template <class T>
 void
-kron (const Array2<T>& A, const Array2<T>& B, Array2<T>& C)
+kron (const Array<T>& A, const Array<T>& B, Array<T>& C)
 {
   C.resize (A.rows () * B.rows (), A.columns () * B.columns ());
 
   octave_idx_type Ac, Ar, Cc, Cr;
 
   for (Ac = Cc = 0; Ac < A.columns (); Ac++, Cc += B.columns ())
     for (Ar = Cr = 0; Ar < A.rows (); Ar++, Cr += B.rows ())
       {
@@ -66,27 +66,27 @@ kron (const Array2<T>& A, const Array2<T
             {
               OCTAVE_QUIT;
               C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
             }
       }
 }
 
 template void
-kron (const Array2<double>&, const Array2<double>&, Array2<double>&);
+kron (const Array<double>&, const Array<double>&, Array<double>&);
 
 template void
-kron (const Array2<Complex>&, const Array2<Complex>&, Array2<Complex>&);
+kron (const Array<Complex>&, const Array<Complex>&, Array<Complex>&);
 
 template void
-kron (const Array2<float>&, const Array2<float>&, Array2<float>&);
+kron (const Array<float>&, const Array<float>&, Array<float>&);
 
 template void
-kron (const Array2<FloatComplex>&, const Array2<FloatComplex>&, 
-      Array2<FloatComplex>&);
+kron (const Array<FloatComplex>&, const Array<FloatComplex>&, 
+      Array<FloatComplex>&);
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern void
 kron (const Sparse<double>&, const Sparse<double>&, Sparse<double>&);
 
 extern void
 kron (const Sparse<Complex>&, const Sparse<Complex>&, Sparse<Complex>&);
 #endif
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -857,17 +857,17 @@ Order of output arguments was selected f
           octave_print_internal (std::cout, (Matrix) alphar, 0);
           std::cout << std::endl << "alphai = " << std::endl;
           octave_print_internal (std::cout, (Matrix) alphai, 0);
           std::cout << std::endl << "beta = " << std::endl;
           octave_print_internal (std::cout, (Matrix) betar, 0);
           std::cout << std::endl;
 #endif
 
-          Array<octave_idx_type> ind (nn);
+          Array<octave_idx_type> ind (nn, 1);
 
           F77_XFCN (dsubsp, DSUBSP,
                     (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
                      ZZ.fortran_vec (), sort_test, eps, ndim, fail,
                      ind.fortran_vec ()));
 
 #ifdef DEBUG
           std::cout << "qz: back from dsubsp: aa=" << std::endl;
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -232,24 +232,24 @@ octregexp_list (const octave_value_list 
 
               std::string tmp_name = 
                 pattern.substr(new_pos+3,tmp_pos-new_pos-3);
               bool found = false;
 
               for (int i = 0; i < nnames; i++)
                 if (named(i) == tmp_name)
                   {
-                    named_idx.resize(inames+1);
+                    named_idx.resize(inames+1, 1);
                     named_idx(inames) = i;
                     found = true;
                     break;
                   }
               if (! found)
                 {
-                  named_idx.resize(inames+1);
+                  named_idx.resize(inames+1, 1);
                   named_idx(inames) = nnames;
                   named.append(tmp_name);
                   nnames++;
                 }
 
               if (new_pos - pos > 0)
                 buf << pattern.substr(pos,new_pos-pos);
               if (inames < 10)
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -84,17 +84,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       dim_vector dv = get_dim_vector (args(0), "sub2ind");
-      Array<idx_vector> idxa (nargin - 1);
+      Array<idx_vector> idxa (nargin - 1, 1);
 
       if (! error_state)
         {
           dv = dv.redim (nargin - 1);
           for (int j = 0; j < nargin - 1; j++)
             {
               if (args(j+1).is_numeric_type ())
                 {
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1887,17 +1887,17 @@ omitted, it defaults to the first non-si
 %!assert (prod (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
 
  */
 
 #define SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
   do \
     { \
       int dv_len = dv.length (); \
-      Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0); \
+      Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 1, 0); \
       \
       for (int j = 1; j < n_args; j++) \
         { \
           octave_quit (); \
           \
           TYPE ra = args(j).EXTRACTOR ();       \
           \
           if (! error_state) \
@@ -2068,17 +2068,17 @@ do_cat (const octave_value_list& args, s
 
               octave_value tmp = args (1);
               tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
               if (error_state)
                 return retval;
 
               int dv_len = dv.length ();
-              Array<octave_idx_type> ra_idx (dv_len, 0);
+              Array<octave_idx_type> ra_idx (dv_len, 1, 0);
 
               for (int j = 1; j < n_args; j++)
                 {
                   // Can't fast return here to skip empty matrices as something
                   // like cat(1,[],single([])) must return an empty matrix of
                   // the right type.
                   tmp = do_cat_op (tmp, args (j), ra_idx);
 
@@ -4830,17 +4830,17 @@ by an empty argument.\n\
   int nargin = args.length ();
 
   Array<int> new_size;
 
   if (nargin == 2)
     new_size = args(1).int_vector_value ();
   else if (nargin > 2)
     {
-      new_size.resize (nargin-1);
+      new_size.resize (1, nargin-1);
       int empty_dim = -1;
       
       for (int i = 1; i < nargin; i++)
         {
           if (args(i).is_empty ())
             if (empty_dim > 0)
               {
                 error ("reshape: only a single dimension can be unknown");
@@ -4899,18 +4899,16 @@ by an empty argument.\n\
   while (n > 2)
     {
       if (new_size(n-1) == 1)
         n--;
       else
         break;
     }
 
-  new_size.resize (n);
-
   if (n < 2)
     {
       error ("reshape: expecting size to be vector with at least 2 elements");
       return retval;
     }
 
   dim_vector new_dims;
 
@@ -6363,18 +6361,18 @@ do_accumarray_minmax (const idx_vector& 
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
 
   NDT retval (dim_vector (n, 1), zero_val);
 
   // Pick minimizer or maximizer.
-  void (MArrayN<T>::*op) (const idx_vector&, const MArrayN<T>&) = 
-    ismin ? (&MArrayN<T>::idx_min) : (&MArrayN<T>::idx_max);
+  void (MArray<T>::*op) (const idx_vector&, const MArray<T>&) = 
+    ismin ? (&MArray<T>::idx_min) : (&MArray<T>::idx_max);
 
   octave_idx_type l = idx.length (n);
   if (vals.numel () == 1)
     (retval.*op) (idx, NDT (dim_vector (l, 1), vals(0)));
   else if (vals.numel () == l)
     (retval.*op) (idx, vals);
   else
     error ("accumarray: dimensions mismatch");
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1144,17 +1144,17 @@ complete description of the syntax of th
           if (! error_state)
             {
               if (args(1).is_string ())
                 {
                   octave_idx_type count = 0;
 
                   Array<double> size = (nargin == 3)
                     ? args(2).vector_value ()
-                    : Array<double> (1, lo_ieee_inf_value ());
+                    : Array<double> (1, 1, lo_ieee_inf_value ());
 
                   if (! error_state)
                     {
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
                           retval(1) = count;
@@ -1229,17 +1229,17 @@ string is treated as an end-of-file cond
               if (os.is_valid ())
                 {
                   if (args(1).is_string ())
                     {
                       octave_idx_type count = 0;
 
                       Array<double> size = (nargin == 3)
                         ? args(2).vector_value ()
-                        : Array<double> (1, lo_ieee_inf_value ());
+                        : Array<double> (1, 1, lo_ieee_inf_value ());
 
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
                           // FIXME -- is this the right thing to do?
                           // Extract error message first, because getting
                           // position will clear it.
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -2389,17 +2389,17 @@ opengl_renderer::draw_patch (const patch
   if (has_z)
     for (int i = 0; i < nv; i++)
       clip(i) = is_nan_or_inf (v(i,0), v(i,1), v(i,2));
   else
     for (int i = 0; i < nv; i++)
       clip(i) = is_nan_or_inf (v(i,0), v(i,1), 0);
 
   boolMatrix clip_f (1, nf, false);
-  Array<int> count_f (nf, 0);
+  Array<int> count_f (nf, 1, 0);
 
   for (int i = 0; i < nf; i++)
     {
       bool fclip = false;
       int count = 0;
 
       for (int j = 0; j < fcmax && ! xisnan (f(i,j)); j++, count++)
         fclip = (fclip || clip(int (f(i,j) - 1)));
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -696,17 +696,17 @@ read_mat5_binary_element (std::istream& 
             error ("load: reading sparse matrix data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
-            re = NDArray (dim_vector (nnz));
+            re = NDArray (dim_vector (nnz, 1));
             data = re.fortran_vec ();
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
@@ -715,17 +715,17 @@ read_mat5_binary_element (std::istream& 
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // imaginary data subelement
         if (imag)
           {
-            NDArray im (dim_vector (static_cast<int> (nnz)));
+            NDArray im (dim_vector (static_cast<int> (nnz), 1));
           
             if (read_mat5_tag (is, swap, type, len))
               {
                 error ("load: reading sparse matrix data for `%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -489,17 +489,17 @@ Octave_map
 Octave_map::index (const octave_value_list& idx, bool resize_ok) const
 {
   Octave_map retval;
 
   octave_idx_type n_idx = idx.length ();
 
   if (n_idx > 0)
     {
-      Array<idx_vector> ra_idx (n_idx);
+      Array<idx_vector> ra_idx (n_idx, 1);
 
       for (octave_idx_type i = 0; i < n_idx; i++)
         {
           ra_idx(i) = idx(i).index_vector ();
           if (error_state)
             break;
         }
 
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -46,23 +46,23 @@ public:
 
   explicit octave_value_list (octave_idx_type n)
     : data (dim_vector (1, n)) { }
 
   octave_value_list (octave_idx_type n, const octave_value& val)
     : data (dim_vector (1, n), val) { }
 
   octave_value_list (const octave_value& tc)
-    : data (1, tc) { }
+    : data (1, 1, tc) { }
 
   octave_value_list (const Array<octave_value>& d)
-    : data (d.reshape (dim_vector (1, d.numel ()))) { }
+    : data (d.as_row ()) { }
 
   octave_value_list (const Cell& tc)
-    : data (tc.reshape (dim_vector (1, tc.numel ()))) { }
+    : data (tc.as_row ()) { }
 
   octave_value_list (const octave_value_list& obj)
     : data (obj.data), names (obj.names) { }
 
   // Concatenation constructor.
   octave_value_list (const std::list<octave_value_list>&);
 
   ~octave_value_list (void) { }
@@ -107,20 +107,19 @@ public:
   octave_value& operator () (octave_idx_type n) { return elem (n); }
 
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
   octave_idx_type length (void) const { return data.length (); }
 
   bool empty (void) const { return length () == 0; }
 
-  void resize (octave_idx_type n) { data.resize (n); }
-
-  void resize (octave_idx_type n, const octave_value& val)
-    { data.resize (n, val); }
+  void resize (octave_idx_type n, const octave_value& rfv 
+               = Array<octave_value>::resize_fill_value ()) 
+    { data.resize (1, n, rfv); }
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -3777,18 +3777,18 @@ With no arguments, return a structure co
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      Cell func_names (dim_vector (autoload_map.size ()), 1);
-      Cell file_names (dim_vector (autoload_map.size ()), 1);
+      Cell func_names (dim_vector (autoload_map.size (), 1));
+      Cell file_names (dim_vector (autoload_map.size (), 1));
 
       octave_idx_type i = 0;
       typedef std::map<std::string, std::string>::const_iterator am_iter;
       for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
         {
           func_names(i) = p->first;
           file_names(i) = p->second;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -150,17 +150,17 @@ get_size (const Array<double>& size, oct
       nr = get_size (dnr, who);
 
       if (! error_state && dnc >= 0.0)
         nc = get_size (dnc, who);
     }
 }
 
 scanf_format_list::scanf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), list (16), buf (0)
+  : nconv (0), curr_idx (0), list (16, 1), buf (0)
 {
   octave_idx_type num_elts = 0;
 
   size_t n = s.length ();
 
   size_t i = 0;
 
   int width = 0;
@@ -223,17 +223,17 @@ scanf_format_list::scanf_format_list (co
           have_more = false;
           break;
         }
     }
 
   if (have_more)
     add_elt_to_list (width, discard, type, modifier, num_elts);
 
-  list.resize (num_elts);
+  list.resize (num_elts, 1);
 
   delete buf;
 }
 
 scanf_format_list::~scanf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
@@ -255,17 +255,17 @@ scanf_format_list::add_elt_to_list (int 
 
       if (! text.empty ())
         {
           scanf_format_elt *elt
             = new scanf_format_elt (text.c_str (), width, discard, type,
                                     modifier, char_class);
 
           if (num_elts == list.length ())
-            list.resize (2 * num_elts);
+            list.resize (2 * num_elts, 1);
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
 }
@@ -570,17 +570,17 @@ scanf_format_list::all_numeric_conversio
     }
   else
     return false;
 }
 
 // Ugh again.
 
 printf_format_list::printf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), list (16), buf (0)
+  : nconv (0), curr_idx (0), list (16, 1), buf (0)
 {
   octave_idx_type num_elts = 0;
 
   size_t n = s.length ();
 
   size_t i = 0;
 
   int args = 0;
@@ -595,17 +595,17 @@ printf_format_list::printf_format_list (
 
   if (n == 0)
     {
       printf_format_elt *elt
         = new printf_format_elt ("", args, fw, prec, flags, type, modifier);
 
       list(num_elts++) = elt;
 
-      list.resize (num_elts);
+      list.resize (num_elts, 1);
     }
   else
     {
       while (i < n)
         {
           have_more = true;
 
           if (! buf)
@@ -650,17 +650,17 @@ printf_format_list::printf_format_list (
               have_more = false;
               break;
             }
         }
 
       if (have_more)
         add_elt_to_list (args, flags, fw, prec, type, modifier, num_elts);
 
-      list.resize (num_elts);
+      list.resize (num_elts, 1);
 
       delete buf;
     }
 }
 
 printf_format_list::~printf_format_list (void)
 {
   octave_idx_type n = list.length ();
@@ -683,17 +683,17 @@ printf_format_list::add_elt_to_list (int
 
       if (! text.empty ())
         {
           printf_format_elt *elt
             = new printf_format_elt (text.c_str (), args, fw, prec, flags,
                                      type, modifier);
 
           if (num_elts == list.length ())
-            list.resize (2 * num_elts);
+            list.resize (2 * num_elts, 1);
 
           list(num_elts++) = elt;
         }
 
       delete buf;
       buf = 0;
     }
 }
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -176,17 +176,17 @@ octave_base_matrix<MT>::do_index_op (con
                   retval = MT (matrix.index (i, j, resize_ok));
               }
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx);
+        Array<idx_vector> idx_vec (n_idx, 1);
         bool scalar_opt = n_idx == nd;
         const dim_vector dv = matrix.dims ();
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
@@ -252,17 +252,17 @@ octave_base_matrix<MT>::assign (const oc
             if (! error_state)
               matrix.assign (i, j, rhs);
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx);
+        Array<idx_vector> idx_vec (n_idx, 1);
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
               break;
           }
@@ -290,17 +290,17 @@ template <class MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx,
                                 typename MT::element_type rhs)
 {
   octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
-  MT mrhs (dim_vector (1), rhs);
+  MT mrhs (dim_vector (1, 1), rhs);
 
   switch (n_idx)
     {
     case 0:
       panic_impossible ();
       break;
 
     case 1:
@@ -336,17 +336,17 @@ octave_base_matrix<MT>::assign (const oc
                   matrix.assign (i, j, mrhs);
               }
           }
       }
       break;
 
     default:
       {
-        Array<idx_vector> idx_vec (n_idx);
+        Array<idx_vector> idx_vec (n_idx, 1);
         bool scalar_opt = n_idx == nd;
         const dim_vector dv = matrix.dims ().redim (n_idx);
 
         for (octave_idx_type i = 0; i < n_idx; i++)
           {
             idx_vec(i) = idx(i).index_vector ();
 
             if (error_state)
@@ -382,17 +382,17 @@ octave_base_matrix<MT>::assign (const oc
 }
 
 template <class MT>
 void
 octave_base_matrix<MT>::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type len = idx.length ();
 
-  Array<idx_vector> ra_idx (len);
+  Array<idx_vector> ra_idx (len, 1);
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx(i).index_vector ();
 
   matrix.delete_elements (ra_idx);
 
   // Clear cache.
   clear_cached_info ();
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -79,17 +79,17 @@ octave_base_sparse<T>::do_index_op (cons
                 idx_vector j = idx (1).index_vector ();
 
                 if (! error_state)
                   retval = octave_value (matrix.index (i, j, resize_ok));
               }
           }
         else
           {
-            Array<idx_vector> idx_vec (n_idx);
+            Array<idx_vector> idx_vec (n_idx, 1);
 
             for (octave_idx_type i = 0; i < n_idx; i++)
               {
                 idx_vec(i) = idx(i).index_vector ();
 
                 if (error_state)
                   break;
               }
@@ -195,17 +195,17 @@ octave_base_sparse<T>::assign (const oct
 }
 
 template <class MT>
 void
 octave_base_sparse<MT>::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type len = idx.length ();
 
-  Array<idx_vector> ra_idx (len);
+  Array<idx_vector> ra_idx (len, 1);
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx(i).index_vector ();
 
   matrix.maybe_delete_elements (ra_idx);
 
   // Invalidate the matrix type
   typ.invalidate_type ();
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -272,27 +272,26 @@ octave_perm_matrix::load_ascii (std::ist
   octave_idx_type n;
   bool success = true;
   char orient;
 
   if (extract_keyword (is, "size", n, true)
       && extract_keyword (is, "orient", orient, true))
     {
       bool colp = orient == 'c';
-      dim_vector dv (n);
       ColumnVector tmp (n);
       is >> tmp;
       if (!is) 
         {
           error ("load: failed to load permutation matrix constant");
           success = false;
         }
       else
         {
-          Array<octave_idx_type> pvec (n);
+          Array<octave_idx_type> pvec (n, 1);
           for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
           matrix = PermMatrix (pvec, colp);
 
           // Invalidate cache. Probably not necessary, but safe.
           dense_cache = octave_value ();
         }
     }
   else
@@ -322,17 +321,17 @@ octave_perm_matrix::load_binary (std::is
                                  oct_mach_info::float_format )
 {
   int32_t sz;
   bool colp;
   if (! (is.read (reinterpret_cast<char *> (&sz), 4)
          && is.read (reinterpret_cast<char *> (&colp), 1)))
     return false;
 
-  MArray<octave_idx_type> m (sz);
+  MArray<octave_idx_type> m (sz, 1);
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = m.numel ();
       for (int i = 0; i < nel; i++) 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -60,17 +60,17 @@ octave_struct::dotref (const octave_valu
 
   std::string nm = idx(0).string_value ();
 
   Octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
-    retval = (numel () == 0) ? Cell (dim_vector (1)) : Cell (dims ());
+    retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else 
     error ("structure has no member `%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
@@ -1128,18 +1128,18 @@ A(1)\n\
                       for (octave_idx_type i = 0; i < field_numel; i++)
                         {
                           // Construct cell array which goes into the
                           // structure together with the appropriate
                           // field name.
 
                           Cell c_value (value_dv);
 
-                          Array<octave_idx_type> value_idx (value_dv.length (), 0);
-                          Array<octave_idx_type> c_idx (c_dv_length, 0);
+                          Array<octave_idx_type> value_idx (value_dv.length (), 1, 0);
+                          Array<octave_idx_type> c_idx (c_dv_length, 1, 0);
 
                           for (octave_idx_type j = 0; j < value_dv.numel (); j++)
                             {
                               // Need to do this to construct the
                               // appropriate idx for getting elements
                               // from the original cell array.
 
                               cell2struct_construct_idx (c_idx, value_idx,
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -188,19 +188,19 @@ octave_value_typeinfo::do_register_type 
       return i;
 
   int len = types.length ();
 
   if (i == len)
     {
       len *= 2;
 
-      types.resize (len, std::string ());
+      types.resize (len, 1, std::string ());
 
-      vals.resize (len, octave_value ());
+      vals.resize (len, 1, octave_value ());
 
       unary_ops.resize (static_cast<int> (octave_value::num_unary_ops), len, 0);
 
       non_const_unary_ops.resize
         (static_cast<int> (octave_value::num_unary_ops), len, 0);
 
       binary_ops.resize (static_cast<int> (octave_value::num_binary_ops),
                          len, len, 0);
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -189,22 +189,22 @@ public:
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
-    : num_types (0), types (init_tab_sz, std::string ()),
-      vals (init_tab_sz),
-      unary_class_ops (octave_value::num_unary_ops, 0),
+    : num_types (0), types (init_tab_sz, 1, std::string ()),
+      vals (init_tab_sz, 1),
+      unary_class_ops (octave_value::num_unary_ops, 1, 0),
       unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
       non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
-      binary_class_ops (octave_value::num_binary_ops, 0),
+      binary_class_ops (octave_value::num_binary_ops, 1, 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz, init_tab_sz, 0),
       cat_ops (init_tab_sz, init_tab_sz, 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz, init_tab_sz, 0),
       assignany_ops (octave_value::num_assign_ops, init_tab_sz, 0),
       pref_assign_conv (init_tab_sz, init_tab_sz, -1),
       type_conv_ops (init_tab_sz, init_tab_sz, 0),
       widening_ops (init_tab_sz, init_tab_sz, 0)  { }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1485,17 +1485,17 @@ make_vector_dims (const dim_vector& dv, 
   retval.chop_trailing_singletons ();
   octave_idx_type nel = dv.numel ();
 
   if (retval.length () > 2 || (retval(0) != 1 && retval(1) != 1))
     {
       if (!force_vector_conversion)
         gripe_implicit_conversion ("Octave:array-as-vector",
                                    my_type.c_str (), wanted_type.c_str ());
-      retval = dim_vector (nel);
+      retval = dim_vector (nel, 1);
     }
 
   return retval;
 }
 
 ColumnVector
 octave_value::column_vector_value (bool force_string_conv,
                                    bool frc_vec_conv) const
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1844,17 +1844,17 @@ octave_print_internal (std::ostream& os,
         print_empty_nd_array (os, nda.dims (), pr_as_read_syntax); \
       else \
         { \
  \
           int ndims = nda.ndims (); \
  \
           dim_vector dims = nda.dims (); \
  \
-          Array<octave_idx_type> ra_idx (ndims, 0); \
+          Array<octave_idx_type> ra_idx (ndims, 1, 0); \
  \
           octave_idx_type m = 1; \
  \
           for (int i = 2; i < ndims; i++) \
             m *= dims(i); \
  \
           octave_idx_type nr = dims(0); \
           octave_idx_type nc = dims(1); \
@@ -1879,17 +1879,17 @@ octave_print_internal (std::ostream& os,
                         buf << ","; \
                       else \
                         buf << ")"; \
                     } \
  \
                   nm += buf.str (); \
                 } \
  \
-              Array<idx_vector> idx (ndims); \
+              Array<idx_vector> idx (ndims, 1); \
  \
               idx(0) = idx_vector (':'); \
               idx(1) = idx_vector (':'); \
  \
               for (int k = 2; k < ndims; k++) \
                 idx(k) = idx_vector (ra_idx(k)); \
  \
               octave_value page \
@@ -2680,17 +2680,17 @@ octave_print_internal (std::ostream& os,
       os << nda(0);
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 0);
+      Array<octave_idx_type> ra_idx (ndims, 1, 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
@@ -2713,17 +2713,17 @@ octave_print_internal (std::ostream& os,
                     buf << ",";
                   else
                     buf << ")";
                 }
 
               nm += buf.str ();
             }
 
-          Array<idx_vector> idx (ndims);
+          Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
           Array2<std::string> page (nda.index (idx), nr, nc);
@@ -2945,17 +2945,17 @@ octave_print_internal_template (std::ost
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 0);
+      Array<octave_idx_type> ra_idx (ndims, 1, 0);
 
       dim_vector dims = nda.dims ();
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
@@ -2980,17 +2980,17 @@ octave_print_internal_template (std::ost
                     buf << ")";
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n\n";
             }
 
-          Array<idx_vector> idx (ndims);
+          Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
           Array2<T> page (nda.index (idx), nr, nc);
@@ -3016,17 +3016,17 @@ octave_print_internal_template (std::ost
         }
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<octave_idx_type> ra_idx (ndims, 0);
+      Array<octave_idx_type> ra_idx (ndims, 1, 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
         m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
@@ -3085,17 +3085,17 @@ octave_print_internal_template (std::ost
                     buf << ")";
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n\n";
             }
 
-          Array<idx_vector> idx (ndims);
+          Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
           Array2<T> page (nda.index (idx), nr, nc);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1003,17 +1003,17 @@ tree_matrix::rvalue1 (int)
             }
 
           if (! error_state)
             {
               // Now, extract the values from the individual elements and
               // insert them in the result matrix.
 
               int dv_len = dv.length ();
-              Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0);
+              Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 1, 0);
 
               for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
                 {
                   octave_quit ();
 
                   tm_row_const row = *p;
 
                   for (tm_row_const::iterator q = row.begin ();
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -349,17 +349,17 @@ do_strcmp_fun (const octave_value& arg0,
       else
         {
           str_val = arg1;
           cell_val = arg0;
         }
 
       const Cell cell = cell_val.cell_value ();
       const string_vector str = str_val.all_strings ();
-      octave_idx_type r = str.rows ();
+      octave_idx_type r = str.length ();
 
       if (r == 0 || r == 1)
         {
           // Broadcast the string.
 
           boolNDArray output (cell_val.dims (), false);
 
           std::string s = r == 0 ? std::string () : str[0];
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -395,47 +395,47 @@ ft_render::render (text_element* elt, Ma
       elt->accept (*this);
 
       switch (rotation)
         {
         case ROTATION_0:
           break;
         case ROTATION_90:
             {
-              Array<octave_idx_type> perm (3);
+              Array<octave_idx_type> perm (3, 1);
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (3);
+              Array<idx_vector> idx (3, 1);
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
               idx(2) = idx_vector (':');
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_180:
             {
-              Array<idx_vector> idx (3);
+              Array<idx_vector> idx (3, 1);
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
               idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_270:
             {
-              Array<octave_idx_type> perm (3);
+              Array<octave_idx_type> perm (3, 1);
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (3);
+              Array<idx_vector> idx (3, 1);
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (':');
               idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         }
     }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -908,17 +908,17 @@ print_descriptor (std::ostream& os, std:
 
 std::string
 get_dims_str (const octave_value& val)
 {
   octave_value tmp = val;
 
   Matrix sz = tmp.size ();
 
-  dim_vector dv (sz.numel ());
+  dim_vector dv = dim_vector::alloc (sz.numel ());
 
   for (octave_idx_type i = 0; i < dv.length (); i++)
     dv(i) = sz(i);
 
   return dv.str ();
 }
 
 class
