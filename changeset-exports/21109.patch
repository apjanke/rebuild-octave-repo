# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453236294 28800
#      Tue Jan 19 12:44:54 2016 -0800
# Node ID bd1752782e561c43d54c7b6ad2c26151346434cf
# Parent  9310b9bb163ba0c4cdbe1cf9aa6b714047b122c7
Use err_disabled_feature, warn_disabled_feature throughout code base.
In liboctave, use the same error text as err_disabled_feature, but
call error_handler directly because err_disabled_feature is in libinterp.

* errwarn.cc (err_disabled_feature): Don't print leading "%s:" if calling
function is "".
* errwarn.cc (warn_disabled_feature): New function.  Same msg as
err_disabled_feature but uses warning rather than error.

* errwarn.h (warn_disabled_feature): prototype for new function.

* file-io.cc, gl-render.cc, gl2ps-renderer.cc, load-save.cc, ls-mat5.cc,
oct-hdf5-types.cc, pt-jit.cc, syscalls.cc, sysdep.cc, toplev.cc,
__delaunayn__.cc, __eigs__.cc, __fltk_uigetfile__.cc, __init_fltk__.cc,
__osmesa_print__.cc, __voronoi__.cc, amd.cc, ccolamd.cc, colamd.cc,
convhulln.cc, dmperm.cc, fftw.cc, symbfact.cc: Replace calls to error about
missing feature with calls to err_disabled_feature.  Replace calls to warning
about missing feature with calls to warn_disabled_feature.

* CSparse.cc, dSparse.cc, SparseCmplxLU.cc, SparseCmplxQR.cc, SparseQR.cc,
SparsedbleLU.cc, sparse-base-chol.cc, sparse-dmsolve.cc, oct-shlib.cc:
Use same text of message from err_disabled_feature but call
(*current_liboctave_error_handler) or
(*current_liboctave_warning_with_id_handler).

diff --git a/libinterp/corefcn/errwarn.cc b/libinterp/corefcn/errwarn.cc
--- a/libinterp/corefcn/errwarn.cc
+++ b/libinterp/corefcn/errwarn.cc
@@ -43,20 +43,24 @@ err_2_or_3_dim_plot (void)
 void
 err_data_conversion (const char *from, const char *to)
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
 err_disabled_feature (const std::string& fcn, const std::string& feature,
-                      const std::string& pkg /*="Octave"*/)
+                      const std::string& pkg /* ="Octave" */)
 {
-  error ("%s: support for %s was unavailable or disabled when %s was built",
-         fcn.c_str (), feature.c_str (), pkg.c_str ());
+  if (! fcn.empty ())
+    error ("%s: support for %s was unavailable or disabled when %s was built",
+           fcn.c_str (), feature.c_str (), pkg.c_str ());
+  else
+    error ("support for %s was unavailable or disabled when %s was built",
+           feature.c_str (), pkg.c_str ());
 }
 
 void
 err_indexed_cs_list (void)
 {
   error ("a cs-list cannot be further indexed");
 }
 
@@ -279,16 +283,28 @@ void
 warn_data_file_in_path (const std::string& fcn, const std::string& file)
 {
   warning_with_id ("Octave:data-file-in-path",
                    "%s: '%s' found by searching load path",
                    fcn.c_str (), file.c_str ());
 }
 
 void
+warn_disabled_feature (const std::string& fcn, const std::string& feature,
+                       const std::string& pkg /*="Octave"*/)
+{
+  if (! fcn.empty ())
+    warning ("%s: support for %s was unavailable or disabled when %s was built",
+             fcn.c_str (), feature.c_str (), pkg.c_str ());
+  else
+    warning ("support for %s was unavailable or disabled when %s was built",
+             feature.c_str (), pkg.c_str ());
+}
+
+void
 warn_divide_by_zero (void)
 {
   warning_with_id ("Octave:divide-by-zero", "division by zero");
 }
 
 void
 warn_empty_arg (const char *name)
 {
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
--- a/libinterp/corefcn/errwarn.h
+++ b/libinterp/corefcn/errwarn.h
@@ -38,17 +38,17 @@ OCTAVE_NORETURN OCTINTERP_API extern
 void err_2_or_3_dim_plot (void);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void err_data_conversion (const char *from, const char *to);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void err_disabled_feature (const std::string& fcn,
                            const std::string& feature,
-                           const std::string& pkg="Octave");
+                           const std::string& pkg = "Octave");
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void err_indexed_cs_list (void);
 
 OCTAVE_NORETURN OCTINTERP_API extern
 void err_invalid_conversion (const std::string& from, const std::string& to);
 
 OCTAVE_NORETURN OCTINTERP_API extern
@@ -145,16 +145,21 @@ void err_wrong_type_arg_for_unary_op (co
 
 OCTINTERP_API extern
 void warn_complex_cmp (void);
 
 OCTINTERP_API extern
 void warn_data_file_in_path (const std::string& fcn, const std::string& file);
 
 OCTINTERP_API extern
+void warn_disabled_feature (const std::string& fcn,
+                            const std::string& feature,
+                            const std::string& pkg = "Octave");
+
+OCTINTERP_API extern
 void warn_divide_by_zero (void);
 
 OCTINTERP_API extern
 void warn_empty_arg (const char *name);
 
 OCTINTERP_API extern
 void warn_implicit_conversion (const char *id,
                                const char *from, const char *to);
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -173,17 +173,17 @@ normalize_fopen_mode (std::string& mode,
       pos = mode.find ('z');
 
       if (pos != std::string::npos)
         {
 #if defined (HAVE_ZLIB)
           use_zlib = true;
           mode.erase (pos, 1);
 #else
-          error ("this version of Octave does not support gzipped files");
+          err_disabled_feature ("", "gzipped files (zlib)");
 #endif
         }
 
       // Use binary mode if 't' is not specified, but don't add
       // 'b' if it is already present.
 
       size_t bpos = mode.find ('b');
       size_t tpos = mode.find ('t');
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -3264,14 +3264,15 @@ opengl_renderer::render_text (const std:
   glDrawPixels (bbox(2), bbox(3),
                 GL_RGBA, GL_UNSIGNED_BYTE, pixels.data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
   return bbox;
 #else
-  warning ("opengl_renderer: cannot render text, FreeType library not available");
+  warn_disabled_feature ("opengl_renderer::render_text",
+                         "rendering text (FreeType)");
   return Matrix (1, 4, 0.0);
 #endif
 }
 
 #endif
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -649,13 +649,11 @@ gl2ps_print (const graphics_object& fig,
 
   frame.add_fcn (safe_pclose, fp);
 
   gl2ps_renderer rend (fp, term);
 
   rend.draw (fig, cmd);
 
 #else
-
-  error ("print: printing not available without gl2ps library");
-
+  err_disabled_feature ("gl2ps_print", "gl2ps");
 #endif
 }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -690,17 +690,17 @@ Force Octave to assume the file is in Oc
         {
           format = LS_MAT_BINARY;
         }
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
         {
 #ifdef HAVE_HDF5
           format = LS_HDF5;
 #else
-          error ("load: octave executable was not linked with HDF5 library");
+          err_disabled_feature ("load", "HDF5");
 #endif
         }
       else if (argv[i] == "-import" || argv[i] == "-i")
         {
           warning ("load: -import ignored");
         }
       else if (argv[i] == "-text" || argv[i] == "-t")
         {
@@ -1059,17 +1059,17 @@ parse_save_options (const string_vector 
         {
           format = LS_BINARY;
         }
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
         {
 #ifdef HAVE_HDF5
           format = LS_HDF5;
 #else
-          error ("save: octave executable was not linked with HDF5 library");
+          err_disabled_feature ("save", "HDF5");
 #endif
         }
       else if (argv[i] == "-mat-binary" || argv[i] == "-mat"
                || argv[i] == "-m" || argv[i] == "-6" || argv[i] == "-v6"
                || argv[i] == "-V6")
         {
           format = LS_MAT5_BINARY;
         }
@@ -1091,17 +1091,17 @@ parse_save_options (const string_vector 
           save_as_floats = true;
         }
       else if (argv[i] == "-float-hdf5")
         {
 #ifdef HAVE_HDF5
           format = LS_HDF5;
           save_as_floats = true;
 #else
-          error ("save: octave executable was not linked with HDF5 library");
+          err_disabled_feature ("save", "HDF5");
 #endif
         }
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
         {
           use_zlib  = true;
         }
 #endif
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -590,17 +590,17 @@ read_mat5_binary_element (std::istream& 
         {
           std::istringstream gz_is (outbuf);
           retval = read_mat5_binary_element (gz_is, filename,
                                              swap, global, tc);
         }
 
       return retval;
 #else
-      error ("load: zlib unavailable, cannot read compressed data element");
+      err_disabled_feature ("load", "compressed data elements (zlib)");
 #endif
     }
 
   std::streampos pos;
 
   if (type != miMATRIX)
     {
       pos = is.tellg ();
diff --git a/libinterp/corefcn/oct-hdf5-types.cc b/libinterp/corefcn/oct-hdf5-types.cc
--- a/libinterp/corefcn/oct-hdf5-types.cc
+++ b/libinterp/corefcn/oct-hdf5-types.cc
@@ -45,18 +45,16 @@ check_hdf5_types (bool warn)
 
       ok = sizeof (octave_hdf5_err) >= sizeof (herr_t);
 
       if (warn && ! ok)
         warning_with_id
           ("Octave:internal",
            "the size of octave_hdf5_err is smaller than the size of HDF5 herr_t");
 #else
-      warning_with_id
-        ("Octave:internal",
-         "check_hdf5_id_type called but Octave was not compiled with support for HDF5");
+      warn_disabled_feature ("check_hdf5_id_type", "HDF5");
 #endif
 
       checked = true;
     }
 
   return ok;
 }
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #define __STDC_CONSTANT_MACROS
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "debug.h"
 #include "defun.h"
+#include "errwarn.h"
 #include "ov.h"
 #include "pt-all.h"
 #include "pt-jit.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "variables.h"
 
 #ifdef HAVE_LLVM
@@ -2527,18 +2528,18 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_enable, jit_startcnt, debug_jit}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE (jit_failcnt);
 #else
-  warning ("jit_failcnt: JIT compiling not available in this version of Octave");
-  return octave_value ();
+  warn_disabled_feature ("jit_failcnt", "JIT compiling");
+  return ovl ();
 #endif
 }
 
 DEFUN (debug_jit, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} debug_jit ()\n\
 @deftypefnx {} {@var{old_val} =} debug_jit (@var{new_val})\n\
@@ -2550,18 +2551,18 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_enable, jit_startcnt}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE (debug_jit);
 #else
-  warning ("debug_jit: JIT compiling not available in this version of Octave");
-  return octave_value ();
+  warn_disabled_feature ("debug_jit", "JIT");
+  return ovl ();
 #endif
 }
 
 DEFUN (jit_enable, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} jit_enable ()\n\
 @deftypefnx {} {@var{old_val} =} jit_enable (@var{new_val})\n\
@@ -2572,18 +2573,18 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_startcnt, debug_jit}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE (jit_enable);
 #else
-  warning ("jit_enable: JIT compiling not available in this version of Octave");
-  return octave_value ();
+  warn_disabled_feature ("jit_enable", "JIT");
+  return ovl ();
 #endif
 }
 
 DEFUN (jit_startcnt, UNUSED_WITHOUT_LLVM (args),
        UNUSED_WITHOUT_LLVM (nargout),
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} jit_startcnt ()\n\
 @deftypefnx {} {@var{old_val} =} jit_startcnt (@var{new_val})\n\
@@ -2600,12 +2601,12 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{jit_enable, jit_failcnt, debug_jit}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (jit_startcnt, 1,
                                             std::numeric_limits<int>::max ());
 #else
-  warning ("jit_enable: JIT compiling not available in this version of Octave");
-  return octave_value ();
+  warn_disabled_feature ("jit_enable", "JIT");
+  return ovl ();
 #endif
 }
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -1308,232 +1308,232 @@ DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
 Return the numerical value to pass to @code{fcntl} to return\n\
 a duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
 #else
-  error ("F_DUPFD: not available on this system");
+  err_disabled_feature ("F_DUPFD", "F_DUPFD");
 #endif
 }
 
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} F_GETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to return\n\
 the file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFD)
   return const_value (args, F_GETFD);
 #else
-  error ("F_GETFD: not available on this system");
+  err_disabled_feature ("F_GETFD", "F_GETFD");
 #endif
 }
 
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} F_GETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to return\n\
 the file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFL)
   return const_value (args, F_GETFL);
 #else
-  error ("F_GETFL: not available on this system");
+  err_disabled_feature ("F_GETFL", "F_GETFL");
 #endif
 }
 
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} F_SETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_SETFD)
   return const_value (args, F_SETFD);
 #else
-  error ("F_SETFD: not available on this system");
+  err_disabled_feature ("F_SETFD", "F_SETFD");
 #endif
 }
 
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} F_SETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
 #if defined (F_SETFL)
   return const_value (args, F_SETFL);
 #else
-  error ("F_SETFL: not available on this system");
+  err_disabled_feature ("F_SETFL", "F_SETFL");
 #endif
 }
 
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_APPEND)
   return const_value (args, O_APPEND);
 #else
-  error ("O_APPEND: not available on this system");
+  err_disabled_feature ("O_APPEND", "O_APPEND");
 #endif
 }
 
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
 #else
-  error ("O_ASYNC: not available on this system");
+  err_disabled_feature ("O_ASYNC", "O_ASYNC");
 #endif
 }
 
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be created if it\n\
 does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_CREAT)
   return const_value (args, O_CREAT);
 #else
-  error ("O_CREAT: not available on this system");
+  err_disabled_feature ("O_CREAT", "O_CREAT");
 #endif
 }
 
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_EXCL)
   return const_value (args, O_EXCL);
 #else
-  error ("O_EXCL: not available on this system");
+  err_disabled_feature ("O_EXCL", "O_EXCL");
 #endif
 }
 
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
 #else
-  error ("O_NONBLOCK: not available on this system");
+  err_disabled_feature ("O_NONBLOCK", "O_NONBLOCK");
 #endif
 }
 
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
 #else
-  error ("O_RDONLY: not available on this system");
+  err_disabled_feature ("O_RDONLY", "O_RDONLY");
 #endif
 }
 
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both reading\n\
 and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDWR)
   return const_value (args, O_RDWR);
 #else
-  error ("O_RDWR: not available on this system");
+  err_disabled_feature ("O_RDWR", "O_RDWR");
 #endif
 }
 
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_SYNC)
   return const_value (args, O_SYNC);
 #else
-  error ("O_SYNC: not available on this system");
+  err_disabled_feature ("O_SYNC", "O_SYNC");
 #endif
 }
 
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should be\n\
 truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
 #else
-  error ("O_TRUNC: not available on this system");
+  err_disabled_feature ("O_TRUNC", "O_TRUNC");
 #endif
 }
 
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
 #if defined (O_WRONLY)
   return const_value (args, O_WRONLY);
 #else
-  error ("O_WRONLY: not available on this system");
+  err_disabled_feature ("O_WRONLY", "O_WRONLY");
 #endif
 }
 
 #if ! defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -463,17 +463,17 @@ raw_mode (bool on, bool wait)
         // Restore saved modes.
 
         s = save_term;
       }
 
     ioctl (tty_fd, TIOCSETN, &s);
   }
 #else
-  warning ("no support for raw mode console I/O on this system");
+  warn_disabled_feature ("", "raw mode console I/O");
 
   // Make sure the current mode doesn't toggle.
   on = curr_on;
 #endif
 
   curr_on = on;
 }
 
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1090,17 +1090,17 @@ command shell that is started to run the
 
       if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
         error ("system: CreateProcess failed -- can't create child process");
 
       retval(0) = pi.dwProcessId;
       CloseHandle (pi.hProcess);
       CloseHandle (pi.hThread);
 #else
-      error ("system: asynchronous system calls are not supported");
+      err_disabled_feature ("system", "asynchronous system calls");
 #endif
     }
   else if (return_output)
     retval = run_command_and_return_output (cmd_str);
   else
     {
       int status = system (cmd_str.c_str ());
 
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -220,18 +220,16 @@ Undocumented internal function.\n\
         vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
   return retval;
 
 #else
-
-  error ("__delaunayn__: not available in this version of Octave");
-
+  err_disabled_feature ("__delaunayn__", "Qhull");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -554,11 +554,11 @@ Undocumented internal function.\n\
              nconv, k);
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 
   return retval;
 
 #else
-  error ("eigs: not available in this version of Octave");
+  err_disabled_feature ("eigs", "ARPACK");
 #endif
 }
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -133,20 +133,17 @@ Undocumented internal function.\n\
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
 
 #else
-
-  error ("__fltk_uigetfile__: not available without OpenGL and FLTK libraries");
-
+  err_disabled_feature ("__fltk_uigetfile__", "OpenGL and FLTK");
 #endif
-
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -2345,17 +2345,17 @@ Undocumented internal function.  Calls F
 #ifdef HAVE_FLTK
   Fl::check ();
 
   if (Vdrawnow_requested)
     Fdrawnow ();
 
   return ovl ();
 #else
-  error ("__fltk_check__: not available without OpenGL and FLTK libraries");
+  err_disabled_feature ("__fltk_check__", "OpenGL and FLTK");
 #endif
 }
 
 // Initialize the fltk graphics toolkit.
 
 DEFUN_DLD (__init_fltk__, , ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __init_fltk__ ()\n\
@@ -2377,18 +2377,19 @@ Undocumented internal function.\n\
       octave_value fcn (new octave_builtin (F__fltk_check__));
       octave_value fcn_handle (new octave_fcn_handle (fcn, "@__fltk_check__"));
       octave_value_list id = Fadd_input_event_hook (fcn_handle, 1);
 
       fltk->set_input_event_hook_id (id);
     }
 
   return ovl ();
+
 #else
-  error ("__init_fltk__: not available without OpenGL and FLTK libraries");
+  err_disabled_feature ("__init_fltk__", "OpenGL and FLTK");
 #endif
 }
 
 DEFUN_DLD (__have_fltk__, , ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{FLTK_available} =} __have_fltk__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -82,18 +82,18 @@ Use GL2PS_SIMPLE_SORT instead of GL2PS_B
 Don't render text.\n\
 @end table\n\
 \n\
 The second method doesn't use gl2ps and returns a RGB image in @var{img}\n\
 instead.\n\
 \n\
 @end deftypefn")
 {
-#if ! defined (HAVE_OSMESA)
-  err_disabled_feature ("__osmesa_print__", "offscreen rendering");
+#ifndef HAVE_OSMESA
+  err_disabled_feature ("__osmesa_print__", "offscreen rendering with OSMesa");
 #else
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
 
   if (nargin == 3)
     {
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -322,16 +322,16 @@ Undocumented internal function.\n\
 
   if (curlong || totlong)
     warning ("%s: qhull did not free %d bytes of long memory (%d pieces)",
              caller.c_str (), totlong, curlong);
 
   return retval;
 
 #else
-  error ("%s: not available in this version of Octave", caller.c_str ());
+  err_disabled_feature (caller, "Qhull");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -172,19 +172,17 @@ The author of the code itself is Timothy
     Pout.xelem (i) = P[i] + 1;
 
   if (nargout > 1)
     return ovl (Pout, xinfo);
   else
     return ovl (Pout);
 
 #else
-
-  error ("amd: not available in this version of Octave");
-
+  err_disabled_feature ("amd", "AMD");
 #endif
 }
 
 /*
 %!shared A, A2, opts
 %! A = ones (20, 30);
 %! A2 = ones (30, 30);
 %!
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -39,21 +39,21 @@ along with Octave; see the file COPYING.
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #include "oct-sparse.h"
 #include "oct-locbuf.h"
 
 #ifdef USE_64_BIT_IDX_T
-#define CCOLAMD_NAME(name) ccolamd_l ## name
-#define CSYMAMD_NAME(name) csymamd_l ## name
+# define CCOLAMD_NAME(name) ccolamd_l ## name
+# define CSYMAMD_NAME(name) csymamd_l ## name
 #else
-#define CCOLAMD_NAME(name) ccolamd ## name
-#define CSYMAMD_NAME(name) csymamd ## name
+# define CCOLAMD_NAME(name) ccolamd ## name
+# define CSYMAMD_NAME(name) csymamd ## name
 #endif
 
 DEFUN_DLD (ccolamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} ccolamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
@@ -324,19 +324,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // occur if symamd returns FALSE
       out_stats (CCOLAMD_INFO1) ++ ;
       out_stats (CCOLAMD_INFO2) ++ ;
     }
 
   return retval;
 
 #else
-
-  error ("ccolamd: not available in this version of Octave");
-
+  err_disabled_feature ("ccolamd", "CCOLAMD");
 #endif
 }
 
 DEFUN_DLD (csymamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} csymamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
@@ -556,13 +554,11 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // occur if symamd returns FALSE
       out_stats (CCOLAMD_INFO1) ++ ;
       out_stats (CCOLAMD_INFO2) ++ ;
     }
 
   return retval;
 
 #else
-
-  error ("csymamd: not available in this version of Octave");
-
+  err_disabled_feature ("csymamd", "CCOLAMD");
 #endif
 }
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -40,21 +40,21 @@ along with Octave; see the file COPYING.
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #include "oct-sparse.h"
 #include "oct-locbuf.h"
 
 #ifdef USE_64_BIT_IDX_T
-#define COLAMD_NAME(name) colamd_l ## name
-#define SYMAMD_NAME(name) symamd_l ## name
+# define COLAMD_NAME(name) colamd_l ## name
+# define SYMAMD_NAME(name) symamd_l ## name
 #else
-#define COLAMD_NAME(name) colamd ## name
-#define SYMAMD_NAME(name) symamd ## name
+# define COLAMD_NAME(name) colamd ## name
+# define SYMAMD_NAME(name) symamd ## name
 #endif
 
 // The symmetric column elimination tree code take from the Davis LDL code.
 // Copyright given elsewhere in this file.
 static void
 symetree (const octave_idx_type *ridx, const octave_idx_type *cidx,
           octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
@@ -436,19 +436,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // occur if symamd returns FALSE
       out_stats (COLAMD_INFO1) ++ ;
       out_stats (COLAMD_INFO2) ++ ;
     }
 
   return retval;
 
 #else
-
-  error ("colamd: not available in this version of Octave");
-
+  err_disabled_feature ("colamd", "COLAMD");
 #endif
 }
 
 DEFUN_DLD (symamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} symamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
@@ -626,19 +624,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // occur if symamd returns FALSE
       out_stats (COLAMD_INFO1) ++ ;
       out_stats (COLAMD_INFO2) ++ ;
     }
 
   return retval;
 
 #else
-
-  error ("symamd: not available in this version of Octave");
-
+  err_disabled_feature ("symamd", "COLAMD");
 #endif
 }
 
 DEFUN_DLD (etree, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -284,17 +284,17 @@ convex hull is calculated.\n\n\
 
   if (curlong || totlong)
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
              totlong, curlong);
 
   return retval;
 
 #else
-  error ("convhulln: not available in this version of Octave");
+  err_disabled_feature ("convhulln", "Qhull");
 #endif
 }
 
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
 %! assert (size (h), [12 3]);
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -33,19 +33,19 @@ along with Octave; see the file COPYING.
 
 #include "oct-sparse.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 
 #ifdef USE_64_BIT_IDX_T
-#define CXSPARSE_NAME(name) cs_dl ## name
+# define CXSPARSE_NAME(name) cs_dl ## name
 #else
-#define CXSPARSE_NAME(name) cs_di ## name
+# define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
     ret.xelem (i) = p[i] + 1;
@@ -152,17 +152,17 @@ ACM Trans. Math. Software, 16(4):303-324
 #if HAVE_CXSPARSE
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (false, args(0), nargout));
 
 #else
-  error ("dmperm: not available in this version of Octave");
+  err_disabled_feature ("dmperm", "CXSparse");
 #endif
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! n = 20;
 %! a = speye (n,n);
 %! a = a(randperm (n),:);
@@ -195,17 +195,17 @@ such the numerical rank of the matrix @v
 #if HAVE_CXSPARSE
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (true, args(0), nargout));
 
 #else
-  error ("sprank: not available in this version of Octave");
+  err_disabled_feature ("sprank", "CXSparse");
 #endif
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! assert (sprank (speye (20)), 20)
 %!testif HAVE_CXSPARSE
 %! assert (sprank ([1,0,2,0;2,0,4,0]), 2)
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -310,19 +310,17 @@ used per default.\n\
 #endif
     }
   else
     error ("fftw: unrecognized argument");
 
   return retval;
 
 #else
-
   err_disabled_feature ("fftw", "the FFTW3 planner");
-
 #endif
 }
 
 /*
 %!testif HAVE_FFTW
 %! def_method = fftw ("planner");
 %! unwind_protect
 %!   method = "estimate";
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -340,11 +340,11 @@ factorization as determined by @var{typ}
 
   for (octave_idx_type i = 0; i < n; i++)
     tmp(i) = ColCount[i];
   retval(0) = tmp;
 
   return retval;
 
 #else
-  error ("symbfact: not available in this version of Octave");
+  err_disabled_feature ("symbfact", "CHOLMOD");
 #endif
 }
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1277,21 +1277,22 @@ SparseComplexMatrix::determinant (octave
                 }
               else
                 retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
         }
     }
+  return retval;
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
-
-  return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
@@ -5548,21 +5549,23 @@ SparseComplexMatrix::factorize (octave_i
       else
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
         }
     }
 
   if (err != 0)
     UMFPACK_ZNAME (free_numeric) (&Numeric);
-#else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
-#endif
 
   return Numeric;
+
+#else
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
+#endif
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
@@ -5704,17 +5707,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -5786,17 +5791,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -5961,17 +5968,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6075,17 +6084,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -6234,17 +6245,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6295,17 +6308,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -6470,17 +6485,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6576,17 +6593,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1362,21 +1362,24 @@ SparseMatrix::determinant (octave_idx_ty
                 }
               else
                 retval = DET (c10, e10, 10);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
         }
     }
-#else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
-#endif
 
   return retval;
+
+#else
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled "
+     "when liboctave was built");
+#endif
 }
 
 Matrix
 SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b,
                       octave_idx_type& err,
                       double& rcond, solve_singularity_handler,
                       bool calc_cond) const
 {
@@ -5742,21 +5745,23 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
         }
     }
 
   if (err != 0)
     UMFPACK_DNAME (free_numeric) (&Numeric);
 
+  return Numeric;
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled "
+     "when liboctave was built");
 #endif
-
-  return Numeric;
 }
 
 Matrix
 SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
@@ -5899,17 +5904,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -5954,17 +5961,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -6128,17 +6137,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6214,17 +6225,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -6373,17 +6386,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6446,17 +6461,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -6621,17 +6638,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:missing-dependency", "CHOLMOD not installed");
+            ("Octave:missing-dependency",
+             "support for CHOLMOD was unavailable or disabled "
+             "when liboctave was built");
 
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
@@ -6716,17 +6735,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 #else
-          (*current_liboctave_error_handler) ("UMFPACK not installed");
+          (*current_liboctave_error_handler)
+            ("support for UMFPACK was unavailable or disabled "
+             "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
diff --git a/liboctave/numeric/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
--- a/liboctave/numeric/SparseCmplxLU.cc
+++ b/liboctave/numeric/SparseCmplxLU.cc
@@ -234,18 +234,20 @@ SparseComplexLU::SparseComplexLU (const 
                   UMFPACK_ZNAME (report_perm) (nr, p, control);
                   UMFPACK_ZNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
             }
         }
     }
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a,
                                   const ColumnVector& Qinit,
                                   const Matrix& piv_thres, bool scale,
                                   bool FixedQ, double droptol,
                                   bool milu, bool udiag)
@@ -472,12 +474,14 @@ SparseComplexLU::SparseComplexLU (const 
                 }
             }
         }
 
       if (udiag)
         (*current_liboctave_error_handler)
           ("Option udiag of incomplete LU not implemented");
     }
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
diff --git a/liboctave/numeric/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
--- a/liboctave/numeric/SparseCmplxQR.cc
+++ b/liboctave/numeric/SparseCmplxQR.cc
@@ -75,19 +75,20 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseComplexQR: sparse matrix QR factorization filled");
   count = 1;
+
 #else
   (*current_liboctave_error_handler)
-    ("SparseComplexQR: sparse matrix QR factorization not implemented");
+    ("SparseComplexQR: support for CXSparse was unavailable or disabled when liboctave was built");
 #endif
 }
 
 SparseComplexQR::SparseComplexQR_rep::~SparseComplexQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME (_sfree) (S);
   CXSPARSE_ZNAME (_nfree) (N);
diff --git a/liboctave/numeric/SparseQR.cc b/liboctave/numeric/SparseQR.cc
--- a/liboctave/numeric/SparseQR.cc
+++ b/liboctave/numeric/SparseQR.cc
@@ -55,19 +55,20 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
 #endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseQR: sparse matrix QR factorization filled");
   count = 1;
+
 #else
   (*current_liboctave_error_handler)
-    ("SparseQR: sparse matrix QR factorization not implemented");
+    ("SparseQR: support for CXSparse was unavailable or disabled when liboctave was built");
 #endif
 }
 
 SparseQR::SparseQR_rep::~SparseQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_DNAME (_sfree) (S);
   CXSPARSE_DNAME (_nfree) (N);
diff --git a/liboctave/numeric/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
--- a/liboctave/numeric/SparsedbleLU.cc
+++ b/liboctave/numeric/SparsedbleLU.cc
@@ -221,18 +221,20 @@ SparseLU::SparseLU (const SparseMatrix& 
                   UMFPACK_DNAME (report_perm) (nr, p, control);
                   UMFPACK_DNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
             }
         }
     }
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
 
 SparseLU::SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
                     const Matrix& piv_thres, bool scale, bool FixedQ,
                     double droptol, bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
@@ -449,12 +451,14 @@ SparseLU::SparseLU (const SparseMatrix& 
                 }
             }
         }
 
       if (udiag)
         (*current_liboctave_error_handler)
           ("Option udiag of incomplete LU not implemented");
     }
+
 #else
-  (*current_liboctave_error_handler) ("UMFPACK not installed");
+  (*current_liboctave_error_handler)
+    ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
diff --git a/liboctave/numeric/sparse-base-chol.cc b/liboctave/numeric/sparse-base-chol.cc
--- a/liboctave/numeric/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-base-chol.cc
@@ -208,21 +208,23 @@ sparse_base_chol<chol_type, chol_elt, p_
       static char tmp[] = " ";
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CHOLMOD_NAME(free_factor) (&Lfactor, cm);
       CHOLMOD_NAME(finish) (cm);
       CHOLMOD_NAME(print_common) (tmp, cm);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
+
+  return info;
+
 #else
   (*current_liboctave_error_handler)
-    ("Missing CHOLMOD. Sparse cholesky factorization disabled");
+    ("support for CHOLMOD was unavailable or disabled when liboctave was built");
 #endif
-  return info;
 }
 
 template <class chol_type, class chol_elt, class p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -477,20 +477,20 @@ dmsolve (const ST &a, const T &b, octave
             qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1] , 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
+
 #else
   (*current_liboctave_error_handler)
-    ("CXSPARSE unavailable; cannot solve minimum norm problem");
-  return RT ();
+    ("support for CXSparse was unavailable or disabled when liboctave was built");
 #endif
 }
 
 #if ! defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern Matrix
 dmsolve (const SparseMatrix &a, const Matrix &b,
          octave_idx_type &info);
 
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -520,12 +520,11 @@ octave_shlib::shlib_rep::new_instance (c
 #elif defined (HAVE_SHL_LOAD_API)
   return new octave_shl_load_shlib (f);
 #elif defined (HAVE_LOADLIBRARY_API)
   return new octave_w32_shlib (f);
 #elif defined (HAVE_DYLD_API)
   return new octave_dyld_shlib (f);
 #else
   (*current_liboctave_error_handler)
-    ("no API for dynamic loading is available");
-  return new shlib_rep ();
+    ("support for dynamically loaded libraries was unavailable or disabled when liboctave was built");
 #endif
 }
