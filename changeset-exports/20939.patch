# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450481842 28800
#      Fri Dec 18 15:37:22 2015 -0800
# Node ID b17fda023ca63d14a2a95957ee7102e159a569c0
# Parent  aac911d8847bc75b19abaf09028dd317ac37ba57
maint: Use new C++ archetype in more files.
Place input validation first in files.
Move declaration of retval down in function to be closer to point of usage.
Eliminate else clause after if () error.
Use "return ovl()" where it makes sense.

* find.cc, gammainc.cc, gcd.cc, getgrent.cc, getpwent.cc, givens.cc,
graphics.cc, help.cc, hess.cc, hex2num.cc, input.cc, kron.cc, load-path.cc,
load-save.cc, lookup.cc, mappers.cc, matrix_type.cc, mgorth.cc, nproc.cc,
ordschur.cc, pager.cc, pinv.cc, pr-output.cc, profiler.cc, psi.cc, quad.cc,
rcond.cc, regexp.cc, schur.cc, sighandlers.cc, sparse.cc, str2double.cc,
strfind.cc, strfns.cc, sub2ind.cc, svd.cc, sylvester.cc, symtab.cc,
syscalls.cc, sysdep.cc, time.cc, toplev.cc, tril.cc, tsearch.cc, typecast.cc,
urlwrite.cc, utils.cc, variables.cc, __delaunayn__.cc, __eigs__.cc,
__glpk__.cc, __magick_read__.cc, __osmesa_print__.cc, __voronoi__.cc, amd.cc,
audiodevinfo.cc, audioread.cc, chol.cc, colamd.cc, dmperm.cc, fftw.cc, qr.cc,
symbfact.cc, symrcm.cc, ov-bool-mat.cc, ov-cell.cc, ov-class.cc,
ov-classdef.cc, ov-fcn-handle.cc, ov-fcn-inline.cc, ov-flt-re-mat.cc,
ov-java.cc, ov-null-mat.cc, ov-oncleanup.cc, ov-re-mat.cc, ov-struct.cc,
ov-typeinfo.cc, ov-usr-fcn.cc, ov.cc, octave.cc:
Use new C++ archetype in more files.

diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -378,21 +378,19 @@ create the original matrix.  For example
 sz = size (a);\n\
 [i, j, v] = find (a);\n\
 b = sparse (i, j, v, sz(1), sz(2));\n\
 @end group\n\
 @end example\n\
 @seealso{nonzeros}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
-  if (nargin > 3 || nargin < 1)
+  if (nargin < 1 || nargin > 3)
     print_usage ();
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).xscalar_value ("find: N must be an integer");
 
@@ -409,40 +407,39 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
       direction = 0;
 
       std::string s_arg = args(2).string_value ();
 
       if (s_arg == "first")
         direction = 1;
       else if (s_arg == "last")
         direction = -1;
-
-      if (direction == 0)
+      else
         error ("find: DIRECTION must be \"first\" or \"last\"");
     }
 
+  octave_value_list retval;
+
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     {
       if (arg.is_sparse_type ())
         {
           SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
           // matrix. Try to reuse the possibly cached index vector.
 
           // No need to catch index_exception, since arg is bool.
-          // Out-of-range errors have already set pos, and will be
-          // caught later.
-
+          // Out-of-range errors have already set pos, and will be caught later.
           retval(0) = arg.index_vector ().unmask ();
         }
       else
         {
           boolNDArray v = arg.bool_array_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -73,36 +73,38 @@ computed.  If @qcode{\"upper\"} is given
 integrated from @var{x} to infinity is calculated.  It should be noted that\n\
 \n\
 @example\n\
 gammainc (@var{x}, @var{a}) @equiv{} 1 - gammainc (@var{x}, @var{a}, \"upper\")\n\
 @end example\n\
 @seealso{gamma, gammaln}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  bool lower = true;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  bool lower = true;
   if (nargin == 3)
     {
       std::string s = args(2).xstring_value ("gammainc: third argument must be \"lower\" or \"upper\"");
 
       std::transform (s.begin (), s.end (), s.begin (), tolower);
 
       if (s == "upper")
         lower = false;
-      else if (s != "lower")
+      else if (s == "lower")
+        lower = true;
+      else
         error ("gammainc: third argument must be \"lower\" or \"upper\"");
     }
 
+  octave_value retval;
+
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
 
   // FIXME: Can we make a template version of the duplicated code below
   if (x_arg.is_single_type () || a_arg.is_single_type ())
     {
       if (x_arg.is_scalar_type ())
         {
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -467,34 +467,33 @@ Example code:\n\
 gcd ([15, 9], [20, 18])\n\
    @result{}  5  9\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{lcm, factor, isprime}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargout > 1)
     {
       retval.resize (nargin + 1);
 
       retval(0) = do_extended_gcd (args(0), args(1), retval(1), retval(2));
 
       for (int j = 2; j < nargin; j++)
         {
           octave_value x;
-          retval(0) = do_extended_gcd (retval(0), args(j),
-                                       x, retval(j+1));
+          retval(0) = do_extended_gcd (retval(0), args(j), x, retval(j+1));
           for (int i = 0; i < j; i++)
             retval(i+1).assign (octave_value::op_el_mul_eq, x);
         }
     }
   else
     {
       retval(0) = do_simple_gcd (args(0), args(1));
 
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -66,128 +66,105 @@ DEFUN (getgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 \n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @seealso{setgrent, endgrent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::getgrent may set msg.
   octave_value val = mk_gr_map (octave_group::getgrent (msg));
 
-  retval = ovl (val, msg);
-
-  return retval;
+  return ovl (val, msg);
 }
 
 DEFUN (getgrgid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.\n\
 \n\
 If the group ID does not exist in the database, @code{getgrgid} returns 0.\n\
 @seealso{getgrnam}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   double dval = args(0).double_value ();
 
-  if (D_NINT (dval) == dval)
-    {
-      gid_t gid = static_cast<gid_t> (dval);
-
-      std::string msg;
-
-      // octave_group::getgrgid may set msg.
-      octave_value val = mk_gr_map (octave_group::getgrgid (gid, msg));
-
-      retval = ovl (val, msg);
-    }
-
-  else
+  if (D_NINT (dval) != dval)
     error ("getgrgid: GID must be an integer");
 
-  return retval;
+  gid_t gid = static_cast<gid_t> (dval);
+
+  std::string msg;
+
+  // octave_group::getgrgid may set msg.
+  octave_value val = mk_gr_map (octave_group::getgrgid (gid, msg));
+
+  return ovl (val, msg);
 }
 
 DEFUN (getgrnam, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.\n\
 \n\
 If the group name does not exist in the database, @code{getgrnam} returns 0.\n\
 @seealso{getgrgid}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   std::string s = args(0).string_value ();
 
   std::string msg;
 
   // octave_group::getgrnam may set msg.
   octave_value val = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
 
-  retval = ovl (val, msg);
-
-  return retval;
+  return ovl (val, msg);
 }
 
 DEFUN (setgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @seealso{getgrent, endgrent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::setgrent may set msg.
   int status = octave_group::setgrent (msg);
 
-  retval = ovl (static_cast<double> (status), msg);
-
-  return retval;
+  return ovl (static_cast<double> (status), msg);
 }
 
 DEFUN (endgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} endgrent ()\n\
 Close the group database.\n\
 @seealso{getgrent, setgrent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::endgrent may set msg.
   int status = octave_group::endgrent (msg);
 
-  retval = ovl (static_cast<double> (status), msg);
-
-  return retval;
+  return ovl (static_cast<double> (status), msg);
 }
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -70,127 +70,105 @@ DEFUN (getpwent, args, ,
 @deftypefn {} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary.\n\
 \n\
 Once the end of the data has been reached, @code{getpwent} returns 0.\n\
 @seealso{setpwent, endpwent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::getpwent may set msg.
   octave_value val = mk_pw_map (octave_passwd::getpwent (msg));
 
-  retval = ovl (val, msg);
-
-  return retval;
+  return ovl (val, msg);
 }
 
 DEFUN (getpwuid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.\n\
 \n\
 If the user ID does not exist in the database, @code{getpwuid} returns 0.\n\
 @seealso{getpwnam}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   double dval = args(0).double_value ();
 
-  if (D_NINT (dval) == dval)
-    {
-      uid_t uid = static_cast<uid_t> (dval);
-
-      std::string msg;
-
-      // octave_passwd::getpwuid may set msg.
-      octave_value val = mk_pw_map (octave_passwd::getpwuid (uid, msg));
-
-      retval = ovl (val, msg);
-    }
-  else
+  if (D_NINT (dval) != dval)
     error ("getpwuid: UID must be an integer");
 
-  return retval;
+  uid_t uid = static_cast<uid_t> (dval);
+
+  std::string msg;
+
+  // octave_passwd::getpwuid may set msg.
+  octave_value val = mk_pw_map (octave_passwd::getpwuid (uid, msg));
+
+  return ovl (val, msg);
 }
 
 DEFUN (getpwnam, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.\n\
 \n\
 If the user name does not exist in the database, @code{getpwname} returns 0.\n\
 @seealso{getpwuid}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   std::string s = args(0).string_value ();
 
   std::string msg;
 
   // octave_passwd::getpwnam may set msg.
   octave_value val = mk_pw_map (octave_passwd::getpwnam (s, msg));
 
-  retval = ovl (val, msg);
-
-  return retval;
+  return ovl (val, msg);
 }
 
 DEFUN (setpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @seealso{getpwent, endpwent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::setpwent may set msg.
   int status = octave_passwd::setpwent (msg);
 
-  retval = ovl (static_cast<double> (status), msg);
-
-  return retval;
+  return ovl (static_cast<double> (status), msg);
 }
 
 DEFUN (endpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} endpwent ()\n\
 Close the password database.\n\
 @seealso{getpwent, setpwent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::endpwent may set msg.
   int status = octave_passwd::endpwent (msg);
 
-  retval = ovl (static_cast<double> (status), msg);
-
-  return retval;
+  return ovl (static_cast<double> (status), msg);
 }
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -69,21 +69,21 @@ For example:\n\
 givens (1, 1)\n\
    @result{}   0.70711   0.70711\n\
        -0.70711   0.70711\n\
 @end group\n\
 @end example\n\
 @seealso{planerot}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value_list retval;
+
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
           FloatComplex cx = args(0).float_complex_value ();
           FloatComplex cy = args(1).float_complex_value ();
 
           FloatComplexMatrix result = Givens (cx, cy);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9583,17 +9583,17 @@ false where they are not.\n\
 @seealso{isaxes, isfigure}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (is_handle (args(0)));
+  return ovl (is_handle (args(0)));
 }
 
 static bool
 is_handle_visible (const graphics_handle& h)
 {
   return h.ok () && gh_manager::is_handle_visible (h);
 }
 
@@ -9629,17 +9629,17 @@ DEFUN (__is_handle_visible__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __is_handle_visible__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (is_handle_visible (args(0)));
+  return ovl (is_handle_visible (args(0)));
 }
 
 DEFUN (reset, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} reset (@var{h})\n\
 Reset the properties of the graphic object @var{h} to their default values.\n\
 \n\
 For figures, the properties @qcode{\"position\"}, @qcode{\"units\"},\n\
@@ -9852,110 +9852,89 @@ set (hf, \"paperorientation\")\n\
 @noindent\n\
 shows the paperorientation property can take three values with the default\n\
 being @qcode{\"portrait\"}.\n\
 @seealso{get}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  octave_value retval;
+
   // get vector of graphics handles
   ColumnVector hcv = args(0).xvector_value ("set: H must be a graphics handle");
 
   bool request_drawnow = false;
 
   // loop over graphics objects
   for (octave_idx_type n = 0; n < hcv.numel (); n++)
     {
       graphics_object go = gh_manager::get_object (hcv(n));
 
-      if (go)
-        {
-          if (nargin == 3
-              && args(1).is_cellstr () && args(2).is_cell ())
-            {
-              if (args(2).cell_value ().rows () == 1)
-                {
-                  go.set (args(1).cellstr_value (),
-                          args(2).cell_value (), 0);
-                }
-              else if (hcv.numel () == args(2).cell_value ().rows ())
-                {
-                  go.set (args(1).cellstr_value (),
-                          args(2).cell_value (), n);
-                }
+      if (! go)
+        error ("set: invalid handle (= %g)", hcv(n));
+
+      if (nargin == 3 && args(1).is_cellstr () && args(2).is_cell ())
+        {
+          if (args(2).cell_value ().rows () == 1)
+            go.set (args(1).cellstr_value (), args(2).cell_value (), 0);
+          else if (hcv.numel () == args(2).cell_value ().rows ())
+            go.set (args(1).cellstr_value (), args(2).cell_value (), n);
+          else
+            error ("set: number of graphics handles must match number of value rows (%d != %d)",
+                   hcv.numel (), args(2).cell_value ().rows ());
+        }
+      else if (nargin == 2 && args(1).is_map ())
+        go.set (args(1).map_value ());
+      else if (nargin == 2 && args(1).is_string ())
+        {
+          std::string property = args(1).string_value ();
+
+          octave_map pmap = go.values_as_struct ();
+
+          if (go.has_readonly_property (property))
+            if (nargout != 0)
+              retval = Matrix ();
+            else
+              octave_stdout << "set: " << property
+                            <<" is read-only" << std::endl;
+          else if (pmap.isfield (property))
+            {
+              if (nargout != 0)
+                retval = pmap.getfield (property)(0);
               else
                 {
-                  error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                         hcv.numel (), args(2).cell_value ().rows ());
-                  break;
-
-                }
-            }
-          else if (nargin == 2 && args(1).is_map ())
-            {
-              go.set (args(1).map_value ());
-            }
-          else if (nargin == 2 && args(1).is_string ())
-            {
-              std::string property = args(1).string_value ();
-
-              octave_map pmap = go.values_as_struct ();
-
-              if (go.has_readonly_property (property))
-                if (nargout != 0)
-                  retval = Matrix ();
-                else
-                  octave_stdout << "set: " << property
-                                <<" is read-only" << std::endl;
-              else if (pmap.isfield (property))
-                {
-                  if (nargout != 0)
-                    retval = pmap.getfield (property)(0);
-                  else
-                    {
-                      std::string s = go.value_as_string (property);
-
-                      octave_stdout << s;
-                    }
-                }
-              else
-                {
-                  error ("set: unknown property");
-                  break;
-                }
-            }
-          else if (nargin == 1)
-            {
-              if (nargout != 0)
-                retval = go.values_as_struct ();
-              else
-                {
-                  std::string s = go.values_as_string ();
+                  std::string s = go.value_as_string (property);
 
                   octave_stdout << s;
                 }
             }
           else
-            {
-              go.set (args.splice (0, 1));
-              request_drawnow = true;
+            error ("set: unknown property");
+        }
+      else if (nargin == 1)
+        {
+          if (nargout != 0)
+            retval = go.values_as_struct ();
+          else
+            {
+              std::string s = go.values_as_string ();
+
+              octave_stdout << s;
             }
         }
       else
         {
-          error ("set: invalid handle (= %g)", hcv(n));
-          break;
+          go.set (args.splice (0, 1));
+          request_drawnow = true;
         }
 
       request_drawnow = true;
     }
 
   if (request_drawnow)
     Vdrawnow_requested = true;
 
@@ -9988,108 +9967,90 @@ If @var{p} is omitted, return the comple
 \n\
 If @var{h} is a vector, return a cell array including the property values or\n\
 lists respectively.\n\
 @seealso{set}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
-  Cell vals;
-
   int nargin = args.length ();
 
-  bool use_cell_format = false;
-
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   if (args(0).is_empty ())
-    {
-      retval = Matrix ();
-      return retval;
-    }
+    return ovl (Matrix ());
 
   ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
   octave_idx_type hcv_len = hcv.numel ();
 
   if (nargin == 1 && hcv_len > 1)
     {
       std::string typ0 = get_graphics_object_type (hcv(0));
 
       for (octave_idx_type n = 1; n < hcv_len; n++)
         {
           std::string typ = get_graphics_object_type (hcv(n));
 
           if (typ != typ0)
-            {
-              error ("get: vector of handles must all have the same type");
-              break;
-            }
-        }
-    }
+            error ("get: vector of handles must all have the same type");
+        }
+    }
+
+  octave_value retval;
+  Cell vals;
+  bool use_cell_format = false;
 
   if (nargin > 1 && args(1).is_cellstr ())
     {
       Array<std::string> plist = args(1).cellstr_value ();
 
       octave_idx_type plen = plist.numel ();
 
       use_cell_format = true;
 
       vals.resize (dim_vector (hcv_len, plen));
 
       for (octave_idx_type n = 0; n < hcv_len; n++)
         {
           graphics_object go = gh_manager::get_object (hcv(n));
 
-          if (go)
-            {
-              for (octave_idx_type m = 0; m < plen; m++)
-                {
-                  caseless_str property = plist(m);
-
-                  vals(n, m) = go.get (property);
-                }
-            }
-          else
-            {
-              error ("get: invalid handle (= %g)", hcv(n));
-              break;
+          if (! go)
+            error ("get: invalid handle (= %g)", hcv(n));
+
+          for (octave_idx_type m = 0; m < plen; m++)
+            {
+              caseless_str property = plist(m);
+
+              vals(n, m) = go.get (property);
             }
         }
     }
   else
     {
       caseless_str property;
 
       if (nargin > 1)
         property = args(1).xstring_value ("get: second argument must be property name or cell array of property names");
 
       vals.resize (dim_vector (hcv_len, 1));
 
       for (octave_idx_type n = 0; n < hcv_len; n++)
         {
           graphics_object go = gh_manager::get_object (hcv(n));
 
-          if (go)
-            {
-              if (nargin == 1)
-                vals(n) = go.get ();
-              else
-                vals(n) = go.get (property);
-            }
+          if (! go)
+            error ("get: invalid handle (= %g)", hcv(n));
+
+          if (nargin == 1)
+            vals(n) = go.get ();
           else
-            {
-              error ("get: invalid handle (= %g)", hcv(n));
-              break;
-            }
+            vals(n) = go.get (property);
         }
     }
 
   if (use_cell_format)
     retval = vals;
   else
     {
       octave_idx_type vals_len = vals.numel ();
@@ -10125,50 +10086,45 @@ lists respectively.\n\
 DEFUN (__get__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __get__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
-  Cell vals;
-
   if (args.length () != 1)
     print_usage ();
 
   ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
   octave_idx_type hcv_len = hcv.numel ();
 
-  vals.resize (dim_vector (hcv_len, 1));
+  Cell vals (dim_vector (hcv_len, 1));
+
+//  vals.resize (dim_vector (hcv_len, 1));
 
   for (octave_idx_type n = 0; n < hcv_len; n++)
     {
       graphics_object go = gh_manager::get_object (hcv(n));
 
       if (go)
         vals(n) = go.get (true);
       else
-        {
-          error ("get: invalid handle (= %g)", hcv(n));
-          break;
-        }
+        error ("get: invalid handle (= %g)", hcv(n));
     }
 
   octave_idx_type vals_len = vals.numel ();
 
   if (vals_len > 1)
-    retval = vals;
+    return octave_value (vals);
   else if (vals_len == 1)
-    retval = vals(0);
-
-  return retval;
+    return octave_value (vals(0));
+  else
+    return octave_value_list ();
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
                       bool integer_figure_handle,
                       const octave_value_list& args)
 {
   octave_value retval;
@@ -10236,23 +10192,23 @@ make_graphics_object (const std::string&
 DEFUN (__go_figure__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
   if (args.length () == 0)
     print_usage ();
 
   double val = args(0).xdouble_value ("__go_figure__: figure number must be a double value");
 
+  octave_value retval;
+
   if (is_figure (val))
     {
       graphics_handle h = gh_manager::lookup (val);
 
       xset (h, args.splice (0, 1));
 
       retval = h.value ();
     }
@@ -10290,38 +10246,35 @@ Undocumented internal function.\n\
                                                 int_fig_handle,
                                                 false, false);
 
           if (! int_fig_handle)
             {
               // We need to initialize the integerhandle property
               // without calling the set_integerhandle method,
               // because doing that will generate a new handle value...
-
               graphics_object go = gh_manager::get_object (h);
               go.get_properties ().init_integerhandle ("off");
             }
         }
       else if (val > 0 && D_NINT (val) == val)
         h = gh_manager::make_figure_handle (val, false);
 
-      if (h.ok ())
-        {
-          adopt (0, h);
-
-          gh_manager::push_figure (h);
-
-          xset (h, xargs);
-          xcreatefcn (h);
-          xinitialize (h);
-
-          retval = h.value ();
-        }
-      else
+      if (! h.ok ())
         error ("__go_figure__: failed to create figure handle");
+
+      adopt (0, h);
+
+      gh_manager::push_figure (h);
+
+      xset (h, xargs);
+      xcreatefcn (h);
+      xinitialize (h);
+
+      retval = h.value ();
     }
 
   return retval;
 }
 
 #define GO_BODY(TYPE) \
   gh_manager::auto_lock guard; \
  \
@@ -10511,84 +10464,73 @@ Undocumented internal function.\n\
 DEFUN (__go_delete__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   graphics_handle h = octave_NaN;
 
   const NDArray vals = args(0).xarray_value ("delete: invalid graphics object");
 
-  // Check all the handles to delete are valid first, as callbacks
-  // might delete one of the handles we later want to delete
+  // Check all the handles to delete are valid first,
+  // as callbacks might delete one of the handles we later want to delete.
   for (octave_idx_type i = 0; i < vals.numel (); i++)
     {
       h = gh_manager::lookup (vals(i));
 
       if (! h.ok ())
-        {
-          error ("delete: invalid graphics object (= %g)", vals(i));
-          break;
-        }
+        error ("delete: invalid graphics object (= %g)", vals(i));
     }
 
   delete_graphics_objects (vals);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (__go_axes_init__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_axes_init__ (@var{h}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
   int nargin = args.length ();
 
-  std::string mode = "";
-
-  if (nargin == 2)
-    mode = args(1).string_value ();
-
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  std::string mode;
+  if (nargin == 2)
+    mode = args(1).string_value ();
+
   graphics_handle h = octave_NaN;
 
   double val = args(0).xdouble_value ("__go_axes_init__: invalid graphics object");
 
   h = gh_manager::lookup (val);
 
-  if (h.ok ())
-    {
-      graphics_object go = gh_manager::get_object (h);
-
-      go.set_defaults (mode);
-
-      h = gh_manager::lookup (val);
-      if (! h.ok ())
-        error ("__go_axes_init__: axis deleted during initialization (= %g)",
-               val);
-    }
-  else
+  if (! h.ok ())
     error ("__go_axes_init__: invalid graphics object (= %g)", val);
 
-  return retval;
+  graphics_object go = gh_manager::get_object (h);
+
+  go.set_defaults (mode);
+
+  h = gh_manager::lookup (val);
+  if (! h.ok ())
+    error ("__go_axes_init__: axis deleted during initialization (= %g)", val);
+
+  return octave_value_list ();
 }
 
 DEFUN (__go_handles__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -10620,70 +10562,60 @@ Undocumented internal function.\n\
 
 DEFUN (__go_execute_callback__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   double val = args(0).xdouble_value ("__go_execute_callback__: invalid graphics object");
 
   graphics_handle h = gh_manager::lookup (val);
 
-  if (h.ok ())
-    {
-      std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
-
-      if (nargin == 2)
-        gh_manager::execute_callback (h, name);
-      else
-        gh_manager::execute_callback (h, name, args(2));
-    }
-  else
+  if (! h.ok ())
     error ("__go_execute_callback__: invalid graphics object (= %g)", val);
 
-  return retval;
+  std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
+
+  if (nargin == 2)
+    gh_manager::execute_callback (h, name);
+  else
+    gh_manager::execute_callback (h, name, args(2));
+
+  return octave_value_list ();
 }
 
 DEFUN (__image_pixel_size__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
 Internal function: returns the pixel size of the image in normalized units.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   double h = args(0).xdouble_value ("__image_pixel_size__: argument is not a handle");
 
   graphics_object go = gh_manager::get_object (h);
-  if (go && go.isa ("image"))
-    {
-      image::properties& ip =
-        dynamic_cast<image::properties&> (go.get_properties ());
-
-      Matrix dp = Matrix (1, 2);
-      dp(0) = ip.pixel_xsize ();
-      dp(1) = ip.pixel_ysize ();
-      retval = dp;
-    }
-  else
+  if (! go || ! go.isa ("image"))
     error ("__image_pixel_size__: object is not an image");
 
-  return retval;
+  image::properties& ip =
+    dynamic_cast<image::properties&> (go.get_properties ());
+
+  Matrix dp = Matrix (1, 2);
+  dp(0) = ip.pixel_xsize ();
+  dp(1) = ip.pixel_ysize ();
+  return ovl (dp);
 }
 
 gtk_manager *gtk_manager::instance = 0;
 
 void
 gtk_manager::create_instance (void)
 {
   instance = new gtk_manager ();
@@ -10785,28 +10717,26 @@ Return a cell array of registered graphi
 
 DEFUN (register_graphics_toolkit, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} register_graphics_toolkit (@var{toolkit})\n\
 List @var{toolkit} as an available graphics toolkit.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("register_graphics_toolkit: TOOLKIT must be a string");
 
   gtk_manager::register_toolkit (name);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
@@ -10830,18 +10760,16 @@ updated and no other events or callbacks
 \n\
 The third calling form of @code{drawnow} is for debugging and is\n\
 undocumented.\n\
 @seealso{refresh}\n\
 @end deftypefn")
 {
   static int drawnow_executing = 0;
 
-  octave_value retval;
-
   if (args.length () > 4)
     print_usage ();
 
   gh_manager::lock ();
 
   unwind_protect frame;
 
   frame.protect_var (Vdrawnow_requested, false);
@@ -10888,17 +10816,17 @@ undocumented.\n\
               if (val.compare ("expose"))
                 do_events = false;
               else
                 {
                   error ("drawnow: invalid argument, 'expose' is only valid option");
 
                   gh_manager::unlock ();
 
-                  return retval;
+                  return octave_value_list ();
                 }
             }
 
           if (do_events)
             {
               gh_manager::unlock ();
 
               gh_manager::process_events ();
@@ -10920,25 +10848,25 @@ undocumented.\n\
 
           if (pos_p == std::string::npos &&
               pos_c == std::string::npos)
             {
               error ("drawnow: empty output ''");
 
               gh_manager::unlock ();
 
-              return retval;
+              return octave_value_list ();
             }
           else if (pos_c == std::string::npos)
             {
               error ("drawnow: empty pipe '|'");
 
               gh_manager::unlock ();
 
-              return retval;
+              return octave_value_list ();
             }
           else if (pos_p != std::string::npos && pos_p < pos_c)
             {
               // Strip leading pipe character
               file = file.substr (pos_c);
             }
           else
             {
@@ -10952,17 +10880,17 @@ undocumented.\n\
 
                   if (! (fs && fs.is_dir ()))
                     {
                       error ("drawnow: nonexistent directory '%s'",
                              dirname.c_str ());
 
                       gh_manager::unlock ();
 
-                      return retval;
+                      return octave_value_list ();
                     }
                 }
             }
 
           mono = (args.length () >= 3 ? args(2).xbool_value ("drawnow: MONO colormode must be a boolean value") : false);
 
           debug_file = (args.length () > 3 ? args(3).xstring_value ("drawnow: DEBUG_FILE must be a string") : "");
 
@@ -10989,17 +10917,17 @@ undocumented.\n\
             }
           else
             error ("drawnow: nothing to draw");
         }
     }
 
   gh_manager::unlock ();
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (addlistener, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} addlistener (@var{h}, @var{prop}, @var{fcn})\n\
 Register @var{fcn} as listener for the property @var{prop} of the graphics\n\
 object @var{h}.\n\
 \n\
@@ -11029,44 +10957,42 @@ addlistener (gcf, \"position\", @{@@my_l
 @end group\n\
 @end example\n\
 \n\
 @seealso{addproperty, hggroup}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
-  if (args.length () < 3 || args.length () > 4)
+  int nargin = args.length ();
+
+  if (nargin < 3 || nargin > 4)
     print_usage ();
 
   double h = args(0).xdouble_value ("addlistener: invalid handle H");
 
   std::string pname = args(1).xstring_value ("addlistener: PROP must be a string");
 
   graphics_handle gh = gh_manager::lookup (h);
 
-  if (gh.ok ())
-    {
-      graphics_object go = gh_manager::get_object (gh);
-
-      go.add_property_listener (pname, args(2), POSTSET);
-
-      if (args.length () == 4)
-        {
-          caseless_str persistent = args(3).string_value ();
-          if (persistent.compare ("persistent"))
-            go.add_property_listener (pname, args(2), PERSISTENT);
-        }
-    }
-  else
+  if (! gh.ok ())
     error ("addlistener: invalid graphics object (= %g)", h);
 
-  return retval;
+  graphics_object go = gh_manager::get_object (gh);
+
+  go.add_property_listener (pname, args(2), POSTSET);
+
+  if (args.length () == 4)
+    {
+      caseless_str persistent = args(3).string_value ();
+      if (persistent.compare ("persistent"))
+        go.add_property_listener (pname, args(2), PERSISTENT);
+    }
+
+  return octave_value_list ();
 }
 
 DEFUN (dellistener, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} dellistener (@var{h}, @var{prop}, @var{fcn})\n\
 Remove the registration of @var{fcn} as a listener for the property\n\
 @var{prop} of the graphics object @var{h}.\n\
 \n\
@@ -11089,51 +11015,47 @@ addlistener (gcf, \"position\", c);\n\
 dellistener (gcf, \"position\", c);\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
   if (args.length () < 2 || args.length () > 3)
     print_usage ();
 
   double h = args(0).xdouble_value ("dellistener: invalid handle");
 
   std::string pname = args(1).xstring_value ("dellistener: PROP must be a string");
 
   graphics_handle gh = gh_manager::lookup (h);
 
-  if (gh.ok ())
-    {
-      graphics_object go = gh_manager::get_object (gh);
-
-      if (args.length () == 2)
-        go.delete_property_listener (pname, octave_value (), POSTSET);
+  if (! gh.ok ())
+    error ("dellistener: invalid graphics object (= %g)", h);
+
+  graphics_object go = gh_manager::get_object (gh);
+
+  if (args.length () == 2)
+    go.delete_property_listener (pname, octave_value (), POSTSET);
+  else
+    {
+      if (args(2).is_string ()
+          && args(2).string_value () == "persistent")
+        {
+          go.delete_property_listener (pname, octave_value (),
+                                       PERSISTENT);
+          go.delete_property_listener (pname, octave_value (),
+                                       POSTSET);
+        }
       else
-        {
-          if (args(2).is_string ()
-              && args(2).string_value () == "persistent")
-            {
-              go.delete_property_listener (pname, octave_value (),
-                                           PERSISTENT);
-              go.delete_property_listener (pname, octave_value (),
-                                           POSTSET);
-            }
-          else
-            go.delete_property_listener (pname, args(2), POSTSET);
-        }
-    }
-  else
-    error ("dellistener: invalid graphics object (= %g)", h);
-
-  return retval;
+        go.delete_property_listener (pname, args(2), POSTSET);
+    }
+
+  return octave_value_list ();
 }
 
 DEFUN (addproperty, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} addproperty (@var{name}, @var{h}, @var{type})\n\
 @deftypefnx {} {} addproperty (@var{name}, @var{h}, @var{type}, @var{arg}, @dots{})\n\
 Create a new property named @var{name} in graphics object @var{h}.\n\
 \n\
@@ -11211,54 +11133,46 @@ addproperty (\"my_style\", gcf, \"lineli
     print_usage ();
 
   std::string name = args(0).xstring_value ("addproperty: NAME must be a string");
 
   double h = args(1).xdouble_value ("addproperty: invalid handle H");
 
   graphics_handle gh = gh_manager::lookup (h);
 
-  if (gh.ok ())
-    {
-      graphics_object go = gh_manager::get_object (gh);
-
-      std::string type = args(2).xstring_value ("addproperty: TYPE must be a string");
-
-      if (! go.get_properties ().has_property (name))
-        {
-          property p = property::create (name, gh, type,
-                                         args.splice (0, 3));
-
-          go.get_properties ().insert_property (name, p);
-        }
-      else
-        error ("addproperty: a '%s' property already exists in the graphics object",
-               name.c_str ());
-    }
-  else
+  if (! gh.ok ())
     error ("addproperty: invalid graphics object (= %g)", h);
 
-  return retval;
+  graphics_object go = gh_manager::get_object (gh);
+
+  std::string type = args(2).xstring_value ("addproperty: TYPE must be a string");
+
+  if (go.get_properties ().has_property (name))
+    error ("addproperty: a '%s' property already exists in the graphics object",
+           name.c_str ());
+
+  property p = property::create (name, gh, type, args.splice (0, 3));
+
+  go.get_properties ().insert_property (name, p);
+
+  return octave_value_list ();
 }
 
 octave_value
 get_property_from_handle (double handle, const std::string& property,
                           const std::string& func)
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
   graphics_object go = gh_manager::get_object (handle);
 
-  if (go)
-    retval = go.get (caseless_str (property));
-  else
+  if (! go)
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
-  return retval;
+  return ovl (go.get (caseless_str (property)));
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
   gh_manager::auto_lock guard;
 
@@ -11445,17 +11359,20 @@ In all cases, typing CTRL-C stops progra
   int timeout_index = -1;
 
   int timeout = 0;
 
   if (args.length () > 1)
     {
       pname = args(1).xstring_value ("waitfor: PROP must be a string");
 
-      if (! pname.empty () && ! pname.compare ("timeout"))
+      if (pname.empty ())
+        error ("waitfor: PROP must be a non-empty string");
+
+      if (pname != "timeout")
         {
           if (pname.compare ("\\timeout"))
             pname = "timeout";
 
           static octave_value wf_listener;
 
           if (! wf_listener.is_defined ())
             wf_listener =
@@ -11498,31 +11415,26 @@ In all cases, typing CTRL-C stops progra
 
           graphics_handle gh = gh_manager::lookup (h);
 
           if (gh.ok ())
             {
               graphics_object go = gh_manager::get_object (gh);
 
               if (max_arg_index >= 2
-                  && compare_property_values (go.get (pname),
-                                              args(2)))
+                  && compare_property_values (go.get (pname), args(2)))
                 waitfor_results[id] = true;
               else
                 {
 
-                  frame.add_fcn (cleanup_waitfor_postset_listener,
-                                 ov_listener);
-                  go.add_property_listener (pname, ov_listener,
-                                            POSTSET);
-                  go.add_property_listener (pname, ov_listener,
-                                            PERSISTENT);
-
-                  if (go.get_properties ()
-                      .has_dynamic_property (pname))
+                  frame.add_fcn (cleanup_waitfor_postset_listener, ov_listener);
+                  go.add_property_listener (pname, ov_listener, POSTSET);
+                  go.add_property_listener (pname, ov_listener, PERSISTENT);
+
+                  if (go.get_properties ().has_dynamic_property (pname))
                     {
                       static octave_value wf_del_listener;
 
                       if (! wf_del_listener.is_defined ())
                         wf_del_listener =
                           octave_value (new octave_builtin
                                         (waitfor_del_listener,
                                          "waitfor_del_listener"));
@@ -11539,18 +11451,16 @@ In all cases, typing CTRL-C stops progra
                       frame.add_fcn (cleanup_waitfor_predelete_listener,
                                      ov_del_listener);
                       go.add_property_listener (pname, ov_del_listener,
                                                 PREDELETE);
                     }
                 }
             }
         }
-      else if (pname.empty ())
-        error ("waitfor: PROP must be a non-empty string");
     }
 
   if (timeout_index < 0 && args.length () > (max_arg_index + 1))
     {
       caseless_str s = args(max_arg_index + 1).xstring_value ("waitfor: invalid parameter, expected 'timeout'");
 
       if (s.compare ("timeout"))
         timeout_index = max_arg_index + 1;
@@ -11620,29 +11530,27 @@ In all cases, typing CTRL-C stops progra
 
       if (timeout > 0)
         {
           if (start + timeout < time (0))
             break;
         }
     }
 
-  return octave_value ();
+  return octave_value_list ();
 }
 
 DEFUN (__zoom__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __zoom__ (@var{axes}, @var{mode}, @var{factor})\n\
 @deftypefnx {} {} __zoom__ (@var{axes}, \"out\")\n\
 @deftypefnx {} {} __zoom__ (@var{axes}, \"reset\")\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
     print_usage ();
 
   double h = args(0).double_value ();
 
   gh_manager::auto_lock guard;
@@ -11676,11 +11584,11 @@ Undocumented internal function.\n\
     {
       std::string mode = args(1).string_value ();
       double factor = args(2).scalar_value ();
 
       ax_props.zoom (mode, factor);
       Vdrawnow_requested = true;
     }
 
-  return retval;
-}
-
+  return octave_value_list ();
+}
+
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1084,31 +1084,26 @@ DEFUN (get_help_text, args, , "-*- texin
 Return the raw help text of function @var{name}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text_from_file}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
 
-  std::string text;
-  std::string format;
+  std::string text, format;
 
   do_get_help_text (name, text, format);
 
-  retval = ovl (text, format);
-
-  return retval;
+  return ovl (text, format);
 }
 
 static void
 do_get_help_text_from_file (const std::string& fname, std::string& text,
                             std::string& format)
 {
   bool symbol_found = false;
 
@@ -1146,31 +1141,26 @@ DEFUN (get_help_text_from_file, args, ,
 Return the raw help text from the file @var{fname}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
 
-  std::string text;
-  std::string format;
+  std::string text, format;
 
   do_get_help_text_from_file (fname, text, format);
 
-  retval = ovl (text, format);
-
-  return retval;
+  return ovl (text, format);
 }
 
 // Return a cell array of strings containing the names of all
 // operators.
 
 DEFUN (__operators__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __operators__ ()\n\
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -59,39 +59,39 @@ transposition) and @var{H} is upper Hess
 \n\
 The Hessenberg decomposition is usually used as the first step in an\n\
 eigenvalue computation, but has other applications as well\n\
 (see @nospell{Golub, Nash, and Van Loan},\n\
 IEEE Transactions on Automatic Control, 1979).\n\
 @seealso{eig, chol, lu, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
   if (arg_is_empty < 0)
-    return retval;
+    return octave_value_list ();
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("hess");
-      return retval;
+      return octave_value_list ();
     }
 
+  octave_value_list retval;
+
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           FloatHESS result (tmp);
 
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -60,128 +60,120 @@ hexadecimal string.  For example:\n\
 @group\n\
 hex2num ([\"402df854\"; \"41200000\"], \"single\")\n\
    @result{} [2.7183; 10.000]\n\
 @end group\n\
 @end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   if (nargin == 2 && ! args(1).is_string ())
     error ("hex2num: CLASS must be a string");
+
+  const charMatrix cmat = args(0).char_matrix_value ();
+  std::string prec = (nargin == 2) ? args(1).string_value () : "double";
+  bool is_single = (prec == "single");
+  octave_idx_type nchars = (is_single) ? 8 : 16;
+
+  if (cmat.columns () > nchars)
+    error ("hex2num: S must be no more than %d characters", nchars);
+  else if (prec != "double" && prec != "single")
+    error ("hex2num: CLASS must be either \"double\" or \"single\"");
+
+  octave_value retval;
+  octave_idx_type nr = cmat.rows ();
+  octave_idx_type nc = cmat.columns ();
+
+  if (is_single)
+    {
+      FloatColumnVector m (nr);
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          union
+          {
+            uint32_t ival;
+            float dval;
+          } num;
+
+          num.ival = 0;
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              unsigned char ch = cmat.elem (i, j);
+
+              if (isxdigit (ch))
+                {
+                  num.ival <<= 4;
+                  if (ch >= 'a')
+                    num.ival += static_cast<uint32_t> (ch - 'a' + 10);
+                  else if (ch >= 'A')
+                    num.ival += static_cast<uint32_t> (ch - 'A' + 10);
+                  else
+                    num.ival += static_cast<uint32_t> (ch - '0');
+                }
+              else
+                {
+                  error ("hex2num: illegal character found in string S");
+                  break;
+                }
+            }
+
+          if (nc < nchars)
+            num.ival <<= (nchars - nc) * 4;
+
+          m(i) = num.dval;
+        }
+
+      retval =  m;
+    }
   else
     {
-      const charMatrix cmat = args(0).char_matrix_value ();
-      std::string prec = (nargin == 2) ? args(1).string_value () : "double";
-      bool is_single = (prec == "single");
-      octave_idx_type nchars = (is_single) ? 8 : 16;
-
-      if (cmat.columns () > nchars)
-        error ("hex2num: S must be no more than %d characters", nchars);
-      else if (prec != "double" && prec != "single")
-        error ("hex2num: CLASS must be either \"double\" or \"single\"");
-      else
-        {
-          octave_idx_type nr = cmat.rows ();
-          octave_idx_type nc = cmat.columns ();
-
-          if (is_single)
-            {
-              FloatColumnVector m (nr);
+      ColumnVector m (nr);
 
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  union
-                  {
-                    uint32_t ival;
-                    float dval;
-                  } num;
-
-                  num.ival = 0;
-
-                  for (octave_idx_type j = 0; j < nc; j++)
-                    {
-                      unsigned char ch = cmat.elem (i, j);
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          union
+          {
+            uint64_t ival;
+            double dval;
+          } num;
 
-                      if (isxdigit (ch))
-                        {
-                          num.ival <<= 4;
-                          if (ch >= 'a')
-                            num.ival += static_cast<uint32_t> (ch - 'a' + 10);
-                          else if (ch >= 'A')
-                            num.ival += static_cast<uint32_t> (ch - 'A' + 10);
-                          else
-                            num.ival += static_cast<uint32_t> (ch - '0');
-                        }
-                      else
-                        {
-                          error ("hex2num: illegal character found in string S");
-                          break;
-                        }
-                    }
+          num.ival = 0;
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              unsigned char ch = cmat.elem (i, j);
 
-                  if (nc < nchars)
-                    num.ival <<= (nchars - nc) * 4;
-
-                  m(i) = num.dval;
+              if (isxdigit (ch))
+                {
+                  num.ival <<= 4;
+                  if (ch >= 'a')
+                    num.ival += static_cast<uint64_t> (ch - 'a' + 10);
+                  else if (ch >= 'A')
+                    num.ival += static_cast<uint64_t> (ch - 'A' + 10);
+                  else
+                    num.ival += static_cast<uint64_t> (ch - '0');
                 }
-
-              retval =  m;
+              else
+                error ("hex2num: illegal character found in string S");
             }
-          else
-            {
-              ColumnVector m (nr);
-
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  union
-                  {
-                    uint64_t ival;
-                    double dval;
-                  } num;
-
-                  num.ival = 0;
-
-                  for (octave_idx_type j = 0; j < nc; j++)
-                    {
-                      unsigned char ch = cmat.elem (i, j);
 
-                      if (isxdigit (ch))
-                        {
-                          num.ival <<= 4;
-                          if (ch >= 'a')
-                            num.ival += static_cast<uint64_t> (ch - 'a' + 10);
-                          else if (ch >= 'A')
-                            num.ival += static_cast<uint64_t> (ch - 'A' + 10);
-                          else
-                            num.ival += static_cast<uint64_t> (ch - '0');
-                        }
-                      else
-                        {
-                          error ("hex2num: illegal character found in string S");
-                          break;
-                        }
-                    }
+          if (nc < nchars)
+            num.ival <<= (nchars - nc) * 4;
 
-                  if (nc < nchars)
-                    num.ival <<= (nchars - nc) * 4;
+          m(i) = num.dval;
+        }
 
-                  m(i) = num.dval;
-                }
-
-              retval =  m;
-            }
-        }
+      retval =  m;
     }
 
   return retval;
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 %!assert (hex2num (["c00";"bf8";"000";"3f8";"400"], "single"), single([-2:2])')
@@ -215,21 +207,21 @@ num2hex (single ([-1, 1, e, Inf]))\n\
     3f800000\n\
     402df854\n\
     7f800000\"\n\
 @end group\n\
 @end example\n\
 @seealso{hex2num, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   if (args(0).is_single_type ())
     {
       const FloatColumnVector v (args(0).float_vector_value ());
 
       octave_idx_type nchars = 8;
       octave_idx_type nr = v.numel ();
       charMatrix m (nr, nchars);
       const float *pv = v.fortran_vec ();
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -908,18 +908,16 @@ within a function, and to assign new val
 prompt and return to normal execution type @samp{return} or @samp{dbcont}.\n\
 The @code{keyboard} function does not return an exit status.\n\
 \n\
 If @code{keyboard} is invoked without arguments, a default prompt of\n\
 @samp{debug> } is used.\n\
 @seealso{dbstop, dbcont, dbquit}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () > 1)
     print_usage ();
 
   unwind_protect frame;
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
@@ -928,17 +926,17 @@ If @code{keyboard} is invoked without ar
 
   tree_evaluator::debug_mode = true;
   tree_evaluator::quiet_breakpoint_flag = false;
 
   tree_evaluator::current_frame = octave_call_stack::current_frame ();
 
   do_keyboard (args);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (echo, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} echo\n\
 @deftypefnx {} {} echo on\n\
 @deftypefnx {} {} echo off\n\
 @deftypefnx {} {} echo on all\n\
@@ -964,65 +962,65 @@ functions.\n\
 @end table\n\
 \n\
 @noindent\n\
 With no arguments, @code{echo} toggles the current echo state.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  string_vector argv = args.make_argv ("echo");
+  string_vector argv = args.make_argv ("");
 
   switch (args.length ())
     {
     case 0:
       {
         if ((Vecho_executing_commands & ECHO_SCRIPTS)
             || (Vecho_executing_commands & ECHO_FUNCTIONS))
           Vecho_executing_commands = ECHO_OFF;
         else
           Vecho_executing_commands = ECHO_SCRIPTS;
       }
       break;
 
     case 1:
       {
-        std::string arg = argv[1];
+        std::string arg = argv[0];
 
         if (arg == "on")
           Vecho_executing_commands = ECHO_SCRIPTS;
         else if (arg == "off")
           Vecho_executing_commands = ECHO_OFF;
         else
           print_usage ();
       }
       break;
 
     case 2:
       {
-        std::string arg = argv[1];
+        std::string arg = argv[0];
 
-        if (arg == "on" && argv[2] == "all")
+        if (arg == "on" && argv[1] == "all")
           {
             int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
             Vecho_executing_commands = tmp;
           }
-        else if (arg == "off" && argv[2] == "all")
+        else if (arg == "off" && argv[1] == "all")
           Vecho_executing_commands = ECHO_OFF;
         else
           print_usage ();
       }
       break;
 
     default:
       print_usage ();
       break;
     }
 
-  return retval;
+  return octave_value_list ();
 }
 
 /*
 %!test
 %! state = echo_executing_commands ();
 %! unwind_protect
 %!   echo ();
 %!   s1 = echo_executing_commands ();
@@ -1042,17 +1040,17 @@ With no arguments, @code{echo} toggles t
 %!   echo ("on");
 %!   assert (echo_executing_commands () != 0);
 %!   echo ("off");
 %!   assert (echo_executing_commands () == 0);
 %! unwind_protect_cleanup
 %!   echo_executing_commands (state);
 %! end_unwind_protect
 
-%!#test  # FIXME: Uncommend when ug #45209 is fixed
+%!#test  # FIXME: This passes, but produces a lot of onscreen output
 %! state = echo_executing_commands ();
 %! unwind_protect
 %!   echo ("on", "all");
 %!   assert (echo_executing_commands () != 0);
 %!   echo ("off", "all");
 %!   assert (echo_executing_commands () == 0);
 %! unwind_protect_cleanup
 %!   echo_executing_commands (state);
@@ -1082,21 +1080,21 @@ DEFUN (completion_matches, args, nargout
 Generate possible completions given @var{hint}.\n\
 \n\
 This function is provided for the benefit of programs like Emacs which\n\
 might be controlling Octave and handling user input.  The current\n\
 command number is not incremented when this function is called.  This is\n\
 a feature, not a bug.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   std::string hint = args(0).string_value ();
 
   int n = 32;
 
   string_vector list (n);
 
   int k = 0;
 
@@ -1168,53 +1166,49 @@ Read the readline library initialization
 If @var{file} is omitted, read the default initialization file\n\
 (normally @file{~/.inputrc}).\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_re_read_init_file}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 0)
     command_editor::read_init_file ();
   else
     {
       std::string file = args(0).string_value ();
 
       command_editor::read_init_file (file);
     }
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (readline_re_read_init_file, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} readline_re_read_init_file ()\n\
 Re-read the last readline library initialization file that was read.\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_read_init_file}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   command_editor::re_read_init_file ();
 
-  return retval;
+  return octave_value_list ();
 }
 
 static int
 internal_input_event_hook_fcn (void)
 {
   input_event_hook_functions.run ();
 
   if (input_event_hook_functions.empty ())
@@ -1268,18 +1262,16 @@ DEFUN (remove_input_event_hook, args, ,
 @deftypefn  {} {} remove_input_event_hook (@var{name})\n\
 @deftypefnx {} {} remove_input_event_hook (@var{fcn_id})\n\
 Remove the named function or function handle with the given identifier\n\
 from the list of functions to call periodically when Octave is waiting\n\
 for input.\n\
 @seealso{add_input_event_hook}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string hook_fcn_id = args(0).string_value ("remove_input_event_hook: argument not valid as a hook function name or id");
 
   bool warn = (nargin < 2);
@@ -1291,17 +1283,17 @@ for input.\n\
     input_event_hook_functions.erase (p);
   else if (warn)
     warning ("remove_input_event_hook: %s not found in list",
              hook_fcn_id.c_str ());
 
   if (input_event_hook_functions.empty ())
     command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (PS1, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} PS1 ()\n\
 @deftypefnx {} {@var{old_val} =} PS1 (@var{new_val})\n\
 @deftypefnx {} {} PS1 (@var{new_val}, \"local\")\n\
 Query or set the primary prompt string.\n\
@@ -1437,50 +1429,48 @@ The original variable value is restored 
 
 DEFUN (__request_drawnow__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __request_drawnow__ ()\n\
 @deftypefnx {} {} __request_drawnow__ (@var{flag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 0)
     Vdrawnow_requested = true;
   else
     Vdrawnow_requested = args(0).bool_value ();
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (__gud_mode__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __gud_mode__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargin == 0)
-    retval = Vgud_mode;
+    retval = ovl (Vgud_mode);
   else
     Vgud_mode = args(0).bool_value ();
 
-  return retval;
+  return retval; 
 }
 
 DEFUN (filemarker, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} filemarker ()\n\
 @deftypefnx {} {@var{old_val} =} filemarker (@var{new_val})\n\
 @deftypefnx {} {} filemarker (@var{new_val}, \"local\")\n\
 Query or set the character used to separate the filename from the subfunction\n\
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -259,23 +259,23 @@ If there are more than two input argumen
 @example\n\
 kron (kron (@var{A1}, @var{A2}), @dots{}, @var{An})\n\
 @end example\n\
 \n\
 @noindent\n\
 Since the Kronecker product is associative, this is well-defined.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value retval;
+
   octave_value a = args(0);
   octave_value b = args(1);
 
   retval = dispatch_kron (a, b);
 
   for (octave_idx_type i = 2; i < nargin; i++)
     retval = dispatch_kron (retval, args(i));
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2236,23 +2236,23 @@ DEFUN (genpath, args, ,
 @deftypefn  {} {} genpath (@var{dir})\n\
 @deftypefnx {} {} genpath (@var{dir}, @var{skip}, @dots{})\n\
 Return a path constructed from @var{dir} and all its subdirectories.\n\
 \n\
 If additional string parameters are given, the resulting path will exclude\n\
 directories with those names.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       std::string dirname = args(0).xstring_value ("genpath: DIR must be a string");
 
       retval = genpath (dirname);
     }
   else
     {
@@ -2401,29 +2401,29 @@ In addition to accepting individual dire
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
 addpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   // Originally written by Bill Denney and Etienne Grossman.  Heavily
   // modified and translated to C++ by jwe.
 
-  if (nargout > 0)
-    retval = load_path::path ();
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  octave_value retval;
+
+  if (nargout > 0)
+    retval = load_path::path ();
+
   bool append = false;
 
   octave_value option_arg = args(nargin-1);
 
   if (option_arg.is_string ())
     {
       std::string option = option_arg.string_value ();
 
@@ -2497,26 +2497,26 @@ directory names separated by @code{paths
 rmpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, addpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   // Originally written by Etienne Grossmann.  Heavily modified and translated
   // to C++ by jwe.
 
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    print_usage ();
+
   octave_value retval;
 
   if (nargout > 0)
     retval = load_path::path ();
 
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    print_usage ();
-
   bool need_to_update = false;
 
   for (int i = 0; i < nargin; i++)
     {
       std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
       std::list<std::string> dir_elts = split_path (arg);
 
       for (std::list<std::string>::const_iterator p = dir_elts.begin ();
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1577,47 +1577,44 @@ save -binary data a b*\n\
 @end example\n\
 \n\
 @noindent\n\
 saves the variable @samp{a} and all variables beginning with @samp{b} to\n\
 the file @file{data} in Octave's binary format.\n\
 @seealso{load, save_default_options, save_header_format_string, dlmread, csvread, fread}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-  string_vector argv = args.make_argv ();
-
   // Here is where we would get the default save format if it were
   // stored in a user preference variable.
-
+  load_save_format format = LS_TEXT;
   bool save_as_floats = false;
-
-  load_save_format format = LS_TEXT;
-
   bool append = false;
-
   bool use_zlib = false;
 
   // get default options
   parse_save_options (Vsave_default_options, format, append, save_as_floats,
                       use_zlib);
 
   // override from command line
+  string_vector argv = args.make_argv ();
+
   argv = parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
+
   int argc = argv.numel ();
   int i = 0;
 
   if (i == argc)
     print_usage ();
 
   if (save_as_floats && format == LS_TEXT)
     error ("save: cannot specify both -text and -float-binary");
 
+  octave_value_list retval;
+
   if (argv[i] == "-")
     {
       i++;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         error ("save: cannot write HDF5 format to stdout");
       else
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -233,63 +233,59 @@ at least 1)\n\
 \n\
 @item r\n\
 For numeric lookups\n\
 the rightmost subinterval shall be extended to infinity (i.e., all indices\n\
 at most n-1).\n\
 @end table\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3 || (nargin == 3 && ! args(2).is_string ()))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value table = args(0);
   octave_value y = args(1);
   if (table.ndims () > 2 || (table.columns () > 1 && table.rows () > 1))
     warning ("lookup: table is not a vector");
 
+  octave_value retval;
+
   bool num_case = ((table.is_numeric_type () && y.is_numeric_type ())
                    || (table.is_char_matrix () && y.is_char_matrix ()));
   bool str_case = table.is_cellstr () && (y.is_string () || y.is_cellstr ());
   bool left_inf = false;
   bool right_inf = false;
   bool match_idx = false;
   bool match_bool = false;
 
   if (nargin == 3)
     {
-      std::string opt = args(2).string_value ();
+      std::string opt = args(2).xstring_value ("lookup: OPT must be a string");
       left_inf = contains_char (opt, 'l');
       right_inf = contains_char (opt, 'r');
       match_idx = contains_char (opt, 'm');
       match_bool = contains_char (opt, 'b');
       if (opt.find_first_not_of ("lrmb") != std::string::npos)
-        {
-          error ("lookup: unrecognized option: %c",
-                 opt[opt.find_first_not_of ("lrmb")]);
-          return retval;
-        }
+        error ("lookup: unrecognized option: %c",
+               opt[opt.find_first_not_of ("lrmb")]);
     }
 
   if ((match_idx || match_bool) && (left_inf || right_inf))
     error ("lookup: m, b cannot be specified with l or r");
   else if (match_idx && match_bool)
     error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
     error ("lookup: l, r are not recognized for string lookups");
 
   if (num_case)
     {
       // In the case of a complex array, absolute values will be used for
       // compatibility (though it's not too meaningful).
-
       if (table.is_complex_type ())
         table = table.abs ();
 
       if (y.is_complex_type ())
         y = y.abs ();
 
       Array<octave_idx_type> idx;
 
@@ -360,17 +356,16 @@ at most n-1).\n\
         }
       else
         retval = idx;
     }
   else
     print_usage ();
 
   return retval;
-
 }
 
 /*
 %!assert (lookup (1:3, 0.5), 0)     # value before table
 %!assert (lookup (1:3, 3.5), 3)     # value after table error
 %!assert (lookup (1:3, 1.5), 1)     # value within table error
 %!assert (lookup (1:3, [3,2,1]), [3,2,1])
 %!assert (lookup ([1:4]', [1.2, 3.5]'), [1, 3]')
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -58,17 +58,17 @@ abs (3 + 4i)\n\
 @end group\n\
 @end example\n\
 @seealso{arg}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).abs ());
+  return ovl (args(0).abs ());
 }
 
 /*
 %!assert (abs (1), 1)
 %!assert (abs (-3.5), 3.5)
 %!assert (abs (3+4i), 5)
 %!assert (abs (3-4i), 5)
 %!assert (abs ([1.1, 3i; 3+4i, -3-4i]), [1.1, 3; 5, 5])
@@ -88,17 +88,17 @@ DEFUN (acos, args, ,
 @deftypefn {} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).acos ());
+  return ovl (args(0).acos ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -134,17 +134,17 @@ DEFUN (acosh, args, ,
 @deftypefn {} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).acosh ());
+  return ovl (args(0).acosh ());
 }
 
 /*
 %!test
 %! x = [1, 0, -1, 0];
 %! v = [0, pi/2*i, pi*i, pi/2*i];
 %! assert (acosh (x), v, sqrt (eps));
 
@@ -173,17 +173,17 @@ DEFUN (angle, args, ,
 @deftypefn {} {} angle (@var{z})\n\
 See @code{arg}.\n\
 @seealso{arg}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).arg ());
+  return ovl (args(0).arg ());
 }
 
 DEFUN (arg, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} arg (@var{z})\n\
 @deftypefnx {} {} angle (@var{z})\n\
 Compute the argument, i.e., angle of @var{z}.\n\
 \n\
@@ -205,17 +205,17 @@ arg (3 + 4i)\n\
 @end group\n\
 @end example\n\
 @seealso{abs}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).arg ());
+  return ovl (args(0).arg ());
 }
 
 /*
 %!assert (arg (1), 0)
 %!assert (arg (i), pi/2)
 %!assert (arg (-1), pi)
 %!assert (arg (-i), -pi/2)
 %!assert (arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2])
@@ -241,17 +241,17 @@ DEFUN (asin, args, ,
 @deftypefn {} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).asin ());
+  return ovl (args(0).asin ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -286,17 +286,17 @@ DEFUN (asinh, args, ,
 @deftypefn {} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).asinh ());
+  return ovl (args(0).asinh ());
 }
 
 /*
 %!test
 %! v = [0, pi/2*i, 0, -pi/2*i];
 %! x = [0, i, 0, -i];
 %! assert (asinh (x), v,  sqrt (eps));
 
@@ -314,17 +314,17 @@ DEFUN (atan, args, ,
 @deftypefn {} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).atan ());
+  return ovl (args(0).atan ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -346,17 +346,17 @@ DEFUN (atanh, args, ,
 @deftypefn {} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).atanh ());
+  return ovl (args(0).atanh ());
 }
 
 /*
 %!test
 %! v = [0, 0];
 %! x = [0, 0];
 %! assert (atanh (x), v, sqrt (eps));
 
@@ -377,17 +377,17 @@ Compute the real cube root of each eleme
 Unlike @code{@var{x}^(1/3)}, the result will be negative if @var{x} is\n\
 negative.\n\
 @seealso{nthroot}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).cbrt ());
+  return ovl (args(0).cbrt ());
 }
 
 /*
 %!assert (cbrt (64), 4)
 %!assert (cbrt (-125), -5)
 %!assert (cbrt (0), 0)
 %!assert (cbrt (Inf), Inf)
 %!assert (cbrt (-Inf), -Inf)
@@ -416,17 +416,17 @@ ceil ([-2.7, 2.7])\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).ceil ());
+  return ovl (args(0).ceil ());
 }
 
 /*
 ## double precision
 %!assert (ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1])
 
 ## complex double precison
 %!assert (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i])
@@ -454,17 +454,17 @@ The complex conjugate is defined as\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifnottex\n\
 @seealso{real, imag}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).conj ());
+  return ovl (args(0).conj ());
 }
 
 /*
 %!assert (conj (1), 1)
 %!assert (conj (i), -i)
 %!assert (conj (1+i), 1-i)
 %!assert (conj (1-i), 1+i)
 %!assert (conj ([-1, -i; -1+i, -1-i]), [-1, i; -1-i, -1+i])
@@ -484,17 +484,17 @@ DEFUN (cos, args, ,
 @deftypefn {} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).cos ());
+  return ovl (args(0).cos ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -518,17 +518,17 @@ DEFUN (cosh, args, ,
 @deftypefn {} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).cosh ());
+  return ovl (args(0).cosh ());
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [1, 0, -1, 0];
 %! assert (cosh (x), v, sqrt (eps));
 
@@ -566,17 +566,17 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erfcx, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erf ());
+  return ovl (args(0).erf ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erf (a), erf (real (a)));
 
 %!test
@@ -621,17 +621,17 @@ The inverse error function is defined su
 erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx, erfi, dawson, erfcinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erfinv ());
+  return ovl (args(0).erfinv ());
 }
 
 /*
 ## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
 %!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), eps ("single"))
 ## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
@@ -658,17 +658,17 @@ The inverse complementary error function
 erfc (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erfc, erf, erfcx, erfi, dawson, erfinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erfcinv ());
+  return ovl (args(0).erfcinv ());
 }
 
 /*
 ## middle region
 %!assert (erfc (erfcinv ([1.9 1.3 1 0.6 0.2])), [1.9 1.3 1 0.6 0.2], eps)
 %!assert (erfc (erfcinv (single ([1.9 1.3 1 0.6 0.2]))), single ([1.9 1.3 1 0.6 0.2]), eps ("single"))
 ## tail region
 %!assert (erfc (erfcinv ([0.001 0.01 1.9999 1.99999])), [0.001 0.01 1.9999 1.99999], eps)
@@ -697,17 +697,17 @@ The complementary error function is defi
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
 @seealso{erfcinv, erfcx, erfi, dawson, erf, erfinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erfc ());
+  return ovl (args(0).erfc ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erfc (a), erfc (real (a)));
 
 %!error erfc ()
@@ -733,17 +733,17 @@ exp (z^2) * erfc (z)\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erfcx ());
+  return ovl (args(0).erfcx ());
 }
 
 /*
 
 %!test
 %! x = [1+2i,-1+2i,1e-6+2e-6i,0+2i];
 %! assert (erfcx (x), exp (x.^2) .* erfc(x), -1.e-10);
 
@@ -775,17 +775,17 @@ The imaginary error function is defined 
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfcx, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).erfi ());
+  return ovl (args(0).erfi ());
 }
 
 /*
 
 %!test
 %! x = [-0.1, 0.1, 1, 1+2i,-1+2i,1e-6+2e-6i,0+2i];
 %! assert (erfi (x), -i * erf(i*x), -1.e-10);
 
@@ -812,17 +812,17 @@ The Dawson function is defined as\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfcx, erfi, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).dawson ());
+  return ovl (args(0).dawson ());
 }
 
 /*
 
 %!test
 %! x = [0.1, 1, 1+2i,-1+2i,1e-4+2e-4i,0+2i];
 %! v = [0.099335992397852861, 0.53807950691, -13.38892731648-11.828715104i, 13.38892731648-11.828715104i, 0.0001000000073333+0.000200000001333i, 48.160012114291i];
 %! assert (dawson (x), v, -1.e-10);
@@ -846,17 +846,17 @@ for each element of @var{x}.\n\
 \n\
 To compute the matrix exponential, see @ref{Linear Algebra}.\n\
 @seealso{log}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).exp ());
+  return ovl (args(0).exp ());
 }
 
 /*
 %!assert (exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps))
 %!assert (exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps))
 %!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ("single")))
 %!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ("single")))
 
@@ -879,17 +879,17 @@ Compute\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{exp}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).expm1 ());
+  return ovl (args(0).expm1 ());
 }
 
 /*
 %!assert (expm1 (2*eps), 2*eps, 1e-29)
 
 %!assert (expm1 ([Inf, -Inf, NaN]), [Inf -1 NaN])
 %!assert (expm1 (single ([Inf, -Inf, NaN])), single ([Inf -1 NaN]))
 
@@ -912,17 +912,17 @@ isfinite ([13, Inf, NA, NaN])\n\
 @end group\n\
 @end example\n\
 @seealso{isinf, isnan, isna}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).finite ());
+  return ovl (args(0).finite ());
 }
 
 /*
 %!assert (!isfinite (Inf))
 %!assert (!isfinite (NaN))
 %!assert (isfinite (rand (1,10)))
 
 %!assert (!isfinite (single (Inf)))
@@ -948,17 +948,17 @@ fix ([-2.7, 2.7])\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).fix ());
+  return ovl (args(0).fix ());
 }
 
 /*
 %!assert (fix ([1.1, 1, -1.1, -1]), [1, 1, -1, -1])
 %!assert (fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]), [1+i, 1+i, -1-i, -1-i])
 %!assert (fix (single ([1.1, 1, -1.1, -1])), single ([1, 1, -1, -1]))
 %!assert (fix (single ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single ([1+i, 1+i, -1-i, -1-i]))
 
@@ -981,17 +981,17 @@ floor ([-2.7, 2.7])\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).floor ());
+  return ovl (args(0).floor ());
 }
 
 /*
 %!assert (floor ([2, 1.1, -1.1, -1]), [2, 1, -2, -1])
 %!assert (floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 1+i, -2-2i, -1-i])
 %!assert (floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]))
 %!assert (floor (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 1+i, -2-2i, -1-i]))
 
@@ -1030,17 +1030,17 @@ logarithm of the gamma function (@code{g
 loss of precision.  The final result is then\n\
 @code{exp (@var{result_using_gammaln}).}\n\
 @seealso{gammainc, gammaln, factorial}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).gamma ());
+  return ovl (args(0).gamma ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (gamma (a), gamma (real (a)));
 
 %!test
@@ -1073,17 +1073,17 @@ DEFUN (imag, args, ,
 @deftypefn {} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).imag ());
+  return ovl (args(0).imag ());
 }
 
 /*
 %!assert (imag (1), 0)
 %!assert (imag (i), 1)
 %!assert (imag (1+i), 1)
 %!assert (imag ([i, 1; 1, i]), full (eye (2)))
 
@@ -1104,17 +1104,17 @@ letters or digits and false where they a
 \n\
 This is equivalent to (@code{isalpha (@var{s}) | isdigit (@var{s})}).\n\
 @seealso{isalpha, isdigit, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisalnum ());
+  return ovl (args(0).xisalnum ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
@@ -1133,17 +1133,17 @@ letters and false where they are not.\n\
 \n\
 This is equivalent to (@code{islower (@var{s}) | isupper (@var{s})}).\n\
 @seealso{isdigit, ispunct, isspace, iscntrl, isalnum, islower, isupper}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisalpha ());
+  return ovl (args(0).xisalpha ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
@@ -1159,17 +1159,17 @@ DEFUNX ("isascii", Fisascii, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 ASCII characters (in the range 0 to 127 decimal) and false where they are\n\
 not.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisascii ());
+  return ovl (args(0).xisascii ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = true (1, 128);
 %! assert (isascii (charset), result);
 
@@ -1183,17 +1183,17 @@ DEFUNX ("iscntrl", Fiscntrl, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 control characters and false where they are not.\n\
 @seealso{ispunct, isspace, isalpha, isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xiscntrl ());
+  return ovl (args(0).xiscntrl ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(1:32) = true;
 %! result(128) = true;
@@ -1209,17 +1209,17 @@ DEFUNX ("isdigit", Fisdigit, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 decimal digits (0-9) and false where they are not.\n\
 @seealso{isxdigit, isalpha, isletter, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisdigit ());
+  return ovl (args(0).xisdigit ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("0":"9") + 1) = true;
 %! assert (isdigit (charset), result);
@@ -1243,17 +1243,17 @@ isinf ([13, Inf, NA, NaN])\n\
 @end group\n\
 @end example\n\
 @seealso{isfinite, isnan, isna}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).isinf ());
+  return ovl (args(0).isinf ());
 }
 
 /*
 %!assert (isinf (Inf))
 %!assert (!isinf (NaN))
 %!assert (!isinf (NA))
 %!assert (isinf (rand (1,10)), false (1,10))
 %!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
@@ -1275,17 +1275,17 @@ Return a logical array which is true whe
 printable characters (but not the space character) and false where they are\n\
 not.\n\
 @seealso{isprint}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisgraph ());
+  return ovl (args(0).xisgraph ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:127) = true;
 %! assert (isgraph (charset), result);
@@ -1300,17 +1300,17 @@ DEFUNX ("islower", Fislower, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 lowercase letters and false where they are not.\n\
 @seealso{isupper, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xislower ());
+  return ovl (args(0).xislower ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("a":"z") + 1) = true;
 %! assert (islower (charset), result);
@@ -1334,17 +1334,17 @@ isna ([13, Inf, NA, NaN])\n\
 @end group\n\
 @end example\n\
 @seealso{isnan, isinf, isfinite}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).isna ());
+  return ovl (args(0).isna ());
 }
 
 /*
 %!assert (!isna (Inf))
 %!assert (!isna (NaN))
 %!assert (isna (NA))
 %!assert (isna (rand (1,10)), false (1,10))
 %!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
@@ -1374,17 +1374,17 @@ isnan ([13, Inf, NA, NaN])\n\
 @end group\n\
 @end example\n\
 @seealso{isna, isinf, isfinite}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).isnan ());
+  return ovl (args(0).isnan ());
 }
 
 /*
 %!assert (!isnan (Inf))
 %!assert (isnan (NaN))
 %!assert (isnan (NA))
 %!assert (isnan (rand (1,10)), false (1,10))
 %!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
@@ -1406,17 +1406,17 @@ Return a logical array which is true whe
 printable characters (including the space character) and false where they\n\
 are not.\n\
 @seealso{isgraph}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisprint ());
+  return ovl (args(0).xisprint ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(33:127) = true;
 %! assert (isprint (charset), result);
@@ -1431,17 +1431,17 @@ DEFUNX ("ispunct", Fispunct, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 punctuation characters and false where they are not.\n\
 @seealso{isalpha, isdigit, isspace, iscntrl}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xispunct ());
+  return ovl (args(0).xispunct ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:48) = true;
 %! result(59:65) = true;
@@ -1460,17 +1460,17 @@ Return a logical array which is true whe
 whitespace characters (space, formfeed, newline, carriage return, tab, and\n\
 vertical tab) and false where they are not.\n\
 @seealso{iscntrl, ispunct, isalpha, isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisspace ());
+  return ovl (args(0).xisspace ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii (" \f\n\r\t\v") + 1) = true;
 %! assert (isspace (charset), result);
@@ -1485,17 +1485,17 @@ DEFUNX ("isupper", Fisupper, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 uppercase letters and false where they are not.\n\
 @seealso{islower, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisupper ());
+  return ovl (args(0).xisupper ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! assert (isupper (charset), result);
@@ -1510,17 +1510,17 @@ DEFUNX ("isxdigit", Fisxdigit, args, ,
 Return a logical array which is true where the elements of @var{s} are\n\
 hexadecimal digits (0-9 and @nospell{a-fA-F}).\n\
 @seealso{isdigit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xisxdigit ());
+  return ovl (args(0).xisxdigit ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"F") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
@@ -1537,17 +1537,17 @@ DEFUN (lgamma, args, ,
 @deftypefnx {} {} lgamma (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).lgamma ());
+  return ovl (args(0).lgamma ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (gammaln (a), gammaln (real (a)));
 
 %!test
@@ -1588,17 +1588,17 @@ for each element of @var{x}.\n\
 \n\
 To compute the matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{exp, log1p, log2, log10, logspace}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).log ());
+  return ovl (args(0).log ());
 }
 
 /*
 %!assert (log ([1, e, e^2]), [0, 1, 2], sqrt (eps))
 %!assert (log ([-0.5, -1.5, -2.5]), log ([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
 
 %!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ("single")))
 %!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
@@ -1612,17 +1612,17 @@ DEFUN (log10, args, ,
 @deftypefn {} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).log10 ());
+  return ovl (args(0).log10 ());
 }
 
 /*
 %!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
 %!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
@@ -1640,17 +1640,17 @@ Compute\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{log, exp, expm1}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).log1p ());
+  return ovl (args(0).log1p ());
 }
 
 /*
 %!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
 %!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
@@ -1661,17 +1661,17 @@ DEFUN (real, args, ,
 @deftypefn {} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).real ());
+  return ovl (args(0).real ());
 }
 
 /*
 %!assert (real (1), 1)
 %!assert (real (i), 0)
 %!assert (real (1+i), 1)
 %!assert (real ([1, i; i, 1]), full (eye (2)))
 
@@ -1700,17 +1700,17 @@ round ([-2.7, 2.7])\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix, roundb}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).round ());
+  return ovl (args(0).round ());
 }
 
 /*
 %!assert (round (1), 1)
 %!assert (round (1.1), 1)
 %!assert (round (5.5), 6)
 %!assert (round (i), i)
 %!assert (round (2.5+3.5i), 3+4i)
@@ -1738,17 +1738,17 @@ integers, return the even one (banker's 
 If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).roundb ());
+  return ovl (args(0).roundb ());
 }
 
 /*
 %!assert (roundb (1), 1)
 %!assert (roundb (1.1), 1)
 %!assert (roundb (1.5), 2)
 %!assert (roundb (4.5), 4)
 %!assert (roundb (i), i)
@@ -1798,17 +1798,17 @@ Note that @code{sign (-0.0)} is 0.  Alth
 allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test\n\
 whether zero is signed, use the @code{signbit} function.\n\
 @seealso{signbit}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).signum ());
+  return ovl (args(0).signum ());
 }
 
 /*
 %!assert (sign (-2) , -1)
 %!assert (sign (0), 0)
 %!assert (sign (3), 1)
 %!assert (sign ([1, -pi; e, 0]), [1, -1; 1, 0])
 
@@ -1837,17 +1837,17 @@ but @code{signbit (-0.0)} will return a 
 @seealso{sign}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value tmp = args(0).xsignbit ();
 
-  return octave_value (tmp != 0);
+  return ovl (tmp != 0);
 }
 
 /*
 %!assert (signbit (1) == 0)
 %!assert (signbit (-2) != 0)
 %!assert (signbit (0) == 0)
 %!assert (signbit (-0) != 0)
 
@@ -1865,17 +1865,17 @@ DEFUN (sin, args, ,
 @deftypefn {} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).sin ());
+  return ovl (args(0).sin ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -1897,17 +1897,17 @@ DEFUN (sinh, args, ,
 @deftypefn {} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).sinh ());
+  return ovl (args(0).sinh ());
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [0, i, 0, -i];
 %! assert (sinh (x), v, sqrt (eps));
 
@@ -1929,17 +1929,17 @@ If @var{x} is negative, a complex result
 \n\
 To compute the matrix square root, see @ref{Linear Algebra}.\n\
 @seealso{realsqrt, nthroot}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).sqrt ());
+  return ovl (args(0).sqrt ());
 }
 
 /*
 %!assert (sqrt (4), 2)
 %!assert (sqrt (-1), i)
 %!assert (sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps))
 %!assert (sqrt ([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt (eps))
 
@@ -1957,17 +1957,17 @@ DEFUN (tan, args, ,
 @deftypefn {} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).tan ());
+  return ovl (args(0).tan ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -1989,17 +1989,17 @@ DEFUN (tanh, args, ,
 @deftypefn {} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).tanh ());
+  return ovl (args(0).tanh ());
 }
 
 /*
 %!test
 %! x = [0, pi*i];
 %! v = [0, 0];
 %! assert (tanh (x), v, sqrt (eps));
 
@@ -2027,17 +2027,17 @@ toascii (\"ASCII\")\n\
 \n\
 @end example\n\
 @seealso{char}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xtoascii ());
+  return ovl (args(0).xtoascii ());
 }
 
 /*
 %!assert (toascii (char (0:127)), 0:127)
 %!assert (toascii (" ":"@"), 32:64)
 %!assert (toascii ("A":"Z"), 65:90)
 %!assert (toascii ("[":"`"), 91:96)
 %!assert (toascii ("a":"z"), 97:122)
@@ -2064,17 +2064,17 @@ tolower (\"MiXeD cAsE 123\")\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xtolower ());
+  return ovl (args(0).xtolower ());
 }
 
 DEFALIAS (lower, tolower);
 
 /*
 %!assert (tolower ("OCTAVE"), "octave")
 %!assert (tolower ("123OCTave!_&"), "123octave!_&")
 %!assert (tolower ({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
@@ -2123,17 +2123,17 @@ toupper (\"MiXeD cAsE 123\")\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).xtoupper ());
+  return ovl (args(0).xtoupper ());
 }
 
 DEFALIAS (upper, toupper);
 
 /*
 %!assert (toupper ("octave"), "OCTAVE")
 %!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
 %!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -114,30 +114,31 @@ Also, the test for positive definiteness
 matrix with a real positive diagonal.  This does not guarantee that the\n\
 matrix is positive definite, but only that it is a probable candidate.  When\n\
 such a matrix is factorized, a Cholesky@tie{}factorization is first\n\
 attempted, and if that fails the matrix is then treated with an\n\
 LU@tie{}factorization.  Once the matrix has been factorized,\n\
 @code{matrix_type} will return the correct classification of the matrix.\n\
 @end deftypefn")
 {
-  octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 0 || nargin > 4)
     print_usage ();
 
   bool autocomp = true;
   if (nargin == 2 && args(1).is_string ()
       && args(1).string_value () == "nocompute")
     {
       nargin = 1;
       autocomp = false;
     }
 
+  octave_value retval;
+
   if (args(0).is_scalar_type ())
     {
       if (nargin == 1)
         retval = octave_value ("Diagonal");
       else
         retval = args(0);
     }
   else if (args(0).is_sparse_type ())
@@ -206,17 +207,16 @@ LU@tie{}factorization.  Once the matrix 
           else if (typ == MatrixType::Full)
             retval = octave_value ("Full");
           else
             retval = octave_value ("Unknown");
         }
       else
         {
           // Ok, we're changing the matrix type
-
           std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
 
           // FIXME: why do I have to explicitly call the constructor?
           MatrixType mattyp = MatrixType ();
 
           octave_idx_type nl = 0;
           octave_idx_type nu = 0;
 
@@ -232,29 +232,27 @@ LU@tie{}factorization.  Once the matrix 
             mattyp.mark_as_upper_triangular ();
           else if (str_typ == "lower")
             mattyp.mark_as_lower_triangular ();
           else if (str_typ == "banded"
                    || str_typ == "banded positive definite")
             {
               if (nargin != 4)
                 error ("matrix_type: banded matrix type requires 4 arguments");
-              else
-                {
-                  nl = args(2).xnint_value ("matrix_type: band size NL, NU must be integers");
-                  nu = args(3).xnint_value ("matrix_type: band size NL, NU must be integers");
+
+              nl = args(2).xnint_value ("matrix_type: band size NL, NU must be integers");
+              nu = args(3).xnint_value ("matrix_type: band size NL, NU must be integers");
 
-                  if (nl == 1 && nu == 1)
-                    mattyp.mark_as_tridiagonal ();
-                  else
-                    mattyp.mark_as_banded (nu, nl);
+              if (nl == 1 && nu == 1)
+                mattyp.mark_as_tridiagonal ();
+              else
+                mattyp.mark_as_banded (nu, nl);
 
-                  if (str_typ == "banded positive definite")
-                    mattyp.mark_as_symmetric ();
-                }
+              if (str_typ == "banded positive definite")
+                mattyp.mark_as_symmetric ();
             }
           else if (str_typ == "positive definite")
             {
               mattyp.mark_as_full ();
               mattyp.mark_as_symmetric ();
             }
           else if (str_typ == "singular")
             mattyp.mark_as_rectangular ();
@@ -270,25 +268,23 @@ LU@tie{}factorization.  Once the matrix 
             {
               const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
 
               octave_idx_type len = perm.numel ();
               dim_vector dv = args(0).dims ();
 
               if (len != dv(0))
                 error ("matrix_type: Invalid permutation vector PERM");
-              else
-                {
-                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                  for (octave_idx_type i = 0; i < len; i++)
-                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+              for (octave_idx_type i = 0; i < len; i++)
+                p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                  mattyp.mark_as_permuted (len, p);
-                }
+              mattyp.mark_as_permuted (len, p);
             }
           else if (nargin != 2
                    && str_typ != "banded positive definite"
                    && str_typ != "banded")
             error ("matrix_type: Invalid number of arguments");
 
           // Set the matrix type
           if (args(0).is_complex_type ())
@@ -373,17 +369,16 @@ LU@tie{}factorization.  Once the matrix 
           else if (typ == MatrixType::Full)
             retval = octave_value ("Full");
           else
             retval = octave_value ("Unknown");
         }
       else
         {
           // Ok, we're changing the matrix type
-
           std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
 
           // FIXME: why do I have to explicitly call the constructor?
           MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
 
           // Use STL function to convert to lower case
           std::transform (str_typ.begin (), str_typ.end (),
                           str_typ.begin (), tolower);
@@ -410,25 +405,23 @@ LU@tie{}factorization.  Once the matrix 
             {
               const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
 
               octave_idx_type len = perm.numel ();
               dim_vector dv = args(0).dims ();
 
               if (len != dv(0))
                 error ("matrix_type: Invalid permutation vector PERM");
-              else
-                {
-                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+
+              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                  for (octave_idx_type i = 0; i < len; i++)
-                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+              for (octave_idx_type i = 0; i < len; i++)
+                p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                  mattyp.mark_as_permuted (len, p);
-                }
+              mattyp.mark_as_permuted (len, p);
             }
           else if (nargin != 2)
             error ("matrix_type: Invalid number of arguments");
 
           // Set the matrix type
           if (args(0).is_single_type ())
             {
               if (args(0).is_complex_type ())
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -62,36 +62,31 @@ On exit, @var{y} is a unit vector such t
   norm (@var{y}) = 1\n\
   @var{v}' * @var{y} = 0\n\
   @var{x} = [@var{v}, @var{y}]*@var{h}'\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
-    {
-      error ("mgorth: V should be a matrix, and X a column vector with"
-             " the same number of rows as V.");
-      return retval;
-    }
+    error ("mgorth: V should be a matrix, and X a column vector with"
+           " the same number of rows as V.");
 
   if (! arg_x.is_numeric_type () && ! arg_v.is_numeric_type ())
-    {
-      error ("mgorth: X and V must be numeric");
-    }
+    error ("mgorth: X and V must be numeric");
+
+  octave_value_list retval;
 
   bool iscomplex = (arg_x.is_complex_type () || arg_v.is_complex_type ());
   if (arg_x.is_single_type () || arg_v.is_single_type ())
     {
       if (iscomplex)
         {
           FloatComplexColumnVector x
             = arg_x.float_complex_column_vector_value ();
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -44,18 +44,16 @@ total number of processors.\n\
 processors available to the current process.\n\
 \n\
 @item overridable\n\
 same as @code{current}, but overridable through the @w{@env{OMP_NUM_THREADS}}\n\
 environment variable.\n\
 @end table\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   nproc_query query = NPROC_CURRENT;
   if (nargin == 1)
     {
@@ -68,19 +66,17 @@ environment variable.\n\
       else if (arg == "current")
         query = NPROC_CURRENT;
       else if (arg == "overridable")
         query = NPROC_CURRENT_OVERRIDABLE;
       else
         error ("nproc: invalid value for QUERY");
     }
 
-  retval = num_processors (query);
-
-  return retval;
+  return ovl (num_processors (query));
 }
 
 /*
 ## Must always report at least 1 cpu available
 %!assert (nproc () >= 1);
 %!assert (nproc ("all") >= 1);
 %!assert (nproc ("current") >= 1);
 
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -102,32 +102,33 @@ is in the upper left corner, by doing:\n
 \n\
 @example\n\
 [@var{U}, @var{S}] = ordschur (@var{U}, @var{S}, [0,1])\n\
 @end example\n\
 \n\
 @seealso{schur}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 3)
     print_usage ();
 
   const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ("ordschur: SELECT must be an array of integers");
 
   const octave_idx_type n = sel.numel ();
 
   const dim_vector dimU = args(0).dims ();
   const dim_vector dimS = args(1).dims ();
+
   if (n != dimU(0))
     error ("ordschur: SELECT must have same length as the sides of U and S");
   else if (n != dimU(0) || n != dimS(0) || n != dimU(1) || n != dimS(1))
     error ("ordschur: U and S must be square and of equal sizes");
 
+  octave_value_list retval;
+
   const bool double_type  = args(0).is_double_type ()
                             || args(1).is_double_type ();
   const bool complex_type = args(0).is_complex_type ()
                             || args(1).is_complex_type ();
 
 #define PREPARE_ARGS(TYPE, TYPE_M, TYPE_COND) \
           TYPE ## Matrix U = args(0).x ## TYPE_M ## _value ("ordschur: U and S must be real or complex floating point matrices"); \
           TYPE ## Matrix S = args(1).x ## TYPE_M ## _value ("ordschur: U and S must be real or complex floating point matrices"); \
@@ -149,56 +150,60 @@ is in the upper left corner, by doing:\n
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
                      sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
                      w.fortran_vec (), m, cond1, cond2, work.fortran_vec (), n,
                      info));
+
           PREPARE_OUTPUT()
         }
       else
         {
           PREPARE_ARGS (, matrix, double)
           Matrix wi (dim_vector (n, 1));
           Array<octave_idx_type> iwork (dim_vector (n, 1));
 
           F77_XFCN (dtrsen, dtrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
                      sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
                      w.fortran_vec (), wi.fortran_vec (), m, cond1, cond2,
                      work.fortran_vec (), n, iwork.fortran_vec (), n, info));
+
           PREPARE_OUTPUT ()
         }
     }
   else
     {
       if (complex_type)
         {
           PREPARE_ARGS (FloatComplex, float_complex_matrix, float)
 
           F77_XFCN (ctrsen, ctrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
                      sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
                      w.fortran_vec (), m, cond1, cond2, work.fortran_vec (), n,
                      info));
+
           PREPARE_OUTPUT ()
         }
       else
         {
           PREPARE_ARGS (Float, float_matrix, float)
           FloatMatrix wi (dim_vector (n, 1));
           Array<octave_idx_type> iwork (dim_vector (n, 1));
 
           F77_XFCN (strsen, strsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
                      sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
                      w.fortran_vec (), wi.fortran_vec (), m, cond1, cond2,
                      work.fortran_vec (), n, iwork.fortran_vec (), n, info));
+
           PREPARE_OUTPUT ()
         }
     }
 
 #undef PREPARE_ARGS
 #undef PREPARE_OUTPUT
 
   return retval;
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -569,17 +569,17 @@ With no arguments, @code{diary} toggles 
       else
         {
           diary_file = arg;
           write_to_diary_file = true;
           open_diary_file ();
         }
     }
 
-  return octave_value ();
+  return octave_value_list ();
 }
 
 DEFUN (__diaryfile__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{fname} =} __diaryfile__ ()\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -49,32 +49,32 @@ If the second argument is omitted, it is
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
 \n\
 @noindent\n\
 where @code{sigma_max (@var{x})} is the maximal singular value of @var{x}.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("pinv", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
-    return retval;
+    return octave_value_list ();
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
+  octave_value retval;
+
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (isfloat)
         {
           float tol = 0.0;
           if (nargin == 2)
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3421,71 +3421,64 @@ x = str2num (r)\n\
 The optional second argument defines the maximum length of the string\n\
 representing the elements of @var{x}.  By default @var{len} is 9.\n\
 \n\
 If the length of the smallest possible rational approximation exceeds\n\
 @var{len}, an asterisk (*) padded with spaces will be returned instead.\n\
 @seealso{format, rat}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value arg = args(0);
+
+  if (! arg.is_numeric_type ())
+    error ("rats: X must be numeric");
+
   unwind_protect frame;
 
   frame.protect_var (rat_string_len);
 
   rat_string_len = 9;
-
   if (nargin == 2)
     rat_string_len = args(1).nint_value ();
 
-  octave_value arg = args(0);
-
-  if (arg.is_numeric_type ())
+  frame.protect_var (rat_format);
+
+  rat_format = true;
+
+  std::ostringstream buf;
+  arg.print (buf);
+  std::string s = buf.str ();
+
+  std::list<std::string> lst;
+
+  size_t n = 0;
+  size_t s_len = s.length ();
+
+  while (n < s_len)
     {
-      frame.protect_var (rat_format);
-
-      rat_format = true;
-
-      std::ostringstream buf;
-      arg.print (buf);
-      std::string s = buf.str ();
-
-      std::list<std::string> lst;
-
-      size_t n = 0;
-      size_t s_len = s.length ();
-
-      while (n < s_len)
+      size_t m = s.find ('\n',  n);
+
+      if (m == std::string::npos)
         {
-          size_t m = s.find ('\n',  n);
-
-          if (m == std::string::npos)
-            {
-              lst.push_back (s.substr (n));
-              break;
-            }
-          else
-            {
-              lst.push_back (s.substr (n, m - n));
-              n = m + 1;
-            }
+          lst.push_back (s.substr (n));
+          break;
         }
-
-      retval = string_vector (lst);
+      else
+        {
+          lst.push_back (s.substr (n, m - n));
+          n = m + 1;
+        }
     }
-  else
-    error ("rats: X must be numeric");
-
-  return retval;
+
+  return ovl (string_vector (lst));
 }
 
 DEFUN (disp, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} disp (@var{x})\n\
 Display the value of @var{x}.\n\
 \n\
 For example:\n\
@@ -3502,21 +3495,21 @@ disp (\"The value of pi is:\"), disp (pi
 @noindent\n\
 Note that the output from @code{disp} always ends with a newline.\n\
 \n\
 If an output value is requested, @code{disp} prints nothing and returns the\n\
 formatted output in a string.\n\
 @seealso{fdisp}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value_list retval;
+
   octave_value arg = args(0);
 
   if (nargout == 0)
     arg.print (octave_stdout);
   else
     {
       std::ostringstream buf;
       arg.print (buf);
@@ -3542,35 +3535,33 @@ fdisp (stdout, \"The value of pi is:\"),
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the output from @code{fdisp} always ends with a newline.\n\
 @seealso{disp}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
   int fid = octave_stream_list::get_file_number (args(0));
 
   octave_stream os = octave_stream_list::lookup (fid, "fdisp");
 
   std::ostream *osp = os.output_stream ();
 
   octave_value arg = args(1);
 
   if (osp)
     arg.print (*osp);
   else
     error ("fdisp: stream FID not open for writing");
 
-  return retval;
+  return octave_value_list ();
 }
 
 /*
 %!test
 %! format short
 %! fd = tmpfile ();
 %! for r = [0, Inf -Inf, NaN]
 %!   for i = [0, Inf -Inf, NaN]
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -401,34 +401,32 @@ Undocumented internal function.\n\
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin > 0)
     profiler.set_active (args(0).bool_value ());
 
-  return octave_value (profiler.is_active ());
+  return ovl (profiler.is_active ());
 }
 
 // Clear all collected profiling data.
 DEFUN (__profiler_reset__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __profiler_reset__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () > 0)
     warning ("profiler_reset: ignoring extra arguments");
 
   profiler.reset ();
 
-  return retval;
+  return octave_value_list ();
 }
 
 // Query the timings collected by the profiler.
 DEFUN (__profiler_data__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __profiler_data__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -60,27 +60,29 @@ psi (z) = d (log (gamma (z))) / dx\n\
 \n\
 When computing the digamma function (when @var{k} equals zero), @var{z}\n\
 can have any value real or complex value.  However, for polygamma functions\n\
 (@var{k} higher than 0), @var{z} must be real and non-negative.\n\
 \n\
 @seealso{gamma, gammainc, gammaln}\n\
 @end deftypefn")
 {
-  octave_value retval;
+  int nargin = args.length ();
 
-  const octave_idx_type nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   const octave_value oct_z = (nargin == 1) ? args(0) : args(1);
   const octave_idx_type k = (nargin == 1) ? 0 : args(0).idx_type_value ("psi: K must be an integer");
   if (k < 0)
     error ("psi: K must be non-negative");
-  else if (k == 0)
+
+  octave_value retval;
+
+  if (k == 0)
     {
 #define FLOAT_BRANCH(T, A, M, E) \
       if (oct_z.is_ ## T ##_type ()) \
         { \
           const A ## NDArray z = oct_z.M ## array_value (); \
           A ## NDArray psi_z (z.dims ()); \
  \
           const E* zv = z.data (); \
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -175,34 +175,32 @@ The function @code{quad_options} can set
 @code{quad}.\n\
 \n\
 Note: because @code{quad} is written in Fortran it cannot be called\n\
 recursively.  This prevents its use in integrating over more than one\n\
 variable by routines @code{dblquad} and @code{triplequad}.\n\
 @seealso{quad_options, quadv, quadl, quadgk, quadcc, trapz, dblquad, triplequad}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  int nargin = args.length ();
 
-  std::string fcn_name;
+  if (nargin < 3 || nargin > 5)
+    print_usage ();
 
   warned_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("quad: invalid recursive call");
 
-  int nargin = args.length ();
-
-  if (nargin < 3 || nargin > 5)
-    print_usage ();
+  std::string fcn_name;
 
   if (args(0).is_function_handle () || args(0).is_inline_function ())
     quad_fcn = args(0).function_value ();
   else
     {
       fcn_name = unique_symbol_name ("__quad_fcn__");
       std::string fname = "function y = ";
       fname.append (fcn_name);
@@ -210,16 +208,18 @@ variable by routines @code{dblquad} and 
       quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
                                    "; endfunction");
       frame.add_fcn (clear_function, fcn_name);
     }
 
   if (! quad_fcn)
     error ("quad: FCN argument is not a valid function name or handle");
 
+  octave_value_list retval;
+
   if (args(1).is_single_type () || args(2).is_single_type ())
     {
       float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
       float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
 
       int indefinite = 0;
       FloatIndefQuad::IntegralType indef_type
         = FloatIndefQuad::doubly_infinite;
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -40,24 +40,25 @@ If the matrix is well-conditioned then @
 matrix is poorly conditioned it will be close to 0.\n\
 \n\
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
 @seealso{cond, condest}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
-  else if (args(0).is_single_type ())
+
+  if (args(0).is_single_type ())
     {
       if (args(0).is_complex_type ())
         {
           FloatComplexMatrix m = args(0).float_complex_matrix_value ();
           MatrixType mattyp;
           retval = m.rcond (mattyp);
           args(0).matrix_type (mattyp);
         }
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -1145,24 +1145,20 @@ Search for @var{pat} in @var{str} and re
 any matches, or empty values if there are none.  @xref{XREFregexp,,regexp},\n\
 for details on the syntax of the search pattern.\n\
 @seealso{regexp}\n\
 @end deftypefn")
 {
   if (args.length () < 2)
     print_usage ();
 
-  octave_value_list retval;
-
   if (args(0).is_cell () || args(1).is_cell ())
-    retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
+    return octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
   else
-    retval = octregexp (args, nargout, "regexpi", true);
-
-  return retval;
+    return octregexp (args, nargout, "regexpi", true);
 }
 
 /*
 ## segfault test
 %!assert (regexpi ("abcde", "."), [1,2,3,4,5])
 
 ## Check that anchoring of pattern works correctly
 %!assert (regexpi ('abcabc', '^ABC'), 1)
@@ -1434,18 +1430,18 @@ function.\n\
               if (rep.numel () != 1)
                 new_args(2) = rep(j);
               new_args(0) = octregexprep (new_args, "regexprep");
             }
 
           ret(i) = new_args(0);
         }
 
-      retval = args(0).is_cell () ? octave_value (ret)
-                                  : octave_value (ret(0));
+      retval = args(0).is_cell () ? ovl (ret)
+                                  : ovl (ret(0));
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -167,17 +167,17 @@ in control (see @code{are} and @code{dar
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("schur");
       return octave_value_list ();
     }
 
-  octave_value_list retval (nargout > 1 ? 2 : 1);
+  octave_value_list retval;
 
   if (! arg.is_numeric_type ())
     gripe_wrong_type_arg ("schur", arg);
   else if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -1052,17 +1052,17 @@ DEFUN (SIG, args, ,
 Return a structure containing Unix signal names and their defined values.\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
   static octave_scalar_map m = make_sig_struct ();
 
-  return octave_value (m);
+  return ovl (m);
 }
 
 /*
 %!assert (isstruct (SIG ()))
 %!assert (! isempty (SIG ()))
 
 %!error SIG (1)
 */
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -46,17 +46,17 @@ DEFUN (issparse, args, ,
 @deftypefn {} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_sparse_type ());
+  return ovl (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{s} =} sparse (@var{a})\n\
 @deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n})\n\
 @deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
 @deftypefnx {} {@var{s} =} sparse (@var{m}, @var{n})\n\
@@ -117,22 +117,23 @@ Compressed Column Sparse (rows = 3, cols
 \n\
   (1, 1) ->  4\n\
   (2, 2) ->  5\n\
 @end group\n\
 @end example\n\
 @seealso{full, accumarray, spalloc, spdiags, speye, spones, sprand, sprandn, sprandsym, spconvert, spfun}\n\
 @end deftypefn")
 {
-  octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 0 || nargin > 6)
     print_usage ();
 
+  octave_value retval;
+
   // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
   unwind_protect frame;
   frame.protect_var (Vsparse_auto_mutate);
   Vsparse_auto_mutate = false;
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
@@ -252,29 +253,25 @@ be more memory and time efficient under 
 it is possible to efficiently build a pre-allocated sparse matrix from a\n\
 contiguous block of columns.\n\
 \n\
 The amount of pre-allocated memory for a given matrix may be queried using\n\
 the function @code{nzmax}.\n\
 @seealso{nzmax, sparse}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_idx_type m = args(0).idx_type_value ();
   octave_idx_type n = args(1).idx_type_value ();
+
   octave_idx_type nz = 0;
-
   if (nargin == 3)
     nz = args(2).idx_type_value ();
 
   if (m >= 0 && n >= 0 && nz >= 0)
-    retval = SparseMatrix (dim_vector (m, n), nz);
+    return ovl (SparseMatrix (dim_vector (m, n), nz));
   else
     error ("spalloc: M,N,NZ must be non-negative");
-
-  return retval;
 }
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -336,43 +336,40 @@ conversion fails.  Note that numeric ele
 cell array are not strings and the conversion will fail for these elements\n\
 and return NaN.\n\
 \n\
 @code{str2double} can replace @code{str2num}, and it avoids the security\n\
 risk of using @code{eval} on unknown data.\n\
 @seealso{str2num}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   if (args(0).is_string ())
     {
       if (args(0).rows () == 0 || args(0).columns () == 0)
-        {
-          retval = Matrix (1, 1, octave_NaN);
-        }
+        retval = Matrix (1, 1, octave_NaN);
       else if (args(0).rows () == 1 && args(0).ndims () == 2)
-        {
-          retval = str2double1 (args(0).string_value ());
-        }
+        retval = str2double1 (args(0).string_value ());
       else
         {
           const string_vector sv = args(0).all_strings ();
 
           retval = sv.map<Complex> (str2double1);
         }
     }
   else if (args(0).is_cell ())
     {
       const Cell cell = args(0).cell_value ();
 
       ComplexNDArray output (cell.dims (), octave_NaN);
+
       for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
           if (cell(i).is_string ())
             output(i) = str2double1 (cell(i).string_value ());
         }
       retval = output;
     }
   else
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -187,40 +187,37 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
           [1,2] = [](1x0)\n\
           [1,3] = [](1x0)\n\
         @}\n\
 @end group\n\
 @end example\n\
 @seealso{findstr, strmatch, regexp, regexpi, find}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin != 4 && nargin != 2)
     print_usage ();
 
   bool overlaps = true;
-
   if (nargin == 4)
     {
-      if (args(2).is_string () && args(3).is_scalar_type ())
-        {
-          std::string opt = args(2).string_value ();
+      if (! args(2).is_string () || ! args(3).is_scalar_type ())
+        error ("strfind: invalid optional arguments");
+
+      std::string opt = args(2).string_value ();
 
-          if (opt == "overlaps")
-            overlaps = args(3).bool_value ();
-          else
-            error ("strfind: unknown option: %s", opt.c_str ());
-        }
+      if (opt == "overlaps")
+        overlaps = args(3).bool_value ();
       else
-        error ("strfind: invalid optional arguments");
+        error ("strfind: unknown option: %s", opt.c_str ());
     }
 
+  octave_value retval;
+
   octave_value argstr = args(0);
   octave_value argpat = args(1);
 
   if (argpat.is_string ())
     {
       Array<char> needle = argpat.char_array_value ();
       OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
       qs_preprocess (needle, table);
@@ -238,28 +235,26 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
         {
           const Cell argsc = argstr.cell_value ();
           Cell retc (argsc.dims ());
           octave_idx_type ns = argsc.numel ();
 
           for (octave_idx_type i = 0; i < ns; i++)
             {
               octave_value argse = argsc(i);
-              if (argse.is_string ())
-                {
-                  if (argpat.is_empty ())
-                    retc(i) = Matrix ();
-                  else
-                    retc(i) = octave_value (qs_search (needle,
-                                                       argse.char_array_value (),
-                                                       table, overlaps),
-                                            true, true);
-                }
+              if (! argse.is_string ())
+                error ("strfind: each element of CELLSTR must be a string");
+
+              if (argpat.is_empty ())
+                retc(i) = Matrix ();
               else
-                error ("strfind: each element of CELLSTR must be a string");
+                retc(i) = octave_value (qs_search (needle,
+                                                   argse.char_array_value (),
+                                                   table, overlaps),
+                                        true, true);
             }
 
           retval = retc;
         }
       else
         error ("strfind: first argument must be a string or cell array of strings");
     }
   else if (argpat.is_cell ())
@@ -378,39 +373,37 @@ Example:\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
     @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{regexprep, strfind, findstr}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  bool overlaps = true;
-
   int nargin = args.length ();
 
   if (nargin != 3 && nargin != 5)
     print_usage ();
 
+  bool overlaps = true;
+
   if (nargin == 5)
     {
-      if (args(3).is_string () && args(4).is_scalar_type ())
-        {
-          std::string opt = args(3).string_value ();
-          if (opt == "overlaps")
-            overlaps = args(4).bool_value ();
-          else
-            error ("strrep: unknown option: %s", opt.c_str ());
-        }
+      if (! args(3).is_string () || ! args(4).is_scalar_type ())
+        error ("strrep: invalid optional arguments");
+
+      std::string opt = args(3).string_value ();
+      if (opt == "overlaps")
+        overlaps = args(4).bool_value ();
       else
-        error ("strrep: invalid optional arguments");
+        error ("strrep: unknown option: %s", opt.c_str ());
     }
 
+  octave_value retval;
+
   octave_value argstr = args(0);
   octave_value argpat = args(1);
   octave_value argrep = args(2);
 
   if (argpat.is_string () && argrep.is_string ())
     {
       const Array<char> pat = argpat.char_array_value ();
       const Array<char> rep = argrep.char_array_value ();
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -287,17 +287,17 @@ DEFUN (ischar, args, ,
 @deftypefn {} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_string ());
+  return ovl (args(0).is_string ());
 }
 
 /*
 %!assert (ischar ("a"), true)
 %!assert (ischar (["ab";"cd"]), true)
 %!assert (ischar ({"ab"}), false)
 %!assert (ischar (1), false)
 %!assert (ischar ([1, 2]), false)
@@ -550,18 +550,18 @@ or character string.\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strcmpi, strncmp, strncmpi}\n\
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
-  return octave_value (do_strcmp_fun (args(0), args(1), 0, "strcmp",
-                                      strcmp_array_op, strcmp_str_op));
+  return ovl (do_strcmp_fun (args(0), args(1), 0, "strcmp",
+                             strcmp_array_op, strcmp_str_op));
 }
 
 /*
 %!shared x
 %! x = char (zeros (0, 2));
 %!assert (strcmp ("", x), false)
 %!assert (strcmp (x, ""), false)
 %!assert (strcmp (x, x), true)
@@ -657,30 +657,26 @@ strncmp (\"abce\", @{\"abcd\", \"bca\", 
 @end example\n\
 \n\
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strncmpi, strcmp, strcmpi}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
   octave_idx_type n = args(2).idx_type_value ();
 
   if (n > 0)
-    retval = do_strcmp_fun (args(0), args(1), n, "strncmp",
-                            strncmp_array_op, strncmp_str_op);
+    return ovl (do_strcmp_fun (args(0), args(1), n, "strncmp",
+                               strncmp_array_op, strncmp_str_op));
   else
     error ("strncmp: N must be greater than 0");
-
-  return retval;
 }
 
 /*
 %!assert (strncmp ("abce", "abc", 3), true)
 %!assert (strncmp (100, 100, 1), false)
 %!assert (strncmp ("abce", {"abcd", "bca", "abc"}, 3), logical ([1, 0, 1]))
 %!assert (strncmp ("abc",  {"abcd", "bca", "abc"}, 4), logical ([0, 0, 0]))
 %!assert (strncmp ({"abcd", "bca", "abc"},"abce", 3), logical ([1, 0, 1]))
@@ -734,23 +730,21 @@ or character string.\n\
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strcmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 \n\
 @strong{Caution:} National alphabets are not supported.\n\
 @seealso{strcmp, strncmp, strncmpi}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
-  return octave_value (do_strcmp_fun (args(0), args(1), 0, "strcmpi",
-                                      strcmpi_array_op, strcmpi_str_op));
+  return ovl (do_strcmp_fun (args(0), args(1), 0, "strcmpi",
+                             strcmpi_array_op, strcmpi_str_op));
 }
 
 /*
 %!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
@@ -791,30 +785,26 @@ or character string.\n\
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmpi\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 \n\
 @strong{Caution:} National alphabets are not supported.\n\
 @seealso{strncmp, strcmp, strcmpi}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
   octave_idx_type n = args(2).idx_type_value ();
 
   if (n > 0)
-    retval = do_strcmp_fun (args(0), args(1), n, "strncmpi",
-                            strncmpi_array_op, strncmpi_str_op);
+    return ovl (do_strcmp_fun (args(0), args(1), n, "strncmpi",
+                               strncmpi_array_op, strncmpi_str_op));
   else
     error ("strncmpi: N must be greater than 0");
-
-  return retval;
 }
 
 /*
 %!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
        "-*- texinfo -*-\n\
@@ -847,18 +837,16 @@ whos ans\n\
 \n\
      Total is 37 elements using 37 bytes\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @seealso{terminal_size}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   string_vector s = args(0).xall_strings ("list_in_columns: ARG must be a cellstr or char array");
 
   int width = -1;
@@ -870,19 +858,17 @@ whos ans\n\
 
   if (nargin > 2)
     prefix = args(2).xstring_value ("list_in_columns: PREFIX must be a string");
 
   std::ostringstream buf;
 
   s.list_in_columns (buf, width, prefix);
 
-  retval = buf.str ();
-
-  return retval;
+  return ovl (buf.str ());
 }
 
 /*
 %!test
 %! input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
 %! result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
 %! assert (list_in_columns (input, 20), result);
 %!test
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -88,38 +88,36 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
     print_usage ();
 
   dim_vector dv = get_dim_vector (args(0), "sub2ind");
   Array<idx_vector> idxa (dim_vector (nargin-1, 1));
 
   dv = dv.redim (nargin - 1);
   for (int j = 0; j < nargin - 1; j++)
     {
-      if (args(j+1).is_numeric_type ())
+      if (! args(j+1).is_numeric_type ())
+        error ("sub2ind: subscripts must be numeric");
+
+      try
         {
-          try
-            {
-              idxa(j) = args(j+1).index_vector ();
+          idxa(j) = args(j+1).index_vector ();
 
-              if (j > 0 && args(j+1).dims () != args(1).dims ())
-                error ("sub2ind: all subscripts must be of the same size");
-            }
-          catch (index_exception& e)
-            {
-              e.set_pos_if_unset (nargin-1, j+1);
-              e.set_var ();
-              std::string msg = e.message ();
-              error_with_id (e.err_id (), msg.c_str ());
-            }
+          if (j > 0 && args(j+1).dims () != args(1).dims ())
+            error ("sub2ind: all subscripts must be of the same size");
         }
-      else
-        error ("sub2ind: subscripts must be numeric");
+      catch (index_exception& e)
+        {
+          e.set_pos_if_unset (nargin-1, j+1);
+          e.set_var ();
+          std::string msg = e.message ();
+          error_with_id (e.err_id (), msg.c_str ());
+        }
     }
 
-  return octave_value (sub2ind (dv, idxa));
+  return ovl (sub2ind (dv, idxa));
 }
 
 /*
 ## Test evaluation
 %!test
 %! s1 = [ 1   1   1   1 ; 2   2   2   2 ];
 %! s2 = [ 1   1   2   2 ; 1   1   2   2 ];
 %! s3 = [ 1   2   1   2 ; 1   2   1   2 ];
@@ -176,21 +174,21 @@ moving from one column to next, filling 
 [r, c] = ind2sub ([3, 3], 8)\n\
     @result{} r =  2\n\
     @result{} c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value_list retval;
+
   dim_vector dv = get_dim_vector (args(0), "ind2sub");
 
   try
     {
       idx_vector idx = args(1).index_vector ();
 
       if (nargout > dv.length ())
         dv = dv.redim (nargout);
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -119,37 +119,37 @@ v =\n\
 @end example\n\
 \n\
 If given a second argument, @code{svd} returns an economy-sized\n\
 decomposition, eliminating the unnecessary rows or columns of @var{U} or\n\
 @var{V}.\n\
 @seealso{svd_driver, svds, eig, lu, chol, hess, qr, qz}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     print_usage ();
 
   octave_value arg = args(0);
 
-  octave_idx_type nr = arg.rows ();
-  octave_idx_type nc = arg.columns ();
-
   if (arg.ndims () != 2)
     error ("svd: A must be a 2-D matrix");
 
+  octave_value_list retval;
+
   bool isfloat = arg.is_single_type ();
 
   SVD::type type = ((nargout == 0 || nargout == 1)
                     ? SVD::sigma_only
                     : (nargin == 2) ? SVD::economy : SVD::std);
 
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
+
   SVD::driver driver = static_cast<SVD::driver> (Vsvd_driver);
 
   if (nr == 0 || nc == 0)
     {
       if (isfloat)
         {
           switch (type)
             {
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -55,21 +55,21 @@ For example:\n\
 @example\n\
 @group\n\
 sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
    @result{} [ 0.50000, 0.66667; 0.66667, 0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
+  octave_value retval;
+
   octave_value arg_a = args(0);
   octave_value arg_b = args(1);
   octave_value arg_c = args(2);
 
   octave_idx_type a_nr = arg_a.rows ();
   octave_idx_type a_nc = arg_a.columns ();
 
   octave_idx_type b_nr = arg_b.rows ();
@@ -83,19 +83,19 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
   int arg_c_is_empty = empty_arg ("sylvester", c_nr, c_nc);
 
   bool isfloat = arg_a.is_single_type ()
                  || arg_b.is_single_type ()
                  || arg_c.is_single_type ();
 
   if (arg_a_is_empty > 0 && arg_b_is_empty > 0 && arg_c_is_empty > 0)
     if (isfloat)
-      return octave_value (FloatMatrix ());
+      return ovl (FloatMatrix ());
     else
-      return octave_value (Matrix ());
+      return ovl (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
     return retval;
 
   // Arguments are not empty, so check for correct dimensions.
 
   if (a_nr != a_nc)
     {
       gripe_square_matrix_required ("sylvester: input A");
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1659,23 +1659,23 @@ automatically recompile function files i
 \n\
 If set to @qcode{\"all\"}, Octave will not recompile any function files\n\
 unless their definitions are removed with @code{clear}.\n\
 \n\
 If set to @qcode{\"none\"}, Octave will always check time stamps on files to\n\
 determine whether functions defined in function files need to recompiled.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargout > 0 || nargin == 0)
     {
       switch (Vignore_function_time_stamp)
         {
         case 1:
           retval = "system";
           break;
 
@@ -1739,23 +1739,23 @@ DEFUN (__dump_symtab_info__, args, ,
 @deftypefn  {} {} __dump_symtab_info__ ()\n\
 @deftypefnx {} {} __dump_symtab_info__ (@var{scope})\n\
 @deftypefnx {} {} __dump_symtab_info__ (\"scopes\")\n\
 @deftypefnx {} {} __dump_symtab_info__ (\"functions\")\n\
 Undocumented internal function.\n\
 @seealso{__current_scope__}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 0)
     {
       symbol_table::dump_functions (octave_stdout);
 
       symbol_table::dump_global (octave_stdout);
 
       std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
@@ -1804,66 +1804,64 @@ Undocumented internal function.\n\
 }
 
 DEFUN (__get_cmdline_fcn_txt__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __get_cmdline_fcn_txt__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: first argument must be function name");
 
   octave_value ov = symbol_table::find_cmdline_function (name);
 
   octave_user_function *f = ov.user_function_value ();
 
+  octave_value_list retval;
+
   if (f)
     {
       std::ostringstream buf;
 
       tree_print_code tpc (buf);
 
       f->accept (tpc);
 
-      retval = buf.str ();
+      retval = ovl (buf.str ());
     }
 
   return retval;
 }
 
 #if 0
 
 // FIXME: should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
   std::string name = args(0).xstring_value ("set_variable: variable NAME must be a string");
 
   symbol_table::assign (name, args(1));
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   std::string name = args(0).xstring_value ("variable_value: variable NAME must be a string");
 
   retval = symbol_table::varval (name);
 
   if (retval.is_undefined ())
     error ("variable_value: '%s' is not a variable in the current scope",
            name.c_str ());
 
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -499,82 +499,82 @@ DEFUNX ("getpid", Fgetpid, args, ,
 @deftypefn {} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
 @seealso{getppid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::getpid ());
+  return ovl (octave_syscalls::getpid ());
 }
 
 DEFUNX ("getppid", Fgetppid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
 @seealso{getpid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::getppid ());
+  return ovl (octave_syscalls::getppid ());
 }
 
 DEFUNX ("getegid", Fgetegid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
 @seealso{getgid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::getegid ());
+  return ovl (octave_syscalls::getegid ());
 }
 
 DEFUNX ("getgid", Fgetgid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
 @seealso{getegid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::getgid ());
+  return ovl (octave_syscalls::getgid ());
 }
 
 DEFUNX ("geteuid", Fgeteuid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
 @seealso{getuid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::geteuid ());
+  return ovl (octave_syscalls::geteuid ());
 }
 
 DEFUNX ("getuid", Fgetuid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {uid =} getuid ()\n\
 Return the real user id of the current process.\n\
 @seealso{geteuid}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_syscalls::getuid ());
+  return ovl (octave_syscalls::getuid ());
 }
 
 DEFUNX ("kill", Fkill, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {[@var{err}, @var{msg}] =} kill (@var{pid}, @var{sig})\n\
 Send signal @var{sig} to process @var{pid}.\n\
 \n\
 If @var{pid} is positive, then signal @var{sig} is sent to @var{pid}.\n\
@@ -877,131 +877,131 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISREG: invalid MODE value");
 
-  return octave_value (file_stat::is_reg (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_reg (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISDIR (@var{mode})\n\
 Return true if @var{mode} corresponds to a directory.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISDIR: invalid MODE value");
 
-  return octave_value (file_stat::is_dir (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_dir (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISCHR (@var{mode})\n\
 Return true if @var{mode} corresponds to a character device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISCHR: invalid MODE value");
 
-  return octave_value (file_stat::is_chr (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_chr (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISBLK (@var{mode})\n\
 Return true if @var{mode} corresponds to a block device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISBLK: invalid MODE value");
 
-  return octave_value (file_stat::is_blk (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_blk (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISFIFO (@var{mode})\n\
 Return true if @var{mode} corresponds to a fifo.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISFIFO: invalid MODE value");
 
-  return octave_value (file_stat::is_fifo (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_fifo (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISLNK (@var{mode})\n\
 Return true if @var{mode} corresponds to a symbolic link.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISLNK: invalid MODE value");
 
-  return octave_value (file_stat::is_lnk (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_lnk (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISSOCK (@var{mode})\n\
 Return true if @var{mode} corresponds to a socket.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISSOCK: invalid MODE value");
 
-  return octave_value (file_stat::is_sock (static_cast<mode_t> (mode)));
+  return ovl (file_stat::is_sock (static_cast<mode_t> (mode)));
 }
 
 DEFUN (gethostname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} gethostname ()\n\
 Return the hostname of the system where Octave is running.\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_env::get_host_name ());
+  return ovl (octave_env::get_host_name ());
 }
 
 DEFUN (uname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.\n\
 \n\
 For example:\n\
@@ -1138,17 +1138,17 @@ true if the child terminated normally.\n
 @seealso{waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WIFEXITED: STATUS must be an integer");
 
-  return octave_value (octave_wait::ifexited (status));
+  return ovl (octave_wait::ifexited (status));
 }
 
 DEFUNX ("WEXITSTATUS", FWEXITSTATUS, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WEXITSTATUS (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the exit status of the child.\n\
 \n\
@@ -1156,33 +1156,33 @@ This function should only be employed if
 @seealso{waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WEXITSTATUS: STATUS must be an integer");
 
-  return octave_value (octave_wait::exitstatus (status));
+  return ovl (octave_wait::exitstatus (status));
 }
 
 DEFUNX ("WIFSIGNALED", FWIFSIGNALED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WIFSIGNALED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was terminated by a signal.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WIFSIGNALED: STATUS must be an integer");
 
-  return octave_value (octave_wait::ifsignaled (status));
+  return ovl (octave_wait::ifsignaled (status));
 }
 
 DEFUNX ("WTERMSIG", FWTERMSIG, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WTERMSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the number of the signal that caused the child process to terminate.\n\
 \n\
@@ -1190,17 +1190,17 @@ This function should only be employed if
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WTERMSIG: STATUS must be an integer");
 
-  return octave_value (octave_wait::termsig (status));
+  return ovl (octave_wait::termsig (status));
 }
 
 DEFUNX ("WCOREDUMP", FWCOREDUMP, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WCOREDUMP (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child produced a core dump.\n\
 \n\
@@ -1210,17 +1210,17 @@ and is not available on some Unix implem
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WCOREDUMP: STATUS must be an integer");
 
-  return octave_value (octave_wait::coredump (status));
+  return ovl (octave_wait::coredump (status));
 }
 
 DEFUNX ("WIFSTOPPED", FWIFSTOPPED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WIFSTOPPED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was stopped by delivery of a signal.\n\
 \n\
@@ -1229,17 +1229,17 @@ the child is being traced (see ptrace(2)
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WIFSTOPPED: STATUS must be an integer");
 
-  return octave_value (octave_wait::ifstopped (status));
+  return ovl (octave_wait::ifstopped (status));
 }
 
 DEFUNX ("WSTOPSIG", FWSTOPSIG, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WSTOPSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 the number of the signal which caused the child to stop.\n\
 \n\
@@ -1247,33 +1247,33 @@ This function should only be employed if
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WIFCONTINUED}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WSTOPSIG: STATUS must be an integer");
 
-  return octave_value (octave_wait::stopsig (status));
+  return ovl (octave_wait::stopsig (status));
 }
 
 DEFUNX ("WIFCONTINUED", FWIFCONTINUED, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} WIFCONTINUED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return\n\
 true if the child process was resumed by delivery of @code{SIGCONT}.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   int status = args(0).xint_value ("WIFCONTINUED: STATUS must be an integer");
 
-  return octave_value (octave_wait::ifcontinued (status));
+  return ovl (octave_wait::ifcontinued (status));
 }
 
 DEFUNX ("canonicalize_file_name", Fcanonicalize_file_name, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
 Return the canonical name of file @var{fname}.\n\
 \n\
 If the file does not exist the empty string (\"\") is returned.\n\
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -611,17 +611,17 @@ returns a string containing the value of
 @seealso{setenv, unsetenv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).string_value ();
 
-  return octave_value (octave_env::getenv (name));
+  return ovl (octave_env::getenv (name));
 }
 
 /*
 %!assert (ischar (getenv ("OCTAVE_HOME")))
 */
 
 DEFUN (setenv, args, ,
        "-*- texinfo -*-\n\
@@ -673,17 +673,17 @@ occurred.\n\
 @seealso{setenv, getenv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string tmp = args(0).string_value ();
 
-  return octave_value (gnulib::unsetenv (tmp.c_str ()));
+  return ovl (gnulib::unsetenv (tmp.c_str ()));
 }
 
 /*
 ## Test for unsetenv is in setenv test
 */
 
 // FIXME: perhaps kbhit should also be able to print a prompt?
 
@@ -728,17 +728,17 @@ returning the empty string if no key is 
       if (c == -1)
         c = 0;
 
       char s[2] = { static_cast<char> (c), '\0' };
 
       retval = s;
     }
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (pause, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} pause ()\n\
 @deftypefnx {} {} pause (@var{n})\n\
 Suspend the execution of the program for @var{n} seconds.\n\
 \n\
@@ -764,50 +764,48 @@ disp (\"wait please...\");\n\
 pause (5);\n\
 clc;\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{kbhit}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
-      if (! xisnan (dval))
+      if (xisnan (dval))
+        warning ("pause: NaN is an invalid delay");
+      else
         {
           Fdrawnow ();
 
           if (xisinf (dval))
             {
               flush_octave_stdout ();
               octave_kbhit ();
             }
           else
             octave_sleep (dval);
         }
-      else
-        warning ("pause: NaN is an invalid delay");
     }
   else
     {
       Fdrawnow ();
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
-  return retval;
+  return octave_value_list ();
 }
 
 /*
 %!test
 %! pause (1);
 
 %!error (pause (1, 2))
 */
@@ -821,33 +819,33 @@ DEFUN (isieee, , ,
 Return true if your computer @emph{claims} to conform to the IEEE standard\n\
 for floating point calculations.\n\
 \n\
 No actual tests are performed.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
-  return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-                       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+  return ovl (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
+              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
 %!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} native_float_format ()\n\
 Return the native floating point format as a string.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
-  return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
+  return ovl (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
        "-*- texinfo -*-\n\
@@ -872,33 +870,29 @@ Examples:\n\
 tilde_expand (\"~joeuser/bin\")\n\
      @result{} \"/home/joeuser/bin\"\n\
 tilde_expand (\"~/bin\")\n\
      @result{} \"/home/jwe/bin\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   string_vector sv = arg.xall_strings ("tilde_expand: argument must be char or cellstr object");
 
   sv = file_ops::tilde_expand (sv);
 
   if (arg.is_cellstr ())
-    retval = Cell (arg.dims (), sv);
+    return ovl (Cell (arg.dims (), sv));
   else
-    retval = sv;
-
-  return retval;
+    return ovl (sv);
 }
 
 /*
 %!test
 %! home = get_home_directory ();
 %! assert (tilde_expand ("~/foobar"), [home "/foobar"]);
 %! assert (tilde_expand ("/foo/bar"), "/foo/bar");
 %! assert (tilde_expand ("foo/bar"), "foo/bar");
@@ -911,17 +905,17 @@ Return the current home directory.\n\
 \n\
 On most systems, this is equivalent to @code{getenv (\"HOME\")}.  On Windows\n\
 systems, if the environment variable @env{HOME} is not set then it is\n\
 equivalent to\n\
 @code{fullfile (getenv (\"HOMEDRIVE\"), getenv (\"HOMEPATH\"))}\n\
 @seealso{getenv}\n\
 @end deftypefn")
 {
-  return octave_value (octave_env::get_home_directory ());
+  return ovl (octave_env::get_home_directory ());
 }
 
 /*
 %!test
 %! if (! ispc ())
 %!   assert (get_home_directory (), getenv ("HOME"));
 %! endif
 */
@@ -933,10 +927,10 @@ equivalent to\n\
 DEFUN (have_window_system, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} have_window_system ()\n\
 Return true if a window system is available (X11, Windows, or Apple OS X)\n\
 and false otherwise.\n\
 @seealso{isguirunning}\n\
 @end deftypefn")
 {
-  return octave_value (display_info::display_available ());
+  return ovl (display_info::display_available ());
 }
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -112,17 +112,17 @@ The epoch is referenced to 00:00:00 CUT 
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the value\n\
 returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_time ());
+  return ovl (octave_time ());
 }
 
 /*
 %!assert (time () > 0)
 
 %!error time (1)
 */
 
@@ -156,17 +156,17 @@ gmtime (time ())\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double tmp = args(0).double_value ();
 
-  return octave_value (mk_tm_map (octave_gmtime (tmp)));
+  return ovl (mk_tm_map (octave_gmtime (tmp)));
 }
 
 /*
 %!test
 %! ts = gmtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -211,17 +211,17 @@ localtime (time ())\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double tmp = args(0).double_value ();
 
-  return octave_value (mk_tm_map (octave_localtime (tmp)));
+  return ovl (mk_tm_map (octave_localtime (tmp)));
 }
 
 /*
 %!test
 %! ts = localtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -257,17 +257,17 @@ mktime (localtime (time ()))\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_scalar_map map = args(0).xscalar_map_value ("mktime: TM_STRUCT argument must be a structure");
 
   octave_base_tm tm = extract_tm (map, "mktime");
 
-  return octave_value (octave_time (tm));
+  return ovl (octave_time (tm));
 }
 
 /*
 %!test
 %! t = time ();
 %! assert (fix (mktime (localtime (t))) == fix (t));
 
 ## These tests fail on systems with mktime functions of limited
@@ -446,17 +446,17 @@ Year (1970-).\n\
     print_usage ();
 
   std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
 
   octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
 
   octave_base_tm tm = extract_tm (map, "strftime");
 
-  return octave_value (tm.strftime (fmt));
+  return ovl (tm.strftime (fmt));
 }
 
 /*
 %!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))));
 %!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))));
 %!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
 %!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
 %!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1017,41 +1017,41 @@ command that was written to the standard
 will set the variable @code{output} to the string @samp{foo}, and the\n\
 variable @code{status} to the integer @samp{2}.\n\
 \n\
 For commands run asynchronously, @var{status} is the process id of the\n\
 command shell that is started to run the command.\n\
 @seealso{unix, dos}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-  unwind_protect frame;
-
   int nargin = args.length ();
 
   if (nargin == 0 || nargin > 3)
     print_usage ();
 
-  bool return_output = (nargin == 1 && nargout > 1);
-
   system_exec_type type = et_sync;
-
   if (nargin == 3)
     {
       std::string type_str = args(2).xstring_value ("system: TYPE must be a string");
 
       if (type_str == "sync")
         type = et_sync;
       else if (type_str == "async")
         type = et_async;
       else
         error ("system: TYPE must be \"sync\" or \"async\"");
     }
 
+  octave_value_list retval;
+
+  // FIXME: Is this unwind_protect frame needed anymore (12/16/15)?
+  unwind_protect frame;
+
+  bool return_output = (nargin == 1 && nargout > 1);
+
   if (nargin > 1)
     {
       try
         {
           return_output = args(1).is_true ();
         }
       catch (octave_execution_exception& e)
         {
@@ -1203,37 +1203,37 @@ will remove the function from the list a
 @code{last_words} when it exits.\n\
 \n\
 Note that @code{atexit} only removes the first occurrence of a function\n\
 from the list, so if a function was placed in the list multiple times with\n\
 @code{atexit}, it must also be removed from the list multiple times.\n\
 @seealso{quit}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string arg = args(0).xstring_value ("atexit: FCN argument must be a string");
 
   bool add_mode = (nargin == 2)
     ? args(1).xbool_value ("atexit: FLAG argument must be a logical value")
     : true;
 
+  octave_value_list retval;
+
   if (add_mode)
     octave_add_atexit_function (arg);
   else
     {
       bool found = octave_remove_atexit_function (arg);
 
       if (nargout > 0)
-        retval(0) = found;
+        retval = ovl (found);
     }
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} octave_config_info ()\n\
@@ -1242,18 +1242,16 @@ Return a structure containing configurat
 Octave.\n\
 \n\
 If @var{option} is a string, return the configuration information for the\n\
 specified option.\n\
 \n\
 @seealso{computer}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #if defined (ENABLE_DYNAMIC_LINKING)
   bool octave_supports_dynamic_linking = true;
 #else
   bool octave_supports_dynamic_linking = false;
 #endif
 
   static bool initialized = false;
   static octave_scalar_map m;
@@ -1507,34 +1505,34 @@ specified option.\n\
       initialized = true;
     }
 
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
-      if (m.isfield (arg))
-        {
-          Cell c = m.contents (arg);
+      if (! m.isfield (arg))
+        error ("octave_config_info: invalid parameter '%s'", arg.c_str ());
+
+      Cell c = m.contents (arg);
 
-          if (c.is_empty ())
-            error ("octave_config_info: no info for '%s'", arg.c_str ());
-          else
-            retval = c(0);
-        }
-      else
-        error ("octave_config_info: invalid parameter '%s'", arg.c_str ());
+      if (c.is_empty ())
+        error ("octave_config_info: no info for '%s'", arg.c_str ());
+
+      retval = ovl (c(0));
     }
   else
-    retval = m;
+    retval = ovl (m);
 
   return retval;
 }
 
 /*
 %!assert (ischar (octave_config_info ("version")))
 %!test
 %! x = octave_config_info ();
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -181,156 +181,152 @@ do_trilu (const Sparse<T>& a, octave_idx
 }
 
 static octave_value
 do_trilu (const std::string& name,
           const octave_value_list& args)
 {
   bool lower = (name == "tril");
 
-  octave_value retval;
   int nargin = args.length ();
-  octave_idx_type k = 0;
   bool pack = false;
 
   if (nargin >= 2 && args(nargin-1).is_string ())
     {
-      pack = args(nargin-1).string_value () == "pack";
+      pack = (args(nargin-1).string_value () == "pack");
       nargin--;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_idx_type k = 0;
   if (nargin == 2)
     k = args(1).int_value (true);
 
   octave_value arg = args(0);
 
   dim_vector dims = arg.dims ();
   if (dims.length () != 2)
     error ("%s: need a 2-D matrix", name.c_str ());
   else if (k < -dims(0) || k > dims(1))
     error ("%s: requested diagonal out of range", name.c_str ());
-  else
+
+  octave_value retval;
+
+  switch (arg.builtin_type ())
     {
-      switch (arg.builtin_type ())
-        {
-        case btyp_double:
-          if (arg.is_sparse_type ())
-            retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
-          else
-            retval = do_trilu (arg.array_value (), k, lower, pack);
-          break;
+    case btyp_double:
+      if (arg.is_sparse_type ())
+        retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
+      else
+        retval = do_trilu (arg.array_value (), k, lower, pack);
+      break;
 
-        case btyp_complex:
-          if (arg.is_sparse_type ())
-            retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
-                               pack);
-          else
-            retval = do_trilu (arg.complex_array_value (), k, lower, pack);
-          break;
+    case btyp_complex:
+      if (arg.is_sparse_type ())
+        retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
+                           pack);
+      else
+        retval = do_trilu (arg.complex_array_value (), k, lower, pack);
+      break;
 
-        case btyp_bool:
-          if (arg.is_sparse_type ())
-            retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
-                               pack);
-          else
-            retval = do_trilu (arg.bool_array_value (), k, lower, pack);
-          break;
+    case btyp_bool:
+      if (arg.is_sparse_type ())
+        retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
+                           pack);
+      else
+        retval = do_trilu (arg.bool_array_value (), k, lower, pack);
+      break;
 
 #define ARRAYCASE(TYP)       \
-          case btyp_ ## TYP: \
-            retval = do_trilu (arg.TYP ## _array_value (), k, lower, pack); \
-            break
+      case btyp_ ## TYP: \
+        retval = do_trilu (arg.TYP ## _array_value (), k, lower, pack); \
+        break
 
-          ARRAYCASE (float);
-          ARRAYCASE (float_complex);
-          ARRAYCASE (int8);
-          ARRAYCASE (int16);
-          ARRAYCASE (int32);
-          ARRAYCASE (int64);
-          ARRAYCASE (uint8);
-          ARRAYCASE (uint16);
-          ARRAYCASE (uint32);
-          ARRAYCASE (uint64);
-          ARRAYCASE (char);
+      ARRAYCASE (float);
+      ARRAYCASE (float_complex);
+      ARRAYCASE (int8);
+      ARRAYCASE (int16);
+      ARRAYCASE (int32);
+      ARRAYCASE (int64);
+      ARRAYCASE (uint8);
+      ARRAYCASE (uint16);
+      ARRAYCASE (uint32);
+      ARRAYCASE (uint64);
+      ARRAYCASE (char);
 
 #undef ARRAYCASE
 
-        default:
-          {
-            // Generic code that works on octave-values, that is slow
-            // but will also work on arbitrary user types
+    default:
+      {
+        // Generic code that works on octave-values, that is slow
+        // but will also work on arbitrary user types
+        if (pack) // FIXME
+          error ("%s: \"pack\" not implemented for class %s",
+                 name.c_str (), arg.class_name ().c_str ());
 
-            if (pack) // FIXME
-              error ("%s: \"pack\" not implemented for class %s",
-                     name.c_str (), arg.class_name ().c_str ());
+        octave_value tmp = arg;
+        if (arg.numel () == 0)
+          return arg;
 
-            octave_value tmp = arg;
-            if (arg.numel () == 0)
-              return arg;
+        octave_idx_type nr = dims(0);
+        octave_idx_type nc = dims(1);
 
-            octave_idx_type nr = dims(0);
-            octave_idx_type nc = dims(1);
+        // The sole purpose of this code is to force the correct matrix size.
+        // This would not be necessary if the octave_value resize function
+        // allowed a fill_value.  It also allows odd attributes in some user
+        // types to be handled.  With a fill_value, it should be replaced with
+        //
+        // octave_value_list ov_idx;
+        // tmp = tmp.resize(dim_vector (0,0)).resize (dims, fill_value);
 
-            // The sole purpose of the below is to force the correct
-            // matrix size. This would not be necessary if the
-            // octave_value resize function allowed a fill_value.
-            // It also allows odd attributes in some user types
-            // to be handled. With a fill_value ot should be replaced
-            // with
-            //
-            // octave_value_list ov_idx;
-            // tmp = tmp.resize(dim_vector (0,0)).resize (dims, fill_value);
+        octave_value_list ov_idx;
+        std::list<octave_value_list> idx_tmp;
+        ov_idx(1) = static_cast<double> (nc+1);
+        ov_idx(0) = Range (1, nr);
+        idx_tmp.push_back (ov_idx);
+        ov_idx(1) = static_cast<double> (nc);
+        tmp = tmp.resize (dim_vector (0,0));
+        tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+        tmp = tmp.resize (dims);
 
-            octave_value_list ov_idx;
-            std::list<octave_value_list> idx_tmp;
-            ov_idx(1) = static_cast<double> (nc+1);
-            ov_idx(0) = Range (1, nr);
-            idx_tmp.push_back (ov_idx);
-            ov_idx(1) = static_cast<double> (nc);
-            tmp = tmp.resize (dim_vector (0,0));
-            tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
-            tmp = tmp.resize (dims);
+        if (lower)
+          {
+            octave_idx_type st = nc < nr + k ? nc : nr + k;
 
-            if (lower)
+            for (octave_idx_type j = 1; j <= st; j++)
               {
-                octave_idx_type st = nc < nr + k ? nc : nr + k;
-
-                for (octave_idx_type j = 1; j <= st; j++)
-                  {
-                    octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
-                    ov_idx(1) = static_cast<double> (j);
-                    ov_idx(0) = Range (nr_limit, nr);
-                    std::list<octave_value_list> idx;
-                    idx.push_back (ov_idx);
+                octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
+                ov_idx(1) = static_cast<double> (j);
+                ov_idx(0) = Range (nr_limit, nr);
+                std::list<octave_value_list> idx;
+                idx.push_back (ov_idx);
 
-                    tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-                  }
+                tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
               }
-            else
-              {
-                octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
+          }
+        else
+          {
+            octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
 
-                for (octave_idx_type j = st; j <= nc; j++)
-                  {
-                    octave_idx_type nr_limit = nr < j - k ? nr : j - k;
-                    ov_idx(1) = static_cast<double> (j);
-                    ov_idx(0) = Range (1, nr_limit);
-                    std::list<octave_value_list> idx;
-                    idx.push_back (ov_idx);
+            for (octave_idx_type j = st; j <= nc; j++)
+              {
+                octave_idx_type nr_limit = nr < j - k ? nr : j - k;
+                ov_idx(1) = static_cast<double> (j);
+                ov_idx(0) = Range (1, nr_limit);
+                std::list<octave_value_list> idx;
+                idx.push_back (ov_idx);
 
-                    tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-                  }
+                tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
               }
+          }
 
-            retval = tmp;
-          }
-        }
+        retval = tmp;
+      }
     }
 
   return retval;
 }
 
 DEFUN (tril, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} tril (@var{A})\n\
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -65,23 +65,21 @@ DEFUN (tsearch, args, ,
 Search for the enclosing Delaunay convex hull.\n\
 \n\
 For @code{@var{t} = delaunay (@var{x}, @var{y})}, finds the index in @var{t}\n\
 containing the points @code{(@var{xi}, @var{yi})}.  For points outside the\n\
 convex hull, @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  if (args.length () != 5)
+    print_usage ();
 
   const double eps = 1.0e-12;
 
-  if (args.length () != 5)
-    print_usage ();
-
   const ColumnVector x (args(0).vector_value ());
   const ColumnVector y (args(1).vector_value ());
   const Matrix elem (args(2).matrix_value ());
   const ColumnVector xi (args(3).vector_value ());
   const ColumnVector yi (args(4).vector_value ());
 
   const octave_idx_type nelem = elem.rows ();
 
@@ -153,19 +151,17 @@ convex hull, @var{idx} is NaN.\n\
             } //endif # examine this element closely
         } //endfor # each element
 
       if (k == nelem)
         values(kp) = lo_ieee_nan_value ();
 
     } //endfor # kp
 
-  retval(0) = values;
-
-  return retval;
+  return ovl (values);
 }
 
 /*
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1, 2, 3];
 %!assert (tsearch (x,y,tri,-1,-1), 1)
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -137,22 +137,23 @@ An example of the use of typecast on a l
 @var{x} = uint16 ([1, 65535]);\n\
 typecast (@var{x}, \"uint8\")\n\
 @result{} [   1,   0, 255, 255]\n\
 @end group\n\
 @end example\n\
 @seealso{cast, bitpack, bitunpack, swapbytes}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   unwind_protect frame;
+
   const void *data = 0;
   octave_idx_type byte_size = 0;
   dim_vector old_dims;
 
   octave_value array = args(0);
 
   if (array.is_bool_type ())
     get_data_and_bytesize (array.bool_array_value (), data, byte_size,
@@ -326,24 +327,24 @@ The number of elements of @var{x} should
 increasing order of significance, i.e., @code{x(1)} is bit 0, @code{x(2)} is\n\
 bit 1, etc.\n\
 \n\
 The result is a row vector if @var{x} is a row vector, otherwise it is a\n\
 column vector.\n\
 @seealso{bitunpack, typecast}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
   if (! args(0).is_bool_type ())
     error ("bitpack: X must be a logical array");
 
+  octave_value retval;
+
   boolNDArray bitp = args(0).bool_array_value ();
 
   std::string numclass = args(1).string_value ();
 
   if (numclass.size () == 0)
     ;
   else if (numclass == "char")
     retval = octave_value (do_bitpack<charNDArray> (bitp), '\'');
@@ -435,24 +436,24 @@ Return a logical array @var{y} correspon
 @end group\n\
 @end example\n\
 \n\
 The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
 @seealso{bitpack, typecast}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   if (! (args(0).is_numeric_type () || args(0).is_string ()))
     error ("bitunpack: argument must be a number or a string");
 
+  octave_value retval;
+
   octave_value array = args(0);
 
   if (array.is_string ())
     retval = do_bitunpack (array.char_array_value ());
   else if (array.is_integer_type ())
     {
       if (array.is_int8_type ())
         retval = do_bitunpack (array.int8_array_value ());
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -325,27 +325,25 @@ For example:\n\
 @group\n\
 urlwrite (\"http://www.google.com/search\", \"search.html\",\n\
           \"get\", @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlread}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     print_usage ();
 
   std::string url = args(0).xstring_value ("urlwrite: URL must be a string");
 
-  // name to store the file if download is succesful
+  // name to store the file if download is successful
   std::string filename = args(1).xstring_value ("urlwrite: LOCALFILE must be a string");
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
       method = args(2).xstring_value ("urlwrite: METHOD must be a string");
@@ -371,39 +369,38 @@ urlwrite (\"http://www.google.com/search
     error ("urlwrite: unable to open file");
 
   unwind_protect_safe frame;
 
   frame.add_fcn (delete_file, filename);
 
   url_transfer curl = url_transfer (url, ofile);
 
-  if (curl.is_valid ())
-    {
-      curl.http_action (param, method);
+  octave_value_list retval;
 
-      ofile.close ();
+  if (! curl.is_valid ())
+    error ("support for URL transfers was disabled when Octave was built");
 
-      if (curl.good ())
-        frame.discard ();
+  curl.http_action (param, method);
+
+  ofile.close ();
 
-      if (nargout > 0)
-        {
-          if (curl.good ())
-            retval = ovl (octave_env::make_absolute (filename),
-                          true, std::string ());
-          else
-            retval = ovl (std::string (), false, curl.lasterror ());
-        }
+  if (curl.good ())
+    frame.discard ();
 
-      if (nargout < 2 && ! curl.good ())
-        error ("urlwrite: %s", curl.lasterror ().c_str ());
+  if (nargout > 0)
+    {
+      if (curl.good ())
+        retval = ovl (octave_env::make_absolute (filename), true, "");
+      else
+        retval = ovl ("", false, curl.lasterror ());
     }
-  else
-    error ("support for URL transfers was disabled when Octave was built");
+
+  if (nargout < 2 && ! curl.good ())
+    error ("urlwrite: %s", curl.lasterror ().c_str ());
 
   return retval;
 }
 
 DEFUN (urlread, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
@@ -442,19 +439,16 @@ For example:\n\
 @group\n\
 s = urlread (\"http://www.google.com/search\", \"get\",\n\
             @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
 @end deftypefn")
 {
-  // Octave's return value
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   // verify arguments
   if (nargin != 1 && nargin != 3)
     print_usage ();
 
   std::string url = args(0).xstring_value ("urlread: URL must be a string");
 
@@ -473,32 +467,32 @@ s = urlread (\"http://www.google.com/sea
       if (param.numel () % 2 == 1)
         error ("urlread: number of elements in PARAM must be even");
     }
 
   std::ostringstream buf;
 
   url_transfer curl = url_transfer (url, buf);
 
-  if (curl.is_valid ())
-    {
-      curl.http_action (param, method);
+  if (! curl.is_valid ())
+    error ("support for URL transfers was disabled when Octave was built");
+
+  curl.http_action (param, method);
+
+  octave_value_list retval;
 
-      if (nargout > 0)
-        {
-          // Return empty string if no error occurred.
-          retval = ovl (buf.str (), curl.good (),
-                        curl.good () ? "" : curl.lasterror ());
-        }
+  if (nargout > 0)
+    {
+      // Return empty string if no error occurred.
+      retval = ovl (buf.str (), curl.good (),
+                    curl.good () ? "" : curl.lasterror ());
+    }
 
-      if (nargout < 2 && ! curl.good ())
-        error ("urlread: %s", curl.lasterror().c_str());
-    }
-  else
-    error ("support for URL transfers was disabled when Octave was built");
+  if (nargout < 2 && ! curl.good ())
+    error ("urlread: %s", curl.lasterror ().c_str ());
 
   return retval;
 }
 
 DEFUN (__ftp__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{handle} =} __ftp__ (@var{host})\n\
 @deftypefnx {} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
@@ -527,482 +521,414 @@ Undocumented internal function\n\
 }
 
 DEFUN (__ftp_pwd__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        retval = curl.pwd ();
-      else
-        error ("__ftp_pwd__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_pwd__: invalid ftp handle");
 
-  return retval;
+  return ovl (curl.pwd ());
 }
 
 DEFUN (__ftp_cwd__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     error ("__ftp_cwd__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string path = "";
+  std::string path = "";
+  if (nargin > 1)
+    path = args(1).xstring_value ("__ftp_cwd__: PATH must be a string");
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          if (nargin > 1)
-            path = args(1).xstring_value ("__ftp_cwd__: PATH must be a string");
+  if (! curl.is_valid ())
+    error ("__ftp_cwd__: invalid ftp handle");
 
-          curl.cwd (path);
-        }
-      else
-        error ("__ftp_cwd__: invalid ftp handle");
-    }
+  curl.cwd (path);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_dir__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
+  if (args.length () != 1)
+    error ("__ftp_dir__: incorrect number of arguments");
+
+  url_transfer curl = ch_manager::get_object (args(0));
+
+  if (! curl.is_valid ())
+    error ("__ftp_dir__: invalid ftp handle");
+
   octave_value retval;
 
-  if (args.length () != 1)
-    error ("__ftp_dir__: incorrect number of arguments");
+  if (nargout == 0)
+    curl.dir ();
   else
     {
-      url_transfer curl = ch_manager::get_object (args(0));
-
-      if (curl.is_valid ())
-        {
-          if (nargout == 0)
-            curl.dir ();
-          else
-            {
-              string_vector sv = curl.list ();
-              octave_idx_type n = sv.numel ();
+      string_vector sv = curl.list ();
+      octave_idx_type n = sv.numel ();
 
-              if (n == 0)
-                {
-                  string_vector flds (5);
-
-                  flds(0) = "name";
-                  flds(1) = "date";
-                  flds(2) = "bytes";
-                  flds(3) = "isdir";
-                  flds(4) = "datenum";
-
-                  retval = octave_map (flds);
-                }
-              else
-                {
-                  octave_map st;
+      if (n == 0)
+        {
+          string_vector flds (5);
 
-                  Cell filectime (dim_vector (n, 1));
-                  Cell filesize (dim_vector (n, 1));
-                  Cell fileisdir (dim_vector (n, 1));
-                  Cell filedatenum (dim_vector (n, 1));
-
-                  st.assign ("name", Cell (sv));
-
-                  for (octave_idx_type i = 0; i < n; i++)
-                    {
-                      time_t ftime;
-                      bool fisdir;
-                      double fsize;
-
-                      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+          flds(0) = "name";
+          flds(1) = "date";
+          flds(2) = "bytes";
+          flds(3) = "isdir";
+          flds(4) = "datenum";
 
-                      fileisdir (i) = fisdir;
-                      filectime (i) = ctime (&ftime);
-                      filesize (i) = fsize;
-                      filedatenum (i) = double (ftime);
-                    }
-
-                  st.assign ("date", filectime);
-                  st.assign ("bytes", filesize);
-                  st.assign ("isdir", fileisdir);
-                  st.assign ("datenum", filedatenum);
-
-                  retval = st;
-                }
-            }
+          retval = octave_map (flds);
         }
       else
-        error ("__ftp_dir__: invalid ftp handle");
+        {
+          octave_map st;
+
+          Cell filectime (dim_vector (n, 1));
+          Cell filesize (dim_vector (n, 1));
+          Cell fileisdir (dim_vector (n, 1));
+          Cell filedatenum (dim_vector (n, 1));
+
+          st.assign ("name", Cell (sv));
+
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              time_t ftime;
+              bool fisdir;
+              double fsize;
+
+              curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+
+              fileisdir (i) = fisdir;
+              filectime (i) = ctime (&ftime);
+              filesize (i) = fsize;
+              filedatenum (i) = double (ftime);
+            }
+
+          st.assign ("date", filectime);
+          st.assign ("bytes", filesize);
+          st.assign ("isdir", fileisdir);
+          st.assign ("datenum", filedatenum);
+
+          retval = st;
+        }
     }
 
   return retval;
 }
 
 DEFUN (__ftp_ascii__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        curl.ascii ();
-      else
-        error ("__ftp_ascii__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_ascii__: invalid ftp handle");
 
-  return retval;
+  curl.ascii ();
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_binary__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     error ("__ftp_binary__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        curl.binary ();
-      else
-        error ("__ftp_binary__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_binary__: invalid ftp handle");
 
-  return retval;
+  curl.binary ();
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_close__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_close__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     error ("__ftp_close__: incorrect number of arguments");
-  else
-    {
-      curl_handle h = ch_manager::lookup (args(0));
+
+  curl_handle h = ch_manager::lookup (args(0));
 
-      if (h.ok ())
-        ch_manager::free (h);
-      else
-        error ("__ftp_close__: invalid ftp handle");
-    }
+  if (! h.ok ())
+    error ("__ftp_close__: invalid ftp handle");
 
-  return retval;
+  ch_manager::free (h);
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_mode__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_mode__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     error ("__ftp_mode__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  octave_value retval;
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        retval = (curl.is_ascii () ? "ascii" : "binary");
-      else
-        error ("__ftp_binary__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_binary__: invalid ftp handle");
 
-  return retval;
+  return ovl (curl.is_ascii () ? "ascii" : "binary");
 }
 
 DEFUN (__ftp_delete__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     error ("__ftp_delete__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string file = args(1).xstring_value ("__ftp_delete__: FILE must be a string");
+  std::string file = args(1).xstring_value ("__ftp_delete__: FILE must be a string");
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          curl.del (file);
-        }
-      else
-        error ("__ftp_delete__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_delete__: invalid ftp handle");
 
-  return retval;
+  curl.del (file);
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_rmdir__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string dir = args(1).xstring_value ("__ftp_rmdir__: DIR must be a string");
+  std::string dir = args(1).xstring_value ("__ftp_rmdir__: DIR must be a string");
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          curl.rmdir (dir);
-        }
-      else
-        error ("__ftp_rmdir__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_rmdir__: invalid ftp handle");
 
-  return retval;
+  curl.rmdir (dir);
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_mkdir__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string dir = args(1).xstring_value ("__ftp_mkdir__: DIR must be a string");
+  std::string dir = args(1).xstring_value ("__ftp_mkdir__: DIR must be a string");
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          curl.mkdir (dir);
-        }
-      else
-        error ("__ftp_mkdir__: invalid ftp handle");
-    }
+  if (! curl.is_valid ())
+    error ("__ftp_mkdir__: invalid ftp handle");
 
-  return retval;
+  curl.mkdir (dir);
+
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_rename__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     error ("__ftp_rename__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  std::string oldname = args(1).xstring_value ("__ftp_rename__: OLDNAME must be a string");
+  std::string newname = args(2).xstring_value ("__ftp_rename__: NEWNAME must be a string");
+
+  url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string oldname = args(1).xstring_value ("__ftp_rename__: OLDNAME must be a string");
-          std::string newname = args(2).xstring_value ("__ftp_rename__: NEWNAME must be a string");
+  if (curl.is_valid ())
+    error ("__ftp_rename__: invalid ftp handle");
 
-          curl.rename (oldname, newname);
-        }
-      else
-        error ("__ftp_rename__: invalid ftp handle");
-    }
+  curl.rename (oldname, newname);
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (__ftp_mput__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     error ("__ftp_mput__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (curl.is_valid ())
-        {
-          std::string pat = args(1).xstring_value ("__ftp_mput__: PATTERN must be a string");
+  std::string pat = args(1).xstring_value ("__ftp_mput__: PATTERN must be a string");
 
-          string_vector file_list;
-
-          glob_match pattern (file_ops::tilde_expand (pat));
-          string_vector files = pattern.glob ();
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          for (octave_idx_type i = 0; i < files.numel (); i++)
-            {
-              std::string file = files (i);
-
-              file_stat fs (file);
+  if (! curl.is_valid ())
+    error ("__ftp_mput__: invalid ftp handle");
 
-              if (! fs.exists ())
-                error ("__ftp__mput: file does not exist");
+  string_vector file_list;
 
-              if (fs.is_dir ())
-                {
-                  file_list.append (curl.mput_directory ("", file));
+  glob_match pattern (file_ops::tilde_expand (pat));
+  string_vector files = pattern.glob ();
 
-                  if (! curl.good ())
-                    error ("__ftp_mput__: %s", curl.lasterror().c_str());
-                }
-              else
-                {
-                  // FIXME: Does ascii mode need to be flagged here?
-                  std::ifstream ifile (file.c_str (), std::ios::in |
-                                       std::ios::binary);
+  for (octave_idx_type i = 0; i < files.numel (); i++)
+    {
+      std::string file = files(i);
 
-                  if (! ifile.is_open ())
-                    error ("__ftp_mput__: unable to open file");
+      file_stat fs (file);
 
-                  curl.put (file, ifile);
-
-                  ifile.close ();
-
-                  if (! curl.good ())
-                    error ("__ftp_mput__: %s", curl.lasterror().c_str());
+      if (! fs.exists ())
+        error ("__ftp__mput: file does not exist");
 
-                  file_list.append (file);
-                }
-            }
+      if (fs.is_dir ())
+        {
+          file_list.append (curl.mput_directory ("", file));
 
-          if (nargout > 0)
-            retval = file_list;
+          if (! curl.good ())
+            error ("__ftp_mput__: %s", curl.lasterror ().c_str ());
         }
       else
-        error ("__ftp_mput__: invalid ftp handle");
+        {
+          // FIXME: Does ascii mode need to be flagged here?
+          std::ifstream ifile (file.c_str (), std::ios::in | std::ios::binary);
+
+          if (! ifile.is_open ())
+            error ("__ftp_mput__: unable to open file");
+
+          curl.put (file, ifile);
+
+          ifile.close ();
+
+          if (! curl.good ())
+            error ("__ftp_mput__: %s", curl.lasterror ().c_str ());
+
+          file_list.append (file);
+        }
     }
 
-  return retval;
+  if (nargout > 0)
+    return ovl (file_list);
+  else
+    return octave_value_list ();
 }
 
 DEFUN (__ftp_mget__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __ftp_mget__ (@var{handle}, @var{pattern})\n\
 @deftypefnx {} {} __ftp_mget__ (@var{handle}, @var{pattern}, @var{target})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
-  else
-    {
-      url_transfer curl = ch_manager::get_object (args(0));
+
+  std::string file = args(1).xstring_value ("__ftp_mget__: PATTERN must be a string");
+
+  std::string target;
 
-      if (curl.is_valid ())
-        {
-          std::string file = args(1).xstring_value ("__ftp_mget__: PATTERN must be a string");
-          std::string target;
+  if (nargin == 3 && ! args(2).is_empty ())
+    target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
 
-          if (nargin == 3 && ! args(2).is_empty ())
-            target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
+  url_transfer curl = ch_manager::get_object (args(0));
 
-          string_vector sv = curl.list ();
-          octave_idx_type n = 0;
-          glob_match pattern (file);
-
+  if (! curl.is_valid ())
+    error ("__ftp_mget__: invalid ftp handle");
 
-          for (octave_idx_type i = 0; i < sv.numel (); i++)
-            {
-              if (pattern.match (sv(i)))
-                {
-                  n++;
+  string_vector sv = curl.list ();
+  octave_idx_type n = 0;
+  glob_match pattern (file);
 
-                  time_t ftime;
-                  bool fisdir;
-                  double fsize;
+  for (octave_idx_type i = 0; i < sv.numel (); i++)
+    {
+      if (pattern.match (sv(i)))
+        {
+          n++;
 
-                  curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+          time_t ftime;
+          bool fisdir;
+          double fsize;
+
+          curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-                  if (fisdir)
-                    curl.mget_directory (sv(i), target);
-                  else
-                    {
-                      std::ofstream ofile ((target + sv(i)).c_str (),
-                                           std::ios::out |
-                                           std::ios::binary);
-
-                      if (! ofile.is_open ())
-                        error ("__ftp_mget__: unable to open file");
+          if (fisdir)
+            curl.mget_directory (sv(i), target);
+          else
+            {
+              std::ofstream ofile ((target + sv(i)).c_str (),
+                                   std::ios::out |
+                                   std::ios::binary);
 
-                      unwind_protect_safe frame;
-
-                      frame.add_fcn (delete_file, target + sv(i));
+              if (! ofile.is_open ())
+                error ("__ftp_mget__: unable to open file");
 
-                      curl.get (sv(i), ofile);
+              unwind_protect_safe frame;
 
-                      ofile.close ();
+              frame.add_fcn (delete_file, target + sv(i));
 
-                      if (curl.good ())
-                        frame.discard ();
-                    }
+              curl.get (sv(i), ofile);
 
-                  if (! curl.good ())
-                    error ("__ftp_mget__: %s", curl.lasterror().c_str());
-                }
+              ofile.close ();
+
+              if (curl.good ())
+                frame.discard ();
             }
 
-          if (n == 0)
-            error ("__ftp_mget__: file not found");
+          if (! curl.good ())
+            error ("__ftp_mget__: %s", curl.lasterror().c_str());
         }
-      else
-        error ("__ftp_mget__: invalid ftp handle");
     }
 
-  return retval;
+  if (n == 0)
+    error ("__ftp_mget__: file not found");
+
+  return octave_value_list ();
 }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -94,21 +94,21 @@ valid_identifier (const std::string& s)
 
 DEFUN (isvarname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name.\n\
 @seealso{iskeyword, exist, who}\n\
 @end deftypefn")
 {
-  octave_value retval = false;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval = false;
+
   if (args(0).is_string ())
     {
       std::string varname = args(0).string_value ();
 
       retval = valid_identifier (varname) && ! is_keyword (varname);
     }
 
   return retval;
@@ -303,43 +303,39 @@ the loadpath for element of the cell arr
 matches.\n\
 \n\
 If the second optional argument @qcode{\"all\"} is supplied, return a cell\n\
 array containing the list of all files that have the same name in the path.\n\
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_path, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   string_vector names = args(0).xall_strings ("file_in_loadpath: FILE argument must be a string");
 
-  if (names.numel () > 0)
-    {
-      if (nargin == 1)
-        retval =
-          octave_env::make_absolute (load_path::find_first_of (names));
-      else if (nargin == 2)
-        {
-          std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
+  octave_value retval;
+
+  if (names.numel () == 0)
+    error ("file_in_loadpath: FILE argument must not be empty");
 
-          if (opt == "all")
-            retval = Cell (make_absolute
-                           (load_path::find_all_first_of (names)));
-          else
-            error ("file_in_loadpath: \"all\" is only valid second argument");
-        }
+  if (nargin == 1)
+    retval = octave_env::make_absolute (load_path::find_first_of (names));
+  else
+    {
+      std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
+
+      if (opt != "all")
+        error ("file_in_loadpath: \"all\" is only valid second argument");
+
+      retval = Cell (make_absolute (load_path::find_all_first_of (names)));
     }
-  else
-    error ("file_in_loadpath: FILE argument must not be empty");
 
   return retval;
 }
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
@@ -380,44 +376,41 @@ If the second argument is a cell array o
 the path for element of the cell array and return the first that matches.\n\
 \n\
 If the third optional argument @qcode{\"all\"} is supplied, return a cell\n\
 array containing the list of all files that have the same name in the path.\n\
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_loadpath, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
 
   string_vector names = args(1).xall_strings ("file_in_path: FILE argument must be a string");
 
-  if (names.numel () > 0)
-    {
-      if (nargin == 2)
-        retval = search_path_for_file (path, names);
-      else if (nargin == 3)
-        {
-          std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
+  octave_value retval;
+
+  if (names.numel () == 0)
+    error ("file_in_path: FILE argument must not be empty");
 
-          if (opt == "all")
-            retval = Cell (make_absolute
-                           (search_path_for_all_files (path, names)));
-          else
-            error ("file_in_path: \"all\" is only valid third argument");
-        }
+  if (nargin == 2)
+    retval = search_path_for_file (path, names);
+  else
+    {
+      std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
+
+      if (opt != "all")
+        error ("file_in_path: \"all\" is only valid third argument");
+
+      retval = Cell (make_absolute (search_path_for_all_files (path, names)));
     }
-  else
-    error ("file_in_path: FILE argument must not be empty");
 
   return retval;
 }
 
 /*
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
@@ -746,17 +739,17 @@ Escape sequences begin with a leading ba
 @seealso{undo_string_escapes}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
 
-  return octave_value (do_string_escapes (str));
+  return ovl (do_string_escapes (str));
 }
 
 /*
 %!assert (do_string_escapes ('foo\nbar'), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"])
 %!assert ("foo\nbar", ["foo", char(10), "bar"])
 
@@ -881,17 +874,17 @@ replaces the unprintable alert character
 @seealso{do_string_escapes}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
 
-  return octave_value (undo_string_escapes (str));
+  return ovl (undo_string_escapes (str));
 }
 
 /*
 %!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar')
 %!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar")
 %!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar")
 
 %!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v')
@@ -913,25 +906,21 @@ replaces the unprintable alert character
 
 DEFUN (is_absolute_filename, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
-  octave_value retval = false;
-
   if (args.length () != 1)
     print_usage ();
 
-  retval = (args(0).is_string ()
-            && octave_env::absolute_pathname (args(0).string_value ()));
-
-  return retval;
+  return ovl (args(0).is_string ()
+              && octave_env::absolute_pathname (args(0).string_value ()));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_absolute_filename ()
 %!error is_absolute_filename ("foo", "bar")
 */
@@ -943,20 +932,18 @@ Return true if @var{file} is a rooted-re
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () != 1)
     print_usage ();
 
-  retval = (args(0).is_string ()
-            && octave_env::rooted_relative_pathname (args(0).string_value ()));
-
-  return retval;
+  return ovl (args(0).is_string ()
+              && octave_env::rooted_relative_pathname (args(0).string_value ()));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
 */
@@ -971,17 +958,17 @@ No check is done for the existence of @v
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a filename");
 
-  return octave_value (octave_env::make_absolute (nm));
+  return ovl (octave_env::make_absolute (nm));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error make_absolute_filename ()
 %!error make_absolute_filename ("foo", "bar")
 */
@@ -998,33 +985,29 @@ The match is performed at the end of eac
 @nospell{@qcode{\"/some/dir/foo/bar/baz\"}}\n\
 @nospell{@qcode{\"/some/dir/allfoo/bar\"}}.\n\
 \n\
 If the optional second argument is supplied, return a cell array containing\n\
 all name matches rather than just the first.\n\
 @seealso{file_in_path, file_in_loadpath, path}\n\
 @end deftypefn")
 {
-  octave_value retval = std::string ();
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string dir;
 
   dir = args(0).xstring_value ("dir_in_loadpath: DIR must be a directory name");
 
   if (nargin == 1)
-    retval = load_path::find_dir (dir);
-  else if (nargin == 2)
-    retval = Cell (load_path::find_matching_dirs (dir));
-
-  return retval;
+    return ovl (load_path::find_dir (dir));
+  else
+    return ovl (Cell (load_path::find_matching_dirs (dir)));
 }
 
 /*
 %!test
 %! f = dir_in_loadpath ("plot");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
@@ -1047,23 +1030,23 @@ DEFUNX ("errno", Ferrno, args, ,
 @deftypefnx {} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
 set its value to @var{val} and return the previous value, or return\n\
 the named error code given @var{name} as a character string, or -1\n\
 if @var{name} is not found.\n\
 @seealso{errno_list}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string nm = args(0).string_value ();
 
           retval = octave_errno::lookup (nm);
         }
@@ -1100,17 +1083,17 @@ DEFUN (errno_list, args, ,
 @deftypefn {} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @seealso{errno}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (octave_errno::list ());
+  return ovl (octave_errno::list ());
 }
 
 /*
 %!assert (isstruct (errno_list ()))
 
 %!error errno_list ("foo")
 */
 
@@ -1385,28 +1368,27 @@ If present, @var{n} specifies the maximu
 indexed.  When possible the internal result is cached so that subsequent\n\
 indexing using @var{ind} will not perform the check again.\n\
 \n\
 Implementation Note: Strings are first converted to double values before the\n\
 checks for valid indices are made.  Unless a string contains the NULL\n\
 character @nospell{\"@xbackslashchar{}0\"}, it will always be a valid index.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  octave_idx_type n = 0;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_idx_type n = 0;
   if (nargin == 2)
     n = args(1).idx_type_value ();
 
+  octave_value retval;
+
   unwind_protect frame;
 
   frame.protect_var (discard_error_messages);
   discard_error_messages = true;
 
   try
     {
       idx_vector idx = args(0).index_vector (true);
@@ -1522,16 +1504,16 @@ Return true if running in the student ed
 \n\
 @code{isstudent} always returns false in Octave.\n\
 @seealso{false}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (false);
+  return ovl (false);
 }
 
 /*
 %!assert (isstudent (), false)
 
 %!error isstudent (1)
 */
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -319,18 +319,16 @@ looks_like_struct (const std::string& te
 #endif
 
   return retval;
 }
 
 static octave_value
 do_isglobal (const octave_value_list& args)
 {
-  octave_value retval = false;
-
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
   std::string name = args(0).string_value ();
 
@@ -573,38 +571,34 @@ variable, built-in function, oct-file, d
 @code{exist} returns 2 if a regular file called @var{name} is present in\n\
 Octave's search path.  If you want information about other types of files\n\
 not on the search path you should use some combination of the functions\n\
 @code{file_in_path} and @code{stat} instead.\n\
 \n\
 @seealso{file_in_loadpath, file_in_path, dir_in_loadpath, stat}\n\
 @end deftypefn")
 {
-  octave_value retval = false;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string name = args(0).xstring_value ("exist: NAME must be a string");
 
   if (nargin == 2)
     {
       std::string type = args(1).xstring_value ("exist: TYPE must be a string");
 
       if (type == "class")
         warning ("exist: \"class\" type argument is not implemented");
 
-      retval = symbol_exist (name, type);
+      return ovl (symbol_exist (name, type));
     }
   else
-    retval = symbol_exist (name);
-
-  return retval;
+    return ovl (symbol_exist (name));
 }
 
 /*
 %!shared dirtmp, __var1
 %! dirtmp = P_tmpdir ();
 %! __var1 = 1;
 
 %!assert (exist ("__%Highly_unlikely_name%__"), 0)
@@ -724,20 +718,17 @@ wants_local_change (const octave_value_l
   if (nargin == 2)
     {
       if (args(1).is_string () && args(1).string_value () == "local")
         {
           nargin = 1;
           retval = true;
         }
       else
-        {
-          error_with_cfn ("second argument must be \"local\"");
-          nargin = 0;
-        }
+        error_with_cfn ("second argument must be \"local\"");
     }
 
   return retval;
 }
 
 template <class T>
 bool try_local_protect (T& var)
 {
@@ -764,24 +755,25 @@ set_internal_variable (bool& var, const 
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       bool bval = args(0).xbool_value ("%s: argument must be a logical value", nm);
 
       var = bval;
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (char& var, const octave_value_list& args,
                        int nargout, const char *nm)
 {
@@ -793,16 +785,19 @@ set_internal_variable (char& var, const 
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: argument must be a single character", nm);
 
       switch (sval.length ())
         {
         case 1:
           var = sval[0];
@@ -812,18 +807,16 @@ set_internal_variable (char& var, const 
           var = '\0';
           break;
 
         default:
           error ("%s: argument must be a single character", nm);
           break;
         }
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (int& var, const octave_value_list& args,
                        int nargout, const char *nm,
                        int minval, int maxval)
@@ -836,30 +829,31 @@ set_internal_variable (int& var, const o
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       int ival = args(0).xint_value ("%s: argument must be an integer value", nm);
 
       if (ival < minval)
         error ("%s: arg must be greater than %d", nm, minval);
       else if (ival > maxval)
         error ("%s: arg must be less than or equal to %d",
                nm, maxval);
       else
         var = ival;
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (double& var, const octave_value_list& args,
                        int nargout, const char *nm,
                        double minval, double maxval)
@@ -872,29 +866,30 @@ set_internal_variable (double& var, cons
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       double dval = args(0).xscalar_value ("%s: argument must be a scalar value", nm);
 
       if (dval < minval)
         error ("%s: argument must be greater than %g", minval);
       else if (dval > maxval)
         error ("%s: argument must be less than or equal to %g", maxval);
       else
         var = dval;
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
                        int nargout, const char *nm, bool empty_ok)
 {
@@ -906,27 +901,28 @@ set_internal_variable (std::string& var,
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
 
       if (empty_ok || ! sval.empty ())
         var = sval;
       else
         error ("%s: value must not be empty", nm);
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (int& var, const octave_value_list& args,
                        int nargout, const char *nm, const char **choices)
 {
@@ -943,34 +939,35 @@ set_internal_variable (int& var, const o
     retval = choices[var];
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
 
       int i = 0;
       for (; i < nchoices; i++)
         {
           if (sval == choices[i])
             {
               var = i;
               break;
             }
         }
       if (i == nchoices)
         error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 struct
 whos_parameter
 {
   char command;
@@ -1980,99 +1977,95 @@ mislocked (const std::string& nm)
 
 DEFUN (mlock, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} mlock ()\n\
 Lock the current function into memory so that it can't be cleared.\n\
 @seealso{munlock, mislocked, persistent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
   octave_function *fcn = octave_call_stack::caller ();
 
-  if (fcn)
+  if (! fcn)
+    error ("mlock: invalid use outside a function");
+
     fcn->lock ();
-  else
-    error ("mlock: invalid use outside a function");
-
-  return retval;
+
+  return octave_value_list ();
 }
 
 DEFUN (munlock, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} munlock ()\n\
 @deftypefnx {} {} munlock (@var{fcn})\n\
 Unlock the named function @var{fcn}.\n\
 \n\
 If no function is named then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       std::string name = args(0).xstring_value ("munlock: FCN must be a string");
 
       munlock (name);
     }
   else
     {
       octave_function *fcn = octave_call_stack::caller ();
 
-      if (fcn)
-        fcn->unlock ();
-      else
+      if (! fcn)
         error ("munlock: invalid use outside a function");
+
+      fcn->unlock ();
     }
 
-  return retval;
+  return octave_value_list ();
 }
 
 
 DEFUN (mislocked, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} mislocked ()\n\
 @deftypefnx {} {} mislocked (@var{fcn})\n\
 Return true if the named function @var{fcn} is locked.\n\
 \n\
 If no function is named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       std::string name = args(0).xstring_value ("mislocked: FCN must be a string");
 
       retval = mislocked (name);
     }
   else
     {
       octave_function *fcn = octave_call_stack::caller ();
 
-      if (fcn)
-        retval = fcn->islocked ();
-      else
+      if (! fcn)
         error ("mislocked: invalid use outside a function");
+
+      retval = fcn->islocked ();
     }
 
   return retval;
 }
 
 // Deleting names from the symbol tables.
 
 static inline bool
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -83,26 +83,27 @@ octave_qhull_dims_ok (octave_idx_type di
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{T} =} __delaunayn__ (@var{pts})\n\
 @deftypefnx {} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
-  octave_value_list retval;
+#if defined (HAVE_QHULL)
+
+  int nargin = args.length ();
 
-#if defined (HAVE_QHULL)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  octave_value_list retval;
 
   retval(0) = 0.0;
 
-  int nargin = args.length ();
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-
   Matrix p (args(0).matrix_value ());
   const octave_idx_type dim = p.columns ();
   const octave_idx_type n = p.rows ();
 
   if (! octave_qhull_dims_ok (dim, n, "__delaynayn__"))
     return retval;
 
   // Default options
@@ -146,66 +147,64 @@ Undocumented internal function.\n\
       // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
       FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
       FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
       FILE *errfile = stderr;
 
-      if (outfile)
-        frame.add_fcn (close_fcn, outfile);
-      else
+      if (! outfile)
         error ("__delaunayn__: unable to create temporary file for output");
 
+      frame.add_fcn (close_fcn, outfile);
+
       int exitcode = qh_new_qhull (dim, n, pt_array,
                                    ismalloc, flags, outfile, errfile);
+      if (exitcode)
+        error ("__delaunayn__: qhull failed");
+
+      // triangulate non-simplicial facets
+      qh_triangulate ();
+
+      facetT *facet;
+      vertexT *vertex, **vertexp;
+      octave_idx_type nf = 0;
+      octave_idx_type i = 0;
+
+      FORALLfacets
+        {
+          if (! facet->upperdelaunay)
+            nf++;
+
+          // Double check.  Non-simplicial facets will cause segfault below
+          if (! facet->simplicial)
+            error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
+        }
+
       if (! exitcode)
         {
-          // triangulate non-simplicial facets
-          qh_triangulate ();
-
-          facetT *facet;
-          vertexT *vertex, **vertexp;
-          octave_idx_type nf = 0;
-          octave_idx_type i = 0;
+          Matrix simpl (nf, dim+1);
 
           FORALLfacets
             {
               if (! facet->upperdelaunay)
-                nf++;
+                {
+                  octave_idx_type j = 0;
 
-              // Double check.  Non-simplicial facets will cause segfault below
-              if (! facet->simplicial)
-                error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
+                  FOREACHvertex_ (facet->vertices)
+                    {
+                      simpl(i, j++) = 1 + qh_pointid(vertex->point);
+                    }
+                  i++;
+                }
             }
 
-          if (! exitcode)
-            {
-              Matrix simpl (nf, dim+1);
-
-              FORALLfacets
-                {
-                  if (! facet->upperdelaunay)
-                    {
-                      octave_idx_type j = 0;
-
-                      FOREACHvertex_ (facet->vertices)
-                        {
-                          simpl(i, j++) = 1 + qh_pointid(vertex->point);
-                        }
-                      i++;
-                    }
-                }
-
-              retval(0) = simpl;
-            }
+          retval(0) = simpl;
         }
-      else
-        error ("__delaunayn__: qhull failed");
 
       // Free memory from Qhull
       qh_freeqhull (! qh_ALL);
 
       int curlong, totlong;
       qh_memfreeshort (&curlong, &totlong);
 
       if (curlong || totlong)
@@ -218,21 +217,21 @@ Undocumented internal function.\n\
       // I will look at this later.
       RowVector vec (n);
       for (octave_idx_type i = 0; i < n; i++)
         vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
+  return retval;
+
 #else
 
   error ("__delaunayn__: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -141,19 +141,24 @@ DEFUN_DLD (__eigs__, args, nargout,
 @deftypefnx {} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{A}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{A}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
 #ifdef HAVE_ARPACK
   int nargin = args.length ();
+
+  if (nargin == 0)
+    print_usage ();
+
+  octave_value_list retval;
+
   std::string fcn_name;
   octave_idx_type n = 0;
   octave_idx_type k = 6;
   Complex sigma = 0.;
   double sigmar, sigmai;
   bool have_sigma = false;
   std::string typ = "LM";
   Matrix amm, bmm, bmt;
@@ -189,19 +194,16 @@ Undocumented internal function.\n\
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
       if (fcn_name.length ())
         clear_function (fcn_name);
       return retval;
     }
 
-  if (nargin == 0)
-    print_usage ();
-
   if (args(0).is_function_handle () || args(0).is_inline_function ()
       || args(0).is_string ())
     {
       if (args(0).is_string ())
         {
           std::string name = args(0).string_value ();
           std::string fname = "function y = ";
           fcn_name = unique_symbol_name ("__eigs_fcn__");
@@ -213,22 +215,20 @@ Undocumented internal function.\n\
       else
         eigs_fcn = args(0).function_value ();
 
       if (!eigs_fcn)
         error ("eigs: unknown function");
 
       if (nargin < 2)
         error ("eigs: incorrect number of arguments");
-      else
-        {
-          n = args(1).nint_value ();
-          arg_offset = 1;
-          have_a_fun = true;
-        }
+
+      n = args(1).nint_value ();
+      arg_offset = 1;
+      have_a_fun = true;
     }
   else
     {
       if (args(0).is_complex_type ())
         {
           if (args(0).is_sparse_type ())
             {
               ascm = (args(0).sparse_complex_matrix_value ());
@@ -247,20 +247,19 @@ Undocumented internal function.\n\
               asmm = (args(0).sparse_matrix_value ());
               a_is_sparse = true;
             }
           else
             {
               amm = (args(0).matrix_value ());
             }
         }
-
     }
 
-  // Note hold off reading B till later to avoid issues of double
+  // Note hold off reading B until later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
   if (nargin > 1 + arg_offset
       && ! (args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).is_complex_type ())
         {
           b_arg = 1+arg_offset;
           have_b = true;
@@ -297,70 +296,68 @@ Undocumented internal function.\n\
         }
     }
 
   sigmar = std::real (sigma);
   sigmai = std::imag (sigma);
 
   if (nargin > (3+arg_offset))
     {
-      if (args(3+arg_offset).is_map ())
-        {
-          octave_scalar_map map = args(3+arg_offset).xscalar_map_value ("eigs: OPTS argument must be a scalar structure");
+      if (! args(3+arg_offset).is_map ())
+        error ("eigs: OPTS argument must be a structure");
 
-          octave_value tmp;
+      octave_scalar_map map = args(3+arg_offset).xscalar_map_value ("eigs: OPTS argument must be a scalar structure");
+
+      octave_value tmp;
 
-          // issym is ignored for complex matrix inputs
-          tmp = map.getfield ("issym");
-          if (tmp.is_defined () && !sym_tested)
-            {
-              symmetric = tmp.double_value () != 0.;
-              sym_tested = true;
-            }
+      // issym is ignored for complex matrix inputs
+      tmp = map.getfield ("issym");
+      if (tmp.is_defined () && !sym_tested)
+        {
+          symmetric = tmp.double_value () != 0.;
+          sym_tested = true;
+        }
 
-          // isreal is ignored if A is not a function
-          tmp = map.getfield ("isreal");
-          if (tmp.is_defined () && have_a_fun)
-            a_is_complex = ! (tmp.double_value () != 0.);
+      // isreal is ignored if A is not a function
+      tmp = map.getfield ("isreal");
+      if (tmp.is_defined () && have_a_fun)
+        a_is_complex = ! (tmp.double_value () != 0.);
 
-          tmp = map.getfield ("tol");
-          if (tmp.is_defined ())
-            tol = tmp.double_value ();
-
-          tmp = map.getfield ("maxit");
-          if (tmp.is_defined ())
-            maxit = tmp.nint_value ();
+      tmp = map.getfield ("tol");
+      if (tmp.is_defined ())
+        tol = tmp.double_value ();
 
-          tmp = map.getfield ("p");
-          if (tmp.is_defined ())
-            p = tmp.nint_value ();
+      tmp = map.getfield ("maxit");
+      if (tmp.is_defined ())
+        maxit = tmp.nint_value ();
 
-          tmp = map.getfield ("v0");
-          if (tmp.is_defined ())
-            {
-              if (a_is_complex || b_is_complex)
-                cresid = ComplexColumnVector (tmp.complex_vector_value ());
-              else
-                resid = ColumnVector (tmp.vector_value ());
-            }
+      tmp = map.getfield ("p");
+      if (tmp.is_defined ())
+        p = tmp.nint_value ();
 
-          tmp = map.getfield ("disp");
-          if (tmp.is_defined ())
-            disp = tmp.nint_value ();
+      tmp = map.getfield ("v0");
+      if (tmp.is_defined ())
+        {
+          if (a_is_complex || b_is_complex)
+            cresid = ComplexColumnVector (tmp.complex_vector_value ());
+          else
+            resid = ColumnVector (tmp.vector_value ());
+        }
 
-          tmp = map.getfield ("cholB");
-          if (tmp.is_defined ())
-            cholB = tmp.double_value () != 0.;
+      tmp = map.getfield ("disp");
+      if (tmp.is_defined ())
+        disp = tmp.nint_value ();
 
-          tmp = map.getfield ("permB");
-          if (tmp.is_defined ())
-            permB = ColumnVector (tmp.vector_value ()) - 1.0;
-        }
-      else
-        error ("eigs: OPTS argument must be a structure");
+      tmp = map.getfield ("cholB");
+      if (tmp.is_defined ())
+        cholB = tmp.double_value () != 0.;
+
+      tmp = map.getfield ("permB");
+      if (tmp.is_defined ())
+        permB = ColumnVector (tmp.vector_value ()) - 1.0;
     }
 
   if (nargin > (4+arg_offset))
     error ("eigs: incorrect number of arguments");
 
   // Test undeclared (no issym) matrix inputs for symmetry
   if (!sym_tested && !have_a_fun)
     {
@@ -559,14 +556,14 @@ Undocumented internal function.\n\
     warning ("eigs: None of the %d requested eigenvalues converged", k);
   else if (nconv < k)
     warning ("eigs: Only %d of the %d requested eigenvalues converged",
              nconv, k);
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 
+  return retval;
+
 #else
   error ("eigs: not available in this version of Octave");
 #endif
-
-  return retval;
 }
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -330,38 +330,35 @@ glpk (int sense, int n, int m, double *c
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {[@var{values}] =} __glpk__ (@var{args})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #if defined (HAVE_GLPK)
 
   // FIXME: Should we even need checking for an internal function?
   if (args.length () != 9)
     print_usage ();
 
-  //-- 1nd Input. A column array containing the objective function
-  //--            coefficients.
+  // 1nd Input.  A column array containing the objective function coefficients.
   volatile int mrowsc = args(0).rows ();
 
   Matrix C = args(0).xmatrix_value ("__glpk__: invalid value of C");
 
   double *c = C.fortran_vec ();
   Array<int> rn;
   Array<int> cn;
   ColumnVector a;
   volatile int mrowsA;
   volatile int nz = 0;
 
-  //-- 2nd Input. A matrix containing the constraints coefficients.
+  // 2nd Input.  A matrix containing the constraints coefficients.
   // If matrix A is NOT a sparse matrix
   if (args(1).is_sparse_type ())
     {
       SparseMatrix A = args(1).xsparse_matrix_value ("__glpk__: invalid value of A");
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nnz ();
@@ -624,23 +621,21 @@ Undocumented internal function.\n\
     {
       extra.assign ("lambda", lambda);
       extra.assign ("redcosts", redcosts);
     }
 
   extra.assign ("time", time);
   extra.assign ("status", status);
 
-  retval = ovl (xmin, fmin, errnum, extra);
+  return ovl (xmin, fmin, errnum, extra);
 
 #else
 
   gripe_not_supported ("glpk");
 
 #endif
-
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -748,28 +748,25 @@ DEFUN_DLD (__magick_read__, args, nargou
 Read image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imread} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
-  octave_value_list output;
-
-#ifndef HAVE_MAGICK
-  gripe_disabled_feature ("imread", "Image IO");
-#else
+#ifdef HAVE_MAGICK
+  if (args.length () != 2 || ! args(0).is_string ())
+    print_usage ();
 
   maybe_initialize_magick ();
 
-  if (args.length () != 2 || ! args(0).is_string ())
-    print_usage ();
+  const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
 
-  const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
+  octave_value_list output;
 
   std::vector<Magick::Image> imvec;
   read_file (args(0).string_value (), imvec);
 
   // Prepare an Array with the indexes for the requested frames.
   const octave_idx_type nFrames = imvec.size ();
   Array<octave_idx_type> frameidx;
   const octave_value indexes = options.getfield ("index");
@@ -844,18 +841,21 @@ Use @code{imread} instead.\n\
         output = read_images<uint16NDArray> (imvec, frameidx, nargout, options);
       else if (depth <= 32)
         output = read_images<FloatNDArray>  (imvec, frameidx, nargout, options);
       else
         error ("imread: reading of images with %i-bit depth is not supported",
                depth);
     }
 
+  return output;
+
+#else
+  gripe_disabled_feature ("imread", "Image IO");
 #endif
-  return output;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 #ifdef HAVE_MAGICK
@@ -1385,27 +1385,22 @@ DEFUN_DLD (__magick_write__, args, ,
 Write image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imwrite} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-#ifndef HAVE_MAGICK
-  gripe_disabled_feature ("imwrite", "Image IO");
-#else
+#ifdef HAVE_MAGICK
+  if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
+    print_usage ();
 
   maybe_initialize_magick ();
 
-  if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
-    print_usage ();
-
   const std::string filename = args(0).string_value ();
   const std::string ext = args(1).string_value ();
 
   const octave_scalar_map options = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
 
   const octave_value img  = args(2);
   const Matrix cmap = args(3).xmatrix_value ("__magick_write__: invalid MAP");
 
@@ -1537,18 +1532,21 @@ Use @code{imwrite} instead.\n\
   else COMPRESS_MAGICK_IMAGE_VECTOR("lzw", Magick::LZWCompression)
   else COMPRESS_MAGICK_IMAGE_VECTOR("rle", Magick::RLECompression)
   else COMPRESS_MAGICK_IMAGE_VECTOR("deflate", Magick::ZipCompression)
 
 #undef COMPRESS_MAGICK_IMAGE_VECTOR
 
   write_file (filename, ext, imvec);
 
+  return octave_value_list ();
+
+#else
+  gripe_disabled_feature ("imwrite", "Image IO");
 #endif
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 // Gets the minimum information from images such as its size and format. Much
@@ -1560,27 +1558,24 @@ DEFUN_DLD (__magick_ping__, args, ,
 @deftypefn {} {} __magick_ping__ (@var{fname}, @var{idx})\n\
 Ping image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 \n\
 @seealso{imfinfo}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-#ifndef HAVE_MAGICK
-  gripe_disabled_feature ("imfinfo", "Image IO");
-#else
-  maybe_initialize_magick ();
-
+#ifdef HAVE_MAGICK
   if (args.length () < 1 || ! args(0).is_string ())
     print_usage ();
 
+  maybe_initialize_magick ();
+
   const std::string filename = args(0).string_value ();
+
   int idx;
   if (args.length () > 1)
     idx = args(1).int_value () -1;
   else
     idx = 0;
 
   Magick::Image img;
   img.subImage (idx); // start ping from this image (in case of multi-page)
@@ -1598,19 +1593,22 @@ This is a private internal function not 
       error ("Magick++ exception: %s", e.what ());
     }
 
   static const char *fields[] = {"rows", "columns", "format", 0};
   octave_scalar_map ping = octave_scalar_map (string_vector (fields));
   ping.setfield ("rows",    octave_value (img.rows ()));
   ping.setfield ("columns", octave_value (img.columns ()));
   ping.setfield ("format",  octave_value (img.magick ()));
-  retval = octave_value (ping);
+
+  return ovl (ping);
+
+#else
+  gripe_disabled_feature ("imfinfo", "Image IO");
 #endif
-  return retval;
 }
 
 #ifdef HAVE_MAGICK
 static octave_value
 magick_to_octave_value (const Magick::CompressionType& magick)
 {
   switch (magick)
     {
@@ -1780,26 +1778,22 @@ DEFUN_DLD (__magick_finfo__, args, ,
 Read image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imfinfo} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-#ifndef HAVE_MAGICK
-  gripe_disabled_feature ("imfinfo", "Image IO");
-#else
-  maybe_initialize_magick ();
-
+#ifdef HAVE_MAGICK
   if (args.length () < 1 || ! args(0).is_string ())
     print_usage ();
 
+  maybe_initialize_magick ();
+
   const std::string filename = args(0).string_value ();
 
   std::vector<Magick::Image> imvec;
   read_file (filename, imvec);
 
   const octave_idx_type nFrames = imvec.size ();
   const std::string format = imvec[0].magick ();
 
@@ -1880,28 +1874,26 @@ Use @code{imfinfo} instead.\n\
   // those values, and make a copy of the template for each image.
   octave_scalar_map template_info = (string_vector (fields));
 
   template_info.setfield ("Format", octave_value (format));
   // We can't actually get FormatVersion but even Matlab sometimes can't.
   template_info.setfield ("FormatVersion", octave_value (""));
 
   const file_stat fs (filename);
-  if (fs)
-    {
-      const octave_localtime mtime (fs.mtime ());
-      const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
-      template_info.setfield ("Filename",    octave_value (filename));
-      template_info.setfield ("FileModDate", octave_value (filetime));
-      template_info.setfield ("FileSize",    octave_value (fs.size ()));
-    }
-  else
+  if (! fs)
     error ("imfinfo: error reading '%s': %s", filename.c_str (),
            fs.error ().c_str ());
 
+  const octave_localtime mtime (fs.mtime ());
+  const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
+  template_info.setfield ("Filename",    octave_value (filename));
+  template_info.setfield ("FileModDate", octave_value (filetime));
+  template_info.setfield ("FileSize",    octave_value (fs.size ()));
+
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       OCTAVE_QUIT;
       octave_scalar_map info_frame (template_info);
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
       info_frame.setfield ("Height", octave_value (img.rows ()));
@@ -2209,45 +2201,44 @@ Use @code{imfinfo} instead.\n\
       for (octave_idx_type frame = 0; frame < nFrames; frame++)
         methods[frame] = disposal_methods[imvec[frame].gifDisposeMethod ()];
       info.setfield ("DisposalMethod", Cell (methods));
     }
   else
     info.setfield ("DisposalMethod",
                    Cell (dim_vector (nFrames, 1), octave_value ("")));
 
-  retval = octave_value (info);
+  return ovl (info);
+
+#else
+  gripe_disabled_feature ("imfinfo", "Image IO");
 #endif
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 DEFUN_DLD (__magick_formats__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __magick_imformats__ (@var{formats})\n\
 Fill formats info with GraphicsMagick CoderInfo.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
-  octave_value retval;
+#ifdef HAVE_MAGICK
+  maybe_initialize_magick ();
 
-#ifndef HAVE_MAGICK
-  gripe_disabled_feature ("imformats", "Image IO");
-#else
   if (args.length () != 1 || ! args(0).is_map ())
     print_usage ();
 
   octave_map formats = args(0).map_value ();
 
-  maybe_initialize_magick ();
   for (octave_idx_type idx = 0; idx < formats.numel (); idx++)
     {
       try
         {
           octave_scalar_map fmt = formats.checkelem (idx);
           Magick::CoderInfo coder (fmt.getfield ("coder").string_value ());
 
           fmt.setfield ("description", octave_value (coder.description ()));
@@ -2263,17 +2254,20 @@ Fill formats info with GraphicsMagick Co
       catch (Magick::Exception& e)
         {
           // Exception here are missing formats. So we remove the format
           // from the structure and reduce idx.
           formats.delete_elements (idx);
           idx--;
         }
     }
-  retval = formats;
+
+  return ovl (formats);
+
+#else
+  gripe_disabled_feature ("imformats", "Image IO");
 #endif
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -82,37 +82,36 @@ Use GL2PS_SIMPLE_SORT instead of GL2PS_B
 Don't render text.\n\
 @end table\n\
 \n\
 The second method doesn't use gl2ps and returns a RGB image in @var{img}\n\
 instead.\n\
 \n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #if ! defined (HAVE_OSMESA)
   gripe_disabled_feature ("__osmesa_print__", "offscreen rendering");
 #else
-
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
 
   if (nargin == 3)
     {
       if (! (args(1).is_string () && args(2).is_string ()))
         error ("__osmesa_print__: FILE and TERM must be strings");
 
 #ifndef HAVE_GL2PS_H
       error ("__osmesa_print__: Octave has been compiled without gl2ps");
 #endif
     }
 
+  octave_value_list retval;
+
   int h = args(0).double_value ();
   graphics_object fobj = gh_manager::get_object (h);
   if (! (fobj && fobj.isa ("figure")))
     error ("__osmesa_print__: H must be a valid figure handle");
 
   figure::properties& fp =
     dynamic_cast<figure::properties&> (fobj.get_properties ());
 
@@ -179,30 +178,28 @@ instead.\n\
           std::string cmd = file.substr (pos_c);
           gl2ps_print (fobj, cmd, term);
         }
       else
         {
           // write gl2ps output directly to file
           FILE *filep = gnulib::fopen (file.substr (pos_c).c_str (), "w");
 
-          if (filep)
-            {
-              unwind_protect frame;
+          if (! filep)
+            error ("__osmesa_print__: Couldn't create file \"%s\"", file.c_str ());
 
-              frame.add_fcn (close_fcn, filep);
+          unwind_protect frame;
 
-              glps_renderer rend (filep, term);
-              rend.draw (fobj, "");
+          frame.add_fcn (close_fcn, filep);
 
-              // Make sure buffered commands are finished!!!
-              glFinish ();
-            }
-          else
-            error ("__osmesa_print__: Couldn't create file \"%s\"", file.c_str ());
+          glps_renderer rend (filep, term);
+          rend.draw (fobj, "");
+
+          // Make sure buffered commands are finished!!!
+          glFinish ();
         }
 #endif
     }
   else
     {
       // return RGB image
       opengl_renderer rend;
       rend.draw (fobj);
@@ -232,18 +229,18 @@ instead.\n\
 
       // Remove alpha channel
       idx(2) = idx_vector (0, 3);
       retval = octave_value (img.permute (perm). index(idx));
     }
 
   OSMesaDestroyContext (ctx);
 
+  return retval;
 #endif
-  return retval;
 }
 
 /*
 ## FIXME: osmesa does not work correctly on Windows platforms.
 ##        This is not critical, since this facility will mostly be used in
 ##        the future for generating the images in Octave's own documentation.
 ##        For the moment, disable these tests on PC's and Macs.
 %!testif HAVE_OSMESA, HAVE_GL2PS_H
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -77,34 +77,32 @@ octave_qhull_dims_ok (octave_idx_type di
 DEFUN_DLD (__voronoi__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+#if defined (HAVE_QHULL)
+  int nargin = args.length ();
+
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
 
   std::string caller = args(0).xstring_value ("__voronoi__: CALLER must be a string");
 
-#if defined (HAVE_QHULL)
-
-  retval(0) = 0.0;
-
-  int nargin = args.length ();
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
+  octave_value_list retval;
 
   Matrix points = args(1).matrix_value ();
   const octave_idx_type dim = points.columns ();
   const octave_idx_type num_points = points.rows ();
 
   if (! octave_qhull_dims_ok (dim, num_points, "__voronoi__"))
-    return retval;
+    return ovl (0.0);
 
   points = points.transpose ();
 
   std::string options;
 
   if (dim <= 3)
     options = " Qbb";
   else
@@ -139,21 +137,21 @@ Undocumented internal function.\n\
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
   FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
-  if (outfile)
-    frame.add_fcn (close_fcn, outfile);
-  else
+  if (! outfile)
     error ("__voronoi__: unable to create temporary file for output");
 
+  frame.add_fcn (close_fcn, outfile);
+
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull v" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
 
@@ -321,19 +319,19 @@ Undocumented internal function.\n\
 
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
   if (curlong || totlong)
     warning ("%s: qhull did not free %d bytes of long memory (%d pieces)",
              caller.c_str (), totlong, curlong);
 
+  return retval;
+
 #else
   error ("%s: not available in this version of Octave", caller.c_str ());
 #endif
-
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -177,16 +177,17 @@ The author of the code itself is Timothy
     return ovl (Pout);
 
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
 }
+
 /*
 %!shared A, A2, opts
 %! A = ones (20, 30);
 %! A2 = ones (30, 30);
 %!
 %!testif HAVE_AMD
 %! assert(amd (A2), [1:30])
 %! opts.dense = 25;
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -100,22 +100,23 @@ named device.\n\
 Given a sampling rate, bits per sample, and number of channels for an input\n\
 or output device, return the ID of the first device that supports playback\n\
 or recording using the specified parameters.\n\
 \n\
 If also given a device ID, return true if the device supports playback or\n\
 recording using those parameters.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_PORTAUDIO
 
   int nargin = args.length ();
 
+  if (nargin > 5)
+    print_usage ();
+
   octave_scalar_map devinfo;
   octave_value_list input;
   octave_value_list output;
 
   PaError err = Pa_Initialize ();
 
   if (err != paNoError)
     error ("audiodevinfo: PortAudio initialization failed");
@@ -192,16 +193,18 @@ recording using those parameters.\n\
   inputdev.setfield ("DriverVersion", input_driver_version);
   inputdev.setfield ("ID", input_id);
   outputdev.setfield ("Name", output_name);
   outputdev.setfield ("DriverVersion", output_driver_version);
   outputdev.setfield ("ID", output_id);
   devinfo.setfield ("input", inputdev);
   devinfo.setfield ("output", outputdev);
 
+  octave_value retval;
+
   // Return information about input and output audio devices and
   // their properties.
   if (nargin == 0)
     retval = devinfo;
   // Return the number of input or output devices
   else if (nargin == 1)
     {
       if (args(0).int_value () == 0)
@@ -398,25 +401,23 @@ recording using those parameters.\n\
               return retval;
             }
         }
       else
         error ("audiodevinfo: please specify 0 for output and 1 for input devices");
 
       retval = 0;
     }
-  else
-    print_usage ();
+
+  return retval;
 
 #else
   NO_PORTAUDIO_MSG
   (void) args;  //silence compiler warning "unused parameter"
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_PORTAUDIO
 %! devinfo = audiodevinfo;
 %! assert (rows (devinfo.input), 1);
 %! assert (rows (devinfo.output), 1);
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -65,26 +65,24 @@ and columns corresponding to channels.\n
 The optional two-element vector argument @var{samples} specifies starting\n\
 and ending frames.\n\
 \n\
 The optional argument @var{datatype} specifies the datatype to return.\n\
 If it is @qcode{\"native\"}, then the type of data depends on how the data\n\
 is stored in the audio file.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_SNDFILE
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
-  std::string filename = args(0).string_value ();
+  std::string filename = args(0).xstring_value ("audioread: FILENAME must be a string");
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
     error ("audioread: failed to open input file %s", filename.c_str ());
 
@@ -166,25 +164,21 @@ is stored in the audio file.\n\
             }
         }
       else
         ret_audio = audio;
     }
   else
     ret_audio = audio;
 
-  retval = ovl (ret_audio, info.samplerate);
+  return ovl (ret_audio, info.samplerate);
 
 #else
-
   error ("sndfile not found on your system and thus audioread is not functional");
-
 #endif
-
-  return retval;
 }
 
 #ifdef HAVE_SNDFILE
 
 static int
 extension_to_format (const std::string& ext)
 {
   static bool initialized = false;
@@ -257,47 +251,42 @@ Title for the audio file.\n\
 @item Artist\n\
 Artist name.\n\
 \n\
 @item Comment\n\
 Comment.\n\
 @end table\n\
 @end deftypefn")
 {
-  // FIXME: shouldn't we return something to indicate whether the file
-  // was written successfully?
-
-  octave_value retval;
-
 #ifdef HAVE_SNDFILE
 
   int nargin = args.length ();
 
   if (nargin < 3)
     print_usage ();
 
-  std::string filename = args(0).string_value ();
-
-  Matrix audio = args(1).matrix_value ();
+  std::string filename = args(0).xstring_value ("audiowrite: FILENAME must be a string");
 
   double bias = 0.0;
   double scale = 1.0;
 
   if (args(1).is_uint8_type ())
     bias = scale = std::pow (2.0, 7);
   else if (args(1).is_int16_type ())
     scale = std::pow (2.0, 15);
   else if (args(1).is_int32_type ())
     scale = std::pow (2.0, 31);
   else if (args(1).is_integer_type ())
     {
       gripe_wrong_type_arg ("audiowrite", args(1));
-      return retval;
+      return octave_value_list ();
     }
 
+  Matrix audio = args(1).matrix_value ();
+
   int samplerate = args(2).int_value ();
 
   std::string ext;
   size_t dotpos = filename.find_last_of (".");
   if (dotpos != std::string::npos)
     ext = filename.substr (dotpos + 1);
   std::transform (ext.begin (), ext.end (), ext.begin (), ::tolower);
 
@@ -420,39 +409,38 @@ Comment.\n\
       if (items_written != chunk_size)
         error ("audiowrite: write failed, wrote %ld of %ld items\n",
                items_written, chunk_size);
 
       total_items_written += items_written;
       offset += chunk_size;
     }
 
+  // FIXME: shouldn't we return something to indicate whether the file
+  // was written successfully?
+  return octave_value_list ();
+
 #else
 
   error ("sndfile not found on your system and thus audiowrite is not functional");
 
 #endif
-
-  return retval;
 }
 
 DEFUN_DLD (audioinfo, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{info} =} audioinfo (@var{filename})\n\
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_SNDFILE
-
   if (args.length () != 1)
     print_usage ();
 
-  std::string filename = args(0).string_value ();
+  std::string filename = args(0).xstring_value ("audioinfo: FILENAME must be a string");
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
 
   if (! file)
     error ("audioinfo: failed to open file %s", filename.c_str ());
 
@@ -496,18 +484,16 @@ Return information about an audio file s
     }
 
   result.assign ("BitsPerSample", bits);
   result.assign ("BitRate", -1);
   result.assign ("Title", sf_get_string (file, SF_STR_TITLE));
   result.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
   result.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
 
-  retval = result;
+  return ovl (result);
 
 #else
 
   error ("sndfile not found on your system and thus audioinfo is not functional");
 
 #endif
-
-  return retval;
 }
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -332,21 +332,20 @@ sparse matrices.\n\
 DEFUN_DLD (cholinv, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} cholinv (@var{A})\n\
 Compute the inverse of the symmetric positive definite matrix @var{A} using\n\
 the Cholesky@tie{}factorization.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
@@ -461,21 +460,21 @@ Invert a symmetric, positive definite sq
 decomposition, @var{U}.\n\
 \n\
 Note that @var{U} should be an upper-triangular matrix with positive\n\
 diagonal elements.  @code{chol2inv (@var{U})} provides\n\
 @code{inv (@var{U}'*@var{U})} but it is much faster than using @code{inv}.\n\
 @seealso{chol, cholinv, inv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
@@ -607,34 +606,34 @@ If @var{info} is not present, an error m
           FloatCHOL fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
           FloatComplexCHOL fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
@@ -643,33 +642,33 @@ If @var{info} is not present, an error m
           CHOL fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u = argu.complex_column_vector_value ();
 
           ComplexCHOL fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
     }
 
   if (nargout > 1)
     retval(1) = err;
   else if (err == 1)
     error ("cholupdate: downdate violates positiveness");
   else if (err == 2)
@@ -770,82 +769,82 @@ If @var{info} is not present, an error m
   octave_value argr = args(0);
   octave_value argj = args(1);
   octave_value argu = args(2);
 
   if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
       || ! argj.is_real_scalar ())
     print_usage ();
 
-  octave_value_list retval (nargout == 2 ? 2 : 1);
-
   octave_idx_type n = argr.rows ();
   octave_idx_type j = argj.scalar_value ();
 
   if (argr.columns () != n || argu.rows () != n+1 || argu.columns () != 1)
     error ("cholinsert: dimension mismatch between R and U");
 
   if (j < 1 || j > n+1)
     error ("cholinsert: index J out of range");
 
+  octave_value_list retval (nargout == 2 ? 2 : 1);
+
   int err = 0;
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
           FloatCHOL fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
           FloatComplexCHOL fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
           CHOL fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u =
             argu.complex_column_vector_value ();
 
           ComplexCHOL fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
-          retval(0) = get_chol_r (fact);
+          retval = ovl (get_chol_r (fact));
         }
     }
 
   if (nargout > 1)
     retval(1) = err;
   else if (err == 1)
     error ("cholinsert: insertion violates positiveness");
   else if (err == 2)
@@ -998,90 +997,86 @@ DEFUN_DLD (choldelete, args, ,
 @deftypefn {} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
 @w{p = [1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert, cholshift}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
 
   if (! argr.is_numeric_type () || ! argj.is_real_scalar ())
     print_usage ();
 
   octave_idx_type n = argr.rows ();
   octave_idx_type j = argj.scalar_value ();
 
-  if (argr.columns () == n)
-    {
-      if (j > 0 && j <= n)
-        {
-          if (argr.is_single_type ())
-            {
-              if (argr.is_real_type ())
-                {
-                  // real case
-                  FloatMatrix R = argr.float_matrix_value ();
+  if (argr.columns () != n)
+    error ("choldelete: matrix R must be square");
 
-                  FloatCHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
+  if (j < 0 && j > n)
+    error ("choldelete: index J out of range");
 
-                  retval(0) = get_chol_r (fact);
-                }
-              else
-                {
-                  // complex case
-                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
-
-                  FloatComplexCHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
+  octave_value_list retval;
 
-                  retval(0) = get_chol_r (fact);
-                }
-            }
-          else
-            {
-              if (argr.is_real_type ())
-                {
-                  // real case
-                  Matrix R = argr.matrix_value ();
-
-                  CHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
+  if (argr.is_single_type ())
+    {
+      if (argr.is_real_type ())
+        {
+          // real case
+          FloatMatrix R = argr.float_matrix_value ();
 
-                  retval(0) = get_chol_r (fact);
-                }
-              else
-                {
-                  // complex case
-                  ComplexMatrix R = argr.complex_matrix_value ();
+          FloatCHOL fact;
+          fact.set (R);
+          fact.delete_sym (j-1);
 
-                  ComplexCHOL fact;
-                  fact.set (R);
-                  fact.delete_sym (j-1);
-
-                  retval(0) = get_chol_r (fact);
-                }
-            }
+          retval = ovl (get_chol_r (fact));
         }
       else
-        error ("choldelete: index J out of range");
+        {
+          // complex case
+          FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+          FloatComplexCHOL fact;
+          fact.set (R);
+          fact.delete_sym (j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
     }
   else
-    error ("choldelete: matrix R must be square");
+    {
+      if (argr.is_real_type ())
+        {
+          // real case
+          Matrix R = argr.matrix_value ();
+
+          CHOL fact;
+          fact.set (R);
+          fact.delete_sym (j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
+      else
+        {
+          // complex case
+          ComplexMatrix R = argr.complex_matrix_value ();
+
+          ComplexCHOL fact;
+          fact.set (R);
+          fact.delete_sym (j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol (A);
 %!
@@ -1128,95 +1123,90 @@ triangular, return the Cholesky@tie{}fac
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
 @seealso{chol, cholupdate, cholinsert, choldelete}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argi = args(1);
   octave_value argj = args(2);
 
   if (! argr.is_numeric_type () || ! argi.is_real_scalar ()
       || ! argj.is_real_scalar ())
     print_usage ();
 
   octave_idx_type n = argr.rows ();
   octave_idx_type i = argi.scalar_value ();
   octave_idx_type j = argj.scalar_value ();
 
-  if (argr.columns () == n)
-    {
-      if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
-        {
-
-          if (argr.is_single_type () && argi.is_single_type ()
-              && argj.is_single_type ())
-            {
-              if (argr.is_real_type ())
-                {
-                  // real case
-                  FloatMatrix R = argr.float_matrix_value ();
+  if (argr.columns () != n)
+    error ("cholshift: R must be a square matrix");
 
-                  FloatCHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
+  if (j < 0 || j > n+1 || i < 0 || i > n+1)
+    error ("cholshift: index I or J is out of range");
 
-                  retval(0) = get_chol_r (fact);
-                }
-              else
-                {
-                  // complex case
-                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
-
-                  FloatComplexCHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
+  octave_value_list retval;
 
-                  retval(0) = get_chol_r (fact);
-                }
-            }
-          else
-            {
-              if (argr.is_real_type ())
-                {
-                  // real case
-                  Matrix R = argr.matrix_value ();
-
-                  CHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
+  if (argr.is_single_type () && argi.is_single_type ()
+      && argj.is_single_type ())
+    {
+      if (argr.is_real_type ())
+        {
+          // real case
+          FloatMatrix R = argr.float_matrix_value ();
 
-                  retval(0) = get_chol_r (fact);
-                }
-              else
-                {
-                  // complex case
-                  ComplexMatrix R = argr.complex_matrix_value ();
+          FloatCHOL fact;
+          fact.set (R);
+          fact.shift_sym (i-1, j-1);
 
-                  ComplexCHOL fact;
-                  fact.set (R);
-                  fact.shift_sym (i-1, j-1);
-
-                  retval(0) = get_chol_r (fact);
-                }
-            }
+          retval = ovl (get_chol_r (fact));
         }
       else
-        error ("cholshift: index I or J is out of range");
+        {
+          // complex case
+          FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+          FloatComplexCHOL fact;
+          fact.set (R);
+          fact.shift_sym (i-1, j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
     }
   else
-    error ("cholshift: R must be a square matrix");
+    {
+      if (argr.is_real_type ())
+        {
+          // real case
+          Matrix R = argr.matrix_value ();
+
+          CHOL fact;
+          fact.set (R);
+          fact.shift_sym (i-1, j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
+      else
+        {
+          // complex case
+          ComplexMatrix R = argr.complex_matrix_value ();
+
+          ComplexCHOL fact;
+          fact.set (R);
+          fact.shift_sym (i-1, j-1);
+
+          retval = ovl (get_chol_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol (A);
 %!
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -663,39 +663,36 @@ permutations on the tree.\n\
   octave_value_list retval (nargout == 2 ? 2 : 1);
 
   octave_idx_type n_row = 0;
   octave_idx_type n_col = 0;
   octave_idx_type *ridx = 0;
   octave_idx_type *cidx = 0;
 
   if (args(0).is_sparse_type ())
-    {
-      if (args(0).is_complex_type ())
-        {
-          SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
+    error ("etree: S must be a sparse matrix");
 
-          n_row = scm.rows ();
-          n_col = scm.cols ();
-          ridx = scm.xridx ();
-          cidx = scm.xcidx ();
-        }
-      else
-        {
-          SparseMatrix sm = args(0).sparse_matrix_value ();
+  if (args(0).is_complex_type ())
+    {
+      SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
 
-          n_row = sm.rows ();
-          n_col = sm.cols ();
-          ridx = sm.xridx ();
-          cidx = sm.xcidx ();
-        }
-
+      n_row = scm.rows ();
+      n_col = scm.cols ();
+      ridx = scm.xridx ();
+      cidx = scm.xcidx ();
     }
   else
-    error ("etree: S must be a sparse matrix");
+    {
+      SparseMatrix sm = args(0).sparse_matrix_value ();
+
+      n_row = sm.rows ();
+      n_col = sm.cols ();
+      ridx = sm.xridx ();
+      cidx = sm.xcidx ();
+    }
 
   bool is_sym = true;
 
   if (nargin == 2)
     {
       std::string str = args(1).xstring_value ("etree: TYP must be a string");
       if (str.find ("C") == 0 || str.find ("c") == 0)
         is_sym = false;
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -144,28 +144,26 @@ triangular form.  The values of @var{r} 
 of the blocks.  If @var{S} is square then @code{@var{r} == @var{S}}.\n\
 \n\
 The method used is described in: @nospell{A. Pothen & C.-J. Fan.}\n\
 @cite{Computing the Block Triangular Form of a Sparse Matrix}.\n\
 ACM Trans. Math. Software, 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+#if HAVE_CXSPARSE
 
   if (args.length () != 1)
     print_usage ();
 
-#if HAVE_CXSPARSE
-  retval = dmperm_internal (false, args(0), nargout);
+  return ovl (dmperm_internal (false, args(0), nargout));
+
 #else
   error ("dmperm: not available in this version of Octave");
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! n = 20;
 %! a = speye (n,n);
 %! a = a(randperm (n),:);
 %! assert (a(dmperm (a),:), speye (n));
@@ -189,28 +187,26 @@ Calculate the structural rank of the spa
 Note that only the structure of the matrix is used in this calculation based\n\
 on a @nospell{Dulmage-Mendelsohn} permutation to block triangular form.  As\n\
 such the numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+#if HAVE_CXSPARSE
 
   if (args.length () != 1)
     print_usage ();
 
-#if HAVE_CXSPARSE
-  retval = dmperm_internal (true, args(0), nargout);
+  return ovl (dmperm_internal (true, args(0), nargout));
+
 #else
   error ("sprank: not available in this version of Octave");
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! assert (sprank (speye (20)), 20)
 %!testif HAVE_CXSPARSE
 %! assert (sprank ([1,0,2,0;2,0,4,0]), 2)
 
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -127,29 +127,30 @@ fftw (\"threads\", @var{NTHREADS})\n\
 \n\
 Note that octave must be compiled with multi-threaded @sc{fftw} support for\n\
 this feature.  The number of processors available to the current process is\n\
 used per default.\n\
 \n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
-  octave_value retval;
+#if defined (HAVE_FFTW)
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-#if defined (HAVE_FFTW)
+  octave_value retval;
+
   std::string arg0 = args(0).xstring_value ("fftw: first argument must be a string");
 
   if (arg0 == "planner")
     {
-      if (nargin == 2)  //planner setter
+      if (nargin == 2)  // planner setter
         {
           // Use STL function to convert to lower case
           std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
 
           std::string arg1 = args(1).xstring_value ("fftw: METHOD must be a string");
 
           std::transform (arg1.begin (), arg1.end (), arg1.begin (), tolower);
           octave_fftw_planner::FftwMethod meth
@@ -230,27 +231,25 @@ used per default.\n\
 
           if (arg1.length () < 1)
             fftw_forget_wisdom ();
           else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
             error ("fftw: could not import supplied WISDOM");
 
           retval = octave_value (std::string (str));
 
-          // FIXME: need to free string even if there is an
-          // exception.
+          // FIXME: need to free string even if there is an exception.
           free (str);
         }
       else //dwisdom getter
         {
           char *str = fftw_export_wisdom_to_string ();
           retval = octave_value (std::string (str));
 
-          // FIXME: need to free string even if there is an
-          // exception.
+          // FIXME: need to free string even if there is an exception.
           free (str);
         }
     }
   else if (arg0 == "swisdom")
     {
       //swisdom uses fftwf_ functions (float), dwisdom fftw_ (real)
       if (nargin == 2)  //swisdom setter
         {
@@ -264,72 +263,67 @@ used per default.\n\
 
           if (arg1.length () < 1)
             fftwf_forget_wisdom ();
           else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
             error ("fftw: could not import supplied WISDOM");
 
           retval = octave_value (std::string (str));
 
-          // FIXME: need to free string even if there is an
-          // exception.
+          // FIXME: need to free string even if there is an exception.
           free (str);
         }
       else //swisdom getter
         {
           char *str = fftwf_export_wisdom_to_string ();
           retval = octave_value (std::string (str));
 
-          // FIXME: need to free string even if there is an
-          // exception.
+          // FIXME: need to free string even if there is an exception.
           free (str);
         }
     }
   else if (arg0 == "threads")
     {
       if (nargin == 2)  //threads setter
         {
-          if (args(1).is_real_scalar ())
-            {
-              int nthreads = args(1).int_value();
-              if (nthreads >= 1)
-                {
+          if (! args(1).is_real_scalar ())
+            error ("fftw: setting threads needs one integer argument");
+
+          int nthreads = args(1).int_value();
+          if (nthreads < 1)
+            error ("fftw: number of threads must be >=1");
+
 #if defined (HAVE_FFTW3_THREADS)
-                  octave_fftw_planner::threads (nthreads);
+          octave_fftw_planner::threads (nthreads);
 #else
-                  gripe_disabled_feature ("fftw", "multithreaded FFTW");
+          gripe_disabled_feature ("fftw", "multithreaded FFTW");
 #endif
 #if defined (HAVE_FFTW3F_THREADS)
-                  octave_float_fftw_planner::threads (nthreads);
+          octave_float_fftw_planner::threads (nthreads);
 #else
-                  gripe_disabled_feature ("fftw", "multithreaded FFTW");
+          gripe_disabled_feature ("fftw", "multithreaded FFTW");
 #endif
-                }
-              else
-                error ("fftw: number of threads must be >=1");
-            }
-          else
-            error ("fftw: setting threads needs one integer argument");
         }
       else //threads getter
 #if defined (HAVE_FFTW3_THREADS)
         retval = octave_value (octave_fftw_planner::threads());
 #else
       retval = 1;
 #endif
     }
   else
     error ("fftw: unrecognized argument");
+
+  return retval;
+
 #else
 
   gripe_disabled_feature ("fftw", "the FFTW3 planner");
 
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_FFTW
 %! def_method = fftw ("planner");
 %! unwind_protect
 %!   method = "estimate";
 %!   fftw ("planner", method);
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -744,86 +744,78 @@ economized (R is square).\n\
   octave_value argr = args(1);
   octave_value argu = args(2);
   octave_value argv = args(3);
 
   if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
       || ! argu.is_numeric_type () || ! argv.is_numeric_type ())
     print_usage ();
 
-  if (check_qr_dims (argq, argr, true))
-    {
-      if (argq.is_real_type ()
-          && argr.is_real_type ()
-          && argu.is_real_type ()
-          && argv.is_real_type ())
-        {
-          // all real case
-          if (argq.is_single_type ()
-              || argr.is_single_type ()
-              || argu.is_single_type ()
-              || argv.is_single_type ())
-            {
-              FloatMatrix Q = argq.float_matrix_value ();
-              FloatMatrix R = argr.float_matrix_value ();
-              FloatMatrix u = argu.float_matrix_value ();
-              FloatMatrix v = argv.float_matrix_value ();
+  if (! check_qr_dims (argq, argr, true))
+    error ("qrupdate: Q and R dimensions don't match");
 
-              FloatQR fact (Q, R);
-              fact.update (u, v);
+  if (argq.is_real_type () && argr.is_real_type () && argu.is_real_type ()
+      && argv.is_real_type ())
+    {
+      // all real case
+      if (argq.is_single_type () || argr.is_single_type ()
+          || argu.is_single_type () || argv.is_single_type ())
+        {
+          FloatMatrix Q = argq.float_matrix_value ();
+          FloatMatrix R = argr.float_matrix_value ();
+          FloatMatrix u = argu.float_matrix_value ();
+          FloatMatrix v = argv.float_matrix_value ();
 
-              retval = ovl (fact.Q (), get_qr_r (fact));
-            }
-          else
-            {
-              Matrix Q = argq.matrix_value ();
-              Matrix R = argr.matrix_value ();
-              Matrix u = argu.matrix_value ();
-              Matrix v = argv.matrix_value ();
+          FloatQR fact (Q, R);
+          fact.update (u, v);
 
-              QR fact (Q, R);
-              fact.update (u, v);
-
-              retval = ovl (fact.Q (), get_qr_r (fact));
-            }
+          retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
-          // complex case
-          if (argq.is_single_type ()
-              || argr.is_single_type ()
-              || argu.is_single_type ()
-              || argv.is_single_type ())
-            {
-              FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-              FloatComplexMatrix R = argr.float_complex_matrix_value ();
-              FloatComplexMatrix u = argu.float_complex_matrix_value ();
-              FloatComplexMatrix v = argv.float_complex_matrix_value ();
-
-              FloatComplexQR fact (Q, R);
-              fact.update (u, v);
+          Matrix Q = argq.matrix_value ();
+          Matrix R = argr.matrix_value ();
+          Matrix u = argu.matrix_value ();
+          Matrix v = argv.matrix_value ();
 
-              retval = ovl (fact.Q (), get_qr_r (fact));
-            }
-          else
-            {
-              ComplexMatrix Q = argq.complex_matrix_value ();
-              ComplexMatrix R = argr.complex_matrix_value ();
-              ComplexMatrix u = argu.complex_matrix_value ();
-              ComplexMatrix v = argv.complex_matrix_value ();
+          QR fact (Q, R);
+          fact.update (u, v);
 
-              ComplexQR fact (Q, R);
-              fact.update (u, v);
-
-              retval = ovl (fact.Q (), get_qr_r (fact));
-            }
+          retval = ovl (fact.Q (), get_qr_r (fact));
         }
     }
   else
-    error ("qrupdate: Q and R dimensions don't match");
+    {
+      // complex case
+      if (argq.is_single_type () || argr.is_single_type ()
+          || argu.is_single_type () || argv.is_single_type ())
+        {
+          FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+          FloatComplexMatrix R = argr.float_complex_matrix_value ();
+          FloatComplexMatrix u = argu.float_complex_matrix_value ();
+          FloatComplexMatrix v = argv.float_complex_matrix_value ();
+
+          FloatComplexQR fact (Q, R);
+          fact.update (u, v);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          ComplexMatrix Q = argq.complex_matrix_value ();
+          ComplexMatrix R = argr.complex_matrix_value ();
+          ComplexMatrix u = argu.complex_matrix_value ();
+          ComplexMatrix v = argv.complex_matrix_value ();
+
+          ComplexQR fact (Q, R);
+          fact.update (u, v);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
@@ -908,135 +900,122 @@ recompute the factorization from scratch
 \n\
 If @var{orient} is @qcode{\"col\"}, the QR@tie{}factorization supplied may\n\
 be either full (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrdelete, qrshift}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 5)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
   octave_value argx = args(3);
 
   if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
       || ! argx.is_numeric_type ()
       || (nargin > 4 && ! args(4).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
+  bool col = (orient == "col");
 
-  bool col = orient == "col";
+  if (! col && orient != "row")
+    error ("qrinsert: ORIENT must be \"col\" or \"row\"");
+
+  if (! check_qr_dims (argq, argr, col) || (! col && argx.rows () != 1))
+    error ("qrinsert: dimension mismatch");
 
-  if (col || orient == "row")
-    if (check_qr_dims (argq, argr, col)
-        && (col || argx.rows () == 1))
-      {
-        if (check_index (argj, col))
-          {
-            MArray<octave_idx_type> j
-              = argj.octave_idx_type_vector_value ();
+  if (! check_index (argj, col))
+    error ("qrinsert: invalid index J");
 
-            octave_idx_type one = 1;
+  octave_value_list retval;
+
+  MArray<octave_idx_type> j = argj.octave_idx_type_vector_value ();
+
+  octave_idx_type one = 1;
 
-            if (argq.is_real_type ()
-                && argr.is_real_type ()
-                && argx.is_real_type ())
-              {
-                // real case
-                if (argq.is_single_type ()
-                    || argr.is_single_type ()
-                    || argx.is_single_type ())
-                  {
-                    FloatMatrix Q = argq.float_matrix_value ();
-                    FloatMatrix R = argr.float_matrix_value ();
-                    FloatMatrix x = argx.float_matrix_value ();
+  if (argq.is_real_type () && argr.is_real_type () && argx.is_real_type ())
+    {
+      // real case
+      if (argq.is_single_type () || argr.is_single_type ()
+          || argx.is_single_type ())
+        {
+          FloatMatrix Q = argq.float_matrix_value ();
+          FloatMatrix R = argr.float_matrix_value ();
+          FloatMatrix x = argx.float_matrix_value ();
 
-                    FloatQR fact (Q, R);
+          FloatQR fact (Q, R);
 
-                    if (col)
-                      fact.insert_col (x, j-one);
-                    else
-                      fact.insert_row (x.row (0), j(0)-one);
+          if (col)
+            fact.insert_col (x, j-one);
+          else
+            fact.insert_row (x.row (0), j(0)-one);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-                else
-                  {
-                    Matrix Q = argq.matrix_value ();
-                    Matrix R = argr.matrix_value ();
-                    Matrix x = argx.matrix_value ();
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          Matrix Q = argq.matrix_value ();
+          Matrix R = argr.matrix_value ();
+          Matrix x = argx.matrix_value ();
 
-                    QR fact (Q, R);
-
-                    if (col)
-                      fact.insert_col (x, j-one);
-                    else
-                      fact.insert_row (x.row (0), j(0)-one);
+          QR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-              }
-            else
-              {
-                // complex case
-                if (argq.is_single_type ()
-                    || argr.is_single_type ()
-                    || argx.is_single_type ())
-                  {
-                    FloatComplexMatrix Q =
-                      argq.float_complex_matrix_value ();
-                    FloatComplexMatrix R =
-                      argr.float_complex_matrix_value ();
-                    FloatComplexMatrix x =
-                      argx.float_complex_matrix_value ();
+          if (col)
+            fact.insert_col (x, j-one);
+          else
+            fact.insert_row (x.row (0), j(0)-one);
 
-                    FloatComplexQR fact (Q, R);
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
+  else
+    {
+      // complex case
+      if (argq.is_single_type () || argr.is_single_type ()
+          || argx.is_single_type ())
+        {
+          FloatComplexMatrix Q =
+            argq.float_complex_matrix_value ();
+          FloatComplexMatrix R =
+            argr.float_complex_matrix_value ();
+          FloatComplexMatrix x =
+            argx.float_complex_matrix_value ();
 
-                    if (col)
-                      fact.insert_col (x, j-one);
-                    else
-                      fact.insert_row (x.row (0), j(0)-one);
+          FloatComplexQR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-                else
-                  {
-                    ComplexMatrix Q = argq.complex_matrix_value ();
-                    ComplexMatrix R = argr.complex_matrix_value ();
-                    ComplexMatrix x = argx.complex_matrix_value ();
-
-                    ComplexQR fact (Q, R);
+          if (col)
+            fact.insert_col (x, j-one);
+          else
+            fact.insert_row (x.row (0), j(0)-one);
 
-                    if (col)
-                      fact.insert_col (x, j-one);
-                    else
-                      fact.insert_row (x.row (0), j(0)-one);
-
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-              }
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          ComplexMatrix Q = argq.complex_matrix_value ();
+          ComplexMatrix R = argr.complex_matrix_value ();
+          ComplexMatrix x = argx.complex_matrix_value ();
 
-          }
-        else
-          error ("qrinsert: invalid index J");
-      }
-    else
-      error ("qrinsert: dimension mismatch");
+          ComplexQR fact (Q, R);
 
-  else
-    error ("qrinsert: ORIENT must be \"col\" or \"row\"");
+          if (col)
+            fact.insert_col (x, j-one);
+          else
+            fact.insert_row (x.row (0), j(0)-one);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! [Q,R] = qr (A);
 %! [Q,R] = qrinsert (Q, R, 3, u);
@@ -1117,122 +1096,112 @@ and more accurate to recompute the facto
 \n\
 If @var{orient} is @qcode{\"col\"}, the QR@tie{}factorization supplied may\n\
 be either full (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrinsert, qrshift}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
 
   if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
       || (nargin > 3 && ! args(3).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 4) ? "col" : args(3).string_value ();
-
   bool col = orient == "col";
 
-  if (col || orient == "row")
-    if (check_qr_dims (argq, argr, col))
-      {
-        if (check_index (argj, col))
-          {
-            MArray<octave_idx_type> j
-              = argj.octave_idx_type_vector_value ();
+  if (! col && orient != "row")
+    error ("qrdelete: ORIENT must be \"col\" or \"row\"");
 
-            octave_idx_type one = 1;
+  if (! check_qr_dims (argq, argr, col))
+    error ("qrdelete: dimension mismatch");
 
-            if (argq.is_real_type ()
-                && argr.is_real_type ())
-              {
-                // real case
-                if (argq.is_single_type ()
-                    || argr.is_single_type ())
-                  {
-                    FloatMatrix Q = argq.float_matrix_value ();
-                    FloatMatrix R = argr.float_matrix_value ();
+  MArray<octave_idx_type> j = argj.octave_idx_type_vector_value ();
+  if (! check_index (argj, col))
+    error ("qrdelete: invalid index J");
+
+  octave_value_list retval;
+
+  octave_idx_type one = 1;
 
-                    FloatQR fact (Q, R);
+  if (argq.is_real_type () && argr.is_real_type ())
+    {
+      // real case
+      if (argq.is_single_type () || argr.is_single_type ())
+        {
+          FloatMatrix Q = argq.float_matrix_value ();
+          FloatMatrix R = argr.float_matrix_value ();
 
-                    if (col)
-                      fact.delete_col (j-one);
-                    else
-                      fact.delete_row (j(0)-one);
+          FloatQR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-                else
-                  {
-                    Matrix Q = argq.matrix_value ();
-                    Matrix R = argr.matrix_value ();
+          if (col)
+            fact.delete_col (j-one);
+          else
+            fact.delete_row (j(0)-one);
 
-                    QR fact (Q, R);
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          Matrix Q = argq.matrix_value ();
+          Matrix R = argr.matrix_value ();
 
-                    if (col)
-                      fact.delete_col (j-one);
-                    else
-                      fact.delete_row (j(0)-one);
+          QR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-              }
-            else
-              {
-                // complex case
-                if (argq.is_single_type ()
-                    || argr.is_single_type ())
-                  {
-                    FloatComplexMatrix Q =
-                      argq.float_complex_matrix_value ();
-                    FloatComplexMatrix R =
-                      argr.float_complex_matrix_value ();
+          if (col)
+            fact.delete_col (j-one);
+          else
+            fact.delete_row (j(0)-one);
 
-                    FloatComplexQR fact (Q, R);
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
+  else
+    {
+      // complex case
+      if (argq.is_single_type () || argr.is_single_type ())
+        {
+          FloatComplexMatrix Q =
+            argq.float_complex_matrix_value ();
+          FloatComplexMatrix R =
+            argr.float_complex_matrix_value ();
 
-                    if (col)
-                      fact.delete_col (j-one);
-                    else
-                      fact.delete_row (j(0)-one);
+          FloatComplexQR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-                else
-                  {
-                    ComplexMatrix Q = argq.complex_matrix_value ();
-                    ComplexMatrix R = argr.complex_matrix_value ();
-
-                    ComplexQR fact (Q, R);
+          if (col)
+            fact.delete_col (j-one);
+          else
+            fact.delete_row (j(0)-one);
 
-                    if (col)
-                      fact.delete_col (j-one);
-                    else
-                      fact.delete_row (j(0)-one);
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          ComplexMatrix Q = argq.complex_matrix_value ();
+          ComplexMatrix R = argr.complex_matrix_value ();
+
+          ComplexQR fact (Q, R);
 
-                    retval = ovl (fact.Q (), get_qr_r (fact));
-                  }
-              }
-          }
-        else
-          error ("qrdelete: invalid index J");
-      }
-    else
-      error ("qrdelete: dimension mismatch");
+          if (col)
+            fact.delete_col (j-one);
+          else
+            fact.delete_row (j(0)-one);
 
-  else
-    error ("qrdelete: ORIENT must be \"col\" or \"row\"");
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! AA = [0.091364  0.613038  0.027504  0.999083;
 %!       0.594638  0.425302  0.562834  0.603537;
@@ -1360,93 +1329,88 @@ Given a QR@tie{}factorization of a real 
 of @w{@var{A}(:,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
 @seealso{qr, qrupdate, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argi = args(2);
   octave_value argj = args(3);
 
   if (! argq.is_numeric_type () || ! argr.is_numeric_type ())
     print_usage ();
 
-  if (check_qr_dims (argq, argr, true))
-    {
-      if (check_index (argi) && check_index (argj))
-        {
-          octave_idx_type i = argi.int_value ();
-          octave_idx_type j = argj.int_value ();
+  if (! check_qr_dims (argq, argr, true))
+    error ("qrshift: dimensions mismatch");
 
-          if (argq.is_real_type ()
-              && argr.is_real_type ())
-            {
-              // all real case
-              if (argq.is_single_type ()
-                  && argr.is_single_type ())
-                {
-                  FloatMatrix Q = argq.float_matrix_value ();
-                  FloatMatrix R = argr.float_matrix_value ();
+  octave_idx_type i = argi.int_value ();
+  octave_idx_type j = argj.int_value ();
 
-                  FloatQR fact (Q, R);
-                  fact.shift_cols (i-1, j-1);
+  if (! check_index (argi) || ! check_index (argj))
+    error ("qrshift: invalid index I or J");
 
-                  retval = ovl (fact.Q (), get_qr_r (fact));
-                }
-              else
-                {
-                  Matrix Q = argq.matrix_value ();
-                  Matrix R = argr.matrix_value ();
+  octave_value_list retval;
 
-                  QR fact (Q, R);
-                  fact.shift_cols (i-1, j-1);
-
-                  retval = ovl (fact.Q (), get_qr_r (fact));
-                }
-            }
-          else
-            {
-              // complex case
-              if (argq.is_single_type ()
-                  && argr.is_single_type ())
-                {
-                  FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
+  if (argq.is_real_type () && argr.is_real_type ())
+    {
+      // all real case
+      if (argq.is_single_type ()
+          && argr.is_single_type ())
+        {
+          FloatMatrix Q = argq.float_matrix_value ();
+          FloatMatrix R = argr.float_matrix_value ();
 
-                  FloatComplexQR fact (Q, R);
-                  fact.shift_cols (i-1, j-1);
+          FloatQR fact (Q, R);
+          fact.shift_cols (i-1, j-1);
 
-                  retval = ovl (fact.Q (), get_qr_r (fact));
-                }
-              else
-                {
-                  ComplexMatrix Q = argq.complex_matrix_value ();
-                  ComplexMatrix R = argr.complex_matrix_value ();
-
-                  ComplexQR fact (Q, R);
-                  fact.shift_cols (i-1, j-1);
-
-                  retval = ovl (fact.Q (), get_qr_r (fact));
-                }
-            }
+          retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
-        error ("qrshift: invalid index I or J");
+        {
+          Matrix Q = argq.matrix_value ();
+          Matrix R = argr.matrix_value ();
+
+          QR fact (Q, R);
+          fact.shift_cols (i-1, j-1);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
     }
   else
-    error ("qrshift: dimensions mismatch");
+    {
+      // complex case
+      if (argq.is_single_type ()
+          && argr.is_single_type ())
+        {
+          FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+          FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+          FloatComplexQR fact (Q, R);
+          fact.shift_cols (i-1, j-1);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+      else
+        {
+          ComplexMatrix Q = argq.complex_matrix_value ();
+          ComplexMatrix R = argr.complex_matrix_value ();
+
+          ComplexQR fact (Q, R);
+          fact.shift_cols (i-1, j-1);
+
+          retval = ovl (fact.Q (), get_qr_r (fact));
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! AA = A.';
 %! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -337,14 +337,14 @@ factorization as determined by @var{typ}
       height++ ;
       retval(1) = static_cast<double> (height);
     }
 
   for (octave_idx_type i = 0; i < n; i++)
     tmp(i) = ColCount[i];
   retval(0) = tmp;
 
+  return retval;
+
 #else
   error ("symbfact: not available in this version of Octave");
 #endif
-
-  return retval;
 }
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -432,21 +432,21 @@ 157--172 1969, Brandon Press, New Jersey
 \n\
 @nospell{A. George, J.W.H. Liu}. @cite{Computer Solution of Large Sparse\n\
 Positive Definite Systems}, Prentice Hall Series in Computational\n\
 Mathematics, ISBN 0-13-165274-5, 1981.\n\
 \n\
 @seealso{colperm, colamd, symamd}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   octave_value arg = args(0);
 
   // the parameter of the matrix is converted into a sparse matrix
   //(if necessary)
   octave_idx_type *cidx;
   octave_idx_type *ridx;
   SparseMatrix Ar;
   SparseComplexMatrix Ac;
@@ -470,17 +470,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("symrcm");
       return retval;
     }
 
   if (nr == 0 && nc == 0)
-    return octave_value (NDArray (dim_vector (1, 0)));
+    return ovl (NDArray (dim_vector (1, 0)));
 
   // sizes of the heaps
   octave_idx_type s = 0;
 
   // head- and tail-indices for the queue
   octave_idx_type qt = 0;
   octave_idx_type qh = 0;
   CMK_Node v, w;
@@ -499,17 +499,18 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   octave_idx_type max_deg = calc_degrees (N, ridx, cidx, D);
 
   // if none of the nodes has a degree > 0 (a matrix of zeros)
   // the return value corresponds to the identity permutation
   if (max_deg == 0)
     {
       for (octave_idx_type i = 0; i < N; i++)
         P(i) = i;
-      return octave_value (P);
+
+      return ovl (P);
     }
 
   // a heap for the a node's neighbors. The number of neighbors is
   // limited by the maximum degree max_deg:
   OCTAVE_LOCAL_BUFFER (CMK_Node, S, max_deg);
 
   // a queue for the BFS. The array is always one element larger than
   // the number of entries that are stored.
@@ -688,10 +689,10 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     std::swap (P.elem (i), P.elem (j));
 
   // increment all indices, since Octave is not C
-  return octave_value (P+1);
+  return ovl (P+1);
 }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -565,21 +565,21 @@ Any nonzero values will be converted to 
 converted to false (0).  The non-numeric value NaN cannot be converted and\n\
 will produce an error.\n\
 \n\
 Compatibility Note: Octave accepts complex values as input, whereas\n\
 @sc{matlab} issues an error.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     retval = arg;
   else if (arg.is_numeric_type ())
     {
       if (arg.is_sparse_type ())
         retval = arg.sparse_bool_matrix_value ();
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1196,17 +1196,17 @@ DEFUN (iscell, args, ,
 @deftypefn {} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.\n\
 @seealso{ismatrix, isstruct, iscellstr, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_cell ());
+  return ovl (args(0).is_cell ());
 }
 
 DEFUN (cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cell (@var{n})\n\
 @deftypefnx {} {} cell (@var{m}, @var{n})\n\
 @deftypefnx {} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {} {} cell ([@var{m} @var{n} @dots{}])\n\
@@ -1261,17 +1261,17 @@ DEFUN (iscellstr, args, ,
 Return true if every element of the cell array @var{cell} is a character\n\
 string.\n\
 @seealso{ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_cellstr ());
+  return ovl (args(0).is_cellstr ());
 }
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
@@ -1282,35 +1282,32 @@ Create a new cell array object from the 
 \n\
 Each row of @var{strmat} becomes an element of @var{cstr}.  Any trailing\n\
 spaces in a row are deleted before conversion.\n\
 \n\
 To convert back from a cellstr to a character array use @code{char}.\n\
 @seealso{cell, char}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval;
+
   octave_value_list tmp = Fiscellstr (args, 1);
 
   if (tmp(0).is_true ())
-    retval = args(0);
+    return ovl (args(0));
   else
     {
       string_vector s = args(0).xall_strings ("cellstr: argument STRING must be a 2-D character array");
 
-      retval = (s.is_empty ()
-                ? Cell (octave_value (std::string ()))
-                : Cell (s, true));
+      return ovl (s.is_empty () ? Cell (octave_value (std::string ()))
+                                : Cell (s, true));
     }
-
-  return retval;
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 \n\
 If @var{f} is the number of fields in the structure, the resulting cell\n\
@@ -1366,23 +1363,23 @@ c(2,1,:)(:)\n\
 
   for (int i = 1; i < result_dv.length (); i++)
     result_dv(i) = m_dv(i-1);
 
   NoAlias<Cell> c (result_dv);
 
   octave_idx_type n_elts = m.numel ();
 
-  // Fill c in one sweep. Note that thanks to octave_map structure,
+  // Fill c in one sweep.  Note that thanks to octave_map structure,
   // we don't need a key lookup at all.
   for (octave_idx_type j = 0; j < n_elts; j++)
     for (octave_idx_type i = 0; i < num_fields; i++)
       c(i,j) = m.contents(i)(j);
 
-  return octave_value (c);
+  return ovl (c);
 }
 
 /*
 %!test
 %! keys = cellstr (char (floor (rand (11,10)*24+65)))';
 %! vals = cellfun (@(x) mat2cell (rand (19,1), ones (19,1), 1), ...
 %!          mat2cell ([1:11]', ones (11,1), 1), "uniformoutput", false)';
 %! s = struct ([keys; vals]{:});
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1734,67 +1734,60 @@ DEFUN (class, args, ,
 Return the class of the object @var{obj}, or create a class with\n\
 fields from structure @var{s} and name (string) @var{id}.\n\
 \n\
 Additional arguments name a list of parent classes from which the new class\n\
 is derived.\n\
 @seealso{typeinfo, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     // Called for class of object
     retval = args(0).class_name ();
   else
     {
       // Called as class constructor
-      octave_function *fcn = octave_call_stack::caller ();
-
       std::string id = args(1).xstring_value ("class: ID (class name) must be a string");
 
-      if (fcn)
-        {
-          if (fcn->is_class_constructor (id) || fcn->is_class_method (id))
-            {
-              octave_map m = args(0).xmap_value ("class: S must be a valid structure");
+      octave_function *fcn = octave_call_stack::caller ();
+
+      if (! fcn)
+        error ("class: invalid call from outside class constructor or method");
 
-              if (nargin == 2)
-                retval
-                  = octave_value (new octave_class
-                                  (m, id, std::list<std::string> ()));
-              else
-                {
-                  octave_value_list parents = args.slice (2, nargin-2);
+      if (! fcn->is_class_constructor (id) && ! fcn->is_class_method (id))
+        error ("class: '%s' is invalid as a class name in this context",
+               id.c_str ());
+
+      octave_map m = args(0).xmap_value ("class: S must be a valid structure");
 
-                  retval
-                    = octave_value (new octave_class (m, id, parents));
-                }
-
-              octave_class::exemplar_const_iterator it
-                = octave_class::exemplar_map.find (id);
+      if (nargin == 2)
+        retval
+          = octave_value (new octave_class (m, id, std::list<std::string> ()));
+      else
+        {
+          octave_value_list parents = args.slice (2, nargin-2);
 
-              if (it == octave_class::exemplar_map.end ())
-                octave_class::exemplar_map[id]
-                  = octave_class::exemplar_info (retval);
-              else if (! it->second.compare (retval))
-                error ("class: object of class '%s' does not match previously constructed objects",
-                       id.c_str ());
-            }
-          else
-            error ("class: '%s' is invalid as a class name in this context",
-                   id.c_str ());
+          retval = octave_value (new octave_class (m, id, parents));
         }
-      else
-        error ("class: invalid call from outside class constructor or method");
+
+      octave_class::exemplar_const_iterator it
+        = octave_class::exemplar_map.find (id);
+
+      if (it == octave_class::exemplar_map.end ())
+        octave_class::exemplar_map[id] = octave_class::exemplar_info (retval);
+      else if (! it->second.compare (retval))
+        error ("class: object of class '%s' does not match previously constructed objects",
+               id.c_str ());
     }
 
   return retval;
 }
 
 /*
 %!assert (class (1.1), "double");
 %!assert (class (single (1.1)), "single");
@@ -1828,37 +1821,37 @@ Numeric value comprising either a floati
 \n\
 If @var{classname} is a cell array of string, a logical array of the same\n\
 size is returned, containing true for each class to which @var{obj}\n\
 belongs to.\n\
 \n\
 @seealso{class, typeinfo}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
   octave_value obj = args(0);  // not const because of find_parent_class ()
   std::string obj_cls = obj.class_name ();
   Array<std::string> clsnames = args(1).xcellstr_value ("isa: CLASSNAME must be a string or cell array of strings");
 
   boolNDArray matches (clsnames.dims (), false);
+
   for (octave_idx_type idx = 0; idx < clsnames.numel (); idx++)
     {
       std::string cls = clsnames(idx);
       if (obj_cls == cls
           || (cls == "float"   && obj.is_float_type   ())
           || (cls == "integer" && obj.is_integer_type ())
           || (cls == "numeric" && obj.is_numeric_type ())
           || obj.is_instance_of (cls))
         matches(idx) = true;
     }
-  return octave_value (matches);
+
+  return ovl (matches);
 }
 
 /*
 %!assert (isa ("char", "float"), false)
 %!assert (isa (logical (1), "float"), false)
 %!assert (isa (double (13), "float"), true)
 %!assert (isa (single (13), "float"), true)
 %!assert (isa (int8 (13), "float"), false)
@@ -1917,53 +1910,49 @@ belongs to.\n\
 */
 
 DEFUN (__parent_classes__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __parent_classes__ (@var{x})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval = Cell ();
-
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   if (arg.is_object ())
-    retval = Cell (arg.parent_class_names ());
-
-  return retval;
+    return ovl (Cell (arg.parent_class_names ()));
+  else
+    return ovl (Cell ());
 }
 
 DEFUN (isobject, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isobject (@var{x})\n\
 Return true if @var{x} is a class object.\n\
 @seealso{class, typeinfo, isa, ismethod, isprop}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_object ());
+  return ovl (args(0).is_object ());
 }
 
 DEFUN (ismethod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} ismethod (@var{obj}, @var{method})\n\
 @deftypefnx {} {} ismethod (@var{clsname}, @var{method})\n\
 Return true if the string @var{method} is a valid method of the object\n\
 @var{obj} or of the class @var{clsname}.\n\
 @seealso{isprop, isobject}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
   octave_value arg = args(0);
 
   std::string class_name;
 
   if (arg.is_object ())
@@ -1971,49 +1960,44 @@ Return true if the string @var{method} i
   else if (arg.is_string ())
     class_name = arg.string_value ();
   else
     error ("ismethod: first argument must be object or class name");
 
   std::string method = args(1).string_value ();
 
   if (load_path::find_method (class_name, method) != std::string ())
-    retval = true;
+    return ovl (true);
   else
-    retval = false;
-
-  return retval;
+    return ovl (false);
 }
 
 DEFUN (__methods__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __methods__ (@var{x})\n\
 @deftypefnx {} {} __methods__ (\"classname\")\n\
 Internal function.\n\
 \n\
 Implements @code{methods} for Octave class objects and classnames.\n\
 @seealso{methods}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   // Input validation has already been done in methods.m.
   octave_value arg = args(0);
 
   std::string class_name;
 
   if (arg.is_object ())
     class_name = arg.class_name ();
   else if (arg.is_string ())
     class_name = arg.string_value ();
 
   string_vector sv = load_path::methods (class_name);
-  retval = Cell (sv);
 
-  return retval;
+  return ovl (Cell (sv));
 }
 
 static bool
 is_built_in_class (const std::string& cn)
 {
   static std::set<std::string> built_in_class_names;
 
   if (built_in_class_names.empty ())
@@ -2045,17 +2029,17 @@ When called from a class constructor, ma
 constructed as having a higher precedence than @var{class_name}.\n\
 \n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{inferiorto}\n\
 @end deftypefn")
 {
   octave_function *fcn = octave_call_stack::caller ();
-  if ((! fcn) || (! fcn->is_class_constructor ()))
+  if (! fcn || ! fcn->is_class_constructor ())
     error ("superiorto: invalid call from outside class constructor");
 
   for (int i = 0; i < args.length (); i++)
     {
       std::string inf_class = args(i).xstring_value ("superiorto: CLASS_NAME must be a string");
 
       // User defined classes always have higher precedence
       // than built-in classes
@@ -2078,17 +2062,17 @@ When called from a class constructor, ma
 constructed as having a lower precedence than @var{class_name}.\n\
 \n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{superiorto}\n\
 @end deftypefn")
 {
   octave_function *fcn = octave_call_stack::caller ();
-  if ((! fcn) || (! fcn->is_class_constructor ()))
+  if (! fcn || ! fcn->is_class_constructor ())
     error ("inferiorto: invalid call from outside class constructor");
 
   for (int i = 0; i < args.length (); i++)
     {
       std::string sup_class = args(i).xstring_value ("inferiorto: CLASS_NAME must be a string");
 
       if (is_built_in_class (sup_class))
         error ("inferiorto: cannot give user-defined class lower "
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3801,18 +3801,16 @@ cdef_manager::do_find_package_symbol (co
 
   return retval;
 }
 
 //----------------------------------------------------------------------------
 
 DEFUN (__meta_get_package__, args, , "")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
 
   return to_ov (lookup_package (cname));
 }
 
@@ -3826,18 +3824,16 @@ Undocumented internal function.\n\
 }
 
 DEFUN (__meta_class_query__, args, /* nargout */,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __meta_class_query__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
             << std::endl;
 #endif
 
   if (args.length () != 1)
     print_usage ();
@@ -3848,18 +3844,16 @@ Undocumented internal function.\n\
 }
 
 DEFUN (metaclass, args, /* nargout */,
        "-*- texinfo -*-\n\
 @deftypefn {} {} metaclass (obj)\n\
 Returns the meta.class object corresponding to the class of @var{obj}.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   cdef_object obj = to_cdef (args(0));
 
   return to_ov (obj.get_class ());
 }
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1718,147 +1718,141 @@ particular output.\n\
 
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
 
   octave_function *fcn = fh ? fh->function_value () : 0;
 
-  if (fcn)
-    {
-      octave_scalar_map m;
-
-      std::string fh_nm = fh->fcn_name ();
-
-      if (fh_nm == octave_fcn_handle::anonymous)
-        {
-          std::ostringstream buf;
-          fh->print_raw (buf);
-          m.setfield ("function", buf.str ());
+  if (! fcn)
+    error ("functions: FCN_HANDLE is not a valid function handle object");
 
-          m.setfield ("type", "anonymous");
-        }
-      else
-        {
-          m.setfield ("function", fh_nm);
+  octave_scalar_map m;
 
-          if (fcn->is_subfunction ())
-            {
-              m.setfield ("type", "subfunction");
-              Cell parentage (dim_vector (1, 2));
-              parentage.elem (0) = fh_nm;
-              parentage.elem (1) = fcn->parent_fcn_name ();
-              m.setfield ("parentage", octave_value (parentage));
-            }
-          else if (fcn->is_private_function ())
-            m.setfield ("type", "private");
-          else if (fh->is_overloaded ())
-            m.setfield ("type", "overloaded");
-          else
-            m.setfield ("type", "simple");
-        }
+  std::string fh_nm = fh->fcn_name ();
 
-      std::string nm = fcn->fcn_file_name ();
-
-      if (fh_nm == octave_fcn_handle::anonymous)
-        {
-          m.setfield ("file", nm);
-
-          octave_user_function *fu = fh->user_function_value ();
-
-          std::list<symbol_table::symbol_record> vars
-            = symbol_table::all_variables (fu->scope (), 0);
-
-          size_t varlen = vars.size ();
+  if (fh_nm == octave_fcn_handle::anonymous)
+    {
+      std::ostringstream buf;
+      fh->print_raw (buf);
+      m.setfield ("function", buf.str ());
 
-          if (varlen > 0)
-            {
-              octave_scalar_map ws;
-              for (std::list<symbol_table::symbol_record>::const_iterator
-                     p = vars.begin (); p != vars.end (); p++)
-                {
-                  ws.assign (p->name (), p->varval (0));
-                }
-
-              m.setfield ("workspace", ws);
-            }
-        }
-      else if (fcn->is_user_function () || fcn->is_user_script ())
-        {
-          octave_function *fu = fh->function_value ();
-          m.setfield ("file", fu->fcn_file_name ());
-        }
-      else
-        m.setfield ("file", "");
-
-      retval = m;
+      m.setfield ("type", "anonymous");
     }
   else
-    error ("functions: FCN_HANDLE is not a valid function handle object");
+    {
+      m.setfield ("function", fh_nm);
+
+      if (fcn->is_subfunction ())
+        {
+          m.setfield ("type", "subfunction");
+          Cell parentage (dim_vector (1, 2));
+          parentage.elem (0) = fh_nm;
+          parentage.elem (1) = fcn->parent_fcn_name ();
+          m.setfield ("parentage", octave_value (parentage));
+        }
+      else if (fcn->is_private_function ())
+        m.setfield ("type", "private");
+      else if (fh->is_overloaded ())
+        m.setfield ("type", "overloaded");
+      else
+        m.setfield ("type", "simple");
+    }
+
+  std::string nm = fcn->fcn_file_name ();
+
+  if (fh_nm == octave_fcn_handle::anonymous)
+    {
+      m.setfield ("file", nm);
+
+      octave_user_function *fu = fh->user_function_value ();
 
-  return retval;
+      std::list<symbol_table::symbol_record> vars
+        = symbol_table::all_variables (fu->scope (), 0);
+
+      size_t varlen = vars.size ();
+
+      if (varlen > 0)
+        {
+          octave_scalar_map ws;
+          for (std::list<symbol_table::symbol_record>::const_iterator
+                 p = vars.begin (); p != vars.end (); p++)
+            {
+              ws.assign (p->name (), p->varval (0));
+            }
+
+          m.setfield ("workspace", ws);
+        }
+    }
+  else if (fcn->is_user_function () || fcn->is_user_script ())
+    {
+      octave_function *fu = fh->function_value ();
+      m.setfield ("file", fu->fcn_file_name ());
+    }
+  else
+    m.setfield ("file", "");
+
+  return ovl (m);
 }
 
 DEFUN (func2str, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by the\n\
 function handle @var{fcn_handle}.\n\
 @seealso{str2func, functions}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_handle *fh = args(0).fcn_handle_value ("func2str: FCN_HANDLE argument must be a function handle object");
 
-  if (fh)
-    {
-      std::string fh_nm = fh->fcn_name ();
+  if (! fh)
+    error ("func2str: FCN_HANDLE must be a valid function handle");
+
+  octave_value retval;
+
+  std::string fh_nm = fh->fcn_name ();
 
-      if (fh_nm == octave_fcn_handle::anonymous)
-        {
-          std::ostringstream buf;
+  if (fh_nm == octave_fcn_handle::anonymous)
+    {
+      std::ostringstream buf;
 
-          fh->print_raw (buf);
+      fh->print_raw (buf);
 
-          retval = buf.str ();
-        }
-      else
-        retval = fh_nm;
+      retval = buf.str ();
     }
   else
-    error ("func2str: FCN_HANDLE must be a valid function handle");
+    retval = fh_nm;
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} str2func (@var{fcn_name})\n\
 @deftypefnx {} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
 \n\
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
 
+  octave_value retval;
+
   if (nm[0] == '@')
     {
       int parse_status;
       octave_value anon_fcn_handle =
         eval_string (nm, true, parse_status);
 
       if (parse_status == 0)
         retval = anon_fcn_handle;
@@ -1906,17 +1900,17 @@ DEFUN (is_function_handle, args, ,
 @deftypefn {} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class, functions}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_function_handle ());
+  return ovl (args(0).is_function_handle ());
 }
 
 /*
 %!shared fh
 %! fh = @(x) x;
 
 %!assert (is_function_handle (fh))
 %!assert (! is_function_handle ({fh}))
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -670,18 +670,16 @@ If the second argument is an integer @va
 \n\
 Programming Note: The use of @code{inline} is discouraged and it may be\n\
 removed from a future version of Octave.  The preferred way to create\n\
 functions from strings is through the use of anonymous functions\n\
 (@pxref{Anonymous Functions}) or @code{str2func}.\n\
 @seealso{argnames, formula, vectorize, str2func}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
   std::string fun = args(0).xstring_value ("inline: STR argument must be a string");
 
   string_vector fargs;
@@ -730,18 +728,17 @@ functions from strings is through the us
                     is_arg = false;
                   }
               }
           else if (! is_arg)
             {
               if (c == 'e' || c == 'E')
                 {
                   // possible number in exponent form, not arg
-                  if (isdigit (fun[i])
-                      || fun[i] == '-' || fun[i] == '+')
+                  if (isdigit (fun[i]) || fun[i] == '-' || fun[i] == '+')
                     continue;
                 }
               is_arg = true;
               tmp_arg.append (1, c);
             }
           else
             {
               tmp_arg.append (1, c);
@@ -804,17 +801,17 @@ functions from strings is through the us
 
       for (int i = 1; i < nargin; i++)
         {
           std::string s = args(i).xstring_value ("inline: additional arguments must be strings");
           fargs(i-1) = s;
         }
     }
 
-  return octave_value (new octave_fcn_inline (fun, fargs));
+  return ovl (new octave_fcn_inline (fun, fargs));
 }
 
 /*
 %!shared fn
 %! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
 %!assert (feval (inline ("sum (x(:))"), [1 2; 3 4]), 10)
@@ -834,29 +831,25 @@ DEFUN (formula, args, ,
 @deftypefn {} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 \n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
 @seealso{char, argnames, inline, vectorize}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_inline* fn = args(0).fcn_inline_value (true);
 
-  if (fn)
-    retval = octave_value (fn->fcn_text ());
-  else
+  if (! fn)
     error ("formula: FUN must be an inline function");
 
-  return retval;
+  return ovl (fn->fcn_text ());
 }
 
 /*
 %!assert (formula (fn), "x.^2 + 1")
 %!assert (formula (fn), char (fn))
 
 ## Test input validation
 %!error formula ()
@@ -867,38 +860,32 @@ Note that @code{char (@var{fun})} is equ
 DEFUN (argnames, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of the\n\
 arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_inline *fn = args(0).fcn_inline_value (true);
 
-  if (fn)
-    {
-      string_vector t1 = fn->fcn_arg_names ();
-
-      Cell t2 (dim_vector (t1.numel (), 1));
-
-      for (int i = 0; i < t1.numel (); i++)
-        t2(i) = t1(i);
-
-      retval = t2;
-    }
-  else
+  if (! fn)
     error ("argnames: FUN must be an inline function");
 
-  return retval;
+  string_vector t1 = fn->fcn_arg_names ();
+
+  Cell t2 (dim_vector (t1.numel (), 1));
+
+  for (int i = 0; i < t1.numel (); i++)
+    t2(i) = t1(i);
+
+  return ovl (t2);
 }
 
 /*
 %!assert (argnames (fn), {"x"})
 %!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
 %!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
 
 ## Test input validation
@@ -922,18 +909,16 @@ fcn = vectorize (inline (\"x^2 - 1\"))\n
    @result{} fcn = f(x) = x.^2 - 1\n\
 quadv (fcn, 0, 3)\n\
    @result{} 6\n\
 @end group\n\
 @end example\n\
 @seealso{inline, formula, argnames}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   std::string old_func;
   octave_fcn_inline* old = 0;
   bool func_is_string = true;
 
   if (args(0).is_string ())
@@ -969,22 +954,19 @@ quadv (fcn, 0, 3)\n\
               i++;
             }
         }
       new_func.append (t1);
       i++;
     }
 
   if (func_is_string)
-    retval = octave_value (new_func);
+    return ovl (new_func);
   else
-    retval = octave_value (new octave_fcn_inline
-                           (new_func, old->fcn_arg_names ()));
-
-  return retval;
+    return ovl (new octave_fcn_inline (new_func, old->fcn_arg_names ()));
 }
 
 /*
 %!assert (char (vectorize (fn)), "x.^2 + 1")
 %!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
 %!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
 %!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
 %!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -890,17 +890,17 @@ Convert @var{x} to single precision type
                               octave_float_complex);
     }
   else
     {
       OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix,
                               octave_float_scalar);
     }
 
-  return octave_value ();
+  return octave_value_list ();
 }
 
 /*
 %!assert (class (single (1)), "single")
 %!assert (class (single (1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
 %!assert (class (single (uint8 (1))), "single")
 %!assert (class (single (int16 (1))), "single")
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2125,46 +2125,38 @@ example supplies an initial argument to 
 x = javaObject (\"java.lang.StringBuffer\")\n\
 x = javaObject (\"java.lang.StringBuffer\", \"Initial string\")\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{javaMethod, javaArray}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_JAVA
 
+  if (args.length () == 0)
+    print_usage ();
+
+  std::string classname = args(0).xstring_value ("javaObject: CLASSNAME must be a string");
+
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () == 0)
-    print_usage ();
-
-  if (args(0).is_string ())
-    {
-      std::string classname = args(0).string_value ();
-
-      octave_value_list tmp;
-      for (int i=1; i<args.length (); i++)
-        tmp(i-1) = args(i);
-      retval = octave_java::do_javaObject (current_env, classname, tmp);
-    }
-  else
-    error ("javaObject: CLASSNAME must be a string");
+  octave_value_list tmp;
+  for (int i=1; i<args.length (); i++)
+    tmp(i-1) = args(i);
+
+  return ovl (octave_java::do_javaObject (current_env, classname, tmp));
 
 #else
 
   error ("javaObject: Octave was not compiled with Java interface");
 
 #endif
-
-  return retval;
 }
 
 /*
 ## The tests below merely check if javaObject() works at all.  Whether it works
 ## properly, i.e., creates the right values, is a matter of Java itself.
 ## Create a Short and check if it really is a short, i.e., whether it overflows.
 %!testif HAVE_JAVA
 %! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
@@ -2191,58 +2183,53 @@ equivalent\n\
 @end group\n\
 @end example\n\
 \n\
 @code{javaMethod} returns the result of the method invocation.\n\
 \n\
 @seealso{methods, javaObject}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_JAVA
 
+  if (args.length () < 2)
+    print_usage ();
+
+  std::string methodname = args(0).xstring_value ("javaMethod: METHODNAME must be a string");
+
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () < 2)
-    print_usage ();
-
-  if (args(0).is_string ())
+  octave_value retval;
+
+  octave_value_list tmp;
+  for (int i=2; i<args.length (); i++)
+    tmp(i-2) = args(i);
+
+  if (args(1).is_java ())
     {
-      std::string methodname = args(0).string_value ();
-
-      octave_value_list tmp;
-      for (int i=2; i<args.length (); i++)
-        tmp(i-2) = args(i);
-
-      if (args(1).is_java ())
-        {
-          octave_java *jobj = TO_JAVA (args(1));
-          retval = jobj->do_javaMethod (current_env, methodname, tmp);
-        }
-      else if (args(1).is_string ())
-        {
-          std::string cls = args(1).string_value ();
-          retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
-        }
-      else
-        error ("javaMethod: OBJ must be a Java object or a string");
+      octave_java *jobj = TO_JAVA (args(1));
+      retval = jobj->do_javaMethod (current_env, methodname, tmp);
+    }
+  else if (args(1).is_string ())
+    {
+      std::string cls = args(1).string_value ();
+      retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
     }
   else
-    error ("javaMethod: METHODNAME must be a string");
+    error ("javaMethod: OBJ must be a Java object or a string");
+
+  return retval;
 
 #else
 
   error ("javaMethod: Octave was not compiled with Java interface");
 
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_JAVA
 %! ## Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ("getProperty", "java.lang.System", "java.version"), ".");
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
 */
@@ -2264,54 +2251,49 @@ equivalent\n\
   __java_get__ (x, \"field1\")\n\
   x.field1\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_set__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_JAVA
 
+  if (args.length () != 2)
+    print_usage ();
+
+  std::string name = args(1).string_value ("__java_get__: NAME must be a string");
+
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () != 2)
-    print_usage ();
-
-  if (args(1).is_string ())
+  octave_value retval;
+
+  if (args(0).is_java ())
     {
-      std::string name = args(1).string_value ();
-
-      if (args(0).is_java ())
-        {
-          octave_java *jobj = TO_JAVA (args(0));
-          retval = jobj->do_java_get (current_env, name);
-        }
-      else if (args(0).is_string ())
-        {
-          std::string cls = args(0).string_value ();
-          retval = octave_java::do_java_get (current_env, cls, name);
-        }
-      else
-        error ("__java_get__: OBJ must be a Java object or a string");
+      octave_java *jobj = TO_JAVA (args(0));
+      retval = jobj->do_java_get (current_env, name);
+    }
+  else if (args(0).is_string ())
+    {
+      std::string cls = args(0).string_value ();
+      retval = octave_java::do_java_get (current_env, cls, name);
     }
   else
-    error ("__java_get__: NAME must be a string");
+    error ("__java_get__: OBJ must be a Java object or a string");
+
+  return retval;
 
 #else
 
   error ("__java_get__: Octave was not compiled with Java interface");
 
 #endif
-
-  return retval;
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
 @var{val}.\n\
 \n\
@@ -2327,88 +2309,83 @@ equivalent\n\
   __java_set__ (x, \"field1\", val)\n\
   x.field1 = val\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_get__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_JAVA
 
+  if (args.length () != 3)
+    print_usage ();
+
+  std::string name = args(1).xstring_value ("__java_set__: NAME must be a string");
+
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () != 3)
-    print_usage ();
-
-  if (args(1).is_string ())
+  octave_value retval;
+
+  if (args(0).is_java ())
     {
-      std::string name = args(1).string_value ();
-
-      if (args(0).is_java ())
-        {
-          octave_java *jobj = TO_JAVA (args(0));
-          retval = jobj->do_java_set (current_env, name, args(2));
-        }
-      else if (args(0).is_string ())
-        {
-          std::string cls = args(0).string_value ();
-          retval = octave_java::do_java_set (current_env, cls, name, args(2));
-        }
-      else
-        error ("__java_set__: OBJ must be a Java object or a string");
+      octave_java *jobj = TO_JAVA (args(0));
+      retval = jobj->do_java_set (current_env, name, args(2));
+    }
+  else if (args(0).is_string ())
+    {
+      std::string cls = args(0).string_value ();
+      retval = octave_java::do_java_set (current_env, cls, name, args(2));
     }
   else
-    error ("__java_set__: NAME must be a string");
+    error ("__java_set__: OBJ must be a Java object or a string");
+
+  return retval;
 
 #else
 
   error ("__java_set__: Octave was not compiled with Java interface");
 
 #endif
-
-  return retval;
 }
 
 DEFUN (java2mat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} java2mat (@var{javaobj})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_JAVA
 
+  if (args.length () != 1)
+    print_usage ();
+
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () != 1)
-    print_usage ();
+  octave_value_list retval;
 
   if (args(0).is_java ())
     {
       octave_java *jobj = TO_JAVA (args(0));
-      retval(0) = box_more (current_env, jobj->to_java (), 0);
+      retval = ovl (box_more (current_env, jobj->to_java (), 0));
     }
   else
-    retval(0) = args(0);
+    retval = ovl (args(0));
+
+  return retval;
 
 #else
 
   error ("java2mat: Octave was not compiled with Java interface");
 
 #endif
-
-  return retval;
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
@@ -2417,28 +2394,21 @@ automatically converted to Octave matric
 The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
 #ifdef HAVE_JAVA
-
-  retval = SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
+  return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
-
   error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
-
 #endif
-
-  return retval;
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
@@ -2489,17 +2459,17 @@ DEFUN (isjava, args, ,
 @deftypefn {} {} isjava (@var{x})\n\
 Return true if @var{x} is a Java object.\n\
 @seealso{class, typeinfo, isa, javaObject}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_java ());
+  return ovl (args(0).is_java ());
 }
 
 /*
 ## Check automatic conversion of java primitive arrays into octave types.
 %!testif HAVE_JAVA
 %! assert (javaObject ("java.lang.String", "hello").getBytes (),
 %!         int8 ([104 101 108 108 111]'));
 
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -112,17 +112,17 @@ This should delete elements if @code{I} 
 This should give an error if @code{I} is nonempty.\n\
 @end table\n\
 @seealso{isempty, isindex}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_null_value ());
+  return ovl (args(0).is_null_value ());
 }
 
 /*
 %!assert (isnull ([]), true)
 %!assert (isnull ([1]), false)
 %!assert (isnull (zeros (0,3)), false)
 %!assert (isnull (""), true)
 %!assert (isnull ("A"), false)
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -184,17 +184,17 @@ elements) or returned from a function, @
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (new octave_oncleanup (args(0)));
+  return ovl (new octave_oncleanup (args(0)));
 }
 
 /*
 %!test
 %! old_wstate = warning ("query");
 %! unwind_protect
 %!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
 %!   warning ("off", "__MY_WARNING__");
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -1025,17 +1025,17 @@ Convert @var{x} to double precision type
       OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix,
                               octave_complex);
     }
   else
     {
       OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
     }
 
-  return octave_value ();
+  return octave_value_list ();
 }
 
 /*
 %!assert (class (double (single (1))), "double")
 %!assert (class (double (single (1 + i))), "double")
 %!assert (class (double (int8 (1))), "double")
 %!assert (class (double (uint8 (1))), "double")
 %!assert (class (double (int16 (1))), "double")
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1840,17 +1840,17 @@ DEFUN (isstruct, args, ,
 @deftypefn {} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_map ());
+  return ovl (args(0).is_map ());
 }
 
 DEFUN (__fieldnames__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __fieldnames__ (@var{struct})\n\
 @deftypefnx {} {} __fieldnames__ (@var{obj})\n\
 Internal function.\n\
 \n\
@@ -1882,30 +1882,27 @@ DEFUN (isfield, args, ,
 Return true if the @var{x} is a structure and it includes an element named\n\
 @var{name}.\n\
 \n\
 If @var{name} is a cell array of strings then a logical array of equal\n\
 dimension is returned.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
-  retval = false;
+  octave_value retval = false;
 
   if (args(0).is_map ())
     {
       octave_map m = args(0).map_value ();
 
       // FIXME: should this work for all types that can do
       // structure reference operations?
-
       if (args(1).is_string ())
         {
           std::string key = args(1).string_value ();
 
           retval = m.isfield (key);
         }
       else if (args(1).is_cell ())
         {
@@ -1934,27 +1931,23 @@ dimension is returned.\n\
 
 DEFUN (numfields, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} numfields (@var{s})\n\
 Return the number of fields of the structure @var{s}.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
-  if (args(0).is_map ())
-    retval = static_cast<double> (args(0).nfields ());
-  else
+  if (! args(0).is_map ())
     error ("numfields: argument must be a struct");
 
-  return retval;
+  return ovl (static_cast<double> (args(0).nfields ()));
 }
 
 /*
 ## test isfield
 %!test
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
 %! assert (isfield (x, "b"));
 %!assert (isfield (struct ("a", "1"), "a"))
@@ -1987,48 +1980,44 @@ A(1)\n\
         Height = 185\n\
       @}\n\
 \n\
 @end group\n\
 @end example\n\
 @seealso{struct2cell, cell2mat, struct}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   if (! args(0).is_cell ())
     error ("cell2struct: argument CELL must be of type cell");
 
   if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
     error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
 
-  const Cell vals = args(0).cell_value ();
-  const Array<std::string> fields = args(1).cellstr_value ();
-
-  octave_idx_type ext = 0;
-
   int dim = 0;
 
   if (nargin == 3)
     {
       if (! args(2).is_real_scalar ())
         error ("cell2struct: DIM must be a real scalar");
 
       dim = nargin == 2 ? 0 : args(2).int_value () - 1;
     }
 
   if (dim < 0)
     error ("cell2struct: DIM must be a valid dimension");
 
-  ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
+  const Cell vals = args(0).cell_value ();
+  const Array<std::string> fields = args(1).cellstr_value ();
+
+  octave_idx_type ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
 
   if (ext != fields.numel ())
     error ("cell2struct: number of FIELDS does not match dimension");
 
   int nd = std::max (dim+1, vals.ndims ());
   // result dimensions.
   dim_vector rdv = vals.dims ().redim (nd);
 
@@ -2050,19 +2039,17 @@ A(1)\n\
   Array<idx_vector> ia (dim_vector (nd, 1), idx_vector::colon);
 
   for (octave_idx_type i = 0; i < ext; i++)
     {
       ia(dim) = i;
       map.setfield (fields(i), vals.index (ia).reshape (rdv));
     }
 
-  retval = map;
-
-  return retval;
+  return ovl (map);
 }
 
 /*
 ## test cell2struct versus struct2cell
 %!test
 %! keys = cellstr (char (floor (rand (100,10)*24+65)))';
 %! vals = mat2cell (rand (100,1), ones (100,1), 1)';
 %! s = struct ([keys; vals]{:});
@@ -2088,18 +2075,16 @@ DEFUN (rmfield, args, ,
 Return a @emph{copy} of the structure (array) @var{s} with the field @var{f}\n\
 removed.\n\
 \n\
 If @var{f} is a cell array of strings or a character array, remove each of\n\
 the named fields.\n\
 @seealso{orderfields, fieldnames, isfield}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
   octave_map m = args(0).xmap_value ("rmfield: first argument must be a struct");
 
   octave_value_list fval = Fcellstr (args(1), 1);
 
   Cell fcell = fval(0).cell_value ();
@@ -2109,19 +2094,17 @@ the named fields.\n\
       std::string key = fcell(i).string_value ();
 
       if (m.isfield (key))
         m.rmfield (key);
       else
         error ("rmfield: structure does not contain field %s", key.c_str ());
     }
 
-  retval = m;
-
-  return retval;
+  return ovl (m);
 }
 
 /*
 ## test rmfield
 %!shared x
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
 %!
 %!test
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -616,29 +616,25 @@ DEFUN (typeinfo, args, ,
 \n\
 Return the type of the expression @var{expr}, as a string.\n\
 \n\
 If @var{expr} is omitted, return a cell array of strings containing all the\n\
 currently installed data types.\n\
 @seealso{class, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 0)
-    retval = Cell (octave_value_typeinfo::installed_type_names ());
+    return ovl (Cell (octave_value_typeinfo::installed_type_names ()));
   else
-    retval = args(0).type_name ();
-
-  return retval;
+    return ovl (args(0).type_name ());
 }
 
 /*
 %!assert (iscellstr (typeinfo ()))
 
 %!assert (typeinfo ({"cell"}), "cell")
 
 %!assert (typeinfo (1), "scalar")
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -813,57 +813,55 @@ nargin (\"union\")\n\
 @result{} -3\n\
 @end group\n\
 @end example\n\
 \n\
 Programming Note: @code{nargin} does not work on built-in functions.\n\
 @seealso{nargout, narginchk, varargin, inputname}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
             error ("nargin: invalid function name: %s", name.c_str ());
         }
 
       octave_function *fcn_val = func.function_value ();
-      if (fcn_val)
-        {
-          octave_user_function *fcn = fcn_val->user_function_value (true);
+      if (! fcn_val)
+        error ("nargin: FCN must be a string or function handle");
 
-          if (fcn)
-            {
-              tree_parameter_list *param_list = fcn->parameter_list ();
+      octave_user_function *fcn = fcn_val->user_function_value (true);
 
-              retval = param_list ? param_list->length () : 0;
-              if (fcn->takes_varargs ())
-                retval = -1 - retval;
-            }
-          else
-            {
-              // Matlab gives up for histc,
-              // so maybe it's ok that that we give up somtimes too?
-              error ("nargin: nargin information not available for built-in functions");
-            }
+      if (fcn)
+        {
+          tree_parameter_list *param_list = fcn->parameter_list ();
+
+          retval = param_list ? param_list->length () : 0;
+          if (fcn->takes_varargs ())
+            retval = -1 - retval;
         }
       else
-        error ("nargin: FCN must be a string or function handle");
+        {
+          // Matlab gives up for histc,
+          // so maybe it's ok that that we give up somtimes too?
+          error ("nargin: nargin information not available for built-in functions");
+        }
     }
   else
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
@@ -921,78 +919,70 @@ nargout (@@imread)\n\
 will return -2, because @code{imread} has two outputs and the second is\n\
 @var{varargout}.\n\
 \n\
 Programming Note.  @code{nargout} does not work for built-in functions and\n\
 returns -1 for all anonymous functions.\n\
 @seealso{nargin, varargout, isargout, nthargout}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
             error ("nargout: invalid function name: %s", name.c_str ());
         }
 
       if (func.is_inline_function ())
-        {
-          retval = 1;
-          return retval;
-        }
+        return ovl (1);
 
       if (func.is_function_handle ())
         {
           octave_fcn_handle *fh = func.fcn_handle_value ();
           std::string fh_nm = fh->fcn_name ();
 
           if (fh_nm == octave_fcn_handle::anonymous)
-            {
-              retval = -1;
-              return retval;
-            }
+            return ovl (-1);
         }
 
       octave_function *fcn_val = func.function_value ();
-      if (fcn_val)
-        {
-          octave_user_function *fcn = fcn_val->user_function_value (true);
+      if (! fcn_val)
+        error ("nargout: FCN must be a string or function handle");
 
-          if (fcn)
-            {
-              tree_parameter_list *ret_list = fcn->return_list ();
-
-              retval = ret_list ? ret_list->length () : 0;
+      octave_user_function *fcn = fcn_val->user_function_value (true);
 
-              if (fcn->takes_var_return ())
-                retval = -1 - retval;
-            }
-          else
-            {
-              // JWE said this information is not available (2011-03-10)
-              // without making intrusive changes to Octave.
-              // Matlab gives up for histc,
-              // so maybe it's ok that we give up somtimes too?
-              error ("nargout: nargout information not available for built-in functions.");
-            }
+      if (fcn)
+        {
+          tree_parameter_list *ret_list = fcn->return_list ();
+
+          retval = ret_list ? ret_list->length () : 0;
+
+          if (fcn->takes_var_return ())
+            retval = -1 - retval;
         }
       else
-        error ("nargout: FCN must be a string or function handle");
+        {
+          // JWE said this information is not available (2011-03-10)
+          // without making intrusive changes to Octave.
+          // Matlab gives up for histc,
+          // so maybe it's ok that we give up somtimes too?
+          error ("nargout: nargout information not available for built-in functions.");
+        }
     }
   else
     {
       if (! symbol_table::at_top_level ())
         {
           retval = symbol_table::varval (".nargout.");
 
           if (retval.is_undefined ())
@@ -1053,53 +1043,49 @@ outputs which are unwanted.\n\
 \n\
 If @var{k} is outside the range @code{1:max (nargout)}, the function returns\n\
 false.  @var{k} can also be an array, in which case the function works\n\
 element-by-element and a logical array is returned.  At the top level,\n\
 @code{isargout} returns an error.\n\
 @seealso{nargout, varargout, nthargout}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
-  if (! symbol_table::at_top_level ())
-    {
-      int nargout1 = symbol_table::varval (".nargout.").int_value ();
+  if (symbol_table::at_top_level ())
+    error ("isargout: invalid call at top level");
+
+  int nargout1 = symbol_table::varval (".nargout.").int_value ();
 
-      Matrix ignored;
-      octave_value tmp = symbol_table::varval (".ignored.");
-      if (tmp.is_defined ())
-        ignored = tmp.matrix_value ();
-
-      if (args(0).is_scalar_type ())
-        {
-          double k = args(0).double_value ();
+  Matrix ignored;
+  octave_value tmp = symbol_table::varval (".ignored.");
+  if (tmp.is_defined ())
+    ignored = tmp.matrix_value ();
 
-          retval = isargout1 (nargout1, ignored, k);
-        }
-      else if (args(0).is_numeric_type ())
-        {
-          const NDArray ka = args(0).array_value ();
+  if (args(0).is_scalar_type ())
+    {
+      double k = args(0).double_value ();
 
-          boolNDArray r (ka.dims ());
-          for (octave_idx_type i = 0; i < ka.numel (); i++)
-            r(i) = isargout1 (nargout1, ignored, ka(i));
+      return ovl (isargout1 (nargout1, ignored, k));
+    }
+  else if (args(0).is_numeric_type ())
+    {
+      const NDArray ka = args(0).array_value ();
 
-          retval = r;
-        }
-      else
-        gripe_wrong_type_arg ("isargout", args(0));
+      boolNDArray r (ka.dims ());
+      for (octave_idx_type i = 0; i < ka.numel (); i++)
+        r(i) = isargout1 (nargout1, ignored, ka(i));
+
+      return ovl (r);
     }
   else
-    error ("isargout: invalid call at top level");
+    gripe_wrong_type_arg ("isargout", args(0));
 
-  return retval;
+  return octave_value_list ();
 }
 
 /*
 %!function [x, y] = try_isargout ()
 %!  if (isargout (1))
 %!    if (isargout (2))
 %!      x = 1; y = 2;
 %!    else
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2925,17 +2925,17 @@ DEFUN (sizeof, args, ,
 @deftypefn {} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).byte_size ());
+  return ovl (args(0).byte_size ());
 }
 
 /*
 %!assert (sizeof (uint64 (ones (3))), 72)
 %!assert (sizeof (double (zeros (2,4))), 64)
 %!assert (sizeof ({"foo", "bar", "baaz"}), 10)
 */
 
@@ -3044,19 +3044,19 @@ If @var{idx} is an empty structure array
   std::string type;
   std::list<octave_value_list> idx;
 
   decode_subscripts ("subsref", args(1), type, idx);
 
   octave_value arg0 = args(0);
 
   if (type.empty ())
-    retval = arg0;
+    return ovl (arg0);
   else
-    retval = arg0.subsref (type, idx, nargout);
+    return arg0.subsref (type, idx, nargout);
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
 Perform the subscripted assignment operation according to the subscript\n\
@@ -3084,42 +3084,37 @@ subsasgn (val, idx, 0)\n\
 \n\
 Note that this is the same as writing @code{val(:,1:2) = 0}.\n\
 \n\
 If @var{idx} is an empty structure array with fields @samp{type} and\n\
 @samp{subs}, return @var{rhs}.\n\
 @seealso{subsref, substruct}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
   std::string type;
   std::list<octave_value_list> idx;
 
   decode_subscripts ("subsasgn", args(1), type, idx);
 
   if (type.empty ())
     {
       // Regularize a null matrix if stored into a variable.
-
-      retval = args(2).storable_value ();
+      return ovl (args(2).storable_value ());
     }
   else
     {
       octave_value arg0 = args(0);
 
       arg0.make_unique ();
 
-      retval= arg0.subsasgn (type, idx, args(2));
+      return ovl (arg0.subsasgn (type, idx, args(2)));
     }
-
-  return retval;
 }
 
 /*
 %!test
 %! a = reshape ([1:25], 5,5);
 %! idx1 = substruct ("()", {3, 3});
 %! idx2 = substruct ("()", {2:2:5, 2:2:5});
 %! idx3 = substruct ("()", {":", [1,5]});
@@ -3189,17 +3184,17 @@ DEFUN (is_sq_string, args, ,
 @deftypefn {} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_sq_string ());
+  return ovl (args(0).is_sq_string ());
 }
 
 /*
 %!assert (is_sq_string ('foo'), true)
 %!assert (is_sq_string ("foo"), false)
 %!assert (is_sq_string (1.0), false)
 %!assert (is_sq_string ({2.0}), false)
 
@@ -3212,17 +3207,17 @@ DEFUN (is_dq_string, args, ,
 @deftypefn {} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
 @seealso{is_sq_string, ischar}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_dq_string ());
+  return ovl (args(0).is_dq_string ());
 }
 
 /*
 %!assert (is_dq_string ("foo"), true)
 %!assert (is_dq_string ('foo'), false)
 %!assert (is_dq_string (1.0), false)
 %!assert (is_dq_string ({2.0}), false)
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -200,50 +200,50 @@ intern_argv (int argc, char **argv)
 }
 
 DEFUN (__version_info__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   static octave_map vinfo;
 
   int nargin = args.length ();
 
   if (nargin != 0 && nargin != 4)
     print_usage ();
 
-  if (nargin == 4)
+  octave_value retval;
+
+  if (nargin == 0)
+    retval = vinfo;
+  else if (nargin == 4)
     {
       if (vinfo.nfields () == 0)
         {
-          vinfo.assign ("Name", args (0));
-          vinfo.assign ("Version", args (1));
-          vinfo.assign ("Release", args (2));
-          vinfo.assign ("Date", args (3));
+          vinfo.assign ("Name", args(0));
+          vinfo.assign ("Version", args(1));
+          vinfo.assign ("Release", args(2));
+          vinfo.assign ("Date", args(3));
         }
       else
         {
           octave_idx_type n = vinfo.numel () + 1;
 
           vinfo.resize (dim_vector (n, 1));
 
           octave_value idx (n);
 
-          vinfo.assign (idx, "Name", Cell (octave_value (args (0))));
-          vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
-          vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
-          vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
+          vinfo.assign (idx, "Name", Cell (octave_value (args(0))));
+          vinfo.assign (idx, "Version", Cell (octave_value (args(1))));
+          vinfo.assign (idx, "Release", Cell (octave_value (args(2))));
+          vinfo.assign (idx, "Date", Cell (octave_value (args(3))));
         }
     }
-  else if (nargin == 0)
-    retval = vinfo;
 
   return retval;
 }
 
 static void
 initialize_version_info (void)
 {
   octave_value_list args;
@@ -1010,24 +1010,20 @@ octave_starting_gui (void)
 
 DEFUN (isguirunning, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isguirunning ()\n\
 Return true if Octave is running in GUI mode and false otherwise.\n\
 @seealso{have_window_system}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 0)
     print_usage ();
 
-  retval = start_gui;
-
-  return retval;
+  return ovl (start_gui);
 }
 
 /*
 %!assert (islogical (isguirunning ()))
 %!error isguirunning (1)
 */
 
 DEFUN (argv, args, ,
@@ -1045,24 +1041,20 @@ octave --no-line-editing --silent\n\
 @code{argv} would return a cell array of strings with the elements\n\
 @option{--no-line-editing} and @option{--silent}.\n\
 \n\
 If you write an executable Octave script, @code{argv} will return the list\n\
 of arguments passed to the script.  @xref{Executable Octave Programs}, for\n\
 an example of how to create an executable Octave script.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 0)
     print_usage ();
 
-  retval = Cell (octave_argv);
-
-  return retval;
+  return ovl (Cell (octave_argv));
 }
 
 /*
 %!assert (iscellstr (argv ()))
 %!error argv (1)
 */
 
 DEFUN (program_invocation_name, args, ,
@@ -1072,45 +1064,37 @@ Return the name that was typed at the sh
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
 or using an executable Octave script, the program name is set to the\n\
 name of the script.  @xref{Executable Octave Programs}, for an example of\n\
 how to create an executable Octave script.\n\
 @seealso{program_name}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 0)
     print_usage ();
 
-  retval = octave_program_invocation_name;
-
-  return retval;
+  return ovl (octave_program_invocation_name);
 }
 
 /*
 %!assert (ischar (program_invocation_name ()))
 %!error program_invocation_name (1)
 */
 
 DEFUN (program_name, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 0)
     print_usage ();
 
-  retval = octave_program_name;
-
-  return retval;
+  return ovl (octave_program_name);
 }
 
 /*
 %!assert (ischar (program_name ()))
 %!error program_name (1)
 */
