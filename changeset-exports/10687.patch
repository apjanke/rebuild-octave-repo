# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1276053758 25200
#      Tue Jun 08 20:22:38 2010 -0700
# Node ID a8ce6bdecce5381f3f2f66f4134efb5d0cccdf59
# Parent  8675858ba1e2d2d67c07bd6f6dfd52e69daeafd1
Improve documentation strings.

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,27 @@
+2010-06-03  Rik <octave@nomad.inbox5.com>
+
+        * general/arrayfun.m, general/cart2pol.m, general/cart2sph.m, 
+        general/idivide.m, general/logspace.m, general/sph2cart.m, 
+        general/structfun.m, image/imagesc.m, io/csvread.m, io/csvwrite.m, 
+        linear-algebra/cond.m, linear-algebra/condest.m, 
+        linear-algebra/isdefinite.m, linear-algebra/null.m, 
+        linear-algebra/orth.m, miscellaneous/list_primes.m, 
+        optimization/fminunc.m, optimization/fzero.m, path/matlabroot.m,
+        plot/axis.m, plot/plot.m, plot/semilogx.m, plot/semilogxerr.m,
+        plot/semilogy.m, plot/semilogyerr.m, plot/stem.m, polynomial/poly.m,
+        polynomial/polyder.m, polynomial/polyderiv.m, polynomial/polyfit.m,
+        polynomial/polyout.m, polynomial/polyval.m, set/ismember.m,
+        sparse/spfun.m, specfun/betaln.m, statistics/base/mean.m,
+        statistics/base/median.m, statistics/base/mode.m, statistics/base/ols.m,
+        statistics/base/ranks.m, 
+        statistics/distributions/kolmogorov_smirnov_cdf.m, 
+        statistics/distributions/wblpdf.m: Improve documentation strings
+
 2010-06-07  Jaroslav Hajek  <highegg@gmail.com>
 
 	* pkg/pkg.m: Support pkg list -forge.
 
 2010-06-07  Jaroslav Hajek  <highegg@gmail.com>
 
 	* pkg/get_forge_pkg.m: New function.
 	* pkg/module.mk: Add it here.
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -120,17 +120,17 @@
 ##           "UniformOutput", false, "ErrorHandler", @@ferr)
 ## @result{} ans =
 ## @{
 ##  [1,1] = MyString
 ## @}
 ## @end group
 ## @end example
 ##
-## @seealso{cellfun, spfun, structfun}
+## @seealso{spfun, cellfun, structfun}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 ## Rewritten: Jaroslav Hajek <highegg@gmail.com>
 
 function varargout = arrayfun (func, varargin)
 
   if (nargin < 2)
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{x}, @var{y})
 ## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{x}, @var{y}, @var{z})
 ## Transform Cartesian to polar or cylindrical coordinates.
 ## @var{x}, @var{y} (and @var{z}) must be the same shape, or scalar.
 ## @var{theta} describes the angle relative to the positive x-axis.
-## @var{r} is the distance to the z-axis (0, 0, z).
+## @var{r} is the distance to the z-axis @w{(0, 0, z)}.
 ## @seealso{pol2cart, cart2sph, sph2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [theta, r, z] = cart2pol (x, y, z)
 
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{x}, @var{y}, @var{z})
 ## Transform Cartesian to spherical coordinates.
 ## @var{x}, @var{y} and @var{z} must be the same shape, or scalar.
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
-## @var{r} is the distance to the origin (0, 0, 0).
+## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @seealso{pol2cart, cart2pol, sph2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [theta, phi, r] = cart2sph (x, y, z)
 
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -13,53 +13,54 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} idivide (@var{x}, @var{y}, @var{op})
-## Integer division with different round rules.  The standard behavior of
-## the an integer division such as @code{@var{a} ./ @var{b}} is to round
-## the result to the nearest integer.  This is not always the desired
-## behavior and @code{idivide} permits integer element-by-element
+## Integer division with different rounding rules.  
+##
+## The standard behavior of integer division such as @code{@var{a} ./ @var{b}}
+## is to round the result to the nearest integer.  This is not always the 
+## desired behavior and @code{idivide} permits integer element-by-element
 ## division to be performed with different treatment for the fractional
 ## part of the division as determined by the @var{op} flag.  @var{op} is
 ## a string with one of the values: 
 ##
 ## @table @asis
 ## @item "fix"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards zero.
 ## @item "round"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards the nearest integer.
 ## @item "floor"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
-## downwards.
+## towards negative infinity.
 ## @item "ceil"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
-## upwards.
+## towards positive infinity.
 ## @end table
 ## 
 ## @noindent
-## If @var{op} is not given it is assumed that it is @code{"fix"}.
+## If @var{op} is not given it defaults to @code{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
 ## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
 ## @result{} int8 ([0, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "round")
 ## @result{} int8 ([-1, 1])
+## idivide (int8 ([-3, 3]), int8 (4), "floor")
+## @result{} int8 ([-1, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "ceil")
 ## @result{} int8 ([0, 1])
-## idivide (int8 ([-3, 3]), int8 (4), "floor")
-## @result{} int8 ([-1, 0])
 ## @end group
 ## @end example
 ##
 ## @seealso{ldivide, rdivide}
 ## @end deftypefn
 
 function z = idivide (x, y, op)
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -13,17 +13,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
+## @deftypefn  {Function File} {} logspace (@var{base}, @var{limit})
+## @deftypefnx {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
 ## Similar to @code{linspace} except that the values are logarithmically
 ## spaced from
 ## @tex
 ## $10^{base}$ to $10^{limit}$.
 ## @end tex
 ## @ifnottex
 ## 10^base to 10^limit.
 ## @end ifnottex
@@ -46,19 +47,20 @@
 ## @tex
 ## $10^{base}$ and $10^{\pi}$,
 ## @end tex
 ## @ifnottex
 ## 10^base and 10^pi,
 ## @end ifnottex
 ## in order to be compatible with the corresponding @sc{matlab}
 ## function.
+## If @var{n} is unspecified it defaults to 50.
 ##
-## Also for compatibility, return the second argument if fewer than two
-## values are requested.
+## Also for compatibility with @sc{matlab}, return the second argument if 
+## fewer than two values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = logspace (x1, x2, n)
 
   if (nargin == 2)
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{theta}, @var{phi}, @var{r})
 ## Transform spherical to Cartesian coordinates.
 ## @var{x}, @var{y} and @var{z} must be the same shape, or scalar.
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
-## @var{r} is the distance to the origin (0, 0, 0).
+## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @seealso{pol2cart, cart2pol, cart2sph}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [x, y, z] = sph2cart (theta, phi, r)
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} structfun (@var{func}, @var{s})
+## @deftypefn  {Function File} {} structfun (@var{func}, @var{s})
 ## @deftypefnx {Function File} {[@var{a}, @dots{}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
 ## @var{s}.  The fields of @var{s} are passed to the function @var{func}
 ## individually.
 ##
@@ -62,17 +62,17 @@
 ## 
 ## where there is an additional input argument to @var{errfunc} relative to
 ## @var{func}, given by @var{se}.  This is a structure with the elements
 ## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.  For an example on how to use
 ## an error handler, @pxref{doc-cellfun, @code{cellfun}}. 
 ##
-## @seealso{cellfun, arrayfun}
+## @seealso{cellfun, arrayfun, spfun}
 ## @end deftypefn
 
 function varargout = structfun (fun, s, varargin);
 
   if (nargin < 2)
     print_usage ();
   endif
 
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} imagesc (@var{a})
+## @deftypefn {Function File}  {} imagesc (@var{a})
 ## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{a})
 ## @deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
 ## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
 ## Display a scaled version of the matrix @var{a} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
 ## range is set to the 'clim' of the current axes.
diff --git a/scripts/io/csvread.m b/scripts/io/csvread.m
--- a/scripts/io/csvread.m
+++ b/scripts/io/csvread.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} csvread (@var{filename})
-## Read the matrix @var{x} from a file.
+## Read the comma-separated-value file @var{filename} into the matrix @var{x}.
 ##
 ## This function is equivalent to
 ## @example
-## dlmread (@var{filename}, "," , @dots{})
+## @var{x} = dlmread (@var{filename}, "," , @dots{})
 ## @end example
 ##
 ## @seealso{dlmread, dlmwrite, csvwrite}
 ## @end deftypefn
 
 function x = csvread (f, varargin)
   x = dlmread (f, ",", varargin{:});
 endfunction
diff --git a/scripts/io/csvwrite.m b/scripts/io/csvwrite.m
--- a/scripts/io/csvwrite.m
+++ b/scripts/io/csvwrite.m
@@ -12,18 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{x} =} csvwrite (@var{filename}, @var{x})
-## Write the matrix @var{x} to a file.
+## @deftypefn {Function File} {} csvwrite (@var{filename}, @var{x})
+## Write the matrix @var{x} to the file @var{filename} in
+## @w{comma-separated-value} format.
 ##
 ## This function is equivalent to
 ## @example
 ## dlmwrite (@var{filename}, @var{x}, ",", @dots{})
 ## @end example
 ##
 ## @seealso{dlmread, dlmwrite, csvread}
 ## @end deftypefn
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -26,17 +26,17 @@
 ## $ {\parallel a \parallel_p * \parallel a^{-1} \parallel_p .} $
 ## @end tex
 ## @ifnottex
 ## @code{norm (@var{a}, @var{p}) * norm (inv (@var{a}), @var{p})}.
 ## @end ifnottex
 ##
 ## By default @code{@var{p} = 2} is used which implies a (relatively slow)
 ## singular value decomposition.  Other possible selections are 
-## @code{@var{p} = 1, Inf, "inf", "fro"} which are generally faster.  See
+## @code{@var{p} = 1, Inf, "fro"} which are generally faster.  See
 ## @code{norm} for a full discussion of possible @var{p} values.
 ## @seealso{condest, rcond, norm, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = cond (a, p)
 
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -12,17 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{t}) 
+## @deftypefn  {Function File} {} condest (@var{a}) 
+## @deftypefnx {Function File} {} condest (@var{a}, @var{t}) 
+## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@dots{}) 
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{solve}, @var{solve_t}, @var{t})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{apply}, @var{apply_t}, @var{solve}, @var{solve_t}, @var{n}, @var{t})
 ##
 ## Estimate the 1-norm condition number of a matrix @var{A}
 ## using @var{t} test vectors using a randomized 1-norm estimator.
 ## If @var{t} exceeds 5, then only 5 test vectors are used.
 ##
 ## If the matrix is not explicit, e.g., when estimating the condition 
@@ -47,21 +49,21 @@
 ##
 ## @code{condest} returns the 1-norm condition estimate @var{est} and
 ## a vector @var{v} satisfying @code{norm (A*v, 1) == norm (A, 1) * norm
 ## (@var{v}, 1) / @var{est}}.  When @var{est} is large, @var{v} is an
 ## approximate null vector.
 ##
 ## References: 
 ## @itemize
-## @item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
+## @item Nicholas J. Higham and Francoise Tisseur, "A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201.
 ## @url{http://dx.doi.org/10.1137/S0895479899356080}
-## @item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
+## @item Nicholas J. Higham and Francoise Tisseur, "A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra." @url{http://citeseer.ist.psu.edu/223007.html}
 ## @end itemize
 ##
 ## @seealso{cond, norm, onenormest}
 ## @end deftypefn
 
 ## Code originally licensed under
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -12,22 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} isdefinite (@var{x}, @var{tol})
+## @deftypefn  {Function File} {} isdefinite (@var{x})
+## @deftypefnx {Function File} {} isdefinite (@var{x}, @var{tol})
 ## Return 1 if @var{x} is symmetric positive definite within the
 ## tolerance specified by @var{tol} or 0 if @var{x} is symmetric
 ## positive semidefinite.  Otherwise, return -1.  If @var{tol}
-## is omitted, use a tolerance equal to 100 times the machine precision,
-## multiplied by the Frobeniusm norm of @var{x}.
+## is omitted, use a tolerance of 
+## @code{100 * eps * norm (@var{x}, "fro")}
 ## @seealso{issymmetric}
 ## @end deftypefn
 
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
 ## Adapted-By: jwe
 
 function retval = isdefinite (x, tol)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -23,16 +23,17 @@
 ##
 ## The dimension of the null space is taken as the number of singular
 ## values of @var{a} not greater than @var{tol}.  If the argument @var{tol}
 ## is missing, it is computed as
 ##
 ## @example
 ## max (size (@var{a})) * max (svd (@var{a})) * eps
 ## @end example
+## @seealso{orth}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993.
 ## Adapted-By: jwe
 
 function retval = null (A, tol)
 
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -23,16 +23,17 @@
 ##
 ## The dimension of the range space is taken as the number of singular
 ## values of @var{a} greater than @var{tol}.  If the argument @var{tol} is
 ## missing, it is computed as
 ##
 ## @example
 ## max (size (@var{a})) * max (svd (@var{a})) * eps
 ## @end example
+## @seealso{null}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993.
 ## Adapted-By: jwe
 
 function retval = orth (A, tol)
 
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -13,17 +13,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} list_primes (@var{n})
+## @deftypefn  {Function File} {} list_primes ()
+## @deftypefnx {Function File} {} list_primes (@var{n})
 ## List the first @var{n} primes.  If @var{n} is unspecified, the first
 ## 25 primes are listed.
 ##
 ## The algorithm used is from page 218 of the @TeX{}book.
 ## @seealso{primes, isprime}
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -14,25 +14,26 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
-## @deftypefn{Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
-## @deftypefnx{Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{grad}, @var{hess}]} = fminunc (@var{fcn}, @dots{})
-## Solve a unconstrained optimization problem defined by the function @var{fcn}.
+## @deftypefn  {Function File} {} fminunc (@var{fcn}, @var{x0})
+## @deftypefnx {Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
+## @deftypefnx {Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{grad}, @var{hess}]} = fminunc (@var{fcn}, @dots{})
+## Solve an unconstrained optimization problem defined by the function @var{fcn}.
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
 ## and return the objective function value, optionally with gradient.
 ## In other words, this function attempts to determine a vector @var{x} such 
 ## that @code{@var{fcn} (@var{x})} is a local minimum.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
-## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
+## in all calls to @var{fcn}, but otherwise is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fminunc} recognizes these options:
 ## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
 ## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"}, 
 ## @code{"GradObj"}, @code{"FinDiffType"},
 ## @code{"TypicalX"}, @code{"AutoScaling"}.
 ##
 ## If @code{"GradObj"} is @code{"on"}, it specifies that @var{fcn},
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -14,46 +14,65 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@var{fun}, @var{x0}, @var{options})
-## Find a zero point of a univariate function.  @var{fun} should be a function
-## handle or name.  @var{x0} should be a two-element vector specifying the initial 
-## bracketing. It should hold
+## @deftypefn  {Function File} {} fzero (@var{fun}, @var{x0})
+## @deftypefnx {Function File} {} fzero (@var{fun}, @var{x0}, @var{options})
+## @deftypefnx {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@dots{})
+## Find a zero of a univariate function.  
+##
+## @var{fun} should be a function handle or name.  @var{x0} should be a 
+## two-element vector specifying two points which bracket a zero.  In
+## other words, there must be a change in sign of the function between
+## @var{x0}(1) and @var{x0}(2).  More mathematically, the following must hold
 ## @example
 ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
 ## @end example
-## If only a single scalar is given as @var{x0}, several nearby and distant
-## values are probed in an attempt to obtain a valid bracketing. If this
+## If @var{x0} is a single scalar then several nearby and distant
+## values are probed in an attempt to obtain a valid bracketing.  If this
 ## is not successful, the function fails.
 ## @var{options} is a structure specifying additional options. 
 ## Currently, @code{fzero}
 ## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
 ## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}. 
-## For description of these options, see @ref{doc-optimset,,optimset}.
+## For a description of these options, see @ref{doc-optimset,,optimset}.
 ## 
 ## On exit, the function returns @var{x}, the approximate zero point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
-## The algorithm converged to a solution.
+##  The algorithm converged to a solution.
 ## @item 0
-## Maximum number of iterations or function evaluations has been exhausted.
+##  Maximum number of iterations or function evaluations has been reached.
 ## @item -1
 ## The algorithm has been terminated from user output function.
 ## @item -5
 ## The algorithm may have converged to a singular point.
 ## @end itemize
+## 
+## @var{output} is a structure containing runtime information about the
+## @code{fzero} algorithm.  Fields in the structure are:
+##
+## @itemize
+## @item iterations
+##  Number of iterations through loop.
+## @item nfev
+##  Number of function evaluations.
+## @item bracketx
+##  A two-element vector with the final bracketing of the zero along the x-axis.
+## @item brackety
+##  A two-element vector with the final bracketing of the zero along the y-axis.
+## @end itemize
 ## @seealso{optimset, fsolve} 
 ## @end deftypefn
 
 ## This is essentially the ACM algorithm 748: Enclosing Zeros of
 ## Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions
 ## on Mathematical Software, Vol. 21, No. 3, September 1995. Although
 ## the workflow should be the same, the structure of the algorithm has
 ## been transformed non-trivially; instead of the authors' approach of
@@ -305,18 +324,18 @@ function [x, fval, info, output] = fzero
   if (info == 1)
     if ((b - a) != 0 && abs ((fb - fa)/(b - a) / slope0) > max (1e6, 0.5/(eps+tolx)))
       info = -5;
     endif
   endif
 
   output.iterations = niter;
   output.funcCount = nfev;
-  output.bracket = [a, b];
-  output.bracketf = [fa, fb];
+  output.bracketx = [a, b];
+  output.brackety = [fa, fb];
 
 endfunction
 
 ## An assistant function that evaluates a function handle and checks for
 ## bad results.
 function fx = guarded_eval (fun, x)
   fx = fun (x);
   fx = fx(1);
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{val} =} matlabroot ()
-## Return the location of Octave's home.
+## Return the location of Octave's home directory.
 ## @seealso{OCTAVE_HOME}
 ## @end deftypefn
 
 function val = matlabroot ()
 
   val = OCTAVE_HOME;
 
 endfunction
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -13,27 +13,34 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} axis (@var{limits})
+## @deftypefn  {Function File} {} axis ()
+## @deftypefnx {Function File} {} axis ([@var{x}_lo, @var{x}_hi])
+## @deftypefnx {Function File} {} axis ([@var{x}_lo, @var{x}_hi, @var{y}_lo, @var{y}_hi])
+## @deftypefnx {Function File} {} axis ([@var{x}_lo, @var{x}_hi, @var{y}_lo, @var{y}_hi, @var{z}_lo, @var{z}_hi])
+## @deftypefnx {Function File} {} axis (@var{option})
+## @deftypefnx {Function File} {} axis (@dots{}, @var{option})
+## @deftypefnx  {Function File} {} axis (@var{h}, @dots{})
+## @deftypefnx  {Function File} {@var{limits} =} axis ()
 ## Set axis limits for plots.
 ##
 ## The argument @var{limits} should be a 2, 4, or 6 element vector.  The
 ## first and second elements specify the lower and upper limits for the x
 ## axis.  The third and fourth specify the limits for the y-axis, and the
 ## fifth and sixth specify the limits for the z-axis.
 ##
 ## Without any arguments, @code{axis} turns autoscaling on.  
 ##
-## With one output argument, @code{x = axis} returns the current axes 
+## With one output argument, @code{x = axis} returns the current axes.
 ##
 ## The vector argument specifying limits is optional, and additional
 ## string arguments may be used to specify various axis properties.  For
 ## example,
 ##
 ## @example
 ## axis ([1, 2, 3, 4], "square");
 ## @end example
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -13,21 +13,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} plot (@var{y})
+## @deftypefn  {Function File} {} plot (@var{y})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} plot (@var{h}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} plot (@dots{})
 ## Produces two-dimensional plots.  Many different combinations of
 ## arguments are possible.  The simplest form is
 ##
 ## @example
 ## plot (@var{y})
 ## @end example
 ##
 ## @noindent
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogx (@var{args})
-## Produce a two-dimensional plot using a log scale for the @var{x}
+## Produce a two-dimensional plot using a logarithmic scale for the @var{x}
 ## axis.  See the description of @code{plot} for a description of the
 ## arguments that @code{semilogx} will accept.
 ## @seealso{plot, semilogy, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -14,28 +14,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogxerr (@var{args})
-## Produce two-dimensional plots on a semilogarithm axis with errorbars.
-## Many different combinations of arguments are possible.  The most used
-## form is
+## Produce two-dimensional plots using a logarithmic scale for the @var{x}
+## axis and errorbars at each data point.  Many different combinations of 
+## arguments are possible.  The most used form is
 ##
 ## @example
 ## semilogxerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
-## which produces a semi-logarithm plot of @var{y} versus @var{x}
+## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See errorbar for available formats and 
+## format defined by @var{fmt}.  See @code{errorbar} for available formats and 
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogyerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogy (@var{args})
-## Produce a two-dimensional plot using a log scale for the @var{y}
+## Produce a two-dimensional plot using a logarithmic scale for the @var{y}
 ## axis.  See the description of @code{plot} for a description of the
 ## arguments that @code{semilogy} will accept.
 ## @seealso{plot, semilogx, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -13,28 +13,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogyerr (@var{args})
-## Produce two-dimensional plots on a semilogarithm axis with errorbars.
-## Many different combinations of arguments are possible.  The most used
-## form is
+## Produce two-dimensional plots using a logarithmic scale for the @var{y}
+## axis and errorbars at each data point.  Many different combinations of 
+## arguments are possible.  The most used form is
 ##
 ## @example
 ## semilogyerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
-## which produces a semi-logarithm plot of @var{y} versus @var{x}
+## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See errorbar for available formats and 
+## format defined by @var{fmt}.  See @code{errorbar} for available formats and 
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogxerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -12,52 +12,55 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{h} =} stem (@var{x}, @var{y}, @var{linespec})
-## @deftypefnx {Function File} {@var{h} =} stem (@dots{}, "filled")
+## @deftypefn  {Function File} {} stem (@var{x})
+## @deftypefnx {Function File} {} stem (@var{x}, @var{y})
+## @deftypefnx {Function File} {} stem (@var{x}, @var{y}, @var{linespec})
+## @deftypefnx {Function File} {} stem (@dots{}, "filled")
+## @deftypefnx {Function File} {@var{h} =} stem (@dots{})
 ## Plot a stem graph from two vectors of x-y data.  If only one argument
 ## is given, it is taken as the y-values and the x coordinates are taken
 ## from the indices of the elements.
 ##
 ## If @var{y} is a matrix, then each column of the matrix is plotted as
 ## a separate stem graph.  In this case @var{x} can either be a vector,
 ## the same length as the number of rows in @var{y}, or it can be a
 ## matrix of the same size as @var{y}.
 ##
-## The default color is @code{"r"} (red).  The default line style is
+## The default color is @code{"b"} (blue).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.  The line style can
 ## be altered by the @code{linespec} argument in the same manner as the
 ## @code{plot} command.  For example
 ##
 ## @example
 ## @group
 ## x = 1:10;
 ## y = ones (1, length (x))*2.*x;
-## stem (x, y, "b");
+## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
-## plots 10 stems with heights from 2 to 20 in blue;
+## plots 10 stems with heights from 2 to 20 in red;
 ## 
-## The return value of @code{stem} is a vector if "stem series" graphics
+## The return value of @code{stem} is a vector of "stem series" graphics
 ## handles, with one handle per column of the variable @var{y}.  This
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example
 ##
 ## @example
 ## @group
-## x = [0 : 10].';
+## x = [0 : 10]';
 ## y = [sin(x), cos(x)]
 ## h = stem (x, y);
 ## set (h(2), "color", "g");
 ## set (h(1), "basevalue", -1)
 ## @end group
 ## @end example
 ##
 ## @noindent
@@ -90,31 +93,31 @@ endfunction
 %!demo
 %! x = 1:10;
 %! y = ones (1, length (x))*2.*x;
 %! stem (x, y);
 
 %!demo
 %! x = 1:10;
 %! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "b");
+%! h = stem (x, y, "r");
 
 %!demo
 %! x = 1:10;
 %! y = ones (size (x))*2.*x;
 %! h = stem (x, y, "-.k");
 
 %!demo
 %! x = 1:10;
 %! y = ones (size (x))*2.*x;
 %! h = stem (x, y, "-.k.");
 
 %!demo
 %! x = 1:10;
 %! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "fill");
+%! h = stem (x, y, "filled");
 
 %!demo
-%! x = [0 : 10].';
+%! x = [0 : 10]';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), "color", "g");
 %! set (h(1), "basevalue", -1)
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -13,37 +13,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} poly (@var{a})
+## @deftypefn  {Function File} {} poly (@var{a})
+## @deftypefnx {Function File} {} poly (@var{x})
 ## If @var{a} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{a})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - a)},
-## the characteristic polynomial of @var{a}.  As an example we can use
-## this to find the eigenvalues of @var{a} as the roots of @code{poly (@var{a})}.
+## the characteristic polynomial of @var{a}.  For example, 
+## the following code finds the eigenvalues of @var{a} which are the roots of 
+## @code{poly (@var{a})}.
 ## @example
 ## @group
 ## roots(poly(eye(3)))
 ## @result{} 1.00000 + 0.00000i
 ## @result{} 1.00000 - 0.00000i
 ## @result{} 1.00000 + 0.00000i
 ## @end group
 ## @end example
-## In real-life examples you should, however, use the @code{eig} function
-## for computing eigenvalues.
+## For numerical performance, however, the @code{eig} function
+## should be used for computing eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of coefficients
 ## of the polynomial whose roots are the elements of @var{x}.  That is,
-## of @var{c} is a polynomial, then the elements of 
+## if @var{c} is a polynomial, then the elements of 
 ## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.
-## The vectors @var{c} and @var{d} are, however, not equal due to sorting
+## The vectors @var{c} and @var{d} are not identical, however, due to sorting
 ## and numerical errors.
 ## @seealso{eig, roots}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polyder (@var{c})
+## @deftypefn  {Function File} {} polyder (@var{c})
 ## @deftypefnx {Function File} {[@var{q}] =} polyder (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{q}, @var{r}] =} polyder (@var{b}, @var{a})
 ## See polyderiv.
 ## @end deftypefn
 
 ## Author: John W. Eaton
 
 function [q, r] = polyder (p, a)
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polyderiv (@var{c})
+## @deftypefn  {Function File} {} polyderiv (@var{c})
 ## @deftypefnx {Function File} {[@var{q}] =} polyderiv (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{q}, @var{r}] =} polyderiv (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by vector @var{c}.  If a pair of polynomials
 ## is given @var{b} and @var{a}, the derivative of the product is
 ## returned in @var{q}, or the quotient numerator in @var{q} and the
 ## quotient denominator in @var{r}.
 ## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -13,17 +13,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
+## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
+## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
+## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The second output is a structure containing the following fields:
 ##
 ## @table @samp
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -13,29 +13,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polyout (@var{c}, @var{x})
+## @deftypefn  {Function File} {} polyout (@var{c})
+## @deftypefnx {Function File} {} polyout (@var{c}, @var{x})
+## @deftypefnx {Function File} {@var{str} =} polyout (@dots{})
 ## Write formatted polynomial
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @ifnottex
 ## @example
 ##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ## @end ifnottex
-##  and return it as a string or write it to the screen (if
-##  @var{nargout} is zero).
-##  @var{x} defaults to the string @code{"s"}.
+## and return it as a string or write it to the screen (if
+## @var{nargout} is zero).
+## @var{x} defaults to the string @code{"s"}.
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyint}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -13,20 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} polyval (@var{p}, @var{x})
+## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
-## Evaluate the polynomial at of the specified values for @var{x}.  When @var{mu}
-## is present evaluate the polynomial for (@var{x}-@var{mu}(1))/@var{mu}(2).
+## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When 
+## @var{mu} is present evaluate the polynomial for 
+## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ## In addition to evaluating the polynomial, the second output 
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{tf} =} ismember (@var{A}, @var{S}) 
+## @deftypefn  {Function File} {@var{tf} =} ismember (@var{A}, @var{S}) 
 ## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{S}) 
 ## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{S}, "rows")
 ## Return a matrix @var{tf} with the same shape as @var{A} which has a 1 if 
 ## @code{A(i,j)} is in @var{S} and 0 if it is not.  If a second output argument 
 ## is requested, the index into @var{S} of each of the matching elements is
 ## also returned. 
 ##
 ## @example
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -17,17 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spfun (@var{f},@var{x})
 ## Compute @code{f(@var{x})} for the non-zero values of @var{x}.
 ## This results in a sparse matrix with the same structure as 
 ## @var{x}.  The function @var{f} can be passed as a string, a
-## function handle or an inline function.
+## function handle, or an inline function.
+## @seealso{arrayfun, cellfun, structfun}
 ## @end deftypefn
 
 function t = spfun (f, s)
 
   if (nargin != 2)
     print_usage ();
   endif
 
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} betaln (@var{a}, @var{b})
-## Return the log of the Beta function,
+## Return the natural logarithm of the Beta function,
 ## @tex
 ## $$
 ##  B (a, b) = \log {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -13,49 +13,53 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} mean (@var{x}, @var{dim}, @var{opt})
+## @deftypefn  {Function File} {} mean (@var{x})
+## @deftypefnx {Function File} {} mean (@var{x}, @var{dim})
+## @deftypefnx {Function File} {} mean (@var{x}, @var{opt})
+## @deftypefnx {Function File} {} mean (@var{x}, @var{dim}, @var{opt})
 ## If @var{x} is a vector, compute the mean of the elements of @var{x}
 ## @tex
 ## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## mean (x) = SUM_i x(i) / N
 ## @end example
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
-## With the optional argument @var{opt}, the kind of mean computed can be
-## selected.  The following options are recognized:
+## The optional argument @var{opt} selects the type of mean to compute.
+## The following options are recognized:
 ##
 ## @table @code
 ## @item "a"
-## Compute the (ordinary) arithmetic mean.  This is the default.
+## Compute the (ordinary) arithmetic mean.  [default]
 ##
 ## @item "g"
 ## Compute the geometric mean.
 ##
 ## @item "h"
 ## Compute the harmonic mean.
 ## @end table
 ##
 ## If the optional argument @var{dim} is supplied, work along dimension
 ## @var{dim}.
 ##
 ## Both @var{dim} and @var{opt} are optional.  If both are supplied,
 ## either may appear first.
+## @seealso{median,mode}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute arithmetic, geometric, and harmonic mean
 
 function y = mean (x, opt1, opt2)
 
   need_dim = 0;
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -14,17 +14,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} median (@var{x}, @var{dim})
+## @deftypefn  {Function File} {} median (@var{x})
+## @deftypefnx {Function File} {} median (@var{x}, @var{dim})
 ## If @var{x} is a vector, compute the median value of the elements of
 ## @var{x}.  If the elements of @var{x} are sorted, the median is defined
 ## as
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
@@ -38,17 +39,17 @@
 ## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
 ## @end example
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.  If the optional @var{dim}
 ## argument is given, operate along this dimension.
-## @seealso{std, mean}
+## @seealso{mean,mode}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = median (a, dim)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -12,26 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{m}, @var{f}, @var{c}] =} mode (@var{x}, @var{dim})
-## Count the most frequently appearing value.  @code{mode} counts the 
-## frequency along the first non-singleton dimension and if two or more
-## values have the same frequency returns the smallest of the two in
-## @var{m}.  The dimension along which to count can be specified by the
-## @var{dim} parameter.
+## @deftypefn  {Function File} {} mode (@var{x})
+## @deftypefnx {Function File} {} mode (@var{x}, @var{dim})
+## @deftypefnx {Function File} {[@var{m}, @var{f}, @var{c}] =} mode (@dots{})
+## Compute the most frequently occurring value in a dataset (mode).  
+## @code{mode} determines the frequency of values along the first non-singleton
+## dimension and returns the value with the highest frequency.  If two, or 
+## more, values have the same frequency @code{mode} returns the smallest.
+## 
+## If the optional argument @var{dim} is supplied, work along dimension
+## @var{dim}.
 ##
-## The variable @var{f} counts the frequency of each of the most frequently 
-## occurring elements.  The cell array @var{c} contains all of the elements
-## with the maximum frequency .
+## The return variable @var{f} is the number of occurrences of the mode in
+## in the dataset.  The cell array @var{c} contains all of the elements
+## with the maximum frequency.
+## @seealso{mean,median}
 ## @end deftypefn
 
 function [m, f, c] = mode (x, dim)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[@var{beta}, @var{sigma}, @var{r}] =} ols (@var{y}, @var{x})
 ## Ordinary least squares estimation for the multivariate model
 ## @tex
 ## $y = x b + e$
 ## with
 ## $\bar{e} = 0$, and cov(vec($e$)) = kron ($s, I$)
 ## @end tex
 ## @ifnottex
-## @math{y = x b + e} with
+## @w{@math{y = x*b + e}} with
 ## @math{mean (e) = 0} and @math{cov (vec (e)) = kron (s, I)}.
 ## @end ifnottex
 ##  where
 ## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix,
 ## $b$ is a $k \times p$ matrix, and $e$ is a $t \times p$ matrix.
 ## @end tex
 ## @ifnottex
@@ -59,18 +59,17 @@
 ## @group
 ## @var{sigma} = (@var{y}-@var{x}*@var{beta})'
 ##   * (@var{y}-@var{x}*@var{beta})
 ##   / (@var{t}-rank(@var{x}))
 ## @end group
 ## @end example
 ##
 ## @item r
-## The matrix of OLS residuals, @code{@var{r} = @var{y} - @var{x} *
-## @var{beta}}.
+## The matrix of OLS residuals, @code{@var{r} = @var{y} - @var{x}*@var{beta}}.
 ## @end table
 ## @end deftypefn
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, SIGMA, R] = ols (Y, X)
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ranks (@var{x}, @var{dim})
 ## Return the ranks of @var{x} along the first non-singleton dimension
-## adjust for ties.  If the optional argument @var{dim} is
+## adjusted for ties.  If the optional argument @var{dim} is
 ## given, operate along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute ranks
 
 ## This code was rather ugly, since it didn't use sort due to the
 ## fact of how to deal with ties. Now it does use sort and its
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -51,24 +51,24 @@ function cdf = kolmogorov_smirnov_cdf (x
 
   if (nargin == 1)
     if (isa (x, "single"))
       tol = eps ("single");
     else
       tol = eps;
     endif
   else
-    if (! isscalar (tol) || ! (tol > 0))
-      error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
+    if (! (isscalar (tol) && (tol > 0)))
+      error ("kolmogorov_smirnov_cdf: tol must be a positive scalar");
     endif
   endif
 
   n = numel (x);
   if (n == 0)
-    error ("kolmogorov_smirnov_cdf: x must not be empty");
+    error ("kolmogorov_smirnov_cdf: X must not be empty");
   endif
 
   cdf = zeros (size (x));
 
   ind = find (x > 0);
   if (length (ind) > 0)
     if (size(ind,2) < size(ind,1))
       y = x(ind.');
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -16,26 +16,26 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wblpdf (@var{x}, @var{scale}, @var{shape})
 ## Compute the probability density function (PDF) at @var{x} of the
 ## Weibull distribution with shape parameter @var{scale} and scale
 ## parameter @var{shape} which is given by
-##
 ## @tex
 ## $$  scale \cdot shape^{-scale} x^{scale-1} \exp(-(x/shape)^{scale}) $$
 ## @end tex
 ## @ifnottex
+##
 ## @example
 ##    scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)
 ## @end example
+##
 ## @end ifnottex
-##
 ## @noindent
 ## for @var{x} > 0.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Weibull distribution
 
 function pdf = wblpdf (x, scale, shape)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,15 @@
+2010-06-08  Rik <octave@nomad.inbox5.com>
+
+        * DLD-FUNCTIONS/bsxfun.cc, DLD-FUNCTIONS/cellfun.cc, 
+        DLD-FUNCTIONS/det.cc, DLD-FUNCTIONS/lookup.cc, DLD-FUNCTIONS/lu.cc, 
+        DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/svd.cc, DLD-FUNCTIONS/tril.cc, 
+        data.cc, ov.cc: Improve documentation string.
+
 2010-06-06  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* data.cc (Frem, Fmod): Specify template arguments of binmap
 	explicitely.
 
 2010-06-02  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/strfind.cc (Fqs_replace): Allow overlapped matches.
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -307,17 +307,17 @@ update_index (Array<int>& idx, const dim
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{a}, @var{b})\n\
-Applies a binary function @var{f} element-wise to two matrix arguments\n\
+Applies a binary function @var{f} element-by-element to two matrix arguments\n\
 @var{a} and @var{b}.  The function @var{f} must be capable of accepting\n\
 two column vector arguments of equal length, or one column vector\n\
 argument and a scalar.\n\
 \n\
 The dimensions of @var{a} and @var{b} must be equal or singleton.  The\n\
 singleton dimensions of the matrices will be expanded to the same\n\
 dimensionality as the other matrix.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -88,17 +88,17 @@ get_output_list (octave_idx_type count, 
         tmp.clear ();
     }
 
   return tmp;
 }
 
 DEFUN_DLD (cellfun, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} cellfun (@var{name}, @var{c})\n\
+@deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{c})\n\
 @deftypefnx {Loadable Function} {} cellfun (\"size\", @var{c}, @var{k})\n\
 @deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{c}, @var{class})\n\
 @deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{c})\n\
 @deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{c}, @var{d})\n\
 @deftypefnx {Loadable Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
 @deftypefnx {Loadable Function} {} cellfun (@dots{}, 'ErrorHandler', @var{errfunc})\n\
 @deftypefnx {Loadable Function} {} cellfun (@dots{}, 'UniformOutput', @var{val})\n\
 \n\
@@ -192,17 +192,17 @@ of the element that caused the error.  F
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (@@factorial, @{-1,2@},'ErrorHandler',@@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
-@seealso{isempty, islogical, isreal, length, ndims, numel, size}\n\
+@seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     {
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -45,20 +45,24 @@ along with Octave; see the file COPYING.
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
 DEFUN_DLD (det, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{a})\n\
-Compute the determinant of @var{a} using @sc{lapack} for full and UMFPACK\n\
-for sparse matrices.  Return an estimate of the reciprocal condition number\n\
-if requested.\n\
+@deftypefn  {Loadable Function} {} det (@var{a})\n\
+@deftypefnx {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{a})\n\
+Compute the determinant of @var{a}.\n\
+\n\
+Routines from @sc{lapack} are used for full matrices and code from\n\
+@sc{umfpack} is used for sparse matrices.\n\
+\n\
+Return an estimate of the reciprocal condition number if requested.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -209,27 +209,36 @@ the complexity is O(min(M*log(N),M+N)).\
 \n\
 @var{table} and @var{y} can also be cell arrays of strings\n\
 (or @var{y} can be a single string).  In this case, string lookup\n\
 is performed using lexicographical comparison.\n\
 \n\
 If @var{opts} is specified, it shall be a string with letters indicating\n\
 additional options.\n\
 \n\
-If 'm' is specified as option, @code{table(idx(i)) == val(i)} if @code{val(i)}\n\
+@table @code\n\
+@item m\n\
+@code{table(idx(i)) == val(i)} if @code{val(i)}\n\
 occurs in table; otherwise, @code{idx(i)} is zero.\n\
-If 'b' is specified, then @code{idx(i)} is a logical 1 or 0, indicating whether\n\
+@item b\n\
+@code{idx(i)} is a logical 1 or 0, indicating whether\n\
 @code{val(i)} is contained in table or not.\n\
 \n\
-For numeric lookup, 'l' in @var{opts} indicates that\n\
+@item l\n\
+For numeric lookups\n\
 the leftmost subinterval shall be extended to infinity (i.e., all indices\n\
-at least 1), and 'r' indicates that the rightmost subinterval shall be\n\
-extended to infinity (i.e., all indices at most n-1).\n\
+at least 1)\n\
+@item r\n\
+For numeric lookups\n\
+the rightmost subinterval shall be extended to infinity (i.e., all indices\n\
+at most n-1).\n\
 \n\
-For string lookup, 'i' indicates case-insensitive comparison.\n\
+@item i\n\
+For string lookups, use case-insensitive comparison.\n\
+@end table\n\
 @end deftypefn") 
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3 || (nargin == 3 && ! args(2).is_string ()))
     {
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -59,17 +59,18 @@ get_lu_u (const base_lu<MT>& fact)
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
 DEFUN_DLD (lu, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})\n\
+@deftypefn  {Loadable Function} {[@var{l}, @var{u}] =} lu (@var{a})\n\
+@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}, @var{r}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{s}, @var{thres})\n\
 @deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, 'vector')\n\
 @cindex LU decomposition\n\
 Compute the LU decomposition of @var{a}.  If @var{a} is full subroutines from\n\
 @sc{lapack} are used and if @var{a} is sparse then UMFPACK is used.  The\n\
@@ -128,17 +129,17 @@ Given the string argument 'vector', @dfn
 (@var{p},:) = @var{l} * @var{u}}, and @code{@var{r}(@var{p},:) * @var{a}\n\
 (:, @var{q}) = @var{l} * @var{u}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
 With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
 routines is returned.  If the input matrix is sparse then the matrix @var{l}\n\
 is embedded into @var{u} to give a return value similar to the full case.\n\
-For both full and sparse matrices, @dfn{lu} looses the permutation\n\
+For both full and sparse matrices, @dfn{lu} loses the permutation\n\
 information.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
   bool scale = (nargout  == 5);
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -306,17 +306,17 @@ do_rand (const octave_value_list& args, 
         }
     }
   else
     return octave_rand::nd_array (dims);
 }
 
 DEFUN_DLD (rand, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} rand (@var{x})\n\
+@deftypefn  {Loadable Function} {} rand (@var{x})\n\
 @deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", @var{x})\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
 for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the\n\
@@ -466,21 +466,21 @@ static std::string current_distribution 
 static void
 reset_rand_generator (void)
 {
   octave_rand::distribution (current_distribution);
 }
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} randn (@var{x})\n\
+@deftypefn  {Loadable Function} {} randn (@var{x})\n\
 @deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", @var{x})\n\
-Return a matrix with normally distributed pseudo-random\n\
+Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique'' to\n\
 transform from a uniform to a normal distribution.  (G. Marsaglia and\n\
 W.W. Tsang, @cite{Ziggurat method for generating random variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
@@ -539,17 +539,17 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.02);
 %!   assert(skewness(x),0,0.02);
 %!   assert(kurtosis(x),0,0.04);
 %! endif
 */
 
 DEFUN_DLD (rande, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} rande (@var{x})\n\
+@deftypefn  {Loadable Function} {} rande (@var{x})\n\
 @deftypefnx {Loadable Function} {} rande (@var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", @var{x})\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique'' to\n\
 transform from a uniform to a exponential distribution.  (G. Marsaglia and\n\
@@ -612,17 +612,17 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(var(x),1,0.03);
 %!   assert(skewness(x),2,0.06);
 %!   assert(kurtosis(x),6,0.7);
 %! endif
 */
 
 DEFUN_DLD (randg, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} randg (@var{a}, @var{x})\n\
+@deftypefn  {Loadable Function} {} randg (@var{a}, @var{x})\n\
 @deftypefnx {Loadable Function} {} randg (@var{a}, @var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{x})\n\
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
@@ -862,21 +862,22 @@ r = r / sum (r)\n\
 %!   assert(skewness(x),2/sqrt(a), 0.05);
 %!   assert(kurtosis(x),6/a,       0.2);
 %! endif
 */
 
 
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} randp (@var{l}, @var{x})\n\
+@deftypefn  {Loadable Function} {} randp (@var{l}, @var{x})\n\
 @deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", @var{x})\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", @var{x})\n\
-Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, @var{l}.  The arguments\n\
+Return a matrix with Poisson distributed random elements with mean value\n\
+parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
 \n\
 @table @asis\n\
 @item For scalar @var{l} <= 12, use direct method.\n\
@@ -1008,17 +1009,17 @@ D 50 p1284, 1994\n\
 %!     assert(skewness(x),1/sqrt(a(1)),a(3));
 %!     assert(kurtosis(x),1/a(1),3*a(3));
 %!   endfor
 %! endif
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} randperm (@var{n})\n\
+@deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} permutations,\n\
 one in each row of a NxM matrix.  The complexity is O(M*N) in both time and\n\
 memory.  The randomization is performed using rand().\n\
 All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -37,34 +37,35 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
 DEFUN_DLD (svd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} svd (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{s} =} svd (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a})\n\
+@deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a}, @var{econ})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{a}\n\
 @tex\n\
 $$\n\
  A = U S V^H\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A = U*S*V'\n\
 @end example\n\
 @end ifnottex\n\
 \n\
-The function @code{svd} normally returns the vector of singular values.\n\
-If asked for three return values, it computes\n\
+The function @code{svd} normally returns only the vector of singular values.\n\
+When called with three return values, it computes\n\
 @tex\n\
 $U$, $S$, and $V$.\n\
 @end tex\n\
 @ifnottex\n\
 U, S, and V.\n\
 @end ifnottex\n\
 For example,\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -334,17 +334,21 @@ do_trilu (const std::string& name,
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (tril, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {} tril (@var{a}, @var{k}, @var{pack})\n\
+@deftypefn  {Function File} {} tril (@var{a})\n\
+@deftypefnx {Function File} {} tril (@var{a}, @var{k})\n\
+@deftypefnx {Function File} {} tril (@var{a}, @var{k}, @var{pack})\n\
+@deftypefnx {Function File} {} triu (@var{a})\n\
+@deftypefnx {Function File} {} triu (@var{a}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{a}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting extract the lower (@code{tril})\n\
 or upper (@code{triu}) triangular part of the matrix @var{a}, and\n\
 setting all other elements to zero.  The second argument is optional,\n\
 and specifies how many diagonals above or below the main diagonal should\n\
 also be set to zero.\n\
 \n\
 The default value of @var{k} is zero, so that @code{triu} and\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1869,17 +1869,17 @@ returns the original array @var{a}.\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
-Return the `length' of the object @var{a}.  For matrix objects, the\n\
+Return the \"length\" of the object @var{a}.  For matrix objects, the\n\
 length is the number of rows or columns, whichever is greater (this\n\
 odd definition is used for compatibility with @sc{matlab}).\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).length ();
@@ -1887,36 +1887,40 @@ odd definition is used for compatibility
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
-Returns the number of dimensions of array @var{a}.\n\
+Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
+@example\n\
+  ndims (ones (4, 1, 2, 1)\n\
+     @result{} 3\n\
+@end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).ndims ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (numel, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} numel (@var{a})\n\
+@deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
-Returns the number of elements in the object @var{a}.\n\
+Return the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 @example\n\
   @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
 This method is also called when an object appears as lvalue with cs-list\n\
 indexing, i.e., @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
 @seealso{size}\n\
@@ -1936,17 +1940,18 @@ indexing, i.e., @code{object@{@dots{}@}}
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} size (@var{a}, @var{n})\n\
+@deftypefn  {Built-in Function} {} size (@var{a})\n\
+@deftypefnx {Built-in Function} {} size (@var{a}, @var{dim})\n\
 Return the number rows and columns of @var{a}.\n\
 \n\
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
 etc.  For example,\n\
 \n\
 @example\n\
@@ -2100,34 +2105,34 @@ but in general they will give the same r
 
   return retval;
 }
 
 DEFUN (rows, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
-@seealso{size, numel, columns, length, isscalar, isvector, ismatrix}\n\
+@seealso{columns, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).rows ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
-@seealso{size, numel, rows, length, isscalar, isvector, ismatrix}\n\
+@seealso{rows, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).columns ();
   else
     print_usage ();
@@ -3282,39 +3287,40 @@ fill_matrix (const octave_value_list& ar
         retval = boolNDArray (dims, val);
     }
 
   return retval;
 }
 
 DEFUN (ones, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} ones (@var{x})\n\
+@deftypefn  {Built-in Function} {} ones (@var{x})\n\
 @deftypefnx {Built-in Function} {} ones (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} ones (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 1.\n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
 given dimensions.\n\
 \n\
 If you need to create a matrix whose values are all the same, you should\n\
 use an expression like\n\
 \n\
 @example\n\
 val_matrix = val * ones (n, m)\n\
 @end example\n\
 \n\
-The optional argument @var{class}, allows @code{ones} to return an array of\n\
-the specified type, for example\n\
+The optional argument @var{class} specifies the class of the return array\n\
+and defaults to double.  For example\n\
 \n\
 @example\n\
 val = ones (n,m, \"uint8\")\n\
 @end example\n\
+@seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
 /*
 
 %!assert(ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1]);
@@ -3331,29 +3337,33 @@ val = ones (n,m, \"uint8\")\n\
 %!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
 %!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
 %!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} zeros (@var{x})\n\
+@deftypefn  {Built-in Function} {} zeros (@var{x})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
-The arguments are handled the same as the arguments for @code{ones}.\n\
+If invoked with a single scalar integer argument, return a square\n\
+matrix of the specified size.  If invoked with two or more scalar\n\
+integer arguments, or a vector of integer values, return an array with\n\
+given dimensions.\n\
 \n\
-The optional argument @var{class}, allows @code{zeros} to return an array of\n\
-the specified type, for example\n\
+The optional argument @var{class} specifies the class of the return array\n\
+and defaults to double.  For example\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
+@seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
 /*
 
 %!assert(zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0]);
@@ -3809,33 +3819,41 @@ either \"double\" or \"single\".\n\
 
 %!assert(single(NA('double')),NA('single'))
 %!assert(double(NA('single')),NA('double'))
 
  */
 
 DEFUN (false, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} false (@var{x})\n\
+@deftypefn  {Built-in Function} {} false (@var{x})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
-The arguments are handled the same as the arguments for @code{ones}.\n\
+If invoked with a single scalar integer argument, return a square\n\
+matrix of the specified size.  If invoked with two or more scalar\n\
+integer arguments, or a vector of integer values, return an array with\n\
+given dimensions.\n\
+@seealso{true}\n\
 @end deftypefn")
 {
   return fill_matrix (args, false, "false");
 }
 
 DEFUN (true, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} true (@var{x})\n\
+@deftypefn  {Built-in Function} {} true (@var{x})\n\
 @deftypefnx {Built-in Function} {} true (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} true (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 1.\n\
-The arguments are handled the same as the arguments for @code{ones}.\n\
+If invoked with a single scalar integer argument, return a square\n\
+matrix of the specified size.  If invoked with two or more scalar\n\
+integer arguments, or a vector of integer values, return an array with\n\
+given dimensions.\n\
+@seealso{false}\n\
 @end deftypefn")
 {
   return fill_matrix (args, true, "true");
 }
 
 template <class MT>
 octave_value
 identity_matrix (int nr, int nc)
@@ -4447,17 +4465,19 @@ DEFUN (full, args, ,
 
   return retval;
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} norm (@var{a}, @var{p}, @var{opt})\n\
+@deftypefn  {Built-in Function} {} norm (@var{a})\n\
+@deftypefnx {Built-in Function} {} norm (@var{a}, @var{p})\n\
+@deftypefnx {Built-in Function} {} norm (@var{a}, @var{p}, @var{opt})\n\
 Compute the p-norm of the matrix @var{a}.  If the second argument is\n\
 missing, @code{p = 2} is assumed.\n\
 \n\
 If @var{a} is a matrix (or sparse matrix):\n\
 \n\
 @table @asis\n\
 @item @var{p} = @code{1}\n\
 1-norm, the largest column sum of the absolute values of @var{a}.\n\
@@ -4495,19 +4515,20 @@ Hamming norm - the number of nonzero ele
 \n\
 @item other @var{p}, @code{@var{p} > 1}\n\
 p-norm of @var{a}, @code{(sum (abs (@var{a}) .^ @var{p})) ^ (1/@var{p})}.\n\
 \n\
 @item other @var{p} @code{@var{p} < 1}\n\
 the p-pseudonorm defined as above.\n\
 @end table\n\
 \n\
-If @code{\"rows\"} is given as @var{opt}, the norms of all rows of the matrix @var{a} are\n\
-returned as a column vector.  Similarly, if @code{\"columns\"} or @code{\"cols\"} is passed\n\
-column norms are computed.\n\
+If @var{opt} is the value @code{\"rows\"}, treat each row as a vector and\n\
+compute its norm.  The result is returned as a column vector.\n\
+Similarly, if @var{opt} is @code{\"columns\"} or @code{\"cols\"} then compute\n\
+the norms of each column and return a row vector.\n\
 @seealso{cond, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2667,17 +2667,18 @@ Convert @var{val} to the new data type @
 
   return retval;
 }
 #endif
 
 DEFUN (sizeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
-Return the size of @var{val} in bytes\n\
+Return the size of @var{val} in bytes.\n\
+@seealso{whos}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).byte_size ();
   else
     print_usage ();
