# HG changeset patch
# User Rik <rik@octave.org>
# Date 1472618807 25200
#      Tue Aug 30 21:46:47 2016 -0700
# Node ID 34ce5be0494233fa148fd3d8f20b9f1b3101bbcf
# Parent  dc4e2203cd159a0e2a1c7f8f4e6ab2ad426abcf8
maint: Style check C++ code in libinterp/.

* build-env.h, build-env.in.cc, builtins.h, Cell.cc, Cell.h, __contourc__.cc,
__dispatch__.cc, __dsearchn__.cc, __ilu__.cc, __lin_interpn__.cc, __luinc__.cc,
__magick_read__.cc, __pchip_deriv__.cc, __qp__.cc, balance.cc,
base-text-renderer.h, besselj.cc, bitfcns.cc, bsxfun.cc, c-file-ptr-stream.cc,
c-file-ptr-stream.h, call-stack.cc, call-stack.h, cdisplay.c, cdisplay.h,
cellfun.cc, coct-hdf5-types.c, comment-list.cc, comment-list.h, conv2.cc,
daspk.cc, dasrt.cc, dassl.cc, data.cc, data.h, debug.cc, debug.h, defaults.cc,
defaults.in.h, defun-dld.h, defun-int.h, defun.h, det.cc, dirfns.cc, dirfns.h,
display.cc, display.h, dlmread.cc, dynamic-ld.cc, dynamic-ld.h, eig.cc,
error.cc, error.h, errwarn.h, event-queue.cc, event-queue.h, fft.cc, fft2.cc,
fftn.cc, file-io.cc, file-io.h, filter.cc, find.cc, ft-text-renderer.cc,
ft-text-renderer.h, gammainc.cc, gcd.cc, getgrent.cc, getpwent.cc, givens.cc,
gl-render.cc, gl-render.h, gl2ps-print.cc, gl2ps-print.h, graphics.cc,
graphics.in.h, gripes.h, gsvd.cc, hash.cc, help.cc, help.h, hess.cc,
hex2num.cc, hook-fcn.cc, hook-fcn.h, input.cc, input.h, interpreter.cc,
interpreter.h, inv.cc, jit-ir.cc, jit-ir.h, jit-typeinfo.cc, jit-typeinfo.h,
jit-util.cc, jit-util.h, kron.cc, load-path.cc, load-path.h, load-save.cc,
load-save.h, lookup.cc, ls-ascii-helper.cc, ls-ascii-helper.h, ls-hdf5.cc,
ls-hdf5.h, ls-mat-ascii.cc, ls-mat-ascii.h, ls-mat4.cc, ls-mat4.h, ls-mat5.h,
ls-oct-binary.cc, ls-oct-binary.h, ls-oct-text.cc, ls-oct-text.h, ls-utils.cc,
ls-utils.h, lsode.cc, lu.cc, matrix_type.cc, max.cc, mex.cc, mex.h, mexproto.h,
mgorth.cc, mxarray.in.h, nproc.cc, oct-errno.h, oct-errno.in.cc, oct-fstrm.cc,
oct-fstrm.h, oct-handle.h, oct-hdf5-types.cc, oct-hdf5-types.h, oct-hdf5.h,
oct-hist.cc, oct-hist.h, oct-iostrm.cc, oct-iostrm.h, oct-lvalue.cc,
oct-lvalue.h, oct-map.h, oct-obj.h, oct-opengl.h, oct-prcstrm.cc,
oct-prcstrm.h, oct-procbuf.cc, oct-procbuf.h, oct-stdstrm.h, oct-stream.cc,
oct-stream.h, oct-strstrm.cc, oct-strstrm.h, oct.h, octave-default-image.h,
octave-link.h, octave-preserve-stream-state.h, ordschur.cc, pager.cc, pager.h,
pinv.cc, pr-output.cc, pr-output.h, procstream.cc, procstream.h, profiler.h,
psi.cc, pt-jit.cc, pt-jit.h, quad.cc, quadcc.cc, qz.cc, rand.cc, rcond.cc,
regexp.cc, schur.cc, sighandlers.cc, sighandlers.h, sparse-xdiv.cc,
sparse-xdiv.h, sparse-xpow.cc, sparse-xpow.h, sparse.cc, spparms.cc, sqrtm.cc,
str2double.cc, strfind.cc, strfns.cc, sub2ind.cc, svd.cc, sylvester.cc,
symtab.cc, symtab.h, syscalls.cc, sysdep.cc, sysdep.h, text-renderer.cc,
text-renderer.h, time.cc, toplev.cc, toplev.h, tril.cc, tsearch.cc, txt-eng.cc,
txt-eng.h, typecast.cc, urlwrite.cc, utils.cc, utils.h, variables.cc,
variables.h, workspace-element.h, xdiv.cc, xdiv.h, xnorm.cc, xnorm.h, xpow.cc,
xpow.h, zfstream.cc, zfstream.h, deprecated-config.h, __delaunayn__.cc,
__eigs__.cc, __fltk_uigetfile__.cc, __glpk__.cc, __init_fltk__.cc,
__init_gnuplot__.cc, __osmesa_print__.cc, __voronoi__.cc, amd.cc,
audiodevinfo.cc, audioread.cc, ccolamd.cc, chol.cc, colamd.cc, convhulln.cc,
dmperm.cc, fftw.cc, gzip.cc, oct-qhull.h, qr.cc, symbfact.cc, symrcm.cc,
liboctinterp-build-info.h, liboctinterp-build-info.in.cc, ov-base-diag.h,
ov-base-int.cc, ov-base-int.h, ov-base-mat.cc, ov-base-mat.h, ov-base-scalar.h,
ov-base-sparse.cc, ov-base-sparse.h, ov-base.cc, ov-base.h, ov-bool-mat.cc,
ov-bool-mat.h, ov-bool-sparse.cc, ov-bool-sparse.h, ov-bool.cc, ov-bool.h,
ov-builtin.cc, ov-builtin.h, ov-cell.cc, ov-cell.h, ov-ch-mat.cc, ov-ch-mat.h,
ov-class.cc, ov-class.h, ov-classdef.cc, ov-classdef.h, ov-colon.cc,
ov-colon.h, ov-complex.cc, ov-complex.h, ov-cs-list.h, ov-cx-diag.cc,
ov-cx-diag.h, ov-cx-mat.cc, ov-cx-mat.h, ov-cx-sparse.cc, ov-cx-sparse.h,
ov-dld-fcn.cc, ov-dld-fcn.h, ov-fcn-handle.cc, ov-fcn-handle.h,
ov-fcn-inline.cc, ov-fcn-inline.h, ov-fcn.cc, ov-fcn.h, ov-float.cc,
ov-float.h, ov-flt-complex.cc, ov-flt-complex.h, ov-flt-cx-diag.cc,
ov-flt-cx-diag.h, ov-flt-cx-mat.cc, ov-flt-cx-mat.h, ov-flt-re-diag.cc,
ov-flt-re-diag.h, ov-flt-re-mat.cc, ov-flt-re-mat.h, ov-int-traits.h,
ov-int16.cc, ov-int16.h, ov-int32.cc, ov-int32.h, ov-int64.cc, ov-int64.h,
ov-int8.cc, ov-int8.h, ov-intx.h, ov-java.cc, ov-java.h, ov-lazy-idx.cc,
ov-lazy-idx.h, ov-mex-fcn.cc, ov-mex-fcn.h, ov-null-mat.cc, ov-null-mat.h,
ov-oncleanup.cc, ov-oncleanup.h, ov-perm.cc, ov-perm.h, ov-range.cc,
ov-range.h, ov-re-diag.cc, ov-re-diag.h, ov-re-mat.cc, ov-re-mat.h,
ov-re-sparse.cc, ov-re-sparse.h, ov-scalar.cc, ov-scalar.h, ov-str-mat.cc,
ov-str-mat.h, ov-struct.cc, ov-struct.h, ov-typeinfo.cc, ov-typeinfo.h,
ov-uint16.cc, ov-uint16.h, ov-uint32.cc, ov-uint32.h, ov-uint64.cc,
ov-uint64.h, ov-uint8.cc, ov-uint8.h, ov-usr-fcn.cc, ov-usr-fcn.h, ov.h,
ovl.cc, ovl.h, octave.cc, octave.h, op-b-b.cc, op-b-bm.cc, op-b-sbm.cc,
op-bm-b.cc, op-bm-bm.cc, op-bm-sbm.cc, op-cdm-cdm.cc, op-cell.cc, op-chm.cc,
op-class.cc, op-cm-cm.cc, op-cm-cs.cc, op-cm-m.cc, op-cm-pm.cc, op-cm-s.cc,
op-cm-scm.cc, op-cm-sm.cc, op-cs-cm.cc, op-cs-cs.cc, op-cs-m.cc, op-cs-s.cc,
op-cs-scm.cc, op-cs-sm.cc, op-dm-dm.cc, op-dm-scm.cc, op-dm-sm.cc,
op-dm-template.cc, op-dms-template.cc, op-fcdm-fcdm.cc, op-fcm-fcm.cc,
op-fcm-fcs.cc, op-fcm-fm.cc, op-fcm-fs.cc, op-fcm-pm.cc, op-fcn.cc,
op-fcs-fcm.cc, op-fcs-fcs.cc, op-fcs-fm.cc, op-fcs-fs.cc, op-fdm-fdm.cc,
op-fm-fcm.cc, op-fm-fcs.cc, op-fm-fm.cc, op-fm-fs.cc, op-fm-pm.cc,
op-fs-fcm.cc, op-fs-fcs.cc, op-fs-fm.cc, op-fs-fs.cc, op-i16-i16.cc,
op-i32-i32.cc, op-i64-i64.cc, op-i8-i8.cc, op-int-concat.cc, op-int.h,
op-m-cm.cc, op-m-cs.cc, op-m-m.cc, op-m-pm.cc, op-m-s.cc, op-m-scm.cc,
op-m-sm.cc, op-pm-cm.cc, op-pm-fcm.cc, op-pm-fm.cc, op-pm-m.cc, op-pm-pm.cc,
op-pm-scm.cc, op-pm-sm.cc, op-pm-template.cc, op-range.cc, op-s-cm.cc,
op-s-cs.cc, op-s-m.cc, op-s-s.cc, op-s-scm.cc, op-s-sm.cc, op-sbm-b.cc,
op-sbm-bm.cc, op-sbm-sbm.cc, op-scm-cm.cc, op-scm-cs.cc, op-scm-m.cc,
op-scm-s.cc, op-scm-scm.cc, op-scm-sm.cc, op-sm-cm.cc, op-sm-cs.cc, op-sm-m.cc,
op-sm-s.cc, op-sm-scm.cc, op-sm-sm.cc, op-str-m.cc, op-str-s.cc, op-str-str.cc,
op-struct.cc, op-ui16-ui16.cc, op-ui32-ui32.cc, op-ui64-ui64.cc, op-ui8-ui8.cc,
ops.h, options-usage.h, lex.h, parse.h, pt-all.h, pt-arg-list.cc,
pt-arg-list.h, pt-array-list.h, pt-assign.cc, pt-assign.h, pt-binop.cc,
pt-binop.h, pt-bp.cc, pt-bp.h, pt-cbinop.cc, pt-cbinop.h, pt-cell.cc,
pt-cell.h, pt-check.cc, pt-check.h, pt-classdef.cc, pt-classdef.h, pt-cmd.cc,
pt-cmd.h, pt-colon.cc, pt-colon.h, pt-const.cc, pt-const.h, pt-decl.cc,
pt-decl.h, pt-eval.cc, pt-eval.h, pt-except.cc, pt-except.h, pt-exp.cc,
pt-exp.h, pt-fcn-handle.cc, pt-fcn-handle.h, pt-funcall.cc, pt-funcall.h,
pt-id.cc, pt-id.h, pt-idx.cc, pt-idx.h, pt-jump.cc, pt-jump.h, pt-loop.cc,
pt-loop.h, pt-mat.cc, pt-mat.h, pt-misc.cc, pt-misc.h, pt-pr-code.cc,
pt-pr-code.h, pt-select.cc, pt-select.h, pt-stmt.cc, pt-stmt.h, pt-unop.cc,
pt-unop.h, pt-walk.h, pt.cc, pt.h, token.cc, token.h, Array-jit.cc,
Array-tc.cc, version.cc, version.in.h:
Style check C++ code in libinterp/

diff --git a/libinterp/build-env.h b/libinterp/build-env.h
--- a/libinterp/build-env.h
+++ b/libinterp/build-env.h
@@ -169,8 +169,9 @@ namespace octave
     extern const char *Z_CPPFLAGS;
     extern const char *Z_LDFLAGS;
     extern const char *Z_LIBS;
     extern const char *config_opts;
   };
 };
 
 #endif
+
diff --git a/libinterp/build-env.in.cc b/libinterp/build-env.in.cc
--- a/libinterp/build-env.in.cc
+++ b/libinterp/build-env.in.cc
@@ -301,8 +301,9 @@ namespace octave
 
     const char *Z_LDFLAGS = %OCTAVE_CONF_Z_LDFLAGS%;
 
     const char *Z_LIBS = %OCTAVE_CONF_Z_LIBS%;
 
     const char *config_opts = %OCTAVE_CONF_config_opts%;
   };
 };
+
diff --git a/libinterp/builtins.h b/libinterp/builtins.h
--- a/libinterp/builtins.h
+++ b/libinterp/builtins.h
@@ -25,8 +25,9 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "builtin-defun-decls.h"
 
 extern OCTINTERP_API void install_builtins (void);
 
 #endif
+
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -255,21 +255,21 @@ Cell::delete_elements (const octave_valu
   Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     try
       {
         ra_idx.xelem (i) = idx_arg(i).index_vector ();
       }
     catch (octave::index_exception& e)
-        {
-          // Rethrow to allow more info to be reported later.
-          e.set_pos (len, i+1);
-          throw;
-        }
+      {
+        // Rethrow to allow more info to be reported later.
+        e.set_pos (len, i+1);
+        throw;
+      }
 
   Array<octave_value>::delete_elements (ra_idx);
 }
 
 octave_idx_type
 Cell::nnz (void) const
 {
   err_wrong_type_arg ("nnz", "cell array");
@@ -349,8 +349,9 @@ Cell::diag (octave_idx_type k) const
   return Array<octave_value>::diag (k);
 }
 
 Cell
 Cell::diag (octave_idx_type m, octave_idx_type n) const
 {
   return Array<octave_value>::diag (m, n);
 }
+
diff --git a/libinterp/corefcn/Cell.h b/libinterp/corefcn/Cell.h
--- a/libinterp/corefcn/Cell.h
+++ b/libinterp/corefcn/Cell.h
@@ -140,8 +140,9 @@ private:
   Cell map (ctype_mapper) const;
 };
 
 template <>
 inline Cell octave_value_extract<Cell> (const octave_value& v)
 { return v.cell_value (); }
 
 #endif
+
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -321,8 +321,9 @@ Undocumented internal function.
 
   return octave_value (contourc);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -105,8 +105,9 @@ Undocumented internal function.
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -94,8 +94,9 @@ Undocumented internal function.
 
   return ovl (idx, dist);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -521,18 +521,18 @@ Undocumented internal function.
       SparseComplexMatrix sm_l =
         feval ("tril", arg_list)(0).sparse_complex_matrix_value ();
       arg_list(1) = "rows";
       rows_norm = feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list(1) = "cols";
       cols_norm = feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list.clear ();
       SparseComplexMatrix U, L;
-      ilu_crout < SparseComplexMatrix, Complex >
-                (sm_l, sm_u, L, U, cols_norm.fortran_vec () ,
+      ilu_crout <SparseComplexMatrix, Complex>
+                (sm_l, sm_u, L, U, cols_norm.fortran_vec (),
                  rows_norm.fortran_vec (), Complex (droptol), milu);
 
       arg_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
         feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
       return ovl (L + eye, U);
     }
 }
@@ -582,17 +582,17 @@ void ilu_tp (octave_matrix_t& sm, octave
   max_len_l = nnz_l;
   max_len_l += (0.1 * max_len_l) > n ? 0.1 * max_len_l : n;
 
   // Extract pointers to the arrays for faster access inside loops
   Array <octave_idx_type> cidx_out_l (dim_vector (n + 1, 1));
   octave_idx_type* cidx_l = cidx_out_l.fortran_vec ();
   Array <octave_idx_type> ridx_out_l (dim_vector (max_len_l, 1));
   octave_idx_type* ridx_l = ridx_out_l.fortran_vec ();
-  Array <T> data_out_l (dim_vector (max_len_l ,1));
+  Array <T> data_out_l (dim_vector (max_len_l, 1));
   T* data_l = data_out_l.fortran_vec ();
 
   // Data for U
   Array <octave_idx_type> cidx_out_u (dim_vector (n + 1, 1));
   octave_idx_type* cidx_u = cidx_out_u.fortran_vec ();
   Array <octave_idx_type> ridx_out_u (dim_vector (max_len_u, 1));
   octave_idx_type* ridx_u = ridx_out_u.fortran_vec ();
   Array <T> data_out_u (dim_vector (max_len_u, 1));
@@ -1022,17 +1022,17 @@ Undocumented internal function.
       if (milu == "row")
         arg_list(1) = "rows";
       else
         arg_list(1) = "cols";
       rc_norm = feval ("norm", arg_list)(0).complex_vector_value ();
       arg_list.clear ();
       Array <octave_idx_type> perm (dim_vector (sm.cols (), 1));
       SparseComplexMatrix U, L;
-      ilu_tp < SparseComplexMatrix, Complex>
+      ilu_tp <SparseComplexMatrix, Complex>
               (sm, L, U, nnz_u, nnz_l, rc_norm.fortran_vec (), perm,
                Complex (droptol), Complex (thresh), milu, udiag);
 
       arg_list.append (octave_value (L.cols ()));
       SparseComplexMatrix eye =
         feval ("speye", arg_list)(0).sparse_complex_matrix_value ();
       if (milu == "row")
         {
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -313,8 +313,9 @@ Undocumented internal function.
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__luinc__.cc b/libinterp/corefcn/__luinc__.cc
--- a/libinterp/corefcn/__luinc__.cc
+++ b/libinterp/corefcn/__luinc__.cc
@@ -67,17 +67,18 @@ See documentation for @code{luinc}.
     {
       if (args(1).string_value () == "0")
         zero_level = true;
       else
         error ("luinc: unrecognized string argument");
     }
   else if (args(1).is_map ())
     {
-      octave_scalar_map map = args(1).xscalar_map_value ("luinc: OPTS must be a scalar structure");
+      octave_scalar_map map
+        = args(1).xscalar_map_value ("luinc: OPTS must be a scalar structure");
 
       octave_value tmp;
 
       tmp = map.getfield ("droptol");
       if (tmp.is_defined ())
         droptol = tmp.double_value ();
 
       tmp = map.getfield ("milu");
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -756,17 +756,18 @@ Use @code{imread} instead.
 {
 #if defined (HAVE_MAGICK)
 
   if (args.length () != 2 || ! args(0).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
-  const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
+  const octave_scalar_map options
+    = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
 
   octave_value_list output;
 
   std::vector<Magick::Image> imvec;
   read_file (args(0).string_value (), imvec);
 
   // Prepare an Array with the indexes for the requested frames.
   const octave_idx_type nFrames = imvec.size ();
@@ -1402,17 +1403,18 @@ Use @code{imwrite} instead.
   if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
   const std::string filename = args(0).string_value ();
   const std::string ext = args(1).string_value ();
 
-  const octave_scalar_map options = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
+  const octave_scalar_map options
+    = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
 
   const octave_value img = args(2);
   const Matrix cmap = args(3).xmatrix_value ("__magick_write__: invalid MAP");
 
   std::vector<Magick::Image> imvec;
 
   if (cmap.is_empty ())
     {
@@ -1521,17 +1523,18 @@ Use @code{imwrite} instead.
   // LoopCount only on the first image) that value will go nowhere.
   // See https://sourceforge.net/p/graphicsmagick/bugs/248/
   // Because of this, we document to set LoopCount on every iteration
   // (in Matlab will cause a lot of warnings), or pass a 4D matrix with
   // all frames (won't work in Matlab at all).
   // Note that this only needs to be set on the first frame
   imvec[0].animationIterations (options.getfield ("loopcount").uint_value ());
 
-  const std::string compression = options.getfield ("compression").string_value ();
+  const std::string compression
+    = options.getfield ("compression").string_value ();
 
 #define COMPRESS_MAGICK_IMAGE_VECTOR(GM_TYPE)                           \
   for (std::vector<Magick::Image>::size_type i = 0; i < imvec.size (); i++) \
     imvec[i].compressType (GM_TYPE)
 
   if (compression == "none")
     COMPRESS_MAGICK_IMAGE_VECTOR (Magick::NoCompression);
   else if (compression == "bzip")
@@ -1652,30 +1655,31 @@ magick_to_octave_value (const Magick::Co
       return octave_value ("lzw");
     case Magick::RLECompression:
       // This is named "rle" for the HDF, but the same thing is named
       // "ccitt" and "PackBits" for binary and non-binary images in TIFF.
       return octave_value ("rle");
     case Magick::ZipCompression:
       return octave_value ("deflate");
 
-      // The following are present only in recent versions of GraphicsMagick.
-      // At the moment the only use of this would be to have imfinfo report
-      // the compression method.  In the future, someone could implement
-      // the Compression option for imwrite in which case a macro in
-      // configure.ac will have to check for their presence of this.
-      // See bug #39913
-      //      case Magick::LZMACompression:
-      //        return octave_value ("lzma");
-      //      case Magick::JPEG2000Compression:
-      //        return octave_value ("jpeg2000");
-      //      case Magick::JBIG1Compression:
-      //        return octave_value ("jbig1");
-      //      case Magick::JBIG2Compression:
-      //        return octave_value ("jbig2");
+    // The following are present only in recent versions of GraphicsMagick.
+    // At the moment the only use of this would be to have imfinfo report
+    // the compression method.  In the future, someone could implement
+    // the Compression option for imwrite in which case a macro in
+    // configure.ac will have to check for their presence of this.
+    // See bug #39913
+    //      case Magick::LZMACompression:
+    //        return octave_value ("lzma");
+    //      case Magick::JPEG2000Compression:
+    //        return octave_value ("jpeg2000");
+    //      case Magick::JBIG1Compression:
+    //        return octave_value ("jbig1");
+    //      case Magick::JBIG2Compression:
+    //        return octave_value ("jbig2");
+
     default:
       return octave_value ("undefined");
     }
 }
 
 static octave_value
 magick_to_octave_value (const Magick::EndianType& magick)
 {
@@ -1690,17 +1694,17 @@ magick_to_octave_value (const Magick::En
     }
 }
 
 static octave_value
 magick_to_octave_value (const Magick::OrientationType& magick)
 {
   switch (magick)
     {
-      // Values come from the TIFF6 spec
+    // Values come from the TIFF6 spec
     case Magick::TopLeftOrientation:
       return octave_value (1);
     case Magick::TopRightOrientation:
       return octave_value (2);
     case Magick::BottomRightOrientation:
       return octave_value (3);
     case Magick::BottomLeftOrientation:
       return octave_value (4);
@@ -2300,8 +2304,9 @@ Fill formats info with GraphicsMagick Co
 
   return ovl (formats);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -129,8 +129,9 @@ Undocumented internal function.
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -515,8 +515,9 @@ Undocumented internal function.
 
   return ovl (x, lambda, info, iter);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -350,8 +350,9 @@ Generalized eigenvalue problem balancing
                   break;
                 }
             }
         }
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/base-text-renderer.h b/libinterp/corefcn/base-text-renderer.h
--- a/libinterp/corefcn/base-text-renderer.h
+++ b/libinterp/corefcn/base-text-renderer.h
@@ -77,8 +77,9 @@ namespace octave
 
     base_text_renderer (const base_text_renderer&);
 
     base_text_renderer& operator = (const base_text_renderer&);
   };
 }
 
 #endif
+
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -129,18 +129,17 @@ do_bessel (enum bessel_type type, const 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
               retval(0) = result;
               if (nargout > 1)
                 retval(1) = static_cast<float> (ierr);
             }
           else
             {
-              FloatComplexNDArray x
-                = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
+              FloatComplexNDArray x = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
               Array<octave_idx_type> ierr;
               octave_value result;
 
               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
               retval(0) = result;
               if (nargout > 1)
@@ -185,18 +184,17 @@ do_bessel (enum bessel_type type, const 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   retval(0) = result;
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
                 }
               else
                 {
-                  FloatComplexNDArray x
-                    = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
+                  FloatComplexNDArray x = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   retval(0) = result;
                   if (nargout > 1)
@@ -1156,8 +1154,9 @@ Table 10.4 - j and y for various integer
 %!
 %! n = [(0:5:20).';30;40;50;100];
 %! z = [1,2,5,10,50,100];
 %! j = sqrt ((pi/2)./z) .* besselj ((n+1/2).', z.').';
 %! y = sqrt ((pi/2)./z) .* bessely ((n+1/2).', z.').';
 %! assert (j, jt, -1e-9);
 %! assert (y, yt, -1e-9);
 */
+
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -596,17 +596,17 @@ bitshift (10, [-2, -1, 0, 1, 2])
 
       nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
       int64_t mask = max_mantissa_value<double> ();
       if (nbits < bits_in_mantissa)
         mask = mask >> (bits_in_mantissa - nbits);
       else if (nbits < 1)
         mask = 0;
       int bits_in_type = sizeof (double)
-        * std::numeric_limits<unsigned char>::digits;
+                         * std::numeric_limits<unsigned char>::digits;
       NDArray m = m_arg.array_value ();
       DO_BITSHIFT ();
     }
   else if (cname == "uint8")
     DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
   else if (cname == "uint16")
     DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
   else if (cname == "uint32")
@@ -627,17 +627,17 @@ bitshift (10, [-2, -1, 0, 1, 2])
         = std::numeric_limits<float>::digits;
       nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
       int64_t mask = max_mantissa_value<float> ();
       if (nbits < bits_in_mantissa)
         mask = mask >> (bits_in_mantissa - nbits);
       else if (nbits < 1)
         mask = 0;
       int bits_in_type = sizeof (float)
-        * std::numeric_limits<unsigned char>::digits;
+                         * std::numeric_limits<unsigned char>::digits;
       FloatNDArray m = m_arg.float_array_value ();
       DO_BITSHIFT (Float);
     }
   else
     error ("bitshift: not defined for %s objects", cname.c_str ());
 
   return retval;
 }
@@ -890,8 +890,9 @@ by @code{intmax}.
   return octave_value (octave_int<octave_idx_type> (dim_vector::dim_max ()));
 }
 
 /*
 %!assert (sizemax () >= (intmax ("int32") - 1))
 
 %!error sizemax (0)
 */
+
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -816,8 +816,9 @@ dimensionality as the other array.
 
 ## In-place broadcasting with zero length dimensions (bug #47085)
 %!test
 %! a = zeros (0, 3);
 %! a .+= [1 2 3];
 %! assert (a, zeros (0, 3));
 
 */
+
diff --git a/libinterp/corefcn/c-file-ptr-stream.cc b/libinterp/corefcn/c-file-ptr-stream.cc
--- a/libinterp/corefcn/c-file-ptr-stream.cc
+++ b/libinterp/corefcn/c-file-ptr-stream.cc
@@ -309,8 +309,9 @@ c_zfile_ptr_buf::buf_close (void)
       retval = cf (f);
       f = 0;
     }
 
   return retval;
 }
 
 #endif
+
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -219,8 +219,9 @@ typedef c_file_ptr_stream<std::istream, 
 typedef c_file_ptr_stream<std::ostream, gzFile, c_zfile_ptr_buf>
   o_c_zfile_ptr_stream;
 typedef c_file_ptr_stream<std::iostream, gzFile, c_zfile_ptr_buf>
   io_c_zfile_ptr_stream;
 
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -580,8 +580,9 @@ octave_call_stack::do_goto_base_frame (v
   tmp.m_prev = curr_frame;
 
   curr_frame = cs.size ();
 
   cs.push_back (tmp);
 
   symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
 }
+
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -471,8 +471,9 @@ private:
         symbol_table::set_scope_and_context (new_elt.m_scope, new_elt.m_context);
       }
   }
 
   void do_clear (void) { cs.clear (); }
 };
 
 #endif
+
diff --git a/libinterp/corefcn/cdisplay.c b/libinterp/corefcn/cdisplay.c
--- a/libinterp/corefcn/cdisplay.c
+++ b/libinterp/corefcn/cdisplay.c
@@ -174,8 +174,9 @@ octave_get_display_info (int *ht, int *w
   octave_unused_parameter (ry);
 
   msg = "no graphical display found";
 
 #endif
 
   return msg;
 }
+
diff --git a/libinterp/corefcn/cdisplay.h b/libinterp/corefcn/cdisplay.h
--- a/libinterp/corefcn/cdisplay.h
+++ b/libinterp/corefcn/cdisplay.h
@@ -33,8 +33,9 @@ OCTINTERP_API extern const char *
 octave_get_display_info (int *ht, int *wd, int *dp, double *rx, double *ry,
                          int *dpy_avail);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -2385,8 +2385,9 @@ endfor
 
       octave_value tmp = x(i);
 
       y(i) = tmp.do_index_op (idx);
     }
 
   return octave_value (y);
 }
+
diff --git a/libinterp/corefcn/coct-hdf5-types.c b/libinterp/corefcn/coct-hdf5-types.c
--- a/libinterp/corefcn/coct-hdf5-types.c
+++ b/libinterp/corefcn/coct-hdf5-types.c
@@ -35,8 +35,9 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_HDF5)
 
 const octave_hdf5_id octave_H5E_DEFAULT = H5E_DEFAULT;
 const octave_hdf5_id octave_H5P_DEFAULT = H5P_DEFAULT;
 const octave_hdf5_id octave_H5S_ALL = H5S_ALL;
 
 #endif
+
diff --git a/libinterp/corefcn/comment-list.cc b/libinterp/corefcn/comment-list.cc
--- a/libinterp/corefcn/comment-list.cc
+++ b/libinterp/corefcn/comment-list.cc
@@ -38,8 +38,9 @@ octave_comment_list::dup (void) const
     {
       const octave_comment_elt elt = *p;
 
       new_cl->append (elt);
     }
 
   return new_cl;
 }
+
diff --git a/libinterp/corefcn/comment-list.h b/libinterp/corefcn/comment-list.h
--- a/libinterp/corefcn/comment-list.h
+++ b/libinterp/corefcn/comment-list.h
@@ -96,8 +96,9 @@ public:
   void append (const std::string& s,
                octave_comment_elt::comment_type t = octave_comment_elt::unknown)
   { append (octave_comment_elt (s, t)); }
 
   octave_comment_list *dup (void) const;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -542,8 +542,9 @@ The size of the result is @code{max (siz
 %!assert (class (convn (ones(5, "uint8"), rand(3))), "double")
 %!assert (class (convn (rand (3, "single"), ones(5, "uint8"))), "single")
 
 %!error convn ()
 %!error convn (1)
 %!error <SHAPE type not valid> convn (1,2, "NOT_A_SHAPE")
 %!error convn (rand (3), 1, 1)
 */
+
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -288,18 +288,18 @@ parameters for @code{daspk}.
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             daspk_fcn = c(0).function_value ();
           else
             {
               fcn_name = unique_symbol_name ("__daspk_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
               fname.append (" (x, xdot, t) y = ");
-              daspk_fcn = extract_function
-                (c(0), "daspk", fcn_name, fname, "; endfunction");
+              daspk_fcn = extract_function (c(0), "daspk", fcn_name,
+                                            fname, "; endfunction");
             }
 
           if (daspk_fcn)
             {
               if (c(1).is_function_handle () || c(1).is_inline_function ())
                 daspk_jac = c(1).function_value ();
               else
                 {
@@ -356,19 +356,18 @@ parameters for @code{daspk}.
                                               fname, "; endfunction");
 
                 if (daspk_fcn)
                   {
                     jac_name = unique_symbol_name ("__daspk_jac__");
                     jname = "function jac = ";
                     jname.append (jac_name);
                     jname.append (" (x, xdot, t, cj) jac = ");
-                    daspk_jac = extract_function (tmp(1), "daspk",
-                                                  jac_name, jname,
-                                                  "; endfunction");
+                    daspk_jac = extract_function (tmp(1), "daspk", jac_name,
+                                                  jname, "; endfunction");
 
                     if (! daspk_jac)
                       {
                         if (fcn_name.length ())
                           clear_function (fcn_name);
                         daspk_fcn = 0;
                       }
                   }
@@ -436,8 +435,9 @@ parameters for @code{daspk}.
       retval(1) = Matrix ();
     }
 
   retval(2) = static_cast<double> (dae.integration_state ());
   retval(3) = msg;
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -544,8 +544,9 @@ parameters for @code{dasrt}.
       retval(2) = Matrix ();
     }
 
   retval(3) = static_cast<double> (dae.integration_state ());
   retval(4) = msg;
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -524,8 +524,9 @@ parameters for @code{dassl}.
 %! old_tol = dassl_options ("absolute tolerance");
 %! dassl_options ("absolute tolerance", eps);
 %! assert (dassl_options ("absolute tolerance") == eps);
 %! ## Restore old value of tolerance
 %! dassl_options ("absolute tolerance", old_tol);
 
 %!error dassl_options ("foo", 1, 2)
 */
+
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1562,17 +1562,17 @@ in double precision even for single prec
       MAKE_INT_BRANCH (int64);
       MAKE_INT_BRANCH (uint8);
       MAKE_INT_BRANCH (uint16);
       MAKE_INT_BRANCH (uint32);
       MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
-          // GAGME: Accursed Matlab compatibility...
+    // GAGME: Accursed Matlab compatibility...
     case btyp_char:
       retval = arg.array_value (true).prod (dim);
       break;
 
     case btyp_bool:
       if (arg.is_sparse_type ())
         {
           if (isnative)
@@ -1955,17 +1955,17 @@ do_cat (const octave_value_list& xargs, 
             all_strings_p = false;
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
           if (all_cmplx_p && ! (args(i).is_complex_type ()
-              || args(i).is_real_type ()))
+                                || args(i).is_real_type ()))
             all_cmplx_p = false;
           if (! any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
           if (! any_cell_p && args(i).is_cell ())
             any_cell_p = true;
           if (! any_class_p && args(i).is_object ())
             any_class_p = true;
         }
@@ -3075,17 +3075,17 @@ inputs, @qcode{"extra"} is the same as @
       MAKE_INT_BRANCH (int64);
       MAKE_INT_BRANCH (uint8);
       MAKE_INT_BRANCH (uint16);
       MAKE_INT_BRANCH (uint32);
       MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
-      // GAGME: Accursed Matlab compatibility...
+    // GAGME: Accursed Matlab compatibility...
     case btyp_char:
       if (isextra)
         retval = arg.array_value (true).xsum (dim);
       else
         retval = arg.array_value (true).sum (dim);
       break;
 
     case btyp_bool:
@@ -3425,17 +3425,17 @@ complex ([1, 2], [3, 4])
             }
           else
             {
               if (re_val.dims () != im_val.dims ())
                 error ("complex: dimension mismatch");
 
               SparseComplexMatrix result;
               result = SparseComplexMatrix (re_val)
-                + Complex (0, 1) * SparseComplexMatrix (im_val);
+                       + Complex (0, 1) * SparseComplexMatrix (im_val);
               retval = octave_value (new octave_sparse_complex_matrix (result));
             }
         }
       else if (re.is_single_type () || im.is_single_type ())
         {
           if (re.numel () == 1)
             {
               float re_val = re.float_value ();
@@ -7380,24 +7380,24 @@ converted to logical.
         }
       else if (tval.is_cell () && fval.is_cell ())
         {
           retval = do_merge (mask,
                              tval.cell_value (),
                              fval.cell_value ());
         }
 
-        MAKE_INT_BRANCH (int8)
-        MAKE_INT_BRANCH (int16)
-        MAKE_INT_BRANCH (int32)
-        MAKE_INT_BRANCH (int64)
-        MAKE_INT_BRANCH (uint8)
-        MAKE_INT_BRANCH (uint16)
-        MAKE_INT_BRANCH (uint32)
-        MAKE_INT_BRANCH (uint64)
+      MAKE_INT_BRANCH (int8)
+      MAKE_INT_BRANCH (int16)
+      MAKE_INT_BRANCH (int32)
+      MAKE_INT_BRANCH (int64)
+      MAKE_INT_BRANCH (uint8)
+      MAKE_INT_BRANCH (uint16)
+      MAKE_INT_BRANCH (uint32)
+      MAKE_INT_BRANCH (uint64)
 
       else
         error ("merge: cannot merge %s with %s with array mask",
                tval.class_name ().c_str (),
                fval.class_name ().c_str ());
     }
 
   return retval;
@@ -7415,30 +7415,30 @@ do_sparse_diff (const SparseT& array, oc
   SparseT retval = array;
   if (dim == 1)
     {
       octave_idx_type k = retval.columns ();
       while (order > 0 && k > 0)
         {
           idx_vector col1 (':'), col2 (':'), sl1 (1, k), sl2 (0, k-1);
           retval = SparseT (retval.index (col1, sl1))
-                 - SparseT (retval.index (col2, sl2));
+                   - SparseT (retval.index (col2, sl2));
           assert (retval.columns () == k-1);
           order--;
           k--;
         }
     }
   else
     {
       octave_idx_type k = retval.rows ();
       while (order > 0 && k > 0)
         {
           idx_vector col1 (':'), col2 (':'), sl1 (1, k), sl2 (0, k-1);
           retval = SparseT (retval.index (sl1, col1))
-                 - SparseT (retval.index (sl2, col2));
+                   - SparseT (retval.index (sl2, col2));
           assert (retval.rows () == k-1);
           order--;
           k--;
         }
     }
 
   return retval;
 }
@@ -7879,8 +7879,9 @@ dimensions of the decoded array.
 
 %!error base64_decode ()
 %!error base64_decode (1,2,3)
 %!error base64_decode (1, "this is not a valid set of dimensions")
 %!error <input was not valid base64> base64_decode (1)
 %!error <input was not valid base64> base64_decode ("AQ=")
 %!error <incorrect input size> base64_decode ("AQ==")
 */
+
diff --git a/libinterp/corefcn/data.h b/libinterp/corefcn/data.h
--- a/libinterp/corefcn/data.h
+++ b/libinterp/corefcn/data.h
@@ -29,8 +29,9 @@ along with Octave; see the file COPYING.
 
 class octave_value;
 class octave_value_list;
 
 extern OCTINTERP_API octave_value
 do_class_concat (const octave_value_list& ovl, std::string cattype, int dim);
 
 #endif
+
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -271,170 +271,170 @@ parse_dbfunction_params (const char *who
       if (pos >= nargin)
         error ("%s: '%s' missing argument", who,
                ( token == dbstop_in ? "in" :
                 (token == dbstop_at ? "at" : "if")));
 
       // process the actual arguments
       switch (token)
         {
-          case dbstop_in:
-            symbol_name = args(pos).string_value ();
-            if (seen_in)
-              error ("%s: Too many function names specified -- %s",
-                     who, symbol_name.c_str ());
-            else if (seen_at || seen_if)
-              error ("%s: function name must come before line number and 'if'",
-                     who);
-            seen_in = true;
-            pos++;
-            break;
+        case dbstop_in:
+          symbol_name = args(pos).string_value ();
+          if (seen_in)
+            error ("%s: Too many function names specified -- %s",
+                   who, symbol_name.c_str ());
+          else if (seen_at || seen_if)
+            error ("%s: function name must come before line number and 'if'",
+                   who);
+          seen_in = true;
+          pos++;
+          break;
 
-          case dbstop_at:
-            if (seen_at)
-              error ("%s: Only one 'at' clause is allowed -- %s",
-                     who, args(pos).string_value ().c_str ());
-            else if (seen_if)
-                error ("%s: line number must come before 'if' clause\n");
-            seen_at = true;
+        case dbstop_at:
+          if (seen_at)
+            error ("%s: Only one 'at' clause is allowed -- %s",
+                   who, args(pos).string_value ().c_str ());
+          else if (seen_if)
+            error ("%s: line number must come before 'if' clause\n");
+          seen_at = true;
 
-            if (! seen_in)
-              {
-                // It was a line number.  Get function name from debugger.
-                if (Vdebugging)
-                  symbol_name = get_user_code ()->profiler_name ();
-                else
-                  error ("%s: function name must come before line number "
-                         "and 'if'", who);
-                seen_in = true;
-              }
-            else if (seen_if)
-              error ("%s: line number must come before 'if' clause\n");
+          if (! seen_in)
+            {
+              // It was a line number.  Get function name from debugger.
+              if (Vdebugging)
+                symbol_name = get_user_code ()->profiler_name ();
+              else
+                error ("%s: function name must come before line number "
+                       "and 'if'", who);
+              seen_in = true;
+            }
+          else if (seen_if)
+            error ("%s: line number must come before 'if' clause\n");
 
-            // Read a list of line numbers (or arrays thereof)
-            for ( ; pos < nargin; pos++)
-              {
-                if (args(pos).is_string ())
-                  {
-                    int line = atoi (args(pos).string_value ().c_str ());
+          // Read a list of line numbers (or arrays thereof)
+          for ( ; pos < nargin; pos++)
+            {
+              if (args(pos).is_string ())
+                {
+                  int line = atoi (args(pos).string_value ().c_str ());
 
-                    if (line > 0)
-                      lines[list_idx++] = line;
-                    else
-                      break;        // may be "if"
-                  }
-                else if (args(pos).is_numeric_type ())
-                  {
-                    const NDArray arg = args(pos).array_value ();
+                  if (line > 0)
+                    lines[list_idx++] = line;
+                  else
+                    break;        // may be "if"
+                }
+              else if (args(pos).is_numeric_type ())
+                {
+                  const NDArray arg = args(pos).array_value ();
 
-                    for (octave_idx_type j = 0; j < arg.numel (); j++)
-                      lines[list_idx++] = static_cast<int> (arg.elem (j));
-                  }
-                else
-                  error ("%s: Invalid argument type %s",
-                         args(pos).type_name ().c_str ());
-              }
-            break;
+                  for (octave_idx_type j = 0; j < arg.numel (); j++)
+                    lines[list_idx++] = static_cast<int> (arg.elem (j));
+                }
+              else
+                error ("%s: Invalid argument type %s",
+                       args(pos).type_name ().c_str ());
+            }
+          break;
 
-          case dbstop_if:
-            if (seen_in)    // conditional breakpoint
-              {
-                cond = "";  // remaining arguments form condition
-                for (; pos < nargin; pos++)
-                  {
-                    if (args(pos).is_string ())
-                      cond = cond + " " + args(pos).string_value ();
-                    else
-                      error ("%s: arguments to 'if' must all be strings", who);
-                  }
+        case dbstop_if:
+          if (seen_in)    // conditional breakpoint
+            {
+              cond = "";  // remaining arguments form condition
+              for (; pos < nargin; pos++)
+                {
+                  if (args(pos).is_string ())
+                    cond = cond + " " + args(pos).string_value ();
+                  else
+                    error ("%s: arguments to 'if' must all be strings", who);
+                }
 
-                cond = cond.substr (1);   // omit initial space
-              }
-            else    // stop on event (error, warning, interrupt, NaN/inf)
-              {
-                std::string condition = args(pos).string_value ();
-                int on_off = ! strcmp(who, "dbstop");
+              cond = cond.substr (1);   // omit initial space
+            }
+          else    // stop on event (error, warning, interrupt, NaN/inf)
+            {
+              std::string condition = args(pos).string_value ();
+              int on_off = ! strcmp(who, "dbstop");
 
-                // list of error/warning IDs to update
-                std::set<std::string> *id_list = NULL;
-                bool *stop_flag = NULL;         // Vdebug_on_... flag
+              // list of error/warning IDs to update
+              std::set<std::string> *id_list = NULL;
+              bool *stop_flag = NULL;         // Vdebug_on_... flag
 
-                if (condition == "error")
-                  {
-                    id_list = &bp_table::errors_that_stop;
-                    stop_flag = &Vdebug_on_error;
-                  }
-                else if (condition == "warning")
-                  {
-                    id_list = &bp_table::warnings_that_stop;
-                    stop_flag = &Vdebug_on_warning;
-                  }
-                else if (condition == "caught" && nargin > pos+1
-                         && args(pos+1).string_value () == "error")
-                  {
-                    id_list = &bp_table::caught_that_stop;
-                    stop_flag = &Vdebug_on_caught;
-                    pos++;
-                  }
-                else if (condition == "interrupt")
-                  {
-                    octave::Vdebug_on_interrupt = on_off;
-                  }
-                else if (condition == "naninf")
+              if (condition == "error")
+                {
+                  id_list = &bp_table::errors_that_stop;
+                  stop_flag = &Vdebug_on_error;
+                }
+              else if (condition == "warning")
+                {
+                  id_list = &bp_table::warnings_that_stop;
+                  stop_flag = &Vdebug_on_warning;
+                }
+              else if (condition == "caught" && nargin > pos+1
+                       && args(pos+1).string_value () == "error")
+                {
+                  id_list = &bp_table::caught_that_stop;
+                  stop_flag = &Vdebug_on_caught;
+                  pos++;
+                }
+              else if (condition == "interrupt")
+                {
+                  octave::Vdebug_on_interrupt = on_off;
+                }
+              else if (condition == "naninf")
 #if defined (DBSTOP_NANINF)
-                  {
-                    Vdebug_on_naninf = on_off;
-                    enable_fpe (on_off);
-                  }
+                {
+                  Vdebug_on_naninf = on_off;
+                  enable_fpe (on_off);
+                }
 #else
-                  warning ("%s: condition '%s' not yet supported",
-                           who, condition.c_str ());
+                warning ("%s: condition '%s' not yet supported",
+                         who, condition.c_str ());
 #endif
-                else
-                  error ("%s: invalid condition %s",
-                         who, condition.c_str ());
+              else
+                error ("%s: invalid condition %s",
+                       who, condition.c_str ());
 
-                // process ID list for "dbstop if error <error_ID>" etc
-                if (id_list != NULL)
-                  {
-                    pos++;
-                    if (pos < nargin)       // only affect a single error ID
-                      {
-                        if (! args(pos).is_string () || nargin > pos+1)
-                          error ("%s: ID must be a single string", who);
-                        else if (on_off == 1)
-                          {
-                            id_list->insert (args(pos).string_value ());
-                            *stop_flag = 1;
-                          }
-                        else
-                          {
-                            id_list->erase (args(pos).string_value ());
-                            if (id_list->empty ())
-                              *stop_flag = 0;
-                          }
-                      }
-                    else   // unqualified.  Turn all on or off
-                      {
-                        id_list->clear ();
-                        *stop_flag = on_off;
-                        if (stop_flag == &Vdebug_on_error)
-                          {
-                            // Matlab stops on both.
-                            octave::Vdebug_on_interrupt = on_off;
-                          }
-                      }
-                  }
+              // process ID list for "dbstop if error <error_ID>" etc
+              if (id_list != NULL)
+                {
+                  pos++;
+                  if (pos < nargin)       // only affect a single error ID
+                    {
+                      if (! args(pos).is_string () || nargin > pos+1)
+                        error ("%s: ID must be a single string", who);
+                      else if (on_off == 1)
+                        {
+                          id_list->insert (args(pos).string_value ());
+                          *stop_flag = 1;
+                        }
+                      else
+                        {
+                          id_list->erase (args(pos).string_value ());
+                          if (id_list->empty ())
+                            *stop_flag = 0;
+                        }
+                    }
+                  else   // unqualified.  Turn all on or off
+                    {
+                      id_list->clear ();
+                      *stop_flag = on_off;
+                      if (stop_flag == &Vdebug_on_error)
+                        {
+                          // Matlab stops on both.
+                          octave::Vdebug_on_interrupt = on_off;
+                        }
+                    }
+                }
 
-                pos = nargin;
-              }
-            break;
+              pos = nargin;
+            }
+          break;
 
-          default:      // dbstop_none should never occur
-            break;
+        default:      // dbstop_none should never occur
+          break;
         }
     }
 }
 
 /*
 %!test
 %! dbclear all;   # Clear out breakpoints before test
 %! dbstop help;
@@ -748,17 +748,18 @@ bp_table::do_add_breakpoint (const std::
           // If multiple are in the same function, we insert multiple times.
           intmap ret_one;
           if (dbg_fcn
               && do_add_breakpoint_1 (dbg_fcn, fname, line, condition, ret_one))
             retval.insert (std::pair<int,int> (i, ret_one.find (i)->second));
         }
     }
 
-  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
+  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
+                                       || Vdebugging;
 
   return retval;
 }
 
 int
 bp_table::do_remove_breakpoint_1 (octave_user_code *fcn,
                                   const std::string& fname,
                                   const bp_table::intmap& line)
@@ -846,17 +847,18 @@ bp_table::do_remove_breakpoint (const st
             {
               octave_user_code *dbg_subfcn = q->second.user_code_value ();
 
               retval += do_remove_breakpoint_1 (dbg_subfcn, fname, line);
             }
         }
     }
 
-  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
+  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
+                                       || Vdebugging;
 
   return retval;
 }
 
 // Remove all breakpoints from a file, including those in subfunctions
 bp_table::intmap
 bp_table::do_remove_all_breakpoints_in_file (const std::string& fname,
                                              bool silent)
@@ -879,34 +881,36 @@ bp_table::do_remove_all_breakpoints_in_f
           if (it != bp_set.end ())
             bp_set.erase (it);
         }
     }
   else if (! silent)
     error ("remove_all_breakpoint_in_file: "
            "unable to find function %s\n", fname.c_str ());
 
-  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
+  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
+                                       || Vdebugging;
 
   return retval;
 }
 
 void
 bp_table::do_remove_all_breakpoints (void)
 {
   // Odd loop structure required because delete will invalidate bp_set iterators
   for (const_bp_set_iterator it=bp_set.begin (), it_next=it;
        it != bp_set.end ();
        it=it_next)
     {
       ++it_next;
       remove_all_breakpoints_in_file (*it);
     }
 
-  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
+  octave::tree_evaluator::debug_mode = bp_table::have_breakpoints ()
+                                       || Vdebugging;
 }
 
 std::string
 do_find_bkpt_list (octave_value_list slist, std::string match)
 {
   std::string retval;
 
   for (int i = 0; i < slist.length (); i++)
@@ -962,17 +966,17 @@ bp_table::do_get_breakpoint_list (const 
                   if (q != subf.end ())
                     {
                       octave_user_code *ff = q->second.user_code_value ();
 
                       cmds = ff->body ();
                       if (cmds)
                         {
                           std::list<bp_type> bkpts
-                                             = cmds->breakpoints_and_conds ();
+                            = cmds->breakpoints_and_conds ();
 
                           if (! bkpts.empty ())
                             retval[bp_fname + Vfilemarker + ff->name ()] = bkpts;
                         }
                     }
                 }
             }
         }
@@ -1595,35 +1599,35 @@ is stopped.
 void
 do_dbtype (std::ostream& os, const std::string& name, int start, int end)
 {
   std::string ff = fcn_file_in_path (name);
 
   if (ff.empty ())
     os << "dbtype: unknown function " << name << "\n";
   else
-  {
-    std::ifstream fs (ff.c_str (), std::ios::in);
+    {
+      std::ifstream fs (ff.c_str (), std::ios::in);
 
-    if (! fs)
-      os << "dbtype: unable to open '" << ff << "' for reading!\n";
-    else
-    {
-      int line = 1;
-      std::string text;
+      if (! fs)
+        os << "dbtype: unable to open '" << ff << "' for reading!\n";
+      else
+        {
+          int line = 1;
+          std::string text;
 
-      while (std::getline (fs, text) && line <= end)
-        {
-          if (line >= start)
-            os << line << "\t" << text << "\n";
+          while (std::getline (fs, text) && line <= end)
+            {
+              if (line >= start)
+                os << line << "\t" << text << "\n";
 
-          line++;
+              line++;
+            }
         }
     }
-  }
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} dbtype
 @deftypefnx {} {} dbtype @var{lineno}
diff --git a/libinterp/corefcn/debug.h b/libinterp/corefcn/debug.h
--- a/libinterp/corefcn/debug.h
+++ b/libinterp/corefcn/debug.h
@@ -196,8 +196,9 @@ private:
   fname_bp_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
 
 extern std::string get_file_line (const std::string& fname, size_t line);
 
 #endif
+
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -604,8 +604,9 @@ Return the version number of Octave as a
 
   return ovl (OCTAVE_VERSION);
 }
 
 /*
 %!assert (ischar (OCTAVE_VERSION ()))
 %!error OCTAVE_VERSION (1)
 */
+
diff --git a/libinterp/corefcn/defaults.in.h b/libinterp/corefcn/defaults.in.h
--- a/libinterp/corefcn/defaults.in.h
+++ b/libinterp/corefcn/defaults.in.h
@@ -234,8 +234,9 @@ extern OCTINTERP_API void install_defaul
 
 extern OCTINTERP_API void
 set_exec_path (const std::string& path = "");
 
 extern OCTINTERP_API void
 set_image_path (const std::string& path = "");
 
 #endif
+
diff --git a/libinterp/corefcn/defun-dld.h b/libinterp/corefcn/defun-dld.h
--- a/libinterp/corefcn/defun-dld.h
+++ b/libinterp/corefcn/defun-dld.h
@@ -48,8 +48,9 @@ along with Octave; see the file COPYING.
   DECLARE_FUN (name, args_name, nargout_name)
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc)    \
   FORWARD_DECLARE_FUNX (fname);                                         \
   DEFINE_FUNX_INSTALLER_FUN (name, fname, gname, doc)                   \
   DECLARE_FUNX (fname, args_name, nargout_name)
 
 #endif
+
diff --git a/libinterp/corefcn/defun-int.h b/libinterp/corefcn/defun-int.h
--- a/libinterp/corefcn/defun-int.h
+++ b/libinterp/corefcn/defun-int.h
@@ -124,8 +124,9 @@ typedef octave_function *
                                                                         \
     if (relative)                                                       \
       fcn->mark_relative ();                                            \
                                                                         \
     return fcn;                                                         \
   }
 
 #endif
+
diff --git a/libinterp/corefcn/defun.h b/libinterp/corefcn/defun.h
--- a/libinterp/corefcn/defun.h
+++ b/libinterp/corefcn/defun.h
@@ -60,8 +60,9 @@ along with Octave; see the file COPYING.
 
 // Make alias another name for the existing function name.  This macro
 // is processed by the mkbuiltins to generate code in builtins.cc to
 // create the alias in the symbol table.
 
 #define DEFALIAS(alias, name)
 
 #endif
+
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -176,17 +176,17 @@ For that, use any of the condition numbe
               retval(1) = rcond;
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
               MAYBE_CAST (rep, octave_matrix);
               MatrixType mtype = rep ? rep -> matrix_type ()
-                : MatrixType ();
+                                     : MatrixType ();
               DET det = m.determinant (mtype, info, rcond);
               retval(0) = info == -1 ? 0.0 : det.value ();
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else if (arg.is_complex_type ())
@@ -203,17 +203,17 @@ For that, use any of the condition numbe
               retval(1) = rcond;
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               MAYBE_CAST (rep, octave_complex_matrix);
               MatrixType mtype = rep ? rep -> matrix_type ()
-                : MatrixType ();
+                                     : MatrixType ();
               ComplexDET det = m.determinant (mtype, info, rcond);
               retval(0) = info == -1 ? Complex (0.0) : det.value ();
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else
@@ -225,8 +225,9 @@ For that, use any of the condition numbe
 
 /*
 %!assert (det ([1, 2; 3, 4]), -2, 10*eps)
 %!assert (det (single ([1, 2; 3, 4])), single (-2), 10*eps ("single"))
 %!error det ()
 %!error det (1, 2)
 %!error <must be a square matrix> det ([1, 2; 3, 4; 5, 6])
 */
+
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -701,8 +701,9 @@ will ask for confirmation before recursi
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{rmdir}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (confirm_recursive_rmdir);
 }
+
diff --git a/libinterp/corefcn/dirfns.h b/libinterp/corefcn/dirfns.h
--- a/libinterp/corefcn/dirfns.h
+++ b/libinterp/corefcn/dirfns.h
@@ -30,8 +30,9 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "oct-time.h"
 
 // The time we last time we changed directories.
 extern octave::sys::time Vlast_chdir_time;
 
 #endif
+
diff --git a/libinterp/corefcn/display.cc b/libinterp/corefcn/display.cc
--- a/libinterp/corefcn/display.cc
+++ b/libinterp/corefcn/display.cc
@@ -62,8 +62,9 @@ display_info::instance_ok (bool query)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     error ("unable to create display_info object!");
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/display.h b/libinterp/corefcn/display.h
--- a/libinterp/corefcn/display.h
+++ b/libinterp/corefcn/display.h
@@ -121,8 +121,9 @@ private:
   }
 
   void init (bool query = true);
 
   static bool instance_ok (bool query = true);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -501,8 +501,9 @@ such as text, are also replaced by the @
 %!assert (dlmread (file, ",", "..B3"), [1, 2; 4 + 4i, 5; 7, 8])
 %!assert (dlmread (file, ",", 1, 0), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
 %!assert (dlmread (file, ",", "A2.."), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12])
 %!error (dlmread (file, ",", [0 1]))
 
 %!test
 %! unlink (file);
 */
+
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -52,31 +52,33 @@ octave_shlib_list
 {
 public:
 
   typedef std::list<octave::dynamic_library>::iterator iterator;
   typedef std::list<octave::dynamic_library>::const_iterator const_iterator;
 
   static void append (const octave::dynamic_library& shl);
 
-  static void remove (octave::dynamic_library& shl, octave::dynamic_library::close_hook cl_hook = 0);
+  static void remove (octave::dynamic_library& shl,
+                      octave::dynamic_library::close_hook cl_hook = 0);
 
   static octave::dynamic_library find_file (const std::string& file_name);
 
   static void display (void);
 
 private:
 
   octave_shlib_list (void) : lib_list () { }
 
   ~octave_shlib_list (void) { }
 
   void do_append (const octave::dynamic_library& shl);
 
-  void do_remove (octave::dynamic_library& shl, octave::dynamic_library::close_hook cl_hook = 0);
+  void do_remove (octave::dynamic_library& shl,
+                  octave::dynamic_library::close_hook cl_hook = 0);
 
   octave::dynamic_library do_find_file (const std::string& file_name) const;
 
   void do_display (void) const;
 
   static octave_shlib_list *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
@@ -448,8 +450,9 @@ octave_dynamic_loader::mex_uscore_mangle
   return "_mexFunction";
 }
 
 std::string
 octave_dynamic_loader::mex_f77_mangler (const std::string&)
 {
   return STRINGIFY (F77_FUNC (mexfunction, MEXFUNCTION));
 }
+
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -47,19 +47,21 @@ public:
             const std::string& file_name = "",
             bool relative = false);
 
   static octave_function *
   load_mex (const std::string& fcn_name,
             const std::string& file_name = "",
             bool relative = false);
 
-  static bool remove_oct (const std::string& fcn_name, octave::dynamic_library& shl);
+  static bool remove_oct (const std::string& fcn_name,
+                          octave::dynamic_library& shl);
 
-  static bool remove_mex (const std::string& fcn_name, octave::dynamic_library& shl);
+  static bool remove_mex (const std::string& fcn_name,
+                          octave::dynamic_library& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
@@ -95,8 +97,9 @@ protected:
   static std::string mex_mangler (const std::string& name);
 
   static std::string mex_uscore_mangler (const std::string& name);
 
   static std::string mex_f77_mangler (const std::string& name);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -117,28 +117,28 @@ The eigenvalues returned by @code{eig} a
 
   if (arg_a.rows () != arg_a.columns ())
     err_square_matrix_required ("eig", "A");
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   if (! AEPcase)
-  {
-    arg_b = args(1);
+    {
+      arg_b = args(1);
 
-    if (arg_b.is_empty ())
-      return octave_value_list (2, Matrix ());
+      if (arg_b.is_empty ())
+        return octave_value_list (2, Matrix ());
 
-    if (! arg_b.is_float_type ())
-      err_wrong_type_arg ("eig", arg_b);
+      if (! arg_b.is_float_type ())
+        err_wrong_type_arg ("eig", arg_b);
 
-    if (arg_b.rows () != arg_b.columns ())
-      err_square_matrix_required ("eig", "B");
-  }
+      if (arg_b.rows () != arg_b.columns ())
+        err_square_matrix_required ("eig", "B");
+    }
 
   bool qz_flag = false;
   bool chol_flag = false;
   bool balance_flag = false;
   bool no_balance_flag = false;
   bool matrix_flag = false;
   bool vector_flag = false;
 
@@ -636,8 +636,9 @@ The eigenvalues returned by @code{eig} a
 %!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "matrix", "vector")
 %!error <"vector" and "matrix" options are mutually exclusive>
 %!  eig ([1 2 ; 2 3], [1 2 ; 2 3], "vector", "matrix")
 %!error <wrong type argument>
 %!  eig ([1 2 ; 2 3], [1 2 ; 2 3], false)
 %!error <wrong type argument>
 %!  eig ([1 2 ; 2 3], [1 2 ; 2 3], [1 2 ; 2 3])
 */
+
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1072,17 +1072,18 @@ maybe_extract_message_id (const std::str
 
               nargs.resize (nargin-1);
 
               for (int i = 1; i < nargin; i++)
                 nargs(i-1) = args(i);
             }
           else
             nargs(0) = "call to " + caller
-              + " with message identifier '" + arg1 + "' requires message";
+                       + " with message identifier '" + arg1
+                       + "' requires message";
         }
     }
 
   return have_fmt;
 }
 
 DEFUN (error, args, ,
        doc: /* -*- texinfo -*-
@@ -1544,18 +1545,18 @@ disable escape sequence expansion use a 
 
                   ids(nel) = arg2;
                   states(nel) = curr_state;
                 }
 
               m.contents ("identifier") = ids;
               m.contents ("state") = states;
 
-              symbol_table::assign
-                (".saved_warning_states.", m, scope, context);
+              symbol_table::assign (".saved_warning_states.",
+                                    m, scope, context);
 
               // Now ignore the "local" argument and continue to
               // handle the current setting.
               nargin--;
             }
 
           if (nargin >= 2 && arg2 == "all")
             {
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -172,8 +172,9 @@ extern OCTINTERP_API std::string last_er
 extern OCTINTERP_API std::string last_error_id (void);
 extern OCTINTERP_API octave_map last_error_stack (void);
 extern OCTINTERP_API std::string last_warning_message (void);
 extern OCTINTERP_API std::string last_warning_id (void);
 
 extern OCTINTERP_API void interpreter_try (octave::unwind_protect&);
 
 #endif
+
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
--- a/libinterp/corefcn/errwarn.h
+++ b/libinterp/corefcn/errwarn.h
@@ -178,8 +178,9 @@ warn_invalid_value_specified (const char
 
 OCTINTERP_API extern void
 warn_logical_conversion (void);
 
 OCTINTERP_API extern void
 warn_wrong_type_arg (const char *name, const octave_value& tc);
 
 #endif
+
diff --git a/libinterp/corefcn/event-queue.cc b/libinterp/corefcn/event-queue.cc
--- a/libinterp/corefcn/event-queue.cc
+++ b/libinterp/corefcn/event-queue.cc
@@ -29,8 +29,9 @@ along with Octave; see the file COPYING.
 
 void
 event_queue_safe::warn_unhandled_exception (void) const
 {
   warning ("unhandled exception in event_queue_safe handler.  "
            "It is a bug in Octave for this to happen.  "
            "Please help improve Octave by reporting it.");
 }
+
diff --git a/libinterp/corefcn/event-queue.h b/libinterp/corefcn/event-queue.h
--- a/libinterp/corefcn/event-queue.h
+++ b/libinterp/corefcn/event-queue.h
@@ -119,8 +119,9 @@ private:
   // No copying!
 
   event_queue_safe (const event_queue_safe&);
 
   event_queue_safe& operator = (const event_queue_safe&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -287,8 +287,9 @@ dimension of the matrix along which the 
 %! s = cos (n*t);
 %!
 %! S = zeros (size (t), "single");
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps ("single"));
 */
+
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -256,8 +256,9 @@ of @var{A} is treated separately
 %! sy = cos (n*y);
 %!
 %! S = kron (fft (sx)', fft (sy));
 %! answer = kron (sx', sy);
 %! s = ifft2 (S);
 %!
 %! assert (s, answer, 30*eps ("single"));
 */
+
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -157,8 +157,9 @@ corresponding dimension of @var{A}, then
 truncated prior to performing the inverse FFT@.  Otherwise, if an element of
 @var{size} is larger than the corresponding dimension then @var{A} is
 resized and padded with zeros.
 @seealso{fftn, ifft, ifft2, fftw}
 @end deftypefn */)
 {
   return do_fftn (args, "ifftn", 1);
 }
+
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -3120,8 +3120,9 @@ Return the numeric value corresponding t
 
 Even if paging is turned on, the standard error is not sent to the pager.
 It is useful for error messages and prompts.
 @seealso{stdin, stdout}
 @end deftypefn */)
 {
   return const_value ("stderr", args, stderr_file);
 }
+
diff --git a/libinterp/corefcn/file-io.h b/libinterp/corefcn/file-io.h
--- a/libinterp/corefcn/file-io.h
+++ b/libinterp/corefcn/file-io.h
@@ -31,8 +31,9 @@ extern OCTINTERP_API void initialize_fil
 
 extern OCTINTERP_API void close_files (void);
 
 extern OCTINTERP_API void mark_for_deletion (const std::string&);
 
 extern OCTINTERP_API void cleanup_tmp_files (void);
 
 #endif
+
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -609,8 +609,9 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!test
 %! x = ones (2, 1, 3, 4);
 %! x(1,1,:,:) = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! y0 = [1 1 6 2 15 3 2 1 8 2 18 3 3 1 10 2 21 3 4 1 12 2 24 3];
 %! y0 = reshape (y0, size (x));
 %! y = filter ([1 1 1], 1, x, [], 3);
 %! assert (y, y0);
 */
+
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -389,17 +389,18 @@ b = sparse (i, j, v, sz(1), sz(2));
     print_usage ();
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).xscalar_value ("find: N must be an integer");
 
-      if (val < 0 || (! octave::math::isinf (val) && val != octave::math::round (val)))
+      if (val < 0 || (! octave::math::isinf (val)
+                      && val != octave::math::round (val)))
         error ("find: N must be a non-negative integer");
       else if (! octave::math::isinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
@@ -574,8 +575,9 @@ b = sparse (i, j, v, sz(1), sz(2));
 %!assert (find ([2 0 1 0 5 0], 1), 1)
 %!assert (find ([2 0 1 0 5 0], 2, "last"), [3, 5])
 
 %!assert (find ([2 0 1 0 5 0], Inf), [1, 3, 5])
 %!assert (find ([2 0 1 0 5 0], Inf, "last"), [1, 3, 5])
 
 %!error find ()
 */
+
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -84,239 +84,239 @@ warn_glyph_render (FT_ULong c)
 #  include "PermMatrix.h"
 #endif
 
 // Forward declaration
 static void ft_face_destroyed (void *object);
 
 namespace octave
 {
-class
-ft_manager
-{
-public:
-  static bool instance_ok (void)
+  class
+  ft_manager
   {
-    bool retval = true;
+  public:
+    static bool instance_ok (void)
+    {
+      bool retval = true;
 
-    if (! instance)
-      {
-        instance = new ft_manager ();
+      if (! instance)
+        {
+          instance = new ft_manager ();
 
-        if (instance)
-          singleton_cleanup_list::add (cleanup_instance);
-      }
+          if (instance)
+            singleton_cleanup_list::add (cleanup_instance);
+        }
 
-    if (! instance)
-      error ("unable to create ft_manager!");
+      if (! instance)
+        error ("unable to create ft_manager!");
 
-    return retval;
-  }
+      return retval;
+    }
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  static FT_Face get_font (const std::string& name, const std::string& weight,
-                           const std::string& angle, double size)
-  {
-    return (instance_ok ()
-            ? instance->do_get_font (name, weight, angle, size)
-            : 0);
-  }
+    static FT_Face get_font (const std::string& name, const std::string& weight,
+                             const std::string& angle, double size)
+    {
+      return (instance_ok ()
+              ? instance->do_get_font (name, weight, angle, size)
+              : 0);
+    }
 
-  static void font_destroyed (FT_Face face)
-  {
-    if (instance_ok ())
-      instance->do_font_destroyed (face);
-  }
+    static void font_destroyed (FT_Face face)
+    {
+      if (instance_ok ())
+        instance->do_font_destroyed (face);
+    }
 
-private:
+  private:
 
-  static ft_manager *instance;
+    static ft_manager *instance;
 
-  typedef std::pair<std::string, double> ft_key;
-  typedef std::map<ft_key, FT_Face> ft_cache;
+    typedef std::pair<std::string, double> ft_key;
+    typedef std::map<ft_key, FT_Face> ft_cache;
 
-  // Cache the fonts loaded by FreeType.  This cache only contains
-  // weak references to the fonts, strong references are only present
-  // in class text_renderer.
-  ft_cache cache;
+    // Cache the fonts loaded by FreeType.  This cache only contains
+    // weak references to the fonts, strong references are only present
+    // in class text_renderer.
+    ft_cache cache;
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  ft_manager (const ft_manager&);
+    ft_manager (const ft_manager&);
 
-  ft_manager& operator = (const ft_manager&);
+    ft_manager& operator = (const ft_manager&);
 
-  ft_manager (void)
-    : library (), freetype_initialized (false), fontconfig_initialized (false)
-  {
-    if (FT_Init_FreeType (&library))
-      error ("unable to initialize FreeType library");
-    else
-      freetype_initialized = true;
+    ft_manager (void)
+      : library (), freetype_initialized (false), fontconfig_initialized (false)
+    {
+      if (FT_Init_FreeType (&library))
+        error ("unable to initialize FreeType library");
+      else
+        freetype_initialized = true;
 
 #if defined (HAVE_FONTCONFIG)
-    if (! FcInit ())
-      error ("unable to initialize fontconfig library");
-    else
-      fontconfig_initialized = true;
+      if (! FcInit ())
+        error ("unable to initialize fontconfig library");
+      else
+        fontconfig_initialized = true;
 #endif
-  }
+    }
 
-  ~ft_manager (void)
-  {
-    if (freetype_initialized)
-      FT_Done_FreeType (library);
+    ~ft_manager (void)
+    {
+      if (freetype_initialized)
+        FT_Done_FreeType (library);
 
 #if defined (HAVE_FONTCONFIG)
-    // FIXME: Skip the call to FcFini because it can trigger the assertion
-    //
-    //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
-    //
-    // if (fontconfig_initialized)
-    //   FcFini ();
+      // FIXME: Skip the call to FcFini because it can trigger the assertion
+      //
+      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
+      //
+      // if (fontconfig_initialized)
+      //   FcFini ();
 #endif
-  }
+    }
 
-  FT_Face do_get_font (const std::string& name, const std::string& weight,
-                       const std::string& angle, double size)
-  {
-    FT_Face retval = 0;
+    FT_Face do_get_font (const std::string& name, const std::string& weight,
+                         const std::string& angle, double size)
+    {
+      FT_Face retval = 0;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
-    // Look first into the font cache, then use fontconfig.  If the font
-    // is present in the cache, simply add a reference and return it.
+      // Look first into the font cache, then use fontconfig.  If the font
+      // is present in the cache, simply add a reference and return it.
 
-    ft_key key (name + ":" + weight + ":" + angle, size);
-    ft_cache::const_iterator it = cache.find (key);
+      ft_key key (name + ":" + weight + ":" + angle, size);
+      ft_cache::const_iterator it = cache.find (key);
 
-    if (it != cache.end ())
-      {
-        FT_Reference_Face (it->second);
-        return it->second;
-      }
+      if (it != cache.end ())
+        {
+          FT_Reference_Face (it->second);
+          return it->second;
+        }
 #endif
 
-    std::string file;
+      std::string file;
 
 #if defined (HAVE_FONTCONFIG)
-    if (fontconfig_initialized)
-      {
-        int fc_weight, fc_angle;
+      if (fontconfig_initialized)
+        {
+          int fc_weight, fc_angle;
 
-        if (weight == "bold")
-          fc_weight = FC_WEIGHT_BOLD;
-        else if (weight == "light")
-          fc_weight = FC_WEIGHT_LIGHT;
-        else if (weight == "demi")
-          fc_weight = FC_WEIGHT_DEMIBOLD;
-        else
-          fc_weight = FC_WEIGHT_NORMAL;
+          if (weight == "bold")
+            fc_weight = FC_WEIGHT_BOLD;
+          else if (weight == "light")
+            fc_weight = FC_WEIGHT_LIGHT;
+          else if (weight == "demi")
+            fc_weight = FC_WEIGHT_DEMIBOLD;
+          else
+            fc_weight = FC_WEIGHT_NORMAL;
 
-        if (angle == "italic")
-          fc_angle = FC_SLANT_ITALIC;
-        else if (angle == "oblique")
-          fc_angle = FC_SLANT_OBLIQUE;
-        else
-          fc_angle = FC_SLANT_ROMAN;
+          if (angle == "italic")
+            fc_angle = FC_SLANT_ITALIC;
+          else if (angle == "oblique")
+            fc_angle = FC_SLANT_OBLIQUE;
+          else
+            fc_angle = FC_SLANT_ROMAN;
 
-        FcPattern *pat = FcPatternCreate ();
+          FcPattern *pat = FcPatternCreate ();
 
-        FcPatternAddString (pat, FC_FAMILY,
-                            (reinterpret_cast<const FcChar8*>
-                             (name == "*" ? "sans" : name.c_str ())));
+          FcPatternAddString (pat, FC_FAMILY,
+                              (reinterpret_cast<const FcChar8*>
+                               (name == "*" ? "sans" : name.c_str ())));
 
-        FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
-        FcPatternAddInteger (pat, FC_SLANT, fc_angle);
-        FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
+          FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
+          FcPatternAddInteger (pat, FC_SLANT, fc_angle);
+          FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
 
-        if (FcConfigSubstitute (0, pat, FcMatchPattern))
-          {
-            FcResult res;
-            FcPattern *match;
+          if (FcConfigSubstitute (0, pat, FcMatchPattern))
+            {
+              FcResult res;
+              FcPattern *match;
 
-            FcDefaultSubstitute (pat);
-            match = FcFontMatch (0, pat, &res);
+              FcDefaultSubstitute (pat);
+              match = FcFontMatch (0, pat, &res);
 
-            // FIXME: originally, this test also required that
-            // res != FcResultNoMatch.  Is that really needed?
-            if (match)
-              {
-                unsigned char *tmp;
+              // FIXME: originally, this test also required that
+              // res != FcResultNoMatch.  Is that really needed?
+              if (match)
+                {
+                  unsigned char *tmp;
 
-                FcPatternGetString (match, FC_FILE, 0, &tmp);
-                file = reinterpret_cast<char*> (tmp);
-              }
-            else
-              ::warning ("could not match any font: %s-%s-%s-%g",
-                         name.c_str (), weight.c_str (), angle.c_str (),
-                         size);
+                  FcPatternGetString (match, FC_FILE, 0, &tmp);
+                  file = reinterpret_cast<char*> (tmp);
+                }
+              else
+                ::warning ("could not match any font: %s-%s-%s-%g",
+                           name.c_str (), weight.c_str (), angle.c_str (),
+                           size);
 
-            if (match)
-              FcPatternDestroy (match);
-          }
+              if (match)
+                FcPatternDestroy (match);
+            }
 
-        FcPatternDestroy (pat);
-      }
+          FcPatternDestroy (pat);
+        }
 #endif
 
-    if (file.empty ())
-      {
+      if (file.empty ())
+        {
 #if defined (OCTAVE_USE_WINDOWS_API)
-        file = "C:/WINDOWS/Fonts/verdana.ttf";
+          file = "C:/WINDOWS/Fonts/verdana.ttf";
 #else
-        // FIXME: find a "standard" font for UNIX platforms
+          // FIXME: find a "standard" font for UNIX platforms
 #endif
-      }
+        }
 
-    if (! file.empty ())
-      {
-        if (FT_New_Face (library, file.c_str (), 0, &retval))
-          ::warning ("ft_manager: unable to load font: %s", file.c_str ());
+      if (! file.empty ())
+        {
+          if (FT_New_Face (library, file.c_str (), 0, &retval))
+            ::warning ("ft_manager: unable to load font: %s", file.c_str ());
 #if defined (HAVE_FT_REFERENCE_FACE)
-        else
-          {
-            // Install a finalizer to notify ft_manager that the font is
-            // being destroyed.  The class ft_manager only keeps weak
-            // references to font objects.
+          else
+            {
+              // Install a finalizer to notify ft_manager that the font is
+              // being destroyed.  The class ft_manager only keeps weak
+              // references to font objects.
 
-            retval->generic.data = new ft_key (key);
-            retval->generic.finalizer = ft_face_destroyed;
+              retval->generic.data = new ft_key (key);
+              retval->generic.finalizer = ft_face_destroyed;
 
-            // Insert loaded font into the cache.
+              // Insert loaded font into the cache.
 
-            cache[key] = retval;
-          }
+              cache[key] = retval;
+            }
 #endif
-      }
+        }
 
-    return retval;
-  }
+      return retval;
+    }
 
-  void do_font_destroyed (FT_Face face)
-  {
-    if (face->generic.data)
-      {
-        ft_key *pkey = reinterpret_cast<ft_key*> (face->generic.data);
+    void do_font_destroyed (FT_Face face)
+    {
+      if (face->generic.data)
+        {
+          ft_key *pkey = reinterpret_cast<ft_key*> (face->generic.data);
 
-        cache.erase (*pkey);
-        delete pkey;
-        face->generic.data = 0;
-      }
-  }
+          cache.erase (*pkey);
+          delete pkey;
+          face->generic.data = 0;
+        }
+    }
 
-private:
-  FT_Library library;
-  bool freetype_initialized;
-  bool fontconfig_initialized;
-};
+  private:
+    FT_Library library;
+    bool freetype_initialized;
+    bool fontconfig_initialized;
+  };
 
-ft_manager *ft_manager::instance = 0;
+  ft_manager *ft_manager::instance = 0;
 
 }
 
 static void
 ft_face_destroyed (void *object)
 {
   octave::ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
 }
@@ -342,19 +342,19 @@ namespace octave
       ROTATION_180 = 2,
       ROTATION_270 = 3
     };
 
   public:
 
     ft_text_renderer (void)
       : base_text_renderer (), font (), bbox (1, 4, 0.0), halign (0),
-      xoffset (0), line_yoffset (0), yoffset (0), mode (MODE_BBOX),
-      color (dim_vector (1, 3), 0)
-        { }
+        xoffset (0), line_yoffset (0), yoffset (0), mode (MODE_BBOX),
+        color (dim_vector (1, 3), 0)
+    { }
 
     ~ft_text_renderer (void) { }
 
     void visit (text_element_string& e);
 
     void visit (text_element_list& e);
 
     void visit (text_element_subscript& e);
@@ -1379,8 +1379,9 @@ namespace octave
   {
 #if defined (HAVE_FREETYPE)
     return new ft_text_renderer ();
 #else
     return 0;
 #endif
   }
 }
+
diff --git a/libinterp/corefcn/ft-text-renderer.h b/libinterp/corefcn/ft-text-renderer.h
--- a/libinterp/corefcn/ft-text-renderer.h
+++ b/libinterp/corefcn/ft-text-renderer.h
@@ -29,8 +29,9 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   class base_text_renderer;
 
   extern base_text_renderer *make_ft_text_renderer (void);
 }
 
 #endif
+
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -109,77 +109,85 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
       if (x_arg.is_scalar_type ())
         {
           float x = x_arg.float_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0f - octave::math::gammainc (x, a);
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0f - octave::math::gammainc (x, a);
             }
         }
       else
         {
           FloatNDArray x = x_arg.float_array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0f - octave::math::gammainc (x, a);
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0f - octave::math::gammainc (x, a);
             }
         }
     }
   else
     {
       if (x_arg.is_scalar_type ())
         {
           double x = x_arg.double_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0 - octave::math::gammainc (x, a);
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0 - octave::math::gammainc (x, a);
             }
         }
       else
         {
           NDArray x = x_arg.array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0 - octave::math::gammainc (x, a);
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a)
+                             : 1.0 - octave::math::gammainc (x, a);
             }
         }
     }
 
   return retval;
 }
 
 /*
@@ -198,8 +206,9 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 %! v1 = sqrt (pi ("single"))*erf (x)./gamma (a);
 %! v3 = gammainc (x.*x, a);
 %! assert (v1, v3, sqrt (eps ("single")));
 
 %!assert (gammainc (single (0:4), single (0.5), "upper"),
 %!        single (1)-gammainc (single (0:4), single (0.5)),
 %!        single (1e-7))
 */
+
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -70,18 +70,20 @@ divide (const std::complex<FP>& a, const
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
 simple_gcd (const std::complex<FP>& a, const std::complex<FP>& b)
 {
-  if (! octave::math::isinteger (a.real ()) || ! octave::math::isinteger (a.imag ())
-      || ! octave::math::isinteger (b.real ()) || ! octave::math::isinteger (b.imag ()))
+  if (! octave::math::isinteger (a.real ())
+      || ! octave::math::isinteger (a.imag ())
+      || ! octave::math::isinteger (b.real ())
+      || ! octave::math::isinteger (b.imag ()))
     error ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
 
   if (abs (aa) < abs (bb))
     std::swap (aa, bb);
 
@@ -149,18 +151,20 @@ extended_gcd (double a, double b, double
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
-  if (! octave::math::isinteger (a.real ()) || ! octave::math::isinteger (a.imag ())
-      || ! octave::math::isinteger (b.real ()) || ! octave::math::isinteger (b.imag ()))
+  if (! octave::math::isinteger (a.real ())
+      || ! octave::math::isinteger (a.imag ())
+      || ! octave::math::isinteger (b.real ())
+      || ! octave::math::isinteger (b.imag ()))
     error ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
@@ -269,20 +273,20 @@ do_simple_gcd (const octave_value& a, co
           break;
         }
       // fall through!
 
     case btyp_float:
       retval = do_simple_gcd<NDArray> (a, b);
       break;
 
-#define MAKE_INT_BRANCH(X)                              \
-      case btyp_ ## X:                                  \
-        retval = do_simple_gcd<X ## NDArray> (a, b);    \
-        break
+#define MAKE_INT_BRANCH(X)                            \
+    case btyp_ ## X:                                  \
+      retval = do_simple_gcd<X ## NDArray> (a, b);    \
+      break
 
     MAKE_INT_BRANCH (int8);
     MAKE_INT_BRANCH (int16);
     MAKE_INT_BRANCH (int32);
     MAKE_INT_BRANCH (int64);
     MAKE_INT_BRANCH (uint8);
     MAKE_INT_BRANCH (uint16);
     MAKE_INT_BRANCH (uint32);
@@ -381,20 +385,20 @@ do_extended_gcd (const octave_value& a, 
                                             b.builtin_type ());
   switch (btyp)
     {
     case btyp_double:
     case btyp_float:
       retval = do_extended_gcd<NDArray> (a, b, x, y);
       break;
 
-#define MAKE_INT_BRANCH(X)                                      \
-      case btyp_ ## X:                                          \
-        retval = do_extended_gcd<X ## NDArray> (a, b, x, y);    \
-        break
+#define MAKE_INT_BRANCH(X)                                    \
+    case btyp_ ## X:                                          \
+      retval = do_extended_gcd<X ## NDArray> (a, b, x, y);    \
+      break
 
     MAKE_INT_BRANCH (int8);
     MAKE_INT_BRANCH (int16);
     MAKE_INT_BRANCH (int32);
     MAKE_INT_BRANCH (int64);
     MAKE_INT_BRANCH (uint8);
     MAKE_INT_BRANCH (uint16);
     MAKE_INT_BRANCH (uint32);
@@ -524,8 +528,9 @@ gcd ([15, 9], [20, 18])
 %!error <all complex parts must be integers> gcd (e + i*pi, 1)
 
 %!error gcd ()
 
 %!test
 %! s.a = 1;
 %! fail ("gcd (s)");
 */
+
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -163,8 +163,9 @@ Close the group database.
 
   std::string msg;
 
   // octave::sys::group::endgrent may set msg.
   int status = octave::sys::group::endgrent (msg);
 
   return ovl (static_cast<double> (status), msg);
 }
+
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -167,8 +167,9 @@ Close the password database.
 
   std::string msg;
 
   // octave::sys::password::endpwent may set msg.
   int status = octave::sys::password::endpwent (msg);
 
   return ovl (static_cast<double> (status), msg);
 }
+
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -169,8 +169,9 @@ givens (1, 1)
 %!assert (givens (1,1), [1, 1; -1, 1] / sqrt (2), 2*eps)
 %!assert (givens (1,0), eye (2))
 %!assert (givens (0,1), [0, 1; -1 0])
 
 %!error givens ()
 %!error givens (1)
 %!error [a,b,c] = givens (1, 1)
 */
+
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -58,38 +58,38 @@ next_power_of_2 (int n)
 namespace octave
 {
 #if defined (HAVE_OPENGL)
 
 #define LIGHT_MODE GL_FRONT_AND_BACK
 
   // Use symbolic names for axes
   enum
-    {
-      X_AXIS,
-      Y_AXIS,
-      Z_AXIS
-    };
+  {
+    X_AXIS,
+    Y_AXIS,
+    Z_AXIS
+  };
 
   // Use symbolic names for color mode
   enum
-    {
-      UNIFORM,
-      FLAT,
-      INTERP,
-      TEXTURE
-    };
+  {
+    UNIFORM,
+    FLAT,
+    INTERP,
+    TEXTURE
+  };
 
   // Use symbolic names for lighting
   enum
-    {
-      NONE,
-      //FLAT,  // Already declared in anonymous enum for color mode
-      GOURAUD = 2
-    };
+  {
+    NONE,
+    //FLAT,  // Already declared in anonymous enum for color mode
+    GOURAUD = 2
+  };
 
   // Win32 API requires the CALLBACK attributes for
   // GLU callback functions.  Define it to empty on
   // other platforms.
 #if ! defined (CALLBACK)
 #  define CALLBACK
 #endif
 
@@ -1479,17 +1479,17 @@ namespace octave
         bool do_yminortick = props.is_yminortick ();
         Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
         Matrix ymticks = xform.yscale (props.get_ymtick ().matrix_value ());
         string_vector yticklabels = props.get_yticklabel ().string_vector_value ();
         int wmax = 0;
         int hmax = 0;
         bool tick_along_z = nearhoriz || octave::math::isinf (fx);
         bool mirror = props.is_box () && ystate != AXE_ANY_DIR
-          && (! props.has_property ("__plotyy_axes__"));
+                      && (! props.has_property ("__plotyy_axes__"));
 
         // set styles when drawing only minor grid
         if (do_yminorgrid && ! do_ygrid)
           {
             gridstyle = minorgridstyle;
             gridcolor = minorgridcolor;
             gridalpha = minorgridalpha;
             do_ygrid = true;
@@ -1719,17 +1719,18 @@ namespace octave
 
         gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
       }
     else
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
   }
 
   void
-  opengl_renderer::draw_all_lights (const base_properties& props, std::list<graphics_object>& obj_list)
+  opengl_renderer::draw_all_lights (const base_properties& props,
+                                    std::list<graphics_object>& obj_list)
   {
 #if defined (HAVE_OPENGL)
     Matrix children = props.get_all_children ();
 
     for (octave_idx_type i = children.numel () - 1; i >= 0; i--)
       {
         graphics_object go = gh_manager::get_object (children(i));
 
@@ -4098,8 +4099,9 @@ namespace octave
     // This shouldn't happen because construction of opengl_renderer
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 
 #endif
   }
 }
+
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -140,18 +140,20 @@ namespace octave
     // No copying!
 
     opengl_renderer (const opengl_renderer&);
 
     opengl_renderer& operator = (const opengl_renderer&);
 
     bool is_nan_or_inf (double x, double y, double z) const
     {
-      return (octave::math::isnan (x) || octave::math::isnan (y) || octave::math::isnan (z)
-              || octave::math::isinf (x) || octave::math::isinf (y) || octave::math::isinf (z));
+      return (octave::math::isnan (x) || octave::math::isnan (y)
+              || octave::math::isnan (z)
+              || octave::math::isinf (x) || octave::math::isinf (y)
+              || octave::math::isinf (z));
     }
 
     octave_uint8 clip_code (double x, double y, double z) const
     {
       return ((x < xmin ? 1 : 0)
               | (x > xmax ? 1 : 0) << 1
               | (y < ymin ? 1 : 0) << 2
               | (y > ymax ? 1 : 0) << 3
@@ -169,17 +171,18 @@ namespace octave
     void draw_axes_boxes (const axes::properties& props);
 
     void draw_axes_x_grid (const axes::properties& props);
     void draw_axes_y_grid (const axes::properties& props);
     void draw_axes_z_grid (const axes::properties& props);
 
     void draw_axes_children (const axes::properties& props);
 
-    void draw_all_lights (const base_properties& props, std::list<graphics_object>& obj_list);
+    void draw_all_lights (const base_properties& props,
+                          std::list<graphics_object>& obj_list);
 
   private:
     // The graphics toolkit associated with the figure being rendered.
     graphics_toolkit toolkit;
 
     // axes transformation data
     graphics_xform xform;
 
@@ -208,8 +211,9 @@ namespace octave
     int max_lights;
 
   private:
     class patch_tesselator;
   };
 }
 
 #endif
+
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -53,18 +53,18 @@ namespace octave
   class
   OCTINTERP_API
   gl2ps_renderer : public opengl_renderer
   {
   public:
 
     gl2ps_renderer (FILE *_fp, const std::string& _term)
       : octave::opengl_renderer () , fp (_fp), term (_term), fontsize (),
-      fontname (), buffer_overflow (false)
-      { }
+        fontname (), buffer_overflow (false)
+    { }
 
     ~gl2ps_renderer (void) { }
 
     // FIXME: should we import the functions from the base class and
     // overload them here, or should we use a different name so we don't
     // have to do this?  Without the using declaration or a name change,
     // the base class functions will be hidden.  That may be OK, but it
     // can also cause some confusion.
@@ -340,19 +340,19 @@ namespace octave
          p != lst.end (); p++)
       {
         // Get pixel coordinates
         ColumnVector coord_pix = get_transform ().transform (x, y, z, false);
 
         // Translate and rotate
         double rot = rotation * 4.0 * atan (1.0) / 180;
         coord_pix(0) += ((*p).get_x () + box(0))*cos (rot)
-          - ((*p).get_y () + box(1))*sin (rot);
+                        - ((*p).get_y () + box(1))*sin (rot);
         coord_pix(1) -= ((*p).get_y () + box(1))*cos (rot)
-          + ((*p).get_x () + box(0))*sin (rot);;
+                        + ((*p).get_x () + box(0))*sin (rot);;
 
         // Turn coordinates back into current gl coordinates
         ColumnVector coord =
           get_transform ().untransform (coord_pix(0), coord_pix(1),
                                         coord_pix(2), false);
         (*p).set_x (coord(0));
         (*p).set_y (coord(1));
         (*p).set_z (coord(2));
@@ -687,22 +687,22 @@ namespace octave
       (props.get ("fontangle").xtolower ().string_value () == "italic");
 
     fontname = select_font (fn, isbold, isitalic);
   }
 
   void
   gl2ps_renderer::draw_pixels (int w, int h, const float *data)
   {
-    // Clip data between 0 and 1 for float values 
+    // Clip data between 0 and 1 for float values
     OCTAVE_LOCAL_BUFFER (float, tmp_data, 3*w*h);
 
     for (int i = 0; i < 3*h*w; i++)
       tmp_data[i] = (data[i] < 0.0f ? 0.0f : (data[i] > 1.0f ? 1.0f : data[i]));
-        
+
     gl2psDrawPixels (w, h, 0, 0, GL_RGB, GL_FLOAT, tmp_data);
   }
 
   void
   gl2ps_renderer::draw_pixels (int w, int h, const uint8_t *data)
   {
     // gl2psDrawPixels only supports the GL_FLOAT type.
 
@@ -842,8 +842,9 @@ namespace octave
     // Make sure buffered commands are finished!!!
     rend.finish ();
 
 #else
     err_disabled_feature ("gl2ps_print", "gl2ps");
 #endif
   }
 }
+
diff --git a/libinterp/corefcn/gl2ps-print.h b/libinterp/corefcn/gl2ps-print.h
--- a/libinterp/corefcn/gl2ps-print.h
+++ b/libinterp/corefcn/gl2ps-print.h
@@ -38,13 +38,14 @@ namespace octave
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 inline void
 gl2ps_print (const graphics_object& fig, const std::string& stream,
              const std::string& term)
 {
   return octave::gl2ps_print (fig, stream, term);
-} 
+}
 
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -132,17 +132,18 @@ static Matrix
 viridis_colormap (void)
 {
   // The values below have been produced by viridis (64)(:)
   // It would be nice to be able to feval the
   // viridis function but since there is a static property object that includes
   // a colormap_property object, we need to initialize this before main is
   // even called, so calling an interpreted function is not possible.
 
-  const double cmapv[] = {
+  const double cmapv[] =
+  {
     2.67004010000000e-01, 2.72651720952381e-01, 2.77106307619048e-01,
     2.80356151428571e-01, 2.82390045238095e-01, 2.83204606666667e-01,
     2.82809341428571e-01, 2.81230763333333e-01, 2.78516153333333e-01,
     2.74735528571429e-01, 2.69981791904762e-01, 2.64368580952381e-01,
     2.58026184285714e-01, 2.51098684761905e-01, 2.43732853333333e-01,
     2.36073294285714e-01, 2.28263191428571e-01, 2.20424955714286e-01,
     2.12666598571429e-01, 2.05079113809524e-01, 1.97721880952381e-01,
     1.90631350000000e-01, 1.83819438571429e-01, 1.77272360952381e-01,
@@ -196,17 +197,18 @@ viridis_colormap (void)
     5.23924198571429e-01, 5.15966779523810e-01, 5.06924262857143e-01,
     4.96751861428571e-01, 4.85412122857143e-01, 4.72873300000000e-01,
     4.59105875238095e-01, 4.44095883333333e-01, 4.27825852857143e-01,
     4.10292713809524e-01, 3.91487632857143e-01, 3.71420688571429e-01,
     3.50098750000000e-01, 3.27544678571429e-01, 3.03798967142857e-01,
     2.78916748571429e-01, 2.53000856190476e-01, 2.26223670000000e-01,
     1.98879439523810e-01, 1.71494930000000e-01, 1.45037631428572e-01,
     1.21291048571429e-01, 1.03326155238095e-01, 9.53507900000000e-02,
-    1.00469958095238e-01, 1.17876387142857e-01, 1.43936200000000e-01};
+    1.00469958095238e-01, 1.17876387142857e-01, 1.43936200000000e-01
+  };
 
   // It would be nice if Matrix had a ctor allowing to do the
   // following without a copy
   Matrix cmap (64, 3, 0.0);
   std::copy (cmapv, cmapv + (64*3), cmap.fortran_vec ());
   return cmap;
 }
 
@@ -1563,17 +1565,17 @@ handle_property::do_set (const octave_va
           current_val = graphics_handle ();
           return true;
         }
       else
         return false;
     }
 
   double dv = v.xdouble_value ("set: invalid graphics handle for property \"%s\"",
-                              get_name ().c_str ());
+                               get_name ().c_str ());
 
   graphics_handle gh = gh_manager::lookup (dv);
 
   if (! (octave::math::isnan (gh.value ()) || gh.ok ()))
     error ("set: invalid graphics handle (= %g) for property \"%s\"",
            dv, get_name ().c_str ());
 
   if (current_val != gh)
@@ -1726,17 +1728,18 @@ property::create (const std::string& nam
   else if (type.compare ("double"))
     {
       double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
       retval = property (new double_property (name, h, dv));
     }
   else if (type.compare ("handle"))
     {
-      double hv = (args.length () > 0 ? args(0).double_value () : octave::numeric_limits<double>::NaN ());
+      double hv = args.length () > 0 ? args(0).double_value ()
+                                     : octave::numeric_limits<double>::NaN ();
 
       graphics_handle gh (hv);
 
       retval = property (new handle_property (name, h, gh));
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
@@ -2587,17 +2590,17 @@ xget (const graphics_handle& h, const ca
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
           const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
   graphics_handle h = octave::numeric_limits<double>::NaN ();
 
   double hv = ov.xdouble_value ("%s: %s must be a graphics handle",
-                               who.c_str (), pname.c_str ());
+                                who.c_str (), pname.c_str ());
 
   h = gh_manager::lookup (hv);
 
   if (! h.ok ())
     error ("%s: invalid graphics handle (= %g) for %s",
            who.c_str (), hv, pname.c_str ());
 
   graphics_object go = gh_manager::get_object (h);
@@ -2617,26 +2620,28 @@ reparent (const octave_value& ov, const 
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
   octave_value val = xget (0, "currentfigure");
 
-  return val.is_empty () ? octave::numeric_limits<double>::NaN () : val.double_value ();
+  return val.is_empty () ? octave::numeric_limits<double>::NaN ()
+                         : val.double_value ();
 }
 
 // This function is NOT equivalent to the scripting language function gca.
 graphics_handle
 gca (void)
 {
   octave_value val = xget (gcf (), "currentaxes");
 
-  return val.is_empty () ? octave::numeric_limits<double>::NaN () : val.double_value ();
+  return val.is_empty () ? octave::numeric_limits<double>::NaN ()
+                         : val.double_value ();
 }
 
 static void
 delete_graphics_object (const graphics_handle& h)
 {
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
@@ -5296,20 +5301,20 @@ axes::properties::update_camera (void)
   if (cameraupvectormode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0);
       double el = tview(1);
 
       if (el == 90 || el == -90)
         {
-          c_upv(0) =
-            -octave::math::signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
-          c_upv(1) =
-            octave::math::signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
+          c_upv(0) = -octave::math::signum (el)
+                     * sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
+          c_upv(1) = octave::math::signum (el)
+                     * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
         }
       else
         c_upv(2) = 1;
 
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
@@ -5956,28 +5961,28 @@ axes::properties::update_zlabel_position
       double angle = 0.0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
                                             (zpTickN + zpTick)/2);
           if (octave::math::isinf (fy))
-            p(0) += (octave::math::signum (xPlaneN - xPlane) * fx * ztickoffset);
+            p(0) += octave::math::signum (xPlaneN - xPlane) * fx * ztickoffset;
           else
-            p(1) += (octave::math::signum (yPlane - yPlaneN) * fy * ztickoffset);
+            p(1) += octave::math::signum (yPlane - yPlaneN) * fy * ztickoffset;
         }
       else
         {
           p = graphics_xform::xform_vector (xPlane, yPlaneN,
                                             (zpTickN + zpTick)/2);
           if (octave::math::isinf (fx))
-            p(1) += (octave::math::signum (yPlaneN - yPlane) * fy * ztickoffset);
+            p(1) += octave::math::signum (yPlaneN - yPlane) * fy * ztickoffset;
           else
-            p(0) += (octave::math::signum (xPlane - xPlaneN) * fx * ztickoffset);
+            p(0) += octave::math::signum (xPlane - xPlaneN) * fx * ztickoffset;
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
         case AXE_ANY_DIR:
           if (camAuto)
@@ -6752,17 +6757,18 @@ axes::properties::get_axis_limits (doubl
                                    double min_pos, double max_neg,
                                    bool logscale)
 {
   Matrix retval;
 
   double min_val = xmin;
   double max_val = xmax;
 
-  if (octave::math::isinf (min_val) && min_val > 0 && octave::math::isinf (max_val) && max_val < 0)
+  if (octave::math::isinf (min_val) && min_val > 0
+      && octave::math::isinf (max_val) && max_val < 0)
     {
       retval = default_lim (logscale);
       return retval;
     }
   else if (! (octave::math::isinf (min_val) || octave::math::isinf (max_val)))
     {
       if (logscale)
         {
@@ -9005,17 +9011,18 @@ uibuttongroup::properties::set_selectedo
     {
       graphics_object go (gh_manager::get_object (val));
       base_properties& gop = go.get_properties ();
 
       if (go.valid_object ()
           && gop.get_parent () == get___myhandle__ ()
           && go.isa ("uicontrol"))
         {
-          uicontrol::properties& cop = dynamic_cast<uicontrol::properties&> (go.get_properties ());
+          uicontrol::properties& cop
+            = dynamic_cast<uicontrol::properties&> (go.get_properties ());
           const caseless_str& style = cop.get_style ();
           if (style.compare ("radiobutton") || style.compare ("togglebutton"))
             {
               selectedobject = val;
               mark_modified ();
               return;
             }
         }
@@ -9643,17 +9650,18 @@ gh_manager::do_post_callback (const grap
 
               if (busy_action == "queue")
                 do_post_event (graphics_event::create_callback_event (h, name,
                                                                       data));
               else
                 {
                   caseless_str cname (name);
 
-                  if (cname.compare ("deletefcn") || cname.compare ("createfcn")
+                  if (cname.compare ("deletefcn")
+                      || cname.compare ("createfcn")
                       || (go.isa ("figure")
                           && (cname.compare ("closerequestfcn")
                               || cname.compare ("resizefcn"))))
                     do_post_event (
                       graphics_event::create_callback_event (h, name, data));
                 }
             }
         }
@@ -11777,8 +11785,9 @@ Undocumented internal function.
       double factor = args(2).scalar_value ();
 
       ax_props.zoom (mode, factor);
       Vdrawnow_requested = true;
     }
 
   return ovl ();
 }
+
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1920,32 +1920,32 @@ public:
                    const caseless_str& type,
                    const octave_value_list& args);
 
   property clone (void) const
   { return property (rep->clone ()); }
 
 #if 0
   const string_property& as_string_property (void) const
-    { return *(dynamic_cast<string_property*> (rep)); }
+  { return *(dynamic_cast<string_property*> (rep)); }
 
   const radio_property& as_radio_property (void) const
-    { return *(dynamic_cast<radio_property*> (rep)); }
+  { return *(dynamic_cast<radio_property*> (rep)); }
 
   const color_property& as_color_property (void) const
-    { return *(dynamic_cast<color_property*> (rep)); }
+  { return *(dynamic_cast<color_property*> (rep)); }
 
   const double_property& as_double_property (void) const
-    { return *(dynamic_cast<double_property*> (rep)); }
+  { return *(dynamic_cast<double_property*> (rep)); }
 
   const bool_property& as_bool_property (void) const
-    { return *(dynamic_cast<bool_property*> (rep)); }
+  { return *(dynamic_cast<bool_property*> (rep)); }
 
   const handle_property& as_handle_property (void) const
-    { return *(dynamic_cast<handle_property*> (rep)); }
+  { return *(dynamic_cast<handle_property*> (rep)); }
 #endif
 
 private:
   base_property *rep;
 };
 
 // ---------------------------------------------------------------------
 
@@ -3982,29 +3982,29 @@ public:
     void update_plotboxaspectratiomode (void) { sync_positions (); }
 
     void update_layer (void) { update_axes_layout (); }
     void update_yaxislocation (void)
     {
       // FIXME: Remove warning with "zero" in 4.6
       if (yaxislocation_is ("zero"))
         warning_with_id ("Octave:deprecated-property",
-            "Setting 'yaxislocation' to 'zero' is deprecated, "
-            "set to 'origin' instead.");
+                         "Setting 'yaxislocation' to 'zero' is deprecated, "
+                         "set to 'origin' instead.");
       sync_positions ();
       update_axes_layout ();
       update_ylabel_position ();
     }
     void update_xaxislocation (void)
     {
       // FIXME: Remove warning with "zero" in 4.6
       if (xaxislocation_is ("zero"))
         warning_with_id ("Octave:deprecated-property",
-            "Setting 'xaxislocation' to 'zero' is deprecated, "
-            "set to 'origin' instead.");
+                         "Setting 'xaxislocation' to 'zero' is deprecated, "
+                         "set to 'origin' instead.");
       sync_positions ();
       update_axes_layout ();
       update_xlabel_position ();
     }
 
     void update_xdir (void) { update_camera (); update_axes_layout (); }
     void update_ydir (void) { update_camera (); update_axes_layout (); }
     void update_zdir (void) { update_camera (); update_axes_layout (); }
@@ -6447,8 +6447,9 @@ OCTINTERP_API int calc_dimensions (const
 OCTINTERP_API graphics_handle gcf (void);
 
 // This function is NOT equivalent to the scripting language function gca.
 OCTINTERP_API graphics_handle gca (void);
 
 OCTINTERP_API void close_all_figures (void);
 
 #endif
+
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -228,8 +228,9 @@ OCTAVE_DEPRECATED ("use 'err_wrong_type_
 OCTAVE_NORETURN OCTINTERP_API extern void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 OCTAVE_DEPRECATED ("use 'err_wrong_type_arg_for_unary_op' instead")
 OCTAVE_NORETURN OCTINTERP_API extern void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
 #endif
+
diff --git a/libinterp/corefcn/gsvd.cc b/libinterp/corefcn/gsvd.cc
--- a/libinterp/corefcn/gsvd.cc
+++ b/libinterp/corefcn/gsvd.cc
@@ -33,18 +33,18 @@
 #include "ov.h"
 
 
 template <typename T>
 static typename gsvd<T>::Type
 gsvd_type (int nargout)
 {
   return ((nargout == 0 || nargout == 1)
-         ? gsvd<T>::Type::sigma_only
-         : (nargout > 5) ? gsvd<T>::Type::std : gsvd<T>::Type::economy);
+          ? gsvd<T>::Type::sigma_only
+          : (nargout > 5) ? gsvd<T>::Type::std : gsvd<T>::Type::economy);
 }
 
 
 DEFUN (gsvd, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{s} =} gsvd (@var{a}, @var{b})
 @deftypefnx {} {[@var{u}, @var{v}, @var{c}, @var{s}, @var{x}] =} gsvd (@var{a}, @var{b})
 @deftypefnx {} {[@var{u}, @var{v}, @var{c}, @var{s}, @var{x}, @var{r}] =} gsvd (@var{a}, @var{b})
@@ -177,24 +177,24 @@ routines.
   octave_idx_type nr = argA.rows ();
   octave_idx_type nc = argA.columns ();
 
   octave_idx_type np = argB.columns ();
 
   if (nr == 0 || nc == 0)
     {
       if (nargout == 5)
-          retval = ovl (identity_matrix (nc, nc), identity_matrix (nc, nc),
-                        Matrix (nr, nc), identity_matrix (nr, nr),
-                        identity_matrix (nr, nr));
+        retval = ovl (identity_matrix (nc, nc), identity_matrix (nc, nc),
+                      Matrix (nr, nc), identity_matrix (nr, nr),
+                      identity_matrix (nr, nr));
       else if (nargout == 6)
-          retval = ovl (identity_matrix (nc, nc), identity_matrix (nc, nc),
-                        Matrix (nr, nc), identity_matrix (nr, nr),
-                        identity_matrix (nr, nr),
-                        identity_matrix (nr, nr));
+        retval = ovl (identity_matrix (nc, nc), identity_matrix (nc, nc),
+                      Matrix (nr, nc), identity_matrix (nr, nr),
+                      identity_matrix (nr, nr),
+                      identity_matrix (nr, nr));
       else
         retval = ovl (Matrix (0, 1));
     }
   else
     {
       if (nc != np)
         print_usage ();
 
@@ -475,8 +475,9 @@ routines.
 %! [U, V, C, S, X, R] = gsvd (A, B);
 %! D1 = zeros(3, 4);  D1(1:3, 1:3) = C;
 %! D2 = eye (4);  D2(1:3, 1:3) = S;  D2(5,:) = 0;
 %! assert (norm (diag (C).^2 + diag (S).^2 - ones (3, 1)) <= 1e-6);
 %! assert (norm ((U'*A*X) - D1*[zeros(4, 1) R]) <= 1e-6);
 %! assert (norm ((V'*B*X) - D2*[zeros(4, 1) R]) <= 1e-6);
 
 */
+
diff --git a/libinterp/corefcn/hash.cc b/libinterp/corefcn/hash.cc
--- a/libinterp/corefcn/hash.cc
+++ b/libinterp/corefcn/hash.cc
@@ -231,8 +231,9 @@ hash ("md5", fileread (file));
 %!error hash ("", "", "")
 %!error hash (1, "")
 %!error hash ([1, 0; 0, 1], "")
 %!error hash ("unknown", "")
 %!error hash ("md5")
 %!error hash ("sha1")
 %!error hash ("sha512")
 */
+
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1031,8 +1031,9 @@ the @code{help} command and usage messag
 
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
+
diff --git a/libinterp/corefcn/help.h b/libinterp/corefcn/help.h
--- a/libinterp/corefcn/help.h
+++ b/libinterp/corefcn/help.h
@@ -49,8 +49,9 @@ extern OCTINTERP_API std::string Vinfo_f
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 extern OCTINTERP_API std::string Vinfo_program;
 
 extern OCTINTERP_API std::string do_which (const std::string& name);
 
 #endif
+
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -143,8 +143,9 @@ IEEE Transactions on Automatic Control, 
 %! a = single ([1, 2, 3; 5, 4, 6; 8, 7, 9]);
 %! [p, h] = hess (a);
 %! assert (p * h * p', a, sqrt (eps ("single")));
 
 %!error hess ()
 %!error hess ([1, 2; 3, 4], 2)
 %!error <must be a square matrix> hess ([1, 2; 3, 4; 5, 6])
 */
+
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -288,8 +288,9 @@ num2hex (single ([-1, 1, e, Inf]))
 /*
 %!assert (num2hex (-2:2), ["c000000000000000";"bff0000000000000";"0000000000000000";"3ff0000000000000";"4000000000000000"])
 %!assert (num2hex (single (-2:2)), ["c0000000";"bf800000";"00000000";"3f800000";"40000000"])
 
 %!error num2hex ()
 %!error num2hex (1,2)
 %!error num2hex (1j)
 */
+
diff --git a/libinterp/corefcn/hook-fcn.cc b/libinterp/corefcn/hook-fcn.cc
--- a/libinterp/corefcn/hook-fcn.cc
+++ b/libinterp/corefcn/hook-fcn.cc
@@ -36,8 +36,9 @@ hook_function::hook_function (const octa
     }
   else if (f.is_function_handle ())
     {
       rep = new fcn_handle_hook_function (f, d);
     }
   else
     error ("invalid hook function");
 }
+
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -257,8 +257,9 @@ public:
   }
 
 private:
 
   map_type fcn_map;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -459,18 +459,18 @@ generate_completion (const std::string& 
       while (list_index < name_list_total_len)
         {
           std::string name = name_list[list_index];
 
           list_index++;
 
           if (hint == name.substr (0, hint_len))
             {
-                    // Special case: array reference forces prefix="."
-                    //               in generate_struct_completions ()
+              // Special case: array reference forces prefix="."
+              //               in generate_struct_completions ()
               if (list_index <= name_list_len && ! prefix.empty ())
                 retval = (prefix == "." ? "" : prefix) + "." + name;
               else
                 retval = name;
 
               char prev_char = octave::command_editor::get_prev_char
                                                        (text.length ());
               if (matches == 1 && looks_like_struct (retval, prev_char))
@@ -1578,8 +1578,9 @@ The original variable value is restored 
   if (::isalnum (Vfilemarker) || Vfilemarker == '_')
     {
       Vfilemarker = tmp;
       error ("filemarker: character can not be a valid character for a function name");
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -288,8 +288,9 @@ public:
   }
 
 private:
 
   octave_base_reader *rep;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -1083,8 +1083,9 @@ namespace octave
       }
     else
       {
         if (octave_exit)
           (*octave_exit) (status);
       }
   }
 }
+
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -134,8 +134,9 @@ namespace octave
     // TRUE means this is an interactive interpreter (forced or not).
     bool m_interactive;
 
     bool m_quitting_gracefully;
   };
 }
 
 #endif
+
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -233,8 +233,9 @@ DEFUN (inverse, args, nargout,
 Compute the inverse of the square matrix @var{A}.
 
 This is an alias for @code{inv}.
 @seealso{inv}
 @end deftypefn */)
 {
   return Finv (args, nargout);
 }
+
diff --git a/libinterp/corefcn/jit-ir.cc b/libinterp/corefcn/jit-ir.cc
--- a/libinterp/corefcn/jit-ir.cc
+++ b/libinterp/corefcn/jit-ir.cc
@@ -838,8 +838,9 @@ jit_magic_end::print (std::ostream& os, 
 const jit_function&
 jit_magic_end::overload () const
 {
   const context& ctx = resolve_context ();
   return jit_typeinfo::end (ctx.value, ctx.index, ctx.count);
 }
 
 #endif
+
diff --git a/libinterp/corefcn/jit-ir.h b/libinterp/corefcn/jit-ir.h
--- a/libinterp/corefcn/jit-ir.h
+++ b/libinterp/corefcn/jit-ir.h
@@ -1437,8 +1437,9 @@ jit_const<T, EXTRACT_T, PASS_T, QUOTE>::
 {
   walker.visit (*this);
 }
 
 #undef JIT_VALUE_ACCEPT
 
 #endif
 #endif
+
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -2237,8 +2237,9 @@ jit_typeinfo::do_type_of (const octave_v
       if (cv.imag () != 0)
         return get_complex ();
     }
 
   return get_any ();
 }
 
 #endif
+
diff --git a/libinterp/corefcn/jit-typeinfo.h b/libinterp/corefcn/jit-typeinfo.h
--- a/libinterp/corefcn/jit-typeinfo.h
+++ b/libinterp/corefcn/jit-typeinfo.h
@@ -844,8 +844,9 @@ private:
   // type id -> identity function
   std::vector<jit_function> identities;
 
   llvm::IRBuilderD& builder;
 };
 
 #endif
 #endif
+
diff --git a/libinterp/corefcn/jit-util.cc b/libinterp/corefcn/jit-util.cc
--- a/libinterp/corefcn/jit-util.cc
+++ b/libinterp/corefcn/jit-util.cc
@@ -44,8 +44,9 @@ std::ostream&
 operator<< (std::ostream& os, const llvm::Value& v)
 {
   llvm::raw_os_ostream llvm_out (os);
   v.print (llvm_out);
   return os;
 }
 
 #endif
+
diff --git a/libinterp/corefcn/jit-util.h b/libinterp/corefcn/jit-util.h
--- a/libinterp/corefcn/jit-util.h
+++ b/libinterp/corefcn/jit-util.h
@@ -211,8 +211,9 @@ bool isa (U *value)
   {                                                                     \
     std::vector<type> the_args (N);                                     \
     OCT_ITERATE_MACRO (JIT_ASSIGN_ARG, N);                              \
     return fname (JIT_PARAMS the_args);                                 \
   }
 
 #endif
 #endif
+
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -317,8 +317,9 @@ Since the Kronecker product is associati
 %!test
 %! expected = zeros (16, 16);
 %! expected (1, 11) = 3;
 %! expected (2, 12) = 4;
 %! expected (5, 15) = 6;
 %! expected (6, 16) = 8;
 %! assert (kron (diag ([1, 2], 2), diag ([3, 4], 2)), expected);
 */
+
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -848,17 +848,18 @@ load_path::loader::remove_method_map (co
   for (method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
 
-      std::string full_dir_name = octave::sys::file_ops::concat (dir, "@" + class_name);
+      std::string full_dir_name
+        = octave::sys::file_ops::concat (dir, "@" + class_name);
 
       for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
         {
           file_info_list_type& file_info_list = q->second;
 
           if (file_info_list.size () == 1)
             continue;
           else
@@ -1335,17 +1336,18 @@ load_path::do_find_file (const std::stri
   else
     {
       std::string tfile = find_private_file (file);
 
       if (! tfile.empty ())
         return tfile;
     }
 
-  if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
+  if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+      != std::string::npos)
     {
       // Given name has a directory separator, so append it to each
       // element of the load path in turn.
 
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
@@ -1486,17 +1488,18 @@ load_path::do_find_first_of (const strin
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
-      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+          != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
               octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 return file;
@@ -1565,17 +1568,18 @@ load_path::do_find_all_first_of (const s
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
-      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+          != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
               octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 retlist.push_back (file);
@@ -2560,8 +2564,9 @@ DEFUN (__dump_load_path__, , ,
 @deftypefn {} {} __dump_load_path__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
   load_path::display (octave_stdout);
 
   return ovl ();
 }
+
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -735,8 +735,9 @@ private:
 
   friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
 };
 
 extern std::string
 genpath (const std::string& dir, const string_vector& skip = "private");
 
 #endif
+
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1839,8 +1839,9 @@ omitted from text-format data files.  Th
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{strftime, save}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (save_header_format_string);
 }
+
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -92,8 +92,9 @@ do_save (std::ostream& os, const symbol_
 extern void
 write_header (std::ostream& os, load_save_format format);
 
 extern void octave_prepare_hdf5 (void);
 
 extern void octave_finalize_hdf5 (void);
 
 #endif
+
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -381,8 +381,9 @@ at most n-1).
 %!assert (lookup (4:-1:1, [1, 1.2; 3, 2.5], "m"), [4, 0; 2, 0])
 %!assert (lookup (1:4, [1, 1.2; 3, 2.5], "b"), logical ([1, 0; 3, 0]))
 %!assert (lookup (4:-1:1, [1, 1.2; 3, 2.5], "b"), logical ([4, 0; 2, 0]))
 %!
 %!assert (lookup ({"apple","lemon","orange"}, {"banana","kiwi"; "ananas","mango"}), [1,1;0,2])
 %!assert (lookup ({"apple","lemon","orange"}, "potato"), 3)
 %!assert (lookup ({"orange","lemon","apple"}, "potato"), 0)
 */
+
diff --git a/libinterp/corefcn/ls-ascii-helper.cc b/libinterp/corefcn/ls-ascii-helper.cc
--- a/libinterp/corefcn/ls-ascii-helper.cc
+++ b/libinterp/corefcn/ls-ascii-helper.cc
@@ -166,8 +166,9 @@ read_until_newline (std::istream& is, bo
           char d;
           is.get (d);
           buf << d;
         }
     }
 
   return buf.str ();
 }
+
diff --git a/libinterp/corefcn/ls-ascii-helper.h b/libinterp/corefcn/ls-ascii-helper.h
--- a/libinterp/corefcn/ls-ascii-helper.h
+++ b/libinterp/corefcn/ls-ascii-helper.h
@@ -33,8 +33,9 @@ skip_until_newline (std::istream& is, bo
 
 extern OCTINTERP_API void
 skip_preceeding_newline (std::istream& is);
 
 extern OCTINTERP_API std::string
 read_until_newline (std::istream& is, bool keep_newline = false);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -1066,18 +1066,18 @@ add_hdf5_data (octave_hdf5_id loc_id, co
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
   std::string t = val.type_name ();
 #if defined (HAVE_HDF5_18)
-  data_id = H5Gcreate (loc_id, name.c_str (), octave_H5P_DEFAULT, octave_H5P_DEFAULT,
-                       octave_H5P_DEFAULT);
+  data_id = H5Gcreate (loc_id, name.c_str (), octave_H5P_DEFAULT,
+                       octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
 #endif
   if (data_id < 0)
     goto error_cleanup;
 
   // attach the type of the variable
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
@@ -1085,22 +1085,25 @@ add_hdf5_data (octave_hdf5_id loc_id, co
     goto error_cleanup;
 
   dims[0] = 0;
   space_id = H5Screate_simple (0 , dims, 0);
   if (space_id < 0)
     goto error_cleanup;
 #if defined (HAVE_HDF5_18)
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
-                            octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                            octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                            octave_H5P_DEFAULT);
 #else
-  data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, octave_H5P_DEFAULT);
+  data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
+                            octave_H5P_DEFAULT);
 #endif
-  if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, octave_H5S_ALL, octave_H5S_ALL,
-                                    octave_H5P_DEFAULT, t.c_str ()) < 0)
+  if (data_type_id < 0
+      || H5Dwrite (data_type_id, type_id, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
 
   // Now call the real function to save the variable
   retval = val.save_hdf5 (data_id, "value", save_as_floats);
 
   // attach doc string as comment:
   if (retval && doc.length () > 0
       && H5Gset_comment (loc_id, name.c_str (), doc.c_str ()) < 0)
@@ -1156,8 +1159,9 @@ save_hdf5_data (std::ostream& os, const 
                         mark_as_global, save_as_floats);
 
 #else
   err_disabled_feature ("save_hdf5_data", "HDF5");
 #endif
 }
 
 #endif
+
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -158,8 +158,9 @@ extern OCTINTERP_API octave_hdf5_err
 hdf5_add_attr (octave_hdf5_id loc_id, const char *attr_name);
 
 
 extern OCTINTERP_API octave_hdf5_err
 hdf5_add_scalar_attr (octave_hdf5_id loc_id, octave_hdf5_id type_id,
                       const char *attr_name, void *buf);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -405,8 +405,9 @@ looks_like_mat_ascii_file (std::istream&
   octave_idx_type nr = 0;
   octave_idx_type nc = 0;
 
   get_lines_and_columns (is, nr, nc, filename, true, true);
   retval = (nr != 0 && nc != 0);
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/ls-mat-ascii.h b/libinterp/corefcn/ls-mat-ascii.h
--- a/libinterp/corefcn/ls-mat-ascii.h
+++ b/libinterp/corefcn/ls-mat-ascii.h
@@ -32,8 +32,9 @@ read_mat_ascii_data (std::istream& is, c
 extern bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val_arg,
                      int precision, bool tabs = false);
 
 extern bool looks_like_mat_ascii_file (std::istream& is,
                                        const std::string& filename);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -567,8 +567,9 @@ save_mat_binary_data (std::ostream& os, 
       os.write (reinterpret_cast<const char *> (m.data ()), n_bytes);
     }
   else
     // FIXME: Should this just error out rather than warn?
     warn_wrong_type_arg ("save", tc);
 
   return ! os.fail ();
 }
+
diff --git a/libinterp/corefcn/ls-mat4.h b/libinterp/corefcn/ls-mat4.h
--- a/libinterp/corefcn/ls-mat4.h
+++ b/libinterp/corefcn/ls-mat4.h
@@ -40,8 +40,9 @@ extern std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
                       octave_value& tc);
 
 extern bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
                       const std::string& name);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-mat5.h b/libinterp/corefcn/ls-mat5.h
--- a/libinterp/corefcn/ls-mat5.h
+++ b/libinterp/corefcn/ls-mat5.h
@@ -56,8 +56,9 @@ read_mat5_binary_element (std::istream& 
                           bool swap, bool& global, octave_value& tc);
 extern bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
                           bool save_as_floats, bool compressing = false);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -297,8 +297,9 @@ save_binary_data (std::ostream& os, cons
   // The octave_value of tc is const.  Make a copy...
   octave_value val = tc;
 
   // Call specific save function
   bool success = val.save_binary (os, save_as_floats);
 
   return (os && success);
 }
+
diff --git a/libinterp/corefcn/ls-oct-binary.h b/libinterp/corefcn/ls-oct-binary.h
--- a/libinterp/corefcn/ls-oct-binary.h
+++ b/libinterp/corefcn/ls-oct-binary.h
@@ -32,8 +32,9 @@ save_binary_data (std::ostream& os, cons
 
 extern OCTINTERP_API std::string
 read_binary_data (std::istream& is, bool swap,
                   octave::mach_info::float_format fmt,
                   const std::string& filename, bool& global,
                   octave_value& tc, std::string& doc);
 
 #endif
+
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -229,17 +229,17 @@ extract_keyword (std::istream& is, const
 
 // Ugh.  The signature of the compare method is not standard in older
 // versions of the GNU libstdc++.  Do this instead:
 
 #define SUBSTRING_COMPARE_EQ(s, pos, n, t) (s.substr (pos, n) == t)
 
 std::string
 read_text_data (std::istream& is, const std::string& filename, bool& global,
-                 octave_value& tc, octave_idx_type count)
+                octave_value& tc, octave_idx_type count)
 {
   // Read name for this entry or break on EOF.
 
   std::string name = extract_keyword (is, "name");
 
   if (name.empty ())
     {
       if (count == 0)
@@ -409,8 +409,9 @@ keep when saving data in text format.
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1,
                                             std::numeric_limits<int>::max ());
 }
+
diff --git a/libinterp/corefcn/ls-oct-text.h b/libinterp/corefcn/ls-oct-text.h
--- a/libinterp/corefcn/ls-oct-text.h
+++ b/libinterp/corefcn/ls-oct-text.h
@@ -44,25 +44,25 @@ along with Octave; see the file COPYING.
 #endif
 
 extern OCTINTERP_API std::string
 extract_keyword (std::istream& is, const char *keyword,
                  const bool next_only = false);
 
 extern OCTINTERP_API std::string
 read_text_data (std::istream& is, const std::string& filename, bool& global,
-                 octave_value& tc, octave_idx_type count);
+                octave_value& tc, octave_idx_type count);
 
 extern OCTINTERP_API bool
 save_text_data (std::ostream& os, const octave_value& val_arg,
-                 const std::string& name, bool mark_as_global, int precision);
+                const std::string& name, bool mark_as_global, int precision);
 
 extern OCTINTERP_API bool
 save_text_data_for_plotting (std::ostream& os, const octave_value& t,
-                              const std::string& name);
+                             const std::string& name);
 
 extern OCTINTERP_API bool
 save_three_d (std::ostream& os, const octave_value& t,
               bool parametric = false);
 
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
@@ -184,8 +184,9 @@ extract_keyword (std::istream& is, const
           if (next_only)
             break;
         }
     }
   return status;
 }
 
 #endif
+
diff --git a/libinterp/corefcn/ls-utils.cc b/libinterp/corefcn/ls-utils.cc
--- a/libinterp/corefcn/ls-utils.cc
+++ b/libinterp/corefcn/ls-utils.cc
@@ -81,8 +81,9 @@ get_save_type (float /* max_val */, floa
   //    st = LS_CHAR;
   //  else if (max_val < 32768 && min_val >= -32768)
   //    st = LS_SHORT;
   //  else if (max_val <= 2147483647L && min_val >= -2147483647L)
   //    st = LS_INT;
 
   return st;
 }
+
diff --git a/libinterp/corefcn/ls-utils.h b/libinterp/corefcn/ls-utils.h
--- a/libinterp/corefcn/ls-utils.h
+++ b/libinterp/corefcn/ls-utils.h
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 extern save_type
 get_save_type (double max_val, double min_val);
 
 extern save_type
 get_save_type (float max_val, float min_val);
 
 #endif
+
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -504,8 +504,9 @@ parameters for @code{lsode}.
 %! assert (x, y, tol);
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
 %! assert (lsode_options ("absolute tolerance") == eps);
 
 %!error lsode_options ("foo", 1, 2)
 */
+
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -211,20 +211,20 @@ permutation information.
                         fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseMatrix L = fact.L ();
 
                   if (nargout == 2)
-                      retval(0)
-                        = octave_value (P.transpose () * L,
-                            MatrixType (MatrixType::Permuted_Lower,
-                                        nr, fact.row_perm ()));
+                    retval(0)
+                      = octave_value (P.transpose () * L,
+                                      MatrixType (MatrixType::Permuted_Lower,
+                                                  nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
                       if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
@@ -259,17 +259,19 @@ permutation information.
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           if (nargout < 4)
             {
               ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit(i) = i;
-              octave::math::sparse_lu<SparseComplexMatrix> fact (m, Qinit, thres, false, true);
+              octave::math::sparse_lu<SparseComplexMatrix> fact (m, Qinit,
+                                                                 thres, false,
+                                                                 true);
 
               if (nargout < 2)
                 retval(0) = fact.Y ();
               else
                 {
                   retval.resize (nargout == 3 ? 3 : 2);
                   retval(1)
                     = octave_value (
@@ -813,8 +815,9 @@ factorization from scratch.
 %!
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu (single (Ac));
 %! [L,U,P] = luupdate (L,U,P,single (uc),single (vc));
 %! assert (norm (vec (tril (L)-L), Inf) == 0);
 %! assert (norm (vec (triu (U)-U), Inf) == 0);
 %! assert (norm (vec (P'*L*U - single (Ac) - single (uc)*single (vc).'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
+
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -552,8 +552,9 @@ LU@tie{}factorization.  Once the matrix 
 %!assert (matrix_type (tril (1i*ones (10,10))), "Lower")
 %!assert (matrix_type (tril (1i*ones (10,10),1)), "Full")
 %!assert (matrix_type (10*eye (10,10) + 1i*triu (ones (10,10),1) -1i*tril (ones (10,10),-1)), "Positive Definite")
 %!assert (matrix_type (ones (11,10)), "Rectangular")
 %!test
 %! a = matrix_type (ones (10,10), "Singular");
 %! assert (matrix_type (a), "Singular");
 */
+
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -316,21 +316,20 @@ do_minmax_body (const octave_value_list&
           retval = do_minmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
                                                           ismin);
           break;
 
         case btyp_char:
           retval = do_minmax_red_op<charNDArray> (arg, nargout, dim, ismin);
           break;
 
-#define MAKE_INT_BRANCH(X)                                              \
-          case btyp_ ## X:                                              \
-            retval = do_minmax_red_op<X ## NDArray> (arg, nargout, dim, \
-                                                     ismin);            \
-            break;
+#define MAKE_INT_BRANCH(X)                                                    \
+        case btyp_ ## X:                                                      \
+          retval = do_minmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
+          break;
 
         MAKE_INT_BRANCH (int8);
         MAKE_INT_BRANCH (int16);
         MAKE_INT_BRANCH (int32);
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
@@ -393,20 +392,20 @@ do_minmax_body (const octave_value_list&
         case btyp_float_complex:
           retval = do_minmax_bin_op<FloatComplexNDArray> (argx, argy, ismin);
           break;
 
         case btyp_char:
           retval = do_minmax_bin_op<charNDArray> (argx, argy, ismin);
           break;
 
-#define MAKE_INT_BRANCH(X)                                              \
-          case btyp_ ## X:                                              \
-            retval = do_minmax_bin_op<X ## NDArray> (argx, argy, ismin); \
-            break;
+#define MAKE_INT_BRANCH(X)                                             \
+        case btyp_ ## X:                                               \
+          retval = do_minmax_bin_op<X ## NDArray> (argx, argy, ismin); \
+          break;
 
         MAKE_INT_BRANCH (int8);
         MAKE_INT_BRANCH (int16);
         MAKE_INT_BRANCH (int32);
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
@@ -946,21 +945,20 @@ do_cumminmax_body (const octave_value_li
       retval = do_cumminmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
       break;
 
     case btyp_float_complex:
       retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
                                                          ismin);
       break;
 
-#define MAKE_INT_BRANCH(X)                                              \
-      case btyp_ ## X:                                                  \
-        retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim,  \
-                                                    ismin);             \
-        break;
+#define MAKE_INT_BRANCH(X)                                                   \
+    case btyp_ ## X:                                                         \
+      retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
+      break;
 
       MAKE_INT_BRANCH (int8);
       MAKE_INT_BRANCH (int16);
       MAKE_INT_BRANCH (int32);
       MAKE_INT_BRANCH (int64);
       MAKE_INT_BRANCH (uint8);
       MAKE_INT_BRANCH (uint16);
       MAKE_INT_BRANCH (uint32);
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3412,8 +3412,9 @@ mexUnlock (void)
             {
               munlock (fname);
 
               mex_lock_count.erase (p);
             }
         }
     }
 }
+
diff --git a/libinterp/corefcn/mex.h b/libinterp/corefcn/mex.h
--- a/libinterp/corefcn/mex.h
+++ b/libinterp/corefcn/mex.h
@@ -178,8 +178,9 @@ void mexFunction (int nlhs, mxArray* plh
 #  define int8_T int8_t
 #endif
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/mexproto.h b/libinterp/corefcn/mexproto.h
--- a/libinterp/corefcn/mexproto.h
+++ b/libinterp/corefcn/mexproto.h
@@ -308,8 +308,9 @@ mxCalcSingleSubscript (const mxArray *pt
 
 extern OCTINTERP_API size_t mxGetElementSize (const mxArray *ptr);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -136,8 +136,9 @@ On exit, @var{y} is a unit vector such t
 %!test
 %! a = hilb (5);
 %! a(:, 1) /= norm (a(:, 1));
 %! for ii = 1:5
 %!   a(:, ii) = mgorth (a(:, ii), a(:, 1:ii-1));
 %! endfor
 %! assert (a' * a, eye (5), 1e10);
 */
+
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -535,8 +535,9 @@ private:
   mxArray& operator = (const mxArray&);
 };
 
 #undef DO_MUTABLE_METHOD
 #undef DO_VOID_MUTABLE_METHOD
 
 #endif
 #endif
+
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -93,8 +93,9 @@ same as @code{current}, but overridable 
 %!     setenv ("OMP_NUM_THREADS", old_val);
 %!   else
 %!     unsetenv ("OMP_NUM_THREADS");
 %!   endif
 %! end_unwind_protect
 
 %!error nproc ("no_valid_option")
 */
+
diff --git a/libinterp/corefcn/oct-errno.h b/libinterp/corefcn/oct-errno.h
--- a/libinterp/corefcn/oct-errno.h
+++ b/libinterp/corefcn/oct-errno.h
@@ -67,8 +67,9 @@ private:
   static octave_errno *instance;
 
   int do_lookup (const std::string& name);
 
   octave_scalar_map do_list (void);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-errno.in.cc b/libinterp/corefcn/oct-errno.in.cc
--- a/libinterp/corefcn/oct-errno.in.cc
+++ b/libinterp/corefcn/oct-errno.in.cc
@@ -334,8 +334,9 @@ octave_errno::do_list (void)
        p != errno_tbl.end ();
        p++)
     {
       retval.assign (p->first, p->second);
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -101,8 +101,9 @@ octave_fstream::output_stream (void)
 {
   std::ostream *retval = 0;
 
   if (mode () & std::ios::out)
     retval = &fs;
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -81,8 +81,9 @@ private:
   // No copying!
 
   octave_fstream (const octave_fstream&);
 
   octave_fstream& operator = (const octave_fstream&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -144,8 +144,9 @@ operator >= (const octave_handle& a, con
 
 inline bool
 operator > (const octave_handle& a, const octave_handle& b)
 {
   return a.value () > b.value ();
 }
 
 #endif
+
diff --git a/libinterp/corefcn/oct-hdf5-types.cc b/libinterp/corefcn/oct-hdf5-types.cc
--- a/libinterp/corefcn/oct-hdf5-types.cc
+++ b/libinterp/corefcn/oct-hdf5-types.cc
@@ -59,8 +59,9 @@ check_hdf5_types (bool warn)
 
 #endif
 
       checked = true;
     }
 
   return ok;
 }
+
diff --git a/libinterp/corefcn/oct-hdf5-types.h b/libinterp/corefcn/oct-hdf5-types.h
--- a/libinterp/corefcn/oct-hdf5-types.h
+++ b/libinterp/corefcn/oct-hdf5-types.h
@@ -46,8 +46,9 @@ extern const octave_hdf5_id octave_H5E_D
 extern const octave_hdf5_id octave_H5P_DEFAULT;
 extern const octave_hdf5_id octave_H5S_ALL;
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/oct-hdf5.h b/libinterp/corefcn/oct-hdf5.h
--- a/libinterp/corefcn/oct-hdf5.h
+++ b/libinterp/corefcn/oct-hdf5.h
@@ -37,8 +37,9 @@ along with Octave; see the file COPYING.
 #    define H5T_NATIVE_IDX H5T_NATIVE_INT64
 #  else
 #    define H5T_NATIVE_IDX H5T_NATIVE_INT
 #  endif
 
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -76,17 +76,17 @@ default_history_file (void)
 
   std::string env_file = octave::sys::env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
     file = env_file;
 
   if (file.empty ())
     file = octave::sys::file_ops::concat (octave::sys::env::get_home_directory (),
-                             ".octave_hist");
+                                          ".octave_hist");
 
   return file;
 }
 
 static int
 default_history_size (void)
 {
   int size = 1000;
@@ -841,8 +841,9 @@ The original variable value is restored 
 
   retval = set_internal_variable (tmp, args, nargout, "history_save");
 
   if (tmp != old_history_save)
     octave::command_history::ignore_entries (! tmp);
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/oct-hist.h b/libinterp/corefcn/oct-hist.h
--- a/libinterp/corefcn/oct-hist.h
+++ b/libinterp/corefcn/oct-hist.h
@@ -33,8 +33,9 @@ extern void initialize_history (bool rea
 
 // Write timestamp to history file.
 extern void octave_history_write_timestamp (void);
 
 // TRUE means input is coming from temporary history file.
 extern bool input_from_tmp_history_file;
 
 #endif
+
diff --git a/libinterp/corefcn/oct-iostrm.cc b/libinterp/corefcn/oct-iostrm.cc
--- a/libinterp/corefcn/oct-iostrm.cc
+++ b/libinterp/corefcn/oct-iostrm.cc
@@ -83,8 +83,9 @@ octave_ostream::eof (void) const
   return os && os->eof ();
 }
 
 octave_stream
 octave_ostream::create (std::ostream *arg, const std::string& n)
 {
   return octave_stream (new octave_ostream (arg, n));
 }
+
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -149,8 +149,9 @@ private:
   // No copying!
 
   octave_ostream (const octave_ostream&);
 
   octave_ostream& operator = (const octave_ostream&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-lvalue.cc b/libinterp/corefcn/oct-lvalue.cc
--- a/libinterp/corefcn/oct-lvalue.cc
+++ b/libinterp/corefcn/oct-lvalue.cc
@@ -100,8 +100,9 @@ octave_lvalue::value (void) const
               if (t.length () > 0)
                 retval = t(0);
             }
         }
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -107,8 +107,9 @@ private:
   std::string type;
 
   std::list<octave_value_list> idx;
 
   octave_idx_type nel;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -468,8 +468,9 @@ private:
                       const octave_map *map_list, octave_map& retval);
 };
 
 template <>
 inline octave_map octave_value_extract<octave_map> (const octave_value& v)
 { return v.map_value (); }
 
 #endif
+
diff --git a/libinterp/corefcn/oct-obj.h b/libinterp/corefcn/oct-obj.h
--- a/libinterp/corefcn/oct-obj.h
+++ b/libinterp/corefcn/oct-obj.h
@@ -30,8 +30,9 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #warning oct-obj.h has been deprecated; use ovl.h instead
 
 #include "ovl.h"
 
 #endif
+
diff --git a/libinterp/corefcn/oct-opengl.h b/libinterp/corefcn/oct-opengl.h
--- a/libinterp/corefcn/oct-opengl.h
+++ b/libinterp/corefcn/oct-opengl.h
@@ -39,8 +39,9 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_GL_GLEXT_H)
 #  include <GL/glext.h>
 #elif defined (HAVE_OPENGL_GLEXT_H) || defined (HAVE_FRAMEWORK_OPENGL)
 #  include <OpenGL/glext.h>
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/oct-prcstrm.cc b/libinterp/corefcn/oct-prcstrm.cc
--- a/libinterp/corefcn/oct-prcstrm.cc
+++ b/libinterp/corefcn/oct-prcstrm.cc
@@ -63,8 +63,9 @@ octave_oprocstream::octave_oprocstream (
                         arg_md, ff, octave_pclose)
 {
 }
 
 octave_oprocstream::~octave_oprocstream (void)
 {
   do_close ();
 }
+
diff --git a/libinterp/corefcn/oct-prcstrm.h b/libinterp/corefcn/oct-prcstrm.h
--- a/libinterp/corefcn/oct-prcstrm.h
+++ b/libinterp/corefcn/oct-prcstrm.h
@@ -82,8 +82,9 @@ private:
   // No copying!
 
   octave_oprocstream (const octave_oprocstream&);
 
   octave_oprocstream& operator = (const octave_oprocstream&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -225,8 +225,9 @@ octave_procbuf::close (void)
   return this;
 
 #else
 
   return 0;
 
 #endif
 }
+
diff --git a/libinterp/corefcn/oct-procbuf.h b/libinterp/corefcn/oct-procbuf.h
--- a/libinterp/corefcn/oct-procbuf.h
+++ b/libinterp/corefcn/oct-procbuf.h
@@ -74,8 +74,9 @@ private:
   octave_procbuf (const octave_procbuf&);
 
   octave_procbuf& operator = (const octave_procbuf&);
 };
 
 extern void symbols_of_oct_procbuf (void);
 
 #endif
+
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -173,8 +173,9 @@ private:
   octave_zstdiostream (const octave_zstdiostream&);
 
   octave_zstdiostream& operator = (const octave_zstdiostream&);
 };
 
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -1610,20 +1610,20 @@ namespace octave
   // A single conversion specifier, such as %f or %c.
 
   class
   textscan_format_elt
   {
   public:
 
     enum special_conversion
-      {
-        whitespace_conversion = 1,
-        literal_conversion = 2
-      };
+    {
+      whitespace_conversion = 1,
+      literal_conversion = 2
+    };
 
     textscan_format_elt (const std::string& txt, int w = 0, int p = -1,
                          int bw = 0, bool dis = false, char typ = '\0',
                          const std::string& ch_class = std::string ())
       : text (txt), width (w), prec (p), bitwidth (bw),
         char_class (ch_class), type (typ), discard (dis),
         numeric (typ == 'd' || typ == 'u' || type == 'f' || type == 'n')
     { }
@@ -2055,17 +2055,18 @@ namespace octave
                                          bool discard, char type,
                                          const std::string& char_class)
   {
     std::string text = buf.str ();
 
     if (! text.empty ())
       {
         textscan_format_elt *elt
-          = new textscan_format_elt (text, width, prec, bitwidth, discard, type, char_class);
+          = new textscan_format_elt (text, width, prec, bitwidth, discard, type,
+                                     char_class);
 
         if (! discard)
           output_container.push_back (val_type);
 
         fmt_elts.push_back (elt);
       }
 
     buf.clear ();
@@ -2705,17 +2706,17 @@ namespace octave
     Array<octave_idx_type> ra_idx (dim_vector (1,2));
 
     // (err & 1) means "error, and no columns read this row
     // FIXME: This may redundant now that done_after=0 says the same
     if (err & 1)
       done_after = out.size () + 1;
 
     int valid_rows = (row == ntimes) ? ntimes
-      : (((err & 1) && (err & 8)) ? row : row+1);
+                                     : (((err & 1) && (err & 8)) ? row : row+1);
     dim_vector dv (valid_rows, 1);
 
     ra_idx(0) = 0;
     int i = 0;
     if (! collect_output)
       {
         retval = Cell (dim_vector (1, out.size ()));
         for (std::list<octave_value>::iterator col = out.begin ();
@@ -2851,17 +2852,18 @@ namespace octave
       }
 
     // look for exponent part in, e.g.,  6.023E+23
     bool used_exp = false;
     if (valid && width_left > 1 && exp_chars.find (ch) != std::string::npos)
       {
         int ch1 = is.peek ();
         if (ch1 == '-' || ch1 == '+' || (ch1 >= '0' && ch1 <= '9'))
-          {          // if 1.0e+$ or some such, this will set failbit, as we want
+          {
+            // if 1.0e+$ or some such, this will set failbit, as we want
             width_left--;                         // count "E"
             int exp = 0;
             int exp_sign = 1;
             if (ch1 == '+')
               {
                 if (width_left)
                   width_left--;
                 is.get ();
@@ -2964,17 +2966,18 @@ namespace octave
                 char *pos = is.tellg ();
                 std::ios::iostate state = is.rdstate ();
 
                 is.get ();
                 ch2 = is.get ();
                 if (ch2 == 'f')
                   {
                     inf = true;
-                    re = (ch == '+') ? octave::numeric_limits<double>::Inf () : -octave::numeric_limits<double>::Inf ();
+                    re = (ch == '+') ? octave::numeric_limits<double>::Inf ()
+                                     : -octave::numeric_limits<double>::Inf ();
                     value = 0;
                   }
                 else
                   {
                     is.clear (state);
                     is.seekg (pos);   // reset to position before look-ahead
                   }
               }
@@ -3016,17 +3019,17 @@ namespace octave
                 // treat_as_empty strings may be different sizes.
                 // Read ahead longest, put it all back, then re-read the string
                 // that matches.
                 std::string look_buf (treat_as_empty_len, '\0');
                 char *look = is.read (&look_buf[0], look_buf.size (), pos);
 
                 is.clear (state);
                 is.seekg (pos);        // reset to position before look-ahead
-                // FIXME: is.read could invalidate pos
+                                       // FIXME: is.read could invalidate pos
 
                 for (int i = 0; i < treat_as_empty.numel (); i++)
                   {
                     std::string s = treat_as_empty (i).string_value ();
                     if (! strncmp (s.c_str (), look, s.size ()))
                       {
                         as_empty = true;
                         // read just the right amount
@@ -3107,17 +3110,18 @@ namespace octave
 
   std::string
   textscan::read_until (delimited_stream& is, const Cell& delimiters,
                         const std::string& ends) const
   {
     std::string retval ("");
     bool done = false;
     do
-      {                               // find sequence ending with an ending char
+      {
+        // find sequence ending with an ending char
         std::string next;
         scan_caret (is, ends.c_str (), next);
         retval = retval + next;   // FIXME: could use repeated doubling of size
 
         int last = (! is.eof ()
                     ? is.get_undelim () : std::istream::traits_type::eof ());
 
         if (last != std::istream::traits_type::eof ())
@@ -3300,18 +3304,18 @@ namespace octave
                                                                 FloatComplex (v));
                       }
                   }
               }
           }
         else
           {
             double v;    // Matlab docs say 1e30 etc should be valid for %d and
-            // 1000 as a %d8 should be 127, so read as double.
-            // Some loss of precision for d64 and u64.
+                         // 1000 as a %d8 should be 127, so read as double.
+                         // Some loss of precision for d64 and u64.
             skip_whitespace (is);
             v = read_double (is, fmt);
             if (! fmt.discard && ! is.fail ())
               switch (fmt.bitwidth)
                 {
                 case 64:
                   switch (fmt.type)
                     {
@@ -3490,48 +3494,50 @@ namespace octave
 
         elem = fmt_list.next ();
         char *pos = is.tellg ();
 
         // FIXME: these conversions "ignore delimiters".  Should they include
         // delimiters at the start of the conversion, or can those be skipped?
         if (elem->type != textscan_format_elt::literal_conversion
             // && elem->type != '[' && elem->type != '^' && elem->type != 'c'
-            )
+           )
           skip_delim (is);
 
         if (is.eof ())
           {
             if (! done)
               done_after = i+1;
 
             // note EOF, but process others to get empty_val.
             done = true;
           }
 
         if (this_conversion_failed)
           {
             if (is.tellg () == pos && ! conversion_failed)
-              {                 // done_after = first failure
+              {
+                // done_after = first failure
                 done_after = i; // note fail, but parse others to get empty_val
                 conversion_failed = true;
               }
             else
               this_conversion_failed = false;
           }
         else if (! done && !conversion_failed)
           nothing_worked = false;
       }
 
     if (done)
       is.setstate (std::ios::eofbit);
 
-    return no_conversions + (is.eof () ? 2 : 0)
-      + (conversion_failed ? 4 : 0)
-      + (nothing_worked ? 8 : 0);
+    return no_conversions
+           + (is.eof () ? 2 : 0)
+           + (conversion_failed ? 4 : 0)
+           + (nothing_worked ? 8 : 0);
 
   }
 
   void
   textscan::parse_options (const octave_value_list& args,
                            textscan_format_list& fmt_list)
   {
     int last = args.length ();
@@ -3586,17 +3592,18 @@ namespace octave
               }
             if (invalid)
               error ("%s: Delimiters must be either a string or cell array of strings",
                      who.c_str ());
           }
         else if (param == "commentstyle")
           {
             if (args(i+1).is_string ())
-              {   // check here for names like "C++", "C", "shell", ...?
+              {
+                // check here for names like "C++", "C", "shell", ...?
                 comment_style = Cell (args(i+1));
               }
             else if (args(i+1).is_cell ())
               {
                 comment_style = args(i+1).cell_value ();
                 int len = comment_style.numel ();
                 if ((len >= 1 && ! comment_style (0).is_string ())
                     || (len >= 2 && ! comment_style (1).is_string ())
@@ -3781,17 +3788,18 @@ namespace octave
                   }
                 else      // matching pair
                   {
                     std::string end_c = comment_style(1).string_value ();
                     // last char of end-comment sequence
                     std::string last = end_c.substr (end_c.size () - 1);
                     std::string may_match ("");
                     do
-                      {           // find sequence ending with last char
+                      {
+                        // find sequence ending with last char
                         scan_caret (is, last, dummy);
                         is.get_undelim ();        // (read LAST itself)
 
                         may_match = may_match + dummy + last;
                         if (may_match.length () > end_c.length ())
                           {
                             size_t start = may_match.length () - end_c.length ();
                             may_match = may_match.substr (start);
@@ -3828,17 +3836,17 @@ namespace octave
 
     char *pos = is.tellg ();
 
     std::string tmp (max_len, '\0');
     char *look = is.read (&tmp[0], tmp.size (), pos);
 
     is.clear ();
     is.seekg (pos);              // reset to position before look-ahead
-    // FIXME: pos may be corrupted by is.read
+                                 // FIXME: pos may be corrupted by is.read
 
     int i;
     int (*compare)(const char *, const char *, size_t);
     compare = case_sensitive ? strncmp : strncasecmp;
 
     for (i = 0; i < targets.numel (); i++)
       {
         std::string s = targets (i).string_value ();
@@ -4196,22 +4204,23 @@ octave_scan_1 (std::istream& is, const s
                   }
                 else
                   {
                     if (c2 == '0' || c2 == '1' || c2 == '2'
                         || c2 == '3' || c2 == '4' || c2 == '5'
                         || c2 == '6' || c2 == '7')
                       is >> std::oct >> value >> std::dec;
                     else if (c2 == '8' || c2 == '9')
-                    {
-                      // FIXME: Would like to set error state on octave stream.
-                      // See bug #46493.  But only std::istream is input to fcn
-                      // error ("internal failure to match octal format");
-                      value = 0;
-                    }
+                      {
+                        // FIXME: Would like to set error state on octave
+                        // stream.  See bug #46493.  But only std::istream is
+                        // input to fcn.
+                        // error ("internal failure to match octal format");
+                        value = 0;
+                      }
                     else
                       value = 0;
                   }
               }
             else
               {
                 is.putback (c1);
 
@@ -4673,18 +4682,18 @@ octave_base_stream::do_scanf (scanf_form
       for (;;)
         {
           octave_quit ();
 
           if (elt)
             {
               if (elt->type == scanf_format_elt::null
                   || (! (elt->type == scanf_format_elt::whitespace_conversion
-                        || elt->type == scanf_format_elt::literal_conversion
-                        || elt->type == '%')
+                         || elt->type == scanf_format_elt::literal_conversion
+                         || elt->type == '%')
                       && max_conv > 0 && conversion_count == max_conv))
                 {
                   // We are done, either because we have reached the end of the
                   // format string and are not cycling through the format again
                   // or because we've converted all the values that have been
                   // requested and the next format element is a conversion.
                   // Determine final array size and exit.
                   if (all_char_conv && one_elt_size_spec)
@@ -6021,17 +6030,18 @@ octave_stream::skipl (const octave_value
   err = false;
 
   int conv_err = 0;
 
   int count = 1;
 
   if (tc_count.is_defined ())
     {
-      if (tc_count.is_scalar_type () && octave::math::isinf (tc_count.scalar_value ()))
+      if (tc_count.is_scalar_type ()
+          && octave::math::isinf (tc_count.scalar_value ()))
         count = -1;
       else
         {
           count = convert_to_valid_int (tc_count, conv_err);
 
           if (conv_err || count < 0)
             {
               err = true;
@@ -7572,8 +7582,9 @@ octave_stream_list::do_get_file_number (
       if (conv_err)
         ::error ("file id must be a file object, std::string, or integer value");
 
       retval = int_fid;
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -476,8 +476,9 @@ private:
   std::string do_list_open_files (void) const;
 
   octave_value do_open_file_numbers (void) const;
 
   int do_get_file_number (const octave_value& fid) const;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct-strstrm.cc b/libinterp/corefcn/oct-strstrm.cc
--- a/libinterp/corefcn/oct-strstrm.cc
+++ b/libinterp/corefcn/oct-strstrm.cc
@@ -63,8 +63,9 @@ octave_istrstream::create (const std::st
 }
 
 octave_stream
 octave_ostrstream::create (std::ios::openmode arg_md,
                            octave::mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_ostrstream (arg_md, flt_fmt));
 }
+
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -171,8 +171,9 @@ private:
   // No copying!
 
   octave_ostrstream (const octave_ostrstream&);
 
   octave_ostrstream& operator = (const octave_ostrstream&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/oct.h b/libinterp/corefcn/oct.h
--- a/libinterp/corefcn/oct.h
+++ b/libinterp/corefcn/oct.h
@@ -36,8 +36,9 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "help.h"
 #include "ovl.h"
 #include "pager.h"
 #include "utils.h"
 #include "variables.h"
 
 #endif
+
diff --git a/libinterp/corefcn/octave-default-image.h b/libinterp/corefcn/octave-default-image.h
--- a/libinterp/corefcn/octave-default-image.h
+++ b/libinterp/corefcn/octave-default-image.h
@@ -281,8 +281,9 @@ static char default_im_data[] =
   19,19,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,19,19,19,19,19,19,19,19,19,19,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
 };
 
 #endif
+
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -475,8 +475,9 @@ protected:
                                        std::string& ps4) = 0;
 
   virtual void do_show_preferences (void) = 0;
 
   virtual void do_show_doc (const std::string &file) = 0;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/octave-preserve-stream-state.h b/libinterp/corefcn/octave-preserve-stream-state.h
--- a/libinterp/corefcn/octave-preserve-stream-state.h
+++ b/libinterp/corefcn/octave-preserve-stream-state.h
@@ -48,8 +48,9 @@ private:
   std::ios& stream;
   std::ios::fmtflags oflags;
   std::streamsize oprecision;
   int owidth;
   char ofill;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -114,18 +114,20 @@ is in the upper left corner, by doing:
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
-                     sel.data (), n, F77_DBLE_CMPLX_ARG (S.fortran_vec ()), n, F77_DBLE_CMPLX_ARG (U.fortran_vec ()), n,
-                     F77_DBLE_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), n,
+                     sel.data (), n, F77_DBLE_CMPLX_ARG (S.fortran_vec ()), n,
+                     F77_DBLE_CMPLX_ARG (U.fortran_vec ()), n,
+                     F77_DBLE_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2,
+                     F77_DBLE_CMPLX_ARG (work.fortran_vec ()), n,
                      info));
 
           PREPARE_OUTPUT()
         }
       else
         {
           PREPARE_ARGS (, matrix, double)
           Matrix wi (dim_vector (n, 1));
@@ -143,18 +145,20 @@ is in the upper left corner, by doing:
   else
     {
       if (complex_type)
         {
           PREPARE_ARGS (FloatComplex, float_complex_matrix, float)
 
           F77_XFCN (ctrsen, ctrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
-                     sel.data (), n, F77_CMPLX_ARG (S.fortran_vec ()), n, F77_CMPLX_ARG (U.fortran_vec ()), n,
-                     F77_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2, F77_CMPLX_ARG (work.fortran_vec ()), n,
+                     sel.data (), n, F77_CMPLX_ARG (S.fortran_vec ()), n,
+                     F77_CMPLX_ARG (U.fortran_vec ()), n,
+                     F77_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2,
+                     F77_CMPLX_ARG (work.fortran_vec ()), n,
                      info));
 
           PREPARE_OUTPUT ()
         }
       else
         {
           PREPARE_ARGS (Float, float_matrix, float)
           FloatMatrix wi (dim_vector (n, 1));
@@ -202,8 +206,9 @@ is in the upper left corner, by doing:
 %!test
 %! A = [1, 2, 3, -2; 4, 5, 6, -5 ; 7, 8, 9, -5; 10, 11, 12, 4+3i ];
 %! [U, T] = schur (A);
 %! [US, TS] = ordschur (single (U), single (T), [ 0, 0, 1, 1 ]);
 %! assert (US*TS*US', A, sqrt (eps ("single")));
 %! assert (diag (T)(3:4), diag (TS)(1:2), sqrt (eps ("single")));
 
 */
+
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -716,8 +716,9 @@ to the pager.
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{PAGER, more, page_screen_output, page_output_immediately}
 @end deftypefn */)
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER_FLAGS);
 }
+
diff --git a/libinterp/corefcn/pager.h b/libinterp/corefcn/pager.h
--- a/libinterp/corefcn/pager.h
+++ b/libinterp/corefcn/pager.h
@@ -145,8 +145,9 @@ private:
 
 #define octave_stdout (octave_pager_stream::stream ())
 
 #define octave_diary (octave_diary_stream::stream ())
 
 extern OCTINTERP_API void flush_octave_stdout (void);
 
 #endif
+
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -185,8 +185,9 @@ where @code{sigma_max (@var{x})} is the 
 %! assert (isa (y, "double"));
 %! assert (diag (y), [1/3, 1/2, 1, 0  1/-0.5]');
 %! y = pinv (x, 1);
 %! assert (diag (y), [1/3 1/2 1 0 0]');
 %! y = pinv (x, 2);
 %! assert (diag (y), [1/3 1/2 0 0 0]');
 
 */
+
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -1001,24 +1001,27 @@ set_format (const Complex& c, int& r_fw,
   if (free_format)
     return;
 
   double rp = c.real ();
   double ip = c.imag ();
 
   bool inf_or_nan = (octave::math::isinf (c) || octave::math::isnan (c));
 
-  bool int_only = (octave::math::x_nint (rp) == rp && octave::math::x_nint (ip) == ip);
+  bool int_only = (octave::math::x_nint (rp) == rp
+                   && octave::math::x_nint (ip) == ip);
 
   double r_abs = rp < 0.0 ? -rp : rp;
   double i_abs = ip < 0.0 ? -ip : ip;
 
-  int r_x = (! octave::math::finite (rp) || r_abs == 0.0) ? 0 : num_digits (r_abs);
-
-  int i_x = (! octave::math::finite (ip) || i_abs == 0.0) ? 0 : num_digits (i_abs);
+  int r_x = (! octave::math::finite (rp)
+             || r_abs == 0.0) ? 0 : num_digits (r_abs);
+
+  int i_x = (! octave::math::finite (ip)
+             || i_abs == 0.0) ? 0 : num_digits (i_abs);
 
   int x_max, x_min;
 
   if (r_x > i_x)
     {
       x_max = r_x;
       x_min = i_x;
     }
@@ -4195,8 +4198,9 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{format, fixed_point_format, output_max_field_width}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1,
                                             std::numeric_limits<int>::max ());
 }
+
diff --git a/libinterp/corefcn/pr-output.h b/libinterp/corefcn/pr-output.h
--- a/libinterp/corefcn/pr-output.h
+++ b/libinterp/corefcn/pr-output.h
@@ -265,8 +265,9 @@ octave_print_internal (std::ostream& os,
 // TRUE means that the dimensions of empty objects should be printed
 // like this: x = [](2x0).
 extern bool Vprint_empty_dimensions;
 
 // TRUE means don't put empty lines in output
 extern bool Vcompact_format;
 
 #endif
+
diff --git a/libinterp/corefcn/procstream.cc b/libinterp/corefcn/procstream.cc
--- a/libinterp/corefcn/procstream.cc
+++ b/libinterp/corefcn/procstream.cc
@@ -63,8 +63,9 @@ procstreambase::close (void)
       if (! pb.close ())
         std::ios::setstate (std::ios::failbit);
 
       status = pb.wait_status ();
     }
 
   return status;
 }
+
diff --git a/libinterp/corefcn/procstream.h b/libinterp/corefcn/procstream.h
--- a/libinterp/corefcn/procstream.h
+++ b/libinterp/corefcn/procstream.h
@@ -157,8 +157,9 @@ public:
 private:
 
   procstream (const procstream&);
 
   procstream& operator = (const procstream&);
 };
 
 #endif
+
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -211,8 +211,9 @@ extern OCTINTERP_API profile_data_accumu
 #define BEGIN_PROFILER_BLOCK(classname)                                 \
   {                                                                     \
     profile_data_accumulator::enter<classname> pe (profiler, *this);
 
 #define END_PROFILER_BLOCK                      \
     }  // end of block => call pe's destructor
 
 #endif
+
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -224,8 +224,9 @@ can have any value real or complex value
 %!error <Z must be> psi ("non numeric")
 %!error <conversion of 5.3 to int.* value failed> psi (5.3, 1)
 %!error <K must be non-negative> psi (-5, 1)
 %!error <Z must be non-negative for polygamma> psi (5, -1)
 %!error <Z must be a floating point> psi (5, uint8 (-1))
 %!error <Z must be real value for polygamma> psi (5, 5i)
 
 */
+
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -1213,17 +1213,17 @@ jit_convert::resolve (tree_index_express
   bool have_extra = extra_arg;
   std::vector<jit_value *> call_args (narg + 1 + have_extra);
   call_args[0] = object;
 
   for (size_t idx = 0; iter != arg_list->end (); ++idx, ++iter)
     {
       octave::unwind_protect frame;
       frame.add_method (&end_context,
-                       &std::vector<jit_magic_end::context>::pop_back);
+                        &std::vector<jit_magic_end::context>::pop_back);
 
       jit_magic_end::context ctx (factory, object, idx, narg);
       end_context.push_back (ctx);
       call_args[idx + 1] = visit (*iter);
     }
 
   if (extra_arg)
     call_args[call_args.size () - 1] = extra_arg;
@@ -2600,8 +2600,9 @@ The original variable value is restored 
                                             std::numeric_limits<int>::max ());
 #else
   octave_unused_parameter (args);
   octave_unused_parameter (nargout);
   warn_disabled_feature ("jit_enable", "JIT");
   return ovl ();
 #endif
 }
+
diff --git a/libinterp/corefcn/pt-jit.h b/libinterp/corefcn/pt-jit.h
--- a/libinterp/corefcn/pt-jit.h
+++ b/libinterp/corefcn/pt-jit.h
@@ -446,8 +446,9 @@ private:
   llvm::Function *llvm_function;
 
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 };
 
 #endif
 #endif
+
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -441,8 +441,9 @@ variable by routines @code{dblquad} and 
 %!error quad ("__f", 1, 2, 3, 4, 5)
 
 %!test
 %! quad_options ("absolute tolerance", eps);
 %! assert (quad_options ("absolute tolerance") == eps);
 
 %!error quad_options (1, 2, 3)
 */
+
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -2217,8 +2217,9 @@ Mathematical Software, Vol. 37, Issue 3,
 %!error (quadcc (@sin, 0))
 %!error (quadcc (@sin, ones (2), pi))
 %!error (quadcc (@sin, -i, pi))
 %!error (quadcc (@sin, 0, ones (2)))
 %!error (quadcc (@sin, 0, i))
 %!error (quadcc (@sin, 0, pi, 0))
 %!error (quadcc (@sin, 0, pi, 1e-6, [ i ]))
 */
+
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -378,17 +378,18 @@ compatibility with @sc{matlab}.
       if (compq == 'V')
         CQ = ComplexMatrix (QQ);
 
       if (compz == 'V')
         CZ = ComplexMatrix (ZZ);
 
       F77_XFCN (zggbal, ZGGBAL,
                 (F77_CONST_CHAR_ARG2 (&bal_job, 1),
-                 nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
+                 nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
                  nn, ilo, ihi, lscale.fortran_vec (),
                  rscale.fortran_vec (), work.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)));
     }
   else
     {
 #if defined (DEBUG)
       if (compq == 'V')
@@ -456,17 +457,18 @@ compatibility with @sc{matlab}.
       // (Q*)caa for following work.
       caa = (cbqr.Q ().hermitian ()) * caa;
       CQ = CQ * cbqr.Q ();
 
       F77_XFCN (zgghrd, ZGGHRD,
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
                  nn, ilo, ihi, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()),
-                 nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn,
+                 nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn,
                  F77_DBLE_CMPLX_ARG (CZ.fortran_vec ()), nn, info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
       ComplexRowVector cwork (1 * nn);
 
       F77_XFCN (zhgeqz, ZHGEQZ,
                 (F77_CONST_CHAR_ARG2 (&qz_job, 1),
@@ -885,18 +887,20 @@ compatibility with @sc{matlab}.
           CVR = CZ;
           ComplexRowVector cwork2 (2 * nn);
           RowVector rwork2 (8 * nn);
           octave_idx_type m;
 
           F77_XFCN (ztgevc, ZTGEVC,
                     (F77_CONST_CHAR_ARG2 (&side, 1),
                      F77_CONST_CHAR_ARG2 (&howmny, 1),
-                     select, nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
-                     nn, F77_DBLE_CMPLX_ARG (CVL.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (CVR.fortran_vec ()), nn, nn,
+                     select, nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn,
+                     F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
+                     nn, F77_DBLE_CMPLX_ARG (CVL.fortran_vec ()), nn,
+                     F77_DBLE_CMPLX_ARG (CVR.fortran_vec ()), nn, nn,
                      m, F77_DBLE_CMPLX_ARG (cwork2.fortran_vec ()), rwork2.fortran_vec (), info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
         }
       else
         {
 #if defined (DEBUG)
           std::cout << "qz: computing generalized eigenvectors" << std::endl;
@@ -1088,8 +1092,9 @@ compatibility with @sc{matlab}.
 
 %!test
 %! A = [0, 0, -1, 0; 1, 0, 0, 0; -1, 0, -2, -1; 0, -1, 1, 0];
 %! B = [0, 0, 0, 0; 0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1];
 %! [AA, BB, Q, Z1] = qz (A, B);
 %! [AA, BB, Z2] = qz (A, B, '-');
 %! assert (Z1, Z2);
 */
+
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1119,21 +1119,19 @@ likely.
   if (short_shuffle)
     {
       std::unordered_map<octave_idx_type, octave_idx_type> map (m);
 
       // Perform the Knuth shuffle only keeping track of moved
       // entries in the map
       for (octave_idx_type i = 0; i < m; i++)
         {
-          octave_idx_type k = i +
-            std::floor (rvec[i] * (n - i));
+          octave_idx_type k = i + std::floor (rvec[i] * (n - i));
 
-          // For shuffling first m entries, no need to use extra
-          // storage
+          // For shuffling first m entries, no need to use extra storage
           if (k < m)
             {
               std::swap (ivec[i], ivec[k]);
             }
           else
             {
               if (map.find (k) == map.end ())
                 map[k] = k;
@@ -1142,18 +1140,17 @@ likely.
             }
         }
     }
   else
     {
       // Perform the Knuth shuffle of the first m entries
       for (octave_idx_type i = 0; i < m; i++)
         {
-          octave_idx_type k = i +
-            std::floor (rvec[i] * (n - i));
+          octave_idx_type k = i + std::floor (rvec[i] * (n - i));
           std::swap (ivec[i], ivec[k]);
         }
     }
 
   // Convert to doubles, reusing r.
   for (octave_idx_type i = 0; i < m; i++)
     rvec[i] = ivec[i] + 1;
 
@@ -1173,8 +1170,9 @@ likely.
 
 %!test
 %! rand ("seed", 0);
 %! for i = 1:100
 %!   p = randperm (305, 30);
 %!   assert (length (unique (p)), 30);
 %! endfor
 */
+
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -98,8 +98,9 @@ instead.
 %! x = [-5.25, -2.25; -2.25, 1] * eps () + ones (2) / 2;
 %! sx = [-5.25, -2.25; -2.25, 1] * eps ("single") + ones (2) / 2;
 %!assert (rcond (x) < eps ())
 %!assert (rcond (sx) < eps ('single'))
 %!assert (rcond (x*i) < eps ())
 %!assert (rcond (sx*i) < eps ('single'))
 
 */
+
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -1496,8 +1496,9 @@ function.
 # Nasty lookbehind expression
 %!test
 %! warning ("off", "Octave:regexp-lookbehind-limit", "local");
 %! assert (regexprep ('x^(-1)+y(-1)+z(-1)=0', '(?<=[a-z]+)\(\-[1-9]*\)', '_minus1'),'x^(-1)+y_minus1+z_minus1=0');
 
 %!assert (regexprep ("\n", '\n', "X"), "X")
 %!assert (regexprep ("\n", "\n", "X"), "X")
 */
+
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -334,8 +334,9 @@ Note also that @var{U} and @var{T} are n
 %! assert (norm (U * U'), 1, 1e-14);
 
 %!test
 %! A = [0, 1;-1, 0];
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u,t);
 %! assert (U * T * U', A, 1e-14);
 */
+
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -405,17 +405,17 @@ namespace octave
   sig_handler *
   set_signal_handler (int sig, sig_handler *handler, bool restart_syscalls)
   {
     return octave_set_signal_handler_internal (sig, handler, restart_syscalls);
   }
 
   sig_handler *
   set_signal_handler (const char *signame, sig_handler *handler,
-                             bool restart_syscalls)
+                      bool restart_syscalls)
   {
     return octave_set_signal_handler_by_name (signame, handler,
                                               restart_syscalls);
   }
 
   static void
   generic_sig_handler (int sig)
   {
@@ -838,8 +838,9 @@ The original variable value is restored 
 %! old_val = sigterm_dumps_octave_core (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (sigterm_dumps_octave_core (), ! orig_val);
 %! sigterm_dumps_octave_core (orig_val);
 %! assert (sigterm_dumps_octave_core (), orig_val);
 
 %!error (sigterm_dumps_octave_core (1, 2))
 */
+
diff --git a/libinterp/corefcn/sighandlers.h b/libinterp/corefcn/sighandlers.h
--- a/libinterp/corefcn/sighandlers.h
+++ b/libinterp/corefcn/sighandlers.h
@@ -126,8 +126,9 @@ OCTAVE_DEPRECATED ("use 'octave::set_int
 const auto octave_set_interrupt_handler = octave::set_interrupt_handler;
 
 OCTAVE_DEPRECATED ("use 'octave::Vdebug_on_interrupt' instead")
 static auto& Vdebug_on_interrupt = octave::Vdebug_on_interrupt;
 
 #endif
 
 #endif
+
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -392,17 +392,18 @@ x_el_div (double a, const SparseMatrix& 
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
-  ComplexMatrix result (nr, nc, Complex (octave::numeric_limits<double>::NaN (), octave::numeric_limits<double>::NaN ()));
+  ComplexMatrix result (nr, nc, Complex (octave::numeric_limits<double>::NaN (),
+                                         octave::numeric_limits<double>::NaN ()));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
         result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
@@ -625,8 +626,9 @@ xleftdiv (const ComplexDiagMatrix& d, co
 
 // -*- 12 -*-
 SparseComplexMatrix
 xleftdiv (const ComplexDiagMatrix& d, const SparseComplexMatrix& a,
           MatrixType&)
 {
   return do_leftdiv_dm_sm<SparseComplexMatrix> (d, a);
 }
+
diff --git a/libinterp/corefcn/sparse-xdiv.h b/libinterp/corefcn/sparse-xdiv.h
--- a/libinterp/corefcn/sparse-xdiv.h
+++ b/libinterp/corefcn/sparse-xdiv.h
@@ -94,8 +94,9 @@ extern SparseComplexMatrix xleftdiv (con
 extern SparseComplexMatrix xleftdiv (const DiagMatrix&,
                                      const SparseComplexMatrix&,
                                      MatrixType&);
 extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&,
                                      const SparseComplexMatrix&,
                                      MatrixType&);
 
 #endif
+
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -736,8 +736,9 @@ elem_xpow (const SparseComplexMatrix& a,
           result.xelem (a.ridx (i), j) = std::pow (a.data (i),
                                                    b(a.ridx (i), j));
         }
     }
   result.maybe_compress (true);
 
   return result;
 }
+
diff --git a/libinterp/corefcn/sparse-xpow.h b/libinterp/corefcn/sparse-xpow.h
--- a/libinterp/corefcn/sparse-xpow.h
+++ b/libinterp/corefcn/sparse-xpow.h
@@ -52,8 +52,9 @@ extern octave_value elem_xpow (const Spa
 extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const SparseMatrix& b);
 extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const Complex& b);
 extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const SparseComplexMatrix& b);
 
 #endif
+
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -270,8 +270,9 @@ the function @code{nzmax}.
   if (nargin == 3)
     nz = args(2).idx_type_value ();
 
   if (m >= 0 && n >= 0 && nz >= 0)
     return ovl (SparseMatrix (dim_vector (m, n), nz));
   else
     error ("spalloc: M,N,NZ must be non-negative");
 }
+
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -201,8 +201,9 @@ longer running time.
 %!#error <input must be a string> spparms ({1, 2, 3})
 %!error spparms ({1, 2, 3})
 %!error <too many elements in vector VALS> spparms (ones (14, 1))
 %!error <first argument must be a string> spparms (1, 1)
 %!#error <second argument must be a real scalar> spparms ("ths_rel", "hello")
 %!error spparms ("ths_rel", "hello")
 %!error <KEY not found> spparms ("UNKNOWN_KEY", 1)
 */
+
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -263,8 +263,9 @@ Mathematics, Manchester, England, Januar
 
 %!test
 %! x = eye (4);  x(2,2) = x(3,3) = 2^-26;  x(1,4) = 1;
 %! z = eye (4);  z(2,2) = z(3,3) = 2^-13;  z(1,4) = 0.5;
 %! [y, err] = sqrtm (x);
 %! assert (y, z);
 %! assert (err, 0);   # Yes, this one has to hold exactly
 */
+
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -406,8 +406,9 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
 %!assert (str2double (zeros (3,1,2)), NaN)
 %!assert (str2double (''), NaN)
 %!assert (str2double ([]), NaN)
 %!assert (str2double (char(zeros(3,0))), NaN)
 */
+
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -448,8 +448,9 @@ strrep ("This is a test string", "is", "
 %!assert (strrep ("abababc", "abab", "xyz"), "xyzxyzc")
 %!assert (strrep ("abababc", "abab", "xyz", "overlaps", false), "xyzabc")
 
 %!assert (size (strrep ("a", "a", "")), [0 0])
 
 %!error strrep ()
 %!error strrep ("foo", "bar", 3, 4)
 */
+
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -804,8 +804,9 @@ whos ans
 %! result = "  abc     mnop  \n  def     qrs   \n  ghijkl  tuv   \n";
 %! assert (list_in_columns (input, 20, "  "), result);
 
 %!error list_in_columns ()
 %!error list_in_columns (["abc", "def"], 20, 2)
 %!error list_in_columns (["abc", "def"], 20, "  ", 3)
 %!error <list_in_columns: WIDTH must be an integer> list_in_columns (["abc", "def"], "a")
 */
+
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -232,17 +232,17 @@ r = ind2sub (dims, ind)
 
   try
     {
       retval = Array<octave_value> (ind2sub (dv, args(1).index_vector ()));
     }
   catch (const octave::index_exception& e)
     {
       error ("ind2sub: Invalid index %s. %s", e.idx ().c_str (),
-        e.details ().c_str ());
+             e.details ().c_str ());
     }
 
   return retval;
 }
 
 /*
 ## Examples
 %!test
@@ -277,8 +277,9 @@ r = ind2sub (dims, ind)
 %! assert (c, [1, 1, 2, 2, 3, 3, 4, 4]);
 %! r = ind2sub ([2, 2, 2], 1:8);
 %! assert (r, 1:8);
 
 %!error <DIMS must contain integers> ind2sub ([2, -2], 3);
 %!error <index out of range> ind2sub ([2, 2, 2], 1:9);
 %!error <Invalid index> ind2sub ([2, 2, 2], -1:8);
 */
+
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -353,8 +353,9 @@ The original variable value is restored 
 %! [U1, S1, V1] = svd (A);
 %! svd_driver ("gesdd");
 %! [U2, S2, V2] = svd (A);
 %! assert (U1, U2, 5*eps);
 %! assert (S1, S2, 5*eps);
 %! assert (V1, V2, 5*eps);
 %! svd_driver (old_driver);
 */
+
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -160,8 +160,9 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
 %!error sylvester ()
 %!error sylvester (1)
 %!error sylvester (1,2)
 %!error sylvester (1, 2, 3, 4)
 %!error <A must be a square matrix> sylvester (ones (2,3), ones (2,2), ones (2,2))
 %!error <B must be a square matrix> sylvester (ones (2,2), ones (2,3), ones (2,2))
 %!error <nonconformant matrices> sylvester (ones (2,2), ones (2,2), ones (3,3))
 */
+
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1328,17 +1328,18 @@ symbol_table::find_function (const std::
 
 // look for @class/method>subfunction
 octave_value
 symbol_table::find_submethod (const std::string& name,
                               const std::string& dispatch_type)
 {
   octave_value fcn;
 
-  std::string full_name = "@" + dispatch_type + octave::sys::file_ops::dir_sep_str () + name;
+  std::string full_name = "@" + dispatch_type +
+                          octave::sys::file_ops::dir_sep_str () + name;
   size_t pos = full_name.find_first_of (Vfilemarker);
 
   if (pos != std::string::npos)
     {
       std::string fcn_scope = full_name.substr (0, pos);
       scope_id stored_scope = xcurrent_scope;
       xcurrent_scope = xtop_scope;
       octave_value parent = find_function (full_name.substr (0, pos),
@@ -1929,8 +1930,9 @@ updated to use some other function.
 %!  x = 5;
 %!endfunction
 %!test
 %! assert (bar == 5);
 %! assert (strcmp (which ("bar"), ""));
 %! clear bar;
 %! assert (! strcmp (which ("bar"), ""));
 */
+
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2952,8 +2952,9 @@ extern bool out_of_date_check (octave_va
                                bool check_relative = true);
 
 extern OCTINTERP_API std::string
 get_dispatch_type (const octave_value_list& args);
 extern OCTINTERP_API std::string
 get_dispatch_type (const octave_value_list& args, builtin_type_t& builtin_type);
 
 #endif
+
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -54,19 +54,22 @@ along with Octave; see the file COPYING.
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 #include "input.h"
 
 static octave_scalar_map
 mk_stat_map (const octave::sys::base_file_stat& fs)
 {
-  static bool have_rdev = octave::sys::base_file_stat::have_struct_stat_st_rdev ();
-  static bool have_blksize = octave::sys::base_file_stat::have_struct_stat_st_blksize ();
-  static bool have_blocks = octave::sys::base_file_stat::have_struct_stat_st_blocks ();
+  static bool have_rdev =
+    octave::sys::base_file_stat::have_struct_stat_st_rdev ();
+  static bool have_blksize =
+    octave::sys::base_file_stat::have_struct_stat_st_blksize ();
+  static bool have_blocks =
+    octave::sys::base_file_stat::have_struct_stat_st_blocks ();
 
   static double nan = octave::numeric_limits<double>::NaN ();
 
   octave_scalar_map m;
 
   m.assign ("dev", static_cast<double> (fs.dev ()));
   m.assign ("ino", fs.ino ());
   m.assign ("mode", fs.mode ());
@@ -734,21 +737,21 @@ error message.
 
   if (status < 0)
     return ovl (-1, -1, -1, msg);
   else
     {
       FILE *ifile = fdopen (fid[0], "r");
       FILE *ofile = fdopen (fid[1], "w");
 
-      octave_stream is = octave_stdiostream::create ("pipe-in", ifile,
-                                                       std::ios::in);
+      octave_stream is
+        = octave_stdiostream::create ("pipe-in", ifile, std::ios::in);
 
-      octave_stream os = octave_stdiostream::create ("pipe-out", ofile,
-                                                       std::ios::out);
+      octave_stream os
+        = octave_stdiostream::create ("pipe-out", ofile, std::ios::out);
 
       return ovl (octave_stream_list::insert (is),
                   octave_stream_list::insert (os),
                   status,
                   msg);
     }
 }
 
@@ -1589,8 +1592,9 @@ DEFUNX ("WCONTINUE", FWCONTINUE, args, ,
 Return the numerical value of the option argument that may be
 passed to @code{waitpid} to indicate that it should also return if a stopped
 child has been resumed by delivery of a @code{SIGCONT} signal.
 @seealso{waitpid, WNOHANG, WUNTRACED}
 @end deftypefn */)
 {
   return const_value (args, octave::sys::wcontinue ());
 }
+
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -188,17 +188,18 @@ set_application_id (void)
 
   typedef HRESULT (WINAPI *SETCURRENTAPPID)(PCWSTR AppID);
 
   HMODULE hShell = LoadLibrary ("shell32.dll");
 
   if (hShell != NULL)
     {
       SETCURRENTAPPID pfnSetCurrentProcessExplicitAppUserModelID =
-        reinterpret_cast<SETCURRENTAPPID> (GetProcAddress (hShell, "SetCurrentProcessExplicitAppUserModelID"));
+        reinterpret_cast<SETCURRENTAPPID> (GetProcAddress (hShell,
+                                           "SetCurrentProcessExplicitAppUserModelID"));
 
       if (pfnSetCurrentProcessExplicitAppUserModelID)
         pfnSetCurrentProcessExplicitAppUserModelID (L"gnu.octave");
 
       FreeLibrary (hShell);
     }
 
 #endif
@@ -851,33 +852,35 @@ DEFUN (isieee, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isieee ()
 Return true if your computer @emph{claims} to conform to the IEEE standard
 for floating point calculations.
 
 No actual tests are performed.
 @end deftypefn */)
 {
-  octave::mach_info::float_format flt_fmt = octave::mach_info::native_float_format ();
+  octave::mach_info::float_format flt_fmt =
+    octave::mach_info::native_float_format ();
 
   return ovl (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian
               || flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
 %!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} native_float_format ()
 Return the native floating point format as a string.
 @end deftypefn */)
 {
-  octave::mach_info::float_format flt_fmt = octave::mach_info::native_float_format ();
+  octave::mach_info::float_format flt_fmt =
+    octave::mach_info::native_float_format ();
 
   return ovl (octave::mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
@@ -963,8 +966,9 @@ DEFUN (have_window_system, , ,
 @deftypefn {} {} have_window_system ()
 Return true if a window system is available (X11, Windows, or Apple OS X)
 and false otherwise.
 @seealso{isguirunning}
 @end deftypefn */)
 {
   return ovl (display_info::display_available ());
 }
+
diff --git a/libinterp/corefcn/sysdep.h b/libinterp/corefcn/sysdep.h
--- a/libinterp/corefcn/sysdep.h
+++ b/libinterp/corefcn/sysdep.h
@@ -46,8 +46,9 @@ extern OCTINTERP_API int octave_pclose (
 extern OCTINTERP_API int octave_kbhit (bool wait = true);
 
 extern OCTINTERP_API std::string get_P_tmpdir (void);
 
 extern OCTINTERP_API bool same_file_internal (const std::string&,
                                               const std::string&);
 
 #endif
+
diff --git a/libinterp/corefcn/text-renderer.cc b/libinterp/corefcn/text-renderer.cc
--- a/libinterp/corefcn/text-renderer.cc
+++ b/libinterp/corefcn/text-renderer.cc
@@ -136,8 +136,9 @@ namespace octave
                             interpreter);
     else
       {
         bbox = empty_bbox;
         lst = empty_lst;
       }
   }
 }
+
diff --git a/libinterp/corefcn/text-renderer.h b/libinterp/corefcn/text-renderer.h
--- a/libinterp/corefcn/text-renderer.h
+++ b/libinterp/corefcn/text-renderer.h
@@ -208,8 +208,9 @@ namespace octave
 
     text_renderer (const text_renderer&);
 
     text_renderer& operator = (const text_renderer&);
   };
 }
 
 #endif
+
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -503,8 +503,9 @@ you're absolutely sure the date string w
 %! assert (isfield (ts, "min"));
 %! assert (isfield (ts, "wday"));
 %! assert (isfield (ts, "hour"));
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error strptime ()
 */
+
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -317,255 +317,255 @@ specified option.
 
   struct conf_info_struct
   {
     const char *key;
     octave_value val;
   };
 
   static const conf_info_struct conf_info[] =
-    {
-      { "DEFAULT_PAGER", OCTAVE_DEFAULT_PAGER },
+  {
+    { "DEFAULT_PAGER", OCTAVE_DEFAULT_PAGER },
 
 #if defined (OCTAVE_ENABLE_64)
-      { "ENABLE_64", true },
+    { "ENABLE_64", true },
 #else
-      { "ENABLE_64", false },
+    { "ENABLE_64", false },
 #endif
 
 #if defined (OCTAVE_ENABLE_ATOMIC_REFCOUNT)
-      { "ENABLE_ATOMIC_REFCOUNT", true },
+    { "ENABLE_ATOMIC_REFCOUNT", true },
 #else
-      { "ENABLE_ATOMIC_REFCOUNT", false },
+    { "ENABLE_ATOMIC_REFCOUNT", false },
 #endif
 
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
-      { "ENABLE_BOUNDS_CHECK", true },
+    { "ENABLE_BOUNDS_CHECK", true },
 #else
-      { "ENABLE_BOUNDS_CHECK", false },
+    { "ENABLE_BOUNDS_CHECK", false },
 #endif
 
 #if defined (ENABLE_DOCS)
-      { "ENABLE_DOCS", true },
+    { "ENABLE_DOCS", true },
 #else
-      { "ENABLE_DOCS", false },
+    { "ENABLE_DOCS", false },
 #endif
 
 #if defined (ENABLE_DYNAMIC_LINKING)
-      { "ENABLE_DYNAMIC_LINKING", true },
+    { "ENABLE_DYNAMIC_LINKING", true },
 #else
-      { "ENABLE_DYNAMIC_LINKING", false },
+    { "ENABLE_DYNAMIC_LINKING", false },
 #endif
 
 #if defined (OCTAVE_ENABLE_FLOAT_TRUNCATE)
-      { "ENABLE_FLOAT_TRUNCATE", true },
+    { "ENABLE_FLOAT_TRUNCATE", true },
 #else
-      { "ENABLE_FLOAT_TRUNCATE", false },
+    { "ENABLE_FLOAT_TRUNCATE", false },
 #endif
 
 #if defined (ENABLE_JIT)
-      { "ENABLE_JIT", true },
+    { "ENABLE_JIT", true },
 #else
-      { "ENABLE_JIT", false },
+    { "ENABLE_JIT", false },
 #endif
 
 #if defined (OCTAVE_ENABLE_OPENMP)
-      { "ENABLE_OPENMP", true },
+    { "ENABLE_OPENMP", true },
 #else
-      { "ENABLE_OPENMP", false },
+    { "ENABLE_OPENMP", false },
 #endif
 
-      { "api_version", OCTAVE_API_VERSION },
-      { "archlibdir", subst_octave_home (OCTAVE_ARCHLIBDIR) },
-      { "bindir", subst_octave_home (OCTAVE_BINDIR) },
-      { "canonical_host_type", OCTAVE_CANONICAL_HOST_TYPE },
-      { "datadir", subst_octave_home (OCTAVE_DATADIR) },
-      { "datarootdir", subst_octave_home (OCTAVE_DATAROOTDIR) },
-      { "exec_prefix", subst_octave_home (OCTAVE_EXEC_PREFIX) },
-      { "fcnfiledir", subst_octave_home (OCTAVE_FCNFILEDIR) },
-      { "fftw_version", octave_fftw_version () },
-      { "fftwf_version", octave_fftwf_version () },
-      { "imagedir", subst_octave_home (OCTAVE_IMAGEDIR) },
-      { "includedir", subst_octave_home (OCTAVE_INCLUDEDIR) },
-      { "infodir", subst_octave_home (OCTAVE_INFODIR) },
-      { "infofile", subst_octave_home (OCTAVE_INFOFILE) },
-      { "libdir", subst_octave_home (OCTAVE_LIBDIR) },
-      { "libexecdir", subst_octave_home (OCTAVE_LIBEXECDIR) },
-      // Each library and executable has its own definition of the hg
-      // id.  We check for consistency when Octave starts so we just
-      // store and report one of them here.
-      { "hg_id", liboctinterp_hg_id () },
-      { "localapiarchlibdir", subst_octave_home (OCTAVE_LOCALAPIARCHLIBDIR) },
-      { "localapifcnfiledir", subst_octave_home (OCTAVE_LOCALAPIFCNFILEDIR) },
-      { "localapioctfiledir", subst_octave_home (OCTAVE_LOCALAPIOCTFILEDIR) },
-      { "localarchlibdir", subst_octave_home (OCTAVE_LOCALARCHLIBDIR) },
-      { "localfcnfiledir", subst_octave_home (OCTAVE_LOCALFCNFILEDIR) },
-      { "localoctfiledir", subst_octave_home (OCTAVE_LOCALOCTFILEDIR) },
-      { "localstartupfiledir", subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR) },
-      { "localverarchlibdir", subst_octave_home (OCTAVE_LOCALVERARCHLIBDIR) },
-      { "localverfcnfiledir", subst_octave_home (OCTAVE_LOCALVERFCNFILEDIR) },
-      { "localveroctfiledir", subst_octave_home (OCTAVE_LOCALVEROCTFILEDIR) },
-      { "man1dir", subst_octave_home (OCTAVE_MAN1DIR) },
-      { "man1ext", OCTAVE_MAN1EXT },
-      { "mandir", subst_octave_home (OCTAVE_MANDIR) },
-      { "octdatadir", subst_octave_home (OCTAVE_OCTDATADIR) },
-      { "octfiledir", subst_octave_home (OCTAVE_OCTFILEDIR) },
-      { "octetcdir", subst_octave_home (OCTAVE_OCTETCDIR) },
-      { "octincludedir", subst_octave_home (OCTAVE_OCTINCLUDEDIR) },
-      { "octlibdir", subst_octave_home (OCTAVE_OCTLIBDIR) },
-      { "octtestsdir", subst_octave_home (OCTAVE_OCTTESTSDIR) },
-      { "prefix", subst_octave_home (OCTAVE_PREFIX) },
-      { "release_date", OCTAVE_RELEASE_DATE },
-      { "startupfiledir", subst_octave_home (OCTAVE_STARTUPFILEDIR) },
-      { "version", OCTAVE_VERSION },
-      { 0, octave_value () }
-    };
+    { "api_version", OCTAVE_API_VERSION },
+    { "archlibdir", subst_octave_home (OCTAVE_ARCHLIBDIR) },
+    { "bindir", subst_octave_home (OCTAVE_BINDIR) },
+    { "canonical_host_type", OCTAVE_CANONICAL_HOST_TYPE },
+    { "datadir", subst_octave_home (OCTAVE_DATADIR) },
+    { "datarootdir", subst_octave_home (OCTAVE_DATAROOTDIR) },
+    { "exec_prefix", subst_octave_home (OCTAVE_EXEC_PREFIX) },
+    { "fcnfiledir", subst_octave_home (OCTAVE_FCNFILEDIR) },
+    { "fftw_version", octave_fftw_version () },
+    { "fftwf_version", octave_fftwf_version () },
+    { "imagedir", subst_octave_home (OCTAVE_IMAGEDIR) },
+    { "includedir", subst_octave_home (OCTAVE_INCLUDEDIR) },
+    { "infodir", subst_octave_home (OCTAVE_INFODIR) },
+    { "infofile", subst_octave_home (OCTAVE_INFOFILE) },
+    { "libdir", subst_octave_home (OCTAVE_LIBDIR) },
+    { "libexecdir", subst_octave_home (OCTAVE_LIBEXECDIR) },
+    // Each library and executable has its own definition of the hg
+    // id.  We check for consistency when Octave starts so we just
+    // store and report one of them here.
+    { "hg_id", liboctinterp_hg_id () },
+    { "localapiarchlibdir", subst_octave_home (OCTAVE_LOCALAPIARCHLIBDIR) },
+    { "localapifcnfiledir", subst_octave_home (OCTAVE_LOCALAPIFCNFILEDIR) },
+    { "localapioctfiledir", subst_octave_home (OCTAVE_LOCALAPIOCTFILEDIR) },
+    { "localarchlibdir", subst_octave_home (OCTAVE_LOCALARCHLIBDIR) },
+    { "localfcnfiledir", subst_octave_home (OCTAVE_LOCALFCNFILEDIR) },
+    { "localoctfiledir", subst_octave_home (OCTAVE_LOCALOCTFILEDIR) },
+    { "localstartupfiledir", subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR) },
+    { "localverarchlibdir", subst_octave_home (OCTAVE_LOCALVERARCHLIBDIR) },
+    { "localverfcnfiledir", subst_octave_home (OCTAVE_LOCALVERFCNFILEDIR) },
+    { "localveroctfiledir", subst_octave_home (OCTAVE_LOCALVEROCTFILEDIR) },
+    { "man1dir", subst_octave_home (OCTAVE_MAN1DIR) },
+    { "man1ext", OCTAVE_MAN1EXT },
+    { "mandir", subst_octave_home (OCTAVE_MANDIR) },
+    { "octdatadir", subst_octave_home (OCTAVE_OCTDATADIR) },
+    { "octfiledir", subst_octave_home (OCTAVE_OCTFILEDIR) },
+    { "octetcdir", subst_octave_home (OCTAVE_OCTETCDIR) },
+    { "octincludedir", subst_octave_home (OCTAVE_OCTINCLUDEDIR) },
+    { "octlibdir", subst_octave_home (OCTAVE_OCTLIBDIR) },
+    { "octtestsdir", subst_octave_home (OCTAVE_OCTTESTSDIR) },
+    { "prefix", subst_octave_home (OCTAVE_PREFIX) },
+    { "release_date", OCTAVE_RELEASE_DATE },
+    { "startupfiledir", subst_octave_home (OCTAVE_STARTUPFILEDIR) },
+    { "version", OCTAVE_VERSION },
+    { 0, octave_value () }
+  };
 
   struct build_info_struct
   {
     const char *key;
     const char *val;
   };
 
   static const build_info_struct build_info[] =
-    {
-      { "AMD_CPPFLAGS", octave::build_env::AMD_CPPFLAGS },
-      { "AMD_LDFLAGS", octave::build_env::AMD_LDFLAGS },
-      { "AMD_LIBS", octave::build_env::AMD_LIBS },
-      { "AR", octave::build_env::AR },
-      { "ARFLAGS", octave::build_env::ARFLAGS },
-      { "ARPACK_CPPFLAGS", octave::build_env::ARPACK_CPPFLAGS },
-      { "ARPACK_LDFLAGS", octave::build_env::ARPACK_LDFLAGS },
-      { "ARPACK_LIBS", octave::build_env::ARPACK_LIBS },
-      { "BLAS_LIBS", octave::build_env::BLAS_LIBS },
-      { "CAMD_CPPFLAGS", octave::build_env::CAMD_CPPFLAGS },
-      { "CAMD_LDFLAGS", octave::build_env::CAMD_LDFLAGS },
-      { "CAMD_LIBS", octave::build_env::CAMD_LIBS },
-      { "CARBON_LIBS", octave::build_env::CARBON_LIBS },
-      { "CC", octave::build_env::CC },
-      { "CCOLAMD_CPPFLAGS", octave::build_env::CCOLAMD_CPPFLAGS },
-      { "CCOLAMD_LDFLAGS", octave::build_env::CCOLAMD_LDFLAGS },
-      { "CCOLAMD_LIBS", octave::build_env::CCOLAMD_LIBS },
-      { "CFLAGS", octave::build_env::CFLAGS },
-      { "CHOLMOD_CPPFLAGS", octave::build_env::CHOLMOD_CPPFLAGS },
-      { "CHOLMOD_LDFLAGS", octave::build_env::CHOLMOD_LDFLAGS },
-      { "CHOLMOD_LIBS", octave::build_env::CHOLMOD_LIBS },
-      { "COLAMD_CPPFLAGS", octave::build_env::COLAMD_CPPFLAGS },
-      { "COLAMD_LDFLAGS", octave::build_env::COLAMD_LDFLAGS },
-      { "COLAMD_LIBS", octave::build_env::COLAMD_LIBS },
-      { "CPICFLAG", octave::build_env::CPICFLAG },
-      { "CPPFLAGS", octave::build_env::CPPFLAGS },
-      { "CURL_CPPFLAGS", octave::build_env::CURL_CPPFLAGS },
-      { "CURL_LDFLAGS", octave::build_env::CURL_LDFLAGS },
-      { "CURL_LIBS", octave::build_env::CURL_LIBS },
-      { "CXSPARSE_CPPFLAGS", octave::build_env::CXSPARSE_CPPFLAGS },
-      { "CXSPARSE_LDFLAGS", octave::build_env::CXSPARSE_LDFLAGS },
-      { "CXSPARSE_LIBS", octave::build_env::CXSPARSE_LIBS },
-      { "CXX", octave::build_env::CXX },
-      { "CXXCPP", octave::build_env::CXXCPP },
-      { "CXXFLAGS", octave::build_env::CXXFLAGS },
-      { "CXXPICFLAG", octave::build_env::CXXPICFLAG },
-      { "DEFS", octave::build_env::DEFS },
-      { "DL_LD", octave::build_env::DL_LD },
-      { "DL_LDFLAGS", octave::build_env::DL_LDFLAGS },
-      { "DL_LIBS", octave::build_env::DL_LIBS },
-      { "GCC_VERSION", octave::build_env::GCC_VERSION },
-      { "GXX_VERSION", octave::build_env::GXX_VERSION },
-      { "EXEEXT", octave::build_env::EXEEXT },
-      { "F77", octave::build_env::F77 },
-      { "F77_FLOAT_STORE_FLAG", octave::build_env::F77_FLOAT_STORE_FLAG },
-      { "F77_INTEGER_8_FLAG", octave::build_env::F77_INTEGER_8_FLAG },
-      { "FFLAGS", octave::build_env::FFLAGS },
-      { "FFTW3_CPPFLAGS", octave::build_env::FFTW3_CPPFLAGS },
-      { "FFTW3_LDFLAGS", octave::build_env::FFTW3_LDFLAGS },
-      { "FFTW3_LIBS", octave::build_env::FFTW3_LIBS },
-      { "FFTW3F_CPPFLAGS", octave::build_env::FFTW3F_CPPFLAGS },
-      { "FFTW3F_LDFLAGS", octave::build_env::FFTW3F_LDFLAGS },
-      { "FFTW3F_LIBS", octave::build_env::FFTW3F_LIBS },
-      { "FLIBS", octave::build_env::FLIBS },
-      { "FLTK_CPPFLAGS", octave::build_env::FLTK_CPPFLAGS },
-      { "FLTK_LDFLAGS", octave::build_env::FLTK_LDFLAGS },
-      { "FLTK_LIBS", octave::build_env::FLTK_LIBS },
-      { "FONTCONFIG_CPPFLAGS", octave::build_env::FONTCONFIG_CPPFLAGS },
-      { "FONTCONFIG_LIBS", octave::build_env::FONTCONFIG_LIBS },
-      { "FPICFLAG", octave::build_env::FPICFLAG },
-      { "FT2_CPPFLAGS", octave::build_env::FT2_CPPFLAGS },
-      { "FT2_LIBS", octave::build_env::FT2_LIBS },
-      { "GLPK_CPPFLAGS", octave::build_env::GLPK_CPPFLAGS },
-      { "GLPK_LDFLAGS", octave::build_env::GLPK_LDFLAGS },
-      { "GLPK_LIBS", octave::build_env::GLPK_LIBS },
-      { "GNUPLOT", octave::build_env::GNUPLOT },
-      { "HDF5_CPPFLAGS", octave::build_env::HDF5_CPPFLAGS },
-      { "HDF5_LDFLAGS", octave::build_env::HDF5_LDFLAGS },
-      { "HDF5_LIBS", octave::build_env::HDF5_LIBS },
-      { "LAPACK_LIBS", octave::build_env::LAPACK_LIBS },
-      { "LDFLAGS", octave::build_env::LDFLAGS },
-      { "LD_CXX", octave::build_env::LD_CXX },
-      { "LD_STATIC_FLAG", octave::build_env::LD_STATIC_FLAG },
-      { "LEX", octave::build_env::LEX },
-      { "LEXLIB", octave::build_env::LEXLIB },
-      { "LFLAGS", octave::build_env::LFLAGS },
-      { "LIBOCTAVE", octave::build_env::LIBOCTAVE },
-      { "LIBOCTINTERP", octave::build_env::LIBOCTINTERP },
-      { "LIBS", octave::build_env::LIBS },
-      { "LLVM_CPPFLAGS", octave::build_env::LLVM_CPPFLAGS },
-      { "LLVM_LDFLAGS", octave::build_env::LLVM_LDFLAGS },
-      { "LLVM_LIBS", octave::build_env::LLVM_LIBS },
-      { "LN_S", octave::build_env::LN_S },
-      { "MAGICK_CPPFLAGS", octave::build_env::MAGICK_CPPFLAGS },
-      { "MAGICK_LDFLAGS", octave::build_env::MAGICK_LDFLAGS },
-      { "MAGICK_LIBS", octave::build_env::MAGICK_LIBS },
-      { "MKOCTFILE_DL_LDFLAGS", octave::build_env::MKOCTFILE_DL_LDFLAGS },
-      { "OCTAVE_LINK_DEPS", octave::build_env::OCTAVE_LINK_DEPS },
-      { "OCTAVE_LINK_OPTS", octave::build_env::OCTAVE_LINK_OPTS },
-      { "OCT_LINK_DEPS", octave::build_env::OCT_LINK_DEPS },
-      { "OCT_LINK_OPTS", octave::build_env::OCT_LINK_OPTS },
-      { "OPENGL_LIBS", octave::build_env::OPENGL_LIBS },
-      { "OSMESA_CPPFLAGS", octave::build_env::OSMESA_CPPFLAGS },
-      { "OSMESA_LDFLAGS", octave::build_env::OSMESA_LDFLAGS },
-      { "OSMESA_LIBS", octave::build_env::OSMESA_LIBS },
-      { "PCRE_CPPFLAGS", octave::build_env::PCRE_CPPFLAGS },
-      { "PCRE_LIBS", octave::build_env::PCRE_LIBS },
-      { "PTHREAD_CFLAGS", octave::build_env::PTHREAD_CFLAGS },
-      { "PTHREAD_LIBS", octave::build_env::PTHREAD_LIBS },
-      { "QHULL_CPPFLAGS", octave::build_env::QHULL_CPPFLAGS },
-      { "QHULL_LDFLAGS", octave::build_env::QHULL_LDFLAGS },
-      { "QHULL_LIBS", octave::build_env::QHULL_LIBS },
-      { "QRUPDATE_CPPFLAGS", octave::build_env::QRUPDATE_CPPFLAGS },
-      { "QRUPDATE_LDFLAGS", octave::build_env::QRUPDATE_LDFLAGS },
-      { "QRUPDATE_LIBS", octave::build_env::QRUPDATE_LIBS },
-      { "QT_CPPFLAGS", octave::build_env::QT_CPPFLAGS },
-      { "QT_LDFLAGS", octave::build_env::QT_LDFLAGS },
-      { "QT_LIBS", octave::build_env::QT_LIBS },
-      { "RANLIB", octave::build_env::RANLIB },
-      { "RDYNAMIC_FLAG", octave::build_env::RDYNAMIC_FLAG },
-      { "READLINE_LIBS", octave::build_env::READLINE_LIBS },
-      { "SED", octave::build_env::SED },
-      { "SHARED_LIBS", octave::build_env::SHARED_LIBS },
-      { "SH_LD", octave::build_env::SH_LD },
-      { "SH_LDFLAGS", octave::build_env::SH_LDFLAGS },
-      { "STATIC_LIBS", octave::build_env::STATIC_LIBS },
-      { "TERM_LIBS", octave::build_env::TERM_LIBS },
-      { "UMFPACK_CPPFLAGS", octave::build_env::UMFPACK_CPPFLAGS },
-      { "UMFPACK_LDFLAGS", octave::build_env::UMFPACK_LDFLAGS },
-      { "UMFPACK_LIBS", octave::build_env::UMFPACK_LIBS },
-      { "WARN_CFLAGS", octave::build_env::WARN_CFLAGS },
-      { "WARN_CXXFLAGS", octave::build_env::WARN_CXXFLAGS },
-      { "X11_INCFLAGS", octave::build_env::X11_INCFLAGS },
-      { "X11_LIBS", octave::build_env::X11_LIBS },
-      { "XTRA_CFLAGS", octave::build_env::XTRA_CFLAGS },
-      { "XTRA_CXXFLAGS", octave::build_env::XTRA_CXXFLAGS },
-      { "YACC", octave::build_env::YACC },
-      { "YFLAGS", octave::build_env::YFLAGS },
-      { "Z_CPPFLAGS", octave::build_env::Z_CPPFLAGS },
-      { "Z_LDFLAGS", octave::build_env::Z_LDFLAGS },
-      { "Z_LIBS", octave::build_env::Z_LIBS },
-      { "config_opts", octave::build_env::config_opts },
-      { 0, 0 },
-    };
+  {
+    { "AMD_CPPFLAGS", octave::build_env::AMD_CPPFLAGS },
+    { "AMD_LDFLAGS", octave::build_env::AMD_LDFLAGS },
+    { "AMD_LIBS", octave::build_env::AMD_LIBS },
+    { "AR", octave::build_env::AR },
+    { "ARFLAGS", octave::build_env::ARFLAGS },
+    { "ARPACK_CPPFLAGS", octave::build_env::ARPACK_CPPFLAGS },
+    { "ARPACK_LDFLAGS", octave::build_env::ARPACK_LDFLAGS },
+    { "ARPACK_LIBS", octave::build_env::ARPACK_LIBS },
+    { "BLAS_LIBS", octave::build_env::BLAS_LIBS },
+    { "CAMD_CPPFLAGS", octave::build_env::CAMD_CPPFLAGS },
+    { "CAMD_LDFLAGS", octave::build_env::CAMD_LDFLAGS },
+    { "CAMD_LIBS", octave::build_env::CAMD_LIBS },
+    { "CARBON_LIBS", octave::build_env::CARBON_LIBS },
+    { "CC", octave::build_env::CC },
+    { "CCOLAMD_CPPFLAGS", octave::build_env::CCOLAMD_CPPFLAGS },
+    { "CCOLAMD_LDFLAGS", octave::build_env::CCOLAMD_LDFLAGS },
+    { "CCOLAMD_LIBS", octave::build_env::CCOLAMD_LIBS },
+    { "CFLAGS", octave::build_env::CFLAGS },
+    { "CHOLMOD_CPPFLAGS", octave::build_env::CHOLMOD_CPPFLAGS },
+    { "CHOLMOD_LDFLAGS", octave::build_env::CHOLMOD_LDFLAGS },
+    { "CHOLMOD_LIBS", octave::build_env::CHOLMOD_LIBS },
+    { "COLAMD_CPPFLAGS", octave::build_env::COLAMD_CPPFLAGS },
+    { "COLAMD_LDFLAGS", octave::build_env::COLAMD_LDFLAGS },
+    { "COLAMD_LIBS", octave::build_env::COLAMD_LIBS },
+    { "CPICFLAG", octave::build_env::CPICFLAG },
+    { "CPPFLAGS", octave::build_env::CPPFLAGS },
+    { "CURL_CPPFLAGS", octave::build_env::CURL_CPPFLAGS },
+    { "CURL_LDFLAGS", octave::build_env::CURL_LDFLAGS },
+    { "CURL_LIBS", octave::build_env::CURL_LIBS },
+    { "CXSPARSE_CPPFLAGS", octave::build_env::CXSPARSE_CPPFLAGS },
+    { "CXSPARSE_LDFLAGS", octave::build_env::CXSPARSE_LDFLAGS },
+    { "CXSPARSE_LIBS", octave::build_env::CXSPARSE_LIBS },
+    { "CXX", octave::build_env::CXX },
+    { "CXXCPP", octave::build_env::CXXCPP },
+    { "CXXFLAGS", octave::build_env::CXXFLAGS },
+    { "CXXPICFLAG", octave::build_env::CXXPICFLAG },
+    { "DEFS", octave::build_env::DEFS },
+    { "DL_LD", octave::build_env::DL_LD },
+    { "DL_LDFLAGS", octave::build_env::DL_LDFLAGS },
+    { "DL_LIBS", octave::build_env::DL_LIBS },
+    { "GCC_VERSION", octave::build_env::GCC_VERSION },
+    { "GXX_VERSION", octave::build_env::GXX_VERSION },
+    { "EXEEXT", octave::build_env::EXEEXT },
+    { "F77", octave::build_env::F77 },
+    { "F77_FLOAT_STORE_FLAG", octave::build_env::F77_FLOAT_STORE_FLAG },
+    { "F77_INTEGER_8_FLAG", octave::build_env::F77_INTEGER_8_FLAG },
+    { "FFLAGS", octave::build_env::FFLAGS },
+    { "FFTW3_CPPFLAGS", octave::build_env::FFTW3_CPPFLAGS },
+    { "FFTW3_LDFLAGS", octave::build_env::FFTW3_LDFLAGS },
+    { "FFTW3_LIBS", octave::build_env::FFTW3_LIBS },
+    { "FFTW3F_CPPFLAGS", octave::build_env::FFTW3F_CPPFLAGS },
+    { "FFTW3F_LDFLAGS", octave::build_env::FFTW3F_LDFLAGS },
+    { "FFTW3F_LIBS", octave::build_env::FFTW3F_LIBS },
+    { "FLIBS", octave::build_env::FLIBS },
+    { "FLTK_CPPFLAGS", octave::build_env::FLTK_CPPFLAGS },
+    { "FLTK_LDFLAGS", octave::build_env::FLTK_LDFLAGS },
+    { "FLTK_LIBS", octave::build_env::FLTK_LIBS },
+    { "FONTCONFIG_CPPFLAGS", octave::build_env::FONTCONFIG_CPPFLAGS },
+    { "FONTCONFIG_LIBS", octave::build_env::FONTCONFIG_LIBS },
+    { "FPICFLAG", octave::build_env::FPICFLAG },
+    { "FT2_CPPFLAGS", octave::build_env::FT2_CPPFLAGS },
+    { "FT2_LIBS", octave::build_env::FT2_LIBS },
+    { "GLPK_CPPFLAGS", octave::build_env::GLPK_CPPFLAGS },
+    { "GLPK_LDFLAGS", octave::build_env::GLPK_LDFLAGS },
+    { "GLPK_LIBS", octave::build_env::GLPK_LIBS },
+    { "GNUPLOT", octave::build_env::GNUPLOT },
+    { "HDF5_CPPFLAGS", octave::build_env::HDF5_CPPFLAGS },
+    { "HDF5_LDFLAGS", octave::build_env::HDF5_LDFLAGS },
+    { "HDF5_LIBS", octave::build_env::HDF5_LIBS },
+    { "LAPACK_LIBS", octave::build_env::LAPACK_LIBS },
+    { "LDFLAGS", octave::build_env::LDFLAGS },
+    { "LD_CXX", octave::build_env::LD_CXX },
+    { "LD_STATIC_FLAG", octave::build_env::LD_STATIC_FLAG },
+    { "LEX", octave::build_env::LEX },
+    { "LEXLIB", octave::build_env::LEXLIB },
+    { "LFLAGS", octave::build_env::LFLAGS },
+    { "LIBOCTAVE", octave::build_env::LIBOCTAVE },
+    { "LIBOCTINTERP", octave::build_env::LIBOCTINTERP },
+    { "LIBS", octave::build_env::LIBS },
+    { "LLVM_CPPFLAGS", octave::build_env::LLVM_CPPFLAGS },
+    { "LLVM_LDFLAGS", octave::build_env::LLVM_LDFLAGS },
+    { "LLVM_LIBS", octave::build_env::LLVM_LIBS },
+    { "LN_S", octave::build_env::LN_S },
+    { "MAGICK_CPPFLAGS", octave::build_env::MAGICK_CPPFLAGS },
+    { "MAGICK_LDFLAGS", octave::build_env::MAGICK_LDFLAGS },
+    { "MAGICK_LIBS", octave::build_env::MAGICK_LIBS },
+    { "MKOCTFILE_DL_LDFLAGS", octave::build_env::MKOCTFILE_DL_LDFLAGS },
+    { "OCTAVE_LINK_DEPS", octave::build_env::OCTAVE_LINK_DEPS },
+    { "OCTAVE_LINK_OPTS", octave::build_env::OCTAVE_LINK_OPTS },
+    { "OCT_LINK_DEPS", octave::build_env::OCT_LINK_DEPS },
+    { "OCT_LINK_OPTS", octave::build_env::OCT_LINK_OPTS },
+    { "OPENGL_LIBS", octave::build_env::OPENGL_LIBS },
+    { "OSMESA_CPPFLAGS", octave::build_env::OSMESA_CPPFLAGS },
+    { "OSMESA_LDFLAGS", octave::build_env::OSMESA_LDFLAGS },
+    { "OSMESA_LIBS", octave::build_env::OSMESA_LIBS },
+    { "PCRE_CPPFLAGS", octave::build_env::PCRE_CPPFLAGS },
+    { "PCRE_LIBS", octave::build_env::PCRE_LIBS },
+    { "PTHREAD_CFLAGS", octave::build_env::PTHREAD_CFLAGS },
+    { "PTHREAD_LIBS", octave::build_env::PTHREAD_LIBS },
+    { "QHULL_CPPFLAGS", octave::build_env::QHULL_CPPFLAGS },
+    { "QHULL_LDFLAGS", octave::build_env::QHULL_LDFLAGS },
+    { "QHULL_LIBS", octave::build_env::QHULL_LIBS },
+    { "QRUPDATE_CPPFLAGS", octave::build_env::QRUPDATE_CPPFLAGS },
+    { "QRUPDATE_LDFLAGS", octave::build_env::QRUPDATE_LDFLAGS },
+    { "QRUPDATE_LIBS", octave::build_env::QRUPDATE_LIBS },
+    { "QT_CPPFLAGS", octave::build_env::QT_CPPFLAGS },
+    { "QT_LDFLAGS", octave::build_env::QT_LDFLAGS },
+    { "QT_LIBS", octave::build_env::QT_LIBS },
+    { "RANLIB", octave::build_env::RANLIB },
+    { "RDYNAMIC_FLAG", octave::build_env::RDYNAMIC_FLAG },
+    { "READLINE_LIBS", octave::build_env::READLINE_LIBS },
+    { "SED", octave::build_env::SED },
+    { "SHARED_LIBS", octave::build_env::SHARED_LIBS },
+    { "SH_LD", octave::build_env::SH_LD },
+    { "SH_LDFLAGS", octave::build_env::SH_LDFLAGS },
+    { "STATIC_LIBS", octave::build_env::STATIC_LIBS },
+    { "TERM_LIBS", octave::build_env::TERM_LIBS },
+    { "UMFPACK_CPPFLAGS", octave::build_env::UMFPACK_CPPFLAGS },
+    { "UMFPACK_LDFLAGS", octave::build_env::UMFPACK_LDFLAGS },
+    { "UMFPACK_LIBS", octave::build_env::UMFPACK_LIBS },
+    { "WARN_CFLAGS", octave::build_env::WARN_CFLAGS },
+    { "WARN_CXXFLAGS", octave::build_env::WARN_CXXFLAGS },
+    { "X11_INCFLAGS", octave::build_env::X11_INCFLAGS },
+    { "X11_LIBS", octave::build_env::X11_LIBS },
+    { "XTRA_CFLAGS", octave::build_env::XTRA_CFLAGS },
+    { "XTRA_CXXFLAGS", octave::build_env::XTRA_CXXFLAGS },
+    { "YACC", octave::build_env::YACC },
+    { "YFLAGS", octave::build_env::YFLAGS },
+    { "Z_CPPFLAGS", octave::build_env::Z_CPPFLAGS },
+    { "Z_LDFLAGS", octave::build_env::Z_LDFLAGS },
+    { "Z_LIBS", octave::build_env::Z_LIBS },
+    { "config_opts", octave::build_env::config_opts },
+    { 0, 0 },
+  };
 
   static octave_scalar_map config;
   static octave_scalar_map build_env;
   static octave_scalar_map build_features = octave::build_env::features ();
 
   if (! initialized)
     {
       int i;
@@ -710,8 +710,9 @@ void
   if (debug_new_delete)
     std::cerr << "__builtin_delete: " << ptr << std::endl;
 
   if (ptr)
     free (ptr);
 }
 
 #endif
+
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -25,8 +25,9 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #warning "toplev.h has been deprecated; use interpreter.h instead"
 
 #include "interpreter.h"
 
 #endif
+
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -413,8 +413,9 @@ See the documentation for the @code{tril
 %! assert (tril (a, -2), lm2);
 %! assert (tril (a, -1), lm1);
 %! assert (tril (a), l0);
 %! assert (tril (a, 1), l1);
 %! assert (tril (a, 2), l2);
 
 %!error tril ()
 */
+
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -167,8 +167,9 @@ convex hull, @var{idx} is NaN.
 %!assert (tsearch (x,y,tri,-1,-1), 1)
 %!assert (tsearch (x,y,tri, 1,-1), 1)
 %!assert (tsearch (x,y,tri,-1, 1), 1)
 %!assert (tsearch (x,y,tri,-1/3, -1/3), 1)
 %!assert (tsearch (x,y,tri, 1, 1), NaN)
 
 %!error tsearch ()
 */
+
diff --git a/libinterp/corefcn/txt-eng.cc b/libinterp/corefcn/txt-eng.cc
--- a/libinterp/corefcn/txt-eng.cc
+++ b/libinterp/corefcn/txt-eng.cc
@@ -32,8 +32,9 @@ text_element_symbol::get_symbol_code (vo
 {
   uint32_t code = invalid_code;
 
   if (0 <= symbol && symbol < num_symbol_codes)
     code = symbol_codes[symbol][0];
 
   return code;
 }
+
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -448,8 +448,9 @@ text_parser::parse (const std::string& s
     parser.reset (new text_parser_tex ());
   else
     parser.reset (new text_parser_none ());
 
   return parser->parse (s);
 }
 
 #endif
+
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -196,17 +196,18 @@ typecast (@var{x}, "uint8")
     }
   else if (array.is_real_type ())
     {
       if (array.is_single_type ())
         get_data_and_bytesize (array.float_array_value (), data, byte_size,
                                old_dims, frame);
       else
         get_data_and_bytesize (array.array_value (), data, byte_size,
-                               old_dims, frame); }
+                               old_dims, frame);
+    }
   else
     error ("typecast: invalid input class: %s",
            array.class_name ().c_str ());
 
   std::string numclass = args(1).string_value ();
 
   if (numclass.size () == 0)
     ;
@@ -286,17 +287,18 @@ typecast (@var{x}, "uint8")
 template <typename ArrayType>
 ArrayType
 do_bitpack (const boolNDArray& bitp)
 {
   typedef typename ArrayType::element_type T;
   octave_idx_type n
     = bitp.numel () / (sizeof (T) * std::numeric_limits<unsigned char>::digits);
 
-  if (n * static_cast<int> (sizeof (T)) * std::numeric_limits<unsigned char>::digits != bitp.numel ())
+  if (n * static_cast<int> (sizeof (T)) *
+      std::numeric_limits<unsigned char>::digits != bitp.numel ())
     error ("bitpack: incorrect number of bits to make up output value");
 
   ArrayType retval (get_vec_dims (bitp.dims (), n));
 
   const bool *bits = bitp.fortran_vec ();
   char *packed = reinterpret_cast<char *> (retval.fortran_vec ());
 
   octave_idx_type m = n * sizeof (T);
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -921,8 +921,9 @@ Undocumented internal function
         }
     }
 
   if (n == 0)
     error ("__ftp_mget__: file not found");
 
   return ovl ();
 }
+
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1486,8 +1486,9 @@ Return true if running in the student ed
   return ovl (false);
 }
 
 /*
 %!assert (isstudent (), false)
 
 %!error isstudent (1)
 */
+
diff --git a/libinterp/corefcn/utils.h b/libinterp/corefcn/utils.h
--- a/libinterp/corefcn/utils.h
+++ b/libinterp/corefcn/utils.h
@@ -133,8 +133,9 @@ do_simple_cellfun (octave_value_list (*f
                    int nargout);
 
 extern OCTINTERP_API
 octave_value
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args);
 
 #endif
+
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -130,17 +130,18 @@ is_valid_function (const octave_value& a
   if (arg.is_string ())
     {
       fcn_name = arg.string_value ();
 
       ans = is_valid_function (fcn_name, warn_for, warn);
     }
   else if (warn)
     // FIXME: Should this be "err" and "error_for", rather than warn?
-    error ("%s: argument must be a string containing function name", warn_for.c_str ());
+    error ("%s: argument must be a string containing function name",
+           warn_for.c_str ());
 
   return ans;
 }
 
 octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer)
@@ -1667,17 +1668,17 @@ do_who (int argc, const string_vector& a
           octave_call_stack::push (tmp_scope, 0);
           frame.add_fcn (octave_call_stack::pop);
 
           frame.add_fcn (symbol_table::clear_variables);
 
           feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
-            + nm + ":\n\n";
+                               + nm + ":\n\n";
 
           retval = do_who (i, argv, return_list, verbose, newmsg);
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
@@ -2685,8 +2686,9 @@ The hook function is expected to be of t
 Octave will call @var{fcn} with the name of the function that requires the
 component and a string describing the missing component.  The hook function
 should return an error message to be displayed.
 @seealso{missing_function_hook}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (missing_component_hook);
 }
+
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -153,8 +153,9 @@ extern OCTINTERP_API bool mislocked (con
 
 extern OCTINTERP_API void clear_function (const std::string& nm);
 extern OCTINTERP_API void clear_variable (const std::string& nm);
 extern OCTINTERP_API void clear_symbol (const std::string& nm);
 
 extern OCTINTERP_API void maybe_missing_function_hook (const std::string& name);
 
 #endif
+
diff --git a/libinterp/corefcn/workspace-element.h b/libinterp/corefcn/workspace-element.h
--- a/libinterp/corefcn/workspace-element.h
+++ b/libinterp/corefcn/workspace-element.h
@@ -84,8 +84,9 @@ private:
   std::string xsymbol;
   std::string xclass_name;
   std::string xvalue;
   std::string xdimension;
   bool xcomplex_flag;
 };
 
 #endif
+
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -1010,8 +1010,9 @@ xleftdiv (const FloatDiagMatrix& a, cons
 FloatComplexDiagMatrix
 xleftdiv (const FloatDiagMatrix& a, const FloatComplexDiagMatrix& b)
 { return dmdm_leftdiv_impl (a, b); }
 
 // -*- 3 -*-
 FloatComplexDiagMatrix
 xleftdiv (const FloatComplexDiagMatrix& a, const FloatComplexDiagMatrix& b)
 { return dmdm_leftdiv_impl (a, b); }
+
diff --git a/libinterp/corefcn/xdiv.h b/libinterp/corefcn/xdiv.h
--- a/libinterp/corefcn/xdiv.h
+++ b/libinterp/corefcn/xdiv.h
@@ -145,8 +145,9 @@ extern FloatComplexMatrix xleftdiv (cons
 extern FloatDiagMatrix xleftdiv (const FloatDiagMatrix& a,
                                  const FloatDiagMatrix& b);
 extern FloatComplexDiagMatrix xleftdiv (const FloatDiagMatrix& a,
                                         const FloatComplexDiagMatrix& b);
 extern FloatComplexDiagMatrix xleftdiv (const FloatComplexDiagMatrix& a,
                                         const FloatComplexDiagMatrix& b);
 
 #endif
+
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -199,8 +199,9 @@ octave_value xfrobnorm (const octave_val
       else if (iscomplex)
         retval = xfrobnorm (x.complex_matrix_value ());
       else
         retval = xfrobnorm (x.matrix_value ());
     }
 
   return retval;
 }
+
diff --git a/libinterp/corefcn/xnorm.h b/libinterp/corefcn/xnorm.h
--- a/libinterp/corefcn/xnorm.h
+++ b/libinterp/corefcn/xnorm.h
@@ -39,8 +39,9 @@ xcolnorms (const octave_value& x, const 
 
 extern OCTINTERP_API octave_value
 xrownorms (const octave_value& x, const octave_value& p);
 
 extern OCTINTERP_API octave_value
 xfrobnorm (const octave_value& x);
 
 #endif
+
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -2777,8 +2777,9 @@ elem_xpow (const FloatComplexNDArray& a,
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
+
diff --git a/libinterp/corefcn/xpow.h b/libinterp/corefcn/xpow.h
--- a/libinterp/corefcn/xpow.h
+++ b/libinterp/corefcn/xpow.h
@@ -196,8 +196,9 @@ extern OCTINTERP_API octave_value elem_x
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
                                              const FloatNDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
                                              const FloatComplex& b);
 extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
                                              const FloatComplexNDArray& b);
 
 #endif
+
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -608,8 +608,9 @@ gzofstream::attach (int fd, std::ios_bas
 void
 gzofstream::close ()
 {
   if (! sb.close ())
     this->setstate (std::ios_base::failbit);
 }
 
 #endif
+
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -500,8 +500,9 @@ operator<<(gzofstream& s, const gzomanip
 // Insert this onto stream to simplify setting of compression level
 inline gzomanip2<int,int>
 setcompression (int l, int s = Z_DEFAULT_STRATEGY)
 { return gzomanip2<int,int>(&setcompression, l, s); }
 
 #endif
 
 #endif
+
diff --git a/libinterp/deprecated-config.h b/libinterp/deprecated-config.h
--- a/libinterp/deprecated-config.h
+++ b/libinterp/deprecated-config.h
@@ -23,8 +23,9 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_config_h)
 #define octave_config_h 1
 
 #include "octave-config.h"
 
 #warning "config.h has been deprecated; there is no need to include it directly"
 
 #endif
+
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -236,8 +236,9 @@ Undocumented internal function.
 
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -392,160 +392,160 @@ Undocumented internal function.
   octave_idx_type nconv;
   if (a_is_complex || b_is_complex)
     {
       ComplexMatrix eig_vec;
       ComplexColumnVector eig_val;
 
       if (have_a_fun)
         nconv = EigsComplexNonSymmetricFunc
-          (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
-           eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-           disp, maxit);
+                (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+                 eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+                 disp, maxit);
       else if (have_sigma)
         {
           if (a_is_sparse)
             nconv = EigsComplexNonSymmetricMatrixShift
-              (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-               maxit);
+                    (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
+                     cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                     maxit);
           else
             nconv = EigsComplexNonSymmetricMatrixShift
-              (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-               maxit);
+                    (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB,
+                     cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                     maxit);
         }
       else
         {
           if (a_is_sparse)
             nconv = EigsComplexNonSymmetricMatrix
-              (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-               maxit);
+                    (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB,
+                     cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                     maxit);
           else
             nconv = EigsComplexNonSymmetricMatrix
-              (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-               maxit);
+                    (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB,
+                     cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                     maxit);
         }
 
       if (nargout < 2)
         retval(0) = eig_val;
       else
         retval = ovl (eig_vec, ComplexDiagMatrix (eig_val), double (info));
     }
   else if (sigmai != 0.)
     {
       // Promote real problem to a complex one.
       ComplexMatrix eig_vec;
       ComplexColumnVector eig_val;
 
       if (have_a_fun)
         nconv = EigsComplexNonSymmetricFunc
-          (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
-           eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-           disp, maxit);
+                (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
+                 eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+                 disp, maxit);
       else
         {
           if (a_is_sparse)
             nconv = EigsComplexNonSymmetricMatrixShift
-              (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
-               eig_val, SparseComplexMatrix (bsmm), permB, cresid,
-               octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                    (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
+                     eig_val, SparseComplexMatrix (bsmm), permB, cresid,
+                     octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
           else
             nconv = EigsComplexNonSymmetricMatrixShift
-              (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
-               eig_val, ComplexMatrix (bmm), permB, cresid,
-               octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                    (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
+                     eig_val, ComplexMatrix (bmm), permB, cresid,
+                     octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
         }
 
       if (nargout < 2)
         retval(0) = eig_val;
       else
         retval = ovl (eig_vec, ComplexDiagMatrix (eig_val), double (info));
     }
   else
     {
       if (symmetric)
         {
           Matrix eig_vec;
           ColumnVector eig_val;
 
           if (have_a_fun)
             nconv = EigsRealSymmetricFunc
-              (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-               eig_val, resid, octave_stdout, tol, (nargout > 1),
-               cholB, disp, maxit);
+                    (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                     eig_val, resid, octave_stdout, tol, (nargout > 1),
+                     cholB, disp, maxit);
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsRealSymmetricMatrixShift
-                  (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else
                 nconv = EigsRealSymmetricMatrixShift
-                  (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
             }
           else
             {
               if (a_is_sparse)
                 nconv = EigsRealSymmetricMatrix
-                  (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else
                 nconv = EigsRealSymmetricMatrix
-                  (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                   resid, octave_stdout, tol, (nargout > 1), cholB,
-                   disp, maxit);
+                        (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                         resid, octave_stdout, tol, (nargout > 1), cholB,
+                         disp, maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             retval = ovl (eig_vec, DiagMatrix (eig_val), double (info));
         }
       else
         {
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
           if (have_a_fun)
             nconv = EigsRealNonSymmetricFunc
-              (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-               eig_val, resid, octave_stdout, tol, (nargout > 1),
-               cholB, disp, maxit);
+                    (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                     eig_val, resid, octave_stdout, tol, (nargout > 1),
+                     cholB, disp, maxit);
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsRealNonSymmetricMatrixShift
-                  (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else
                 nconv = EigsRealNonSymmetricMatrixShift
-                  (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
             }
           else
             {
               if (a_is_sparse)
                 nconv = EigsRealNonSymmetricMatrix
-                  (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
-                   permB, resid, octave_stdout, tol, (nargout > 1),
-                   cholB, disp, maxit);
+                        (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                         permB, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else
                 nconv = EigsRealNonSymmetricMatrix
-                  (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                   resid, octave_stdout, tol, (nargout > 1), cholB,
-                   disp, maxit);
+                        (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                         resid, octave_stdout, tol, (nargout > 1), cholB,
+                         disp, maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             retval = ovl (eig_vec, ComplexDiagMatrix (eig_val), double (info));
         }
     }
@@ -570,8 +570,9 @@ Undocumented internal function.
 
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -120,17 +120,18 @@ Undocumented internal function.
               fname = fc.value (n);
               idx = fname.find_last_of (sep);
               file_cell(n - 1) = fname.substr (idx + 1);
             }
           retval(0) = file_cell;
         }
 
       if (multi_type == Fl_File_Chooser::DIRECTORY)
-        retval(0) = octave::sys::file_ops::native_separator_path (std::string (fc.value ()));
+        retval(0) = octave::sys::file_ops::native_separator_path (
+                      std::string (fc.value ()));
       else
         {
           retval(1) = octave::sys::file_ops::native_separator_path (
                         std::string (fc.directory ()) + sep);
           retval(2) = fc.filter_value () + 1;
         }
     }
 
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -626,8 +626,9 @@ Undocumented internal function.
 
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -114,17 +114,17 @@ public:
   OpenGL_fltk (int xx, int yy, int ww, int hh, double num)
     : Fl_Gl_Window (xx, yy, ww, hh, 0), number (num), renderer (),
       in_zoom (false), zoom_box ()
   {
 #if defined (HAVE_OPENGL)
     // Ask for double buffering and a depth buffer.
     mode (FL_DEPTH | FL_DOUBLE | FL_MULTISAMPLE);
 #else
-  err_disabled_feature ("OpenGL_fltk", "OpenGL");
+    err_disabled_feature ("OpenGL_fltk", "OpenGL");
 #endif
   }
 
   ~OpenGL_fltk (void) { }
 
   void zoom (bool z)
   {
     in_zoom = z;
@@ -144,20 +144,20 @@ public:
 
   void resize (int xx, int yy, int ww, int hh)
   {
 #if defined (HAVE_OPENGL)
 
     Fl_Gl_Window::resize (xx, yy, ww, hh);
 
 #else
-  // This shouldn't happen because construction of Opengl_fltk
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of Opengl_fltk
+    // objects is supposed to be impossible if OpenGL is not available.
 
-  panic_impossible ();
+    panic_impossible ();
 #endif
   }
 
   bool renumber (double new_number)
   {
     bool retval = false;
 
     if (number != new_number)
@@ -188,38 +188,38 @@ private:
       }
 
     renderer.draw (gh_manager::get_object (number));
 
     if (zoom ())
       overlay ();
 
 #else
-  // This shouldn't happen because construction of Opengl_fltk
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of Opengl_fltk
+    // objects is supposed to be impossible if OpenGL is not available.
 
-  panic_impossible ();
+    panic_impossible ();
 #endif
   }
 
   void zoom_box_vertex (void)
   {
 #if defined (HAVE_OPENGL)
 
     glVertex2d (zoom_box(0), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(1));
 
 #else
-  // This shouldn't happen because construction of Opengl_fltk
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of Opengl_fltk
+    // objects is supposed to be impossible if OpenGL is not available.
 
-  panic_impossible ();
+    panic_impossible ();
 #endif
   }
 
   void overlay (void)
   {
 #if defined (HAVE_OPENGL)
 
     glPushMatrix ();
@@ -244,20 +244,20 @@ private:
     glColor4f (0.45, 0.62, 0.81, 0.9);
     zoom_box_vertex ();
     glEnd ();
 
     glPopAttrib ();
     glPopMatrix ();
 
 #else
-  // This shouldn't happen because construction of Opengl_fltk
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of Opengl_fltk
+    // objects is supposed to be impossible if OpenGL is not available.
 
-  panic_impossible ();
+    panic_impossible ();
 #endif
   }
 
   int handle (int event)
   {
 #if defined (HAVE_OPENGL)
 
     switch (event)
@@ -269,20 +269,20 @@ private:
       case FL_LEAVE:
         cursor (FL_CURSOR_DEFAULT);
         return 1;
       }
 
     return Fl_Gl_Window::handle (event);
 
 #else
-  // This shouldn't happen because construction of Opengl_fltk
-  // objects is supposed to be impossible if OpenGL is not available.
+    // This shouldn't happen because construction of Opengl_fltk
+    // objects is supposed to be impossible if OpenGL is not available.
 
-  panic_impossible ();
+    panic_impossible ();
 #endif
   }
 };
 
 void script_cb (Fl_Widget*, void* data)
 {
   static_cast<uimenu::properties*> (data)->execute_callback ();
 }
@@ -551,17 +551,18 @@ public:
             else
               item->hide ();
           }
       }
   }
 
   void update_position (uimenu::properties& uimenup, int pos)
   {
-    uimenup.get_property ("position").set (octave_value (static_cast<double> (pos)), true, false);
+    uimenup.get_property ("position").set (octave_value (static_cast<double> (pos)),
+                                           true, false);
   }
 
   void add_entry (uimenu::properties& uimenup)
   {
 
     std::string fltk_label = uimenup.get_fltk_label ();
 
     if (! fltk_label.empty ())
@@ -633,19 +634,19 @@ public:
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
 
             // if no pos yet, delay adding menu until after other menus
             int pos = kprop.get_position ();
             if (pos <= 0)
               delayed_menus.push_back ((len - (ii + 1)));
             else
-             {
-               add_to_menu (kprop);
-             }
+              {
+                add_to_menu (kprop);
+              }
           }
       }
 
     // create any delayed menus
     for (size_t ii = 0; ii < delayed_menus.size (); ii++)
       {
         graphics_object kgo = gh_manager::get_object (kids (delayed_menus[ii]));
 
@@ -675,20 +676,20 @@ public:
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
 
             // if no pos yet, delay adding menu until after other menus
             int pos = kprop.get_position ();
             if (pos <= 0)
               delayed_menus.push_back ((len - (ii + 1)));
             else
-             {
-               add_to_menu (kprop);
-               update_position (kprop, ++count);
-             }
+              {
+                add_to_menu (kprop);
+                update_position (kprop, ++count);
+              }
           }
       }
 
     // create any delayed menus
     for (size_t ii = 0; ii < delayed_menus.size (); ii++)
       {
         graphics_object kgo = gh_manager::get_object (kids (delayed_menus[ii]));
 
@@ -1493,17 +1494,17 @@ private:
 
                       gh = pixel2axes_or_ca (pos_x, pos_y);
 
                       if (gh.ok ())
                         {
                           ax_obj = gh_manager::get_object (gh);
                           set_axes_currentpoint (ax_obj, pos_x, pos_y);
                         }
-                     }
+                    }
 
                   fp.execute_keypressfcn (evt);
                 }
 
               // Handle special keys used in toolbar
               switch (e_key)
                 {
                 case 'a':
@@ -1654,21 +1655,21 @@ private:
                           double x0, y0, x1, y1;
                           Matrix pos = fp.get_boundingbox (true);
                           pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
                           pixel2pos (ax_obj, Fl::event_x (),
                                      Fl::event_y () - menu_dy (),
                                      x1, y1);
 
                           if (pan_enabled ())
-                          {
-                            std::string mode = pan_mode ();
+                            {
+                              std::string mode = pan_mode ();
 
-                            ap.translate_view (mode, x0, x1, y0, y1);
-                          }
+                              ap.translate_view (mode, x0, x1, y0, y1);
+                            }
                           else if (rotate_enabled ())
                             {
                               double daz, del;
                               daz = (Fl::event_x () - pos_x) / pos(2) * 360;
                               del = (Fl::event_y () - menu_dy () - pos_y)
                                     / pos(3) * 360;
                               ap.rotate_view (del, daz);
                             }
@@ -2437,8 +2438,9 @@ Undocumented internal function.
   err_disabled_feature ("__init_fltk__", "OpenGL and FLTK");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -242,8 +242,9 @@ Undocumented internal function.
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -242,8 +242,9 @@ instead.
 %!     img_fp = squeeze (sum (sum (img), 2));
 %!     assert (img_fp, [59281711; 59281711; 59482179], -0.05);
 %!   unwind_protect_cleanup
 %!     close (hf);
 %!     unlink (fn);
 %!   end_unwind_protect
 %! endif
 */
+
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -344,8 +344,9 @@ Undocumented internal function.
 
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -199,8 +199,9 @@ The author of the code itself is Timothy
 %! assert(amd (A2, opts), [1:30]);
 %! opts.aggressive = 1;
 %! assert(amd (A2, opts), [1:30]);
 
 %!error <S must be a square matrix|was unavailable or disabled> amd (A)
 %!error amd (A2, 2)
 %!error <matrix S is corrupted|was unavailable or disabled> amd ([])
 */
+
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -2650,8 +2650,9 @@ Undocumented internal function.
   err_disabled_feature ("__player_stop__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_player (args(0))->stop ();
   return ovl ();
 #endif
 }
+
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -105,17 +105,18 @@ is stored in the audio file.
 
       if (range.numel () != 2)
         error ("audioread: invalid specification for range of frames");
 
       double dstart = octave::math::isinf (range(0)) ? info.frames : range(0);
       double dend = octave::math::isinf (range(1)) ? info.frames : range(1);
 
       if (dstart < 1 || dstart > dend || dend > info.frames
-          || octave::math::x_nint (dstart) != dstart || octave::math::x_nint (dend) != dend)
+          || octave::math::x_nint (dstart) != dstart
+          || octave::math::x_nint (dend) != dend)
         error ("audioread: invalid specification for range of frames");
 
       start = dstart - 1;
       end = dend;
     }
 
   sf_count_t items = end - start;
 
@@ -598,8 +599,9 @@ with names that start with @var{format}.
 
   err_disabled_feature ("audioformats",
                         "getting sound formats through libsndfile");
 
 #endif
 
   return octave_value ();
 }
+
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -523,17 +523,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
           CSYMAMD_NAME (_report)(stats);
 
           error ("csymamd: internal error!");
         }
     }
   else
     {
       if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
-                            &calloc, &free, 0, -1))
+                             &calloc, &free, 0, -1))
         {
           CSYMAMD_NAME (_report)(stats);
 
           error ("csymamd: internal error!");
         }
     }
 
   // return the permutation vector
@@ -568,8 +568,9 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
   octave_unused_parameter (args);
   octave_unused_parameter (nargout);
 
   err_disabled_feature ("csymamd", "CCOLAMD");
 
 #endif
 }
+
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -1318,8 +1318,9 @@ triangular, return the Cholesky@tie{}fac
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 %!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
+
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -586,17 +586,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
   if (n_row != n_col)
     err_square_matrix_required ("symamd", "S");
 
   // Allocate workspace for symamd
   OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
   if (! SYMAMD_NAME () (n_col, ridx, cidx, perm,
-                       knobs, stats, &calloc, &free))
+                        knobs, stats, &calloc, &free))
     {
       SYMAMD_NAME (_report)(stats);
 
       error ("symamd: internal error!");
     }
 
   // column elimination tree post-ordering
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
@@ -750,8 +750,9 @@ permutations on the tree.
       for (octave_idx_type i = 0; i < n_col; i++)
         postorder(i) = post[i] + 1;
 
       retval(1) = postorder;
     }
 
   return retval;
 }
+
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -330,8 +330,9 @@ convex hull is calculated.
 %! assert (h, [1 2 3;1 2 4; 1 3 4; 2 3 4]);
 %! assert (v, 8/3, 10*eps);
 
 %!testif HAVE_QHULL
 %! triangle=[0 0; 1 1; 1 0; 1 2];
 %! h = convhulln (triangle);
 %! assert (size (h), [3 2]);
 */
+
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -205,8 +205,9 @@ such the numerical rank of the matrix @v
 /*
 %!testif HAVE_CXSPARSE
 %! assert (sprank (speye (20)), 20);
 %!testif HAVE_CXSPARSE
 %! assert (sprank ([1,0,2,0;2,0,4,0]), 2);
 
 %!error sprank (1,2)
 */
+
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -301,17 +301,17 @@ used per default.
 #else
           err_disabled_feature ("fftw", "multithreaded FFTW");
 #endif
         }
       else //threads getter
 #if defined (HAVE_FFTW3_THREADS)
         retval = octave_value (octave_fftw_planner::threads());
 #else
-      retval = 1;
+        retval = 1;
 #endif
     }
   else
     error ("fftw: unrecognized argument");
 
   return retval;
 
 #else
@@ -378,8 +378,9 @@ used per default.
 %!error fftw ("invalid")
 %!error fftw ("planner", "invalid")
 %!error fftw ("planner", 2)
 %!error fftw ("dwisdom", "invalid")
 %!error fftw ("swisdom", "invalid")
 %!error fftw ("threads", "invalid")
 %!error fftw ("threads", -3)
  */
+
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -419,56 +419,56 @@ namespace octave
   string_vector
   xzip (const Array<std::string>& source_patterns,
         const std::function<std::string(const std::string&)>& mk_dest_path)
   {
     std::list<std::string> dest_paths;
 
     std::function<void(const std::string&)> walk;
     walk = [&walk, &mk_dest_path, &dest_paths] (const std::string& path) -> void
-      {
-        const octave::sys::file_stat fs (path);
-        // is_dir and is_reg will return false if failed to stat.
-        if (fs.is_dir ())
-          {
-            octave::sys::dir_entry dir (path);
-            if (dir)
-              {
-                // Collect the whole list of filenames first, before recursion
-                // to avoid issues with infinite loop if the action generates
-                // files in the same directory (highly likely).
-                string_vector dirlist = dir.read ();
-                for (octave_idx_type i = 0; i < dirlist.numel (); i++)
-                  if (dirlist(i) != "." && dirlist(i) != "..")
-                    walk (octave::sys::file_ops::concat (path, dirlist(i)));
-              }
-            // Note that we skip any problem with directories.
-          }
-        else if (fs.is_reg ())
-          {
-            const std::string dest_path = mk_dest_path (path);
-            try
-              {
-                X::zip (path, dest_path);
-              }
-            catch (...)
-              {
-                // Error "handling" is not including filename on the output list.
-                // Also remove created file which maybe was not even created
-                // in the first place.  Note that it is possible for the file
-                // to exist in the first place and for X::zip to not have
-                // clobber it yet but we remove it anyway by design.
-                octave::sys::unlink (dest_path);
-                return;
-              }
-            dest_paths.push_front (dest_path);
-          }
-        // Skip all other file types and errors.
-        return;
-      };
+    {
+      const octave::sys::file_stat fs (path);
+      // is_dir and is_reg will return false if failed to stat.
+      if (fs.is_dir ())
+        {
+          octave::sys::dir_entry dir (path);
+          if (dir)
+            {
+              // Collect the whole list of filenames first, before recursion
+              // to avoid issues with infinite loop if the action generates
+              // files in the same directory (highly likely).
+              string_vector dirlist = dir.read ();
+              for (octave_idx_type i = 0; i < dirlist.numel (); i++)
+                if (dirlist(i) != "." && dirlist(i) != "..")
+                  walk (octave::sys::file_ops::concat (path, dirlist(i)));
+            }
+          // Note that we skip any problem with directories.
+        }
+      else if (fs.is_reg ())
+        {
+          const std::string dest_path = mk_dest_path (path);
+          try
+            {
+              X::zip (path, dest_path);
+            }
+          catch (...)
+            {
+              // Error "handling" is not including filename on the output list.
+              // Also remove created file which maybe was not even created
+              // in the first place.  Note that it is possible for the file
+              // to exist in the first place and for X::zip to not have
+              // clobber it yet but we remove it anyway by design.
+              octave::sys::unlink (dest_path);
+              return;
+            }
+          dest_paths.push_front (dest_path);
+        }
+      // Skip all other file types and errors.
+      return;
+    };
 
     for (octave_idx_type i = 0; i < source_patterns.numel (); i++)
       {
         const glob_match pattern (octave::sys::file_ops::tilde_expand (source_patterns(i)));
         const string_vector filepaths = pattern.glob ();
         for (octave_idx_type j = 0; j < filepaths.numel (); j++)
           walk (filepaths(j));
       }
@@ -782,8 +782,9 @@ The optional output @var{filelist} is a 
 %!    confirm_recursive_rmdir (false, "local");
 %!    for idx = 1:numel(out_dirs)
 %!      rmdir (out_dirs{idx}, "s");
 %!    endfor
 %!  end_unwind_protect
 %!endfunction
 %!test run_test_function (@test_save_to_dir)
 */
+
diff --git a/libinterp/dldfcn/oct-qhull.h b/libinterp/dldfcn/oct-qhull.h
--- a/libinterp/dldfcn/oct-qhull.h
+++ b/libinterp/dldfcn/oct-qhull.h
@@ -55,8 +55,9 @@ extern "C" {
 #  include <geom.h>
 #  include <poly.h>
 #  include <io.h>
 #endif
 
 }
 
 #endif
+
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -1636,8 +1636,9 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
 %! j = 2;  i = 4;  p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrshift (Q, R, i, j);
 %! assert (norm (vec (Q'*Q - eye (3,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - AA(:,p)), Inf) < norm (AA)*1e1*eps ("single"));
 */
+
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -413,8 +413,9 @@ cleanup:
 %! fail ("symbfact ({1})", "wrong type argument 'cell'");
 %! fail ("symbfact (sparse (1), {1})", "TYP must be a string");
 %! fail ("symbfact (sparse (1), 'foobar')", 'unrecognized TYP "foobar"');
 %! fail ("symbfact (sparse (1), 'sym', {'L'})", "MODE must be a string");
 %! fail ('symbfact (sparse (1), "sym", "foobar")', 'unrecognized MODE "foobar"');
 %! fail ("symbfact (sparse ([1, 2; 3, 4; 5, 6]))", "S must be a square matrix");
 
 */
+
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -686,8 +686,9 @@ Mathematics, ISBN 0-13-165274-5, 1981.
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     std::swap (P.elem (i), P.elem (j));
 
   // increment all indices, since Octave is not C
   return ovl (P+1);
 }
+
diff --git a/libinterp/liboctinterp-build-info.h b/libinterp/liboctinterp-build-info.h
--- a/libinterp/liboctinterp-build-info.h
+++ b/libinterp/liboctinterp-build-info.h
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include <ctime>
 
 #include <string>
 
 extern OCTAVE_API std::string liboctinterp_hg_id (void);
 
 #endif
+
diff --git a/libinterp/liboctinterp-build-info.in.cc b/libinterp/liboctinterp-build-info.in.cc
--- a/libinterp/liboctinterp-build-info.in.cc
+++ b/libinterp/liboctinterp-build-info.in.cc
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include "liboctinterp-build-info.h"
 
 std::string
 liboctinterp_hg_id (void)
 {
   return "%OCTAVE_HG_ID%";
 }
+
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -229,8 +229,9 @@ protected:
 
 private:
 
   mutable octave_value dense_cache;
 
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -400,17 +400,18 @@ octave_base_int_matrix<T>::load_binary (
     }
 
   this->matrix = m;
   return true;
 }
 
 template <typename T>
 bool
-octave_base_int_matrix<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+octave_base_int_matrix<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                      bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   dim_vector dv = this->dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
@@ -693,17 +694,18 @@ octave_base_int_scalar<T>::load_binary (
         break;
       }
   this->scalar = tmp;
   return true;
 }
 
 template <typename T>
 bool
-octave_base_int_scalar<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+octave_base_int_scalar<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                      bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -152,8 +152,9 @@ public:
                     octave::mach_info::float_format);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -220,49 +220,49 @@ octave_base_matrix<MT>::assign (const oc
   // Same variable as used in the for loop in the default case.
 
   octave_idx_type k = 0;
 
   try
     {
       switch (n_idx)
         {
-          case 0:
-            panic_impossible ();
-            break;
+        case 0:
+          panic_impossible ();
+          break;
 
-          case 1:
-            {
-              idx_vector i = idx (0).index_vector ();
+        case 1:
+          {
+            idx_vector i = idx (0).index_vector ();
 
-              matrix.assign (i, rhs);
-            }
-            break;
+            matrix.assign (i, rhs);
+          }
+          break;
 
-          case 2:
-            {
-              idx_vector i = idx (0).index_vector ();
+        case 2:
+          {
+            idx_vector i = idx (0).index_vector ();
 
-              k = 1;
-              idx_vector j = idx (1).index_vector ();
+            k = 1;
+            idx_vector j = idx (1).index_vector ();
 
-              matrix.assign (i, j, rhs);
-            }
-            break;
+            matrix.assign (i, j, rhs);
+          }
+          break;
 
-          default:
-            {
-              Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
+        default:
+          {
+            Array<idx_vector> idx_vec (dim_vector (n_idx, 1));
 
-              for (k = 0; k < n_idx; k++)
-                idx_vec(k) = idx(k).index_vector ();
+            for (k = 0; k < n_idx; k++)
+              idx_vec(k) = idx(k).index_vector ();
 
-              matrix.assign (idx_vec, rhs);
-            }
-            break;
+            matrix.assign (idx_vec, rhs);
+          }
+          break;
         }
     }
   catch (const octave::index_exception& e)
     {
       octave::err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -208,8 +208,9 @@ protected:
 private:
 
   // No assignment.
 
   octave_base_matrix& operator = (const octave_base_matrix&);
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -155,8 +155,9 @@ public:
 
 protected:
 
   // The value of this scalar.
   ST scalar;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -535,8 +535,9 @@ octave_base_sparse<T>::map (octave_base_
           default:
             break;
           }
       }
     }
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -182,8 +182,9 @@ protected:
   octave_value map (octave_base_value::unary_mapper_t umap) const;
 
   T matrix;
 
   mutable MatrixType typ;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1585,8 +1585,9 @@ The original variable value is restored 
 %! sparse_auto_mutate (false);
 %! s(:, 1) = 1;
 %! assert (typeinfo (s), "sparse matrix");
 %! sparse_auto_mutate (true);
 %! s(1, :) = 1;
 %! assert (typeinfo (s), "matrix");
 %! sparse_auto_mutate (false);
 */
+
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -869,8 +869,9 @@ make_idx_args (const std::string& type,
                const std::list<octave_value_list>& idx,
                const std::string& who);
 
 // Tells whether some regular octave_value_base methods are being called from
 // within the "builtin" function.
 extern OCTINTERP_API bool called_from_builtin (void);
 
 #endif
+
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -546,17 +546,18 @@ octave_bool_matrix::load_hdf5 (octave_hd
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   octave_idx_type nel = dv.numel ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
-  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, htmp)
+  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, htmp)
       >= 0)
     {
       retval = true;
 
       boolNDArray btmp (dv);
       for (octave_idx_type i = 0; i < nel; i++)
         btmp.elem (i) = htmp[i];
 
@@ -635,8 +636,9 @@ Compatibility Note: Octave accepts compl
 %! m = eye (2) != 0;
 %! s = ! 0;
 %! c = {"double", "single", "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "logical"};
 %! for i = 1:numel (c)
 %!   assert (logical (eye (2, c{i})), m);
 %!   assert (logical (eye (1, c{i})), s);
 %! endfor
 */
+
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -243,8 +243,9 @@ public:
   }
 
 protected:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -52,17 +52,18 @@ along with Octave; see the file COPYING.
 template class OCTINTERP_API octave_base_sparse<SparseBoolMatrix>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix,
                                      "sparse bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
+  const octave_sparse_bool_matrix& v =
+    dynamic_cast<const octave_sparse_bool_matrix&> (a);
 
   return
     new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
 
 octave_base_value::type_conv_info
 octave_sparse_bool_matrix::numeric_conversion_function (void) const
 {
@@ -331,32 +332,33 @@ octave_sparse_bool_matrix::load_binary (
     return false;
 
   matrix = m;
 
   return true;
 }
 
 bool
-octave_sparse_bool_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+octave_sparse_bool_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                      bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 #if defined (HAVE_HDF5_18)
-  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
-                               octave_H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT,
+                               octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
@@ -367,17 +369,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -392,17 +395,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -417,17 +421,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -455,17 +460,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -493,17 +499,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -518,17 +525,18 @@ octave_sparse_bool_matrix::save_hdf5 (oc
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -590,17 +598,18 @@ octave_sparse_bool_matrix::load_hdf5 (oc
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, &nr)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, &nr)
       < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -615,17 +624,18 @@ octave_sparse_bool_matrix::load_hdf5 (oc
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, &nc)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, &nc)
       < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -640,17 +650,18 @@ octave_sparse_bool_matrix::load_hdf5 (oc
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, &nz)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, &nz)
       < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -685,17 +696,18 @@ octave_sparse_bool_matrix::load_hdf5 (oc
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, itmp)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, itmp)
       < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -813,8 +825,9 @@ octave_sparse_bool_matrix::as_mxArray (v
       ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < columns () + 1; i++)
     jc[i] = matrix.cidx (i);
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -153,8 +153,9 @@ public:
   }
 
 protected:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -313,8 +313,9 @@ octave_bool::as_mxArray (void) const
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, 1, 1, mxREAL);
 
   bool *pr = static_cast<bool *> (retval->get_data ());
 
   pr[0] = scalar;
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -255,8 +255,9 @@ public:
   }
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -118,17 +118,17 @@ octave_builtin::do_multi_index_op (int n
   if (lvalue_list || curr_lvalue_list)
     {
       frame.protect_var (curr_lvalue_list);
       curr_lvalue_list = lvalue_list;
     }
 
   BEGIN_PROFILER_BLOCK (octave_builtin)
 
-    retval = (*f) (args, nargout);
+  retval = (*f) (args, nargout);
   // Do not allow null values to be returned from functions.
   // FIXME: perhaps true builtins should be allowed?
   retval.make_storable_values ();
   // Fix the case of a single undefined value.
   // This happens when a compiled function uses
   //   octave_value retval;
   // instead of
   //   octave_value_list retval;
@@ -155,8 +155,9 @@ octave_builtin::stash_jit (jit_type &typ
 
 octave_builtin::fcn
 octave_builtin::function (void) const
 {
   return f;
 }
 
 const std::list<octave_lvalue> *octave_builtin::curr_lvalue_list = 0;
+
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -111,8 +111,9 @@ private:
   octave_builtin (const octave_builtin& ob);
 
   octave_builtin& operator = (const octave_builtin& ob);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -954,31 +954,33 @@ octave_cell::load_binary (std::istream& 
 void *
 octave_cell::mex_get_data (void) const
 {
   clear_cellstr_cache ();
   return matrix.mex_get_data ();
 }
 
 bool
-octave_cell::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+octave_cell::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                        bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   hsize_t rank = dv.ndims ();
   hid_t space_hid, data_hid, size_hid;
   space_hid = data_hid = size_hid = -1;
 
 #if defined (HAVE_HDF5_18)
-  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
 
   if (data_hid < 0)
     return false;
 
   // Have to save cell array shape, since can't have a
@@ -1383,19 +1385,19 @@ octave_cell::as_mxArray (void) const
   return retval;
 }
 
 octave_value
 octave_cell::map (unary_mapper_t umap) const
 {
   switch (umap)
     {
-#define FORWARD_MAPPER(UMAP)                    \
-      case umap_ ## UMAP:                       \
-        return matrix.UMAP ()
+#define FORWARD_MAPPER(UMAP)                  \
+    case umap_ ## UMAP:                       \
+      return matrix.UMAP ()
 
     FORWARD_MAPPER (xisalnum);
     FORWARD_MAPPER (xisalpha);
     FORWARD_MAPPER (xisascii);
     FORWARD_MAPPER (xiscntrl);
     FORWARD_MAPPER (xisdigit);
     FORWARD_MAPPER (xisgraph);
     FORWARD_MAPPER (xislower);
@@ -1407,8 +1409,9 @@ octave_cell::map (unary_mapper_t umap) c
     FORWARD_MAPPER (xtoascii);
     FORWARD_MAPPER (xtolower);
     FORWARD_MAPPER (xtoupper);
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -183,8 +183,9 @@ private:
   { cellstr_cache.reset (); }
 
   mutable std::unique_ptr<Array<std::string> > cellstr_cache;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -272,19 +272,19 @@ static inline int xtoascii (int c)
 
 octave_value
 octave_char_matrix::map (unary_mapper_t umap) const
 {
   octave_value retval;
 
   switch (umap)
     {
-#define STRING_MAPPER(UMAP,FCN,TYPE)                                    \
-      case umap_ ## UMAP:                                               \
-        return octave_value (matrix.map<TYPE, int (&) (int)> (FCN))
+#define STRING_MAPPER(UMAP,FCN,TYPE)                                  \
+    case umap_ ## UMAP:                                               \
+      return octave_value (matrix.map<TYPE, int (&) (int)> (FCN))
 
     STRING_MAPPER (xisalnum, std::isalnum, bool);
     STRING_MAPPER (xisalpha, std::isalpha, bool);
     STRING_MAPPER (xisascii, xisascii, bool);
     STRING_MAPPER (xiscntrl, std::iscntrl, bool);
     STRING_MAPPER (xisdigit, std::isdigit, bool);
     STRING_MAPPER (xisgraph, std::isgraph, bool);
     STRING_MAPPER (xislower, std::islower, bool);
@@ -315,8 +315,9 @@ octave_char_matrix::map (unary_mapper_t 
 
     default:
       error ("%s: argument must be numeric", get_umap_name (umap));
       break;
     }
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-ch-mat.h b/libinterp/octave-value/ov-ch-mat.h
--- a/libinterp/octave-value/ov-ch-mat.h
+++ b/libinterp/octave-value/ov-ch-mat.h
@@ -168,8 +168,9 @@ public:
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -377,21 +377,20 @@ octave_class::subsref (const std::string
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
                 Cell t = tmp.index (idx.front ());
 
                 retval(0) = (t.numel () == 1) ? t(0)
-                  : octave_value (t, true);
+                                              : octave_value (t, true);
 
                 // We handled two index elements, so tell
                 // next_subsref to skip both of them.
-
                 skip++;
               }
             else
               retval(0) = octave_value (map.index (idx.front ()),
                                         c_name, parent_list);
           }
           break;
 
@@ -1386,31 +1385,33 @@ octave_class::load_binary (std::istream&
     map = octave_map (dim_vector (1, 1));
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
-octave_class::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+octave_class::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                         bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   hsize_t hdims[3];
   hid_t group_hid = -1;
   hid_t type_hid = -1;
   hid_t space_hid = -1;
   hid_t class_hid = -1;
   hid_t data_hid = -1;
   octave_map m;
   octave_map::iterator i;
 
 #if defined (HAVE_HDF5_18)
-  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                         octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     goto error_cleanup;
 
   // Add the class name to the group
   type_hid = H5Tcopy (H5T_C_S1); H5Tset_size (type_hid, c_name.length () + 1);
@@ -1418,28 +1419,30 @@ octave_class::save_hdf5 (octave_hdf5_id 
     goto error_cleanup;
 
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     goto error_cleanup;
 #if defined (HAVE_HDF5_18)
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
-                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                         octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                         octave_H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          octave_H5P_DEFAULT);
 #endif
-  if (class_hid < 0 || H5Dwrite (class_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
-                                 octave_H5P_DEFAULT, c_name.c_str ()) < 0)
+  if (class_hid < 0 || H5Dwrite (class_hid, type_hid, octave_H5S_ALL,
+                                 octave_H5S_ALL, octave_H5P_DEFAULT,
+                                 c_name.c_str ()) < 0)
     goto error_cleanup;
 
 #if defined (HAVE_HDF5_18)
-  data_hid = H5Gcreate (group_hid, "value", octave_H5P_DEFAULT, octave_H5P_DEFAULT,
-                        octave_H5P_DEFAULT);
+  data_hid = H5Gcreate (group_hid, "value", octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != "")
     {
@@ -1558,18 +1561,19 @@ octave_class::load_hdf5 (octave_hdf5_id 
   do
     {
       OCTAVE_LOCAL_BUFFER (char, classname, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
-      if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                   classname) < 0)
+      if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, classname)
+          < 0)
         {
           H5Tclose (st_id);
           H5Dclose (data_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Tclose (st_id);
@@ -2063,8 +2067,9 @@ may @emph{only} be called from a class c
       std::string inf_class = fcn->name ();
       if (! symbol_table::set_class_relationship (sup_class, inf_class))
         error ("inferiorto: opposite precedence already set for %s and %s",
                inf_class.c_str (), sup_class.c_str ());
     }
 
   return octave_value();
 }
+
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -280,8 +280,9 @@ public:
 
   typedef std::map<std::string, exemplar_info>::iterator
     exemplar_iterator;
   typedef std::map<std::string, exemplar_info>::const_iterator
     exemplar_const_iterator;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -61,17 +61,17 @@ err_method_access (const std::string& fr
 
   error ("%s: method `%s' has %s access and cannot be run in this context",
          from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 OCTAVE_NORETURN static
 void
 err_property_access (const std::string& from, const cdef_property& prop,
-                       bool is_set = false)
+                     bool is_set = false)
 {
   octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
     acc_s = "class-restricted";
@@ -816,18 +816,18 @@ make_package (const std::string& nm,
 int octave_classdef::t_id (-1);
 
 const std::string octave_classdef::t_name ("object");
 
 void
 octave_classdef::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
-    (octave_classdef::t_name, "<unknown>",
-     octave_value (new octave_classdef ()));
+         (octave_classdef::t_name, "<unknown>",
+          octave_value (new octave_classdef ()));
 }
 
 octave_value_list
 octave_classdef::subsref (const std::string& type,
                           const std::list<octave_value_list>& idx,
                           int nargout)
 {
   size_t skip = 0;
@@ -2015,17 +2015,17 @@ cdef_class::cdef_class_rep::install_meth
               ctor_analyzer a (meth.get_name (), obj_name);
 
               body->accept (a);
 
               std::list<cdef_class> explicit_ctor_list
                 = a.get_constructor_list ();
 
               for (std::list<cdef_class>::const_iterator
-                     it = explicit_ctor_list.begin ();
+                   it = explicit_ctor_list.begin ();
                    it != explicit_ctor_list.end ();
                    ++it)
                 {
 #if DEBUG_TRACE
                   std::cerr << "explicit superclass constructor: "
                             << it->get_name () << std::endl;
 #endif
 
@@ -2049,17 +2049,17 @@ cdef_class::cdef_class_rep::get_methods 
 
   find_methods (meths, false);
 
   Cell c (meths.size (), 1);
 
   int idx = 0;
 
   for (std::map<std::string,cdef_method>::const_iterator
-         it = meths.begin (); it != meths.end (); ++it, ++idx)
+       it = meths.begin (); it != meths.end (); ++it, ++idx)
     c (idx, 0) = to_ov (it->second);
 
   return c;
 }
 
 void
 cdef_class::cdef_class_rep::find_methods (std::map<std::string,
                                           cdef_method>& meths,
@@ -2148,17 +2148,17 @@ cdef_class::cdef_class_rep::get_properti
 
   props = get_property_map (mode);
 
   Cell c (props.size (), 1);
 
   int idx = 0;
 
   for (std::map<std::string,cdef_property>::const_iterator
-         it = props.begin (); it != props.end (); ++it, ++idx)
+       it = props.begin (); it != props.end (); ++it, ++idx)
     c (idx, 0) = to_ov (it->second);
 
   return c;
 }
 
 std::map<std::string, cdef_property>
 cdef_class::cdef_class_rep::get_property_map (int mode)
 {
@@ -3465,19 +3465,21 @@ install_classdef (void)
                       "public", Matrix (), "private"));
   meta_class.install_property
       (make_property (meta_class, "SuperClassList",
                       make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClassList"),
                       "public", Matrix (), "private"));
   // meta.class methods
   meta_class.install_method (make_method (meta_class, "fromName", class_fromName,
                                           "public", true));
-  meta_class.install_method (make_method (meta_class, "fevalStatic", class_fevalStatic,
+  meta_class.install_method (make_method (meta_class, "fevalStatic",
+                                          class_fevalStatic,
                                           "public", false));
-  meta_class.install_method (make_method (meta_class, "getConstant", class_getConstant,
+  meta_class.install_method (make_method (meta_class, "getConstant",
+                                          class_getConstant,
                                           "public", false));
   meta_class.install_method (make_method (meta_class, "eq", class_eq));
   meta_class.install_method (make_method (meta_class, "ne", class_ne));
   meta_class.install_method (make_method (meta_class, "lt", class_lt));
   meta_class.install_method (make_method (meta_class, "le", class_le));
   meta_class.install_method (make_method (meta_class, "gt", class_gt));
   meta_class.install_method (make_method (meta_class, "ge", class_ge));
 
@@ -3770,8 +3772,9 @@ Returns the meta.class object correspond
   return to_ov (obj.get_class ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
+
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -405,17 +405,17 @@ public:
   void put (const std::string& pname, const octave_value& val)
   { map.assign (pname, val); }
 
   octave_value get (const std::string& pname) const
   {
     Cell val = map.contents (pname);
 
     if (val.numel () < 1)
-        error ("get: unknown slot: %s", pname.c_str ());
+      error ("get: unknown slot: %s", pname.c_str ());
 
     return val(0, 0);
   }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context,
            bool auto_add);
@@ -1661,8 +1661,9 @@ private:
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
+
diff --git a/libinterp/octave-value/ov-colon.cc b/libinterp/octave-value/ov-colon.cc
--- a/libinterp/octave-value/ov-colon.cc
+++ b/libinterp/octave-value/ov-colon.cc
@@ -41,8 +41,9 @@ octave_magic_colon::print (std::ostream&
   print_raw (os);
 }
 
 void
 octave_magic_colon::print_raw (std::ostream& os, bool) const
 {
   os << ":";
 }
+
diff --git a/libinterp/octave-value/ov-colon.h b/libinterp/octave-value/ov-colon.h
--- a/libinterp/octave-value/ov-colon.h
+++ b/libinterp/octave-value/ov-colon.h
@@ -74,8 +74,9 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -391,18 +391,18 @@ octave_complex::save_hdf5 (octave_hdf5_i
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Complex tmp = complex_value ();
-  retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     &tmp) >= 0;
+  retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
   octave_unused_parameter (loc_id);
   octave_unused_parameter (name);
@@ -444,18 +444,18 @@ octave_complex::load_hdf5 (octave_hdf5_i
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
   Complex ctmp;
-  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-               &ctmp) >= 0)
+  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, &ctmp) >= 0)
     {
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
@@ -484,57 +484,58 @@ octave_complex::as_mxArray (void) const
   return retval;
 }
 
 octave_value
 octave_complex::map (unary_mapper_t umap) const
 {
   switch (umap)
     {
-#define SCALAR_MAPPER(UMAP, FCN)                \
-      case umap_ ## UMAP:                       \
-        return octave_value (FCN (scalar))
+#define SCALAR_MAPPER(UMAP, FCN)              \
+    case umap_ ## UMAP:                       \
+      return octave_value (FCN (scalar))
 
-      SCALAR_MAPPER (abs, std::abs);
-      SCALAR_MAPPER (acos, octave::math::acos);
-      SCALAR_MAPPER (acosh, octave::math::acosh);
-      SCALAR_MAPPER (angle, std::arg);
-      SCALAR_MAPPER (arg, std::arg);
-      SCALAR_MAPPER (asin, octave::math::asin);
-      SCALAR_MAPPER (asinh, octave::math::asinh);
-      SCALAR_MAPPER (atan, octave::math::atan);
-      SCALAR_MAPPER (atanh, octave::math::atanh);
-      SCALAR_MAPPER (erf, octave::math::erf);
-      SCALAR_MAPPER (erfc, octave::math::erfc);
-      SCALAR_MAPPER (erfcx, octave::math::erfcx);
-      SCALAR_MAPPER (erfi, octave::math::erfi);
-      SCALAR_MAPPER (dawson, octave::math::dawson);
-      SCALAR_MAPPER (ceil, octave::math::ceil);
-      SCALAR_MAPPER (conj, std::conj);
-      SCALAR_MAPPER (cos, std::cos);
-      SCALAR_MAPPER (cosh, std::cosh);
-      SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, octave::math::expm1);
-      SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, octave::math::floor);
-      SCALAR_MAPPER (imag, std::imag);
-      SCALAR_MAPPER (log, std::log);
-      SCALAR_MAPPER (log2, octave::math::log2);
-      SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, octave::math::log1p);
-      SCALAR_MAPPER (real, std::real);
-      SCALAR_MAPPER (round, octave::math::round);
-      SCALAR_MAPPER (roundb, octave::math::roundb);
-      SCALAR_MAPPER (signum, octave::math::signum);
-      SCALAR_MAPPER (sin, std::sin);
-      SCALAR_MAPPER (sinh, std::sinh);
-      SCALAR_MAPPER (sqrt, std::sqrt);
-      SCALAR_MAPPER (tan, std::tan);
-      SCALAR_MAPPER (tanh, std::tanh);
-      SCALAR_MAPPER (isfinite, octave::math::finite);
-      SCALAR_MAPPER (isinf, octave::math::isinf);
-      SCALAR_MAPPER (isna, octave::math::is_NA);
-      SCALAR_MAPPER (isnan, octave::math::isnan);
+    SCALAR_MAPPER (abs, std::abs);
+    SCALAR_MAPPER (acos, octave::math::acos);
+    SCALAR_MAPPER (acosh, octave::math::acosh);
+    SCALAR_MAPPER (angle, std::arg);
+    SCALAR_MAPPER (arg, std::arg);
+    SCALAR_MAPPER (asin, octave::math::asin);
+    SCALAR_MAPPER (asinh, octave::math::asinh);
+    SCALAR_MAPPER (atan, octave::math::atan);
+    SCALAR_MAPPER (atanh, octave::math::atanh);
+    SCALAR_MAPPER (erf, octave::math::erf);
+    SCALAR_MAPPER (erfc, octave::math::erfc);
+    SCALAR_MAPPER (erfcx, octave::math::erfcx);
+    SCALAR_MAPPER (erfi, octave::math::erfi);
+    SCALAR_MAPPER (dawson, octave::math::dawson);
+    SCALAR_MAPPER (ceil, octave::math::ceil);
+    SCALAR_MAPPER (conj, std::conj);
+    SCALAR_MAPPER (cos, std::cos);
+    SCALAR_MAPPER (cosh, std::cosh);
+    SCALAR_MAPPER (exp, std::exp);
+    SCALAR_MAPPER (expm1, octave::math::expm1);
+    SCALAR_MAPPER (fix, octave::math::fix);
+    SCALAR_MAPPER (floor, octave::math::floor);
+    SCALAR_MAPPER (imag, std::imag);
+    SCALAR_MAPPER (log, std::log);
+    SCALAR_MAPPER (log2, octave::math::log2);
+    SCALAR_MAPPER (log10, std::log10);
+    SCALAR_MAPPER (log1p, octave::math::log1p);
+    SCALAR_MAPPER (real, std::real);
+    SCALAR_MAPPER (round, octave::math::round);
+    SCALAR_MAPPER (roundb, octave::math::roundb);
+    SCALAR_MAPPER (signum, octave::math::signum);
+    SCALAR_MAPPER (sin, std::sin);
+    SCALAR_MAPPER (sinh, std::sinh);
+    SCALAR_MAPPER (sqrt, std::sqrt);
+    SCALAR_MAPPER (tan, std::tan);
+    SCALAR_MAPPER (tanh, std::tanh);
+    SCALAR_MAPPER (isfinite, octave::math::finite);
+    SCALAR_MAPPER (isinf, octave::math::isinf);
+    SCALAR_MAPPER (isna, octave::math::is_NA);
+    SCALAR_MAPPER (isnan, octave::math::isnan);
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -196,8 +196,9 @@ public:
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_complex octave_complex_scalar;
 
 #endif
+
diff --git a/libinterp/octave-value/ov-cs-list.h b/libinterp/octave-value/ov-cs-list.h
--- a/libinterp/octave-value/ov-cs-list.h
+++ b/libinterp/octave-value/ov-cs-list.h
@@ -83,8 +83,9 @@ private:
 
   // The list of Octave values.
   octave_value_list lst;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -38,33 +38,35 @@ along with Octave; see the file COPYING.
 template class octave_base_diag<ComplexDiagMatrix, ComplexMatrix>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_diag_matrix,
                                      "complex diagonal matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
+  const octave_complex_diag_matrix& v =
+    dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info
            (default_numeric_conversion_function,
             octave_complex_matrix::static_type_id ());
 }
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
+  const octave_complex_diag_matrix& v =
+    dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_float_complex_diag_matrix
                (v.float_complex_diag_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_demotion_function (void) const
 {
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -93,8 +93,9 @@ private:
 
   bool chk_valid_scalar (const octave_value&,
                          Complex&) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -104,85 +104,85 @@ octave_complex_matrix::try_narrowing_con
 
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+                              "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
-                             "complex matrix", "real scalar");
+                            "complex matrix", "real scalar");
 
   retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+                              "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
-                             "complex matrix", "real scalar");
+                            "complex matrix", "real scalar");
 
   retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 NDArray
 octave_complex_matrix::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+                              "complex matrix", "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+                              "complex matrix", "real matrix");
 
   retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 FloatMatrix
 octave_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+                              "complex matrix", "real matrix");
 
   retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 Complex
 octave_complex_matrix::complex_value (bool) const
@@ -190,17 +190,17 @@ octave_complex_matrix::complex_value (bo
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "complex scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
-                             "complex matrix", "complex scalar");
+                            "complex matrix", "complex scalar");
 
   retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_complex_matrix::float_complex_value (bool) const
@@ -208,17 +208,17 @@ octave_complex_matrix::float_complex_val
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "complex scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
-                             "complex matrix", "complex scalar");
+                            "complex matrix", "complex scalar");
 
   retval = matrix(0, 0);
 
   return retval;
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
@@ -246,17 +246,17 @@ octave_complex_matrix::bool_array_value 
 
 charNDArray
 octave_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     warn_implicit_conversion ("Octave:num-to-str",
-                               "complex matrix", "string");
+                              "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval.elem (i) = static_cast<char>(octave::math::real (matrix.elem (i)));
     }
@@ -272,17 +272,17 @@ octave_complex_matrix::float_complex_arr
 
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+                              "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (ComplexMatrix (matrix)));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
@@ -609,18 +609,19 @@ octave_complex_matrix::save_hdf5 (octave
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (complex_type_hid < 0) retval = false;
 
   if (retval)
     {
       Complex *mtmp = m.fortran_vec ();
-      if (H5Dwrite (data_hid, complex_type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                    mtmp) < 0)
+      if (H5Dwrite (data_hid, complex_type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                    octave_H5P_DEFAULT, mtmp)
+          < 0)
         {
           H5Tclose (complex_type_hid);
           retval = false;
         }
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
@@ -698,18 +699,19 @@ octave_complex_matrix::load_hdf5 (octave
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   ComplexNDArray m (dv);
   Complex *reim = m.fortran_vec ();
-  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-               reim) >= 0)
+  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, reim)
+      >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
@@ -761,59 +763,60 @@ octave_complex_matrix::map (unary_mapper
     // Mappers handled specially.
     case umap_real:
       return ::real (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_conj:
       return ::conj (matrix);
 
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
-      ARRAY_METHOD_MAPPER (isnan, isnan);
-      ARRAY_METHOD_MAPPER (isinf, isinf);
-      ARRAY_METHOD_MAPPER (isfinite, isfinite);
+    ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (isnan, isnan);
+    ARRAY_METHOD_MAPPER (isinf, isinf);
+    ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, octave::math::acos);
-      ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
-      ARRAY_MAPPER (angle, double, std::arg);
-      ARRAY_MAPPER (arg, double, std::arg);
-      ARRAY_MAPPER (asin, Complex, octave::math::asin);
-      ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
-      ARRAY_MAPPER (atan, Complex, octave::math::atan);
-      ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
-      ARRAY_MAPPER (erf, Complex, octave::math::erf);
-      ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
-      ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
-      ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
-      ARRAY_MAPPER (cos, Complex, std::cos);
-      ARRAY_MAPPER (cosh, Complex, std::cosh);
-      ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
-      ARRAY_MAPPER (fix, Complex, octave::math::fix);
-      ARRAY_MAPPER (floor, Complex, octave::math::floor);
-      ARRAY_MAPPER (log, Complex, std::log);
-      ARRAY_MAPPER (log2, Complex, octave::math::log2);
-      ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
-      ARRAY_MAPPER (round, Complex, octave::math::round);
-      ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
-      ARRAY_MAPPER (signum, Complex, octave::math::signum);
-      ARRAY_MAPPER (sin, Complex, std::sin);
-      ARRAY_MAPPER (sinh, Complex, std::sinh);
-      ARRAY_MAPPER (sqrt, Complex, std::sqrt);
-      ARRAY_MAPPER (tan, Complex, std::tan);
-      ARRAY_MAPPER (tanh, Complex, std::tanh);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (acos, Complex, octave::math::acos);
+    ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
+    ARRAY_MAPPER (angle, double, std::arg);
+    ARRAY_MAPPER (arg, double, std::arg);
+    ARRAY_MAPPER (asin, Complex, octave::math::asin);
+    ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
+    ARRAY_MAPPER (atan, Complex, octave::math::atan);
+    ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
+    ARRAY_MAPPER (erf, Complex, octave::math::erf);
+    ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
+    ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
+    ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
+    ARRAY_MAPPER (cos, Complex, std::cos);
+    ARRAY_MAPPER (cosh, Complex, std::cosh);
+    ARRAY_MAPPER (exp, Complex, std::exp);
+    ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
+    ARRAY_MAPPER (fix, Complex, octave::math::fix);
+    ARRAY_MAPPER (floor, Complex, octave::math::floor);
+    ARRAY_MAPPER (log, Complex, std::log);
+    ARRAY_MAPPER (log2, Complex, octave::math::log2);
+    ARRAY_MAPPER (log10, Complex, std::log10);
+    ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
+    ARRAY_MAPPER (round, Complex, octave::math::round);
+    ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
+    ARRAY_MAPPER (signum, Complex, octave::math::signum);
+    ARRAY_MAPPER (sin, Complex, std::sin);
+    ARRAY_MAPPER (sinh, Complex, std::sinh);
+    ARRAY_MAPPER (sqrt, Complex, std::sqrt);
+    ARRAY_MAPPER (tan, Complex, std::tan);
+    ARRAY_MAPPER (tanh, Complex, std::tanh);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -180,8 +180,9 @@ public:
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -379,18 +379,18 @@ octave_sparse_complex_matrix::save_hdf5 
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
 #if defined (HAVE_HDF5_18)
-  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
-                               octave_H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT,
+                               octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
@@ -541,18 +541,18 @@ octave_sparse_complex_matrix::save_hdf5 
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     itmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -586,17 +586,18 @@ octave_sparse_complex_matrix::save_hdf5 
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, octave_H5P_DEFAULT);
+  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid,
+                        octave_H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
@@ -623,17 +624,18 @@ octave_sparse_complex_matrix::save_hdf5 
 
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
-octave_sparse_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
+octave_sparse_complex_matrix::load_hdf5 (octave_hdf5_id loc_id,
+                                         const char *name)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
@@ -909,60 +911,61 @@ octave_sparse_complex_matrix::map (unary
   switch (umap)
     {
     // Mappers handled specially.
     case umap_real:
       return ::real (matrix);
     case umap_imag:
       return ::imag (matrix);
 
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (abs, abs);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, octave::math::acos);
-      ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
-      ARRAY_MAPPER (angle, double, std::arg);
-      ARRAY_MAPPER (arg, double, std::arg);
-      ARRAY_MAPPER (asin, Complex, octave::math::asin);
-      ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
-      ARRAY_MAPPER (atan, Complex, octave::math::atan);
-      ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
-      ARRAY_MAPPER (erf, Complex, octave::math::erf);
-      ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
-      ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
-      ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
-      ARRAY_MAPPER (conj, Complex, std::conj<double>);
-      ARRAY_MAPPER (cos, Complex, std::cos);
-      ARRAY_MAPPER (cosh, Complex, std::cosh);
-      ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
-      ARRAY_MAPPER (fix, Complex, octave::math::fix);
-      ARRAY_MAPPER (floor, Complex, octave::math::floor);
-      ARRAY_MAPPER (log, Complex, std::log);
-      ARRAY_MAPPER (log2, Complex, octave::math::log2);
-      ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
-      ARRAY_MAPPER (round, Complex, octave::math::round);
-      ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
-      ARRAY_MAPPER (signum, Complex, octave::math::signum);
-      ARRAY_MAPPER (sin, Complex, std::sin);
-      ARRAY_MAPPER (sinh, Complex, std::sinh);
-      ARRAY_MAPPER (sqrt, Complex, std::sqrt);
-      ARRAY_MAPPER (tan, Complex, std::tan);
-      ARRAY_MAPPER (tanh, Complex, std::tanh);
-      ARRAY_MAPPER (isnan, bool, octave::math::isnan);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
-      ARRAY_MAPPER (isinf, bool, octave::math::isinf);
-      ARRAY_MAPPER (isfinite, bool, octave::math::finite);
+    ARRAY_MAPPER (acos, Complex, octave::math::acos);
+    ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
+    ARRAY_MAPPER (angle, double, std::arg);
+    ARRAY_MAPPER (arg, double, std::arg);
+    ARRAY_MAPPER (asin, Complex, octave::math::asin);
+    ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
+    ARRAY_MAPPER (atan, Complex, octave::math::atan);
+    ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
+    ARRAY_MAPPER (erf, Complex, octave::math::erf);
+    ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
+    ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
+    ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
+    ARRAY_MAPPER (conj, Complex, std::conj<double>);
+    ARRAY_MAPPER (cos, Complex, std::cos);
+    ARRAY_MAPPER (cosh, Complex, std::cosh);
+    ARRAY_MAPPER (exp, Complex, std::exp);
+    ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
+    ARRAY_MAPPER (fix, Complex, octave::math::fix);
+    ARRAY_MAPPER (floor, Complex, octave::math::floor);
+    ARRAY_MAPPER (log, Complex, std::log);
+    ARRAY_MAPPER (log2, Complex, octave::math::log2);
+    ARRAY_MAPPER (log10, Complex, std::log10);
+    ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
+    ARRAY_MAPPER (round, Complex, octave::math::round);
+    ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
+    ARRAY_MAPPER (signum, Complex, octave::math::signum);
+    ARRAY_MAPPER (sin, Complex, std::sin);
+    ARRAY_MAPPER (sinh, Complex, std::sinh);
+    ARRAY_MAPPER (sqrt, Complex, std::sqrt);
+    ARRAY_MAPPER (tan, Complex, std::tan);
+    ARRAY_MAPPER (tanh, Complex, std::tanh);
+    ARRAY_MAPPER (isnan, bool, octave::math::isnan);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (isinf, bool, octave::math::isinf);
+    ARRAY_MAPPER (isfinite, bool, octave::math::finite);
 
     default: // Attempt to go via dense matrix.
       return octave_base_sparse<SparseComplexMatrix>::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -154,8 +154,9 @@ public:
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-dld-fcn.cc b/libinterp/octave-value/ov-dld-fcn.cc
--- a/libinterp/octave-value/ov-dld-fcn.cc
+++ b/libinterp/octave-value/ov-dld-fcn.cc
@@ -76,13 +76,15 @@ octave_dld_function::time_parsed (void) 
 //       been fully deleted; indeed, MSVC attaches auto-generated code
 //       (scalar deleting destructor) to objects created in a dynamic
 //       module, and this code will be executed in the dynamic module
 //       context at object deletion; unloading the dynamic module
 //       before objects have been deleted will make the "delete" code
 //       of objects to point to an invalid code segment.
 
 octave_dld_function*
-octave_dld_function::create (octave_builtin::fcn ff, const octave::dynamic_library& shl,
+octave_dld_function::create (octave_builtin::fcn ff,
+                             const octave::dynamic_library& shl,
                              const std::string& nm, const std::string& ds)
 {
   return new octave_dld_function (ff, shl, nm, ds);
 }
+
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -94,8 +94,9 @@ private:
   octave_dld_function (const octave_dld_function& fn);
 
   octave_dld_function& operator = (const octave_dld_function& fn);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -694,17 +694,18 @@ octave_fcn_handle::save_hdf5 (octave_hdf
                               bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   bool retval = true;
 
   hid_t group_hid = -1;
 #if defined (HAVE_HDF5_18)
-  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                         octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
@@ -725,22 +726,25 @@ octave_fcn_handle::save_hdf5 (octave_hdf
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
-                        octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                        octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, octave_H5P_DEFAULT);
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
+                        octave_H5P_DEFAULT);
 #endif
-  if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
-                                octave_H5P_DEFAULT, nm.c_str ()) < 0)
+  if (data_hid < 0
+      || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -756,23 +760,25 @@ octave_fcn_handle::save_hdf5 (octave_hdf
         {
           H5Sclose (space_hid);
           H5Gclose (group_hid);
           return false;
         }
 
 #if defined (HAVE_HDF5_18)
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
-                            octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+                            octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                            octave_H5P_DEFAULT);
 #else
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
                             octave_H5P_DEFAULT);
 #endif
-      if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
-                                    octave_H5P_DEFAULT, stmp.c_str ()) < 0)
+      if (data_hid < 0
+          || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                       octave_H5P_DEFAULT, stmp.c_str ()) < 0)
         {
           H5Sclose (space_hid);
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Dclose (data_hid);
@@ -994,17 +1000,19 @@ octave_fcn_handle::load_hdf5 (octave_hdf
     }
 
   OCTAVE_LOCAL_BUFFER (char, nm_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, nm_tmp) < 0)
+  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, nm_tmp)
+      < 0)
     {
       H5Tclose (st_id);
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
@@ -1065,17 +1073,19 @@ octave_fcn_handle::load_hdf5 (octave_hdf
         }
 
       OCTAVE_LOCAL_BUFFER (char, fcn_tmp, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
-      if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, fcn_tmp) < 0)
+      if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, fcn_tmp)
+          < 0)
         {
           H5Tclose (st_id);
           H5Sclose (space_hid);
           H5Tclose (type_hid);
           H5Dclose (data_hid);
           H5Gclose (group_hid);
           return false;
         }
@@ -1752,17 +1762,17 @@ particular output.
         = symbol_table::all_variables (fu->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (std::list<symbol_table::symbol_record>::const_iterator
-                 p = vars.begin (); p != vars.end (); p++)
+               p = vars.begin (); p != vars.end (); p++)
             {
               ws.assign (p->name (), p->varval (0));
             }
 
           m.setfield ("workspace", ws);
         }
     }
   else if (fcn->is_user_function () || fcn->is_user_script ())
@@ -2121,8 +2131,9 @@ octave_fcn_binder::do_multi_index_op (in
 /*
 %!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
 %!test
 %! x = [1,2;3,4];
 %! assert (__f (@(i) x(:,i), 1), [1;3]);
 */
+
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -212,8 +212,9 @@ public:
 protected:
 
   octave_value root_handle;
   octave_value_list arg_template;
   std::vector<int> arg_mask;
   int expected_nargin;
 };
 #endif
+
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -280,17 +280,18 @@ octave_fcn_inline::save_hdf5 (octave_hdf
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t group_hid = -1;
 
 #if defined (HAVE_HDF5_18)
-  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                         octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.numel (); i++)
     if (len < ifargs(i).length ())
@@ -367,20 +368,22 @@ octave_fcn_inline::save_hdf5 (octave_hdf
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, octave_H5P_DEFAULT);
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
+                        octave_H5P_DEFAULT);
 #endif
-  if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
-                                octave_H5P_DEFAULT, nm.c_str ()) < 0)
+  if (data_hid < 0
+      || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -394,18 +397,19 @@ octave_fcn_inline::save_hdf5 (octave_hdf
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
                         octave_H5P_DEFAULT);
 #endif
-  if (data_hid < 0 || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
-                                octave_H5P_DEFAULT, iftext.c_str ()) < 0)
+  if (data_hid < 0
+      || H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                   octave_H5P_DEFAULT, iftext.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -525,17 +529,18 @@ octave_fcn_inline::load_hdf5 (octave_hdf
     }
 
   OCTAVE_LOCAL_BUFFER (char, nm_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, nm_tmp) < 0)
+  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, nm_tmp) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
@@ -587,17 +592,18 @@ octave_fcn_inline::load_hdf5 (octave_hdf
     }
 
   OCTAVE_LOCAL_BUFFER (char, iftext_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT, iftext_tmp) < 0)
+  if (H5Dread (data_hid, st_id, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, iftext_tmp) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
@@ -980,8 +986,9 @@ quadv (fcn, 0, 3)
 %!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
 %!assert (vectorize ("2**x^5"), "2.**x.^5")
 
 ## Test input validation
 %!error vectorize ()
 %!error vectorize (1, 2)
 %!error <FUN must be a string or inline function> vectorize (1)
 */
+
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -95,8 +95,9 @@ private:
   // The expression of an inline function.
   std::string iftext;
 
   // The args of an inline function.
   string_vector ifargs;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-fcn.cc b/libinterp/octave-value/ov-fcn.cc
--- a/libinterp/octave-value/ov-fcn.cc
+++ b/libinterp/octave-value/ov-fcn.cc
@@ -37,8 +37,9 @@ octave_function::clone (void) const
 }
 
 octave_base_value *
 octave_function::empty_clone (void) const
 {
   panic_impossible ();
   return 0;
 }
+
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -222,8 +222,9 @@ private:
 
   octave_function (const octave_function& f);
 
   octave_function& operator = (const octave_function& f);
 
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -349,63 +349,63 @@ octave_float_scalar::map (unary_mapper_t
     {
     case umap_imag:
       return 0.0f;
 
     case umap_real:
     case umap_conj:
       return scalar;
 
-#define SCALAR_MAPPER(UMAP, FCN)                \
-      case umap_ ## UMAP:                       \
-        return octave_value (FCN (scalar))
+#define SCALAR_MAPPER(UMAP, FCN)              \
+    case umap_ ## UMAP:                       \
+      return octave_value (FCN (scalar))
 
-      SCALAR_MAPPER (abs, ::fabsf);
-      SCALAR_MAPPER (acos, octave::math::rc_acos);
-      SCALAR_MAPPER (acosh, octave::math::rc_acosh);
-      SCALAR_MAPPER (angle, octave::math::arg);
-      SCALAR_MAPPER (arg, octave::math::arg);
-      SCALAR_MAPPER (asin, octave::math::rc_asin);
-      SCALAR_MAPPER (asinh, octave::math::asinh);
-      SCALAR_MAPPER (atan, ::atanf);
-      SCALAR_MAPPER (atanh, octave::math::rc_atanh);
-      SCALAR_MAPPER (erf, octave::math::erf);
-      SCALAR_MAPPER (erfinv, octave::math::erfinv);
-      SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
-      SCALAR_MAPPER (erfc, octave::math::erfc);
-      SCALAR_MAPPER (erfcx, octave::math::erfcx);
-      SCALAR_MAPPER (erfi, octave::math::erfi);
-      SCALAR_MAPPER (dawson, octave::math::dawson);
-      SCALAR_MAPPER (gamma, octave::math::gamma);
-      SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
-      SCALAR_MAPPER (cbrt, octave::math::cbrt);
-      SCALAR_MAPPER (ceil, ::ceilf);
-      SCALAR_MAPPER (cos, ::cosf);
-      SCALAR_MAPPER (cosh, ::coshf);
-      SCALAR_MAPPER (exp, ::expf);
-      SCALAR_MAPPER (expm1, octave::math::expm1);
-      SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, std::floor);
-      SCALAR_MAPPER (log, octave::math::rc_log);
-      SCALAR_MAPPER (log2, octave::math::rc_log2);
-      SCALAR_MAPPER (log10, octave::math::rc_log10);
-      SCALAR_MAPPER (log1p, octave::math::rc_log1p);
-      SCALAR_MAPPER (round, octave::math::round);
-      SCALAR_MAPPER (roundb, octave::math::roundb);
-      SCALAR_MAPPER (signum, octave::math::signum);
-      SCALAR_MAPPER (sin, ::sinf);
-      SCALAR_MAPPER (sinh, ::sinhf);
-      SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
-      SCALAR_MAPPER (tan, ::tanf);
-      SCALAR_MAPPER (tanh, ::tanhf);
-      SCALAR_MAPPER (isfinite, octave::math::finite);
-      SCALAR_MAPPER (isinf, octave::math::isinf);
-      SCALAR_MAPPER (isna, octave::math::is_NA);
-      SCALAR_MAPPER (isnan, octave::math::isnan);
-      SCALAR_MAPPER (xsignbit, octave::math::signbit);
+    SCALAR_MAPPER (abs, ::fabsf);
+    SCALAR_MAPPER (acos, octave::math::rc_acos);
+    SCALAR_MAPPER (acosh, octave::math::rc_acosh);
+    SCALAR_MAPPER (angle, octave::math::arg);
+    SCALAR_MAPPER (arg, octave::math::arg);
+    SCALAR_MAPPER (asin, octave::math::rc_asin);
+    SCALAR_MAPPER (asinh, octave::math::asinh);
+    SCALAR_MAPPER (atan, ::atanf);
+    SCALAR_MAPPER (atanh, octave::math::rc_atanh);
+    SCALAR_MAPPER (erf, octave::math::erf);
+    SCALAR_MAPPER (erfinv, octave::math::erfinv);
+    SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
+    SCALAR_MAPPER (erfc, octave::math::erfc);
+    SCALAR_MAPPER (erfcx, octave::math::erfcx);
+    SCALAR_MAPPER (erfi, octave::math::erfi);
+    SCALAR_MAPPER (dawson, octave::math::dawson);
+    SCALAR_MAPPER (gamma, octave::math::gamma);
+    SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
+    SCALAR_MAPPER (cbrt, octave::math::cbrt);
+    SCALAR_MAPPER (ceil, ::ceilf);
+    SCALAR_MAPPER (cos, ::cosf);
+    SCALAR_MAPPER (cosh, ::coshf);
+    SCALAR_MAPPER (exp, ::expf);
+    SCALAR_MAPPER (expm1, octave::math::expm1);
+    SCALAR_MAPPER (fix, octave::math::fix);
+    SCALAR_MAPPER (floor, std::floor);
+    SCALAR_MAPPER (log, octave::math::rc_log);
+    SCALAR_MAPPER (log2, octave::math::rc_log2);
+    SCALAR_MAPPER (log10, octave::math::rc_log10);
+    SCALAR_MAPPER (log1p, octave::math::rc_log1p);
+    SCALAR_MAPPER (round, octave::math::round);
+    SCALAR_MAPPER (roundb, octave::math::roundb);
+    SCALAR_MAPPER (signum, octave::math::signum);
+    SCALAR_MAPPER (sin, ::sinf);
+    SCALAR_MAPPER (sinh, ::sinhf);
+    SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
+    SCALAR_MAPPER (tan, ::tanf);
+    SCALAR_MAPPER (tanh, ::tanhf);
+    SCALAR_MAPPER (isfinite, octave::math::finite);
+    SCALAR_MAPPER (isinf, octave::math::isinf);
+    SCALAR_MAPPER (isna, octave::math::is_NA);
+    SCALAR_MAPPER (isnan, octave::math::isnan);
+    SCALAR_MAPPER (xsignbit, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return scalar;
 
     case umap_xisalnum:
     case umap_xisalpha:
@@ -444,8 +444,9 @@ octave_float_scalar::fast_elem_insert_se
   else if (btyp == btyp_float_complex)
     {
       *(reinterpret_cast<FloatComplex *>(where)) = scalar;
       return true;
     }
   else
     return false;
 }
+
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -267,8 +267,9 @@ public:
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -338,18 +338,18 @@ octave_float_complex::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   FloatComplex tmp = float_complex_value ();
-  retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     &tmp) >= 0;
+  retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
   octave_unused_parameter (loc_id);
   octave_unused_parameter (name);
@@ -391,18 +391,19 @@ octave_float_complex::load_hdf5 (octave_
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
   FloatComplex ctmp;
-  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-               &ctmp) >= 0)
+  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, &ctmp)
+      >= 0)
     {
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
@@ -431,57 +432,58 @@ octave_float_complex::as_mxArray (void) 
   return retval;
 }
 
 octave_value
 octave_float_complex::map (unary_mapper_t umap) const
 {
   switch (umap)
     {
-#define SCALAR_MAPPER(UMAP, FCN)                \
-      case umap_ ## UMAP:                       \
-        return octave_value (FCN (scalar))
+#define SCALAR_MAPPER(UMAP, FCN)              \
+    case umap_ ## UMAP:                       \
+      return octave_value (FCN (scalar))
 
-      SCALAR_MAPPER (abs, std::abs);
-      SCALAR_MAPPER (acos, octave::math::acos);
-      SCALAR_MAPPER (acosh, octave::math::acosh);
-      SCALAR_MAPPER (angle, std::arg);
-      SCALAR_MAPPER (arg, std::arg);
-      SCALAR_MAPPER (asin, octave::math::asin);
-      SCALAR_MAPPER (asinh, octave::math::asinh);
-      SCALAR_MAPPER (atan, octave::math::atan);
-      SCALAR_MAPPER (atanh, octave::math::atanh);
-      SCALAR_MAPPER (erf, octave::math::erf);
-      SCALAR_MAPPER (erfc, octave::math::erfc);
-      SCALAR_MAPPER (erfcx, octave::math::erfcx);
-      SCALAR_MAPPER (erfi, octave::math::erfi);
-      SCALAR_MAPPER (dawson, octave::math::dawson);
-      SCALAR_MAPPER (ceil, octave::math::ceil);
-      SCALAR_MAPPER (conj, std::conj);
-      SCALAR_MAPPER (cos, std::cos);
-      SCALAR_MAPPER (cosh, std::cosh);
-      SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, octave::math::expm1);
-      SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, octave::math::floor);
-      SCALAR_MAPPER (imag, std::imag);
-      SCALAR_MAPPER (log, std::log);
-      SCALAR_MAPPER (log2, octave::math::log2);
-      SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, octave::math::log1p);
-      SCALAR_MAPPER (real, std::real);
-      SCALAR_MAPPER (round, octave::math::round);
-      SCALAR_MAPPER (roundb, octave::math::roundb);
-      SCALAR_MAPPER (signum, octave::math::signum);
-      SCALAR_MAPPER (sin, std::sin);
-      SCALAR_MAPPER (sinh, std::sinh);
-      SCALAR_MAPPER (sqrt, std::sqrt);
-      SCALAR_MAPPER (tan, std::tan);
-      SCALAR_MAPPER (tanh, std::tanh);
-      SCALAR_MAPPER (isfinite, octave::math::finite);
-      SCALAR_MAPPER (isinf, octave::math::isinf);
-      SCALAR_MAPPER (isna, octave::math::is_NA);
-      SCALAR_MAPPER (isnan, octave::math::isnan);
+    SCALAR_MAPPER (abs, std::abs);
+    SCALAR_MAPPER (acos, octave::math::acos);
+    SCALAR_MAPPER (acosh, octave::math::acosh);
+    SCALAR_MAPPER (angle, std::arg);
+    SCALAR_MAPPER (arg, std::arg);
+    SCALAR_MAPPER (asin, octave::math::asin);
+    SCALAR_MAPPER (asinh, octave::math::asinh);
+    SCALAR_MAPPER (atan, octave::math::atan);
+    SCALAR_MAPPER (atanh, octave::math::atanh);
+    SCALAR_MAPPER (erf, octave::math::erf);
+    SCALAR_MAPPER (erfc, octave::math::erfc);
+    SCALAR_MAPPER (erfcx, octave::math::erfcx);
+    SCALAR_MAPPER (erfi, octave::math::erfi);
+    SCALAR_MAPPER (dawson, octave::math::dawson);
+    SCALAR_MAPPER (ceil, octave::math::ceil);
+    SCALAR_MAPPER (conj, std::conj);
+    SCALAR_MAPPER (cos, std::cos);
+    SCALAR_MAPPER (cosh, std::cosh);
+    SCALAR_MAPPER (exp, std::exp);
+    SCALAR_MAPPER (expm1, octave::math::expm1);
+    SCALAR_MAPPER (fix, octave::math::fix);
+    SCALAR_MAPPER (floor, octave::math::floor);
+    SCALAR_MAPPER (imag, std::imag);
+    SCALAR_MAPPER (log, std::log);
+    SCALAR_MAPPER (log2, octave::math::log2);
+    SCALAR_MAPPER (log10, std::log10);
+    SCALAR_MAPPER (log1p, octave::math::log1p);
+    SCALAR_MAPPER (real, std::real);
+    SCALAR_MAPPER (round, octave::math::round);
+    SCALAR_MAPPER (roundb, octave::math::roundb);
+    SCALAR_MAPPER (signum, octave::math::signum);
+    SCALAR_MAPPER (sin, std::sin);
+    SCALAR_MAPPER (sinh, std::sinh);
+    SCALAR_MAPPER (sqrt, std::sqrt);
+    SCALAR_MAPPER (tan, std::tan);
+    SCALAR_MAPPER (tanh, std::tanh);
+    SCALAR_MAPPER (isfinite, octave::math::finite);
+    SCALAR_MAPPER (isinf, octave::math::isinf);
+    SCALAR_MAPPER (isna, octave::math::is_NA);
+    SCALAR_MAPPER (isnan, octave::math::isnan);
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -192,8 +192,9 @@ public:
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_float_complex octave_float_complex_scalar;
 
 #endif
+
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -37,17 +37,18 @@ along with Octave; see the file COPYING.
 template class octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_diag_matrix,
                                      "float complex diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
+  const octave_float_complex_diag_matrix& v =
+    dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_float_complex_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
@@ -214,8 +215,9 @@ bool
 octave_float_complex_diag_matrix::chk_valid_scalar (const octave_value& val,
                                                     FloatComplex& x) const
 {
   bool retval = val.is_complex_scalar () || val.is_real_scalar ();
   if (retval)
     x = val.float_complex_value ();
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -91,8 +91,9 @@ private:
 
   bool chk_valid_scalar (const octave_value&,
                          FloatComplex&) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -499,17 +499,18 @@ octave_float_complex_matrix::load_binary
         return false;
 
       matrix = m;
     }
   return true;
 }
 
 bool
-octave_float_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+octave_float_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                        bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
@@ -563,18 +564,19 @@ octave_float_complex_matrix::save_hdf5 (
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (complex_type_hid < 0) retval = false;
 
   if (retval)
     {
       FloatComplex *mtmp = m.fortran_vec ();
-      if (H5Dwrite (data_hid, complex_type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                    mtmp) < 0)
+      if (H5Dwrite (data_hid, complex_type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                    octave_H5P_DEFAULT, mtmp)
+          < 0)
         {
           H5Tclose (complex_type_hid);
           retval = false;
         }
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
@@ -649,18 +651,19 @@ octave_float_complex_matrix::load_hdf5 (
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   FloatComplexNDArray m (dv);
   FloatComplex *reim = m.fortran_vec ();
-  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-               reim) >= 0)
+  if (H5Dread (data_hid, complex_type, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, reim)
+      >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
@@ -712,59 +715,60 @@ octave_float_complex_matrix::map (unary_
     // Mappers handled specially.
     case umap_real:
       return ::real (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_conj:
       return ::conj (matrix);
 
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
-      ARRAY_METHOD_MAPPER (isnan, isnan);
-      ARRAY_METHOD_MAPPER (isinf, isinf);
-      ARRAY_METHOD_MAPPER (isfinite, isfinite);
+    ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (isnan, isnan);
+    ARRAY_METHOD_MAPPER (isinf, isinf);
+    ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, FloatComplex, octave::math::acos);
-      ARRAY_MAPPER (acosh, FloatComplex, octave::math::acosh);
-      ARRAY_MAPPER (angle, float, std::arg);
-      ARRAY_MAPPER (arg, float, std::arg);
-      ARRAY_MAPPER (asin, FloatComplex, octave::math::asin);
-      ARRAY_MAPPER (asinh, FloatComplex, octave::math::asinh);
-      ARRAY_MAPPER (atan, FloatComplex, octave::math::atan);
-      ARRAY_MAPPER (atanh, FloatComplex, octave::math::atanh);
-      ARRAY_MAPPER (erf, FloatComplex, octave::math::erf);
-      ARRAY_MAPPER (erfc, FloatComplex, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, FloatComplex, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, FloatComplex, octave::math::erfi);
-      ARRAY_MAPPER (dawson, FloatComplex, octave::math::dawson);
-      ARRAY_MAPPER (ceil, FloatComplex, octave::math::ceil);
-      ARRAY_MAPPER (cos, FloatComplex, std::cos);
-      ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
-      ARRAY_MAPPER (exp, FloatComplex, std::exp);
-      ARRAY_MAPPER (expm1, FloatComplex, octave::math::expm1);
-      ARRAY_MAPPER (fix, FloatComplex, octave::math::fix);
-      ARRAY_MAPPER (floor, FloatComplex, octave::math::floor);
-      ARRAY_MAPPER (log, FloatComplex, std::log);
-      ARRAY_MAPPER (log2, FloatComplex, octave::math::log2);
-      ARRAY_MAPPER (log10, FloatComplex, std::log10);
-      ARRAY_MAPPER (log1p, FloatComplex, octave::math::log1p);
-      ARRAY_MAPPER (round, FloatComplex, octave::math::round);
-      ARRAY_MAPPER (roundb, FloatComplex, octave::math::roundb);
-      ARRAY_MAPPER (signum, FloatComplex, octave::math::signum);
-      ARRAY_MAPPER (sin, FloatComplex, std::sin);
-      ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
-      ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
-      ARRAY_MAPPER (tan, FloatComplex, std::tan);
-      ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (acos, FloatComplex, octave::math::acos);
+    ARRAY_MAPPER (acosh, FloatComplex, octave::math::acosh);
+    ARRAY_MAPPER (angle, float, std::arg);
+    ARRAY_MAPPER (arg, float, std::arg);
+    ARRAY_MAPPER (asin, FloatComplex, octave::math::asin);
+    ARRAY_MAPPER (asinh, FloatComplex, octave::math::asinh);
+    ARRAY_MAPPER (atan, FloatComplex, octave::math::atan);
+    ARRAY_MAPPER (atanh, FloatComplex, octave::math::atanh);
+    ARRAY_MAPPER (erf, FloatComplex, octave::math::erf);
+    ARRAY_MAPPER (erfc, FloatComplex, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, FloatComplex, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, FloatComplex, octave::math::erfi);
+    ARRAY_MAPPER (dawson, FloatComplex, octave::math::dawson);
+    ARRAY_MAPPER (ceil, FloatComplex, octave::math::ceil);
+    ARRAY_MAPPER (cos, FloatComplex, std::cos);
+    ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
+    ARRAY_MAPPER (exp, FloatComplex, std::exp);
+    ARRAY_MAPPER (expm1, FloatComplex, octave::math::expm1);
+    ARRAY_MAPPER (fix, FloatComplex, octave::math::fix);
+    ARRAY_MAPPER (floor, FloatComplex, octave::math::floor);
+    ARRAY_MAPPER (log, FloatComplex, std::log);
+    ARRAY_MAPPER (log2, FloatComplex, octave::math::log2);
+    ARRAY_MAPPER (log10, FloatComplex, std::log10);
+    ARRAY_MAPPER (log1p, FloatComplex, octave::math::log1p);
+    ARRAY_MAPPER (round, FloatComplex, octave::math::round);
+    ARRAY_MAPPER (roundb, FloatComplex, octave::math::roundb);
+    ARRAY_MAPPER (signum, FloatComplex, octave::math::signum);
+    ARRAY_MAPPER (sin, FloatComplex, std::sin);
+    ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
+    ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
+    ARRAY_MAPPER (tan, FloatComplex, std::tan);
+    ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -176,8 +176,9 @@ public:
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -36,17 +36,18 @@ along with Octave; see the file COPYING.
 template class octave_base_diag<FloatDiagMatrix, FloatMatrix>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_diag_matrix,
                                      "float diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
+  const octave_float_diag_matrix& v =
+    dynamic_cast<const octave_float_diag_matrix&> (a);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_float_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
@@ -231,8 +232,9 @@ bool
 octave_float_diag_matrix::chk_valid_scalar (const octave_value& val,
                                             float& x) const
 {
   bool retval = val.is_real_scalar ();
   if (retval)
     x = val.float_value ();
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -101,8 +101,9 @@ private:
 
   bool chk_valid_scalar (const octave_value&,
                          float&) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -791,72 +791,72 @@ octave_float_matrix::map (unary_mapper_t
     case umap_imag:
       return FloatNDArray (matrix.dims (), 0.0);
 
     case umap_real:
     case umap_conj:
       return matrix;
 
     // Mappers handled specially.
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
-      ARRAY_METHOD_MAPPER (isnan, isnan);
-      ARRAY_METHOD_MAPPER (isinf, isinf);
-      ARRAY_METHOD_MAPPER (isfinite, isfinite);
+    ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (isnan, isnan);
+    ARRAY_METHOD_MAPPER (isinf, isinf);
+    ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-#define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)        \
-      case umap_ ## UMAP:                       \
-        return do_rc_map (matrix, FCN)
+#define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)      \
+    case umap_ ## UMAP:                       \
+      return do_rc_map (matrix, FCN)
 
-      RC_ARRAY_MAPPER (acos, FloatComplex, octave::math::rc_acos);
-      RC_ARRAY_MAPPER (acosh, FloatComplex, octave::math::rc_acosh);
-      ARRAY_MAPPER (angle, float, octave::math::arg);
-      ARRAY_MAPPER (arg, float,octave::math ::arg);
-      RC_ARRAY_MAPPER (asin, FloatComplex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, float, octave::math::asinh);
-      ARRAY_MAPPER (atan, float, ::atanf);
-      RC_ARRAY_MAPPER (atanh, FloatComplex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, float, octave::math::erf);
-      ARRAY_MAPPER (erfinv, float, octave::math::erfinv);
-      ARRAY_MAPPER (erfcinv, float, octave::math::erfcinv);
-      ARRAY_MAPPER (erfc, float, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, float, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, float, octave::math::erfi);
-      ARRAY_MAPPER (dawson, float, octave::math::dawson);
-      ARRAY_MAPPER (gamma, float, octave::math::gamma);
-      RC_ARRAY_MAPPER (lgamma, FloatComplex, octave::math::rc_lgamma);
-      ARRAY_MAPPER (cbrt, float, octave::math::cbrt);
-      ARRAY_MAPPER (ceil, float, ::ceilf);
-      ARRAY_MAPPER (cos, float, ::cosf);
-      ARRAY_MAPPER (cosh, float, ::coshf);
-      ARRAY_MAPPER (exp, float, ::expf);
-      ARRAY_MAPPER (expm1, float, octave::math::expm1);
-      ARRAY_MAPPER (fix, float, octave::math::fix);
-      ARRAY_MAPPER (floor, float, ::floorf);
-      RC_ARRAY_MAPPER (log, FloatComplex, octave::math::rc_log);
-      RC_ARRAY_MAPPER (log2, FloatComplex, octave::math::rc_log2);
-      RC_ARRAY_MAPPER (log10, FloatComplex, octave::math::rc_log10);
-      RC_ARRAY_MAPPER (log1p, FloatComplex, octave::math::rc_log1p);
-      ARRAY_MAPPER (round, float, octave::math::round);
-      ARRAY_MAPPER (roundb, float, octave::math::roundb);
-      ARRAY_MAPPER (signum, float, octave::math::signum);
-      ARRAY_MAPPER (sin, float, ::sinf);
-      ARRAY_MAPPER (sinh, float, ::sinhf);
-      RC_ARRAY_MAPPER (sqrt, FloatComplex, octave::math::rc_sqrt);
-      ARRAY_MAPPER (tan, float, ::tanf);
-      ARRAY_MAPPER (tanh, float, ::tanhf);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
-      ARRAY_MAPPER (xsignbit, float, octave::math::signbit);
+    RC_ARRAY_MAPPER (acos, FloatComplex, octave::math::rc_acos);
+    RC_ARRAY_MAPPER (acosh, FloatComplex, octave::math::rc_acosh);
+    ARRAY_MAPPER (angle, float, octave::math::arg);
+    ARRAY_MAPPER (arg, float,octave::math ::arg);
+    RC_ARRAY_MAPPER (asin, FloatComplex, octave::math::rc_asin);
+    ARRAY_MAPPER (asinh, float, octave::math::asinh);
+    ARRAY_MAPPER (atan, float, ::atanf);
+    RC_ARRAY_MAPPER (atanh, FloatComplex, octave::math::rc_atanh);
+    ARRAY_MAPPER (erf, float, octave::math::erf);
+    ARRAY_MAPPER (erfinv, float, octave::math::erfinv);
+    ARRAY_MAPPER (erfcinv, float, octave::math::erfcinv);
+    ARRAY_MAPPER (erfc, float, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, float, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, float, octave::math::erfi);
+    ARRAY_MAPPER (dawson, float, octave::math::dawson);
+    ARRAY_MAPPER (gamma, float, octave::math::gamma);
+    RC_ARRAY_MAPPER (lgamma, FloatComplex, octave::math::rc_lgamma);
+    ARRAY_MAPPER (cbrt, float, octave::math::cbrt);
+    ARRAY_MAPPER (ceil, float, ::ceilf);
+    ARRAY_MAPPER (cos, float, ::cosf);
+    ARRAY_MAPPER (cosh, float, ::coshf);
+    ARRAY_MAPPER (exp, float, ::expf);
+    ARRAY_MAPPER (expm1, float, octave::math::expm1);
+    ARRAY_MAPPER (fix, float, octave::math::fix);
+    ARRAY_MAPPER (floor, float, ::floorf);
+    RC_ARRAY_MAPPER (log, FloatComplex, octave::math::rc_log);
+    RC_ARRAY_MAPPER (log2, FloatComplex, octave::math::rc_log2);
+    RC_ARRAY_MAPPER (log10, FloatComplex, octave::math::rc_log10);
+    RC_ARRAY_MAPPER (log1p, FloatComplex, octave::math::rc_log1p);
+    ARRAY_MAPPER (round, float, octave::math::round);
+    ARRAY_MAPPER (roundb, float, octave::math::roundb);
+    ARRAY_MAPPER (signum, float, octave::math::signum);
+    ARRAY_MAPPER (sin, float, ::sinf);
+    ARRAY_MAPPER (sinh, float, ::sinhf);
+    RC_ARRAY_MAPPER (sqrt, FloatComplex, octave::math::rc_sqrt);
+    ARRAY_MAPPER (tan, float, ::tanf);
+    ARRAY_MAPPER (tanh, float, ::tanhf);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (xsignbit, float, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return matrix;
 
     case umap_xisalnum:
     case umap_xisalpha:
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -222,8 +222,9 @@ public:
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-int-traits.h b/libinterp/octave-value/ov-int-traits.h
--- a/libinterp/octave-value/ov-int-traits.h
+++ b/libinterp/octave-value/ov-int-traits.h
@@ -58,8 +58,9 @@ OCTAVE_VALUE_INT_TRAITS(int32NDArray, oc
 OCTAVE_VALUE_INT_TRAITS(int64NDArray, octave_int64_scalar);
 
 OCTAVE_VALUE_INT_TRAITS(uint8NDArray, octave_uint8_scalar);
 OCTAVE_VALUE_INT_TRAITS(uint16NDArray, octave_uint16_scalar);
 OCTAVE_VALUE_INT_TRAITS(uint32NDArray, octave_uint32_scalar);
 OCTAVE_VALUE_INT_TRAITS(uint64NDArray, octave_uint64_scalar);
 
 #endif
+
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "int16 matrix", "int16");
 
 template class octave_base_scalar<octave_int16>;
 
 template class octave_base_int_scalar<octave_int16>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
                                      "int16 scalar", "int16");
+
diff --git a/libinterp/octave-value/ov-int16.h b/libinterp/octave-value/ov-int16.h
--- a/libinterp/octave-value/ov-int16.h
+++ b/libinterp/octave-value/ov-int16.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "int32 matrix", "int32");
 
 template class octave_base_scalar<octave_int32>;
 
 template class octave_base_int_scalar<octave_int32>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
                                      "int32 scalar", "int32");
+
diff --git a/libinterp/octave-value/ov-int32.h b/libinterp/octave-value/ov-int32.h
--- a/libinterp/octave-value/ov-int32.h
+++ b/libinterp/octave-value/ov-int32.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "int64 matrix", "int64");
 
 template class octave_base_scalar<octave_int64>;
 
 template class octave_base_int_scalar<octave_int64>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
                                      "int64 scalar", "int64");
+
diff --git a/libinterp/octave-value/ov-int64.h b/libinterp/octave-value/ov-int64.h
--- a/libinterp/octave-value/ov-int64.h
+++ b/libinterp/octave-value/ov-int64.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "int8 matrix", "int8");
 
 template class octave_base_scalar<octave_int8>;
 
 template class octave_base_int_scalar<octave_int8>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
                                      "int8 scalar", "int8");
+
diff --git a/libinterp/octave-value/ov-int8.h b/libinterp/octave-value/ov-int8.h
--- a/libinterp/octave-value/ov-int8.h
+++ b/libinterp/octave-value/ov-int8.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -671,8 +671,9 @@ public:
         }
       }
   }
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
+
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -619,17 +619,18 @@ initialize_jvm (void)
     {
       // No JVM exists, create one
 
       octave::JVMArgs vm_args;
 
       vm_args.add ("-Djava.class.path=" + initial_class_path ());
       vm_args.add ("-Xrs");
       vm_args.add ("-Djava.system.class.loader=org.octave.OctClassLoader");
-      vm_args.read_java_opts (initial_java_dir () + octave::sys::file_ops::dir_sep_str () +
+      vm_args.read_java_opts (initial_java_dir () +
+                              octave::sys::file_ops::dir_sep_str () +
                               "java.opts");
 
 #if ! defined (__APPLE__) && ! defined (__MACH__)
 
       if (create_vm (&jvm, &current_env, vm_args.to_args ()) != JNI_OK)
         error ("unable to start Java VM in %s", jvm_lib_path.c_str ());
     }
 
@@ -1601,17 +1602,17 @@ unbox (JNIEnv *jni_env, const octave_val
       else if (val.is_uint32_type ())
         UNBOX_PRIMITIVE_SCALAR (uint32_t, uint32_scalar, "java/lang/Integer", "(I)V");
       else if (val.is_int64_type ())
         UNBOX_PRIMITIVE_SCALAR (int64_t, int64_scalar, "java/lang/Long", "(J)V");
       else if (val.is_uint64_type ())
         UNBOX_PRIMITIVE_SCALAR (uint64_t, uint64_scalar, "java/lang/Long", "(J)V");
 
 #undef UNBOX_PRIMITIVE_SCALAR
-      }
+    }
   else if (val.is_empty ())
     {
       jobj = 0;
       jcls = 0;
       //jcls = jni_env->FindClass ("java/lang/Object");
     }
   else if (! Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
@@ -2265,17 +2266,18 @@ octave_java::do_javaMethod (void *jni_en
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
 
 #endif
 }
 
 octave_value
-octave_java::do_javaMethod (const std::string& name, const octave_value_list& args)
+octave_java::do_javaMethod (const std::string& name,
+                            const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
 
   return do_javaMethod (thread_jni_env (), name, args);
 
 #else
 
   octave_unused_parameter (name);
@@ -2406,17 +2408,18 @@ octave_java::do_javaObject (void *jni_en
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
 
 #endif
 }
 
 octave_value
-octave_java::do_javaObject (const std::string& name, const octave_value_list& args)
+octave_java::do_javaObject (const std::string& name,
+                            const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
 
   return do_javaObject (thread_jni_env (), name, args);
 
 #else
 
   octave_unused_parameter (name);
@@ -2529,17 +2532,18 @@ octave_java::do_java_get (void *jni_env_
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
 
 #endif
 }
 
 octave_value
-octave_java::do_java_get (const std::string& class_name, const std::string& name)
+octave_java::do_java_get (const std::string& class_name,
+                          const std::string& name)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_get (thread_jni_env (), class_name, name);
 
 #else
 
   octave_unused_parameter (class_name);
@@ -2659,17 +2663,18 @@ octave_java::do_java_set (void *jni_env_
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
 
 #endif
 }
 
 octave_value
-octave_java::do_java_set (const std::string& class_name, const std::string& name,
+octave_java::do_java_set (const std::string& class_name,
+                          const std::string& name,
                           const octave_value& val)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_set (thread_jni_env (), class_name, name, val);
 
 #else
 
@@ -3240,8 +3245,9 @@ Return true if @var{x} is a Java object.
 %! assert (class (javaMethod ("valueOf", "java.math.BigInteger",  int64 (1))), "java.math.BigInteger")
 
 ## Automatic conversion from string cell array into String[] (bug #45290)
 %!testif HAVE_JAVA
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "aaa"), 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "zzz"), 3);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "hhh") < 0);
 */
+
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -183,8 +183,9 @@ private:
 
 extern OCTINTERP_API bool Vjava_matrix_autoconversion;
 
 extern OCTINTERP_API bool Vjava_unsigned_autoconversion;
 
 extern OCTINTERP_API bool Vdebug_java;
 
 #endif
+
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -192,8 +192,9 @@ bool octave_lazy_index::load_binary (std
   std::string nm = read_binary_data (is, swap, fmt, "", dummy, value, doc);
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
 
   index = value.index_vector ();
 
   return true;
 }
+
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -248,8 +248,9 @@ private:
 
   static octave_base_value *
   numeric_conversion_function (const octave_base_value&);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -139,14 +139,15 @@ octave_mex_function::do_multi_index_op (
   octave::unwind_protect frame;
 
   octave_call_stack::push (this);
 
   frame.add_fcn (octave_call_stack::pop);
 
   BEGIN_PROFILER_BLOCK (octave_mex_function)
 
-    retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 
   END_PROFILER_BLOCK
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -113,8 +113,9 @@ private:
   octave_mex_function (const octave_mex_function& fn);
 
   octave_mex_function& operator = (const octave_mex_function& fn);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -127,8 +127,9 @@ This should give an error if @code{I} is
 %!assert (isnull (""), true)
 %!assert (isnull ("A"), false)
 %!assert (isnull (''), true)
 %!assert (isnull ('A'), false)
 %!test
 %! x = [];
 %! assert (isnull (x), false);
 */
+
diff --git a/libinterp/octave-value/ov-null-mat.h b/libinterp/octave-value/ov-null-mat.h
--- a/libinterp/octave-value/ov-null-mat.h
+++ b/libinterp/octave-value/ov-null-mat.h
@@ -95,8 +95,9 @@ public:
   type_conv_info numeric_conversion_function (void) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -203,8 +203,9 @@ For similar functionality @xref{The unwi
 %!   warning ("off", "__MY_WARNING__");
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
 %!   clear trigger;
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
 %! unwind_protect_cleanup
 %!   warning (old_wstate);
 %! end_unwind_protect
 */
+
diff --git a/libinterp/octave-value/ov-oncleanup.h b/libinterp/octave-value/ov-oncleanup.h
--- a/libinterp/octave-value/ov-oncleanup.h
+++ b/libinterp/octave-value/ov-oncleanup.h
@@ -90,8 +90,9 @@ private:
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
 protected:
 
   octave_value fcn;
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -512,8 +512,9 @@ octave_perm_matrix::fast_elem_extract (o
       octave_idx_type r = n % nr;
       octave_idx_type c = n / nr;
 
       return octave_value (matrix.elem (r, c));
     }
   else
     return octave_value ();
 }
+
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -244,8 +244,9 @@ protected:
   mutable octave_value dense_cache;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -670,18 +670,19 @@ octave_range::save_hdf5 (octave_hdf5_id 
     }
 
   Range r = range_value ();
   double range_vals[3];
   range_vals[0] = r.base ();
   range_vals[1] = r.inc () != 0 ? r.limit () : r.numel ();
   range_vals[2] = r.inc ();
 
-  if (H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                range_vals) >= 0)
+  if (H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
+                octave_H5P_DEFAULT, range_vals)
+      >= 0)
     {
       octave_idx_type nel = r.numel ();
       retval = hdf5_add_scalar_attr (data_hid, H5T_NATIVE_IDX,
                                      "OCTAVE_RANGE_NELEM", &nel) >= 0;
     }
   else
     retval = false;
 
@@ -729,18 +730,19 @@ octave_range::load_hdf5 (octave_hdf5_id 
     {
       H5Tclose (range_type);
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       return false;
     }
 
   double rangevals[3];
-  if (H5Dread (data_hid, range_type, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-               rangevals) >= 0)
+  if (H5Dread (data_hid, range_type, octave_H5S_ALL, octave_H5S_ALL,
+               octave_H5P_DEFAULT, rangevals)
+      >= 0)
     {
       retval = true;
       octave_idx_type nel;
       if (hdf5_get_scalar_attr (data_hid, H5T_NATIVE_IDX,
                                 "OCTAVE_RANGE_NELEM", &nel))
         range = Range (rangevals[0], rangevals[2], nel);
       else
         {
@@ -835,8 +837,9 @@ The original variable value is restored 
 %!   assert (x(2.49:5), 1:3);
 %!   assert (x(2.5:5), 2:4);
 %!   assert (x(2.51:5), 2:4);
 %! unwind_protect_cleanup
 %!   allow_noninteger_range_as_index (save);
 %!   warning (warn_state.state, warn_state.identifier);
 %! end_unwind_protect
 */
+
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -324,8 +324,9 @@ private:
   // No assignment.
 
   octave_range& operator = (const octave_range&);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -308,8 +308,9 @@ bool
 octave_diag_matrix::chk_valid_scalar (const octave_value& val,
                                       double& x) const
 {
   bool retval = val.is_real_scalar ();
   if (retval)
     x = val.double_value ();
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -106,8 +106,9 @@ private:
 
   bool chk_valid_scalar (const octave_value&,
                          double&) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -687,17 +687,18 @@ octave_matrix::load_binary (std::istream
         return false;
 
       matrix = m;
     }
   return true;
 }
 
 bool
-octave_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+octave_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                          bool save_as_floats)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
@@ -916,72 +917,72 @@ octave_matrix::map (unary_mapper_t umap)
     case umap_imag:
       return NDArray (matrix.dims (), 0.0);
 
     case umap_real:
     case umap_conj:
       return matrix;
 
     // Mappers handled specially.
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
-      ARRAY_METHOD_MAPPER (isnan, isnan);
-      ARRAY_METHOD_MAPPER (isinf, isinf);
-      ARRAY_METHOD_MAPPER (isfinite, isfinite);
+    ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (isnan, isnan);
+    ARRAY_METHOD_MAPPER (isinf, isinf);
+    ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-#define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)        \
-      case umap_ ## UMAP:                       \
-        return do_rc_map (matrix, FCN)
+#define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)      \
+    case umap_ ## UMAP:                       \
+      return do_rc_map (matrix, FCN)
 
-      RC_ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
-      RC_ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
-      ARRAY_MAPPER (angle, double, octave::math::arg);
-      ARRAY_MAPPER (arg, double,octave::math ::arg);
-      RC_ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, double, octave::math::asinh);
-      ARRAY_MAPPER (atan, double, ::atan);
-      RC_ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, double, octave::math::erf);
-      ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
-      ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
-      ARRAY_MAPPER (erfc, double, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, double, octave::math::erfi);
-      ARRAY_MAPPER (dawson, double, octave::math::dawson);
-      ARRAY_MAPPER (gamma, double, octave::math::gamma);
-      RC_ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
-      ARRAY_MAPPER (ceil, double, ::ceil);
-      ARRAY_MAPPER (cos, double, ::cos);
-      ARRAY_MAPPER (cosh, double, ::cosh);
-      ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, octave::math::expm1);
-      ARRAY_MAPPER (fix, double, octave::math::fix);
-      ARRAY_MAPPER (floor, double, ::floor);
-      RC_ARRAY_MAPPER (log, Complex, octave::math::rc_log);
-      RC_ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
-      RC_ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
-      RC_ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
-      ARRAY_MAPPER (round, double, octave::math::round);
-      ARRAY_MAPPER (roundb, double, octave::math::roundb);
-      ARRAY_MAPPER (signum, double, octave::math::signum);
-      ARRAY_MAPPER (sin, double, ::sin);
-      ARRAY_MAPPER (sinh, double, ::sinh);
-      RC_ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
-      ARRAY_MAPPER (tan, double, ::tan);
-      ARRAY_MAPPER (tanh, double, ::tanh);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
-      ARRAY_MAPPER (xsignbit, double, octave::math::signbit);
+    RC_ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
+    RC_ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
+    ARRAY_MAPPER (angle, double, octave::math::arg);
+    ARRAY_MAPPER (arg, double,octave::math ::arg);
+    RC_ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
+    ARRAY_MAPPER (asinh, double, octave::math::asinh);
+    ARRAY_MAPPER (atan, double, ::atan);
+    RC_ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
+    ARRAY_MAPPER (erf, double, octave::math::erf);
+    ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
+    ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
+    ARRAY_MAPPER (erfc, double, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, double, octave::math::erfi);
+    ARRAY_MAPPER (dawson, double, octave::math::dawson);
+    ARRAY_MAPPER (gamma, double, octave::math::gamma);
+    RC_ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
+    ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
+    ARRAY_MAPPER (ceil, double, ::ceil);
+    ARRAY_MAPPER (cos, double, ::cos);
+    ARRAY_MAPPER (cosh, double, ::cosh);
+    ARRAY_MAPPER (exp, double, ::exp);
+    ARRAY_MAPPER (expm1, double, octave::math::expm1);
+    ARRAY_MAPPER (fix, double, octave::math::fix);
+    ARRAY_MAPPER (floor, double, ::floor);
+    RC_ARRAY_MAPPER (log, Complex, octave::math::rc_log);
+    RC_ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
+    RC_ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
+    RC_ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
+    ARRAY_MAPPER (round, double, octave::math::round);
+    ARRAY_MAPPER (roundb, double, octave::math::roundb);
+    ARRAY_MAPPER (signum, double, octave::math::signum);
+    ARRAY_MAPPER (sin, double, ::sin);
+    ARRAY_MAPPER (sinh, double, ::sinh);
+    RC_ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
+    ARRAY_MAPPER (tan, double, ::tan);
+    ARRAY_MAPPER (tanh, double, ::tanh);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (xsignbit, double, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return matrix;
 
     case umap_xisalnum:
     case umap_xisalpha:
@@ -1000,8 +1001,9 @@ octave_matrix::map (unary_mapper_t umap)
         octave_value str_conv = convert_to_str (true, true);
         return str_conv.map (umap);
       }
 
     default:
       return octave_base_value::map (umap);
     }
 }
+
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -246,8 +246,9 @@ public:
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -401,18 +401,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
 #if defined (HAVE_HDF5_18)
-  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
-                               octave_H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT,
+                               octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
@@ -436,18 +436,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.rows ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     &tmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
@@ -460,18 +460,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.cols ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     &tmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -485,18 +485,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.nnz ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     &tmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -523,18 +523,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type * itmp = m.xcidx ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     itmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -560,18 +560,18 @@ octave_sparse_matrix::save_hdf5 (octave_
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
-                     itmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, octave_H5S_ALL, octave_H5S_ALL,
+                     octave_H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (! retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -898,64 +898,64 @@ octave_sparse_matrix::map (unary_mapper_
     case umap_imag:
       return SparseMatrix (matrix.rows (), matrix.cols (), 0.0);
 
     case umap_real:
     case umap_conj:
       return matrix;
 
     // Mappers handled specially.
-#define ARRAY_METHOD_MAPPER(UMAP, FCN)          \
-      case umap_ ## UMAP:                       \
-        return octave_value (matrix.FCN ())
+#define ARRAY_METHOD_MAPPER(UMAP, FCN)        \
+    case umap_ ## UMAP:                       \
+      return octave_value (matrix.FCN ())
 
-      ARRAY_METHOD_MAPPER (abs, abs);
+    ARRAY_METHOD_MAPPER (abs, abs);
 
-#define ARRAY_MAPPER(UMAP, TYPE, FCN)                   \
-      case umap_ ## UMAP:                               \
-        return octave_value (matrix.map<TYPE> (FCN))
+#define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
+    case umap_ ## UMAP:                               \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
-      ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
-      ARRAY_MAPPER (angle, double, octave::math::arg);
-      ARRAY_MAPPER (arg, double,octave::math ::arg);
-      ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, double, octave::math::asinh);
-      ARRAY_MAPPER (atan, double, ::atan);
-      ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, double, octave::math::erf);
-      ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
-      ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
-      ARRAY_MAPPER (erfc, double, octave::math::erfc);
-      ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
-      ARRAY_MAPPER (erfi, double, octave::math::erfi);
-      ARRAY_MAPPER (dawson, double, octave::math::dawson);
-      ARRAY_MAPPER (gamma, double, octave::math::gamma);
-      ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
-      ARRAY_MAPPER (ceil, double, ::ceil);
-      ARRAY_MAPPER (cos, double, ::cos);
-      ARRAY_MAPPER (cosh, double, ::cosh);
-      ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, octave::math::expm1);
-      ARRAY_MAPPER (fix, double, octave::math::fix);
-      ARRAY_MAPPER (floor, double, ::floor);
-      ARRAY_MAPPER (log, Complex, octave::math::rc_log);
-      ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
-      ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
-      ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
-      ARRAY_MAPPER (round, double, octave::math::round);
-      ARRAY_MAPPER (roundb, double, octave::math::roundb);
-      ARRAY_MAPPER (signum, double, octave::math::signum);
-      ARRAY_MAPPER (sin, double, ::sin);
-      ARRAY_MAPPER (sinh, double, ::sinh);
-      ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
-      ARRAY_MAPPER (tan, double, ::tan);
-      ARRAY_MAPPER (tanh, double, ::tanh);
-      ARRAY_MAPPER (isnan, bool, octave::math::isnan);
-      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
-      ARRAY_MAPPER (isinf, bool, octave::math::isinf);
-      ARRAY_MAPPER (isfinite, bool, octave::math::finite);
+    ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
+    ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
+    ARRAY_MAPPER (angle, double, octave::math::arg);
+    ARRAY_MAPPER (arg, double,octave::math ::arg);
+    ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
+    ARRAY_MAPPER (asinh, double, octave::math::asinh);
+    ARRAY_MAPPER (atan, double, ::atan);
+    ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
+    ARRAY_MAPPER (erf, double, octave::math::erf);
+    ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
+    ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
+    ARRAY_MAPPER (erfc, double, octave::math::erfc);
+    ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
+    ARRAY_MAPPER (erfi, double, octave::math::erfi);
+    ARRAY_MAPPER (dawson, double, octave::math::dawson);
+    ARRAY_MAPPER (gamma, double, octave::math::gamma);
+    ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
+    ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
+    ARRAY_MAPPER (ceil, double, ::ceil);
+    ARRAY_MAPPER (cos, double, ::cos);
+    ARRAY_MAPPER (cosh, double, ::cosh);
+    ARRAY_MAPPER (exp, double, ::exp);
+    ARRAY_MAPPER (expm1, double, octave::math::expm1);
+    ARRAY_MAPPER (fix, double, octave::math::fix);
+    ARRAY_MAPPER (floor, double, ::floor);
+    ARRAY_MAPPER (log, Complex, octave::math::rc_log);
+    ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
+    ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
+    ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
+    ARRAY_MAPPER (round, double, octave::math::round);
+    ARRAY_MAPPER (roundb, double, octave::math::roundb);
+    ARRAY_MAPPER (signum, double, octave::math::signum);
+    ARRAY_MAPPER (sin, double, ::sin);
+    ARRAY_MAPPER (sinh, double, ::sinh);
+    ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
+    ARRAY_MAPPER (tan, double, ::tan);
+    ARRAY_MAPPER (tanh, double, ::tanh);
+    ARRAY_MAPPER (isnan, bool, octave::math::isnan);
+    ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+    ARRAY_MAPPER (isinf, bool, octave::math::isinf);
+    ARRAY_MAPPER (isfinite, bool, octave::math::finite);
 
     default: // Attempt to go via dense matrix.
       return octave_base_sparse<SparseMatrix>::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -158,8 +158,9 @@ public:
 
 private:
   octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -370,63 +370,63 @@ octave_scalar::map (unary_mapper_t umap)
     {
     case umap_imag:
       return 0.0;
 
     case umap_real:
     case umap_conj:
       return scalar;
 
-#define SCALAR_MAPPER(UMAP, FCN)                \
-      case umap_ ## UMAP:                       \
-        return octave_value (FCN (scalar))
+#define SCALAR_MAPPER(UMAP, FCN)              \
+    case umap_ ## UMAP:                       \
+      return octave_value (FCN (scalar))
 
-      SCALAR_MAPPER (abs, ::fabs);
-      SCALAR_MAPPER (acos, octave::math::rc_acos);
-      SCALAR_MAPPER (acosh, octave::math::rc_acosh);
-      SCALAR_MAPPER (angle, octave::math::arg);
-      SCALAR_MAPPER (arg,octave::math ::arg);
-      SCALAR_MAPPER (asin, octave::math::rc_asin);
-      SCALAR_MAPPER (asinh, octave::math::asinh);
-      SCALAR_MAPPER (atan, ::atan);
-      SCALAR_MAPPER (atanh, octave::math::rc_atanh);
-      SCALAR_MAPPER (erf, octave::math::erf);
-      SCALAR_MAPPER (erfinv, octave::math::erfinv);
-      SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
-      SCALAR_MAPPER (erfc, octave::math::erfc);
-      SCALAR_MAPPER (erfcx, octave::math::erfcx);
-      SCALAR_MAPPER (erfi, octave::math::erfi);
-      SCALAR_MAPPER (dawson, octave::math::dawson);
-      SCALAR_MAPPER (gamma, octave::math::gamma);
-      SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
-      SCALAR_MAPPER (cbrt, octave::math::cbrt);
-      SCALAR_MAPPER (ceil, ::ceil);
-      SCALAR_MAPPER (cos, ::cos);
-      SCALAR_MAPPER (cosh, ::cosh);
-      SCALAR_MAPPER (exp, ::exp);
-      SCALAR_MAPPER (expm1, octave::math::expm1);
-      SCALAR_MAPPER (fix, octave::math::fix);
-      SCALAR_MAPPER (floor, std::floor);
-      SCALAR_MAPPER (log, octave::math::rc_log);
-      SCALAR_MAPPER (log2, octave::math::rc_log2);
-      SCALAR_MAPPER (log10, octave::math::rc_log10);
-      SCALAR_MAPPER (log1p, octave::math::rc_log1p);
-      SCALAR_MAPPER (round, octave::math::round);
-      SCALAR_MAPPER (roundb, octave::math::roundb);
-      SCALAR_MAPPER (signum, octave::math::signum);
-      SCALAR_MAPPER (sin, ::sin);
-      SCALAR_MAPPER (sinh, ::sinh);
-      SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
-      SCALAR_MAPPER (tan, ::tan);
-      SCALAR_MAPPER (tanh, ::tanh);
-      SCALAR_MAPPER (isfinite, octave::math::finite);
-      SCALAR_MAPPER (isinf, octave::math::isinf);
-      SCALAR_MAPPER (isna, octave::math::is_NA);
-      SCALAR_MAPPER (isnan, octave::math::isnan);
-      SCALAR_MAPPER (xsignbit, octave::math::signbit);
+    SCALAR_MAPPER (abs, ::fabs);
+    SCALAR_MAPPER (acos, octave::math::rc_acos);
+    SCALAR_MAPPER (acosh, octave::math::rc_acosh);
+    SCALAR_MAPPER (angle, octave::math::arg);
+    SCALAR_MAPPER (arg,octave::math ::arg);
+    SCALAR_MAPPER (asin, octave::math::rc_asin);
+    SCALAR_MAPPER (asinh, octave::math::asinh);
+    SCALAR_MAPPER (atan, ::atan);
+    SCALAR_MAPPER (atanh, octave::math::rc_atanh);
+    SCALAR_MAPPER (erf, octave::math::erf);
+    SCALAR_MAPPER (erfinv, octave::math::erfinv);
+    SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
+    SCALAR_MAPPER (erfc, octave::math::erfc);
+    SCALAR_MAPPER (erfcx, octave::math::erfcx);
+    SCALAR_MAPPER (erfi, octave::math::erfi);
+    SCALAR_MAPPER (dawson, octave::math::dawson);
+    SCALAR_MAPPER (gamma, octave::math::gamma);
+    SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
+    SCALAR_MAPPER (cbrt, octave::math::cbrt);
+    SCALAR_MAPPER (ceil, ::ceil);
+    SCALAR_MAPPER (cos, ::cos);
+    SCALAR_MAPPER (cosh, ::cosh);
+    SCALAR_MAPPER (exp, ::exp);
+    SCALAR_MAPPER (expm1, octave::math::expm1);
+    SCALAR_MAPPER (fix, octave::math::fix);
+    SCALAR_MAPPER (floor, std::floor);
+    SCALAR_MAPPER (log, octave::math::rc_log);
+    SCALAR_MAPPER (log2, octave::math::rc_log2);
+    SCALAR_MAPPER (log10, octave::math::rc_log10);
+    SCALAR_MAPPER (log1p, octave::math::rc_log1p);
+    SCALAR_MAPPER (round, octave::math::round);
+    SCALAR_MAPPER (roundb, octave::math::roundb);
+    SCALAR_MAPPER (signum, octave::math::signum);
+    SCALAR_MAPPER (sin, ::sin);
+    SCALAR_MAPPER (sinh, ::sinh);
+    SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
+    SCALAR_MAPPER (tan, ::tan);
+    SCALAR_MAPPER (tanh, ::tanh);
+    SCALAR_MAPPER (isfinite, octave::math::finite);
+    SCALAR_MAPPER (isinf, octave::math::isinf);
+    SCALAR_MAPPER (isna, octave::math::is_NA);
+    SCALAR_MAPPER (isnan, octave::math::isnan);
+    SCALAR_MAPPER (xsignbit, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return scalar;
 
     case umap_xisalnum:
     case umap_xisalpha:
@@ -464,8 +464,9 @@ octave_scalar::fast_elem_insert_self (vo
   else if (btyp == btyp_complex)
     {
       *(reinterpret_cast<Complex *>(where)) = scalar;
       return true;
     }
   else
     return false;
 }
+
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -266,8 +266,9 @@ public:
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -59,17 +59,18 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string",
                                      "char");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   octave_base_value *retval = 0;
 
-  const octave_char_matrix_str& v = dynamic_cast<const octave_char_matrix_str&> (a);
+  const octave_char_matrix_str& v
+    = dynamic_cast<const octave_char_matrix_str&> (a);
 
   NDArray nda = v.array_value (true);
 
   if (nda.numel () == 1)
     retval = new octave_scalar (nda(0));
   else
     retval = new octave_matrix (nda);
 
@@ -760,8 +761,9 @@ octave_char_matrix_str::load_hdf5 (octav
   octave_unused_parameter (loc_id);
   octave_unused_parameter (name);
 
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
+
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -253,8 +253,9 @@ public:
   { return octave_value (matrix.sort (sidx, dim, mode), '\''); }
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -864,24 +864,26 @@ octave_struct::load_binary (std::istream
     map = octave_map (dv);
   else
     success = false;
 
   return success;
 }
 
 bool
-octave_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+octave_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                          bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   hid_t data_hid = -1;
 
 #if defined (HAVE_HDF5_18)
-  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the structure to this group
   octave_map m = map_value ();
 
@@ -1476,17 +1478,18 @@ bool
 octave_scalar_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                                  bool save_as_floats)
 {
 #if defined (HAVE_HDF5)
 
   hid_t data_hid = -1;
 
 #if defined (HAVE_HDF5_18)
-  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
+  data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
+                        octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
 
   // recursively add each element of the structure to this group
   octave_scalar_map m = scalar_map_value ();
 
@@ -2120,8 +2123,9 @@ by @var{struct_levels_to_print}.
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{struct_levels_to_print}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (print_struct_array_contents);
 }
+
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -276,8 +276,9 @@ protected:
 private:
 
   octave_value to_array (void);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -701,17 +701,17 @@ as_bool_nd_array (const Array<void *>& x
 }
 
 octave_scalar_map
 octave_value_typeinfo::unary_ops_map (void) const
 {
   octave_scalar_map retval;
 
   int len = std::min (static_cast<int> (non_const_unary_ops.columns ()),
-    num_types);
+                      num_types);
 
   dim_vector tab_dims (1, len);
 
   for (int j = 0; j < octave_value::num_unary_ops; j++)
     {
       boolNDArray tab (tab_dims);
 
       for (int i = 0; i < len; i++)
@@ -726,17 +726,17 @@ octave_value_typeinfo::unary_ops_map (vo
 }
 
 octave_scalar_map
 octave_value_typeinfo::non_const_unary_ops_map (void) const
 {
   octave_scalar_map retval;
 
   int len = std::min (static_cast<int> (non_const_unary_ops.columns ()),
-    num_types);
+                      num_types);
 
   dim_vector tab_dims (1, len);
 
   for (int j = 0; j < octave_value::num_unary_ops; j++)
     {
       boolNDArray tab (tab_dims);
 
       for (int i = 0; i < len; i++)
@@ -776,29 +776,30 @@ octave_value_typeinfo::binary_ops_map (v
 }
 
 octave_scalar_map
 octave_value_typeinfo::compound_binary_ops_map (void) const
 {
   octave_scalar_map retval;
 
   int len = std::min (static_cast<int> (compound_binary_ops.columns ()),
-    num_types);
+                      num_types);
 
   dim_vector tab_dims (len, len);
 
   for (int k = 0; k < octave_value::num_compound_binary_ops; k++)
     {
       boolNDArray tab (tab_dims);
 
       for (int j = 0; j < len; j++)
         for (int i = 0; i < len; i++)
           tab.xelem (j,i) = (compound_binary_ops(k,j,i) != 0);
 
-      octave_value::compound_binary_op op_id = static_cast<octave_value::compound_binary_op> (k);
+      octave_value::compound_binary_op op_id
+        = static_cast<octave_value::compound_binary_op> (k);
 
       retval.setfield (octave_value::binary_op_fcn_name (op_id), tab);
     }
 
   return retval;
 }
 
 octave_scalar_map
@@ -886,8 +887,9 @@ DEFUN (__dump_typeinfo__, args, ,
 Undocumented internal function.
 @end deftypefn */)
 {
   if (args.length () > 0)
     print_usage ();
 
   return ovl (octave_value_typeinfo::installed_type_info ());
 }
+
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -322,8 +322,9 @@ private:
   // No copying!
 
   octave_value_typeinfo (const octave_value_typeinfo&);
 
   octave_value_typeinfo& operator = (const octave_value_typeinfo&);
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -67,8 +67,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "uint16 matrix", "uint16");
 
 template class octave_base_scalar<octave_uint16>;
 
 template class octave_base_int_scalar<octave_uint16>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
                                      "uint16 scalar", "uint16");
+
diff --git a/libinterp/octave-value/ov-uint16.h b/libinterp/octave-value/ov-uint16.h
--- a/libinterp/octave-value/ov-uint16.h
+++ b/libinterp/octave-value/ov-uint16.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "uint32 matrix", "uint32");
 
 template class octave_base_scalar<octave_uint32>;
 
 template class octave_base_int_scalar<octave_uint32>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
                                      "uint32 scalar", "uint32");
+
diff --git a/libinterp/octave-value/ov-uint32.h b/libinterp/octave-value/ov-uint32.h
--- a/libinterp/octave-value/ov-uint32.h
+++ b/libinterp/octave-value/ov-uint32.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "uint64 matrix", "uint64");
 
 template class octave_base_scalar<octave_uint64>;
 
 template class octave_base_int_scalar<octave_uint64>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
                                      "uint64 scalar", "uint64");
+
diff --git a/libinterp/octave-value/ov-uint64.h b/libinterp/octave-value/ov-uint64.h
--- a/libinterp/octave-value/ov-uint64.h
+++ b/libinterp/octave-value/ov-uint64.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -66,8 +66,9 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "uint8 matrix", "uint8");
 
 template class octave_base_scalar<octave_uint8>;
 
 template class octave_base_int_scalar<octave_uint8>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
                                      "uint8 scalar", "uint8");
+
diff --git a/libinterp/octave-value/ov-uint8.h b/libinterp/octave-value/ov-uint8.h
--- a/libinterp/octave-value/ov-uint8.h
+++ b/libinterp/octave-value/ov-uint8.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 
 #undef OCTAVE_TYPE_PREDICATE_FUNCTION
 
 #undef OCTAVE_INT_MX_CLASS
 
 #undef OCTAVE_INT_BTYP
 
 #endif
+
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -1143,8 +1143,9 @@ element-by-element and a logical array i
 %! assert (y, -2);
 %! [~, y] = af ();
 %! assert (y, -2);
 %! [~, y] = c{1}();
 %! assert (y, -2);
 %! [~, y] = c{2}();
 %! assert (y, -2);
 */
+
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -520,8 +520,9 @@ private:
   octave_user_function (const octave_user_function& fn);
 
   octave_user_function& operator = (const octave_user_function& fn);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
+
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1627,8 +1627,9 @@ DEF_VALUE_EXTRACTOR (SparseBoolMatrix, s
     return DEFVAL;                                                      \
   }
 
 DEF_DUMMY_VALUE_EXTRACTOR (char, 0)
 DEF_DUMMY_VALUE_EXTRACTOR (octave_value, octave_value ())
 #undef DEF_DUMMY_VALUE_EXTRACTOR
 
 #endif
+
diff --git a/libinterp/octave-value/ovl.cc b/libinterp/octave-value/ovl.cc
--- a/libinterp/octave-value/ovl.cc
+++ b/libinterp/octave-value/ovl.cc
@@ -269,8 +269,9 @@ octave_value_list::make_storable_values 
   for (octave_idx_type i = 0; i < len; i++)
     {
       // This is optimized so that we don't force a copy unless necessary.
       octave_value tmp = cdata(i).storable_value ();
       if (! tmp.is_copy_of (cdata (i)))
         data(i) = tmp;
     }
 }
+
diff --git a/libinterp/octave-value/ovl.h b/libinterp/octave-value/ovl.h
--- a/libinterp/octave-value/ovl.h
+++ b/libinterp/octave-value/ovl.h
@@ -188,8 +188,9 @@ private:
 template<typename... OV_Args>
 inline octave_value_list
 ovl (const OV_Args&... args)
 {
   return octave_value_list (std::initializer_list<octave_value> ({args...}));
 }
 
 #endif
+
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -547,8 +547,9 @@ Return the last component of the value r
 
   return ovl (octave::application::program_name ());
 }
 
 /*
 %!assert (ischar (program_name ()))
 %!error program_name (1)
 */
+
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -340,8 +340,9 @@ extern "C" {
 
 extern OCTINTERP_API int octave_main (int argc, char **argv, int embedded);
 
 #if defined  (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/libinterp/operators/op-b-b.cc b/libinterp/operators/op-b-b.cc
--- a/libinterp/operators/op-b-b.cc
+++ b/libinterp/operators/op-b-b.cc
@@ -95,8 +95,9 @@ install_b_b_ops (void)
   INSTALL_CATOP (octave_float_scalar, octave_bool, f_b);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_bool, octave_bool_matrix);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_null_matrix, octave_bool_matrix);
   INSTALL_ASSIGNCONV (octave_bool, octave_null_str, octave_bool_matrix);
   INSTALL_ASSIGNCONV (octave_bool, octave_null_sq_str, octave_bool_matrix);
 }
+
diff --git a/libinterp/operators/op-b-bm.cc b/libinterp/operators/op-b-bm.cc
--- a/libinterp/operators/op-b-bm.cc
+++ b/libinterp/operators/op-b-bm.cc
@@ -74,8 +74,9 @@ install_b_bm_ops (void)
   INSTALL_CATOP (octave_scalar, octave_bool_matrix, s_bm);
   INSTALL_CATOP (octave_bool, octave_float_matrix, b_fm);
   INSTALL_CATOP (octave_float_scalar, octave_bool_matrix, f_bm);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_bool_matrix, octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool, octave_bool_matrix, bool_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-b-sbm.cc b/libinterp/operators/op-b-sbm.cc
--- a/libinterp/operators/op-b-sbm.cc
+++ b/libinterp/operators/op-b-sbm.cc
@@ -43,34 +43,36 @@ DEFBINOP_FN (ne, bool, sparse_bool_matri
 DEFBINOP_FN (eq, bool, sparse_bool_matrix, mx_el_eq)
 
 DEFBINOP_FN (el_and, bool, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or, bool, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (b_sbm, bool, sparse_bool_matrix)
 {
   octave_bool& v1 = dynamic_cast<octave_bool&> (a1);
-  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
+  const octave_sparse_bool_matrix& v2 =
+    dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseBoolMatrix tmp (1, 1, v1.bool_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (b_sm, bool, sparse_matrix)
 {
   octave_bool& v1 = dynamic_cast<octave_bool&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCATOP (s_sbm, scalar, sparse_bool_matrix)
 {
   octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
-  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
+  const octave_sparse_bool_matrix& v2 =
+    dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value(tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_bool_matrix_conv, bool, sparse_bool_matrix)
 {
   const octave_bool& v = dynamic_cast<const octave_bool&> (a);
 
@@ -92,8 +94,9 @@ install_b_sbm_ops (void)
   INSTALL_CATOP (octave_scalar, octave_sparse_bool_matrix, s_sbm);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_sparse_bool_matrix,
                       octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool, octave_sparse_bool_matrix,
                    sparse_bool_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-bm-b.cc b/libinterp/operators/op-bm-b.cc
--- a/libinterp/operators/op-bm-b.cc
+++ b/libinterp/operators/op-bm-b.cc
@@ -113,8 +113,9 @@ install_bm_b_ops (void)
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint16_scalar,
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint32_scalar,
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint64_scalar,
                     conv_and_assign);
 }
+
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -193,8 +193,9 @@ install_bm_bm_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_sq_str,
                     null_assign);
 
   INSTALL_ASSIGNOP (op_el_and_eq, octave_bool_matrix, octave_bool_matrix,
                     assign_and);
   INSTALL_ASSIGNOP (op_el_or_eq, octave_bool_matrix, octave_bool_matrix,
                     assign_or);
 }
+
diff --git a/libinterp/operators/op-bm-sbm.cc b/libinterp/operators/op-bm-sbm.cc
--- a/libinterp/operators/op-bm-sbm.cc
+++ b/libinterp/operators/op-bm-sbm.cc
@@ -45,26 +45,28 @@ DEFBINOP_FN (eq, bool_matrix, sparse_boo
 DEFBINOP_FN (ne, bool_matrix, sparse_bool_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_and, bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  bool_matrix, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (bm_sbm, bool_matrix, sparse_bool_matrix)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
-  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
+  const octave_sparse_bool_matrix& v2 =
+    dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseBoolMatrix tmp (v1.bool_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (m_sbm, matrix, sparse_bool_matrix)
 {
   octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
-  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
+  const octave_sparse_bool_matrix& v2 =
+    dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCATOP (bm_sm, bool_matrix, sparse_matrix)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
@@ -99,8 +101,9 @@ install_bm_sbm_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_bool_matrix,
                     assign)
   INSTALL_ASSIGNCONV (octave_bool_matrix, octave_sparse_bool_matrix,
                       octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool_matrix, octave_sparse_bool_matrix,
                    sparse_bool_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-cdm-cdm.cc b/libinterp/operators/op-cdm-cdm.cc
--- a/libinterp/operators/op-cdm-cdm.cc
+++ b/libinterp/operators/op-cdm-cdm.cc
@@ -37,53 +37,60 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, complex_diag_matrix, -)
 
 DEFUNOP (transpose, complex_diag_matrix)
 {
-  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
+  const octave_complex_diag_matrix& v =
+    dynamic_cast<const octave_complex_diag_matrix&> (a);
   return octave_value (v.complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_diag_matrix)
 {
-  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
+  const octave_complex_diag_matrix& v =
+    dynamic_cast<const octave_complex_diag_matrix&> (a);
   return octave_value (v.complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
 DEFBINOP (div, complex_diag_matrix, complex_diag_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_complex_diag_matrix& v1 =
+    dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 =
+    dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   return xdiv (v1.complex_diag_matrix_value (),
                v2.complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex_diag_matrix, complex_diag_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_complex_diag_matrix& v1 =
+    dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 =
+    dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.complex_diag_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_complex_matrix)
 {
-  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
+  const octave_complex_diag_matrix& v =
+    dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cdm_cdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_complex_diag_matrix, uplus);
@@ -102,8 +109,9 @@ install_cdm_cdm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix,
                  octave_complex_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV (octave_complex_diag_matrix, octave_complex_matrix,
                       octave_complex_matrix);
   INSTALL_WIDENOP (octave_complex_diag_matrix, octave_complex_matrix,
                    complex_diag_matrix_to_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-cell.cc b/libinterp/operators/op-cell.cc
--- a/libinterp/operators/op-cell.cc
+++ b/libinterp/operators/op-cell.cc
@@ -61,8 +61,9 @@ install_cell_ops (void)
   INSTALL_CATOP (octave_cell, octave_cell, c_c);
 
   INSTALL_ASSIGNANYOP (op_asn_eq, octave_cell, assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_cell, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_cell, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_cell, octave_null_sq_str, null_assign);
 }
+
diff --git a/libinterp/operators/op-chm.cc b/libinterp/operators/op-chm.cc
--- a/libinterp/operators/op-chm.cc
+++ b/libinterp/operators/op-chm.cc
@@ -102,8 +102,9 @@ install_chm_ops (void)
   INSTALL_UNOP (op_hermitian, octave_char_matrix, transpose);
 
   INSTALL_CATOP (octave_char_matrix, octave_char_matrix, chm_chm);
   INSTALL_CATOP (octave_char_matrix, octave_scalar, chm_s);
   INSTALL_CATOP (octave_char_matrix, octave_matrix, chm_m);
   INSTALL_CATOP (octave_scalar, octave_char_matrix, s_chm);
   INSTALL_CATOP (octave_matrix, octave_char_matrix, m_chm);
 }
+
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -150,8 +150,9 @@ install_class_ops (void)
   INSTALL_CLASS_BINOP (op_ne, ne);
   INSTALL_CLASS_BINOP (op_el_mul, times);
   INSTALL_CLASS_BINOP (op_el_div, rdivide);
   INSTALL_CLASS_BINOP (op_el_pow, power);
   INSTALL_CLASS_BINOP (op_el_ldiv, ldivide);
   INSTALL_CLASS_BINOP (op_el_and, and);
   INSTALL_CLASS_BINOP (op_el_or, or);
 }
+
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -38,27 +38,29 @@ along with Octave; see the file COPYING.
 // unary complex matrix ops.
 
 DEFNDUNOP_OP (not, complex_matrix, complex_array, !)
 DEFNDUNOP_OP (uplus, complex_matrix, complex_array, /* no-op */)
 DEFNDUNOP_OP (uminus, complex_matrix, complex_array, -)
 
 DEFUNOP (transpose, complex_matrix)
 {
-  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
+  const octave_complex_matrix& v
+    = dynamic_cast<const octave_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_matrix)
 {
-  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
+  const octave_complex_matrix& v
+    = dynamic_cast<const octave_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("complex-conjugate transpose not defined for N-D objects");
 
   return octave_value (v.complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, complex_matrix, increment)
@@ -71,98 +73,114 @@ DEFNDBINOP_OP (add, complex_matrix, comp
                complex_array, +)
 DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array,
                complex_array, -)
 
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ,
                                 blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -185,18 +203,20 @@ DEFNDBINOP_FN (el_mul, complex_matrix, c
                complex_array, product)
 DEFNDBINOP_FN (el_div, complex_matrix, complex_matrix, complex_array,
                complex_array, quotient)
 DEFNDBINOP_FN (el_pow, complex_matrix, complex_matrix, complex_array,
                complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.complex_array_value (),
                                  v1.complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, complex_matrix, complex_array,
                complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, complex_matrix, complex_array,
@@ -282,8 +302,9 @@ install_cm_cm_ops (void)
                     assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix,
                     assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_complex_matrix, octave_complex_matrix,
                     assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_complex_matrix, octave_complex_matrix,
                     assign_el_div);
 }
+
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -38,32 +38,34 @@ along with Octave; see the file COPYING.
 // complex matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, complex_matrix, complex, complex_array, complex, +)
 DEFNDBINOP_OP (sub, complex_matrix, complex, complex_array, complex, -)
 DEFNDBINOP_OP (mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (div, complex_matrix, complex)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
 DEFBINOP (ldiv, complex_matrix, complex)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
@@ -82,33 +84,35 @@ DEFNDCMPLXCMPOP_FN (gt, complex_matrix, 
                     mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex, complex_array, complex,
                     mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (el_div, complex_matrix, complex)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return x_el_div (v2.complex_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, complex, complex_array, complex,
                mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, complex, complex_array, complex,
@@ -158,8 +162,9 @@ install_cm_cs_ops (void)
                     assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_scalar,
                     assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_complex_scalar,
                     assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_complex_scalar,
                     assign_div);
 }
+
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -43,29 +43,31 @@ along with Octave; see the file COPYING.
 
 DEFNDBINOP_OP (add, complex_matrix, matrix, complex_array, array, +)
 DEFNDBINOP_OP (sub, complex_matrix, matrix, complex_array, array, -)
 
 DEFBINOP_OP (mul, complex_matrix, matrix, *)
 
 DEFBINOP (mul_trans, complex_matrix, matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
 
   return ComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                         xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, complex_matrix, matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
@@ -73,17 +75,18 @@ DEFBINOP (div, complex_matrix, matrix)
 
 DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
@@ -97,17 +100,18 @@ DEFNDCMPLXCMPOP_FN (gt, complex_matrix, 
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, matrix, complex_array, array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, complex_matrix, matrix, complex_array, array, product)
 DEFNDBINOP_FN (el_div, complex_matrix, matrix, complex_array, array, quotient)
 DEFNDBINOP_FN (el_pow, complex_matrix, matrix, complex_array, array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return quotient (v2.array_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, matrix, complex_array, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, matrix, complex_array, array, mx_el_or)
 
@@ -138,8 +142,9 @@ install_cm_m_ops (void)
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_matrix, el_or);
   INSTALL_BINOP (op_mul_trans, octave_complex_matrix, octave_matrix, mul_trans);
   INSTALL_BINOP (op_mul_herm, octave_complex_matrix, octave_matrix, mul_trans);
 
   INSTALL_CATOP (octave_complex_matrix, octave_matrix, cm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_matrix, assign);
 }
+
diff --git a/libinterp/operators/op-cm-pm.cc b/libinterp/operators/op-cm-pm.cc
--- a/libinterp/operators/op-cm-pm.cc
+++ b/libinterp/operators/op-cm-pm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX perm_matrix
 
 #define LSHORT cm
 #define RSHORT pm
 
 #define RIGHT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -41,32 +41,34 @@ along with Octave; see the file COPYING.
 // complex matrix by scalar ops.
 
 DEFNDBINOP_OP (add, complex_matrix, scalar, complex_array, scalar, +)
 DEFNDBINOP_OP (sub, complex_matrix, scalar, complex_array, scalar, -)
 DEFNDBINOP_OP (mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (div, complex_matrix, scalar)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
 DEFBINOP (ldiv, complex_matrix, scalar)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
 
@@ -80,32 +82,34 @@ DEFNDCMPLXCMPOP_FN (eq, complex_matrix, 
 DEFNDCMPLXCMPOP_FN (ge, complex_matrix, scalar, complex_array, scalar, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, complex_matrix, scalar, complex_array, scalar, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, scalar, complex_array, scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (el_div, complex_matrix, scalar)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, scalar, complex_array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, scalar)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return x_el_div (v2.double_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, scalar, complex_array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, scalar, complex_array, scalar, mx_el_or)
 
@@ -142,8 +146,9 @@ install_cm_s_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_scalar, assign);
 
   INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_scalar,
                     assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_scalar,
                     assign_div);
 }
+
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -43,18 +43,20 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -74,18 +76,20 @@ DEFBINOP (div, complex_matrix, sparse_co
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -100,49 +104,55 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_complex_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
                      v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cm_scm, complex_matrix, sparse_complex_matrix)
 {
   octave_complex_matrix& v1 = dynamic_cast<octave_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex_matrix,
          sparse_complex_matrix)
 {
-  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
+  const octave_complex_matrix& v
+    = dynamic_cast<const octave_complex_matrix&> (a);
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix,
                   complex_array, assign)
 
 void
@@ -195,8 +205,9 @@ install_cm_scm_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_sparse_complex_matrix, assign)
   INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -43,18 +43,20 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -74,18 +76,20 @@ DEFBINOP (div, complex_matrix, sparse_ma
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -97,39 +101,44 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
                      v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
-  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_matrix& v1
+    = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
   return octave_value
          (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (cm_sm, complex_matrix, sparse_matrix)
 {
   octave_complex_matrix& v1 = dynamic_cast<octave_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_matrix, complex_array, assign)
 
 void
 install_cm_sm_ops (void)
@@ -162,8 +171,9 @@ install_cm_sm_ops (void)
   INSTALL_CATOP (octave_complex_matrix, octave_sparse_matrix, cm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_sparse_matrix,
                     assign);
   INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_matrix,
                       octave_complex_matrix)
 
 }
+
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -38,34 +38,36 @@ along with Octave; see the file COPYING.
 
 DEFNDBINOP_OP (add, complex, complex_matrix, complex, complex_array, +)
 DEFNDBINOP_OP (sub, complex, complex_matrix, complex, complex_array, -)
 DEFNDBINOP_OP (mul, complex, complex_matrix, complex, complex_array, *)
 
 DEFBINOP (div, complex, complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, complex, complex_matrix, xpow)
 
 DEFBINOP (ldiv, complex, complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
@@ -87,17 +89,18 @@ DEFNDBINOP_OP (el_mul, complex, complex_
 DEFNDBINOP_FN (el_div, complex, complex_matrix, complex, complex_array,
                x_el_div)
 DEFNDBINOP_FN (el_pow, complex, complex_matrix, complex, complex_array,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex, complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -189,8 +189,9 @@ install_cs_cs_ops (void)
   INSTALL_ASSIGNCONV (octave_complex, octave_complex, octave_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_null_matrix,
                       octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_str, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_sq_str,
                       octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-cs-m.cc b/libinterp/operators/op-cs-m.cc
--- a/libinterp/operators/op-cs-m.cc
+++ b/libinterp/operators/op-cs-m.cc
@@ -126,8 +126,9 @@ install_cs_m_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_matrix, el_or);
 
   INSTALL_CATOP (octave_complex, octave_matrix, cs_m);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_matrix, octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-cs-s.cc b/libinterp/operators/op-cs-s.cc
--- a/libinterp/operators/op-cs-s.cc
+++ b/libinterp/operators/op-cs-s.cc
@@ -145,8 +145,9 @@ install_cs_s_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_complex, octave_scalar, cs_s);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_scalar, octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -42,17 +42,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -67,24 +68,26 @@ DEFBINOP (div, complex, sparse_complex_m
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.sparse_complex_matrix_value () / d);
 }
@@ -99,17 +102,18 @@ DEFBINOP_FN (ne, complex, sparse_complex
 DEFBINOP_OP (el_mul, complex, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, complex, sparse_complex_matrix, x_el_div)
 
 DEFBINOP_FN (el_pow, complex, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -118,17 +122,18 @@ DEFBINOP (el_ldiv, complex, sparse_compl
 }
 
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cs_scm, complex, sparse_complex_matrix)
 {
   octave_complex& v1 = dynamic_cast<octave_complex&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex, sparse_complex_matrix)
 {
   const octave_complex& v = dynamic_cast<const octave_complex&> (a);
@@ -169,8 +174,9 @@ install_cs_scm_ops (void)
   INSTALL_CATOP (octave_complex, octave_sparse_complex_matrix, cs_scm);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -164,8 +164,9 @@ install_cs_sm_ops (void)
 
   INSTALL_CATOP (octave_complex, octave_sparse_matrix, cs_sm);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_sparse_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_sparse_matrix, sparse_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-dm-dm.cc b/libinterp/operators/op-dm-dm.cc
--- a/libinterp/operators/op-dm-dm.cc
+++ b/libinterp/operators/op-dm-dm.cc
@@ -89,8 +89,9 @@ install_dm_dm_ops (void)
   INSTALL_BINOP (op_sub, octave_diag_matrix, octave_diag_matrix, sub);
   INSTALL_BINOP (op_mul, octave_diag_matrix, octave_diag_matrix, mul);
   INSTALL_BINOP (op_div, octave_diag_matrix, octave_diag_matrix, div);
   INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV (octave_diag_matrix, octave_matrix, octave_matrix);
   INSTALL_WIDENOP (octave_diag_matrix, octave_matrix, diag_matrix_to_matrix);
 }
+
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -46,17 +46,18 @@ along with Octave; see the file COPYING.
 
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
@@ -70,18 +71,20 @@ DEFBINOP (mul_dm_scm, diag_matrix, spars
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.scalar_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
@@ -95,18 +98,20 @@ DEFBINOP (mul_cdm_sm, complex_diag_matri
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
@@ -121,133 +126,148 @@ DEFBINOP (mul_cdm_scm, complex_diag_matr
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (ldiv_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (ldiv_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_matrix_value (),
                    typ);
 }
 
 DEFBINOP (ldiv_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_complex_diag_matrix& v1
+    = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
@@ -255,17 +275,18 @@ DEFBINOP (sub_cdm_scm, complex_diag_matr
   else
     return v1.complex_diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
@@ -280,18 +301,20 @@ DEFBINOP (mul_scm_dm, sparse_complex_mat
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
@@ -305,18 +328,20 @@ DEFBINOP (mul_sm_cdm, sparse_matrix, com
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
@@ -337,17 +362,18 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
@@ -359,18 +385,20 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -381,18 +409,20 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -403,103 +433,113 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + d);
     }
   else
     return v1.sparse_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + (-d));
     }
   else
     return v1.sparse_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
     return v1.sparse_complex_matrix_value () - v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2
+    = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
@@ -559,8 +599,9 @@ install_dm_scm_ops (void)
                  octave_complex_diag_matrix, add_scm_cdm);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_diag_matrix,
                  sub_scm_dm);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_complex_diag_matrix,
                  sub_sm_cdm);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix,
                  octave_complex_diag_matrix, sub_scm_cdm);
 }
+
diff --git a/libinterp/operators/op-dm-sm.cc b/libinterp/operators/op-dm-sm.cc
--- a/libinterp/operators/op-dm-sm.cc
+++ b/libinterp/operators/op-dm-sm.cc
@@ -197,8 +197,9 @@ install_dm_sm_ops (void)
 
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_diag_matrix,
                  mul_sm_dm);
 
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_diag_matrix, add_sm_dm);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_diag_matrix, sub_sm_dm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_diag_matrix, div_sm_dm);
 }
+
diff --git a/libinterp/operators/op-dm-template.cc b/libinterp/operators/op-dm-template.cc
--- a/libinterp/operators/op-dm-template.cc
+++ b/libinterp/operators/op-dm-template.cc
@@ -94,8 +94,9 @@ INST_NAME (void)
   INSTALL_BINOP (op_ldiv, OCTAVE_LMATRIX, OCTAVE_RMATRIX, ldiv);
 #endif
 #if defined (DEFINENULLASSIGNCONV)
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_matrix, OCTAVE_LDMATRIX);
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_str, OCTAVE_LDMATRIX);
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_sq_str, OCTAVE_LDMATRIX);
 #endif
 }
+
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -89,8 +89,9 @@ void
 INST_NAME (void)
 {
   INSTALL_BINOP (op_mul, OCTAVE_MATRIX, OCTAVE_SCALAR, dmsmul);
   INSTALL_BINOP (op_div, OCTAVE_MATRIX, OCTAVE_SCALAR, dmsdiv);
   INSTALL_BINOP (op_mul, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmmul);
   INSTALL_BINOP (op_ldiv, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmldiv);
   INSTALL_BINOP (op_pow, OCTAVE_MATRIX, OCTAVE_SCALAR, dmspow);
 }
+
diff --git a/libinterp/operators/op-fcdm-fcdm.cc b/libinterp/operators/op-fcdm-fcdm.cc
--- a/libinterp/operators/op-fcdm-fcdm.cc
+++ b/libinterp/operators/op-fcdm-fcdm.cc
@@ -37,53 +37,60 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_complex_diag_matrix, -)
 
 DEFUNOP (transpose, float_complex_diag_matrix)
 {
-  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
+  const octave_float_complex_diag_matrix& v
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
   return octave_value (v.float_complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_diag_matrix)
 {
-  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
+  const octave_float_complex_diag_matrix& v
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
   return octave_value (v.float_complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
 DEFBINOP (div, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  const octave_float_complex_diag_matrix& v1 = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
-  const octave_float_complex_diag_matrix& v2 = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
+  const octave_float_complex_diag_matrix& v1
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
+  const octave_float_complex_diag_matrix& v2
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
 
   return xdiv (v1.float_complex_diag_matrix_value (),
                v2.float_complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  const octave_float_complex_diag_matrix& v1 = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
-  const octave_float_complex_diag_matrix& v2 = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
+  const octave_float_complex_diag_matrix& v1
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
+  const octave_float_complex_diag_matrix& v2
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
 
   return xleftdiv (v1.float_complex_diag_matrix_value (),
                    v2.float_complex_diag_matrix_value ());
 }
 
 CONVDECL (float_complex_diag_matrix_to_complex_diag_matrix)
 {
-  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
+  const octave_float_complex_diag_matrix& v
+    = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
   return new octave_complex_diag_matrix (v.complex_diag_matrix_value ());
 }
 
 void
 install_fcdm_fcdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_complex_diag_matrix, uplus);
@@ -102,8 +109,9 @@ install_fcdm_fcdm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_float_complex_diag_matrix,
                  octave_float_complex_diag_matrix, ldiv);
 
   INSTALL_ASSIGNCONV (octave_float_complex_diag_matrix,
                       octave_float_complex_matrix, octave_float_complex_matrix);
   INSTALL_WIDENOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix,
                    float_complex_diag_matrix_to_complex_diag_matrix);
 }
+
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -38,27 +38,29 @@ along with Octave; see the file COPYING.
 // unary complex matrix ops.
 
 DEFNDUNOP_OP (not, float_complex_matrix, float_complex_array, !)
 DEFNDUNOP_OP (uplus, float_complex_matrix, float_complex_array, /* no-op */)
 DEFNDUNOP_OP (uminus, float_complex_matrix, float_complex_array, -)
 
 DEFUNOP (transpose, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v = dynamic_cast<const octave_float_complex_matrix&> (a);
+  const octave_float_complex_matrix& v
+    = dynamic_cast<const octave_float_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.float_complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v = dynamic_cast<const octave_float_complex_matrix&> (a);
+  const octave_float_complex_matrix& v
+    = dynamic_cast<const octave_float_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("complex-conjugate transpose not defined for N-D objects");
 
   return octave_value (v.float_complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
@@ -71,99 +73,115 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_complex_array, float_complex_array, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_complex_matrix, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -186,18 +204,20 @@ DEFNDBINOP_FN (el_mul, float_complex_mat
                float_complex_array, float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.float_complex_array_value (),
                                  v1.float_complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix,
@@ -322,8 +342,9 @@ install_fcm_fcm_ops (void)
                     octave_float_complex_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_div);
 }
+
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -42,33 +42,37 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_complex_array, float_complex, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex,
                float_complex_array, float_complex, -)
 DEFNDBINOP_OP (mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2
+    = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2
+    = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
@@ -87,34 +91,38 @@ DEFNDCMPLXCMPOP_FN (gt, float_complex_ma
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex,
                     float_complex_array, float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2
+    = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex,
                float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2
+    = dynamic_cast<const octave_float_complex&> (a2);
 
   return x_el_div (v2.float_complex_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_or)
@@ -189,8 +197,9 @@ install_fcm_fcs_ops (void)
                     octave_float_complex_scalar, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_div);
 }
+
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -47,48 +47,54 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_array, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_matrix, float_complex_array,
                float_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_matrix, *)
 
 DEFBINOP (mul_trans, float_complex_matrix, float_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2
+    = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
 
   return FloatComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                              xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, float_complex_matrix, float_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2
+    = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2
+    = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -110,18 +116,20 @@ DEFNDBINOP_FN (el_mul, float_complex_mat
                float_complex_array, float_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix,
                float_complex_array, float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix,
                float_complex_array, float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_matrix)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2
+    = dynamic_cast<const octave_float_matrix&> (a2);
 
   return quotient (v2.float_array_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_or)
@@ -177,8 +185,9 @@ install_fcm_fm_ops (void)
   INSTALL_CATOP (octave_complex_matrix, octave_float_matrix, cm_fm);
   INSTALL_CATOP (octave_float_complex_matrix, octave_matrix, fcm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_float_matrix, dbl_assign);
 }
+
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -45,33 +45,37 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_scalar, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, -)
 DEFNDBINOP_OP (mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (div, float_complex_matrix, float)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2
+    = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2
+    = dynamic_cast<const octave_float_scalar&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -91,34 +95,38 @@ DEFNDCMPLXCMPOP_FN (gt, float_complex_ma
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array,
                     float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2
+    = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
-  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
-  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
+  const octave_float_complex_matrix& v1
+    = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2
+    = dynamic_cast<const octave_float_scalar&> (a2);
 
   return x_el_div (v2.float_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_or)
@@ -180,8 +188,9 @@ install_fcm_fs_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_float_scalar, dbl_assign);
 
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_div);
 }
+
diff --git a/libinterp/operators/op-fcm-pm.cc b/libinterp/operators/op-fcm-pm.cc
--- a/libinterp/operators/op-fcm-pm.cc
+++ b/libinterp/operators/op-fcm-pm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX perm_matrix
 
 #define LSHORT fcm
 #define RSHORT pm
 
 #define RIGHT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-fcn.cc b/libinterp/operators/op-fcn.cc
--- a/libinterp/operators/op-fcn.cc
+++ b/libinterp/operators/op-fcn.cc
@@ -49,8 +49,9 @@ DEFBINOP (ne, fcn_handle, fcn_handle)
 }
 
 void
 install_fcn_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_fcn_handle, octave_fcn_handle, eq);
   INSTALL_BINOP (op_ne, octave_fcn_handle, octave_fcn_handle, ne);
 }
+
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -42,35 +42,39 @@ DEFNDBINOP_OP (add, float_complex, float
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_complex, float_complex_matrix, float_complex,
                float_complex_array, -)
 DEFNDBINOP_OP (mul, float_complex, float_complex_matrix, float_complex,
                float_complex_array, *)
 
 DEFBINOP (div, float_complex, float_complex_matrix)
 {
-  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex& v1
+    = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex_matrix)
 {
-  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex& v1
+    = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -92,18 +96,20 @@ DEFNDBINOP_OP (el_mul, float_complex, fl
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
-  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_complex& v1
+    = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -119,17 +125,18 @@ DEFNDCATOP_FN (fcs_fcm, float_complex, f
 DEFNDCATOP_FN (cs_fcm, complex, float_complex_matrix, float_complex_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (fcs_cm, float_complex, complex_matrix, float_complex_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_complex, float_complex_matrix)
 {
-  const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
+  const octave_float_complex& v
+    = dynamic_cast<const octave_float_complex&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 void
 install_fcs_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_complex_matrix,
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -204,8 +204,9 @@ install_fcs_fcs_ops (void)
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_matrix,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_str,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_sq_str,
                       octave_float_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -151,8 +151,9 @@ install_fcs_fm_ops (void)
   INSTALL_CATOP (octave_complex, octave_float_matrix, cs_fm);
   INSTALL_CATOP (octave_float_complex, octave_matrix, fcs_m);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_matrix,
                       octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -161,8 +161,9 @@ install_fcs_fs_ops (void)
   INSTALL_CATOP (octave_complex, octave_float_scalar, cs_fs);
   INSTALL_CATOP (octave_float_complex, octave_scalar, fcs_s);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_float_scalar,
                       octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-fdm-fdm.cc b/libinterp/operators/op-fdm-fdm.cc
--- a/libinterp/operators/op-fdm-fdm.cc
+++ b/libinterp/operators/op-fdm-fdm.cc
@@ -37,47 +37,53 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_diag_matrix, -)
 
 DEFUNOP (transpose, float_diag_matrix)
 {
-  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
+  const octave_float_diag_matrix& v
+    = dynamic_cast<const octave_float_diag_matrix&> (a);
   return octave_value (v.float_diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
 DEFBINOP (div, float_diag_matrix, float_diag_matrix)
 {
-  const octave_float_diag_matrix& v1 = dynamic_cast<const octave_float_diag_matrix&> (a1);
-  const octave_float_diag_matrix& v2 = dynamic_cast<const octave_float_diag_matrix&> (a2);
+  const octave_float_diag_matrix& v1
+    = dynamic_cast<const octave_float_diag_matrix&> (a1);
+  const octave_float_diag_matrix& v2
+    = dynamic_cast<const octave_float_diag_matrix&> (a2);
 
   return xdiv (v1.float_diag_matrix_value (),
                v2.float_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_diag_matrix, float_diag_matrix)
 {
-  const octave_float_diag_matrix& v1 = dynamic_cast<const octave_float_diag_matrix&> (a1);
-  const octave_float_diag_matrix& v2 = dynamic_cast<const octave_float_diag_matrix&> (a2);
+  const octave_float_diag_matrix& v1
+    = dynamic_cast<const octave_float_diag_matrix&> (a1);
+  const octave_float_diag_matrix& v2
+    = dynamic_cast<const octave_float_diag_matrix&> (a2);
 
   return xleftdiv (v1.float_diag_matrix_value (),
                    v2.float_diag_matrix_value ());
 }
 
 CONVDECL (float_diag_matrix_to_float_matrix)
 {
-  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
+  const octave_float_diag_matrix& v
+    = dynamic_cast<const octave_float_diag_matrix&> (a);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 void
 install_fdm_fdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_diag_matrix, uplus);
@@ -96,8 +102,9 @@ install_fdm_fdm_ops (void)
   INSTALL_BINOP (op_ldiv, octave_float_diag_matrix, octave_float_diag_matrix,
                  ldiv);
 
   INSTALL_ASSIGNCONV (octave_float_diag_matrix, octave_float_matrix,
                       octave_float_matrix);
   INSTALL_WIDENOP (octave_float_diag_matrix, octave_float_matrix,
                    float_diag_matrix_to_float_matrix);
 }
+
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -47,61 +47,69 @@ DEFNDBINOP_OP (add, float_matrix, float_
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array,
                float_complex_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_complex_matrix, *)
 
 DEFBINOP (trans_mul, float_matrix, float_complex_matrix)
 {
-  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_matrix& v1
+    = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
 
   return FloatComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                              xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, float_matrix, float_complex_matrix)
 {
-  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_matrix& v1
+    = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_matrix_value (),
                                  v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
-  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_matrix& v1
+    = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_complex_matrix)
 {
-  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_matrix& v1
+    = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -124,18 +132,20 @@ DEFNDBINOP_FN (el_mul, float_matrix, flo
                float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array,
                float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_complex_matrix)
 {
-  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_matrix& v1
+    = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   return quotient (v2.float_complex_array_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_or)
@@ -201,8 +211,9 @@ install_fm_fcm_ops (void)
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex_matrix,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_matrix, octave_float_complex_matrix,
                    float_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -160,8 +160,9 @@ install_fm_fcs_ops (void)
   INSTALL_CATOP (octave_matrix, octave_float_complex, m_fcs);
   INSTALL_CATOP (octave_float_matrix, octave_complex, fm_cs);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex,
                       octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -258,8 +258,9 @@ install_fm_fm_ops (void)
                     assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix,
                     assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_matrix, octave_float_matrix,
                     assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_float_matrix, octave_float_matrix,
                     assign_el_div);
 }
+
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -164,8 +164,9 @@ install_fm_fs_ops (void)
                     assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_scalar,
                     assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_matrix, octave_float_scalar,
                     assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_matrix, octave_float_scalar,
                     assign_div);
 }
+
diff --git a/libinterp/operators/op-fm-pm.cc b/libinterp/operators/op-fm-pm.cc
--- a/libinterp/operators/op-fm-pm.cc
+++ b/libinterp/operators/op-fm-pm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX perm_matrix
 
 #define LSHORT fm
 #define RSHORT pm
 
 #define RIGHT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -48,35 +48,39 @@ DEFNDBINOP_OP (add, float_scalar, float_
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, -)
 DEFNDBINOP_OP (mul, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, *)
 
 DEFBINOP (div, float_scalar, float_complex_matrix)
 {
-  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_scalar& v1
+    = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
-  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_scalar& v1
+    = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -98,18 +102,20 @@ DEFNDBINOP_OP (el_mul, float_scalar, flo
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
-  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
-  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
+  const octave_float_scalar& v1
+    = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2
+    = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -172,8 +178,9 @@ install_fs_fcm_ops (void)
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex_matrix,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_complex_matrix,
                    float_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -163,8 +163,9 @@ install_fs_fcs_ops (void)
   INSTALL_CATOP (octave_scalar, octave_float_complex, s_fcs);
   INSTALL_CATOP (octave_float_scalar, octave_complex, fs_cs);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex,
                       octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex,
                       octave_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -151,8 +151,9 @@ install_fs_fm_ops (void)
   INSTALL_CATOP (octave_float_scalar, octave_matrix, fs_m);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_matrix,
                       octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_matrix, octave_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_matrix, matrix_conv);
 }
+
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -178,8 +178,9 @@ install_fs_fs_ops (void)
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_matrix,
                       octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_str,
                       octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_sq_str,
                       octave_float_matrix);
 }
+
diff --git a/libinterp/operators/op-i16-i16.cc b/libinterp/operators/op-i16-i16.cc
--- a/libinterp/operators/op-i16-i16.cc
+++ b/libinterp/operators/op-i16-i16.cc
@@ -151,8 +151,9 @@ install_i16_i16_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int16, uint64);
 }
+
diff --git a/libinterp/operators/op-i32-i32.cc b/libinterp/operators/op-i32-i32.cc
--- a/libinterp/operators/op-i32-i32.cc
+++ b/libinterp/operators/op-i32-i32.cc
@@ -151,8 +151,9 @@ install_i32_i32_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int32, uint64);
 }
+
diff --git a/libinterp/operators/op-i64-i64.cc b/libinterp/operators/op-i64-i64.cc
--- a/libinterp/operators/op-i64-i64.cc
+++ b/libinterp/operators/op-i64-i64.cc
@@ -151,8 +151,9 @@ install_i64_i64_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int64, uint64);
 }
+
diff --git a/libinterp/operators/op-i8-i8.cc b/libinterp/operators/op-i8-i8.cc
--- a/libinterp/operators/op-i8-i8.cc
+++ b/libinterp/operators/op-i8-i8.cc
@@ -151,8 +151,9 @@ install_i8_i8_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (int8, uint64);
 }
+
diff --git a/libinterp/operators/op-int-concat.cc b/libinterp/operators/op-int-concat.cc
--- a/libinterp/operators/op-int-concat.cc
+++ b/libinterp/operators/op-int-concat.cc
@@ -311,8 +311,9 @@ install_int_concat_ops (void)
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int32);
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int64);
 
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint8);
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint16);
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint32);
   OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint64);
 }
+
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -1189,8 +1189,9 @@ along with Octave; see the file COPYING.
 
 #define OCTAVE_INSTALL_MIXED_INT_CMP_OPS(T1, T2)                        \
   OCTAVE_INSTALL_SS_INT_CMP_OPS (T1 ## _ ## T2 ## _ss, T1 ## _, T2 ## _) \
   OCTAVE_INSTALL_SM_INT_CMP_OPS (T1 ## _ ## T2 ## _sm, T1 ## _, T2 ## _) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (T1 ## _ ## T2 ## _ms, T1 ## _, T2 ## _) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (T1 ## _ ## T2 ## _mm, T1 ## _, T2 ## _)
 
 #endif
+
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -46,29 +46,31 @@ along with Octave; see the file COPYING.
 DEFNDBINOP_OP (add, matrix, complex_matrix, array, complex_array, +)
 DEFNDBINOP_OP (sub, matrix, complex_matrix, array, complex_array, -)
 
 DEFBINOP_OP (mul, matrix, complex_matrix, *)
 
 DEFBINOP (trans_mul, matrix, complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
 
   return ComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                         xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, matrix, complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
@@ -76,30 +78,32 @@ DEFBINOP (div, matrix, complex_matrix)
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, matrix, complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -113,17 +117,18 @@ DEFNDCMPLXCMPOP_FN (ne, matrix, complex_
 
 DEFNDBINOP_FN (el_mul, matrix, complex_matrix, array, complex_array, product)
 DEFNDBINOP_FN (el_div, matrix, complex_matrix, array, complex_array, quotient)
 DEFNDBINOP_FN (el_pow, matrix, complex_matrix, array, complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return quotient (v2.complex_array_value (), v1.array_value ());
 }
 
 DEFNDBINOP_FN (el_and, matrix, complex_matrix, array, complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  matrix, complex_matrix, array, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (m_cm, matrix, complex_matrix, array, complex_array, concat)
@@ -167,8 +172,9 @@ install_m_cm_ops (void)
 
   INSTALL_ASSIGNCONV (octave_matrix, octave_complex_matrix,
                       octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex_matrix,
                       octave_float_complex_matrix);
 
   INSTALL_WIDENOP (octave_matrix, octave_complex_matrix, complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -138,8 +138,9 @@ install_m_cs_ops (void)
   INSTALL_BINOP (op_el_or, octave_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_matrix, octave_complex, m_cs);
 
   INSTALL_ASSIGNCONV (octave_matrix, octave_complex, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex,
                       octave_float_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -209,8 +209,9 @@ install_m_m_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_matrix, octave_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_matrix, octave_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_matrix, octave_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_matrix, octave_matrix, assign_el_div);
 }
+
diff --git a/libinterp/operators/op-m-pm.cc b/libinterp/operators/op-m-pm.cc
--- a/libinterp/operators/op-m-pm.cc
+++ b/libinterp/operators/op-m-pm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX perm_matrix
 
 #define LSHORT m
 #define RSHORT pm
 
 #define RIGHT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -154,8 +154,9 @@ install_m_s_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_scalar,
                     clx_sgl_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_matrix, octave_scalar, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_matrix, octave_scalar, assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_matrix, octave_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_matrix, octave_scalar, assign_div);
 }
+
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -45,17 +45,18 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -76,17 +77,18 @@ DEFBINOP (div, matrix, sparse_complex_ma
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -99,38 +101,41 @@ DEFBINOP_FN (gt, matrix, sparse_complex_
 DEFBINOP_FN (ne, matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseMatrix (v1.matrix_value ()),
                      v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return octave_value
          (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (m_scm, matrix, sparse_complex_matrix)
 {
   octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
@@ -169,8 +174,9 @@ install_m_scm_ops (void)
   INSTALL_CATOP (octave_matrix, octave_sparse_complex_matrix, m_scm);
 
   INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -164,8 +164,9 @@ install_m_sm_ops (void)
   INSTALL_CATOP (octave_matrix, octave_sparse_matrix, m_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_sparse_matrix, assign)
   INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_matrix, octave_matrix)
 
   INSTALL_WIDENOP (octave_matrix, octave_sparse_matrix,
                    sparse_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-pm-cm.cc b/libinterp/operators/op-pm-cm.cc
--- a/libinterp/operators/op-pm-cm.cc
+++ b/libinterp/operators/op-pm-cm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX complex_matrix
 
 #define LSHORT pm
 #define RSHORT cm
 
 #define LEFT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-pm-fcm.cc b/libinterp/operators/op-pm-fcm.cc
--- a/libinterp/operators/op-pm-fcm.cc
+++ b/libinterp/operators/op-pm-fcm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX float_complex_matrix
 
 #define LSHORT pm
 #define RSHORT fcm
 
 #define LEFT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-pm-fm.cc b/libinterp/operators/op-pm-fm.cc
--- a/libinterp/operators/op-pm-fm.cc
+++ b/libinterp/operators/op-pm-fm.cc
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 #define RMATRIX float_matrix
 
 #define LSHORT pm
 #define RSHORT fm
 
 #define LEFT
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-pm-m.cc b/libinterp/operators/op-pm-m.cc
--- a/libinterp/operators/op-pm-m.cc
+++ b/libinterp/operators/op-pm-m.cc
@@ -28,8 +28,9 @@ along with Octave; see the file COPYING.
 
 #define LSHORT pm
 #define RSHORT m
 
 #define LEFT
 #define DEFINENULLASSIGNCONV
 
 #include "op-pm-template.cc"
+
diff --git a/libinterp/operators/op-pm-pm.cc b/libinterp/operators/op-pm-pm.cc
--- a/libinterp/operators/op-pm-pm.cc
+++ b/libinterp/operators/op-pm-pm.cc
@@ -82,8 +82,9 @@ install_pm_pm_ops (void)
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_perm_matrix, mul);
   INSTALL_BINOP (op_div, octave_perm_matrix, octave_perm_matrix, div);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_perm_matrix, ldiv);
   INSTALL_BINOP (op_pow, octave_perm_matrix, octave_scalar, pow);
 
   INSTALL_ASSIGNCONV (octave_perm_matrix, octave_matrix, octave_matrix);
   INSTALL_WIDENOP (octave_perm_matrix, octave_matrix, perm_matrix_to_matrix);
 }
+
diff --git a/libinterp/operators/op-pm-scm.cc b/libinterp/operators/op-pm-scm.cc
--- a/libinterp/operators/op-pm-scm.cc
+++ b/libinterp/operators/op-pm-scm.cc
@@ -33,60 +33,64 @@ along with Octave; see the file COPYING.
 #include "ov-perm.h"
 #include "ov-cx-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
   else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_complex_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return v1.perm_matrix_value ().inverse () * v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       std::complex<double> d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
   else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_complex_matrix_value ());
   else
     return v1.sparse_complex_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   return v1.sparse_complex_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_scm_ops (void)
 {
@@ -94,8 +98,9 @@ install_pm_scm_ops (void)
                  mul_pm_scm);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_sparse_complex_matrix,
                  ldiv_pm_scm);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_perm_matrix,
                  mul_scm_pm);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_perm_matrix,
                  div_scm_pm);
 }
+
diff --git a/libinterp/operators/op-pm-sm.cc b/libinterp/operators/op-pm-sm.cc
--- a/libinterp/operators/op-pm-sm.cc
+++ b/libinterp/operators/op-pm-sm.cc
@@ -94,8 +94,9 @@ install_pm_sm_ops (void)
                  mul_pm_sm);
   INSTALL_BINOP (op_ldiv, octave_perm_matrix, octave_sparse_matrix,
                  ldiv_pm_sm);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_perm_matrix,
                  mul_sm_pm);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_perm_matrix,
                  div_sm_pm);
 }
+
diff --git a/libinterp/operators/op-pm-template.cc b/libinterp/operators/op-pm-template.cc
--- a/libinterp/operators/op-pm-template.cc
+++ b/libinterp/operators/op-pm-template.cc
@@ -89,8 +89,9 @@ INST_NAME (void)
   INSTALL_BINOP (op_div, OCTAVE_LMATRIX, OCTAVE_RMATRIX, div);
 #endif
 #if defined (DEFINENULLASSIGNCONV)
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_matrix, OCTAVE_LDMATRIX);
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_str, OCTAVE_LDMATRIX);
   INSTALL_ASSIGNCONV (OCTAVE_LMATRIX, octave_null_sq_str, OCTAVE_LDMATRIX);
 #endif
 }
+
diff --git a/libinterp/operators/op-range.cc b/libinterp/operators/op-range.cc
--- a/libinterp/operators/op-range.cc
+++ b/libinterp/operators/op-range.cc
@@ -135,8 +135,9 @@ install_range_ops (void)
   INSTALL_ASSIGNCONV (octave_range, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_sq_str, octave_matrix);
 
   // However, this should probably be here just in case we need it.
 
   INSTALL_WIDENOP (octave_range, octave_matrix, range_to_matrix);
 }
+
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -46,34 +46,36 @@ along with Octave; see the file COPYING.
 
 DEFNDBINOP_OP (add, scalar, complex_matrix, scalar, complex_array, +)
 DEFNDBINOP_OP (sub, scalar, complex_matrix, scalar, complex_array, -)
 DEFNDBINOP_OP (mul, scalar, complex_matrix, scalar, complex_array, *)
 
 DEFBINOP (div, scalar, complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, scalar, complex_matrix, xpow)
 
 DEFBINOP (ldiv, scalar, complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
@@ -87,17 +89,18 @@ DEFNDCMPLXCMPOP_FN (ne, scalar, complex_
 
 DEFNDBINOP_OP (el_mul, scalar, complex_matrix, scalar, complex_array, *)
 DEFNDBINOP_FN (el_div, scalar, complex_matrix, scalar, complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, scalar, complex_matrix, scalar, complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -149,8 +149,9 @@ install_s_cs_ops (void)
   INSTALL_BINOP (op_el_or, octave_scalar, octave_complex, el_or);
 
   INSTALL_CATOP (octave_scalar, octave_complex, s_cs);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_complex, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_complex,
                       octave_float_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-s-m.cc b/libinterp/operators/op-s-m.cc
--- a/libinterp/operators/op-s-m.cc
+++ b/libinterp/operators/op-s-m.cc
@@ -132,8 +132,9 @@ install_s_m_ops (void)
 
   INSTALL_CATOP (octave_scalar, octave_matrix, s_m);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_matrix, octave_float_matrix);
 
   INSTALL_WIDENOP (octave_scalar, octave_matrix, matrix_conv);
 }
+
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -170,8 +170,9 @@ install_s_s_ops (void)
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_scalar, octave_matrix);
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_scalar, octave_float_matrix);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_null_sq_str, octave_matrix);
 }
+
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -45,17 +45,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -70,24 +71,26 @@ DEFBINOP (div, scalar, sparse_complex_ma
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -104,17 +107,18 @@ DEFBINOP_FN (ne, scalar, sparse_complex_
 
 DEFBINOP_OP (el_mul, scalar, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, scalar, sparse_complex_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -123,17 +127,18 @@ DEFBINOP (el_ldiv, scalar, sparse_comple
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (s_scm, scalar, sparse_compelx_matrix)
 {
   octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value
          (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
@@ -173,8 +178,9 @@ install_s_scm_ops (void)
   INSTALL_CATOP (octave_scalar, octave_sparse_complex_matrix, s_scm);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_scalar, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-s-sm.cc b/libinterp/operators/op-s-sm.cc
--- a/libinterp/operators/op-s-sm.cc
+++ b/libinterp/operators/op-s-sm.cc
@@ -159,8 +159,9 @@ install_s_sm_ops (void)
   INSTALL_BINOP (op_el_or, octave_scalar, octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_scalar, octave_sparse_matrix, s_sm);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_sparse_matrix, octave_matrix);
 
   INSTALL_WIDENOP (octave_scalar, octave_sparse_matrix, sparse_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -137,8 +137,9 @@ install_sbm_b_ops (void)
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_uint16_scalar,
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_uint32_scalar,
                     conv_and_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_uint64_scalar,
                     conv_and_assign);
 }
+
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -163,8 +163,9 @@ install_sbm_bm_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_null_matrix,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_null_str,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, octave_null_sq_str,
                     null_assign);
 }
+
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -37,29 +37,32 @@ along with Octave; see the file COPYING.
 #include "ov-bool-sparse.h"
 
 // unary sparse bool matrix ops.
 
 DEFUNOP_OP (not, sparse_bool_matrix, !)
 
 DEFUNOP (uplus, sparse_bool_matrix)
 {
-  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
+  const octave_sparse_bool_matrix& v
+    = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (v.sparse_matrix_value ());
 }
 
 DEFUNOP (uminus, sparse_bool_matrix)
 {
-  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
+  const octave_sparse_bool_matrix& v
+    = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (- v.sparse_matrix_value ());
 }
 
 DEFUNOP (transpose, sparse_bool_matrix)
 {
-  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
+  const octave_sparse_bool_matrix& v
+    = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (v.sparse_bool_matrix_value ().transpose ());
 }
 
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
@@ -97,8 +100,9 @@ install_sbm_sbm_ops (void)
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_bool_matrix,
                  sbm_sbm);
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_matrix, sbm_sm);
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_bool_matrix, sm_sbm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix,
                     octave_sparse_bool_matrix, assign);
 }
+
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -43,36 +43,40 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -100,49 +104,57 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix
                      (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
          (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cm_ops (void)
@@ -189,8 +201,9 @@ install_scm_cm_ops (void)
                  octave_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix,
                  octave_complex_matrix, scm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_complex_matrix, assign);
 }
+
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -41,40 +41,43 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by complex scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
@@ -98,17 +101,18 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, complex)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
@@ -117,38 +121,41 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value
          (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
 
 DEFCATOP (scm_cs, sparse_complex_matrix, complex)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
          (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
@@ -180,8 +187,9 @@ install_scm_cs_ops (void)
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_complex,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_complex, scm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_complex,
                     assign);
 }
+
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -44,17 +44,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
@@ -62,17 +63,18 @@ DEFBINOP (div, sparse_complex_matrix, ma
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
@@ -98,48 +100,52 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix
                      (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value
          (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
 
 DEFCATOP (scm_m, sparse_complex_matrix, matrix)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value
          (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, matrix)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
@@ -170,8 +176,9 @@ install_scm_m_ops (void)
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_matrix, scm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_matrix,
                     assign);
 }
+
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -44,45 +44,48 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, scalar, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (div, sparse_complex_matrix, scalar)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double tmp = v2.scalar_value ();
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
@@ -106,17 +109,18 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, scalar)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
@@ -124,38 +128,41 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, scalar)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return octave_value
          (x_el_div (v2.double_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, scalar, mx_el_or)
 
 DEFCATOP (scm_s, sparse_complex_matrix, scalar)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
          (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, scalar)
 {
-  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  octave_sparse_complex_matrix& v1
+    = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
@@ -186,8 +193,9 @@ install_scm_s_ops (void)
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_scalar,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_scalar, scm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_scalar,
                     assign);
 }
+
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -49,57 +49,63 @@ along with Octave; see the file COPYING.
 // unary sparse complex matrix ops.
 
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
+  const octave_sparse_complex_matrix& v
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
   return octave_value
          (v.sparse_complex_matrix_value ().transpose (),
           v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
+  const octave_sparse_complex_matrix& v
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
   return octave_value
          (v.sparse_complex_matrix_value ().hermitian (),
           v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
+  const octave_sparse_complex_matrix& v
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
 
   return octave_value (v.complex_matrix_value () .increment ());
 }
 
 DEFUNOP (decr, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
+  const octave_sparse_complex_matrix& v
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
 
   return octave_value (v.complex_matrix_value () .decrement ());
 }
 #endif
 
 // complex matrix by complex matrix ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -118,18 +124,20 @@ DEFBINOP (div, sparse_complex_matrix, sp
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -156,18 +164,20 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_complex_matrix, mx_el_or)
 
@@ -236,8 +246,9 @@ install_scm_scm_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_sq_str, null_assign);
 }
+
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -42,18 +42,20 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -72,18 +74,20 @@ DEFBINOP (div, sparse_complex_matrix, sp
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -109,18 +113,20 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
-  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
+  const octave_sparse_complex_matrix& v1
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2
+    = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_matrix, mx_el_or)
 
@@ -168,8 +174,9 @@ install_scm_sm_ops (void)
   INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_sparse_matrix, scm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_sparse_matrix, assign);
 }
+
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -43,36 +43,40 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -97,47 +101,53 @@ DEFBINOP_FN (ge, sparse_matrix, complex_
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix
                      (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (sm_cm, sparse_matrix, complex_matrix)
 {
   octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
-  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
+  const octave_complex_matrix& v2
+    = dynamic_cast<const octave_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, sparse_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_matrix& v = dynamic_cast<const octave_sparse_matrix&> (a);
+  const octave_sparse_matrix& v
+    = dynamic_cast<const octave_sparse_matrix&> (a);
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_sm_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_complex_matrix, sub);
@@ -167,8 +177,9 @@ install_sm_cm_ops (void)
   INSTALL_CATOP (octave_sparse_matrix, octave_complex_matrix, sm_cm);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex_matrix,
                       octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP (octave_sparse_matrix, octave_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-sm-cs.cc b/libinterp/operators/op-sm-cs.cc
--- a/libinterp/operators/op-sm-cs.cc
+++ b/libinterp/operators/op-sm-cs.cc
@@ -164,8 +164,9 @@ install_sm_cs_ops (void)
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_complex, sm_cs);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex,
                       octave_sparse_complex_matrix);
 }
+
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -163,8 +163,9 @@ install_sm_m_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_matrix,  el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_matrix, sm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_matrix, assign);
 }
+
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -175,8 +175,9 @@ install_sm_s_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_scalar, sm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_scalar, assign);
 }
+
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -42,18 +42,20 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -72,18 +74,20 @@ DEFBINOP (div, sparse_matrix, sparse_com
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -110,31 +114,34 @@ DEFBINOP_FN (gt, sparse_matrix, sparse_c
 DEFBINOP_FN (ne, sparse_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
+  const octave_sparse_matrix& v1
+    = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2
+    = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP_FN (sm_scm, sparse_matrix, sparse_complex_matrix, concat)
 
 DEFCONV (sparse_complex_matrix_conv, sparse_matrix, sparse_complex_matrix)
 {
-  const octave_sparse_matrix& v = dynamic_cast<const octave_sparse_matrix&> (a);
+  const octave_sparse_matrix& v
+    = dynamic_cast<const octave_sparse_matrix&> (a);
   return new octave_sparse_complex_matrix (v.sparse_complex_matrix_value ());
 }
 
 void
 install_sm_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_sparse_complex_matrix,
                  add);
@@ -176,8 +183,9 @@ install_sm_scm_ops (void)
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_complex_matrix, sm_scm);
 
   INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_sparse_complex_matrix,
                       octave_sparse_complex_matrix);
 
   INSTALL_WIDENOP (octave_sparse_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
+
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -196,8 +196,9 @@ install_sm_sm_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_matrix,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_str,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_sq_str,
                     null_assign);
 }
+
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -58,8 +58,9 @@ install_str_m_ops (void)
                     assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_matrix, str_m);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_matrix, str_m);
 
   INSTALL_CATOP (octave_matrix, octave_char_matrix_str, m_str);
   INSTALL_CATOP (octave_matrix, octave_char_matrix_sq_str, m_str);
 }
+
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -58,8 +58,9 @@ install_str_s_ops (void)
                     assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_scalar, str_s);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_scalar, str_s);
 
   INSTALL_CATOP (octave_scalar, octave_char_matrix_str, s_str);
   INSTALL_CATOP (octave_scalar, octave_char_matrix_sq_str, s_str);
 }
+
diff --git a/libinterp/operators/op-str-str.cc b/libinterp/operators/op-str-str.cc
--- a/libinterp/operators/op-str-str.cc
+++ b/libinterp/operators/op-str-str.cc
@@ -31,17 +31,18 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 // string unary ops.
 
 DEFUNOP (transpose, char_matrix_str)
 {
-  const octave_char_matrix_str& v = dynamic_cast<const octave_char_matrix_str&> (a);
+  const octave_char_matrix_str& v
+    = dynamic_cast<const octave_char_matrix_str&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.char_matrix_value ().transpose (),
                        a.is_sq_string () ? '\'' : '"');
 }
 
@@ -92,17 +93,18 @@ DEFCHARNDBINOP_FN (ge, >=, char_matrix_s
 DEFCHARNDBINOP_FN (gt, >, char_matrix_str, char_matrix_str, char_array,
                    char_array, mx_el_gt)
 DEFCHARNDBINOP_FN (ne, !=, char_matrix_str, char_matrix_str, char_array,
                    char_array, mx_el_ne)
 
 DEFASSIGNOP (assign, char_matrix_str, char_matrix_str)
 {
   octave_char_matrix_str& v1 = dynamic_cast<octave_char_matrix_str&> (a1);
-  const octave_char_matrix_str& v2 = dynamic_cast<const octave_char_matrix_str&> (a2);
+  const octave_char_matrix_str& v2
+    = dynamic_cast<const octave_char_matrix_str&> (a2);
 
   v1.assign (idx, v2.char_array_value ());
   return octave_value ();
 }
 
 DEFNULLASSIGNOP_FN (null_assign, char_matrix_str, delete_elements)
 
 DEFNDCHARCATOP_FN (str_str, char_matrix_str, char_matrix_str, concat)
@@ -177,8 +179,9 @@ install_str_str_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_matrix,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_str,
                     null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_sq_str,
                     null_assign);
 
 }
+
diff --git a/libinterp/operators/op-struct.cc b/libinterp/operators/op-struct.cc
--- a/libinterp/operators/op-struct.cc
+++ b/libinterp/operators/op-struct.cc
@@ -100,8 +100,9 @@ install_struct_ops (void)
   INSTALL_CATOP (octave_struct, octave_struct, s_s_concat);
   INSTALL_CATOP (octave_struct, octave_scalar_struct, s_ss_concat)
   INSTALL_CATOP (octave_scalar_struct, octave_struct, ss_s_concat)
   INSTALL_CATOP (octave_scalar_struct, octave_scalar_struct, ss_ss_concat)
 
   INSTALL_CATOP (octave_struct, octave_matrix, struct_matrix);
   INSTALL_CATOP (octave_matrix, octave_struct, matrix_struct);
 }
+
diff --git a/libinterp/operators/op-ui16-ui16.cc b/libinterp/operators/op-ui16-ui16.cc
--- a/libinterp/operators/op-ui16-ui16.cc
+++ b/libinterp/operators/op-ui16-ui16.cc
@@ -151,8 +151,9 @@ install_ui16_ui16_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint16, uint64);
 }
+
diff --git a/libinterp/operators/op-ui32-ui32.cc b/libinterp/operators/op-ui32-ui32.cc
--- a/libinterp/operators/op-ui32-ui32.cc
+++ b/libinterp/operators/op-ui32-ui32.cc
@@ -150,8 +150,9 @@ install_ui32_ui32_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint32, uint64);
 }
+
diff --git a/libinterp/operators/op-ui64-ui64.cc b/libinterp/operators/op-ui64-ui64.cc
--- a/libinterp/operators/op-ui64-ui64.cc
+++ b/libinterp/operators/op-ui64-ui64.cc
@@ -151,8 +151,9 @@ install_ui64_ui64_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, uint8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint64, int64);
 }
+
diff --git a/libinterp/operators/op-ui8-ui8.cc b/libinterp/operators/op-ui8-ui8.cc
--- a/libinterp/operators/op-ui8-ui8.cc
+++ b/libinterp/operators/op-ui8-ui8.cc
@@ -151,8 +151,9 @@ install_ui8_ui8_ops (void)
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, int8);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, int16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, uint16);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, int32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, uint32);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, int64);
   OCTAVE_INSTALL_MIXED_INT_CMP_OPS (uint8, uint64);
 }
+
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -375,8 +375,9 @@ extern void install_ops (void);
   {                                                                     \
     CONCAT2 (octave_, t1)& v1 = dynamic_cast<CONCAT2 (octave_, t1)&> (a1); \
     const CONCAT2 (octave_, t2)& v2 = dynamic_cast<const CONCAT2 (octave_, t2)&> (a2); \
                                                                         \
     return octave_value (tc1 (v1.CONCAT2 (e1, _value) ()) . f (tc2 (v2.CONCAT2 (e2, _value) ()), ra_idx)); \
   }
 
 #endif
+
diff --git a/libinterp/options-usage.h b/libinterp/options-usage.h
--- a/libinterp/options-usage.h
+++ b/libinterp/options-usage.h
@@ -174,8 +174,9 @@ static void
 octave_print_version_and_exit (void)
 {
   std::cout << octave_name_version_copyright_copying_warranty_and_bugs ()
             << "\n";
   exit (0);
 }
 
 #endif
+
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -90,22 +90,22 @@ namespace octave
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
       enum bracket_type
-        {
-          BRACKET = 1,
-          BRACE = 2,
-          PAREN = 3,
-          ANON_FCN_BODY = 4
-        };
+      {
+        BRACKET = 1,
+        BRACE = 2,
+        PAREN = 3,
+        ANON_FCN_BODY = 4
+      };
 
     public:
 
       bbp_nesting_level (void) : context () { }
 
       bbp_nesting_level (const bbp_nesting_level& nl) : context (nl.context) { }
 
       bbp_nesting_level& operator = (const bbp_nesting_level& nl)
@@ -847,8 +847,9 @@ namespace octave
 
     push_lexer (const push_lexer&);
 
     push_lexer& operator = (const push_lexer&);
   };
 }
 
 #endif
+
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -523,8 +523,9 @@ namespace octave
 
     push_parser (const push_parser&);
 
     push_parser& operator = (const push_parser&);
   };
 }
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-all.h b/libinterp/parse-tree/pt-all.h
--- a/libinterp/parse-tree/pt-all.h
+++ b/libinterp/parse-tree/pt-all.h
@@ -51,8 +51,9 @@ along with Octave; see the file COPYING.
 #include "pt-pr-code.h"
 #include "pt-select.h"
 #include "pt-stmt.h"
 #include "pt-unop.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -343,8 +343,9 @@ tree_argument_list::dup (symbol_table::s
   return new_list;
 }
 
 void
 tree_argument_list::accept (tree_walker& tw)
 {
   tw.visit_argument_list (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -105,8 +105,9 @@ private:
   // No copying!
 
   tree_argument_list (const tree_argument_list&);
 
   tree_argument_list& operator = (const tree_argument_list&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -77,8 +77,9 @@ private:
   // No copying!
 
   tree_array_list (const tree_array_list&);
 
   tree_array_list& operator = (const tree_array_list&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -374,8 +374,9 @@ tree_multi_assignment::dup (symbol_table
   return new_ma;
 }
 
 void
 tree_multi_assignment::accept (tree_walker& tw)
 {
   tw.visit_multi_assignment (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -162,8 +162,9 @@ private:
   // No copying!
 
   tree_multi_assignment (const tree_multi_assignment&);
 
   tree_multi_assignment& operator = (const tree_multi_assignment&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -297,8 +297,9 @@ The original variable value is restored 
 %! if (1 | (x = 1))
 %! endif
 %! assert (x, 1);
 %! do_braindead_shortcircuit_evaluation (1);
 %! if (1 | (x = 0))
 %! endif
 %! assert (x, 1);
 */
+
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -178,8 +178,9 @@ private:
   // No copying!
 
   tree_boolean_expression (const tree_boolean_expression&);
 
   tree_boolean_expression& operator = (const tree_boolean_expression&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -503,8 +503,9 @@ tree_breakpoint::take_action (tree_state
         {
           bp_list.append (octave_value (lineno));
           bp_cond_list.append (octave_value (stmt.bp_cond ()));
         }
     }
   else
     panic_impossible ();
 }
+
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -175,8 +175,9 @@ private:
   tree_breakpoint& operator = (const tree_breakpoint&);
 };
 
 // TRUE means SIGINT should put us in the debugger at the next
 // available breakpoint.
 extern bool octave_debug_on_interrupt_state;
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -226,8 +226,9 @@ maybe_compound_binary_expression (tree_e
   tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
                                 ? new tree_binary_expression (a, b, l, c, t)
                                 : new tree_compound_binary_expression (a, b, l,
                                                                        c, t, ca,
                                                                        cb, ct);
 
   return ret;
 }
+
diff --git a/libinterp/parse-tree/pt-cbinop.h b/libinterp/parse-tree/pt-cbinop.h
--- a/libinterp/parse-tree/pt-cbinop.h
+++ b/libinterp/parse-tree/pt-cbinop.h
@@ -78,8 +78,9 @@ private:
 
 tree_binary_expression *
 maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
                                   int l = -1, int c = -1,
                                   octave_value::binary_op t
                                   = octave_value::unknown_binary_op);
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -107,8 +107,9 @@ tree_cell::dup (symbol_table::scope_id s
   return new_cell;
 }
 
 void
 tree_cell::accept (tree_walker& tw)
 {
   tw.visit_cell (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -67,8 +67,9 @@ private:
   // No copying!
 
   tree_cell (const tree_cell&);
 
   tree_cell& operator = (const tree_cell&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -171,17 +171,17 @@ tree_checker::visit_complex_for_command 
   tree_argument_list *lhs = cmd.left_hand_side ();
 
   if (lhs)
     {
       int len = lhs->length ();
 
       if (len == 0 || len > 2)
         errmsg ("invalid number of output arguments in for command",
-               cmd.line ());
+                cmd.line ());
 
       do_lvalue_check = true;
 
       lhs->accept (*this);
 
       do_lvalue_check = false;
     }
 
@@ -505,17 +505,17 @@ tree_checker::visit_try_catch_command (t
   tree_statement_list *try_code = cmd.body ();
 
   tree_identifier *expr_id = cmd.identifier ();
 
   if (expr_id)
     {
       if (! expr_id->lvalue_ok ())
         errmsg ("invalid lvalue used for identifier in try-catch command",
-               cmd.line ());
+                cmd.line ());
     }
 
   if (try_code)
     try_code->accept (*this);
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   if (catch_code)
@@ -567,8 +567,9 @@ tree_checker::visit_do_until_command (tr
 void
 tree_checker::errmsg (const std::string& msg, int line)
 {
   if (file_name.empty ())
     error ("%s", msg.c_str ());
   else
     error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
 }
+
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -138,8 +138,9 @@ private:
   // No copying!
 
   tree_checker (const tree_checker&);
 
   tree_checker& operator = (const tree_checker&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -251,8 +251,9 @@ tree_classdef::dup (symbol_table::scope_
   return 0;
 }
 
 void
 tree_classdef::accept (tree_walker& tw)
 {
   tw.visit_classdef (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -648,8 +648,9 @@ private:
   // No copying!
 
   tree_classdef (const tree_classdef&);
 
   tree_classdef& operator = (const tree_classdef&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-cmd.cc b/libinterp/parse-tree/pt-cmd.cc
--- a/libinterp/parse-tree/pt-cmd.cc
+++ b/libinterp/parse-tree/pt-cmd.cc
@@ -52,8 +52,9 @@ tree_function_def::dup (symbol_table::sc
   return new tree_function_def (fcn, line (), column ());
 }
 
 void
 tree_function_def::accept (tree_walker& tw)
 {
   tw.visit_function_def (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -127,8 +127,9 @@ private:
   // No copying!
 
   tree_function_def (const tree_function_def&);
 
   tree_function_def& operator = (const tree_function_def&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -165,8 +165,9 @@ tree_colon_expression::dup (symbol_table
   return new_ce;
 }
 
 void
 tree_colon_expression::accept (tree_walker& tw)
 {
   tw.visit_colon_expression (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -110,8 +110,9 @@ private:
   // No copying!
 
   tree_colon_expression (const tree_colon_expression&);
 
   tree_colon_expression& operator = (const tree_colon_expression&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -80,8 +80,9 @@ tree_constant::dup (symbol_table::scope_
   return new_tc;
 }
 
 void
 tree_constant::accept (tree_walker& tw)
 {
   tw.visit_constant (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -98,8 +98,9 @@ private:
 
   tree_constant (const tree_constant&);
 
   tree_constant& operator = (const tree_constant&);
 
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -138,8 +138,9 @@ tree_persistent_command::dup (symbol_tab
                                  line (), column ());
 }
 
 void
 tree_persistent_command::accept (tree_walker& tw)
 {
   tw.visit_persistent_command (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -238,8 +238,9 @@ private:
   // No copying!
 
   tree_persistent_command (const tree_persistent_command&);
 
   tree_persistent_command& operator = (const tree_persistent_command&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -63,17 +63,17 @@ namespace octave
 
   size_t tree_evaluator::current_frame = 0;
 
   bool tree_evaluator::debug_mode = false;
 
   bool tree_evaluator::quiet_breakpoint_flag = false;
 
   tree_evaluator::stmt_list_type tree_evaluator::statement_context
-  = tree_evaluator::other;
+    = tree_evaluator::other;
 
   bool tree_evaluator::in_loop_command = false;
 
   // Normal evaluator.
 
   void
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle&)
   {
@@ -811,17 +811,18 @@ namespace octave
       }
   }
 
   void
   tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
   {
     bool execution_error = false;
 
-    { // unwind frame before catch block
+    {
+      // unwind frame before catch block
       octave::unwind_protect frame;
 
       frame.protect_var (buffer_error_messages);
       frame.protect_var (Vdebug_on_error);
       frame.protect_var (Vdebug_on_warning);
 
       buffer_error_messages++;
       Vdebug_on_error = false;
@@ -1235,8 +1236,9 @@ The original variable value is restored 
 %! old_val = silent_functions (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (silent_functions (), ! orig_val);
 %! silent_functions (orig_val);
 %! assert (silent_functions (), orig_val);
 
 %!error (silent_functions (1, 2))
 */
+
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -198,8 +198,9 @@ namespace octave
   };
 }
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 extern int Vmax_recursion_depth;
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-except.cc b/libinterp/parse-tree/pt-except.cc
--- a/libinterp/parse-tree/pt-except.cc
+++ b/libinterp/parse-tree/pt-except.cc
@@ -96,8 +96,9 @@ tree_unwind_protect_command::dup (symbol
      line (), column ());
 }
 
 void
 tree_unwind_protect_command::accept (tree_walker& tw)
 {
   tw.visit_unwind_protect_command (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -158,8 +158,9 @@ private:
   // No copying!
 
   tree_unwind_protect_command (const tree_unwind_protect_command&);
 
   tree_unwind_protect_command& operator = (const tree_unwind_protect_command&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -74,8 +74,9 @@ tree_expression::lvalue (void)
   error ("invalid lvalue function called in expression");
 }
 
 std::string
 tree_expression::original_text (void) const
 {
   return "";
 }
+
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -162,8 +162,9 @@ private:
   // No copying!
 
   tree_expression (const tree_expression&);
 
   tree_expression& operator = (const tree_expression&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -214,8 +214,9 @@ tree_anon_fcn_handle::dup (symbol_table:
   return new_afh;
 }
 
 void
 tree_anon_fcn_handle::accept (tree_walker& tw)
 {
   tw.visit_anon_fcn_handle (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -151,8 +151,9 @@ private:
   // No copying!
 
   tree_anon_fcn_handle (const tree_anon_fcn_handle&);
 
   tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -103,8 +103,9 @@ tree_funcall::rvalue (int nargout)
           octave_value_list tmp_args;
 
           retval = val.do_multi_index_op (nargout, tmp_args);
         }
     }
 
   return retval;
 }
+
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -93,8 +93,9 @@ private:
   // No copying!
 
   tree_funcall (const tree_funcall&);
 
   tree_funcall& operator = (const tree_funcall&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -149,8 +149,9 @@ tree_identifier::dup (symbol_table::scop
   return new_id;
 }
 
 void
 tree_identifier::accept (tree_walker& tw)
 {
   tw.visit_identifier (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -166,8 +166,9 @@ public:
 
   octave_lvalue lvalue (void)
   {
     return octave_lvalue (); // black hole lvalue
   }
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -423,17 +423,17 @@ tree_index_expression::rvalue (int nargo
       p_dyn_field++;
     }
 
   try
     {
       retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
                             lvalue_list);
     }
-  catch (octave::index_exception& e)    // problems with range, invalid index type etc.
+  catch (octave::index_exception& e)  // range problems, bad index type, etc.
     {
       final_index_error (e, expr);
     }
 
   octave_value val = retval.length () ? retval(0) : octave_value ();
 
   if (val.is_function ())
     {
@@ -699,8 +699,9 @@ tree_index_expression::dup (symbol_table
   return new_idx_expr;
 }
 
 void
 tree_index_expression::accept (tree_walker& tw)
 {
   tw.visit_index_expression (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -127,8 +127,9 @@ private:
   // No copying!
 
   tree_index_expression (const tree_index_expression&);
 
   tree_index_expression& operator = (const tree_index_expression&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-jump.cc b/libinterp/parse-tree/pt-jump.cc
--- a/libinterp/parse-tree/pt-jump.cc
+++ b/libinterp/parse-tree/pt-jump.cc
@@ -80,8 +80,9 @@ tree_return_command::dup (symbol_table::
   return new tree_return_command (line (), column ());
 }
 
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-jump.h b/libinterp/parse-tree/pt-jump.h
--- a/libinterp/parse-tree/pt-jump.h
+++ b/libinterp/parse-tree/pt-jump.h
@@ -110,8 +110,9 @@ private:
   // No copying!
 
   tree_return_command (const tree_return_command&);
 
   tree_return_command& operator = (const tree_return_command&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-loop.cc b/libinterp/parse-tree/pt-loop.cc
--- a/libinterp/parse-tree/pt-loop.cc
+++ b/libinterp/parse-tree/pt-loop.cc
@@ -146,8 +146,9 @@ tree_complex_for_command::dup (symbol_ta
                                        line (), column ());
 }
 
 void
 tree_complex_for_command::accept (tree_walker& tw)
 {
   tw.visit_complex_for_command (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -323,8 +323,9 @@ private:
   // No copying!
 
   tree_complex_for_command (const tree_complex_for_command&);
 
   tree_complex_for_command& operator = (const tree_complex_for_command&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1386,8 +1386,9 @@ The original variable value is restored 
 %! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char (orig_val);
 %! assert (string_fill_char (), orig_val);
 
 %!assert ( [ [], {1} ], {1} )
 
 %!error (string_fill_char (1, 2))
 */
+
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -85,8 +85,9 @@ maybe_warn_string_concat (bool all_dq_st
 
 extern std::string
 get_concat_class (const std::string& c1, const std::string& c2);
 
 extern void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -350,8 +350,9 @@ tree_return_list::dup (symbol_table::sco
   return new_list;
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
   tw.visit_return_list (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -150,8 +150,9 @@ private:
   // No copying!
 
   tree_va_return_list (const tree_va_return_list&);
 
   tree_va_return_list& operator = (const tree_va_return_list&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -1335,8 +1335,9 @@ void
 tree_print_code::print_indented_comment (octave_comment_list *comment_list)
 {
   increment_indent_level ();
 
   print_comment_list (comment_list);
 
   decrement_indent_level ();
 }
+
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -193,8 +193,9 @@ private:
   // No copying!
 
   tree_print_code (const tree_print_code&);
 
   tree_print_code& operator = (const tree_print_code&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -206,8 +206,9 @@ tree_switch_command::dup (symbol_table::
                                   line (), column ());
 }
 
 void
 tree_switch_command::accept (tree_walker& tw)
 {
   tw.visit_switch_command (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -297,8 +297,9 @@ private:
   // No copying!
 
   tree_switch_command (const tree_switch_command&);
 
   tree_switch_command& operator = (const tree_switch_command&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -238,17 +238,17 @@ tree_statement_list::breakpoints_and_con
 
   std::list<bp_type> retval;
   octave_value_list lines = tbp.get_list ();
   octave_value_list conds = tbp.get_cond_list ();
 
   for (int i = 0; i < lines.length (); i++)
     {
       retval.push_back (bp_type (lines(i).double_value (),
-                                conds(i).string_value ()));
+                                 conds(i).string_value ()));
     }
 
   return retval;
 }
 
 // Add breakpoints to  file  at multiple lines (the second arguments of  line),
 // to stop only if  condition  is true.
 // Updates GUI via  octave_link::update_breakpoint.
@@ -320,8 +320,9 @@ tree_statement_list::dup (symbol_table::
   return new_list;
 }
 
 void
 tree_statement_list::accept (tree_walker& tw)
 {
   tw.visit_statement_list (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -195,8 +195,9 @@ private:
   // No copying!
 
   tree_statement_list (const tree_statement_list&);
 
   tree_statement_list& operator = (const tree_statement_list&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -77,17 +77,17 @@ tree_prefix_expression::rvalue1 (int)
           END_PROFILER_BLOCK
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
           if (val.is_defined ())
             {
-               BEGIN_PROFILER_BLOCK (tree_prefix_expression)
+              BEGIN_PROFILER_BLOCK (tree_prefix_expression)
 
               // Attempt to do the operation in-place if it is unshared
               // (a temporary expression).
               if (val.get_count () == 1)
                 retval = val.do_non_const_unary_op (etype);
               else
                 retval = ::do_unary_op (etype, val);
 
@@ -184,8 +184,9 @@ tree_postfix_expression::dup (symbol_tab
   return new_pe;
 }
 
 void
 tree_postfix_expression::accept (tree_walker& tw)
 {
   tw.visit_postfix_expression (*this);
 }
+
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -156,8 +156,9 @@ private:
   // No copying!
 
   tree_postfix_expression (const tree_postfix_expression&);
 
   tree_postfix_expression& operator = (const tree_postfix_expression&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt-walk.h b/libinterp/parse-tree/pt-walk.h
--- a/libinterp/parse-tree/pt-walk.h
+++ b/libinterp/parse-tree/pt-walk.h
@@ -279,8 +279,9 @@ private:
   // No copying!
 
   tree_walker (const tree_walker&);
 
   tree_walker& operator = (const tree_walker&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -77,23 +77,24 @@ tree::meets_bp_condition () const
       retval = true;                // default to stopping if any error
       try
         {
           octave_value_list val = eval_string (*bp, 1, parse_status, 1);
           if (parse_status == 0)
             {
               if (! val(0).is_scalar_type ())
                 warning ("Breakpoint condition must be a scalar, not size %s",
-                  val(0).dims ().str ('x').c_str ());
+                         val(0).dims ().str ('x').c_str ());
               else
                 retval = val(0).bool_value ();
             }
           else
             warning ("Error parsing breakpoint condition");
         }
       catch (const octave::execution_exception& e)
         {
           warning ("Error evaluating breakpoint condition:\n    %s",
                    last_error_message ().c_str ());
         }
     }
   return retval;
 }
+
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -56,33 +56,34 @@ public:
 
   void set_location (int l, int c)
   {
     line_num = l;
     column_num = c;
   }
 
   virtual void set_breakpoint (const std::string& condition)
-    { if (bp)
-        *bp = condition;
-      else
-        bp = new std::string(condition);
-    }
+  {
+    if (bp)
+      *bp = condition;
+    else
+      bp = new std::string(condition);
+  }
 
   virtual void delete_breakpoint (void) { if (bp) delete bp; bp = NULL; }
 
   bool meets_bp_condition (void) const;
 
   bool is_breakpoint (bool check_active = false) const
-    { return bp && (!check_active || meets_bp_condition ()); }
+  { return bp && (!check_active || meets_bp_condition ()); }
 
   // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
   // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
   const std::string bp_cond (void) const
-    { return bp ? *bp : std::string("0"); }
+  { return bp ? *bp : std::string("0"); }
 
   std::string str_print_code (void);
 
   virtual void accept (tree_walker& tw) = 0;
 
 private:
 
   // The input line and column where we found the text that was
@@ -96,8 +97,9 @@ private:
   // No copying!
 
   tree (const tree&);
 
   tree& operator = (const tree&);
 };
 
 #endif
+
diff --git a/libinterp/parse-tree/token.cc b/libinterp/parse-tree/token.cc
--- a/libinterp/parse-tree/token.cc
+++ b/libinterp/parse-tree/token.cc
@@ -188,8 +188,9 @@ token::superclass_class_name (void)
   return *sc.class_nm;
 }
 
 std::string
 token::text_rep (void)
 {
   return orig_text;
 }
+
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -135,8 +135,9 @@ private:
       std::string *method_nm;
       std::string *class_nm;
     } sc;
   };
   std::string orig_text;
 };
 
 #endif
+
diff --git a/libinterp/template-inst/Array-jit.cc b/libinterp/template-inst/Array-jit.cc
--- a/libinterp/template-inst/Array-jit.cc
+++ b/libinterp/template-inst/Array-jit.cc
@@ -44,8 +44,9 @@ NO_INSTANTIATE_ARRAY_SORT (jit_function)
 INSTANTIATE_ARRAY (jit_function, OCTINTERP_API);
 
 #if defined (Cell_h)
 #  error Must not include Cell.h in Array-jit.h
 #  error This causes problems on MSVC
 #endif
 
 #endif
+
diff --git a/libinterp/template-inst/Array-tc.cc b/libinterp/template-inst/Array-tc.cc
--- a/libinterp/template-inst/Array-tc.cc
+++ b/libinterp/template-inst/Array-tc.cc
@@ -47,8 +47,9 @@ extern template class OCTAVE_API Array<i
 extern template class OCTAVE_API Array<octave_idx_type>;
 extern template class OCTAVE_API Array<std::string>;
 
 NO_INSTANTIATE_ARRAY_SORT (octave_value);
 INSTANTIATE_ARRAY (octave_value, OCTINTERP_API);
 
 NO_INSTANTIATE_ARRAY_SORT (cdef_object);
 INSTANTIATE_ARRAY (cdef_object, OCTINTERP_API);
+
diff --git a/libinterp/version.cc b/libinterp/version.cc
--- a/libinterp/version.cc
+++ b/libinterp/version.cc
@@ -72,17 +72,17 @@ octave_name_version_and_copyright (void)
   // --version, the version number should follow the last space on the
   // line.
 
   return "GNU Octave, version " OCTAVE_VERSION "\n" OCTAVE_COPYRIGHT;
 }
 
 std::string
 octave_name_version_copyright_copying_and_warranty
- (bool html, const std::string& extra_info)
+  (bool html, const std::string& extra_info)
 {
   std::string br = html ? "<br>\n" : "\n";
   std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
 
   return octave_name_version_and_copyright ()
          + br
          + "This is free software; see the source code for copying conditions."
          + br
@@ -124,8 +124,9 @@ octave_startup_message (bool html)
   msg += (html ? "<p>\n" : "\n");
 
   msg += "For information about changes from previous versions, type 'news'.";
 
   msg += (html ? "\n</p>" : "");
 
   return msg;
 }
+
diff --git a/libinterp/version.in.h b/libinterp/version.in.h
--- a/libinterp/version.in.h
+++ b/libinterp/version.in.h
@@ -64,8 +64,9 @@ octave_name_version_copyright_copying_an
 
 extern OCTINTERP_API std::string
 octave_name_version_copyright_copying_warranty_and_bugs
   (bool html = false, const std::string& extra_info = "");
 
 extern OCTINTERP_API std::string octave_startup_message (bool html = false);
 
 #endif
+
